// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/api/v2/endpoint/endpoint_components.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { UInt32Value } from "../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../typeRegistry";
import { Address } from "../core/address";
import { Locality, Metadata } from "../core/base";
import { HealthStatus, healthStatusFromJSON, healthStatusToJSON, healthStatusToNumber } from "../core/health_check";

export const protobufPackage = "envoy.api.v2.endpoint";

/** Upstream host identifier. */
export interface Endpoint {
  $type: "envoy.api.v2.endpoint.Endpoint";
  /**
   * The upstream host address.
   *
   * .. attention::
   *
   *   The form of host address depends on the given cluster type. For STATIC or EDS,
   *   it is expected to be a direct IP address (or something resolvable by the
   *   specified :ref:`resolver <envoy_api_field_core.SocketAddress.resolver_name>`
   *   in the Address). For LOGICAL or STRICT DNS, it is expected to be hostname,
   *   and will be resolved via DNS.
   */
  address?:
    | Address
    | undefined;
  /**
   * The optional health check configuration is used as configuration for the
   * health checker to contact the health checked host.
   *
   * .. attention::
   *
   *   This takes into effect only for upstream clusters with
   *   :ref:`active health checking <arch_overview_health_checking>` enabled.
   */
  health_check_config?:
    | Endpoint_HealthCheckConfig
    | undefined;
  /**
   * The hostname associated with this endpoint. This hostname is not used for routing or address
   * resolution. If provided, it will be associated with the endpoint, and can be used for features
   * that require a hostname, like
   * :ref:`auto_host_rewrite <envoy_api_field_route.RouteAction.auto_host_rewrite>`.
   */
  hostname?: string | undefined;
}

/** The optional health check configuration. */
export interface Endpoint_HealthCheckConfig {
  $type: "envoy.api.v2.endpoint.Endpoint.HealthCheckConfig";
  /**
   * Optional alternative health check port value.
   *
   * By default the health check address port of an upstream host is the same
   * as the host's serving address port. This provides an alternative health
   * check port. Setting this with a non-zero value allows an upstream host
   * to have different health check address port.
   */
  port_value?:
    | number
    | undefined;
  /**
   * By default, the host header for L7 health checks is controlled by cluster level configuration
   * (see: :ref:`host <envoy_api_field_core.HealthCheck.HttpHealthCheck.host>` and
   * :ref:`authority <envoy_api_field_core.HealthCheck.GrpcHealthCheck.authority>`). Setting this
   * to a non-empty value allows overriding the cluster level configuration for a specific
   * endpoint.
   */
  hostname?: string | undefined;
}

/**
 * An Endpoint that Envoy can route traffic to.
 * [#next-free-field: 6]
 */
export interface LbEndpoint {
  $type: "envoy.api.v2.endpoint.LbEndpoint";
  /** Upstream host identifier or a named reference. */
  host_identifier?:
    | //
    { $case: "endpoint"; endpoint: Endpoint }
    | //
    /** [#not-implemented-hide:] */
    { $case: "endpoint_name"; endpoint_name: string }
    | undefined;
  /** Optional health status when known and supplied by EDS server. */
  health_status?:
    | HealthStatus
    | undefined;
  /**
   * The endpoint metadata specifies values that may be used by the load
   * balancer to select endpoints in a cluster for a given request. The filter
   * name should be specified as *envoy.lb*. An example boolean key-value pair
   * is *canary*, providing the optional canary status of the upstream host.
   * This may be matched against in a route's
   * :ref:`RouteAction <envoy_api_msg_route.RouteAction>` metadata_match field
   * to subset the endpoints considered in cluster load balancing.
   */
  metadata?:
    | Metadata
    | undefined;
  /**
   * The optional load balancing weight of the upstream host; at least 1.
   * Envoy uses the load balancing weight in some of the built in load
   * balancers. The load balancing weight for an endpoint is divided by the sum
   * of the weights of all endpoints in the endpoint's locality to produce a
   * percentage of traffic for the endpoint. This percentage is then further
   * weighted by the endpoint's locality's load balancing weight from
   * LocalityLbEndpoints. If unspecified, each host is presumed to have equal
   * weight in a locality. The sum of the weights of all endpoints in the
   * endpoint's locality must not exceed uint32_t maximal value (4294967295).
   */
  load_balancing_weight?: number | undefined;
}

/**
 * A group of endpoints belonging to a Locality.
 * One can have multiple LocalityLbEndpoints for a locality, but this is
 * generally only done if the different groups need to have different load
 * balancing weights or different priorities.
 * [#next-free-field: 7]
 */
export interface LocalityLbEndpoints {
  $type: "envoy.api.v2.endpoint.LocalityLbEndpoints";
  /** Identifies location of where the upstream hosts run. */
  locality?:
    | Locality
    | undefined;
  /** The group of endpoints belonging to the locality specified. */
  lb_endpoints?:
    | LbEndpoint[]
    | undefined;
  /**
   * Optional: Per priority/region/zone/sub_zone weight; at least 1. The load
   * balancing weight for a locality is divided by the sum of the weights of all
   * localities  at the same priority level to produce the effective percentage
   * of traffic for the locality. The sum of the weights of all localities at
   * the same priority level must not exceed uint32_t maximal value (4294967295).
   *
   * Locality weights are only considered when :ref:`locality weighted load
   * balancing <arch_overview_load_balancing_locality_weighted_lb>` is
   * configured. These weights are ignored otherwise. If no weights are
   * specified when locality weighted load balancing is enabled, the locality is
   * assigned no load.
   */
  load_balancing_weight?:
    | number
    | undefined;
  /**
   * Optional: the priority for this LocalityLbEndpoints. If unspecified this will
   * default to the highest priority (0).
   *
   * Under usual circumstances, Envoy will only select endpoints for the highest
   * priority (0). In the event all endpoints for a particular priority are
   * unavailable/unhealthy, Envoy will fail over to selecting endpoints for the
   * next highest priority group.
   *
   * Priorities should range from 0 (highest) to N (lowest) without skipping.
   */
  priority?:
    | number
    | undefined;
  /**
   * Optional: Per locality proximity value which indicates how close this
   * locality is from the source locality. This value only provides ordering
   * information (lower the value, closer it is to the source locality).
   * This will be consumed by load balancing schemes that need proximity order
   * to determine where to route the requests.
   * [#not-implemented-hide:]
   */
  proximity?: number | undefined;
}

function createBaseEndpoint(): Endpoint {
  return { $type: "envoy.api.v2.endpoint.Endpoint" };
}

export const Endpoint: MessageFns<Endpoint, "envoy.api.v2.endpoint.Endpoint"> = {
  $type: "envoy.api.v2.endpoint.Endpoint" as const,

  encode(message: Endpoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== undefined) {
      Address.encode(message.address, writer.uint32(10).fork()).join();
    }
    if (message.health_check_config !== undefined) {
      Endpoint_HealthCheckConfig.encode(message.health_check_config, writer.uint32(18).fork()).join();
    }
    if (message.hostname !== undefined && message.hostname !== "") {
      writer.uint32(26).string(message.hostname);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Endpoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = Address.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.health_check_config = Endpoint_HealthCheckConfig.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.hostname = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Endpoint {
    return {
      $type: Endpoint.$type,
      address: isSet(object.address) ? Address.fromJSON(object.address) : undefined,
      health_check_config: isSet(object.health_check_config)
        ? Endpoint_HealthCheckConfig.fromJSON(object.health_check_config)
        : undefined,
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : undefined,
    };
  },

  toJSON(message: Endpoint): unknown {
    const obj: any = {};
    if (message.address !== undefined) {
      obj.address = Address.toJSON(message.address);
    }
    if (message.health_check_config !== undefined) {
      obj.health_check_config = Endpoint_HealthCheckConfig.toJSON(message.health_check_config);
    }
    if (message.hostname !== undefined) {
      obj.hostname = message.hostname;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Endpoint>, I>>(base?: I): Endpoint {
    return Endpoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Endpoint>, I>>(object: I): Endpoint {
    const message = createBaseEndpoint();
    message.address = (object.address !== undefined && object.address !== null)
      ? Address.fromPartial(object.address)
      : undefined;
    message.health_check_config = (object.health_check_config !== undefined && object.health_check_config !== null)
      ? Endpoint_HealthCheckConfig.fromPartial(object.health_check_config)
      : undefined;
    message.hostname = object.hostname ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Endpoint.$type, Endpoint);

function createBaseEndpoint_HealthCheckConfig(): Endpoint_HealthCheckConfig {
  return { $type: "envoy.api.v2.endpoint.Endpoint.HealthCheckConfig" };
}

export const Endpoint_HealthCheckConfig: MessageFns<
  Endpoint_HealthCheckConfig,
  "envoy.api.v2.endpoint.Endpoint.HealthCheckConfig"
> = {
  $type: "envoy.api.v2.endpoint.Endpoint.HealthCheckConfig" as const,

  encode(message: Endpoint_HealthCheckConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.port_value !== undefined && message.port_value !== 0) {
      writer.uint32(8).uint32(message.port_value);
    }
    if (message.hostname !== undefined && message.hostname !== "") {
      writer.uint32(18).string(message.hostname);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Endpoint_HealthCheckConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndpoint_HealthCheckConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.port_value = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.hostname = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Endpoint_HealthCheckConfig {
    return {
      $type: Endpoint_HealthCheckConfig.$type,
      port_value: isSet(object.port_value) ? globalThis.Number(object.port_value) : undefined,
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : undefined,
    };
  },

  toJSON(message: Endpoint_HealthCheckConfig): unknown {
    const obj: any = {};
    if (message.port_value !== undefined) {
      obj.port_value = Math.round(message.port_value);
    }
    if (message.hostname !== undefined) {
      obj.hostname = message.hostname;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Endpoint_HealthCheckConfig>, I>>(base?: I): Endpoint_HealthCheckConfig {
    return Endpoint_HealthCheckConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Endpoint_HealthCheckConfig>, I>>(object: I): Endpoint_HealthCheckConfig {
    const message = createBaseEndpoint_HealthCheckConfig();
    message.port_value = object.port_value ?? undefined;
    message.hostname = object.hostname ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Endpoint_HealthCheckConfig.$type, Endpoint_HealthCheckConfig);

function createBaseLbEndpoint(): LbEndpoint {
  return { $type: "envoy.api.v2.endpoint.LbEndpoint", host_identifier: undefined };
}

export const LbEndpoint: MessageFns<LbEndpoint, "envoy.api.v2.endpoint.LbEndpoint"> = {
  $type: "envoy.api.v2.endpoint.LbEndpoint" as const,

  encode(message: LbEndpoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.host_identifier?.$case) {
      case "endpoint":
        Endpoint.encode(message.host_identifier.endpoint, writer.uint32(10).fork()).join();
        break;
      case "endpoint_name":
        writer.uint32(42).string(message.host_identifier.endpoint_name);
        break;
    }
    if (message.health_status !== undefined && message.health_status !== HealthStatus.UNKNOWN) {
      writer.uint32(16).int32(healthStatusToNumber(message.health_status));
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    if (message.load_balancing_weight !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.load_balancing_weight! },
        writer.uint32(34).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LbEndpoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLbEndpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.host_identifier = { $case: "endpoint", endpoint: Endpoint.decode(reader, reader.uint32()) };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.host_identifier = { $case: "endpoint_name", endpoint_name: reader.string() };
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.health_status = healthStatusFromJSON(reader.int32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.load_balancing_weight = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LbEndpoint {
    return {
      $type: LbEndpoint.$type,
      host_identifier: isSet(object.endpoint)
        ? { $case: "endpoint", endpoint: Endpoint.fromJSON(object.endpoint) }
        : isSet(object.endpoint_name)
        ? { $case: "endpoint_name", endpoint_name: globalThis.String(object.endpoint_name) }
        : undefined,
      health_status: isSet(object.health_status) ? healthStatusFromJSON(object.health_status) : undefined,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      load_balancing_weight: isSet(object.load_balancing_weight) ? Number(object.load_balancing_weight) : undefined,
    };
  },

  toJSON(message: LbEndpoint): unknown {
    const obj: any = {};
    if (message.host_identifier?.$case === "endpoint") {
      obj.endpoint = Endpoint.toJSON(message.host_identifier.endpoint);
    }
    if (message.host_identifier?.$case === "endpoint_name") {
      obj.endpoint_name = message.host_identifier.endpoint_name;
    }
    if (message.health_status !== undefined) {
      obj.health_status = healthStatusToJSON(message.health_status);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.load_balancing_weight !== undefined) {
      obj.load_balancing_weight = message.load_balancing_weight;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LbEndpoint>, I>>(base?: I): LbEndpoint {
    return LbEndpoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LbEndpoint>, I>>(object: I): LbEndpoint {
    const message = createBaseLbEndpoint();
    if (
      object.host_identifier?.$case === "endpoint" &&
      object.host_identifier?.endpoint !== undefined &&
      object.host_identifier?.endpoint !== null
    ) {
      message.host_identifier = { $case: "endpoint", endpoint: Endpoint.fromPartial(object.host_identifier.endpoint) };
    }
    if (
      object.host_identifier?.$case === "endpoint_name" &&
      object.host_identifier?.endpoint_name !== undefined &&
      object.host_identifier?.endpoint_name !== null
    ) {
      message.host_identifier = { $case: "endpoint_name", endpoint_name: object.host_identifier.endpoint_name };
    }
    message.health_status = object.health_status ?? undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.load_balancing_weight = object.load_balancing_weight ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(LbEndpoint.$type, LbEndpoint);

function createBaseLocalityLbEndpoints(): LocalityLbEndpoints {
  return { $type: "envoy.api.v2.endpoint.LocalityLbEndpoints" };
}

export const LocalityLbEndpoints: MessageFns<LocalityLbEndpoints, "envoy.api.v2.endpoint.LocalityLbEndpoints"> = {
  $type: "envoy.api.v2.endpoint.LocalityLbEndpoints" as const,

  encode(message: LocalityLbEndpoints, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.locality !== undefined) {
      Locality.encode(message.locality, writer.uint32(10).fork()).join();
    }
    if (message.lb_endpoints !== undefined && message.lb_endpoints.length !== 0) {
      for (const v of message.lb_endpoints) {
        LbEndpoint.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.load_balancing_weight !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.load_balancing_weight! },
        writer.uint32(26).fork(),
      ).join();
    }
    if (message.priority !== undefined && message.priority !== 0) {
      writer.uint32(40).uint32(message.priority);
    }
    if (message.proximity !== undefined) {
      UInt32Value.encode({ $type: "google.protobuf.UInt32Value", value: message.proximity! }, writer.uint32(50).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocalityLbEndpoints {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocalityLbEndpoints();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.locality = Locality.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.lb_endpoints === undefined) {
            message.lb_endpoints = [];
          }
          const el = LbEndpoint.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.lb_endpoints!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.load_balancing_weight = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.priority = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.proximity = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocalityLbEndpoints {
    return {
      $type: LocalityLbEndpoints.$type,
      locality: isSet(object.locality) ? Locality.fromJSON(object.locality) : undefined,
      lb_endpoints: globalThis.Array.isArray(object?.lb_endpoints)
        ? object.lb_endpoints.map((e: any) => LbEndpoint.fromJSON(e))
        : undefined,
      load_balancing_weight: isSet(object.load_balancing_weight) ? Number(object.load_balancing_weight) : undefined,
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : undefined,
      proximity: isSet(object.proximity) ? Number(object.proximity) : undefined,
    };
  },

  toJSON(message: LocalityLbEndpoints): unknown {
    const obj: any = {};
    if (message.locality !== undefined) {
      obj.locality = Locality.toJSON(message.locality);
    }
    if (message.lb_endpoints?.length) {
      obj.lb_endpoints = message.lb_endpoints.map((e) => LbEndpoint.toJSON(e));
    }
    if (message.load_balancing_weight !== undefined) {
      obj.load_balancing_weight = message.load_balancing_weight;
    }
    if (message.priority !== undefined) {
      obj.priority = Math.round(message.priority);
    }
    if (message.proximity !== undefined) {
      obj.proximity = message.proximity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LocalityLbEndpoints>, I>>(base?: I): LocalityLbEndpoints {
    return LocalityLbEndpoints.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LocalityLbEndpoints>, I>>(object: I): LocalityLbEndpoints {
    const message = createBaseLocalityLbEndpoints();
    message.locality = (object.locality !== undefined && object.locality !== null)
      ? Locality.fromPartial(object.locality)
      : undefined;
    message.lb_endpoints = object.lb_endpoints?.map((e) => LbEndpoint.fromPartial(e)) || undefined;
    message.load_balancing_weight = object.load_balancing_weight ?? undefined;
    message.priority = object.priority ?? undefined;
    message.proximity = object.proximity ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(LocalityLbEndpoints.$type, LocalityLbEndpoints);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
