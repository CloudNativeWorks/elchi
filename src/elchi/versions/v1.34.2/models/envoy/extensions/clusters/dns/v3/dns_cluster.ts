// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/clusters/dns/v3/dns_cluster.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../../../google/protobuf/duration";
import { messageTypeRegistry } from "../../../../../typeRegistry";
import { TypedExtensionConfig } from "../../../../config/core/v3/extension";
import {
  DnsLookupFamily,
  dnsLookupFamilyFromJSON,
  dnsLookupFamilyToJSON,
  dnsLookupFamilyToNumber,
} from "../../common/dns/v3/dns";

export const protobufPackage = "envoy.extensions.clusters.dns.v3";

/** [#next-free-field: 10] */
export interface DnsCluster {
  $type: "envoy.extensions.clusters.dns.v3.DnsCluster";
  /**
   * This value is the cluster’s DNS refresh rate. The value configured must be at least 1ms.
   * If this setting is not specified, the
   * value defaults to 5000ms.
   */
  dns_refresh_rate?:
    | Duration
    | undefined;
  /**
   * This is the cluster’s DNS refresh rate when requests are failing. If this setting is
   * not specified, the failure refresh rate defaults to the DNS refresh rate.
   */
  dns_failure_refresh_rate?:
    | DnsCluster_RefreshRate
    | undefined;
  /**
   * Optional configuration for setting cluster's DNS refresh rate. If the value is set to true,
   * cluster's DNS refresh rate will be set to resource record's TTL which comes from DNS
   * resolution.
   */
  respect_dns_ttl?:
    | boolean
    | undefined;
  /**
   * DNS jitter causes the cluster to refresh DNS entries later by a random amount of time to avoid a
   * stampede of DNS requests. This value sets the upper bound (exclusive) for the random amount.
   * There will be no jitter if this value is omitted.
   */
  dns_jitter?:
    | Duration
    | undefined;
  /**
   * DNS resolver type configuration extension. This extension can be used to configure c-ares, apple,
   * or any other DNS resolver types and the related parameters.
   * For example, an object of
   * :ref:`CaresDnsResolverConfig<envoy_v3_api_msg_extensions.network.dns_resolver.cares.v3.CaresDnsResolverConfig>`
   * can be packed into this ``typed_dns_resolver_config``. This configuration replaces the
   * :ref:`Cluster.typed_dns_resolver_config<envoy_v3_api_field_config.cluster.v3.Cluster.typed_dns_resolver_config>`
   * configuration which replaces :ref:`Cluster.dns_resolution_config<envoy_v3_api_field_config.cluster.v3.Cluster.dns_resolution_config>`.
   * During the transition period when
   * :ref:`DnsCluster.typed_dns_resolver_config<envoy_v3_api_field_extensions.clusters.dns.v3.DnsCluster.typed_dns_resolver_config>`,
   * :ref:`Cluster.typed_dns_resolver_config<envoy_v3_api_field_config.cluster.v3.Cluster.typed_dns_resolver_config>`,
   * and :ref:`Cluster.dns_resolution_config<envoy_v3_api_field_config.cluster.v3.Cluster.dns_resolution_config>`
   * exist, Envoy will use
   * :ref:`DnsCluster.typed_dns_resolver_config<envoy_v3_api_field_extensions.clusters.dns.v3.DnsCluster.typed_dns_resolver_config>`
   * and ignore
   * DNS resolver-related fields in :ref:`Cluster<envoy_v3_api_msg_config.cluster.v3.Cluster>` if the cluster is configured via the
   * :ref:`Cluster.cluster_type<envoy_v3_api_field_config.cluster.v3.Cluster.cluster_type>` extension point with the
   * :ref:`DnsCluster<envoy_v3_api_msg_extensions.clusters.dns.v3.DnsCluster>` extension type.
   * Otherwise, see  :ref:`Cluster.typed_dns_resolver_config<envoy_v3_api_field_config.cluster.v3.Cluster.typed_dns_resolver_config>`.
   * [#extension-category: envoy.network.dns_resolver]
   */
  typed_dns_resolver_config?:
    | TypedExtensionConfig
    | undefined;
  /**
   * The DNS IP address resolution policy. If this setting is not specified, the
   * value defaults to
   * :ref:`AUTO<envoy_v3_api_enum_value_extensions.clusters.common.dns.v3.DnsLookupFamily.AUTO>`.
   */
  dns_lookup_family?:
    | DnsLookupFamily
    | undefined;
  /**
   * If true, all returned addresses are considered to be associated with a single endpoint,
   * which maps to :ref:`logical DNS discovery <arch_overview_service_discovery_types_logical_dns>`
   * semantics. Otherwise, each address is considered to be a separate endpoint, which maps to
   * :ref:`strict DNS discovery <arch_overview_service_discovery_types_strict_dns>` semantics.
   */
  all_addresses_in_single_endpoint?: boolean | undefined;
}

export interface DnsCluster_RefreshRate {
  $type: "envoy.extensions.clusters.dns.v3.DnsCluster.RefreshRate";
  /**
   * Specifies the base interval between refreshes. This parameter is required and must be greater
   * than zero and less than
   * :ref:`max_interval <envoy_v3_api_field_extensions.clusters.dns.v3.DnsCluster.RefreshRate.max_interval>`.
   */
  base_interval?:
    | Duration
    | undefined;
  /**
   * Specifies the maximum interval between refreshes. This parameter is optional, but must be
   * greater than or equal to the
   * :ref:`base_interval <envoy_v3_api_field_extensions.clusters.dns.v3.DnsCluster.RefreshRate.base_interval>`  if set. The default
   * is 10 times the :ref:`base_interval <envoy_v3_api_field_extensions.clusters.dns.v3.DnsCluster.RefreshRate.base_interval>`.
   */
  max_interval?: Duration | undefined;
}

function createBaseDnsCluster(): DnsCluster {
  return { $type: "envoy.extensions.clusters.dns.v3.DnsCluster" };
}

export const DnsCluster: MessageFns<DnsCluster, "envoy.extensions.clusters.dns.v3.DnsCluster"> = {
  $type: "envoy.extensions.clusters.dns.v3.DnsCluster" as const,

  encode(message: DnsCluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dns_refresh_rate !== undefined) {
      Duration.encode(message.dns_refresh_rate, writer.uint32(26).fork()).join();
    }
    if (message.dns_failure_refresh_rate !== undefined) {
      DnsCluster_RefreshRate.encode(message.dns_failure_refresh_rate, writer.uint32(34).fork()).join();
    }
    if (message.respect_dns_ttl !== undefined && message.respect_dns_ttl !== false) {
      writer.uint32(40).bool(message.respect_dns_ttl);
    }
    if (message.dns_jitter !== undefined) {
      Duration.encode(message.dns_jitter, writer.uint32(50).fork()).join();
    }
    if (message.typed_dns_resolver_config !== undefined) {
      TypedExtensionConfig.encode(message.typed_dns_resolver_config, writer.uint32(58).fork()).join();
    }
    if (message.dns_lookup_family !== undefined && message.dns_lookup_family !== DnsLookupFamily.UNSPECIFIED) {
      writer.uint32(64).int32(dnsLookupFamilyToNumber(message.dns_lookup_family));
    }
    if (message.all_addresses_in_single_endpoint !== undefined && message.all_addresses_in_single_endpoint !== false) {
      writer.uint32(72).bool(message.all_addresses_in_single_endpoint);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DnsCluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDnsCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.dns_refresh_rate = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.dns_failure_refresh_rate = DnsCluster_RefreshRate.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.respect_dns_ttl = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.dns_jitter = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.typed_dns_resolver_config = TypedExtensionConfig.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.dns_lookup_family = dnsLookupFamilyFromJSON(reader.int32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.all_addresses_in_single_endpoint = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DnsCluster {
    return {
      $type: DnsCluster.$type,
      dns_refresh_rate: isSet(object.dns_refresh_rate) ? Duration.fromJSON(object.dns_refresh_rate) : undefined,
      dns_failure_refresh_rate: isSet(object.dns_failure_refresh_rate)
        ? DnsCluster_RefreshRate.fromJSON(object.dns_failure_refresh_rate)
        : undefined,
      respect_dns_ttl: isSet(object.respect_dns_ttl) ? globalThis.Boolean(object.respect_dns_ttl) : undefined,
      dns_jitter: isSet(object.dns_jitter) ? Duration.fromJSON(object.dns_jitter) : undefined,
      typed_dns_resolver_config: isSet(object.typed_dns_resolver_config)
        ? TypedExtensionConfig.fromJSON(object.typed_dns_resolver_config)
        : undefined,
      dns_lookup_family: isSet(object.dns_lookup_family)
        ? dnsLookupFamilyFromJSON(object.dns_lookup_family)
        : undefined,
      all_addresses_in_single_endpoint: isSet(object.all_addresses_in_single_endpoint)
        ? globalThis.Boolean(object.all_addresses_in_single_endpoint)
        : undefined,
    };
  },

  toJSON(message: DnsCluster): unknown {
    const obj: any = {};
    if (message.dns_refresh_rate !== undefined) {
      obj.dns_refresh_rate = Duration.toJSON(message.dns_refresh_rate);
    }
    if (message.dns_failure_refresh_rate !== undefined) {
      obj.dns_failure_refresh_rate = DnsCluster_RefreshRate.toJSON(message.dns_failure_refresh_rate);
    }
    if (message.respect_dns_ttl !== undefined) {
      obj.respect_dns_ttl = message.respect_dns_ttl;
    }
    if (message.dns_jitter !== undefined) {
      obj.dns_jitter = Duration.toJSON(message.dns_jitter);
    }
    if (message.typed_dns_resolver_config !== undefined) {
      obj.typed_dns_resolver_config = TypedExtensionConfig.toJSON(message.typed_dns_resolver_config);
    }
    if (message.dns_lookup_family !== undefined) {
      obj.dns_lookup_family = dnsLookupFamilyToJSON(message.dns_lookup_family);
    }
    if (message.all_addresses_in_single_endpoint !== undefined) {
      obj.all_addresses_in_single_endpoint = message.all_addresses_in_single_endpoint;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DnsCluster>, I>>(base?: I): DnsCluster {
    return DnsCluster.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DnsCluster>, I>>(object: I): DnsCluster {
    const message = createBaseDnsCluster();
    message.dns_refresh_rate = (object.dns_refresh_rate !== undefined && object.dns_refresh_rate !== null)
      ? Duration.fromPartial(object.dns_refresh_rate)
      : undefined;
    message.dns_failure_refresh_rate =
      (object.dns_failure_refresh_rate !== undefined && object.dns_failure_refresh_rate !== null)
        ? DnsCluster_RefreshRate.fromPartial(object.dns_failure_refresh_rate)
        : undefined;
    message.respect_dns_ttl = object.respect_dns_ttl ?? undefined;
    message.dns_jitter = (object.dns_jitter !== undefined && object.dns_jitter !== null)
      ? Duration.fromPartial(object.dns_jitter)
      : undefined;
    message.typed_dns_resolver_config =
      (object.typed_dns_resolver_config !== undefined && object.typed_dns_resolver_config !== null)
        ? TypedExtensionConfig.fromPartial(object.typed_dns_resolver_config)
        : undefined;
    message.dns_lookup_family = object.dns_lookup_family ?? undefined;
    message.all_addresses_in_single_endpoint = object.all_addresses_in_single_endpoint ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(DnsCluster.$type, DnsCluster);

function createBaseDnsCluster_RefreshRate(): DnsCluster_RefreshRate {
  return { $type: "envoy.extensions.clusters.dns.v3.DnsCluster.RefreshRate" };
}

export const DnsCluster_RefreshRate: MessageFns<
  DnsCluster_RefreshRate,
  "envoy.extensions.clusters.dns.v3.DnsCluster.RefreshRate"
> = {
  $type: "envoy.extensions.clusters.dns.v3.DnsCluster.RefreshRate" as const,

  encode(message: DnsCluster_RefreshRate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.base_interval !== undefined) {
      Duration.encode(message.base_interval, writer.uint32(10).fork()).join();
    }
    if (message.max_interval !== undefined) {
      Duration.encode(message.max_interval, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DnsCluster_RefreshRate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDnsCluster_RefreshRate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.base_interval = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.max_interval = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DnsCluster_RefreshRate {
    return {
      $type: DnsCluster_RefreshRate.$type,
      base_interval: isSet(object.base_interval) ? Duration.fromJSON(object.base_interval) : undefined,
      max_interval: isSet(object.max_interval) ? Duration.fromJSON(object.max_interval) : undefined,
    };
  },

  toJSON(message: DnsCluster_RefreshRate): unknown {
    const obj: any = {};
    if (message.base_interval !== undefined) {
      obj.base_interval = Duration.toJSON(message.base_interval);
    }
    if (message.max_interval !== undefined) {
      obj.max_interval = Duration.toJSON(message.max_interval);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DnsCluster_RefreshRate>, I>>(base?: I): DnsCluster_RefreshRate {
    return DnsCluster_RefreshRate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DnsCluster_RefreshRate>, I>>(object: I): DnsCluster_RefreshRate {
    const message = createBaseDnsCluster_RefreshRate();
    message.base_interval = (object.base_interval !== undefined && object.base_interval !== null)
      ? Duration.fromPartial(object.base_interval)
      : undefined;
    message.max_interval = (object.max_interval !== undefined && object.max_interval !== null)
      ? Duration.fromPartial(object.max_interval)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(DnsCluster_RefreshRate.$type, DnsCluster_RefreshRate);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
