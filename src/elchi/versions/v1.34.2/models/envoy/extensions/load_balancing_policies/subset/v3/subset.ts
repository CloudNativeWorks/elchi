// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/load_balancing_policies/subset/v3/subset.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Struct } from "../../../../../google/protobuf/struct";
import { messageTypeRegistry } from "../../../../../typeRegistry";
import { LoadBalancingPolicy } from "../../../../config/cluster/v3/cluster";

export const protobufPackage = "envoy.extensions.load_balancing_policies.subset.v3";

/**
 * Optionally divide the endpoints in this cluster into subsets defined by
 * endpoint metadata and selected by route and weighted cluster metadata.
 * [#next-free-field: 11]
 */
export interface Subset {
  $type: "envoy.extensions.load_balancing_policies.subset.v3.Subset";
  /**
   * The behavior used when no endpoint subset matches the selected route's
   * metadata. The value defaults to
   * :ref:`NO_FALLBACK<envoy_v3_api_enum_value_extensions.load_balancing_policies.subset.v3.Subset.LbSubsetFallbackPolicy.NO_FALLBACK>`.
   */
  fallback_policy?:
    | Subset_LbSubsetFallbackPolicy
    | undefined;
  /**
   * Specifies the default subset of endpoints used during fallback if
   * fallback_policy is
   * :ref:`DEFAULT_SUBSET<envoy_v3_api_enum_value_extensions.load_balancing_policies.subset.v3.Subset.LbSubsetFallbackPolicy.DEFAULT_SUBSET>`.
   * Each field in default_subset is
   * compared to the matching LbEndpoint.Metadata under the ``envoy.lb``
   * namespace. It is valid for no hosts to match, in which case the behavior
   * is the same as a fallback_policy of
   * :ref:`NO_FALLBACK<envoy_v3_api_enum_value_extensions.load_balancing_policies.subset.v3.Subset.LbSubsetFallbackPolicy.NO_FALLBACK>`.
   */
  default_subset?:
    | { [key: string]: any }
    | undefined;
  /**
   * For each entry, LbEndpoint.Metadata's
   * ``envoy.lb`` namespace is traversed and a subset is created for each unique
   * combination of key and value. For example:
   *
   * .. code-block:: json
   *
   *   { "subset_selectors": [
   *       { "keys": [ "version" ] },
   *       { "keys": [ "stage", "hardware_type" ] }
   *   ]}
   *
   * A subset is matched when the metadata from the selected route and
   * weighted cluster contains the same keys and values as the subset's
   * metadata. The same host may appear in multiple subsets.
   */
  subset_selectors?:
    | Subset_LbSubsetSelector[]
    | undefined;
  /**
   * By default, only when the request metadata has exactly the **same** keys as one of subset selectors and
   * the values of the related keys are matched, the load balancer will have a valid subset for the request.
   * For example, given the following subset selectors:
   *
   * .. code-block:: json
   *
   *   { "subset_selectors": [
   *       { "keys": [ "version" ] },
   *       { "keys": [ "stage", "version" ] }
   *   ]}
   *
   * A request with metadata ``{"redundant-key": "redundant-value", "stage": "prod", "version": "v1"}`` or
   * ``{"redundant-key": "redundant-value", "version": "v1"}`` will not have a valid subset even if the values
   * of keys ``stage`` and ``version`` are matched because of the redundant key/value pair in the request
   * metadata.
   *
   * By setting this field to true, the most appropriate keys will be filtered out from the request metadata
   * according to the subset selectors. And then the filtered keys and related values will be matched to find
   * the valid host subset. By this way, redundant key/value pairs are allowed in the request metadata. The keys
   * of a request metadata could be superset of the keys of the subset selectors and need not to be exactly the
   * same as the keys of the subset selectors.
   *
   * More specifically, if the keys of a request metadata is a superset of one of the subset selectors, then only
   * the values of the keys that in the selector keys will be matched. Take the above example, if the request
   * metadata is ``{"redundant-key": "redundant-value", "stage": "prod", "version": "v1"}``, the load balancer
   * will only match the values of ``stage`` and ``version`` to find an appropriate subset because ``stage``
   * ``version`` are contained by the second subset selector and the redundant ``redundant-key`` will be
   * ignored.
   *
   * .. note::
   *   If the keys of request metadata is superset of multiple different subset selectors keys, the subset
   *   selector with most keys to win. For example, given subset selectors
   *   ``{"subset_selectors": ["keys": ["A", "B", "C"], ["A", "B"]]}`` and request metadata ``{"A": "-",
   *   "B": "-", "C": "-", "D": "-"}``, keys ``A``, ``B``, ``C`` will be evaluated.
   *   If the keys of request metadata is superset of multiple different subset selectors keys and the number
   *   of selector keys are same, then the one placed in front to win. For example, given subset selectors
   *   ``{"subset_selectors": ["keys": ["A", "B"], ["C", "D"]]}`` and request metadata ``{"A": "-", "B": "-",
   *   "C": "-", "D": "-"}``, keys ``A``, ``B`` will be evaluated.
   */
  allow_redundant_keys?:
    | boolean
    | undefined;
  /**
   * If true, routing to subsets will take into account the localities and locality weights of the
   * endpoints when making the routing decision.
   *
   * There are some potential pitfalls associated with enabling this feature, as the resulting
   * traffic split after applying both a subset match and locality weights might be undesirable.
   *
   * Consider for example a situation in which you have 50/50 split across two localities X/Y
   * which have 100 hosts each without subsetting. If the subset LB results in X having only 1
   * host selected but Y having 100, then a lot more load is being dumped on the single host in X
   * than originally anticipated in the load balancing assignment delivered via EDS.
   */
  locality_weight_aware?:
    | boolean
    | undefined;
  /**
   * When used with locality_weight_aware, scales the weight of each locality by the ratio
   * of hosts in the subset vs hosts in the original subset. This aims to even out the load
   * going to an individual locality if said locality is disproportionately affected by the
   * subset predicate.
   */
  scale_locality_weight?:
    | boolean
    | undefined;
  /**
   * If true, when a fallback policy is configured and its corresponding subset fails to find
   * a host this will cause any host to be selected instead.
   *
   * This is useful when using the default subset as the fallback policy, given the default
   * subset might become empty. With this option enabled, if that happens the LB will attempt
   * to select a host from the entire cluster.
   */
  panic_mode_any?:
    | boolean
    | undefined;
  /**
   * If true, metadata specified for a metadata key will be matched against the corresponding
   * endpoint metadata if the endpoint metadata matches the value exactly OR it is a list value
   * and any of the elements in the list matches the criteria.
   */
  list_as_any?:
    | boolean
    | undefined;
  /**
   * Fallback mechanism that allows to try different route metadata until a host is found.
   * If load balancing process, including all its mechanisms (like
   * :ref:`fallback_policy<envoy_v3_api_field_extensions.load_balancing_policies.subset.v3.subset.fallback_policy>`)
   * fails to select a host, this policy decides if and how the process is repeated using another metadata.
   *
   * The value defaults to
   * :ref:`METADATA_NO_FALLBACK
   * <envoy_v3_api_enum_value_extensions.load_balancing_policies.subset.v3.subset.LbSubsetMetadataFallbackPolicy.METADATA_NO_FALLBACK>`.
   */
  metadata_fallback_policy?:
    | Subset_LbSubsetMetadataFallbackPolicy
    | undefined;
  /** The child LB policy to create for endpoint-picking within the chosen subset. */
  subset_lb_policy?: LoadBalancingPolicy | undefined;
}

/**
 * If NO_FALLBACK is selected, a result
 * equivalent to no healthy hosts is reported. If ANY_ENDPOINT is selected,
 * any cluster endpoint may be returned (subject to policy, health checks,
 * etc). If DEFAULT_SUBSET is selected, load balancing is performed over the
 * endpoints matching the values from the default_subset field.
 */
export enum Subset_LbSubsetFallbackPolicy {
  NO_FALLBACK = "NO_FALLBACK",
  ANY_ENDPOINT = "ANY_ENDPOINT",
  DEFAULT_SUBSET = "DEFAULT_SUBSET",
}

export function subset_LbSubsetFallbackPolicyFromJSON(object: any): Subset_LbSubsetFallbackPolicy {
  switch (object) {
    case 0:
    case "NO_FALLBACK":
      return Subset_LbSubsetFallbackPolicy.NO_FALLBACK;
    case 1:
    case "ANY_ENDPOINT":
      return Subset_LbSubsetFallbackPolicy.ANY_ENDPOINT;
    case 2:
    case "DEFAULT_SUBSET":
      return Subset_LbSubsetFallbackPolicy.DEFAULT_SUBSET;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Subset_LbSubsetFallbackPolicy");
  }
}

export function subset_LbSubsetFallbackPolicyToJSON(object: Subset_LbSubsetFallbackPolicy): string {
  switch (object) {
    case Subset_LbSubsetFallbackPolicy.NO_FALLBACK:
      return "NO_FALLBACK";
    case Subset_LbSubsetFallbackPolicy.ANY_ENDPOINT:
      return "ANY_ENDPOINT";
    case Subset_LbSubsetFallbackPolicy.DEFAULT_SUBSET:
      return "DEFAULT_SUBSET";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Subset_LbSubsetFallbackPolicy");
  }
}

export function subset_LbSubsetFallbackPolicyToNumber(object: Subset_LbSubsetFallbackPolicy): number {
  switch (object) {
    case Subset_LbSubsetFallbackPolicy.NO_FALLBACK:
      return 0;
    case Subset_LbSubsetFallbackPolicy.ANY_ENDPOINT:
      return 1;
    case Subset_LbSubsetFallbackPolicy.DEFAULT_SUBSET:
      return 2;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Subset_LbSubsetFallbackPolicy");
  }
}

export enum Subset_LbSubsetMetadataFallbackPolicy {
  /** METADATA_NO_FALLBACK - No fallback. Route metadata will be used as-is. */
  METADATA_NO_FALLBACK = "METADATA_NO_FALLBACK",
  /**
   * FALLBACK_LIST - A special metadata key ``fallback_list`` will be used to provide variants of metadata to try.
   * Value of ``fallback_list`` key has to be a list. Every list element has to be a struct - it will
   * be merged with route metadata, overriding keys that appear in both places.
   * ``fallback_list`` entries will be used in order until a host is found.
   *
   * ``fallback_list`` key itself is removed from metadata before subset load balancing is performed.
   *
   * Example:
   *
   * for metadata:
   *
   * .. code-block:: yaml
   *
   *   version: 1.0
   *   fallback_list:
   *     - version: 2.0
   *       hardware: c64
   *     - hardware: c32
   *     - version: 3.0
   *
   * at first, metadata:
   *
   * .. code-block:: json
   *
   *   {"version": "2.0", "hardware": "c64"}
   *
   * will be used for load balancing. If no host is found, metadata:
   *
   * .. code-block:: json
   *
   *   {"version": "1.0", "hardware": "c32"}
   *
   * is next to try. If it still results in no host, finally metadata:
   *
   * .. code-block:: json
   *
   *   {"version": "3.0"}
   *
   * is used.
   */
  FALLBACK_LIST = "FALLBACK_LIST",
}

export function subset_LbSubsetMetadataFallbackPolicyFromJSON(object: any): Subset_LbSubsetMetadataFallbackPolicy {
  switch (object) {
    case 0:
    case "METADATA_NO_FALLBACK":
      return Subset_LbSubsetMetadataFallbackPolicy.METADATA_NO_FALLBACK;
    case 1:
    case "FALLBACK_LIST":
      return Subset_LbSubsetMetadataFallbackPolicy.FALLBACK_LIST;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum Subset_LbSubsetMetadataFallbackPolicy",
      );
  }
}

export function subset_LbSubsetMetadataFallbackPolicyToJSON(object: Subset_LbSubsetMetadataFallbackPolicy): string {
  switch (object) {
    case Subset_LbSubsetMetadataFallbackPolicy.METADATA_NO_FALLBACK:
      return "METADATA_NO_FALLBACK";
    case Subset_LbSubsetMetadataFallbackPolicy.FALLBACK_LIST:
      return "FALLBACK_LIST";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum Subset_LbSubsetMetadataFallbackPolicy",
      );
  }
}

export function subset_LbSubsetMetadataFallbackPolicyToNumber(object: Subset_LbSubsetMetadataFallbackPolicy): number {
  switch (object) {
    case Subset_LbSubsetMetadataFallbackPolicy.METADATA_NO_FALLBACK:
      return 0;
    case Subset_LbSubsetMetadataFallbackPolicy.FALLBACK_LIST:
      return 1;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum Subset_LbSubsetMetadataFallbackPolicy",
      );
  }
}

/** Specifications for subsets. */
export interface Subset_LbSubsetSelector {
  $type: "envoy.extensions.load_balancing_policies.subset.v3.Subset.LbSubsetSelector";
  /** List of keys to match with the weighted cluster metadata. */
  keys?:
    | string[]
    | undefined;
  /**
   * Selects a mode of operation in which each subset has only one host. This mode uses the same rules for
   * choosing a host, but updating hosts is faster, especially for large numbers of hosts.
   *
   * If a match is found to a host, that host will be used regardless of priority levels.
   *
   * When this mode is enabled, configurations that contain more than one host with the same metadata value for the single key in ``keys``
   * will use only one of the hosts with the given key; no requests will be routed to the others. The cluster gauge
   * :ref:`lb_subsets_single_host_per_subset_duplicate<config_cluster_manager_cluster_stats_subset_lb>` indicates how many duplicates are
   * present in the current configuration.
   */
  single_host_per_subset?:
    | boolean
    | undefined;
  /**
   * The behavior used when no endpoint subset matches the selected route's
   * metadata.
   */
  fallback_policy?:
    | Subset_LbSubsetSelector_LbSubsetSelectorFallbackPolicy
    | undefined;
  /**
   * Subset of
   * :ref:`keys<envoy_v3_api_field_extensions.load_balancing_policies.subset.v3.Subset.LbSubsetSelector.keys>` used by
   * :ref:`KEYS_SUBSET<envoy_v3_api_enum_value_extensions.load_balancing_policies.subset.v3.Subset.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.KEYS_SUBSET>`
   * fallback policy.
   * It has to be a non empty list if KEYS_SUBSET fallback policy is selected.
   * For any other fallback policy the parameter is not used and should not be set.
   * Only values also present in
   * :ref:`keys<envoy_v3_api_field_extensions.load_balancing_policies.subset.v3.Subset.LbSubsetSelector.keys>` are allowed, but
   * ``fallback_keys_subset`` cannot be equal to ``keys``.
   */
  fallback_keys_subset?: string[] | undefined;
}

/** Allows to override top level fallback policy per selector. */
export enum Subset_LbSubsetSelector_LbSubsetSelectorFallbackPolicy {
  /** NOT_DEFINED - If NOT_DEFINED top level config fallback policy is used instead. */
  NOT_DEFINED = "NOT_DEFINED",
  /** NO_FALLBACK - If NO_FALLBACK is selected, a result equivalent to no healthy hosts is reported. */
  NO_FALLBACK = "NO_FALLBACK",
  /**
   * ANY_ENDPOINT - If ANY_ENDPOINT is selected, any cluster endpoint may be returned
   * (subject to policy, health checks, etc).
   */
  ANY_ENDPOINT = "ANY_ENDPOINT",
  /**
   * DEFAULT_SUBSET - If DEFAULT_SUBSET is selected, load balancing is performed over the
   * endpoints matching the values from the default_subset field.
   */
  DEFAULT_SUBSET = "DEFAULT_SUBSET",
  /**
   * KEYS_SUBSET - If KEYS_SUBSET is selected, subset selector matching is performed again with metadata
   * keys reduced to
   * :ref:`fallback_keys_subset<envoy_v3_api_field_extensions.load_balancing_policies.subset.v3.Subset.LbSubsetSelector.fallback_keys_subset>`.
   * It allows for a fallback to a different, less specific selector if some of the keys of
   * the selector are considered optional.
   */
  KEYS_SUBSET = "KEYS_SUBSET",
}

export function subset_LbSubsetSelector_LbSubsetSelectorFallbackPolicyFromJSON(
  object: any,
): Subset_LbSubsetSelector_LbSubsetSelectorFallbackPolicy {
  switch (object) {
    case 0:
    case "NOT_DEFINED":
      return Subset_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.NOT_DEFINED;
    case 1:
    case "NO_FALLBACK":
      return Subset_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.NO_FALLBACK;
    case 2:
    case "ANY_ENDPOINT":
      return Subset_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.ANY_ENDPOINT;
    case 3:
    case "DEFAULT_SUBSET":
      return Subset_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.DEFAULT_SUBSET;
    case 4:
    case "KEYS_SUBSET":
      return Subset_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.KEYS_SUBSET;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum Subset_LbSubsetSelector_LbSubsetSelectorFallbackPolicy",
      );
  }
}

export function subset_LbSubsetSelector_LbSubsetSelectorFallbackPolicyToJSON(
  object: Subset_LbSubsetSelector_LbSubsetSelectorFallbackPolicy,
): string {
  switch (object) {
    case Subset_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.NOT_DEFINED:
      return "NOT_DEFINED";
    case Subset_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.NO_FALLBACK:
      return "NO_FALLBACK";
    case Subset_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.ANY_ENDPOINT:
      return "ANY_ENDPOINT";
    case Subset_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.DEFAULT_SUBSET:
      return "DEFAULT_SUBSET";
    case Subset_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.KEYS_SUBSET:
      return "KEYS_SUBSET";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum Subset_LbSubsetSelector_LbSubsetSelectorFallbackPolicy",
      );
  }
}

export function subset_LbSubsetSelector_LbSubsetSelectorFallbackPolicyToNumber(
  object: Subset_LbSubsetSelector_LbSubsetSelectorFallbackPolicy,
): number {
  switch (object) {
    case Subset_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.NOT_DEFINED:
      return 0;
    case Subset_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.NO_FALLBACK:
      return 1;
    case Subset_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.ANY_ENDPOINT:
      return 2;
    case Subset_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.DEFAULT_SUBSET:
      return 3;
    case Subset_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.KEYS_SUBSET:
      return 4;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum Subset_LbSubsetSelector_LbSubsetSelectorFallbackPolicy",
      );
  }
}

function createBaseSubset(): Subset {
  return { $type: "envoy.extensions.load_balancing_policies.subset.v3.Subset" };
}

export const Subset: MessageFns<Subset, "envoy.extensions.load_balancing_policies.subset.v3.Subset"> = {
  $type: "envoy.extensions.load_balancing_policies.subset.v3.Subset" as const,

  encode(message: Subset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (
      message.fallback_policy !== undefined && message.fallback_policy !== Subset_LbSubsetFallbackPolicy.NO_FALLBACK
    ) {
      writer.uint32(8).int32(subset_LbSubsetFallbackPolicyToNumber(message.fallback_policy));
    }
    if (message.default_subset !== undefined) {
      Struct.encode(Struct.wrap(message.default_subset), writer.uint32(18).fork()).join();
    }
    if (message.subset_selectors !== undefined && message.subset_selectors.length !== 0) {
      for (const v of message.subset_selectors) {
        Subset_LbSubsetSelector.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    if (message.allow_redundant_keys !== undefined && message.allow_redundant_keys !== false) {
      writer.uint32(80).bool(message.allow_redundant_keys);
    }
    if (message.locality_weight_aware !== undefined && message.locality_weight_aware !== false) {
      writer.uint32(32).bool(message.locality_weight_aware);
    }
    if (message.scale_locality_weight !== undefined && message.scale_locality_weight !== false) {
      writer.uint32(40).bool(message.scale_locality_weight);
    }
    if (message.panic_mode_any !== undefined && message.panic_mode_any !== false) {
      writer.uint32(48).bool(message.panic_mode_any);
    }
    if (message.list_as_any !== undefined && message.list_as_any !== false) {
      writer.uint32(56).bool(message.list_as_any);
    }
    if (
      message.metadata_fallback_policy !== undefined &&
      message.metadata_fallback_policy !== Subset_LbSubsetMetadataFallbackPolicy.METADATA_NO_FALLBACK
    ) {
      writer.uint32(64).int32(subset_LbSubsetMetadataFallbackPolicyToNumber(message.metadata_fallback_policy));
    }
    if (message.subset_lb_policy !== undefined) {
      LoadBalancingPolicy.encode(message.subset_lb_policy, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Subset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fallback_policy = subset_LbSubsetFallbackPolicyFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.default_subset = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.subset_selectors === undefined) {
            message.subset_selectors = [];
          }
          const el = Subset_LbSubsetSelector.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.subset_selectors!.push(el);
          }
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.allow_redundant_keys = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.locality_weight_aware = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.scale_locality_weight = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.panic_mode_any = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.list_as_any = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.metadata_fallback_policy = subset_LbSubsetMetadataFallbackPolicyFromJSON(reader.int32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.subset_lb_policy = LoadBalancingPolicy.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Subset {
    return {
      $type: Subset.$type,
      fallback_policy: isSet(object.fallback_policy)
        ? subset_LbSubsetFallbackPolicyFromJSON(object.fallback_policy)
        : undefined,
      default_subset: isObject(object.default_subset) ? object.default_subset : undefined,
      subset_selectors: globalThis.Array.isArray(object?.subset_selectors)
        ? object.subset_selectors.map((e: any) => Subset_LbSubsetSelector.fromJSON(e))
        : undefined,
      allow_redundant_keys: isSet(object.allow_redundant_keys)
        ? globalThis.Boolean(object.allow_redundant_keys)
        : undefined,
      locality_weight_aware: isSet(object.locality_weight_aware)
        ? globalThis.Boolean(object.locality_weight_aware)
        : undefined,
      scale_locality_weight: isSet(object.scale_locality_weight)
        ? globalThis.Boolean(object.scale_locality_weight)
        : undefined,
      panic_mode_any: isSet(object.panic_mode_any) ? globalThis.Boolean(object.panic_mode_any) : undefined,
      list_as_any: isSet(object.list_as_any) ? globalThis.Boolean(object.list_as_any) : undefined,
      metadata_fallback_policy: isSet(object.metadata_fallback_policy)
        ? subset_LbSubsetMetadataFallbackPolicyFromJSON(object.metadata_fallback_policy)
        : undefined,
      subset_lb_policy: isSet(object.subset_lb_policy)
        ? LoadBalancingPolicy.fromJSON(object.subset_lb_policy)
        : undefined,
    };
  },

  toJSON(message: Subset): unknown {
    const obj: any = {};
    if (message.fallback_policy !== undefined) {
      obj.fallback_policy = subset_LbSubsetFallbackPolicyToJSON(message.fallback_policy);
    }
    if (message.default_subset !== undefined) {
      obj.default_subset = message.default_subset;
    }
    if (message.subset_selectors?.length) {
      obj.subset_selectors = message.subset_selectors.map((e) => Subset_LbSubsetSelector.toJSON(e));
    }
    if (message.allow_redundant_keys !== undefined) {
      obj.allow_redundant_keys = message.allow_redundant_keys;
    }
    if (message.locality_weight_aware !== undefined) {
      obj.locality_weight_aware = message.locality_weight_aware;
    }
    if (message.scale_locality_weight !== undefined) {
      obj.scale_locality_weight = message.scale_locality_weight;
    }
    if (message.panic_mode_any !== undefined) {
      obj.panic_mode_any = message.panic_mode_any;
    }
    if (message.list_as_any !== undefined) {
      obj.list_as_any = message.list_as_any;
    }
    if (message.metadata_fallback_policy !== undefined) {
      obj.metadata_fallback_policy = subset_LbSubsetMetadataFallbackPolicyToJSON(message.metadata_fallback_policy);
    }
    if (message.subset_lb_policy !== undefined) {
      obj.subset_lb_policy = LoadBalancingPolicy.toJSON(message.subset_lb_policy);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Subset>, I>>(base?: I): Subset {
    return Subset.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Subset>, I>>(object: I): Subset {
    const message = createBaseSubset();
    message.fallback_policy = object.fallback_policy ?? undefined;
    message.default_subset = object.default_subset ?? undefined;
    message.subset_selectors = object.subset_selectors?.map((e) => Subset_LbSubsetSelector.fromPartial(e)) || undefined;
    message.allow_redundant_keys = object.allow_redundant_keys ?? undefined;
    message.locality_weight_aware = object.locality_weight_aware ?? undefined;
    message.scale_locality_weight = object.scale_locality_weight ?? undefined;
    message.panic_mode_any = object.panic_mode_any ?? undefined;
    message.list_as_any = object.list_as_any ?? undefined;
    message.metadata_fallback_policy = object.metadata_fallback_policy ?? undefined;
    message.subset_lb_policy = (object.subset_lb_policy !== undefined && object.subset_lb_policy !== null)
      ? LoadBalancingPolicy.fromPartial(object.subset_lb_policy)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Subset.$type, Subset);

function createBaseSubset_LbSubsetSelector(): Subset_LbSubsetSelector {
  return { $type: "envoy.extensions.load_balancing_policies.subset.v3.Subset.LbSubsetSelector" };
}

export const Subset_LbSubsetSelector: MessageFns<
  Subset_LbSubsetSelector,
  "envoy.extensions.load_balancing_policies.subset.v3.Subset.LbSubsetSelector"
> = {
  $type: "envoy.extensions.load_balancing_policies.subset.v3.Subset.LbSubsetSelector" as const,

  encode(message: Subset_LbSubsetSelector, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keys !== undefined && message.keys.length !== 0) {
      for (const v of message.keys) {
        writer.uint32(10).string(v!);
      }
    }
    if (message.single_host_per_subset !== undefined && message.single_host_per_subset !== false) {
      writer.uint32(32).bool(message.single_host_per_subset);
    }
    if (
      message.fallback_policy !== undefined &&
      message.fallback_policy !== Subset_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.NOT_DEFINED
    ) {
      writer.uint32(16).int32(subset_LbSubsetSelector_LbSubsetSelectorFallbackPolicyToNumber(message.fallback_policy));
    }
    if (message.fallback_keys_subset !== undefined && message.fallback_keys_subset.length !== 0) {
      for (const v of message.fallback_keys_subset) {
        writer.uint32(26).string(v!);
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Subset_LbSubsetSelector {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubset_LbSubsetSelector();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.keys === undefined) {
            message.keys = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.keys!.push(el);
          }
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.single_host_per_subset = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.fallback_policy = subset_LbSubsetSelector_LbSubsetSelectorFallbackPolicyFromJSON(reader.int32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.fallback_keys_subset === undefined) {
            message.fallback_keys_subset = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.fallback_keys_subset!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Subset_LbSubsetSelector {
    return {
      $type: Subset_LbSubsetSelector.$type,
      keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e: any) => globalThis.String(e)) : undefined,
      single_host_per_subset: isSet(object.single_host_per_subset)
        ? globalThis.Boolean(object.single_host_per_subset)
        : undefined,
      fallback_policy: isSet(object.fallback_policy)
        ? subset_LbSubsetSelector_LbSubsetSelectorFallbackPolicyFromJSON(object.fallback_policy)
        : undefined,
      fallback_keys_subset: globalThis.Array.isArray(object?.fallback_keys_subset)
        ? object.fallback_keys_subset.map((e: any) => globalThis.String(e))
        : undefined,
    };
  },

  toJSON(message: Subset_LbSubsetSelector): unknown {
    const obj: any = {};
    if (message.keys?.length) {
      obj.keys = message.keys;
    }
    if (message.single_host_per_subset !== undefined) {
      obj.single_host_per_subset = message.single_host_per_subset;
    }
    if (message.fallback_policy !== undefined) {
      obj.fallback_policy = subset_LbSubsetSelector_LbSubsetSelectorFallbackPolicyToJSON(message.fallback_policy);
    }
    if (message.fallback_keys_subset?.length) {
      obj.fallback_keys_subset = message.fallback_keys_subset;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Subset_LbSubsetSelector>, I>>(base?: I): Subset_LbSubsetSelector {
    return Subset_LbSubsetSelector.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Subset_LbSubsetSelector>, I>>(object: I): Subset_LbSubsetSelector {
    const message = createBaseSubset_LbSubsetSelector();
    message.keys = object.keys?.map((e) => e) || undefined;
    message.single_host_per_subset = object.single_host_per_subset ?? undefined;
    message.fallback_policy = object.fallback_policy ?? undefined;
    message.fallback_keys_subset = object.fallback_keys_subset?.map((e) => e) || undefined;
    return message;
  },
};

messageTypeRegistry.set(Subset_LbSubsetSelector.$type, Subset_LbSubsetSelector);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
