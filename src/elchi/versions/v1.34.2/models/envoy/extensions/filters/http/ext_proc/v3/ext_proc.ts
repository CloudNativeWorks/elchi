// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/filters/http/ext_proc/v3/ext_proc.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../../../../google/protobuf/duration";
import { Struct } from "../../../../../../google/protobuf/struct";
import { messageTypeRegistry } from "../../../../../../typeRegistry";
import { HeaderMutationRules } from "../../../../../config/common/mutation_rules/v3/mutation_rules";
import { HeaderValue } from "../../../../../config/core/v3/base";
import { TypedExtensionConfig } from "../../../../../config/core/v3/extension";
import { GrpcService } from "../../../../../config/core/v3/grpc_service";
import { HttpService } from "../../../../../config/core/v3/http_service";
import { ListStringMatcher } from "../../../../../type/matcher/v3/string";
import { ProcessingMode } from "./processing_mode";

export const protobufPackage = "envoy.extensions.filters.http.ext_proc.v3";

/**
 * The filter communicates with an external gRPC service called an "external processor"
 * that can do a variety of things with the request and response:
 *
 * * Access and modify the HTTP headers on the request, response, or both
 * * Access and modify the HTTP request and response bodies
 * * Access and modify the dynamic stream metadata
 * * Immediately send an HTTP response downstream and terminate other processing
 *
 * The filter communicates with the server using a gRPC bidirectional stream. After the initial
 * request, the external server is in control over what additional data is sent to it
 * and how it should be processed.
 *
 * By implementing the protocol specified by the stream, the external server can choose:
 *
 * * Whether it receives the response message at all
 * * Whether it receives the message body at all, in separate chunks, or as a single buffer
 * * Whether subsequent HTTP requests are transmitted synchronously or whether they are
 *   sent asynchronously.
 * * To modify request or response trailers if they already exist
 *
 * The filter supports up to six different processing steps. Each is represented by
 * a gRPC stream message that is sent to the external processor. For each message, the
 * processor must send a matching response.
 *
 * * Request headers: Contains the headers from the original HTTP request.
 * * Request body: Delivered if they are present and sent in a single message if
 *   the BUFFERED or BUFFERED_PARTIAL mode is chosen, in multiple messages if the
 *   STREAMED mode is chosen, and not at all otherwise.
 * * Request trailers: Delivered if they are present and if the trailer mode is set
 *   to SEND.
 * * Response headers: Contains the headers from the HTTP response. Keep in mind
 *   that if the upstream system sends them before processing the request body that
 *   this message may arrive before the complete body.
 * * Response body: Sent according to the processing mode like the request body.
 * * Response trailers: Delivered according to the processing mode like the
 *   request trailers.
 *
 * By default, the processor sends only the request and response headers messages.
 * This may be changed to include any of the six steps by changing the processing_mode
 * setting of the filter configuration, or by setting the mode_override of any response
 * from the external processor. The latter is only enabled if allow_mode_override is
 * set to true. This way, a processor may, for example, use information
 * in the request header to determine whether the message body must be examined, or whether
 * the proxy should simply stream it straight through.
 *
 * All of this together allows a server to process the filter traffic in fairly
 * sophisticated ways. For example:
 *
 * * A server may choose to examine all or part of the HTTP message bodies depending
 *   on the content of the headers.
 * * A server may choose to immediately reject some messages based on their HTTP
 *   headers (or other dynamic metadata) and more carefully examine others.
 * * A server may asynchronously monitor traffic coming through the filter by inspecting
 *   headers, bodies, or both, and then decide to switch to a synchronous processing
 *   mode, either permanently or temporarily.
 *
 * The protocol itself is based on a bidirectional gRPC stream. Envoy will send the
 * server
 * :ref:`ProcessingRequest <envoy_v3_api_msg_service.ext_proc.v3.ProcessingRequest>`
 * messages, and the server must reply with
 * :ref:`ProcessingResponse <envoy_v3_api_msg_service.ext_proc.v3.ProcessingResponse>`.
 *
 * Stats about each gRPC call are recorded in a :ref:`dynamic filter state
 * <arch_overview_advanced_filter_state_sharing>` object in a namespace matching the filter
 * name.
 *
 * [#next-free-field: 24]
 */
export interface ExternalProcessor {
  $type: "envoy.extensions.filters.http.ext_proc.v3.ExternalProcessor";
  /**
   * Configuration for the gRPC service that the filter will communicate with.
   * The filter supports both the "Envoy" and "Google" gRPC clients.
   * Only one of ``grpc_service`` or ``http_service`` can be set.
   * It is required that one of them must be set.
   */
  grpc_service?:
    | GrpcService
    | undefined;
  /**
   * Configuration for the HTTP service that the filter will communicate with.
   * Only one of ``http_service`` or
   * :ref:`grpc_service <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.grpc_service>`.
   * can be set. It is required that one of them must be set.
   *
   * If ``http_service`` is set, the
   * :ref:`processing_mode <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.processing_mode>`
   * can not be configured to send any body or trailers. i.e, http_service only supports
   * sending request or response headers to the side stream server.
   *
   * With this configuration, Envoy behavior:
   *
   * 1. The headers are first put in a proto message
   * :ref:`ProcessingRequest <envoy_v3_api_msg_service.ext_proc.v3.ProcessingRequest>`.
   *
   * 2. This proto message is then transcoded into a JSON text.
   *
   * 3. Envoy then sends a HTTP POST message with content-type as "application/json",
   * and this JSON text as body to the side stream server.
   *
   * After the side-stream receives this HTTP request message, it is expected to do as follows:
   *
   * 1. It converts the body, which is a JSON string, into a ``ProcessingRequest``
   * proto message to examine and mutate the headers.
   *
   * 2. It then sets the mutated headers into a new proto message
   * :ref:`ProcessingResponse <envoy_v3_api_msg_service.ext_proc.v3.ProcessingResponse>`.
   *
   * 3. It converts ``ProcessingResponse`` proto message into a JSON text.
   *
   * 4. It then sends a HTTP response back to Envoy with status code as "200",
   * content-type as "application/json" and sets the JSON text as the body.
   */
  http_service?:
    | ExtProcHttpService
    | undefined;
  /**
   * By default, if the gRPC stream cannot be established, or if it is closed
   * prematurely with an error, the filter will fail. Specifically, if the
   * response headers have not yet been delivered, then it will return a 500
   * error downstream. If they have been delivered, then instead the HTTP stream to the
   * downstream client will be reset.
   * With this parameter set to true, however, then if the gRPC stream is prematurely closed
   * or could not be opened, processing continues without error.
   */
  failure_mode_allow?:
    | boolean
    | undefined;
  /**
   * Specifies default options for how HTTP headers, trailers, and bodies are
   * sent. See ProcessingMode for details.
   */
  processing_mode?:
    | ProcessingMode
    | undefined;
  /**
   * Envoy provides a number of :ref:`attributes <arch_overview_attributes>`
   * for expressive policies. Each attribute name provided in this field will be
   * matched against that list and populated in the request_headers message.
   * See the :ref:`attribute documentation <arch_overview_request_attributes>`
   * for the list of supported attributes and their types.
   */
  request_attributes?:
    | string[]
    | undefined;
  /**
   * Envoy provides a number of :ref:`attributes <arch_overview_attributes>`
   * for expressive policies. Each attribute name provided in this field will be
   * matched against that list and populated in the response_headers message.
   * See the :ref:`attribute documentation <arch_overview_attributes>`
   * for the list of supported attributes and their types.
   */
  response_attributes?:
    | string[]
    | undefined;
  /**
   * Specifies the timeout for each individual message sent on the stream and
   * when the filter is running in synchronous mode. Whenever the proxy sends
   * a message on the stream that requires a response, it will reset this timer,
   * and will stop processing and return an error (subject to the processing mode)
   * if the timer expires before a matching response is received. There is no
   * timeout when the filter is running in asynchronous mode. Zero is a valid
   * config which means the timer will be triggered immediately. If not
   * configured, default is 200 milliseconds.
   */
  message_timeout?:
    | Duration
    | undefined;
  /**
   * Optional additional prefix to use when emitting statistics. This allows to distinguish
   * emitted statistics between configured *ext_proc* filters in an HTTP filter chain.
   */
  stat_prefix?:
    | string
    | undefined;
  /**
   * Rules that determine what modifications an external processing server may
   * make to message headers. If not set, all headers may be modified except
   * for "host", ":authority", ":scheme", ":method", and headers that start
   * with the header prefix set via
   * :ref:`header_prefix <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.header_prefix>`
   * (which is usually "x-envoy").
   * Note that changing headers such as "host" or ":authority" may not in itself
   * change Envoy's routing decision, as routes can be cached. To also force the
   * route to be recomputed, set the
   * :ref:`clear_route_cache <envoy_v3_api_field_service.ext_proc.v3.CommonResponse.clear_route_cache>`
   * field to true in the same response.
   */
  mutation_rules?:
    | HeaderMutationRules
    | undefined;
  /**
   * Specify the upper bound of
   * :ref:`override_message_timeout <envoy_v3_api_field_service.ext_proc.v3.ProcessingResponse.override_message_timeout>`
   * If not specified, by default it is 0, which will effectively disable the ``override_message_timeout`` API.
   */
  max_message_timeout?:
    | Duration
    | undefined;
  /**
   * Allow headers matching the ``forward_rules`` to be forwarded to the external processing server.
   * If not set, all headers are forwarded to the external processing server.
   */
  forward_rules?:
    | HeaderForwardingRules
    | undefined;
  /**
   * Additional metadata to be added to the filter state for logging purposes. The metadata
   * will be added to StreamInfo's filter state under the namespace corresponding to the
   * ext_proc filter name.
   */
  filter_metadata?:
    | { [key: string]: any }
    | undefined;
  /**
   * If ``allow_mode_override`` is set to true, the filter config :ref:`processing_mode
   * <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.processing_mode>`
   * can be overridden by the response message from the external processing server
   * :ref:`mode_override <envoy_v3_api_field_service.ext_proc.v3.ProcessingResponse.mode_override>`.
   * If not set, ``mode_override`` API in the response message will be ignored.
   */
  allow_mode_override?:
    | boolean
    | undefined;
  /**
   * If set to true, ignore the
   * :ref:`immediate_response <envoy_v3_api_field_service.ext_proc.v3.ProcessingResponse.immediate_response>`
   * message in an external processor response. In such case, no local reply will be sent.
   * Instead, the stream to the external processor will be closed. There will be no
   * more external processing for this stream from now on.
   */
  disable_immediate_response?:
    | boolean
    | undefined;
  /** Options related to the sending and receiving of dynamic metadata. */
  metadata_options?:
    | MetadataOptions
    | undefined;
  /**
   * If true, send each part of the HTTP request or response specified by ProcessingMode
   * without pausing on filter chain iteration. It is "Send and Go" mode that can be used
   * by external processor to observe Envoy data and status. In this mode:
   *
   * 1. Only STREAMED body processing mode is supported and any other body processing modes will be
   * ignored. NONE mode(i.e., skip body processing) will still work as expected.
   *
   * 2. External processor should not send back processing response, as any responses will be ignored.
   * This also means that
   * :ref:`message_timeout <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.message_timeout>`
   * restriction doesn't apply to this mode.
   *
   * 3. External processor may still close the stream to indicate that no more messages are needed.
   *
   * .. warning::
   *
   *    Flow control is necessary mechanism to prevent the fast sender (either downstream client or upstream server)
   *    from overwhelming the external processor when its processing speed is slower.
   *    This protective measure is being explored and developed but has not been ready yet, so please use your own
   *    discretion when enabling this feature.
   *    This work is currently tracked under https://github.com/envoyproxy/envoy/issues/33319.
   */
  observability_mode?:
    | boolean
    | undefined;
  /**
   * Prevents clearing the route-cache when the
   * :ref:`clear_route_cache <envoy_v3_api_field_service.ext_proc.v3.CommonResponse.clear_route_cache>`
   * field is set in an external processor response.
   * Only one of ``disable_clear_route_cache`` or ``route_cache_action`` can be set.
   * It is recommended to set ``route_cache_action`` which supersedes ``disable_clear_route_cache``.
   */
  disable_clear_route_cache?:
    | boolean
    | undefined;
  /**
   * Specifies the action to be taken when an external processor response is
   * received in response to request headers. It is recommended to set this field than set
   * :ref:`disable_clear_route_cache <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.disable_clear_route_cache>`.
   * Only one of ``disable_clear_route_cache`` or ``route_cache_action`` can be set.
   */
  route_cache_action?:
    | ExternalProcessor_RouteCacheAction
    | undefined;
  /**
   * Specifies the deferred closure timeout for gRPC stream that connects to external processor. Currently, the deferred stream closure
   * is only used in :ref:`observability_mode <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.observability_mode>`.
   * In observability mode, gRPC streams may be held open to the external processor longer than the lifetime of the regular client to
   * backend stream lifetime. In this case, Envoy will eventually timeout the external processor stream according to this time limit.
   * The default value is 5000 milliseconds (5 seconds) if not specified.
   */
  deferred_close_timeout?:
    | Duration
    | undefined;
  /**
   * Send body to the side stream server once it arrives without waiting for the header response from that server.
   * It only works for STREAMED body processing mode. For any other body processing modes, it is ignored.
   * The server has two options upon receiving a header request:
   *
   * 1. Instant Response: send the header response as soon as the header request is received.
   *
   * 2. Delayed Response: wait for the body before sending any response.
   *
   * In all scenarios, the header-body ordering must always be maintained.
   *
   * If enabled Envoy will ignore the
   * :ref:`mode_override <envoy_v3_api_field_service.ext_proc.v3.ProcessingResponse.mode_override>`
   * value that the server sends in the header response. This is because Envoy may have already
   * sent the body to the server, prior to processing the header response.
   */
  send_body_without_waiting_for_header_response?:
    | boolean
    | undefined;
  /**
   * When :ref:`allow_mode_override
   * <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.allow_mode_override>` is enabled and
   * ``allowed_override_modes`` is configured, the filter config :ref:`processing_mode
   * <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.processing_mode>`
   * can only be overridden by the response message from the external processing server iff the
   * :ref:`mode_override <envoy_v3_api_field_service.ext_proc.v3.ProcessingResponse.mode_override>` is allowed by
   * the ``allowed_override_modes`` allow-list below.
   * Since request_header_mode is not applicable in any way, it's ignored in comparison.
   */
  allowed_override_modes?:
    | ProcessingMode[]
    | undefined;
  /**
   * Decorator to introduce custom logic that runs after a message received from
   * the External Processor is processed, but before continuing filter chain iteration.
   *
   * .. note::
   *   Response processors are currently in alpha.
   *
   * [#extension-category: envoy.http.ext_proc.response_processors]
   */
  on_processing_response?: TypedExtensionConfig | undefined;
}

/**
 * Describes the route cache action to be taken when an external processor response
 * is received in response to request headers.
 */
export enum ExternalProcessor_RouteCacheAction {
  /**
   * DEFAULT - The default behavior is to clear the route cache only when the
   * :ref:`clear_route_cache <envoy_v3_api_field_service.ext_proc.v3.CommonResponse.clear_route_cache>`
   * field is set in an external processor response.
   */
  DEFAULT = "DEFAULT",
  /**
   * CLEAR - Always clear the route cache irrespective of the clear_route_cache bit in
   * the external processor response.
   */
  CLEAR = "CLEAR",
  /**
   * RETAIN - Do not clear the route cache irrespective of the clear_route_cache bit in
   * the external processor response. Setting to RETAIN is equivalent to set the
   * :ref:`disable_clear_route_cache <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.disable_clear_route_cache>`
   * to true.
   */
  RETAIN = "RETAIN",
}

export function externalProcessor_RouteCacheActionFromJSON(object: any): ExternalProcessor_RouteCacheAction {
  switch (object) {
    case 0:
    case "DEFAULT":
      return ExternalProcessor_RouteCacheAction.DEFAULT;
    case 1:
    case "CLEAR":
      return ExternalProcessor_RouteCacheAction.CLEAR;
    case 2:
    case "RETAIN":
      return ExternalProcessor_RouteCacheAction.RETAIN;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ExternalProcessor_RouteCacheAction");
  }
}

export function externalProcessor_RouteCacheActionToJSON(object: ExternalProcessor_RouteCacheAction): string {
  switch (object) {
    case ExternalProcessor_RouteCacheAction.DEFAULT:
      return "DEFAULT";
    case ExternalProcessor_RouteCacheAction.CLEAR:
      return "CLEAR";
    case ExternalProcessor_RouteCacheAction.RETAIN:
      return "RETAIN";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ExternalProcessor_RouteCacheAction");
  }
}

export function externalProcessor_RouteCacheActionToNumber(object: ExternalProcessor_RouteCacheAction): number {
  switch (object) {
    case ExternalProcessor_RouteCacheAction.DEFAULT:
      return 0;
    case ExternalProcessor_RouteCacheAction.CLEAR:
      return 1;
    case ExternalProcessor_RouteCacheAction.RETAIN:
      return 2;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ExternalProcessor_RouteCacheAction");
  }
}

/** ExtProcHttpService is used for HTTP communication between the filter and the external processing service. */
export interface ExtProcHttpService {
  $type: "envoy.extensions.filters.http.ext_proc.v3.ExtProcHttpService";
  /** Sets the HTTP service which the external processing requests must be sent to. */
  http_service?: HttpService | undefined;
}

/**
 * The MetadataOptions structure defines options for the sending and receiving of
 * dynamic metadata. Specifically, which namespaces to send to the server, whether
 * metadata returned by the server may be written, and how that metadata may be written.
 */
export interface MetadataOptions {
  $type: "envoy.extensions.filters.http.ext_proc.v3.MetadataOptions";
  /**
   * Describes which typed or untyped dynamic metadata namespaces to forward to
   * the external processing server.
   */
  forwarding_namespaces?:
    | MetadataOptions_MetadataNamespaces
    | undefined;
  /**
   * Describes which typed or untyped dynamic metadata namespaces to accept from
   * the external processing server. Set to empty or leave unset to disallow writing
   * any received dynamic metadata. Receiving of typed metadata is not supported.
   */
  receiving_namespaces?: MetadataOptions_MetadataNamespaces | undefined;
}

export interface MetadataOptions_MetadataNamespaces {
  $type: "envoy.extensions.filters.http.ext_proc.v3.MetadataOptions.MetadataNamespaces";
  /**
   * Specifies a list of metadata namespaces whose values, if present,
   * will be passed to the ext_proc service as an opaque *protobuf::Struct*.
   */
  untyped?:
    | string[]
    | undefined;
  /**
   * Specifies a list of metadata namespaces whose values, if present,
   * will be passed to the ext_proc service as a *protobuf::Any*. This allows
   * envoy and the external processing server to share the protobuf message
   * definition for safe parsing.
   */
  typed?: string[] | undefined;
}

/**
 * The HeaderForwardingRules structure specifies what headers are
 * allowed to be forwarded to the external processing server.
 *
 * This works as below:
 *
 *   1. If neither ``allowed_headers`` nor ``disallowed_headers`` is set, all headers are forwarded.
 *   2. If both ``allowed_headers`` and ``disallowed_headers`` are set, only headers in the
 *      ``allowed_headers`` but not in the ``disallowed_headers`` are forwarded.
 *   3. If ``allowed_headers`` is set, and ``disallowed_headers`` is not set, only headers in
 *      the ``allowed_headers`` are forwarded.
 *   4. If ``disallowed_headers`` is set, and ``allowed_headers`` is not set, all headers except
 *      headers in the ``disallowed_headers`` are forwarded.
 */
export interface HeaderForwardingRules {
  $type: "envoy.extensions.filters.http.ext_proc.v3.HeaderForwardingRules";
  /**
   * If set, specifically allow any header in this list to be forwarded to the external
   * processing server. This can be overridden by the below ``disallowed_headers``.
   */
  allowed_headers?:
    | ListStringMatcher
    | undefined;
  /**
   * If set, specifically disallow any header in this list to be forwarded to the external
   * processing server. This overrides the above ``allowed_headers`` if a header matches both.
   */
  disallowed_headers?: ListStringMatcher | undefined;
}

/**
 * Extra settings that may be added to per-route configuration for a
 * virtual host or cluster.
 */
export interface ExtProcPerRoute {
  $type: "envoy.extensions.filters.http.ext_proc.v3.ExtProcPerRoute";
  override?:
    | //
    /**
     * Disable the filter for this particular vhost or route.
     * If disabled is specified in multiple per-filter-configs, the most specific one will be used.
     */
    { $case: "disabled"; disabled: boolean }
    | //
    /**
     * Override aspects of the configuration for this route. A set of
     * overrides in a more specific configuration will override a "disabled"
     * flag set in a less-specific one.
     */
    { $case: "overrides"; overrides: ExtProcOverrides }
    | undefined;
}

/**
 * Overrides that may be set on a per-route basis
 * [#next-free-field: 8]
 */
export interface ExtProcOverrides {
  $type: "envoy.extensions.filters.http.ext_proc.v3.ExtProcOverrides";
  /** Set a different processing mode for this route than the default. */
  processing_mode?:
    | ProcessingMode
    | undefined;
  /**
   * [#not-implemented-hide:]
   * Set a different asynchronous processing option than the default.
   */
  async_mode?:
    | boolean
    | undefined;
  /**
   * [#not-implemented-hide:]
   * Set different optional attributes than the default setting of the
   * ``request_attributes`` field.
   */
  request_attributes?:
    | string[]
    | undefined;
  /**
   * [#not-implemented-hide:]
   * Set different optional properties than the default setting of the
   * ``response_attributes`` field.
   */
  response_attributes?:
    | string[]
    | undefined;
  /** Set a different gRPC service for this route than the default. */
  grpc_service?:
    | GrpcService
    | undefined;
  /**
   * Options related to the sending and receiving of dynamic metadata.
   * Lists of forwarding and receiving namespaces will be overridden in their entirety,
   * meaning the most-specific config that specifies this override will be the final
   * config used. It is the prerogative of the control plane to ensure this
   * most-specific config contains the correct final overrides.
   */
  metadata_options?:
    | MetadataOptions
    | undefined;
  /**
   * Additional metadata to include into streams initiated to the ext_proc gRPC
   * service. This can be used for scenarios in which additional ad hoc
   * authorization headers (e.g. ``x-foo-bar: baz-key``) are to be injected or
   * when a route needs to partially override inherited metadata.
   */
  grpc_initial_metadata?: HeaderValue[] | undefined;
}

function createBaseExternalProcessor(): ExternalProcessor {
  return { $type: "envoy.extensions.filters.http.ext_proc.v3.ExternalProcessor" };
}

export const ExternalProcessor: MessageFns<
  ExternalProcessor,
  "envoy.extensions.filters.http.ext_proc.v3.ExternalProcessor"
> = {
  $type: "envoy.extensions.filters.http.ext_proc.v3.ExternalProcessor" as const,

  encode(message: ExternalProcessor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.grpc_service !== undefined) {
      GrpcService.encode(message.grpc_service, writer.uint32(10).fork()).join();
    }
    if (message.http_service !== undefined) {
      ExtProcHttpService.encode(message.http_service, writer.uint32(162).fork()).join();
    }
    if (message.failure_mode_allow !== undefined && message.failure_mode_allow !== false) {
      writer.uint32(16).bool(message.failure_mode_allow);
    }
    if (message.processing_mode !== undefined) {
      ProcessingMode.encode(message.processing_mode, writer.uint32(26).fork()).join();
    }
    if (message.request_attributes !== undefined && message.request_attributes.length !== 0) {
      for (const v of message.request_attributes) {
        writer.uint32(42).string(v!);
      }
    }
    if (message.response_attributes !== undefined && message.response_attributes.length !== 0) {
      for (const v of message.response_attributes) {
        writer.uint32(50).string(v!);
      }
    }
    if (message.message_timeout !== undefined) {
      Duration.encode(message.message_timeout, writer.uint32(58).fork()).join();
    }
    if (message.stat_prefix !== undefined && message.stat_prefix !== "") {
      writer.uint32(66).string(message.stat_prefix);
    }
    if (message.mutation_rules !== undefined) {
      HeaderMutationRules.encode(message.mutation_rules, writer.uint32(74).fork()).join();
    }
    if (message.max_message_timeout !== undefined) {
      Duration.encode(message.max_message_timeout, writer.uint32(82).fork()).join();
    }
    if (message.forward_rules !== undefined) {
      HeaderForwardingRules.encode(message.forward_rules, writer.uint32(98).fork()).join();
    }
    if (message.filter_metadata !== undefined) {
      Struct.encode(Struct.wrap(message.filter_metadata), writer.uint32(106).fork()).join();
    }
    if (message.allow_mode_override !== undefined && message.allow_mode_override !== false) {
      writer.uint32(112).bool(message.allow_mode_override);
    }
    if (message.disable_immediate_response !== undefined && message.disable_immediate_response !== false) {
      writer.uint32(120).bool(message.disable_immediate_response);
    }
    if (message.metadata_options !== undefined) {
      MetadataOptions.encode(message.metadata_options, writer.uint32(130).fork()).join();
    }
    if (message.observability_mode !== undefined && message.observability_mode !== false) {
      writer.uint32(136).bool(message.observability_mode);
    }
    if (message.disable_clear_route_cache !== undefined && message.disable_clear_route_cache !== false) {
      writer.uint32(88).bool(message.disable_clear_route_cache);
    }
    if (
      message.route_cache_action !== undefined &&
      message.route_cache_action !== ExternalProcessor_RouteCacheAction.DEFAULT
    ) {
      writer.uint32(144).int32(externalProcessor_RouteCacheActionToNumber(message.route_cache_action));
    }
    if (message.deferred_close_timeout !== undefined) {
      Duration.encode(message.deferred_close_timeout, writer.uint32(154).fork()).join();
    }
    if (
      message.send_body_without_waiting_for_header_response !== undefined &&
      message.send_body_without_waiting_for_header_response !== false
    ) {
      writer.uint32(168).bool(message.send_body_without_waiting_for_header_response);
    }
    if (message.allowed_override_modes !== undefined && message.allowed_override_modes.length !== 0) {
      for (const v of message.allowed_override_modes) {
        ProcessingMode.encode(v!, writer.uint32(178).fork()).join();
      }
    }
    if (message.on_processing_response !== undefined) {
      TypedExtensionConfig.encode(message.on_processing_response, writer.uint32(186).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExternalProcessor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExternalProcessor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.grpc_service = GrpcService.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.http_service = ExtProcHttpService.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.failure_mode_allow = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.processing_mode = ProcessingMode.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          if (message.request_attributes === undefined) {
            message.request_attributes = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.request_attributes!.push(el);
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          if (message.response_attributes === undefined) {
            message.response_attributes = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.response_attributes!.push(el);
          }
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.message_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.stat_prefix = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.mutation_rules = HeaderMutationRules.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.max_message_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.forward_rules = HeaderForwardingRules.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.filter_metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.allow_mode_override = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.disable_immediate_response = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.metadata_options = MetadataOptions.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.observability_mode = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.disable_clear_route_cache = reader.bool();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.route_cache_action = externalProcessor_RouteCacheActionFromJSON(reader.int32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.deferred_close_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.send_body_without_waiting_for_header_response = reader.bool();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          if (message.allowed_override_modes === undefined) {
            message.allowed_override_modes = [];
          }
          const el = ProcessingMode.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.allowed_override_modes!.push(el);
          }
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.on_processing_response = TypedExtensionConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExternalProcessor {
    return {
      $type: ExternalProcessor.$type,
      grpc_service: isSet(object.grpc_service) ? GrpcService.fromJSON(object.grpc_service) : undefined,
      http_service: isSet(object.http_service) ? ExtProcHttpService.fromJSON(object.http_service) : undefined,
      failure_mode_allow: isSet(object.failure_mode_allow) ? globalThis.Boolean(object.failure_mode_allow) : undefined,
      processing_mode: isSet(object.processing_mode) ? ProcessingMode.fromJSON(object.processing_mode) : undefined,
      request_attributes: globalThis.Array.isArray(object?.request_attributes)
        ? object.request_attributes.map((e: any) => globalThis.String(e))
        : undefined,
      response_attributes: globalThis.Array.isArray(object?.response_attributes)
        ? object.response_attributes.map((e: any) => globalThis.String(e))
        : undefined,
      message_timeout: isSet(object.message_timeout) ? Duration.fromJSON(object.message_timeout) : undefined,
      stat_prefix: isSet(object.stat_prefix) ? globalThis.String(object.stat_prefix) : undefined,
      mutation_rules: isSet(object.mutation_rules) ? HeaderMutationRules.fromJSON(object.mutation_rules) : undefined,
      max_message_timeout: isSet(object.max_message_timeout)
        ? Duration.fromJSON(object.max_message_timeout)
        : undefined,
      forward_rules: isSet(object.forward_rules) ? HeaderForwardingRules.fromJSON(object.forward_rules) : undefined,
      filter_metadata: isObject(object.filter_metadata) ? object.filter_metadata : undefined,
      allow_mode_override: isSet(object.allow_mode_override)
        ? globalThis.Boolean(object.allow_mode_override)
        : undefined,
      disable_immediate_response: isSet(object.disable_immediate_response)
        ? globalThis.Boolean(object.disable_immediate_response)
        : undefined,
      metadata_options: isSet(object.metadata_options) ? MetadataOptions.fromJSON(object.metadata_options) : undefined,
      observability_mode: isSet(object.observability_mode) ? globalThis.Boolean(object.observability_mode) : undefined,
      disable_clear_route_cache: isSet(object.disable_clear_route_cache)
        ? globalThis.Boolean(object.disable_clear_route_cache)
        : undefined,
      route_cache_action: isSet(object.route_cache_action)
        ? externalProcessor_RouteCacheActionFromJSON(object.route_cache_action)
        : undefined,
      deferred_close_timeout: isSet(object.deferred_close_timeout)
        ? Duration.fromJSON(object.deferred_close_timeout)
        : undefined,
      send_body_without_waiting_for_header_response: isSet(object.send_body_without_waiting_for_header_response)
        ? globalThis.Boolean(object.send_body_without_waiting_for_header_response)
        : undefined,
      allowed_override_modes: globalThis.Array.isArray(object?.allowed_override_modes)
        ? object.allowed_override_modes.map((e: any) => ProcessingMode.fromJSON(e))
        : undefined,
      on_processing_response: isSet(object.on_processing_response)
        ? TypedExtensionConfig.fromJSON(object.on_processing_response)
        : undefined,
    };
  },

  toJSON(message: ExternalProcessor): unknown {
    const obj: any = {};
    if (message.grpc_service !== undefined) {
      obj.grpc_service = GrpcService.toJSON(message.grpc_service);
    }
    if (message.http_service !== undefined) {
      obj.http_service = ExtProcHttpService.toJSON(message.http_service);
    }
    if (message.failure_mode_allow !== undefined) {
      obj.failure_mode_allow = message.failure_mode_allow;
    }
    if (message.processing_mode !== undefined) {
      obj.processing_mode = ProcessingMode.toJSON(message.processing_mode);
    }
    if (message.request_attributes?.length) {
      obj.request_attributes = message.request_attributes;
    }
    if (message.response_attributes?.length) {
      obj.response_attributes = message.response_attributes;
    }
    if (message.message_timeout !== undefined) {
      obj.message_timeout = Duration.toJSON(message.message_timeout);
    }
    if (message.stat_prefix !== undefined) {
      obj.stat_prefix = message.stat_prefix;
    }
    if (message.mutation_rules !== undefined) {
      obj.mutation_rules = HeaderMutationRules.toJSON(message.mutation_rules);
    }
    if (message.max_message_timeout !== undefined) {
      obj.max_message_timeout = Duration.toJSON(message.max_message_timeout);
    }
    if (message.forward_rules !== undefined) {
      obj.forward_rules = HeaderForwardingRules.toJSON(message.forward_rules);
    }
    if (message.filter_metadata !== undefined) {
      obj.filter_metadata = message.filter_metadata;
    }
    if (message.allow_mode_override !== undefined) {
      obj.allow_mode_override = message.allow_mode_override;
    }
    if (message.disable_immediate_response !== undefined) {
      obj.disable_immediate_response = message.disable_immediate_response;
    }
    if (message.metadata_options !== undefined) {
      obj.metadata_options = MetadataOptions.toJSON(message.metadata_options);
    }
    if (message.observability_mode !== undefined) {
      obj.observability_mode = message.observability_mode;
    }
    if (message.disable_clear_route_cache !== undefined) {
      obj.disable_clear_route_cache = message.disable_clear_route_cache;
    }
    if (message.route_cache_action !== undefined) {
      obj.route_cache_action = externalProcessor_RouteCacheActionToJSON(message.route_cache_action);
    }
    if (message.deferred_close_timeout !== undefined) {
      obj.deferred_close_timeout = Duration.toJSON(message.deferred_close_timeout);
    }
    if (message.send_body_without_waiting_for_header_response !== undefined) {
      obj.send_body_without_waiting_for_header_response = message.send_body_without_waiting_for_header_response;
    }
    if (message.allowed_override_modes?.length) {
      obj.allowed_override_modes = message.allowed_override_modes.map((e) => ProcessingMode.toJSON(e));
    }
    if (message.on_processing_response !== undefined) {
      obj.on_processing_response = TypedExtensionConfig.toJSON(message.on_processing_response);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExternalProcessor>, I>>(base?: I): ExternalProcessor {
    return ExternalProcessor.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExternalProcessor>, I>>(object: I): ExternalProcessor {
    const message = createBaseExternalProcessor();
    message.grpc_service = (object.grpc_service !== undefined && object.grpc_service !== null)
      ? GrpcService.fromPartial(object.grpc_service)
      : undefined;
    message.http_service = (object.http_service !== undefined && object.http_service !== null)
      ? ExtProcHttpService.fromPartial(object.http_service)
      : undefined;
    message.failure_mode_allow = object.failure_mode_allow ?? undefined;
    message.processing_mode = (object.processing_mode !== undefined && object.processing_mode !== null)
      ? ProcessingMode.fromPartial(object.processing_mode)
      : undefined;
    message.request_attributes = object.request_attributes?.map((e) => e) || undefined;
    message.response_attributes = object.response_attributes?.map((e) => e) || undefined;
    message.message_timeout = (object.message_timeout !== undefined && object.message_timeout !== null)
      ? Duration.fromPartial(object.message_timeout)
      : undefined;
    message.stat_prefix = object.stat_prefix ?? undefined;
    message.mutation_rules = (object.mutation_rules !== undefined && object.mutation_rules !== null)
      ? HeaderMutationRules.fromPartial(object.mutation_rules)
      : undefined;
    message.max_message_timeout = (object.max_message_timeout !== undefined && object.max_message_timeout !== null)
      ? Duration.fromPartial(object.max_message_timeout)
      : undefined;
    message.forward_rules = (object.forward_rules !== undefined && object.forward_rules !== null)
      ? HeaderForwardingRules.fromPartial(object.forward_rules)
      : undefined;
    message.filter_metadata = object.filter_metadata ?? undefined;
    message.allow_mode_override = object.allow_mode_override ?? undefined;
    message.disable_immediate_response = object.disable_immediate_response ?? undefined;
    message.metadata_options = (object.metadata_options !== undefined && object.metadata_options !== null)
      ? MetadataOptions.fromPartial(object.metadata_options)
      : undefined;
    message.observability_mode = object.observability_mode ?? undefined;
    message.disable_clear_route_cache = object.disable_clear_route_cache ?? undefined;
    message.route_cache_action = object.route_cache_action ?? undefined;
    message.deferred_close_timeout =
      (object.deferred_close_timeout !== undefined && object.deferred_close_timeout !== null)
        ? Duration.fromPartial(object.deferred_close_timeout)
        : undefined;
    message.send_body_without_waiting_for_header_response = object.send_body_without_waiting_for_header_response ??
      undefined;
    message.allowed_override_modes = object.allowed_override_modes?.map((e) => ProcessingMode.fromPartial(e)) ||
      undefined;
    message.on_processing_response =
      (object.on_processing_response !== undefined && object.on_processing_response !== null)
        ? TypedExtensionConfig.fromPartial(object.on_processing_response)
        : undefined;
    return message;
  },
};

messageTypeRegistry.set(ExternalProcessor.$type, ExternalProcessor);

function createBaseExtProcHttpService(): ExtProcHttpService {
  return { $type: "envoy.extensions.filters.http.ext_proc.v3.ExtProcHttpService" };
}

export const ExtProcHttpService: MessageFns<
  ExtProcHttpService,
  "envoy.extensions.filters.http.ext_proc.v3.ExtProcHttpService"
> = {
  $type: "envoy.extensions.filters.http.ext_proc.v3.ExtProcHttpService" as const,

  encode(message: ExtProcHttpService, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.http_service !== undefined) {
      HttpService.encode(message.http_service, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExtProcHttpService {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExtProcHttpService();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.http_service = HttpService.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExtProcHttpService {
    return {
      $type: ExtProcHttpService.$type,
      http_service: isSet(object.http_service) ? HttpService.fromJSON(object.http_service) : undefined,
    };
  },

  toJSON(message: ExtProcHttpService): unknown {
    const obj: any = {};
    if (message.http_service !== undefined) {
      obj.http_service = HttpService.toJSON(message.http_service);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExtProcHttpService>, I>>(base?: I): ExtProcHttpService {
    return ExtProcHttpService.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExtProcHttpService>, I>>(object: I): ExtProcHttpService {
    const message = createBaseExtProcHttpService();
    message.http_service = (object.http_service !== undefined && object.http_service !== null)
      ? HttpService.fromPartial(object.http_service)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(ExtProcHttpService.$type, ExtProcHttpService);

function createBaseMetadataOptions(): MetadataOptions {
  return { $type: "envoy.extensions.filters.http.ext_proc.v3.MetadataOptions" };
}

export const MetadataOptions: MessageFns<MetadataOptions, "envoy.extensions.filters.http.ext_proc.v3.MetadataOptions"> =
  {
    $type: "envoy.extensions.filters.http.ext_proc.v3.MetadataOptions" as const,

    encode(message: MetadataOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
      if (message.forwarding_namespaces !== undefined) {
        MetadataOptions_MetadataNamespaces.encode(message.forwarding_namespaces, writer.uint32(10).fork()).join();
      }
      if (message.receiving_namespaces !== undefined) {
        MetadataOptions_MetadataNamespaces.encode(message.receiving_namespaces, writer.uint32(18).fork()).join();
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): MetadataOptions {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseMetadataOptions();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.forwarding_namespaces = MetadataOptions_MetadataNamespaces.decode(reader, reader.uint32());
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.receiving_namespaces = MetadataOptions_MetadataNamespaces.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): MetadataOptions {
      return {
        $type: MetadataOptions.$type,
        forwarding_namespaces: isSet(object.forwarding_namespaces)
          ? MetadataOptions_MetadataNamespaces.fromJSON(object.forwarding_namespaces)
          : undefined,
        receiving_namespaces: isSet(object.receiving_namespaces)
          ? MetadataOptions_MetadataNamespaces.fromJSON(object.receiving_namespaces)
          : undefined,
      };
    },

    toJSON(message: MetadataOptions): unknown {
      const obj: any = {};
      if (message.forwarding_namespaces !== undefined) {
        obj.forwarding_namespaces = MetadataOptions_MetadataNamespaces.toJSON(message.forwarding_namespaces);
      }
      if (message.receiving_namespaces !== undefined) {
        obj.receiving_namespaces = MetadataOptions_MetadataNamespaces.toJSON(message.receiving_namespaces);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<MetadataOptions>, I>>(base?: I): MetadataOptions {
      return MetadataOptions.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<MetadataOptions>, I>>(object: I): MetadataOptions {
      const message = createBaseMetadataOptions();
      message.forwarding_namespaces =
        (object.forwarding_namespaces !== undefined && object.forwarding_namespaces !== null)
          ? MetadataOptions_MetadataNamespaces.fromPartial(object.forwarding_namespaces)
          : undefined;
      message.receiving_namespaces = (object.receiving_namespaces !== undefined && object.receiving_namespaces !== null)
        ? MetadataOptions_MetadataNamespaces.fromPartial(object.receiving_namespaces)
        : undefined;
      return message;
    },
  };

messageTypeRegistry.set(MetadataOptions.$type, MetadataOptions);

function createBaseMetadataOptions_MetadataNamespaces(): MetadataOptions_MetadataNamespaces {
  return { $type: "envoy.extensions.filters.http.ext_proc.v3.MetadataOptions.MetadataNamespaces" };
}

export const MetadataOptions_MetadataNamespaces: MessageFns<
  MetadataOptions_MetadataNamespaces,
  "envoy.extensions.filters.http.ext_proc.v3.MetadataOptions.MetadataNamespaces"
> = {
  $type: "envoy.extensions.filters.http.ext_proc.v3.MetadataOptions.MetadataNamespaces" as const,

  encode(message: MetadataOptions_MetadataNamespaces, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.untyped !== undefined && message.untyped.length !== 0) {
      for (const v of message.untyped) {
        writer.uint32(10).string(v!);
      }
    }
    if (message.typed !== undefined && message.typed.length !== 0) {
      for (const v of message.typed) {
        writer.uint32(18).string(v!);
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MetadataOptions_MetadataNamespaces {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetadataOptions_MetadataNamespaces();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.untyped === undefined) {
            message.untyped = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.untyped!.push(el);
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.typed === undefined) {
            message.typed = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.typed!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetadataOptions_MetadataNamespaces {
    return {
      $type: MetadataOptions_MetadataNamespaces.$type,
      untyped: globalThis.Array.isArray(object?.untyped)
        ? object.untyped.map((e: any) => globalThis.String(e))
        : undefined,
      typed: globalThis.Array.isArray(object?.typed) ? object.typed.map((e: any) => globalThis.String(e)) : undefined,
    };
  },

  toJSON(message: MetadataOptions_MetadataNamespaces): unknown {
    const obj: any = {};
    if (message.untyped?.length) {
      obj.untyped = message.untyped;
    }
    if (message.typed?.length) {
      obj.typed = message.typed;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetadataOptions_MetadataNamespaces>, I>>(
    base?: I,
  ): MetadataOptions_MetadataNamespaces {
    return MetadataOptions_MetadataNamespaces.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetadataOptions_MetadataNamespaces>, I>>(
    object: I,
  ): MetadataOptions_MetadataNamespaces {
    const message = createBaseMetadataOptions_MetadataNamespaces();
    message.untyped = object.untyped?.map((e) => e) || undefined;
    message.typed = object.typed?.map((e) => e) || undefined;
    return message;
  },
};

messageTypeRegistry.set(MetadataOptions_MetadataNamespaces.$type, MetadataOptions_MetadataNamespaces);

function createBaseHeaderForwardingRules(): HeaderForwardingRules {
  return { $type: "envoy.extensions.filters.http.ext_proc.v3.HeaderForwardingRules" };
}

export const HeaderForwardingRules: MessageFns<
  HeaderForwardingRules,
  "envoy.extensions.filters.http.ext_proc.v3.HeaderForwardingRules"
> = {
  $type: "envoy.extensions.filters.http.ext_proc.v3.HeaderForwardingRules" as const,

  encode(message: HeaderForwardingRules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.allowed_headers !== undefined) {
      ListStringMatcher.encode(message.allowed_headers, writer.uint32(10).fork()).join();
    }
    if (message.disallowed_headers !== undefined) {
      ListStringMatcher.encode(message.disallowed_headers, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeaderForwardingRules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeaderForwardingRules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.allowed_headers = ListStringMatcher.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.disallowed_headers = ListStringMatcher.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeaderForwardingRules {
    return {
      $type: HeaderForwardingRules.$type,
      allowed_headers: isSet(object.allowed_headers) ? ListStringMatcher.fromJSON(object.allowed_headers) : undefined,
      disallowed_headers: isSet(object.disallowed_headers)
        ? ListStringMatcher.fromJSON(object.disallowed_headers)
        : undefined,
    };
  },

  toJSON(message: HeaderForwardingRules): unknown {
    const obj: any = {};
    if (message.allowed_headers !== undefined) {
      obj.allowed_headers = ListStringMatcher.toJSON(message.allowed_headers);
    }
    if (message.disallowed_headers !== undefined) {
      obj.disallowed_headers = ListStringMatcher.toJSON(message.disallowed_headers);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HeaderForwardingRules>, I>>(base?: I): HeaderForwardingRules {
    return HeaderForwardingRules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HeaderForwardingRules>, I>>(object: I): HeaderForwardingRules {
    const message = createBaseHeaderForwardingRules();
    message.allowed_headers = (object.allowed_headers !== undefined && object.allowed_headers !== null)
      ? ListStringMatcher.fromPartial(object.allowed_headers)
      : undefined;
    message.disallowed_headers = (object.disallowed_headers !== undefined && object.disallowed_headers !== null)
      ? ListStringMatcher.fromPartial(object.disallowed_headers)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(HeaderForwardingRules.$type, HeaderForwardingRules);

function createBaseExtProcPerRoute(): ExtProcPerRoute {
  return { $type: "envoy.extensions.filters.http.ext_proc.v3.ExtProcPerRoute", override: undefined };
}

export const ExtProcPerRoute: MessageFns<ExtProcPerRoute, "envoy.extensions.filters.http.ext_proc.v3.ExtProcPerRoute"> =
  {
    $type: "envoy.extensions.filters.http.ext_proc.v3.ExtProcPerRoute" as const,

    encode(message: ExtProcPerRoute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
      switch (message.override?.$case) {
        case "disabled":
          writer.uint32(8).bool(message.override.disabled);
          break;
        case "overrides":
          ExtProcOverrides.encode(message.override.overrides, writer.uint32(18).fork()).join();
          break;
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): ExtProcPerRoute {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseExtProcPerRoute();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.override = { $case: "disabled", disabled: reader.bool() };
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.override = { $case: "overrides", overrides: ExtProcOverrides.decode(reader, reader.uint32()) };
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): ExtProcPerRoute {
      return {
        $type: ExtProcPerRoute.$type,
        override: isSet(object.disabled)
          ? { $case: "disabled", disabled: globalThis.Boolean(object.disabled) }
          : isSet(object.overrides)
          ? { $case: "overrides", overrides: ExtProcOverrides.fromJSON(object.overrides) }
          : undefined,
      };
    },

    toJSON(message: ExtProcPerRoute): unknown {
      const obj: any = {};
      if (message.override?.$case === "disabled") {
        obj.disabled = message.override.disabled;
      }
      if (message.override?.$case === "overrides") {
        obj.overrides = ExtProcOverrides.toJSON(message.override.overrides);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<ExtProcPerRoute>, I>>(base?: I): ExtProcPerRoute {
      return ExtProcPerRoute.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<ExtProcPerRoute>, I>>(object: I): ExtProcPerRoute {
      const message = createBaseExtProcPerRoute();
      if (
        object.override?.$case === "disabled" &&
        object.override?.disabled !== undefined &&
        object.override?.disabled !== null
      ) {
        message.override = { $case: "disabled", disabled: object.override.disabled };
      }
      if (
        object.override?.$case === "overrides" &&
        object.override?.overrides !== undefined &&
        object.override?.overrides !== null
      ) {
        message.override = { $case: "overrides", overrides: ExtProcOverrides.fromPartial(object.override.overrides) };
      }
      return message;
    },
  };

messageTypeRegistry.set(ExtProcPerRoute.$type, ExtProcPerRoute);

function createBaseExtProcOverrides(): ExtProcOverrides {
  return { $type: "envoy.extensions.filters.http.ext_proc.v3.ExtProcOverrides" };
}

export const ExtProcOverrides: MessageFns<
  ExtProcOverrides,
  "envoy.extensions.filters.http.ext_proc.v3.ExtProcOverrides"
> = {
  $type: "envoy.extensions.filters.http.ext_proc.v3.ExtProcOverrides" as const,

  encode(message: ExtProcOverrides, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processing_mode !== undefined) {
      ProcessingMode.encode(message.processing_mode, writer.uint32(10).fork()).join();
    }
    if (message.async_mode !== undefined && message.async_mode !== false) {
      writer.uint32(16).bool(message.async_mode);
    }
    if (message.request_attributes !== undefined && message.request_attributes.length !== 0) {
      for (const v of message.request_attributes) {
        writer.uint32(26).string(v!);
      }
    }
    if (message.response_attributes !== undefined && message.response_attributes.length !== 0) {
      for (const v of message.response_attributes) {
        writer.uint32(34).string(v!);
      }
    }
    if (message.grpc_service !== undefined) {
      GrpcService.encode(message.grpc_service, writer.uint32(42).fork()).join();
    }
    if (message.metadata_options !== undefined) {
      MetadataOptions.encode(message.metadata_options, writer.uint32(50).fork()).join();
    }
    if (message.grpc_initial_metadata !== undefined && message.grpc_initial_metadata.length !== 0) {
      for (const v of message.grpc_initial_metadata) {
        HeaderValue.encode(v!, writer.uint32(58).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExtProcOverrides {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExtProcOverrides();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.processing_mode = ProcessingMode.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.async_mode = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.request_attributes === undefined) {
            message.request_attributes = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.request_attributes!.push(el);
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          if (message.response_attributes === undefined) {
            message.response_attributes = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.response_attributes!.push(el);
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.grpc_service = GrpcService.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.metadata_options = MetadataOptions.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          if (message.grpc_initial_metadata === undefined) {
            message.grpc_initial_metadata = [];
          }
          const el = HeaderValue.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.grpc_initial_metadata!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExtProcOverrides {
    return {
      $type: ExtProcOverrides.$type,
      processing_mode: isSet(object.processing_mode) ? ProcessingMode.fromJSON(object.processing_mode) : undefined,
      async_mode: isSet(object.async_mode) ? globalThis.Boolean(object.async_mode) : undefined,
      request_attributes: globalThis.Array.isArray(object?.request_attributes)
        ? object.request_attributes.map((e: any) => globalThis.String(e))
        : undefined,
      response_attributes: globalThis.Array.isArray(object?.response_attributes)
        ? object.response_attributes.map((e: any) => globalThis.String(e))
        : undefined,
      grpc_service: isSet(object.grpc_service) ? GrpcService.fromJSON(object.grpc_service) : undefined,
      metadata_options: isSet(object.metadata_options) ? MetadataOptions.fromJSON(object.metadata_options) : undefined,
      grpc_initial_metadata: globalThis.Array.isArray(object?.grpc_initial_metadata)
        ? object.grpc_initial_metadata.map((e: any) => HeaderValue.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: ExtProcOverrides): unknown {
    const obj: any = {};
    if (message.processing_mode !== undefined) {
      obj.processing_mode = ProcessingMode.toJSON(message.processing_mode);
    }
    if (message.async_mode !== undefined) {
      obj.async_mode = message.async_mode;
    }
    if (message.request_attributes?.length) {
      obj.request_attributes = message.request_attributes;
    }
    if (message.response_attributes?.length) {
      obj.response_attributes = message.response_attributes;
    }
    if (message.grpc_service !== undefined) {
      obj.grpc_service = GrpcService.toJSON(message.grpc_service);
    }
    if (message.metadata_options !== undefined) {
      obj.metadata_options = MetadataOptions.toJSON(message.metadata_options);
    }
    if (message.grpc_initial_metadata?.length) {
      obj.grpc_initial_metadata = message.grpc_initial_metadata.map((e) => HeaderValue.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExtProcOverrides>, I>>(base?: I): ExtProcOverrides {
    return ExtProcOverrides.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExtProcOverrides>, I>>(object: I): ExtProcOverrides {
    const message = createBaseExtProcOverrides();
    message.processing_mode = (object.processing_mode !== undefined && object.processing_mode !== null)
      ? ProcessingMode.fromPartial(object.processing_mode)
      : undefined;
    message.async_mode = object.async_mode ?? undefined;
    message.request_attributes = object.request_attributes?.map((e) => e) || undefined;
    message.response_attributes = object.response_attributes?.map((e) => e) || undefined;
    message.grpc_service = (object.grpc_service !== undefined && object.grpc_service !== null)
      ? GrpcService.fromPartial(object.grpc_service)
      : undefined;
    message.metadata_options = (object.metadata_options !== undefined && object.metadata_options !== null)
      ? MetadataOptions.fromPartial(object.metadata_options)
      : undefined;
    message.grpc_initial_metadata = object.grpc_initial_metadata?.map((e) => HeaderValue.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(ExtProcOverrides.$type, ExtProcOverrides);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
