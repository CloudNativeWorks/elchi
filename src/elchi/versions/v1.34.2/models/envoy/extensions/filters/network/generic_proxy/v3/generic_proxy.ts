// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/filters/network/generic_proxy/v3/generic_proxy.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { messageTypeRegistry } from "../../../../../../typeRegistry";
import { AccessLog } from "../../../../../config/accesslog/v3/accesslog";
import { ConfigSource } from "../../../../../config/core/v3/config_source";
import { TypedExtensionConfig } from "../../../../../config/core/v3/extension";
import { HttpConnectionManager_Tracing } from "../../http_connection_manager/v3/http_connection_manager";
import { RouteConfiguration } from "./route";

export const protobufPackage = "envoy.extensions.filters.network.generic_proxy.v3";

/** [#next-free-field: 8] */
export interface GenericProxy {
  $type: "envoy.extensions.filters.network.generic_proxy.v3.GenericProxy";
  /** The human readable prefix to use when emitting statistics. */
  stat_prefix?:
    | string
    | undefined;
  /**
   * The codec which encodes and decodes the application protocol.
   * [#extension-category: envoy.generic_proxy.codecs]
   */
  codec_config?: TypedExtensionConfig | undefined;
  route_specifier?:
    | //
    /** The generic proxies route table will be dynamically loaded via the meta RDS API. */
    { $case: "generic_rds"; generic_rds: GenericRds }
    | //
    /** The route table for the generic proxy is static and is specified in this property. */
    { $case: "route_config"; route_config: RouteConfiguration }
    | undefined;
  /**
   * A list of individual Layer-7 filters that make up the filter chain for requests made to the
   * proxy. Order matters as the filters are processed sequentially as request events
   * happen.
   * [#extension-category: envoy.generic_proxy.filters]
   */
  filters?:
    | TypedExtensionConfig[]
    | undefined;
  /** Tracing configuration for the generic proxy. */
  tracing?:
    | HttpConnectionManager_Tracing
    | undefined;
  /** Configuration for :ref:`access logs <arch_overview_access_logs>` emitted by generic proxy. */
  access_log?: AccessLog[] | undefined;
}

export interface GenericRds {
  $type: "envoy.extensions.filters.network.generic_proxy.v3.GenericRds";
  /** Configuration source specifier for RDS. */
  config_source?:
    | ConfigSource
    | undefined;
  /**
   * The name of the route configuration. This name will be passed to the RDS API. This allows an
   * Envoy configuration with multiple generic proxies to use different route configurations.
   */
  route_config_name?: string | undefined;
}

function createBaseGenericProxy(): GenericProxy {
  return { $type: "envoy.extensions.filters.network.generic_proxy.v3.GenericProxy", route_specifier: undefined };
}

export const GenericProxy: MessageFns<GenericProxy, "envoy.extensions.filters.network.generic_proxy.v3.GenericProxy"> =
  {
    $type: "envoy.extensions.filters.network.generic_proxy.v3.GenericProxy" as const,

    encode(message: GenericProxy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
      if (message.stat_prefix !== undefined && message.stat_prefix !== "") {
        writer.uint32(10).string(message.stat_prefix);
      }
      if (message.codec_config !== undefined) {
        TypedExtensionConfig.encode(message.codec_config, writer.uint32(18).fork()).join();
      }
      switch (message.route_specifier?.$case) {
        case "generic_rds":
          GenericRds.encode(message.route_specifier.generic_rds, writer.uint32(26).fork()).join();
          break;
        case "route_config":
          RouteConfiguration.encode(message.route_specifier.route_config, writer.uint32(34).fork()).join();
          break;
      }
      if (message.filters !== undefined && message.filters.length !== 0) {
        for (const v of message.filters) {
          TypedExtensionConfig.encode(v!, writer.uint32(42).fork()).join();
        }
      }
      if (message.tracing !== undefined) {
        HttpConnectionManager_Tracing.encode(message.tracing, writer.uint32(50).fork()).join();
      }
      if (message.access_log !== undefined && message.access_log.length !== 0) {
        for (const v of message.access_log) {
          AccessLog.encode(v!, writer.uint32(58).fork()).join();
        }
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): GenericProxy {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGenericProxy();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.stat_prefix = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.codec_config = TypedExtensionConfig.decode(reader, reader.uint32());
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.route_specifier = { $case: "generic_rds", generic_rds: GenericRds.decode(reader, reader.uint32()) };
            continue;
          }
          case 4: {
            if (tag !== 34) {
              break;
            }

            message.route_specifier = {
              $case: "route_config",
              route_config: RouteConfiguration.decode(reader, reader.uint32()),
            };
            continue;
          }
          case 5: {
            if (tag !== 42) {
              break;
            }

            if (message.filters === undefined) {
              message.filters = [];
            }
            const el = TypedExtensionConfig.decode(reader, reader.uint32());
            if (el !== undefined) {
              message.filters!.push(el);
            }
            continue;
          }
          case 6: {
            if (tag !== 50) {
              break;
            }

            message.tracing = HttpConnectionManager_Tracing.decode(reader, reader.uint32());
            continue;
          }
          case 7: {
            if (tag !== 58) {
              break;
            }

            if (message.access_log === undefined) {
              message.access_log = [];
            }
            const el = AccessLog.decode(reader, reader.uint32());
            if (el !== undefined) {
              message.access_log!.push(el);
            }
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GenericProxy {
      return {
        $type: GenericProxy.$type,
        stat_prefix: isSet(object.stat_prefix) ? globalThis.String(object.stat_prefix) : undefined,
        codec_config: isSet(object.codec_config) ? TypedExtensionConfig.fromJSON(object.codec_config) : undefined,
        route_specifier: isSet(object.generic_rds)
          ? { $case: "generic_rds", generic_rds: GenericRds.fromJSON(object.generic_rds) }
          : isSet(object.route_config)
          ? { $case: "route_config", route_config: RouteConfiguration.fromJSON(object.route_config) }
          : undefined,
        filters: globalThis.Array.isArray(object?.filters)
          ? object.filters.map((e: any) => TypedExtensionConfig.fromJSON(e))
          : undefined,
        tracing: isSet(object.tracing) ? HttpConnectionManager_Tracing.fromJSON(object.tracing) : undefined,
        access_log: globalThis.Array.isArray(object?.access_log)
          ? object.access_log.map((e: any) => AccessLog.fromJSON(e))
          : undefined,
      };
    },

    toJSON(message: GenericProxy): unknown {
      const obj: any = {};
      if (message.stat_prefix !== undefined) {
        obj.stat_prefix = message.stat_prefix;
      }
      if (message.codec_config !== undefined) {
        obj.codec_config = TypedExtensionConfig.toJSON(message.codec_config);
      }
      if (message.route_specifier?.$case === "generic_rds") {
        obj.generic_rds = GenericRds.toJSON(message.route_specifier.generic_rds);
      }
      if (message.route_specifier?.$case === "route_config") {
        obj.route_config = RouteConfiguration.toJSON(message.route_specifier.route_config);
      }
      if (message.filters?.length) {
        obj.filters = message.filters.map((e) => TypedExtensionConfig.toJSON(e));
      }
      if (message.tracing !== undefined) {
        obj.tracing = HttpConnectionManager_Tracing.toJSON(message.tracing);
      }
      if (message.access_log?.length) {
        obj.access_log = message.access_log.map((e) => AccessLog.toJSON(e));
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<GenericProxy>, I>>(base?: I): GenericProxy {
      return GenericProxy.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<GenericProxy>, I>>(object: I): GenericProxy {
      const message = createBaseGenericProxy();
      message.stat_prefix = object.stat_prefix ?? undefined;
      message.codec_config = (object.codec_config !== undefined && object.codec_config !== null)
        ? TypedExtensionConfig.fromPartial(object.codec_config)
        : undefined;
      if (
        object.route_specifier?.$case === "generic_rds" &&
        object.route_specifier?.generic_rds !== undefined &&
        object.route_specifier?.generic_rds !== null
      ) {
        message.route_specifier = {
          $case: "generic_rds",
          generic_rds: GenericRds.fromPartial(object.route_specifier.generic_rds),
        };
      }
      if (
        object.route_specifier?.$case === "route_config" &&
        object.route_specifier?.route_config !== undefined &&
        object.route_specifier?.route_config !== null
      ) {
        message.route_specifier = {
          $case: "route_config",
          route_config: RouteConfiguration.fromPartial(object.route_specifier.route_config),
        };
      }
      message.filters = object.filters?.map((e) => TypedExtensionConfig.fromPartial(e)) || undefined;
      message.tracing = (object.tracing !== undefined && object.tracing !== null)
        ? HttpConnectionManager_Tracing.fromPartial(object.tracing)
        : undefined;
      message.access_log = object.access_log?.map((e) => AccessLog.fromPartial(e)) || undefined;
      return message;
    },
  };

messageTypeRegistry.set(GenericProxy.$type, GenericProxy);

function createBaseGenericRds(): GenericRds {
  return { $type: "envoy.extensions.filters.network.generic_proxy.v3.GenericRds" };
}

export const GenericRds: MessageFns<GenericRds, "envoy.extensions.filters.network.generic_proxy.v3.GenericRds"> = {
  $type: "envoy.extensions.filters.network.generic_proxy.v3.GenericRds" as const,

  encode(message: GenericRds, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.config_source !== undefined) {
      ConfigSource.encode(message.config_source, writer.uint32(10).fork()).join();
    }
    if (message.route_config_name !== undefined && message.route_config_name !== "") {
      writer.uint32(18).string(message.route_config_name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenericRds {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenericRds();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.config_source = ConfigSource.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.route_config_name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenericRds {
    return {
      $type: GenericRds.$type,
      config_source: isSet(object.config_source) ? ConfigSource.fromJSON(object.config_source) : undefined,
      route_config_name: isSet(object.route_config_name) ? globalThis.String(object.route_config_name) : undefined,
    };
  },

  toJSON(message: GenericRds): unknown {
    const obj: any = {};
    if (message.config_source !== undefined) {
      obj.config_source = ConfigSource.toJSON(message.config_source);
    }
    if (message.route_config_name !== undefined) {
      obj.route_config_name = message.route_config_name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenericRds>, I>>(base?: I): GenericRds {
    return GenericRds.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenericRds>, I>>(object: I): GenericRds {
    const message = createBaseGenericRds();
    message.config_source = (object.config_source !== undefined && object.config_source !== null)
      ? ConfigSource.fromPartial(object.config_source)
      : undefined;
    message.route_config_name = object.route_config_name ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(GenericRds.$type, GenericRds);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
