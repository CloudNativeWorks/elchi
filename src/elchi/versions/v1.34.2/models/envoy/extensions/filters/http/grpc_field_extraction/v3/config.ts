// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/filters/http/grpc_field_extraction/v3/config.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { messageTypeRegistry } from "../../../../../../typeRegistry";
import { DataSource } from "../../../../../config/core/v3/base";

export const protobufPackage = "envoy.extensions.filters.http.grpc_field_extraction.v3";

export interface GrpcFieldExtractionConfig {
  $type: "envoy.extensions.filters.http.grpc_field_extraction.v3.GrpcFieldExtractionConfig";
  /**
   * The proto descriptor set binary for the gRPC services.
   *
   * It could be passed by a local file through ``Datasource.filename`` or embedded in the
   * ``Datasource.inline_bytes``.
   */
  descriptor_set?:
    | DataSource
    | undefined;
  /**
   * Specify the extraction info.
   * The key is the fully qualified gRPC method name.
   * ``${package}.${Service}.${Method}``, like
   * ``endpoints.examples.bookstore.BookStore.GetShelf``
   *
   * The value is the field extractions for individual gRPC method.
   */
  extractions_by_method?: Map<string, FieldExtractions> | undefined;
}

export interface GrpcFieldExtractionConfig_ExtractionsByMethodEntry {
  $type: "envoy.extensions.filters.http.grpc_field_extraction.v3.GrpcFieldExtractionConfig.ExtractionsByMethodEntry";
  key: string;
  value?: FieldExtractions | undefined;
}

/**
 * This message can be used to support per route config approach later even
 * though the Istio doesn't support that so far.
 */
export interface FieldExtractions {
  $type: "envoy.extensions.filters.http.grpc_field_extraction.v3.FieldExtractions";
  /**
   * The field extractions for requests.
   * The key is the field path within the grpc request.
   * For example, we can define ``foo.bar.name`` if we want to extract
   * ``Request.foo.bar.name``.
   *
   * .. code-block:: proto
   *
   *  message Request {
   *    Foo foo = 1;
   *  }
   *
   *  message Foo {
   *    Bar bar = 1;
   *  }
   *
   *  message Bar {
   *    string name = 1;
   *  }
   */
  request_field_extractions?: Map<string, RequestFieldValueDisposition> | undefined;
}

export interface FieldExtractions_RequestFieldExtractionsEntry {
  $type: "envoy.extensions.filters.http.grpc_field_extraction.v3.FieldExtractions.RequestFieldExtractionsEntry";
  key: string;
  value?: RequestFieldValueDisposition | undefined;
}

export interface RequestFieldValueDisposition {
  $type: "envoy.extensions.filters.http.grpc_field_extraction.v3.RequestFieldValueDisposition";
  disposition?:
    | //
    /**
     * The dynamic metadata namespace. If empty, "envoy.filters.http.grpc_field_extraction" will be used by default.
     *
     * Unimplemented. Uses "envoy.filters.http.grpc_field_extraction" for now.
     */
    { $case: "dynamic_metadata"; dynamic_metadata: string }
    | undefined;
}

function createBaseGrpcFieldExtractionConfig(): GrpcFieldExtractionConfig {
  return { $type: "envoy.extensions.filters.http.grpc_field_extraction.v3.GrpcFieldExtractionConfig" };
}

export const GrpcFieldExtractionConfig: MessageFns<
  GrpcFieldExtractionConfig,
  "envoy.extensions.filters.http.grpc_field_extraction.v3.GrpcFieldExtractionConfig"
> = {
  $type: "envoy.extensions.filters.http.grpc_field_extraction.v3.GrpcFieldExtractionConfig" as const,

  encode(message: GrpcFieldExtractionConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.descriptor_set !== undefined) {
      DataSource.encode(message.descriptor_set, writer.uint32(10).fork()).join();
    }
    (message.extractions_by_method || new Map()).forEach((value, key) => {
      GrpcFieldExtractionConfig_ExtractionsByMethodEntry.encode({
        $type:
          "envoy.extensions.filters.http.grpc_field_extraction.v3.GrpcFieldExtractionConfig.ExtractionsByMethodEntry",
        key: key as any,
        value,
      }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrpcFieldExtractionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrpcFieldExtractionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.descriptor_set = DataSource.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = GrpcFieldExtractionConfig_ExtractionsByMethodEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            if (message.extractions_by_method === undefined) {
              message.extractions_by_method = new Map();
            }
            message.extractions_by_method!.set(entry2.key, entry2.value);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrpcFieldExtractionConfig {
    return {
      $type: GrpcFieldExtractionConfig.$type,
      descriptor_set: isSet(object.descriptor_set) ? DataSource.fromJSON(object.descriptor_set) : undefined,
      extractions_by_method: isObject(object.extractions_by_method)
        ? Object.entries(object.extractions_by_method).reduce<Map<string, FieldExtractions>>((acc, [key, value]) => {
          acc.set(key, FieldExtractions.fromJSON(value));
          return acc;
        }, new Map())
        : undefined,
    };
  },

  toJSON(message: GrpcFieldExtractionConfig): unknown {
    const obj: any = {};
    if (message.descriptor_set !== undefined) {
      obj.descriptor_set = DataSource.toJSON(message.descriptor_set);
    }
    if (message.extractions_by_method?.size) {
      obj.extractions_by_method = {};
      message.extractions_by_method.forEach((v, k) => {
        obj.extractions_by_method[k] = FieldExtractions.toJSON(v);
      });
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GrpcFieldExtractionConfig>, I>>(base?: I): GrpcFieldExtractionConfig {
    return GrpcFieldExtractionConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GrpcFieldExtractionConfig>, I>>(object: I): GrpcFieldExtractionConfig {
    const message = createBaseGrpcFieldExtractionConfig();
    message.descriptor_set = (object.descriptor_set !== undefined && object.descriptor_set !== null)
      ? DataSource.fromPartial(object.descriptor_set)
      : undefined;
    message.extractions_by_method =
      (object.extractions_by_method === undefined || object.extractions_by_method === null)
        ? undefined
        : (() => {
          const m = new Map();
          (object.extractions_by_method as Map<string, FieldExtractions> ?? new Map()).forEach((value, key) => {
            if (value !== undefined) {
              m.set(key, FieldExtractions.fromPartial(value));
            }
          });
          return m;
        })();
    return message;
  },
};

messageTypeRegistry.set(GrpcFieldExtractionConfig.$type, GrpcFieldExtractionConfig);

function createBaseGrpcFieldExtractionConfig_ExtractionsByMethodEntry(): GrpcFieldExtractionConfig_ExtractionsByMethodEntry {
  return {
    $type: "envoy.extensions.filters.http.grpc_field_extraction.v3.GrpcFieldExtractionConfig.ExtractionsByMethodEntry",
    key: "",
  };
}

export const GrpcFieldExtractionConfig_ExtractionsByMethodEntry: MessageFns<
  GrpcFieldExtractionConfig_ExtractionsByMethodEntry,
  "envoy.extensions.filters.http.grpc_field_extraction.v3.GrpcFieldExtractionConfig.ExtractionsByMethodEntry"
> = {
  $type:
    "envoy.extensions.filters.http.grpc_field_extraction.v3.GrpcFieldExtractionConfig.ExtractionsByMethodEntry" as const,

  encode(
    message: GrpcFieldExtractionConfig_ExtractionsByMethodEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      FieldExtractions.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrpcFieldExtractionConfig_ExtractionsByMethodEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrpcFieldExtractionConfig_ExtractionsByMethodEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = FieldExtractions.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrpcFieldExtractionConfig_ExtractionsByMethodEntry {
    return {
      $type: GrpcFieldExtractionConfig_ExtractionsByMethodEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? FieldExtractions.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: GrpcFieldExtractionConfig_ExtractionsByMethodEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = FieldExtractions.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GrpcFieldExtractionConfig_ExtractionsByMethodEntry>, I>>(
    base?: I,
  ): GrpcFieldExtractionConfig_ExtractionsByMethodEntry {
    return GrpcFieldExtractionConfig_ExtractionsByMethodEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GrpcFieldExtractionConfig_ExtractionsByMethodEntry>, I>>(
    object: I,
  ): GrpcFieldExtractionConfig_ExtractionsByMethodEntry {
    const message = createBaseGrpcFieldExtractionConfig_ExtractionsByMethodEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? FieldExtractions.fromPartial(object.value)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(
  GrpcFieldExtractionConfig_ExtractionsByMethodEntry.$type,
  GrpcFieldExtractionConfig_ExtractionsByMethodEntry,
);

function createBaseFieldExtractions(): FieldExtractions {
  return { $type: "envoy.extensions.filters.http.grpc_field_extraction.v3.FieldExtractions" };
}

export const FieldExtractions: MessageFns<
  FieldExtractions,
  "envoy.extensions.filters.http.grpc_field_extraction.v3.FieldExtractions"
> = {
  $type: "envoy.extensions.filters.http.grpc_field_extraction.v3.FieldExtractions" as const,

  encode(message: FieldExtractions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    (message.request_field_extractions || new Map()).forEach((value, key) => {
      FieldExtractions_RequestFieldExtractionsEntry.encode({
        $type: "envoy.extensions.filters.http.grpc_field_extraction.v3.FieldExtractions.RequestFieldExtractionsEntry",
        key: key as any,
        value,
      }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FieldExtractions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFieldExtractions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = FieldExtractions_RequestFieldExtractionsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            if (message.request_field_extractions === undefined) {
              message.request_field_extractions = new Map();
            }
            message.request_field_extractions!.set(entry1.key, entry1.value);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FieldExtractions {
    return {
      $type: FieldExtractions.$type,
      request_field_extractions: isObject(object.request_field_extractions)
        ? Object.entries(object.request_field_extractions).reduce<Map<string, RequestFieldValueDisposition>>(
          (acc, [key, value]) => {
            acc.set(key, RequestFieldValueDisposition.fromJSON(value));
            return acc;
          },
          new Map(),
        )
        : undefined,
    };
  },

  toJSON(message: FieldExtractions): unknown {
    const obj: any = {};
    if (message.request_field_extractions?.size) {
      obj.request_field_extractions = {};
      message.request_field_extractions.forEach((v, k) => {
        obj.request_field_extractions[k] = RequestFieldValueDisposition.toJSON(v);
      });
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FieldExtractions>, I>>(base?: I): FieldExtractions {
    return FieldExtractions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FieldExtractions>, I>>(object: I): FieldExtractions {
    const message = createBaseFieldExtractions();
    message.request_field_extractions =
      (object.request_field_extractions === undefined || object.request_field_extractions === null)
        ? undefined
        : (() => {
          const m = new Map();
          (object.request_field_extractions as Map<string, RequestFieldValueDisposition> ?? new Map()).forEach(
            (value, key) => {
              if (value !== undefined) {
                m.set(key, RequestFieldValueDisposition.fromPartial(value));
              }
            },
          );
          return m;
        })();
    return message;
  },
};

messageTypeRegistry.set(FieldExtractions.$type, FieldExtractions);

function createBaseFieldExtractions_RequestFieldExtractionsEntry(): FieldExtractions_RequestFieldExtractionsEntry {
  return {
    $type: "envoy.extensions.filters.http.grpc_field_extraction.v3.FieldExtractions.RequestFieldExtractionsEntry",
    key: "",
  };
}

export const FieldExtractions_RequestFieldExtractionsEntry: MessageFns<
  FieldExtractions_RequestFieldExtractionsEntry,
  "envoy.extensions.filters.http.grpc_field_extraction.v3.FieldExtractions.RequestFieldExtractionsEntry"
> = {
  $type:
    "envoy.extensions.filters.http.grpc_field_extraction.v3.FieldExtractions.RequestFieldExtractionsEntry" as const,

  encode(
    message: FieldExtractions_RequestFieldExtractionsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      RequestFieldValueDisposition.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FieldExtractions_RequestFieldExtractionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFieldExtractions_RequestFieldExtractionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = RequestFieldValueDisposition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FieldExtractions_RequestFieldExtractionsEntry {
    return {
      $type: FieldExtractions_RequestFieldExtractionsEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? RequestFieldValueDisposition.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: FieldExtractions_RequestFieldExtractionsEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = RequestFieldValueDisposition.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FieldExtractions_RequestFieldExtractionsEntry>, I>>(
    base?: I,
  ): FieldExtractions_RequestFieldExtractionsEntry {
    return FieldExtractions_RequestFieldExtractionsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FieldExtractions_RequestFieldExtractionsEntry>, I>>(
    object: I,
  ): FieldExtractions_RequestFieldExtractionsEntry {
    const message = createBaseFieldExtractions_RequestFieldExtractionsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? RequestFieldValueDisposition.fromPartial(object.value)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(
  FieldExtractions_RequestFieldExtractionsEntry.$type,
  FieldExtractions_RequestFieldExtractionsEntry,
);

function createBaseRequestFieldValueDisposition(): RequestFieldValueDisposition {
  return {
    $type: "envoy.extensions.filters.http.grpc_field_extraction.v3.RequestFieldValueDisposition",
    disposition: undefined,
  };
}

export const RequestFieldValueDisposition: MessageFns<
  RequestFieldValueDisposition,
  "envoy.extensions.filters.http.grpc_field_extraction.v3.RequestFieldValueDisposition"
> = {
  $type: "envoy.extensions.filters.http.grpc_field_extraction.v3.RequestFieldValueDisposition" as const,

  encode(message: RequestFieldValueDisposition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.disposition?.$case) {
      case "dynamic_metadata":
        writer.uint32(10).string(message.disposition.dynamic_metadata);
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestFieldValueDisposition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestFieldValueDisposition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.disposition = { $case: "dynamic_metadata", dynamic_metadata: reader.string() };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestFieldValueDisposition {
    return {
      $type: RequestFieldValueDisposition.$type,
      disposition: isSet(object.dynamic_metadata)
        ? { $case: "dynamic_metadata", dynamic_metadata: globalThis.String(object.dynamic_metadata) }
        : undefined,
    };
  },

  toJSON(message: RequestFieldValueDisposition): unknown {
    const obj: any = {};
    if (message.disposition?.$case === "dynamic_metadata") {
      obj.dynamic_metadata = message.disposition.dynamic_metadata;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestFieldValueDisposition>, I>>(base?: I): RequestFieldValueDisposition {
    return RequestFieldValueDisposition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestFieldValueDisposition>, I>>(object: I): RequestFieldValueDisposition {
    const message = createBaseRequestFieldValueDisposition();
    if (
      object.disposition?.$case === "dynamic_metadata" &&
      object.disposition?.dynamic_metadata !== undefined &&
      object.disposition?.dynamic_metadata !== null
    ) {
      message.disposition = { $case: "dynamic_metadata", dynamic_metadata: object.disposition.dynamic_metadata };
    }
    return message;
  },
};

messageTypeRegistry.set(RequestFieldValueDisposition.$type, RequestFieldValueDisposition);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
