// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/filters/network/redis_proxy/v3/redis_proxy.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../../../../google/protobuf/duration";
import { UInt32Value } from "../../../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../../../typeRegistry";
import { DataSource, RuntimeFractionalPercent } from "../../../../../config/core/v3/base";
import { GrpcService } from "../../../../../config/core/v3/grpc_service";
import { DnsCacheConfig } from "../../../../common/dynamic_forward_proxy/v3/dns_cache";

export const protobufPackage = "envoy.extensions.filters.network.redis_proxy.v3";

/** [#next-free-field: 12] */
export interface RedisProxy {
  $type: "envoy.extensions.filters.network.redis_proxy.v3.RedisProxy";
  /** The prefix to use when emitting :ref:`statistics <config_network_filters_redis_proxy_stats>`. */
  stat_prefix?:
    | string
    | undefined;
  /** Network settings for the connection pool to the upstream clusters. */
  settings?:
    | RedisProxy_ConnPoolSettings
    | undefined;
  /**
   * Indicates that latency stat should be computed in microseconds. By default it is computed in
   * milliseconds. This does not apply to upstream command stats currently.
   */
  latency_in_micros?:
    | boolean
    | undefined;
  /**
   * List of **unique** prefixes used to separate keys from different workloads to different
   * clusters. Envoy will always favor the longest match first in case of overlap. A catch-all
   * cluster can be used to forward commands when there is no match. Time complexity of the
   * lookups are in O(min(longest key prefix, key length)).
   *
   * Example:
   *
   * .. code-block:: yaml
   *
   *    prefix_routes:
   *      routes:
   *        - prefix: "ab"
   *          cluster: "cluster_a"
   *        - prefix: "abc"
   *          cluster: "cluster_b"
   *
   * When using the above routes, the following prefixes would be sent to:
   *
   * * ``get abc:users`` would retrieve the key 'abc:users' from cluster_b.
   * * ``get ab:users`` would retrieve the key 'ab:users' from cluster_a.
   * * ``get z:users`` would return a NoUpstreamHost error. A :ref:`catch-all
   *   route<envoy_v3_api_field_extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes.catch_all_route>`
   *   would have retrieved the key from that cluster instead.
   *
   * See the :ref:`configuration section
   * <arch_overview_redis_configuration>` of the architecture overview for recommendations on
   * configuring the backing clusters.
   */
  prefix_routes?:
    | RedisProxy_PrefixRoutes
    | undefined;
  /**
   * Authenticate Redis client connections locally by forcing downstream clients to issue a `Redis
   * AUTH command <https://redis.io/commands/auth>`_ with this password before enabling any other
   * command. If an AUTH command's password matches this password, an "OK" response will be returned
   * to the client. If the AUTH command password does not match this password, then an "ERR invalid
   * password" error will be returned. If any other command is received before AUTH when this
   * password is set, then a "NOAUTH Authentication required." error response will be sent to the
   * client. If an AUTH command is received when the password is not set, then an "ERR Client sent
   * AUTH, but no password is set" error will be returned.
   *
   * .. attention::
   *   This field is deprecated. Use :ref:`downstream_auth_passwords
   *   <envoy_v3_api_field_extensions.filters.network.redis_proxy.v3.RedisProxy.downstream_auth_passwords>`.
   *
   * @deprecated
   */
  downstream_auth_password?:
    | DataSource
    | undefined;
  /**
   * Authenticate Redis client connections locally by forcing downstream clients to issue a `Redis
   * AUTH command <https://redis.io/commands/auth>`_ with one of these passwords before enabling any other
   * command. If an AUTH command's password matches one of these passwords, an "OK" response will be returned
   * to the client. If the AUTH command password does not match, then an "ERR invalid
   * password" error will be returned. If any other command is received before AUTH when the
   * password(s) are set, then a "NOAUTH Authentication required." error response will be sent to the
   * client. If an AUTH command is received when the password is not set, then an "ERR Client sent
   * AUTH, but no password is set" error will be returned.
   */
  downstream_auth_passwords?:
    | DataSource[]
    | undefined;
  /**
   * List of faults to inject. Faults currently come in two flavors:
   * - Delay, which delays a request.
   * - Error, which responds to a request with an error. Errors can also have delays attached.
   *
   * Example:
   *
   * .. code-block:: yaml
   *
   *    faults:
   *    - fault_type: ERROR
   *      fault_enabled:
   *        default_value:
   *          numerator: 10
   *          denominator: HUNDRED
   *        runtime_key: "bogus_key"
   *        commands:
   *        - GET
   *      - fault_type: DELAY
   *        fault_enabled:
   *          default_value:
   *            numerator: 10
   *            denominator: HUNDRED
   *          runtime_key: "bogus_key"
   *        delay: 2s
   *
   * See the :ref:`fault injection section
   * <config_network_filters_redis_proxy_fault_injection>` for more information on how to configure this.
   */
  faults?:
    | RedisProxy_RedisFault[]
    | undefined;
  /**
   * If a username is provided an ACL style AUTH command will be required with a username and password.
   * Authenticate Redis client connections locally by forcing downstream clients to issue a `Redis
   * AUTH command <https://redis.io/commands/auth>`_ with this username and the ``downstream_auth_password``
   * before enabling any other command. If an AUTH command's username and password matches this username
   * and the ``downstream_auth_password`` , an "OK" response will be returned to the client. If the AUTH
   * command username or password does not match this username or the ``downstream_auth_password``, then an
   * "WRONGPASS invalid username-password pair" error will be returned. If any other command is received before AUTH when this
   * password is set, then a "NOAUTH Authentication required." error response will be sent to the
   * client. If an AUTH command is received when the password is not set, then an "ERR Client sent
   * AUTH, but no ACL is set" error will be returned.
   */
  downstream_auth_username?:
    | DataSource
    | undefined;
  /**
   * External authentication configuration. If set, instead of validating username and password against ``downstream_auth_username`` and ``downstream_auth_password``,
   * the filter will call an external gRPC service to authenticate the client.
   * A typical usage of this feature is for situations where the password is a one-time token that needs to be validated against a remote service, like a sidecar.
   * Expiration is also supported, which will disable any further commands from the client after the expiration time, unless a new AUTH command is received and the external auth service returns a new expiration time.
   * If the external auth service returns an error, authentication is considered failed.
   * If this setting is set together with ``downstream_auth_username`` and ``downstream_auth_password``, the external auth service will be source of truth, but those fields will still be used for downstream authentication to the cluster.
   * The API is defined by :ref:`RedisProxyExternalAuthRequest <envoy_v3_api_msg_service.redis_auth.v3.RedisProxyExternalAuthRequest>`.
   */
  external_auth_provider?:
    | RedisExternalAuthProvider
    | undefined;
  /**
   * Optional configure redis custom commands for the proxy, eg -> ["my_custom_cmd1", "my_custom_cmd2"]
   *
   * .. note::
   *   The is to support redis's feature wherein new commands can be added using redis' modules api:
   *   https://redis.io/docs/latest/develop/reference/modules/
   */
  custom_commands?: string[] | undefined;
}

/**
 * Redis connection pool settings.
 * [#next-free-field: 11]
 */
export interface RedisProxy_ConnPoolSettings {
  $type: "envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.ConnPoolSettings";
  /**
   * Per-operation timeout in milliseconds. The timer starts when the first
   * command of a pipeline is written to the backend connection. Each response received from Redis
   * resets the timer since it signifies that the next command is being processed by the backend.
   * The only exception to this behavior is when a connection to a backend is not yet established.
   * In that case, the connect timeout on the cluster will govern the timeout until the connection
   * is ready.
   */
  op_timeout?:
    | Duration
    | undefined;
  /**
   * Use hash tagging on every redis key to guarantee that keys with the same hash tag will be
   * forwarded to the same upstream. The hash key used for determining the upstream in a
   * consistent hash ring configuration will be computed from the hash tagged key instead of the
   * whole key. The algorithm used to compute the hash tag is identical to the `redis-cluster
   * implementation <https://redis.io/topics/cluster-spec#keys-hash-tags>`_.
   *
   * Examples:
   *
   * * '{user1000}.following' and '{user1000}.followers' **will** be sent to the same upstream
   * * '{user1000}.following' and '{user1001}.following' **might** be sent to the same upstream
   */
  enable_hashtagging?:
    | boolean
    | undefined;
  /**
   * Accept `moved and ask redirection
   * <https://redis.io/topics/cluster-spec#redirection-and-resharding>`_ errors from upstream
   * redis servers, and retry commands to the specified target server. The target server does not
   * need to be known to the cluster manager. If the command cannot be redirected, then the
   * original error is passed downstream unchanged. By default, this support is not enabled.
   */
  enable_redirection?:
    | boolean
    | undefined;
  /**
   * If ``enable_redirection`` is set to true this option configures the DNS cache that the
   * connection pool will use to resolve hostnames that are returned with MOVED and ASK responses.
   * If no configuration is provided, DNS lookups will not be performed (and thus the MOVED/ASK errors
   * will be propagated verbatim to the user).
   */
  dns_cache_config?:
    | DnsCacheConfig
    | undefined;
  /**
   * Maximum size of encoded request buffer before flush is triggered and encoded requests
   * are sent upstream. If this is unset, the buffer flushes whenever it receives data
   * and performs no batching.
   * This feature makes it possible for multiple clients to send requests to Envoy and have
   * them batched- for example if one is running several worker processes, each with its own
   * Redis connection. There is no benefit to using this with a single downstream process.
   * Recommended size (if enabled) is 1024 bytes.
   */
  max_buffer_size_before_flush?:
    | number
    | undefined;
  /**
   * The encoded request buffer is flushed N milliseconds after the first request has been
   * encoded, unless the buffer size has already exceeded ``max_buffer_size_before_flush``.
   * If ``max_buffer_size_before_flush`` is not set, this flush timer is not used. Otherwise,
   * the timer should be set according to the number of clients, overall request rate and
   * desired maximum latency for a single command. For example, if there are many requests
   * being batched together at a high rate, the buffer will likely be filled before the timer
   * fires. Alternatively, if the request rate is lower the buffer will not be filled as often
   * before the timer fires.
   * If ``max_buffer_size_before_flush`` is set, but ``buffer_flush_timeout`` is not, the latter
   * defaults to 3ms.
   */
  buffer_flush_timeout?:
    | Duration
    | undefined;
  /**
   * ``max_upstream_unknown_connections`` controls how many upstream connections to unknown hosts
   * can be created at any given time by any given worker thread (see ``enable_redirection`` for
   * more details). If the host is unknown and a connection cannot be created due to enforcing
   * this limit, then redirection will fail and the original redirection error will be passed
   * downstream unchanged. This limit defaults to 100.
   */
  max_upstream_unknown_connections?:
    | number
    | undefined;
  /**
   * Enable per-command statistics per upstream cluster, in addition to the filter level aggregate
   * count. These commands are measured in microseconds.
   */
  enable_command_stats?:
    | boolean
    | undefined;
  /** Read policy. The default is to read from the primary. */
  read_policy?:
    | RedisProxy_ConnPoolSettings_ReadPolicy
    | undefined;
  /**
   * Ops or connection timeout triggers reconnection to redis server which could result in reconnection
   * storm to busy redis server. This config is a protection to rate limit reconnection rate.
   * If not set, there will be no rate limiting on the reconnection.
   */
  connection_rate_limit?: RedisProxy_ConnectionRateLimit | undefined;
}

/**
 * ReadPolicy controls how Envoy routes read commands to Redis nodes. This is currently
 * supported for Redis Cluster. All ReadPolicy settings except MASTER may return stale data
 * because replication is asynchronous and requires some delay. You need to ensure that your
 * application can tolerate stale data.
 */
export enum RedisProxy_ConnPoolSettings_ReadPolicy {
  /** MASTER - Default mode. Read from the current primary node. */
  MASTER = "MASTER",
  /** PREFER_MASTER - Read from the primary, but if it is unavailable, read from replica nodes. */
  PREFER_MASTER = "PREFER_MASTER",
  /**
   * REPLICA - Read from replica nodes. If multiple replica nodes are present within a shard, a random
   * node is selected. Healthy nodes have precedent over unhealthy nodes.
   */
  REPLICA = "REPLICA",
  /**
   * PREFER_REPLICA - Read from the replica nodes (similar to REPLICA), but if all replicas are unavailable (not
   * present or unhealthy), read from the primary.
   */
  PREFER_REPLICA = "PREFER_REPLICA",
  /**
   * ANY - Read from any node of the cluster. A random node is selected among the primary and
   * replicas, healthy nodes have precedent over unhealthy nodes.
   */
  ANY = "ANY",
}

export function redisProxy_ConnPoolSettings_ReadPolicyFromJSON(object: any): RedisProxy_ConnPoolSettings_ReadPolicy {
  switch (object) {
    case 0:
    case "MASTER":
      return RedisProxy_ConnPoolSettings_ReadPolicy.MASTER;
    case 1:
    case "PREFER_MASTER":
      return RedisProxy_ConnPoolSettings_ReadPolicy.PREFER_MASTER;
    case 2:
    case "REPLICA":
      return RedisProxy_ConnPoolSettings_ReadPolicy.REPLICA;
    case 3:
    case "PREFER_REPLICA":
      return RedisProxy_ConnPoolSettings_ReadPolicy.PREFER_REPLICA;
    case 4:
    case "ANY":
      return RedisProxy_ConnPoolSettings_ReadPolicy.ANY;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum RedisProxy_ConnPoolSettings_ReadPolicy",
      );
  }
}

export function redisProxy_ConnPoolSettings_ReadPolicyToJSON(object: RedisProxy_ConnPoolSettings_ReadPolicy): string {
  switch (object) {
    case RedisProxy_ConnPoolSettings_ReadPolicy.MASTER:
      return "MASTER";
    case RedisProxy_ConnPoolSettings_ReadPolicy.PREFER_MASTER:
      return "PREFER_MASTER";
    case RedisProxy_ConnPoolSettings_ReadPolicy.REPLICA:
      return "REPLICA";
    case RedisProxy_ConnPoolSettings_ReadPolicy.PREFER_REPLICA:
      return "PREFER_REPLICA";
    case RedisProxy_ConnPoolSettings_ReadPolicy.ANY:
      return "ANY";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum RedisProxy_ConnPoolSettings_ReadPolicy",
      );
  }
}

export function redisProxy_ConnPoolSettings_ReadPolicyToNumber(object: RedisProxy_ConnPoolSettings_ReadPolicy): number {
  switch (object) {
    case RedisProxy_ConnPoolSettings_ReadPolicy.MASTER:
      return 0;
    case RedisProxy_ConnPoolSettings_ReadPolicy.PREFER_MASTER:
      return 1;
    case RedisProxy_ConnPoolSettings_ReadPolicy.REPLICA:
      return 2;
    case RedisProxy_ConnPoolSettings_ReadPolicy.PREFER_REPLICA:
      return 3;
    case RedisProxy_ConnPoolSettings_ReadPolicy.ANY:
      return 4;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum RedisProxy_ConnPoolSettings_ReadPolicy",
      );
  }
}

export interface RedisProxy_PrefixRoutes {
  $type: "envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes";
  /** List of prefix routes. */
  routes?:
    | RedisProxy_PrefixRoutes_Route[]
    | undefined;
  /** Indicates that prefix matching should be case insensitive. */
  case_insensitive?:
    | boolean
    | undefined;
  /**
   * Optional catch-all route to forward commands that doesn't match any of the routes. The
   * catch-all route becomes required when no routes are specified.
   */
  catch_all_route?: RedisProxy_PrefixRoutes_Route | undefined;
}

/** [#next-free-field: 7] */
export interface RedisProxy_PrefixRoutes_Route {
  $type: "envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes.Route";
  /**
   * String prefix that must match the beginning of the keys. Envoy will always favor the
   * longest match.
   */
  prefix?:
    | string
    | undefined;
  /** Indicates if the prefix needs to be removed from the key when forwarded. */
  remove_prefix?:
    | boolean
    | undefined;
  /** Upstream cluster to forward the command to. */
  cluster?:
    | string
    | undefined;
  /** Indicates that the route has a request mirroring policy. */
  request_mirror_policy?:
    | RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy[]
    | undefined;
  /**
   * Indicates how redis key should be formatted. To substitute redis key into the formatting
   * expression, use %KEY% as a string replacement command.
   */
  key_formatter?:
    | string
    | undefined;
  /** Indicates that the route has a read command policy */
  read_command_policy?: RedisProxy_PrefixRoutes_Route_ReadCommandPolicy | undefined;
}

/**
 * The router is capable of shadowing traffic from one cluster to another. The current
 * implementation is "fire and forget," meaning Envoy will not wait for the shadow cluster to
 * respond before returning the response from the primary cluster. All normal statistics are
 * collected for the shadow cluster making this feature useful for testing.
 */
export interface RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy {
  $type: "envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes.Route.RequestMirrorPolicy";
  /**
   * Specifies the cluster that requests will be mirrored to. The cluster must
   * exist in the cluster manager configuration.
   */
  cluster?:
    | string
    | undefined;
  /**
   * If not specified or the runtime key is not present, all requests to the target cluster
   * will be mirrored.
   *
   * If specified, Envoy will lookup the runtime key to get the percentage of requests to the
   * mirror.
   */
  runtime_fraction?:
    | RuntimeFractionalPercent
    | undefined;
  /**
   * Set this to TRUE to only mirror write commands, this is effectively replicating the
   * writes in a "fire and forget" manner.
   */
  exclude_read_commands?: boolean | undefined;
}

/** ReadCommandPolicy specifies that Envoy should route read commands to another cluster. */
export interface RedisProxy_PrefixRoutes_Route_ReadCommandPolicy {
  $type: "envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes.Route.ReadCommandPolicy";
  cluster?: string | undefined;
}

/** RedisFault defines faults used for fault injection. */
export interface RedisProxy_RedisFault {
  $type: "envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.RedisFault";
  /** Fault type. */
  fault_type?:
    | RedisProxy_RedisFault_RedisFaultType
    | undefined;
  /** Percentage of requests fault applies to. */
  fault_enabled?:
    | RuntimeFractionalPercent
    | undefined;
  /** Delay for all faults. If not set, defaults to zero */
  delay?:
    | Duration
    | undefined;
  /**
   * Commands fault is restricted to, if any. If not set, fault applies to all commands
   * other than auth and ping (due to special handling of those commands in Envoy).
   */
  commands?: string[] | undefined;
}

export enum RedisProxy_RedisFault_RedisFaultType {
  /** DELAY - Delays requests. This is the base fault; other faults can have delays added. */
  DELAY = "DELAY",
  /** ERROR - Returns errors on requests. */
  ERROR = "ERROR",
}

export function redisProxy_RedisFault_RedisFaultTypeFromJSON(object: any): RedisProxy_RedisFault_RedisFaultType {
  switch (object) {
    case 0:
    case "DELAY":
      return RedisProxy_RedisFault_RedisFaultType.DELAY;
    case 1:
    case "ERROR":
      return RedisProxy_RedisFault_RedisFaultType.ERROR;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum RedisProxy_RedisFault_RedisFaultType",
      );
  }
}

export function redisProxy_RedisFault_RedisFaultTypeToJSON(object: RedisProxy_RedisFault_RedisFaultType): string {
  switch (object) {
    case RedisProxy_RedisFault_RedisFaultType.DELAY:
      return "DELAY";
    case RedisProxy_RedisFault_RedisFaultType.ERROR:
      return "ERROR";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum RedisProxy_RedisFault_RedisFaultType",
      );
  }
}

export function redisProxy_RedisFault_RedisFaultTypeToNumber(object: RedisProxy_RedisFault_RedisFaultType): number {
  switch (object) {
    case RedisProxy_RedisFault_RedisFaultType.DELAY:
      return 0;
    case RedisProxy_RedisFault_RedisFaultType.ERROR:
      return 1;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum RedisProxy_RedisFault_RedisFaultType",
      );
  }
}

/**
 * Configuration to limit reconnection rate to redis server to protect redis server
 * from client reconnection storm.
 */
export interface RedisProxy_ConnectionRateLimit {
  $type: "envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.ConnectionRateLimit";
  /** Reconnection rate per sec. Rate limiting is implemented with TokenBucket. */
  connection_rate_limit_per_sec?: number | undefined;
}

/**
 * RedisProtocolOptions specifies Redis upstream protocol options. This object is used in
 * :ref:`typed_extension_protocol_options<envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`,
 * keyed by the name ``envoy.filters.network.redis_proxy``.
 */
export interface RedisProtocolOptions {
  $type: "envoy.extensions.filters.network.redis_proxy.v3.RedisProtocolOptions";
  /**
   * Upstream server password as defined by the ``requirepass`` directive
   * `<https://redis.io/topics/config>`_ in the server's configuration file.
   */
  auth_password?:
    | DataSource
    | undefined;
  /**
   * Upstream server username as defined by the ``user`` directive
   * `<https://redis.io/topics/acl>`_ in the server's configuration file.
   */
  auth_username?: DataSource | undefined;
}

/**
 * RedisExternalAuthProvider specifies a gRPC service that can be used to authenticate Redis clients.
 * This service will be called every time an AUTH command is received from a client.
 * If the service returns an error, authentication is considered failed.
 * If the service returns a success, the client is considered authenticated.
 * The service can also return an expiration timestamp, which will be used to disable any further
 * commands from the client after it passes, unless a new AUTH command is received and the
 * external auth service returns a new expiration timestamp.
 */
export interface RedisExternalAuthProvider {
  $type: "envoy.extensions.filters.network.redis_proxy.v3.RedisExternalAuthProvider";
  /**
   * External auth gRPC service configuration.
   * It will be called every time an AUTH command is received from a client.
   */
  grpc_service?:
    | GrpcService
    | undefined;
  /**
   * If set to true, the filter will expect an expiration timestamp in the response from the external
   * auth service. This timestamp will be used to disable any further commands from the client after
   * the expiration time, unless a new AUTH command is received and the external auth service returns
   * a new expiration timestamp.
   */
  enable_auth_expiration?: boolean | undefined;
}

function createBaseRedisProxy(): RedisProxy {
  return { $type: "envoy.extensions.filters.network.redis_proxy.v3.RedisProxy" };
}

export const RedisProxy: MessageFns<RedisProxy, "envoy.extensions.filters.network.redis_proxy.v3.RedisProxy"> = {
  $type: "envoy.extensions.filters.network.redis_proxy.v3.RedisProxy" as const,

  encode(message: RedisProxy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stat_prefix !== undefined && message.stat_prefix !== "") {
      writer.uint32(10).string(message.stat_prefix);
    }
    if (message.settings !== undefined) {
      RedisProxy_ConnPoolSettings.encode(message.settings, writer.uint32(26).fork()).join();
    }
    if (message.latency_in_micros !== undefined && message.latency_in_micros !== false) {
      writer.uint32(32).bool(message.latency_in_micros);
    }
    if (message.prefix_routes !== undefined) {
      RedisProxy_PrefixRoutes.encode(message.prefix_routes, writer.uint32(42).fork()).join();
    }
    if (message.downstream_auth_password !== undefined) {
      DataSource.encode(message.downstream_auth_password, writer.uint32(50).fork()).join();
    }
    if (message.downstream_auth_passwords !== undefined && message.downstream_auth_passwords.length !== 0) {
      for (const v of message.downstream_auth_passwords) {
        DataSource.encode(v!, writer.uint32(74).fork()).join();
      }
    }
    if (message.faults !== undefined && message.faults.length !== 0) {
      for (const v of message.faults) {
        RedisProxy_RedisFault.encode(v!, writer.uint32(66).fork()).join();
      }
    }
    if (message.downstream_auth_username !== undefined) {
      DataSource.encode(message.downstream_auth_username, writer.uint32(58).fork()).join();
    }
    if (message.external_auth_provider !== undefined) {
      RedisExternalAuthProvider.encode(message.external_auth_provider, writer.uint32(82).fork()).join();
    }
    if (message.custom_commands !== undefined && message.custom_commands.length !== 0) {
      for (const v of message.custom_commands) {
        writer.uint32(90).string(v!);
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RedisProxy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRedisProxy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stat_prefix = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.settings = RedisProxy_ConnPoolSettings.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.latency_in_micros = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.prefix_routes = RedisProxy_PrefixRoutes.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.downstream_auth_password = DataSource.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          if (message.downstream_auth_passwords === undefined) {
            message.downstream_auth_passwords = [];
          }
          const el = DataSource.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.downstream_auth_passwords!.push(el);
          }
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          if (message.faults === undefined) {
            message.faults = [];
          }
          const el = RedisProxy_RedisFault.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.faults!.push(el);
          }
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.downstream_auth_username = DataSource.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.external_auth_provider = RedisExternalAuthProvider.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          if (message.custom_commands === undefined) {
            message.custom_commands = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.custom_commands!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RedisProxy {
    return {
      $type: RedisProxy.$type,
      stat_prefix: isSet(object.stat_prefix) ? globalThis.String(object.stat_prefix) : undefined,
      settings: isSet(object.settings) ? RedisProxy_ConnPoolSettings.fromJSON(object.settings) : undefined,
      latency_in_micros: isSet(object.latency_in_micros) ? globalThis.Boolean(object.latency_in_micros) : undefined,
      prefix_routes: isSet(object.prefix_routes) ? RedisProxy_PrefixRoutes.fromJSON(object.prefix_routes) : undefined,
      downstream_auth_password: isSet(object.downstream_auth_password)
        ? DataSource.fromJSON(object.downstream_auth_password)
        : undefined,
      downstream_auth_passwords: globalThis.Array.isArray(object?.downstream_auth_passwords)
        ? object.downstream_auth_passwords.map((e: any) => DataSource.fromJSON(e))
        : undefined,
      faults: globalThis.Array.isArray(object?.faults)
        ? object.faults.map((e: any) => RedisProxy_RedisFault.fromJSON(e))
        : undefined,
      downstream_auth_username: isSet(object.downstream_auth_username)
        ? DataSource.fromJSON(object.downstream_auth_username)
        : undefined,
      external_auth_provider: isSet(object.external_auth_provider)
        ? RedisExternalAuthProvider.fromJSON(object.external_auth_provider)
        : undefined,
      custom_commands: globalThis.Array.isArray(object?.custom_commands)
        ? object.custom_commands.map((e: any) => globalThis.String(e))
        : undefined,
    };
  },

  toJSON(message: RedisProxy): unknown {
    const obj: any = {};
    if (message.stat_prefix !== undefined) {
      obj.stat_prefix = message.stat_prefix;
    }
    if (message.settings !== undefined) {
      obj.settings = RedisProxy_ConnPoolSettings.toJSON(message.settings);
    }
    if (message.latency_in_micros !== undefined) {
      obj.latency_in_micros = message.latency_in_micros;
    }
    if (message.prefix_routes !== undefined) {
      obj.prefix_routes = RedisProxy_PrefixRoutes.toJSON(message.prefix_routes);
    }
    if (message.downstream_auth_password !== undefined) {
      obj.downstream_auth_password = DataSource.toJSON(message.downstream_auth_password);
    }
    if (message.downstream_auth_passwords?.length) {
      obj.downstream_auth_passwords = message.downstream_auth_passwords.map((e) => DataSource.toJSON(e));
    }
    if (message.faults?.length) {
      obj.faults = message.faults.map((e) => RedisProxy_RedisFault.toJSON(e));
    }
    if (message.downstream_auth_username !== undefined) {
      obj.downstream_auth_username = DataSource.toJSON(message.downstream_auth_username);
    }
    if (message.external_auth_provider !== undefined) {
      obj.external_auth_provider = RedisExternalAuthProvider.toJSON(message.external_auth_provider);
    }
    if (message.custom_commands?.length) {
      obj.custom_commands = message.custom_commands;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RedisProxy>, I>>(base?: I): RedisProxy {
    return RedisProxy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RedisProxy>, I>>(object: I): RedisProxy {
    const message = createBaseRedisProxy();
    message.stat_prefix = object.stat_prefix ?? undefined;
    message.settings = (object.settings !== undefined && object.settings !== null)
      ? RedisProxy_ConnPoolSettings.fromPartial(object.settings)
      : undefined;
    message.latency_in_micros = object.latency_in_micros ?? undefined;
    message.prefix_routes = (object.prefix_routes !== undefined && object.prefix_routes !== null)
      ? RedisProxy_PrefixRoutes.fromPartial(object.prefix_routes)
      : undefined;
    message.downstream_auth_password =
      (object.downstream_auth_password !== undefined && object.downstream_auth_password !== null)
        ? DataSource.fromPartial(object.downstream_auth_password)
        : undefined;
    message.downstream_auth_passwords = object.downstream_auth_passwords?.map((e) => DataSource.fromPartial(e)) ||
      undefined;
    message.faults = object.faults?.map((e) => RedisProxy_RedisFault.fromPartial(e)) || undefined;
    message.downstream_auth_username =
      (object.downstream_auth_username !== undefined && object.downstream_auth_username !== null)
        ? DataSource.fromPartial(object.downstream_auth_username)
        : undefined;
    message.external_auth_provider =
      (object.external_auth_provider !== undefined && object.external_auth_provider !== null)
        ? RedisExternalAuthProvider.fromPartial(object.external_auth_provider)
        : undefined;
    message.custom_commands = object.custom_commands?.map((e) => e) || undefined;
    return message;
  },
};

messageTypeRegistry.set(RedisProxy.$type, RedisProxy);

function createBaseRedisProxy_ConnPoolSettings(): RedisProxy_ConnPoolSettings {
  return { $type: "envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.ConnPoolSettings" };
}

export const RedisProxy_ConnPoolSettings: MessageFns<
  RedisProxy_ConnPoolSettings,
  "envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.ConnPoolSettings"
> = {
  $type: "envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.ConnPoolSettings" as const,

  encode(message: RedisProxy_ConnPoolSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.op_timeout !== undefined) {
      Duration.encode(message.op_timeout, writer.uint32(10).fork()).join();
    }
    if (message.enable_hashtagging !== undefined && message.enable_hashtagging !== false) {
      writer.uint32(16).bool(message.enable_hashtagging);
    }
    if (message.enable_redirection !== undefined && message.enable_redirection !== false) {
      writer.uint32(24).bool(message.enable_redirection);
    }
    if (message.dns_cache_config !== undefined) {
      DnsCacheConfig.encode(message.dns_cache_config, writer.uint32(74).fork()).join();
    }
    if (message.max_buffer_size_before_flush !== undefined && message.max_buffer_size_before_flush !== 0) {
      writer.uint32(32).uint32(message.max_buffer_size_before_flush);
    }
    if (message.buffer_flush_timeout !== undefined) {
      Duration.encode(message.buffer_flush_timeout, writer.uint32(42).fork()).join();
    }
    if (message.max_upstream_unknown_connections !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.max_upstream_unknown_connections! },
        writer.uint32(50).fork(),
      ).join();
    }
    if (message.enable_command_stats !== undefined && message.enable_command_stats !== false) {
      writer.uint32(64).bool(message.enable_command_stats);
    }
    if (message.read_policy !== undefined && message.read_policy !== RedisProxy_ConnPoolSettings_ReadPolicy.MASTER) {
      writer.uint32(56).int32(redisProxy_ConnPoolSettings_ReadPolicyToNumber(message.read_policy));
    }
    if (message.connection_rate_limit !== undefined) {
      RedisProxy_ConnectionRateLimit.encode(message.connection_rate_limit, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RedisProxy_ConnPoolSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRedisProxy_ConnPoolSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.op_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.enable_hashtagging = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.enable_redirection = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.dns_cache_config = DnsCacheConfig.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.max_buffer_size_before_flush = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.buffer_flush_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.max_upstream_unknown_connections = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.enable_command_stats = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.read_policy = redisProxy_ConnPoolSettings_ReadPolicyFromJSON(reader.int32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.connection_rate_limit = RedisProxy_ConnectionRateLimit.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RedisProxy_ConnPoolSettings {
    return {
      $type: RedisProxy_ConnPoolSettings.$type,
      op_timeout: isSet(object.op_timeout) ? Duration.fromJSON(object.op_timeout) : undefined,
      enable_hashtagging: isSet(object.enable_hashtagging) ? globalThis.Boolean(object.enable_hashtagging) : undefined,
      enable_redirection: isSet(object.enable_redirection) ? globalThis.Boolean(object.enable_redirection) : undefined,
      dns_cache_config: isSet(object.dns_cache_config) ? DnsCacheConfig.fromJSON(object.dns_cache_config) : undefined,
      max_buffer_size_before_flush: isSet(object.max_buffer_size_before_flush)
        ? globalThis.Number(object.max_buffer_size_before_flush)
        : undefined,
      buffer_flush_timeout: isSet(object.buffer_flush_timeout)
        ? Duration.fromJSON(object.buffer_flush_timeout)
        : undefined,
      max_upstream_unknown_connections: isSet(object.max_upstream_unknown_connections)
        ? Number(object.max_upstream_unknown_connections)
        : undefined,
      enable_command_stats: isSet(object.enable_command_stats)
        ? globalThis.Boolean(object.enable_command_stats)
        : undefined,
      read_policy: isSet(object.read_policy)
        ? redisProxy_ConnPoolSettings_ReadPolicyFromJSON(object.read_policy)
        : undefined,
      connection_rate_limit: isSet(object.connection_rate_limit)
        ? RedisProxy_ConnectionRateLimit.fromJSON(object.connection_rate_limit)
        : undefined,
    };
  },

  toJSON(message: RedisProxy_ConnPoolSettings): unknown {
    const obj: any = {};
    if (message.op_timeout !== undefined) {
      obj.op_timeout = Duration.toJSON(message.op_timeout);
    }
    if (message.enable_hashtagging !== undefined) {
      obj.enable_hashtagging = message.enable_hashtagging;
    }
    if (message.enable_redirection !== undefined) {
      obj.enable_redirection = message.enable_redirection;
    }
    if (message.dns_cache_config !== undefined) {
      obj.dns_cache_config = DnsCacheConfig.toJSON(message.dns_cache_config);
    }
    if (message.max_buffer_size_before_flush !== undefined) {
      obj.max_buffer_size_before_flush = Math.round(message.max_buffer_size_before_flush);
    }
    if (message.buffer_flush_timeout !== undefined) {
      obj.buffer_flush_timeout = Duration.toJSON(message.buffer_flush_timeout);
    }
    if (message.max_upstream_unknown_connections !== undefined) {
      obj.max_upstream_unknown_connections = message.max_upstream_unknown_connections;
    }
    if (message.enable_command_stats !== undefined) {
      obj.enable_command_stats = message.enable_command_stats;
    }
    if (message.read_policy !== undefined) {
      obj.read_policy = redisProxy_ConnPoolSettings_ReadPolicyToJSON(message.read_policy);
    }
    if (message.connection_rate_limit !== undefined) {
      obj.connection_rate_limit = RedisProxy_ConnectionRateLimit.toJSON(message.connection_rate_limit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RedisProxy_ConnPoolSettings>, I>>(base?: I): RedisProxy_ConnPoolSettings {
    return RedisProxy_ConnPoolSettings.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RedisProxy_ConnPoolSettings>, I>>(object: I): RedisProxy_ConnPoolSettings {
    const message = createBaseRedisProxy_ConnPoolSettings();
    message.op_timeout = (object.op_timeout !== undefined && object.op_timeout !== null)
      ? Duration.fromPartial(object.op_timeout)
      : undefined;
    message.enable_hashtagging = object.enable_hashtagging ?? undefined;
    message.enable_redirection = object.enable_redirection ?? undefined;
    message.dns_cache_config = (object.dns_cache_config !== undefined && object.dns_cache_config !== null)
      ? DnsCacheConfig.fromPartial(object.dns_cache_config)
      : undefined;
    message.max_buffer_size_before_flush = object.max_buffer_size_before_flush ?? undefined;
    message.buffer_flush_timeout = (object.buffer_flush_timeout !== undefined && object.buffer_flush_timeout !== null)
      ? Duration.fromPartial(object.buffer_flush_timeout)
      : undefined;
    message.max_upstream_unknown_connections = object.max_upstream_unknown_connections ?? undefined;
    message.enable_command_stats = object.enable_command_stats ?? undefined;
    message.read_policy = object.read_policy ?? undefined;
    message.connection_rate_limit =
      (object.connection_rate_limit !== undefined && object.connection_rate_limit !== null)
        ? RedisProxy_ConnectionRateLimit.fromPartial(object.connection_rate_limit)
        : undefined;
    return message;
  },
};

messageTypeRegistry.set(RedisProxy_ConnPoolSettings.$type, RedisProxy_ConnPoolSettings);

function createBaseRedisProxy_PrefixRoutes(): RedisProxy_PrefixRoutes {
  return { $type: "envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes" };
}

export const RedisProxy_PrefixRoutes: MessageFns<
  RedisProxy_PrefixRoutes,
  "envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes"
> = {
  $type: "envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes" as const,

  encode(message: RedisProxy_PrefixRoutes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.routes !== undefined && message.routes.length !== 0) {
      for (const v of message.routes) {
        RedisProxy_PrefixRoutes_Route.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    if (message.case_insensitive !== undefined && message.case_insensitive !== false) {
      writer.uint32(16).bool(message.case_insensitive);
    }
    if (message.catch_all_route !== undefined) {
      RedisProxy_PrefixRoutes_Route.encode(message.catch_all_route, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RedisProxy_PrefixRoutes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRedisProxy_PrefixRoutes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.routes === undefined) {
            message.routes = [];
          }
          const el = RedisProxy_PrefixRoutes_Route.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.routes!.push(el);
          }
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.case_insensitive = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.catch_all_route = RedisProxy_PrefixRoutes_Route.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RedisProxy_PrefixRoutes {
    return {
      $type: RedisProxy_PrefixRoutes.$type,
      routes: globalThis.Array.isArray(object?.routes)
        ? object.routes.map((e: any) => RedisProxy_PrefixRoutes_Route.fromJSON(e))
        : undefined,
      case_insensitive: isSet(object.case_insensitive) ? globalThis.Boolean(object.case_insensitive) : undefined,
      catch_all_route: isSet(object.catch_all_route)
        ? RedisProxy_PrefixRoutes_Route.fromJSON(object.catch_all_route)
        : undefined,
    };
  },

  toJSON(message: RedisProxy_PrefixRoutes): unknown {
    const obj: any = {};
    if (message.routes?.length) {
      obj.routes = message.routes.map((e) => RedisProxy_PrefixRoutes_Route.toJSON(e));
    }
    if (message.case_insensitive !== undefined) {
      obj.case_insensitive = message.case_insensitive;
    }
    if (message.catch_all_route !== undefined) {
      obj.catch_all_route = RedisProxy_PrefixRoutes_Route.toJSON(message.catch_all_route);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RedisProxy_PrefixRoutes>, I>>(base?: I): RedisProxy_PrefixRoutes {
    return RedisProxy_PrefixRoutes.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RedisProxy_PrefixRoutes>, I>>(object: I): RedisProxy_PrefixRoutes {
    const message = createBaseRedisProxy_PrefixRoutes();
    message.routes = object.routes?.map((e) => RedisProxy_PrefixRoutes_Route.fromPartial(e)) || undefined;
    message.case_insensitive = object.case_insensitive ?? undefined;
    message.catch_all_route = (object.catch_all_route !== undefined && object.catch_all_route !== null)
      ? RedisProxy_PrefixRoutes_Route.fromPartial(object.catch_all_route)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(RedisProxy_PrefixRoutes.$type, RedisProxy_PrefixRoutes);

function createBaseRedisProxy_PrefixRoutes_Route(): RedisProxy_PrefixRoutes_Route {
  return { $type: "envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes.Route" };
}

export const RedisProxy_PrefixRoutes_Route: MessageFns<
  RedisProxy_PrefixRoutes_Route,
  "envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes.Route"
> = {
  $type: "envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes.Route" as const,

  encode(message: RedisProxy_PrefixRoutes_Route, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prefix !== undefined && message.prefix !== "") {
      writer.uint32(10).string(message.prefix);
    }
    if (message.remove_prefix !== undefined && message.remove_prefix !== false) {
      writer.uint32(16).bool(message.remove_prefix);
    }
    if (message.cluster !== undefined && message.cluster !== "") {
      writer.uint32(26).string(message.cluster);
    }
    if (message.request_mirror_policy !== undefined && message.request_mirror_policy.length !== 0) {
      for (const v of message.request_mirror_policy) {
        RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    if (message.key_formatter !== undefined && message.key_formatter !== "") {
      writer.uint32(42).string(message.key_formatter);
    }
    if (message.read_command_policy !== undefined) {
      RedisProxy_PrefixRoutes_Route_ReadCommandPolicy.encode(message.read_command_policy, writer.uint32(50).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RedisProxy_PrefixRoutes_Route {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRedisProxy_PrefixRoutes_Route();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.prefix = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.remove_prefix = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.cluster = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          if (message.request_mirror_policy === undefined) {
            message.request_mirror_policy = [];
          }
          const el = RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.request_mirror_policy!.push(el);
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.key_formatter = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.read_command_policy = RedisProxy_PrefixRoutes_Route_ReadCommandPolicy.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RedisProxy_PrefixRoutes_Route {
    return {
      $type: RedisProxy_PrefixRoutes_Route.$type,
      prefix: isSet(object.prefix) ? globalThis.String(object.prefix) : undefined,
      remove_prefix: isSet(object.remove_prefix) ? globalThis.Boolean(object.remove_prefix) : undefined,
      cluster: isSet(object.cluster) ? globalThis.String(object.cluster) : undefined,
      request_mirror_policy: globalThis.Array.isArray(object?.request_mirror_policy)
        ? object.request_mirror_policy.map((e: any) => RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy.fromJSON(e))
        : undefined,
      key_formatter: isSet(object.key_formatter) ? globalThis.String(object.key_formatter) : undefined,
      read_command_policy: isSet(object.read_command_policy)
        ? RedisProxy_PrefixRoutes_Route_ReadCommandPolicy.fromJSON(object.read_command_policy)
        : undefined,
    };
  },

  toJSON(message: RedisProxy_PrefixRoutes_Route): unknown {
    const obj: any = {};
    if (message.prefix !== undefined) {
      obj.prefix = message.prefix;
    }
    if (message.remove_prefix !== undefined) {
      obj.remove_prefix = message.remove_prefix;
    }
    if (message.cluster !== undefined) {
      obj.cluster = message.cluster;
    }
    if (message.request_mirror_policy?.length) {
      obj.request_mirror_policy = message.request_mirror_policy.map((e) =>
        RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy.toJSON(e)
      );
    }
    if (message.key_formatter !== undefined) {
      obj.key_formatter = message.key_formatter;
    }
    if (message.read_command_policy !== undefined) {
      obj.read_command_policy = RedisProxy_PrefixRoutes_Route_ReadCommandPolicy.toJSON(message.read_command_policy);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RedisProxy_PrefixRoutes_Route>, I>>(base?: I): RedisProxy_PrefixRoutes_Route {
    return RedisProxy_PrefixRoutes_Route.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RedisProxy_PrefixRoutes_Route>, I>>(
    object: I,
  ): RedisProxy_PrefixRoutes_Route {
    const message = createBaseRedisProxy_PrefixRoutes_Route();
    message.prefix = object.prefix ?? undefined;
    message.remove_prefix = object.remove_prefix ?? undefined;
    message.cluster = object.cluster ?? undefined;
    message.request_mirror_policy =
      object.request_mirror_policy?.map((e) => RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy.fromPartial(e)) ||
      undefined;
    message.key_formatter = object.key_formatter ?? undefined;
    message.read_command_policy = (object.read_command_policy !== undefined && object.read_command_policy !== null)
      ? RedisProxy_PrefixRoutes_Route_ReadCommandPolicy.fromPartial(object.read_command_policy)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(RedisProxy_PrefixRoutes_Route.$type, RedisProxy_PrefixRoutes_Route);

function createBaseRedisProxy_PrefixRoutes_Route_RequestMirrorPolicy(): RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy {
  return { $type: "envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes.Route.RequestMirrorPolicy" };
}

export const RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy: MessageFns<
  RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy,
  "envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes.Route.RequestMirrorPolicy"
> = {
  $type: "envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes.Route.RequestMirrorPolicy" as const,

  encode(
    message: RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.cluster !== undefined && message.cluster !== "") {
      writer.uint32(10).string(message.cluster);
    }
    if (message.runtime_fraction !== undefined) {
      RuntimeFractionalPercent.encode(message.runtime_fraction, writer.uint32(18).fork()).join();
    }
    if (message.exclude_read_commands !== undefined && message.exclude_read_commands !== false) {
      writer.uint32(24).bool(message.exclude_read_commands);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRedisProxy_PrefixRoutes_Route_RequestMirrorPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cluster = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.runtime_fraction = RuntimeFractionalPercent.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.exclude_read_commands = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy {
    return {
      $type: RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy.$type,
      cluster: isSet(object.cluster) ? globalThis.String(object.cluster) : undefined,
      runtime_fraction: isSet(object.runtime_fraction)
        ? RuntimeFractionalPercent.fromJSON(object.runtime_fraction)
        : undefined,
      exclude_read_commands: isSet(object.exclude_read_commands)
        ? globalThis.Boolean(object.exclude_read_commands)
        : undefined,
    };
  },

  toJSON(message: RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy): unknown {
    const obj: any = {};
    if (message.cluster !== undefined) {
      obj.cluster = message.cluster;
    }
    if (message.runtime_fraction !== undefined) {
      obj.runtime_fraction = RuntimeFractionalPercent.toJSON(message.runtime_fraction);
    }
    if (message.exclude_read_commands !== undefined) {
      obj.exclude_read_commands = message.exclude_read_commands;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy>, I>>(
    base?: I,
  ): RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy {
    return RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy>, I>>(
    object: I,
  ): RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy {
    const message = createBaseRedisProxy_PrefixRoutes_Route_RequestMirrorPolicy();
    message.cluster = object.cluster ?? undefined;
    message.runtime_fraction = (object.runtime_fraction !== undefined && object.runtime_fraction !== null)
      ? RuntimeFractionalPercent.fromPartial(object.runtime_fraction)
      : undefined;
    message.exclude_read_commands = object.exclude_read_commands ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(
  RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy.$type,
  RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy,
);

function createBaseRedisProxy_PrefixRoutes_Route_ReadCommandPolicy(): RedisProxy_PrefixRoutes_Route_ReadCommandPolicy {
  return { $type: "envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes.Route.ReadCommandPolicy" };
}

export const RedisProxy_PrefixRoutes_Route_ReadCommandPolicy: MessageFns<
  RedisProxy_PrefixRoutes_Route_ReadCommandPolicy,
  "envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes.Route.ReadCommandPolicy"
> = {
  $type: "envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes.Route.ReadCommandPolicy" as const,

  encode(
    message: RedisProxy_PrefixRoutes_Route_ReadCommandPolicy,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.cluster !== undefined && message.cluster !== "") {
      writer.uint32(10).string(message.cluster);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RedisProxy_PrefixRoutes_Route_ReadCommandPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRedisProxy_PrefixRoutes_Route_ReadCommandPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cluster = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RedisProxy_PrefixRoutes_Route_ReadCommandPolicy {
    return {
      $type: RedisProxy_PrefixRoutes_Route_ReadCommandPolicy.$type,
      cluster: isSet(object.cluster) ? globalThis.String(object.cluster) : undefined,
    };
  },

  toJSON(message: RedisProxy_PrefixRoutes_Route_ReadCommandPolicy): unknown {
    const obj: any = {};
    if (message.cluster !== undefined) {
      obj.cluster = message.cluster;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RedisProxy_PrefixRoutes_Route_ReadCommandPolicy>, I>>(
    base?: I,
  ): RedisProxy_PrefixRoutes_Route_ReadCommandPolicy {
    return RedisProxy_PrefixRoutes_Route_ReadCommandPolicy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RedisProxy_PrefixRoutes_Route_ReadCommandPolicy>, I>>(
    object: I,
  ): RedisProxy_PrefixRoutes_Route_ReadCommandPolicy {
    const message = createBaseRedisProxy_PrefixRoutes_Route_ReadCommandPolicy();
    message.cluster = object.cluster ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(
  RedisProxy_PrefixRoutes_Route_ReadCommandPolicy.$type,
  RedisProxy_PrefixRoutes_Route_ReadCommandPolicy,
);

function createBaseRedisProxy_RedisFault(): RedisProxy_RedisFault {
  return { $type: "envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.RedisFault" };
}

export const RedisProxy_RedisFault: MessageFns<
  RedisProxy_RedisFault,
  "envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.RedisFault"
> = {
  $type: "envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.RedisFault" as const,

  encode(message: RedisProxy_RedisFault, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fault_type !== undefined && message.fault_type !== RedisProxy_RedisFault_RedisFaultType.DELAY) {
      writer.uint32(8).int32(redisProxy_RedisFault_RedisFaultTypeToNumber(message.fault_type));
    }
    if (message.fault_enabled !== undefined) {
      RuntimeFractionalPercent.encode(message.fault_enabled, writer.uint32(18).fork()).join();
    }
    if (message.delay !== undefined) {
      Duration.encode(message.delay, writer.uint32(26).fork()).join();
    }
    if (message.commands !== undefined && message.commands.length !== 0) {
      for (const v of message.commands) {
        writer.uint32(34).string(v!);
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RedisProxy_RedisFault {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRedisProxy_RedisFault();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fault_type = redisProxy_RedisFault_RedisFaultTypeFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fault_enabled = RuntimeFractionalPercent.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.delay = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          if (message.commands === undefined) {
            message.commands = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.commands!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RedisProxy_RedisFault {
    return {
      $type: RedisProxy_RedisFault.$type,
      fault_type: isSet(object.fault_type)
        ? redisProxy_RedisFault_RedisFaultTypeFromJSON(object.fault_type)
        : undefined,
      fault_enabled: isSet(object.fault_enabled) ? RuntimeFractionalPercent.fromJSON(object.fault_enabled) : undefined,
      delay: isSet(object.delay) ? Duration.fromJSON(object.delay) : undefined,
      commands: globalThis.Array.isArray(object?.commands)
        ? object.commands.map((e: any) => globalThis.String(e))
        : undefined,
    };
  },

  toJSON(message: RedisProxy_RedisFault): unknown {
    const obj: any = {};
    if (message.fault_type !== undefined) {
      obj.fault_type = redisProxy_RedisFault_RedisFaultTypeToJSON(message.fault_type);
    }
    if (message.fault_enabled !== undefined) {
      obj.fault_enabled = RuntimeFractionalPercent.toJSON(message.fault_enabled);
    }
    if (message.delay !== undefined) {
      obj.delay = Duration.toJSON(message.delay);
    }
    if (message.commands?.length) {
      obj.commands = message.commands;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RedisProxy_RedisFault>, I>>(base?: I): RedisProxy_RedisFault {
    return RedisProxy_RedisFault.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RedisProxy_RedisFault>, I>>(object: I): RedisProxy_RedisFault {
    const message = createBaseRedisProxy_RedisFault();
    message.fault_type = object.fault_type ?? undefined;
    message.fault_enabled = (object.fault_enabled !== undefined && object.fault_enabled !== null)
      ? RuntimeFractionalPercent.fromPartial(object.fault_enabled)
      : undefined;
    message.delay = (object.delay !== undefined && object.delay !== null)
      ? Duration.fromPartial(object.delay)
      : undefined;
    message.commands = object.commands?.map((e) => e) || undefined;
    return message;
  },
};

messageTypeRegistry.set(RedisProxy_RedisFault.$type, RedisProxy_RedisFault);

function createBaseRedisProxy_ConnectionRateLimit(): RedisProxy_ConnectionRateLimit {
  return { $type: "envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.ConnectionRateLimit" };
}

export const RedisProxy_ConnectionRateLimit: MessageFns<
  RedisProxy_ConnectionRateLimit,
  "envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.ConnectionRateLimit"
> = {
  $type: "envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.ConnectionRateLimit" as const,

  encode(message: RedisProxy_ConnectionRateLimit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connection_rate_limit_per_sec !== undefined && message.connection_rate_limit_per_sec !== 0) {
      writer.uint32(8).uint32(message.connection_rate_limit_per_sec);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RedisProxy_ConnectionRateLimit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRedisProxy_ConnectionRateLimit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.connection_rate_limit_per_sec = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RedisProxy_ConnectionRateLimit {
    return {
      $type: RedisProxy_ConnectionRateLimit.$type,
      connection_rate_limit_per_sec: isSet(object.connection_rate_limit_per_sec)
        ? globalThis.Number(object.connection_rate_limit_per_sec)
        : undefined,
    };
  },

  toJSON(message: RedisProxy_ConnectionRateLimit): unknown {
    const obj: any = {};
    if (message.connection_rate_limit_per_sec !== undefined) {
      obj.connection_rate_limit_per_sec = Math.round(message.connection_rate_limit_per_sec);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RedisProxy_ConnectionRateLimit>, I>>(base?: I): RedisProxy_ConnectionRateLimit {
    return RedisProxy_ConnectionRateLimit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RedisProxy_ConnectionRateLimit>, I>>(
    object: I,
  ): RedisProxy_ConnectionRateLimit {
    const message = createBaseRedisProxy_ConnectionRateLimit();
    message.connection_rate_limit_per_sec = object.connection_rate_limit_per_sec ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RedisProxy_ConnectionRateLimit.$type, RedisProxy_ConnectionRateLimit);

function createBaseRedisProtocolOptions(): RedisProtocolOptions {
  return { $type: "envoy.extensions.filters.network.redis_proxy.v3.RedisProtocolOptions" };
}

export const RedisProtocolOptions: MessageFns<
  RedisProtocolOptions,
  "envoy.extensions.filters.network.redis_proxy.v3.RedisProtocolOptions"
> = {
  $type: "envoy.extensions.filters.network.redis_proxy.v3.RedisProtocolOptions" as const,

  encode(message: RedisProtocolOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.auth_password !== undefined) {
      DataSource.encode(message.auth_password, writer.uint32(10).fork()).join();
    }
    if (message.auth_username !== undefined) {
      DataSource.encode(message.auth_username, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RedisProtocolOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRedisProtocolOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.auth_password = DataSource.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.auth_username = DataSource.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RedisProtocolOptions {
    return {
      $type: RedisProtocolOptions.$type,
      auth_password: isSet(object.auth_password) ? DataSource.fromJSON(object.auth_password) : undefined,
      auth_username: isSet(object.auth_username) ? DataSource.fromJSON(object.auth_username) : undefined,
    };
  },

  toJSON(message: RedisProtocolOptions): unknown {
    const obj: any = {};
    if (message.auth_password !== undefined) {
      obj.auth_password = DataSource.toJSON(message.auth_password);
    }
    if (message.auth_username !== undefined) {
      obj.auth_username = DataSource.toJSON(message.auth_username);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RedisProtocolOptions>, I>>(base?: I): RedisProtocolOptions {
    return RedisProtocolOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RedisProtocolOptions>, I>>(object: I): RedisProtocolOptions {
    const message = createBaseRedisProtocolOptions();
    message.auth_password = (object.auth_password !== undefined && object.auth_password !== null)
      ? DataSource.fromPartial(object.auth_password)
      : undefined;
    message.auth_username = (object.auth_username !== undefined && object.auth_username !== null)
      ? DataSource.fromPartial(object.auth_username)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(RedisProtocolOptions.$type, RedisProtocolOptions);

function createBaseRedisExternalAuthProvider(): RedisExternalAuthProvider {
  return { $type: "envoy.extensions.filters.network.redis_proxy.v3.RedisExternalAuthProvider" };
}

export const RedisExternalAuthProvider: MessageFns<
  RedisExternalAuthProvider,
  "envoy.extensions.filters.network.redis_proxy.v3.RedisExternalAuthProvider"
> = {
  $type: "envoy.extensions.filters.network.redis_proxy.v3.RedisExternalAuthProvider" as const,

  encode(message: RedisExternalAuthProvider, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.grpc_service !== undefined) {
      GrpcService.encode(message.grpc_service, writer.uint32(10).fork()).join();
    }
    if (message.enable_auth_expiration !== undefined && message.enable_auth_expiration !== false) {
      writer.uint32(16).bool(message.enable_auth_expiration);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RedisExternalAuthProvider {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRedisExternalAuthProvider();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.grpc_service = GrpcService.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.enable_auth_expiration = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RedisExternalAuthProvider {
    return {
      $type: RedisExternalAuthProvider.$type,
      grpc_service: isSet(object.grpc_service) ? GrpcService.fromJSON(object.grpc_service) : undefined,
      enable_auth_expiration: isSet(object.enable_auth_expiration)
        ? globalThis.Boolean(object.enable_auth_expiration)
        : undefined,
    };
  },

  toJSON(message: RedisExternalAuthProvider): unknown {
    const obj: any = {};
    if (message.grpc_service !== undefined) {
      obj.grpc_service = GrpcService.toJSON(message.grpc_service);
    }
    if (message.enable_auth_expiration !== undefined) {
      obj.enable_auth_expiration = message.enable_auth_expiration;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RedisExternalAuthProvider>, I>>(base?: I): RedisExternalAuthProvider {
    return RedisExternalAuthProvider.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RedisExternalAuthProvider>, I>>(object: I): RedisExternalAuthProvider {
    const message = createBaseRedisExternalAuthProvider();
    message.grpc_service = (object.grpc_service !== undefined && object.grpc_service !== null)
      ? GrpcService.fromPartial(object.grpc_service)
      : undefined;
    message.enable_auth_expiration = object.enable_auth_expiration ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RedisExternalAuthProvider.$type, RedisExternalAuthProvider);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
