// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/filters/http/decompressor/v3/decompressor.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { BoolValue } from "../../../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../../../typeRegistry";
import { RuntimeFeatureFlag } from "../../../../../config/core/v3/base";
import { TypedExtensionConfig } from "../../../../../config/core/v3/extension";

export const protobufPackage = "envoy.extensions.filters.http.decompressor.v3";

export interface Decompressor {
  $type: "envoy.extensions.filters.http.decompressor.v3.Decompressor";
  /**
   * A decompressor library to use for both request and response decompression. Currently only
   * :ref:`envoy.compression.gzip.compressor<envoy_v3_api_msg_extensions.compression.gzip.decompressor.v3.Gzip>`
   * is included in Envoy.
   * [#extension-category: envoy.compression.decompressor]
   */
  decompressor_library?:
    | TypedExtensionConfig
    | undefined;
  /** Configuration for request decompression. Decompression is enabled by default if left empty. */
  request_direction_config?:
    | Decompressor_RequestDirectionConfig
    | undefined;
  /** Configuration for response decompression. Decompression is enabled by default if left empty. */
  response_direction_config?: Decompressor_ResponseDirectionConfig | undefined;
}

/** Common configuration for filter behavior on both the request and response direction. */
export interface Decompressor_CommonDirectionConfig {
  $type: "envoy.extensions.filters.http.decompressor.v3.Decompressor.CommonDirectionConfig";
  /**
   * Runtime flag that controls whether the filter is enabled for decompression or not. If set to false, the
   * filter will operate as a pass-through filter. If the message is unspecified, the filter will be enabled.
   */
  enabled?:
    | RuntimeFeatureFlag
    | undefined;
  /** If set to true, will decompress response even if a ``no-transform`` cache control header is set. */
  ignore_no_transform_header?: boolean | undefined;
}

/** Configuration for filter behavior on the request direction. */
export interface Decompressor_RequestDirectionConfig {
  $type: "envoy.extensions.filters.http.decompressor.v3.Decompressor.RequestDirectionConfig";
  common_config?:
    | Decompressor_CommonDirectionConfig
    | undefined;
  /**
   * If set to true, and response decompression is enabled, the filter modifies the Accept-Encoding
   * request header by appending the decompressor_library's encoding. Defaults to true.
   */
  advertise_accept_encoding?: boolean | undefined;
}

/** Configuration for filter behavior on the response direction. */
export interface Decompressor_ResponseDirectionConfig {
  $type: "envoy.extensions.filters.http.decompressor.v3.Decompressor.ResponseDirectionConfig";
  common_config?: Decompressor_CommonDirectionConfig | undefined;
}

function createBaseDecompressor(): Decompressor {
  return { $type: "envoy.extensions.filters.http.decompressor.v3.Decompressor" };
}

export const Decompressor: MessageFns<Decompressor, "envoy.extensions.filters.http.decompressor.v3.Decompressor"> = {
  $type: "envoy.extensions.filters.http.decompressor.v3.Decompressor" as const,

  encode(message: Decompressor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.decompressor_library !== undefined) {
      TypedExtensionConfig.encode(message.decompressor_library, writer.uint32(10).fork()).join();
    }
    if (message.request_direction_config !== undefined) {
      Decompressor_RequestDirectionConfig.encode(message.request_direction_config, writer.uint32(18).fork()).join();
    }
    if (message.response_direction_config !== undefined) {
      Decompressor_ResponseDirectionConfig.encode(message.response_direction_config, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Decompressor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecompressor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.decompressor_library = TypedExtensionConfig.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.request_direction_config = Decompressor_RequestDirectionConfig.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.response_direction_config = Decompressor_ResponseDirectionConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Decompressor {
    return {
      $type: Decompressor.$type,
      decompressor_library: isSet(object.decompressor_library)
        ? TypedExtensionConfig.fromJSON(object.decompressor_library)
        : undefined,
      request_direction_config: isSet(object.request_direction_config)
        ? Decompressor_RequestDirectionConfig.fromJSON(object.request_direction_config)
        : undefined,
      response_direction_config: isSet(object.response_direction_config)
        ? Decompressor_ResponseDirectionConfig.fromJSON(object.response_direction_config)
        : undefined,
    };
  },

  toJSON(message: Decompressor): unknown {
    const obj: any = {};
    if (message.decompressor_library !== undefined) {
      obj.decompressor_library = TypedExtensionConfig.toJSON(message.decompressor_library);
    }
    if (message.request_direction_config !== undefined) {
      obj.request_direction_config = Decompressor_RequestDirectionConfig.toJSON(message.request_direction_config);
    }
    if (message.response_direction_config !== undefined) {
      obj.response_direction_config = Decompressor_ResponseDirectionConfig.toJSON(message.response_direction_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Decompressor>, I>>(base?: I): Decompressor {
    return Decompressor.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Decompressor>, I>>(object: I): Decompressor {
    const message = createBaseDecompressor();
    message.decompressor_library = (object.decompressor_library !== undefined && object.decompressor_library !== null)
      ? TypedExtensionConfig.fromPartial(object.decompressor_library)
      : undefined;
    message.request_direction_config =
      (object.request_direction_config !== undefined && object.request_direction_config !== null)
        ? Decompressor_RequestDirectionConfig.fromPartial(object.request_direction_config)
        : undefined;
    message.response_direction_config =
      (object.response_direction_config !== undefined && object.response_direction_config !== null)
        ? Decompressor_ResponseDirectionConfig.fromPartial(object.response_direction_config)
        : undefined;
    return message;
  },
};

messageTypeRegistry.set(Decompressor.$type, Decompressor);

function createBaseDecompressor_CommonDirectionConfig(): Decompressor_CommonDirectionConfig {
  return { $type: "envoy.extensions.filters.http.decompressor.v3.Decompressor.CommonDirectionConfig" };
}

export const Decompressor_CommonDirectionConfig: MessageFns<
  Decompressor_CommonDirectionConfig,
  "envoy.extensions.filters.http.decompressor.v3.Decompressor.CommonDirectionConfig"
> = {
  $type: "envoy.extensions.filters.http.decompressor.v3.Decompressor.CommonDirectionConfig" as const,

  encode(message: Decompressor_CommonDirectionConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== undefined) {
      RuntimeFeatureFlag.encode(message.enabled, writer.uint32(10).fork()).join();
    }
    if (message.ignore_no_transform_header !== undefined && message.ignore_no_transform_header !== false) {
      writer.uint32(16).bool(message.ignore_no_transform_header);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Decompressor_CommonDirectionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecompressor_CommonDirectionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.enabled = RuntimeFeatureFlag.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.ignore_no_transform_header = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Decompressor_CommonDirectionConfig {
    return {
      $type: Decompressor_CommonDirectionConfig.$type,
      enabled: isSet(object.enabled) ? RuntimeFeatureFlag.fromJSON(object.enabled) : undefined,
      ignore_no_transform_header: isSet(object.ignore_no_transform_header)
        ? globalThis.Boolean(object.ignore_no_transform_header)
        : undefined,
    };
  },

  toJSON(message: Decompressor_CommonDirectionConfig): unknown {
    const obj: any = {};
    if (message.enabled !== undefined) {
      obj.enabled = RuntimeFeatureFlag.toJSON(message.enabled);
    }
    if (message.ignore_no_transform_header !== undefined) {
      obj.ignore_no_transform_header = message.ignore_no_transform_header;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Decompressor_CommonDirectionConfig>, I>>(
    base?: I,
  ): Decompressor_CommonDirectionConfig {
    return Decompressor_CommonDirectionConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Decompressor_CommonDirectionConfig>, I>>(
    object: I,
  ): Decompressor_CommonDirectionConfig {
    const message = createBaseDecompressor_CommonDirectionConfig();
    message.enabled = (object.enabled !== undefined && object.enabled !== null)
      ? RuntimeFeatureFlag.fromPartial(object.enabled)
      : undefined;
    message.ignore_no_transform_header = object.ignore_no_transform_header ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Decompressor_CommonDirectionConfig.$type, Decompressor_CommonDirectionConfig);

function createBaseDecompressor_RequestDirectionConfig(): Decompressor_RequestDirectionConfig {
  return { $type: "envoy.extensions.filters.http.decompressor.v3.Decompressor.RequestDirectionConfig" };
}

export const Decompressor_RequestDirectionConfig: MessageFns<
  Decompressor_RequestDirectionConfig,
  "envoy.extensions.filters.http.decompressor.v3.Decompressor.RequestDirectionConfig"
> = {
  $type: "envoy.extensions.filters.http.decompressor.v3.Decompressor.RequestDirectionConfig" as const,

  encode(message: Decompressor_RequestDirectionConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common_config !== undefined) {
      Decompressor_CommonDirectionConfig.encode(message.common_config, writer.uint32(10).fork()).join();
    }
    if (message.advertise_accept_encoding !== undefined) {
      BoolValue.encode(
        { $type: "google.protobuf.BoolValue", value: message.advertise_accept_encoding! },
        writer.uint32(18).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Decompressor_RequestDirectionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecompressor_RequestDirectionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common_config = Decompressor_CommonDirectionConfig.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.advertise_accept_encoding = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Decompressor_RequestDirectionConfig {
    return {
      $type: Decompressor_RequestDirectionConfig.$type,
      common_config: isSet(object.common_config)
        ? Decompressor_CommonDirectionConfig.fromJSON(object.common_config)
        : undefined,
      advertise_accept_encoding: isSet(object.advertise_accept_encoding)
        ? Boolean(object.advertise_accept_encoding)
        : undefined,
    };
  },

  toJSON(message: Decompressor_RequestDirectionConfig): unknown {
    const obj: any = {};
    if (message.common_config !== undefined) {
      obj.common_config = Decompressor_CommonDirectionConfig.toJSON(message.common_config);
    }
    if (message.advertise_accept_encoding !== undefined) {
      obj.advertise_accept_encoding = message.advertise_accept_encoding;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Decompressor_RequestDirectionConfig>, I>>(
    base?: I,
  ): Decompressor_RequestDirectionConfig {
    return Decompressor_RequestDirectionConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Decompressor_RequestDirectionConfig>, I>>(
    object: I,
  ): Decompressor_RequestDirectionConfig {
    const message = createBaseDecompressor_RequestDirectionConfig();
    message.common_config = (object.common_config !== undefined && object.common_config !== null)
      ? Decompressor_CommonDirectionConfig.fromPartial(object.common_config)
      : undefined;
    message.advertise_accept_encoding = object.advertise_accept_encoding ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Decompressor_RequestDirectionConfig.$type, Decompressor_RequestDirectionConfig);

function createBaseDecompressor_ResponseDirectionConfig(): Decompressor_ResponseDirectionConfig {
  return { $type: "envoy.extensions.filters.http.decompressor.v3.Decompressor.ResponseDirectionConfig" };
}

export const Decompressor_ResponseDirectionConfig: MessageFns<
  Decompressor_ResponseDirectionConfig,
  "envoy.extensions.filters.http.decompressor.v3.Decompressor.ResponseDirectionConfig"
> = {
  $type: "envoy.extensions.filters.http.decompressor.v3.Decompressor.ResponseDirectionConfig" as const,

  encode(message: Decompressor_ResponseDirectionConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common_config !== undefined) {
      Decompressor_CommonDirectionConfig.encode(message.common_config, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Decompressor_ResponseDirectionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecompressor_ResponseDirectionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common_config = Decompressor_CommonDirectionConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Decompressor_ResponseDirectionConfig {
    return {
      $type: Decompressor_ResponseDirectionConfig.$type,
      common_config: isSet(object.common_config)
        ? Decompressor_CommonDirectionConfig.fromJSON(object.common_config)
        : undefined,
    };
  },

  toJSON(message: Decompressor_ResponseDirectionConfig): unknown {
    const obj: any = {};
    if (message.common_config !== undefined) {
      obj.common_config = Decompressor_CommonDirectionConfig.toJSON(message.common_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Decompressor_ResponseDirectionConfig>, I>>(
    base?: I,
  ): Decompressor_ResponseDirectionConfig {
    return Decompressor_ResponseDirectionConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Decompressor_ResponseDirectionConfig>, I>>(
    object: I,
  ): Decompressor_ResponseDirectionConfig {
    const message = createBaseDecompressor_ResponseDirectionConfig();
    message.common_config = (object.common_config !== undefined && object.common_config !== null)
      ? Decompressor_CommonDirectionConfig.fromPartial(object.common_config)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Decompressor_ResponseDirectionConfig.$type, Decompressor_ResponseDirectionConfig);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
