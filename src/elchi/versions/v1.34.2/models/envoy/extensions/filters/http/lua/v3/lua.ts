// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/filters/http/lua/v3/lua.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { BoolValue } from "../../../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../../../typeRegistry";
import { DataSource } from "../../../../../config/core/v3/base";

export const protobufPackage = "envoy.extensions.filters.http.lua.v3";

/** [#next-free-field: 6] */
export interface Lua {
  $type: "envoy.extensions.filters.http.lua.v3.Lua";
  /**
   * The Lua code that Envoy will execute. This can be a very small script that
   * further loads code from disk if desired. Note that if JSON configuration is used, the code must
   * be properly escaped. YAML configuration may be easier to read since YAML supports multi-line
   * strings so complex scripts can be easily expressed inline in the configuration.
   *
   * This field is deprecated. Please use
   * :ref:`default_source_code <envoy_v3_api_field_extensions.filters.http.lua.v3.Lua.default_source_code>`.
   * Only one of :ref:`inline_code <envoy_v3_api_field_extensions.filters.http.lua.v3.Lua.inline_code>`
   * or :ref:`default_source_code <envoy_v3_api_field_extensions.filters.http.lua.v3.Lua.default_source_code>`
   * can be set for the Lua filter.
   *
   * @deprecated
   */
  inline_code?:
    | string
    | undefined;
  /**
   * Map of named Lua source codes that can be referenced in :ref:`LuaPerRoute
   * <envoy_v3_api_msg_extensions.filters.http.lua.v3.LuaPerRoute>`. The Lua source codes can be
   * loaded from inline string or local files.
   *
   * Example:
   *
   * .. code-block:: yaml
   *
   *   source_codes:
   *     hello.lua:
   *       inline_string: |
   *         function envoy_on_response(response_handle)
   *           -- Do something.
   *         end
   *     world.lua:
   *       filename: /etc/lua/world.lua
   */
  source_codes?:
    | Map<string, DataSource>
    | undefined;
  /**
   * The default Lua code that Envoy will execute. If no per route config is provided
   * for the request, this Lua code will be applied.
   */
  default_source_code?:
    | DataSource
    | undefined;
  /**
   * Optional additional prefix to use when emitting statistics. By default
   * metrics are emitted in *.lua.* namespace. If multiple lua filters are
   * configured in a filter chain, the stats from each filter instance can
   * be emitted using custom stat prefix to distinguish emitted
   * statistics. For example:
   *
   * .. code-block:: yaml
   *
   *   http_filters:
   *     - name: envoy.filters.http.lua
   *       typed_config:
   *         "@type": type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua
   *         stat_prefix: foo_script # This emits lua.foo_script.errors etc.
   *     - name: envoy.filters.http.lua
   *       typed_config:
   *         "@type": type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua
   *         stat_prefix: bar_script # This emits lua.bar_script.errors etc.
   */
  stat_prefix?:
    | string
    | undefined;
  /**
   * If set to true, the Lua filter will clear the route cache automatically if the request
   * headers are modified by the Lua script. If set to false, the Lua filter will not clear the
   * route cache automatically.
   * Default is true for backward compatibility.
   */
  clear_route_cache?: boolean | undefined;
}

export interface Lua_SourceCodesEntry {
  $type: "envoy.extensions.filters.http.lua.v3.Lua.SourceCodesEntry";
  key: string;
  value?: DataSource | undefined;
}

export interface LuaPerRoute {
  $type: "envoy.extensions.filters.http.lua.v3.LuaPerRoute";
  override?:
    | //
    /**
     * Disable the Lua filter for this particular vhost or route. If disabled is specified in
     * multiple per-filter-configs, the most specific one will be used.
     */
    { $case: "disabled"; disabled: boolean }
    | //
    /**
     * A name of a Lua source code stored in
     * :ref:`Lua.source_codes <envoy_v3_api_field_extensions.filters.http.lua.v3.Lua.source_codes>`.
     */
    { $case: "name"; name: string }
    | //
    /** A configured per-route Lua source code that can be served by RDS or provided inline. */
    { $case: "source_code"; source_code: DataSource }
    | undefined;
}

function createBaseLua(): Lua {
  return { $type: "envoy.extensions.filters.http.lua.v3.Lua" };
}

export const Lua: MessageFns<Lua, "envoy.extensions.filters.http.lua.v3.Lua"> = {
  $type: "envoy.extensions.filters.http.lua.v3.Lua" as const,

  encode(message: Lua, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inline_code !== undefined && message.inline_code !== "") {
      writer.uint32(10).string(message.inline_code);
    }
    (message.source_codes || new Map()).forEach((value, key) => {
      Lua_SourceCodesEntry.encode({
        $type: "envoy.extensions.filters.http.lua.v3.Lua.SourceCodesEntry",
        key: key as any,
        value,
      }, writer.uint32(18).fork()).join();
    });
    if (message.default_source_code !== undefined) {
      DataSource.encode(message.default_source_code, writer.uint32(26).fork()).join();
    }
    if (message.stat_prefix !== undefined && message.stat_prefix !== "") {
      writer.uint32(34).string(message.stat_prefix);
    }
    if (message.clear_route_cache !== undefined) {
      BoolValue.encode(
        { $type: "google.protobuf.BoolValue", value: message.clear_route_cache! },
        writer.uint32(42).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Lua {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLua();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.inline_code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = Lua_SourceCodesEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            if (message.source_codes === undefined) {
              message.source_codes = new Map();
            }
            message.source_codes!.set(entry2.key, entry2.value);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.default_source_code = DataSource.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.stat_prefix = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.clear_route_cache = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Lua {
    return {
      $type: Lua.$type,
      inline_code: isSet(object.inline_code) ? globalThis.String(object.inline_code) : undefined,
      source_codes: isObject(object.source_codes)
        ? Object.entries(object.source_codes).reduce<Map<string, DataSource>>((acc, [key, value]) => {
          acc.set(key, DataSource.fromJSON(value));
          return acc;
        }, new Map())
        : undefined,
      default_source_code: isSet(object.default_source_code)
        ? DataSource.fromJSON(object.default_source_code)
        : undefined,
      stat_prefix: isSet(object.stat_prefix) ? globalThis.String(object.stat_prefix) : undefined,
      clear_route_cache: isSet(object.clear_route_cache) ? Boolean(object.clear_route_cache) : undefined,
    };
  },

  toJSON(message: Lua): unknown {
    const obj: any = {};
    if (message.inline_code !== undefined) {
      obj.inline_code = message.inline_code;
    }
    if (message.source_codes?.size) {
      obj.source_codes = {};
      message.source_codes.forEach((v, k) => {
        obj.source_codes[k] = DataSource.toJSON(v);
      });
    }
    if (message.default_source_code !== undefined) {
      obj.default_source_code = DataSource.toJSON(message.default_source_code);
    }
    if (message.stat_prefix !== undefined) {
      obj.stat_prefix = message.stat_prefix;
    }
    if (message.clear_route_cache !== undefined) {
      obj.clear_route_cache = message.clear_route_cache;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Lua>, I>>(base?: I): Lua {
    return Lua.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Lua>, I>>(object: I): Lua {
    const message = createBaseLua();
    message.inline_code = object.inline_code ?? undefined;
    message.source_codes = (object.source_codes === undefined || object.source_codes === null) ? undefined : (() => {
      const m = new Map();
      (object.source_codes as Map<string, DataSource> ?? new Map()).forEach((value, key) => {
        if (value !== undefined) {
          m.set(key, DataSource.fromPartial(value));
        }
      });
      return m;
    })();
    message.default_source_code = (object.default_source_code !== undefined && object.default_source_code !== null)
      ? DataSource.fromPartial(object.default_source_code)
      : undefined;
    message.stat_prefix = object.stat_prefix ?? undefined;
    message.clear_route_cache = object.clear_route_cache ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Lua.$type, Lua);

function createBaseLua_SourceCodesEntry(): Lua_SourceCodesEntry {
  return { $type: "envoy.extensions.filters.http.lua.v3.Lua.SourceCodesEntry", key: "" };
}

export const Lua_SourceCodesEntry: MessageFns<
  Lua_SourceCodesEntry,
  "envoy.extensions.filters.http.lua.v3.Lua.SourceCodesEntry"
> = {
  $type: "envoy.extensions.filters.http.lua.v3.Lua.SourceCodesEntry" as const,

  encode(message: Lua_SourceCodesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      DataSource.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Lua_SourceCodesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLua_SourceCodesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = DataSource.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Lua_SourceCodesEntry {
    return {
      $type: Lua_SourceCodesEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? DataSource.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Lua_SourceCodesEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = DataSource.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Lua_SourceCodesEntry>, I>>(base?: I): Lua_SourceCodesEntry {
    return Lua_SourceCodesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Lua_SourceCodesEntry>, I>>(object: I): Lua_SourceCodesEntry {
    const message = createBaseLua_SourceCodesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? DataSource.fromPartial(object.value)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Lua_SourceCodesEntry.$type, Lua_SourceCodesEntry);

function createBaseLuaPerRoute(): LuaPerRoute {
  return { $type: "envoy.extensions.filters.http.lua.v3.LuaPerRoute", override: undefined };
}

export const LuaPerRoute: MessageFns<LuaPerRoute, "envoy.extensions.filters.http.lua.v3.LuaPerRoute"> = {
  $type: "envoy.extensions.filters.http.lua.v3.LuaPerRoute" as const,

  encode(message: LuaPerRoute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.override?.$case) {
      case "disabled":
        writer.uint32(8).bool(message.override.disabled);
        break;
      case "name":
        writer.uint32(18).string(message.override.name);
        break;
      case "source_code":
        DataSource.encode(message.override.source_code, writer.uint32(26).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LuaPerRoute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLuaPerRoute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.override = { $case: "disabled", disabled: reader.bool() };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.override = { $case: "name", name: reader.string() };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.override = { $case: "source_code", source_code: DataSource.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LuaPerRoute {
    return {
      $type: LuaPerRoute.$type,
      override: isSet(object.disabled)
        ? { $case: "disabled", disabled: globalThis.Boolean(object.disabled) }
        : isSet(object.name)
        ? { $case: "name", name: globalThis.String(object.name) }
        : isSet(object.source_code)
        ? { $case: "source_code", source_code: DataSource.fromJSON(object.source_code) }
        : undefined,
    };
  },

  toJSON(message: LuaPerRoute): unknown {
    const obj: any = {};
    if (message.override?.$case === "disabled") {
      obj.disabled = message.override.disabled;
    }
    if (message.override?.$case === "name") {
      obj.name = message.override.name;
    }
    if (message.override?.$case === "source_code") {
      obj.source_code = DataSource.toJSON(message.override.source_code);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LuaPerRoute>, I>>(base?: I): LuaPerRoute {
    return LuaPerRoute.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LuaPerRoute>, I>>(object: I): LuaPerRoute {
    const message = createBaseLuaPerRoute();
    if (
      object.override?.$case === "disabled" &&
      object.override?.disabled !== undefined &&
      object.override?.disabled !== null
    ) {
      message.override = { $case: "disabled", disabled: object.override.disabled };
    }
    if (object.override?.$case === "name" && object.override?.name !== undefined && object.override?.name !== null) {
      message.override = { $case: "name", name: object.override.name };
    }
    if (
      object.override?.$case === "source_code" &&
      object.override?.source_code !== undefined &&
      object.override?.source_code !== null
    ) {
      message.override = { $case: "source_code", source_code: DataSource.fromPartial(object.override.source_code) };
    }
    return message;
  },
};

messageTypeRegistry.set(LuaPerRoute.$type, LuaPerRoute);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
