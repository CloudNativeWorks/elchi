// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/type/http/v3/path_transformation.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { messageTypeRegistry } from "../../../../typeRegistry";

export const protobufPackage = "envoy.type.http.v3";

export interface PathTransformation {
  $type: "envoy.type.http.v3.PathTransformation";
  /** A list of operations to apply. Transformations will be performed in the order that they appear. */
  operations?: PathTransformation_Operation[] | undefined;
}

/** A type of operation to alter text. */
export interface PathTransformation_Operation {
  $type: "envoy.type.http.v3.PathTransformation.Operation";
  operation_specifier?:
    | //
    /** Enable path normalization per RFC 3986. */
    { $case: "normalize_path_rfc_3986"; normalize_path_rfc_3986: PathTransformation_Operation_NormalizePathRFC3986 }
    | //
    /** Enable merging adjacent slashes. */
    { $case: "merge_slashes"; merge_slashes: PathTransformation_Operation_MergeSlashes }
    | undefined;
}

/**
 * Should text be normalized according to RFC 3986? This typically is used for path headers
 * before any processing of requests by HTTP filters or routing. This applies percent-encoded
 * normalization and path segment normalization. Fails on characters disallowed in URLs
 * (e.g. NULLs). See `Normalization and Comparison
 * <https://tools.ietf.org/html/rfc3986#section-6>`_ for details of normalization. Note that
 * this options does not perform `case normalization
 * <https://tools.ietf.org/html/rfc3986#section-6.2.2.1>`_
 */
export interface PathTransformation_Operation_NormalizePathRFC3986 {
  $type: "envoy.type.http.v3.PathTransformation.Operation.NormalizePathRFC3986";
}

/**
 * Determines if adjacent slashes are merged into one. A common use case is for a request path
 * header. Using this option in ``:ref: PathNormalizationOptions
 * <envoy_v3_api_msg_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions>``
 * will allow incoming requests with path ``//dir///file`` to match against route with ``prefix``
 * match set to ``/dir``. When using for header transformations, note that slash merging is not
 * part of `HTTP spec <https://tools.ietf.org/html/rfc3986>`_ and is provided for convenience.
 */
export interface PathTransformation_Operation_MergeSlashes {
  $type: "envoy.type.http.v3.PathTransformation.Operation.MergeSlashes";
}

function createBasePathTransformation(): PathTransformation {
  return { $type: "envoy.type.http.v3.PathTransformation" };
}

export const PathTransformation: MessageFns<PathTransformation, "envoy.type.http.v3.PathTransformation"> = {
  $type: "envoy.type.http.v3.PathTransformation" as const,

  encode(message: PathTransformation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operations !== undefined && message.operations.length !== 0) {
      for (const v of message.operations) {
        PathTransformation_Operation.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PathTransformation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePathTransformation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.operations === undefined) {
            message.operations = [];
          }
          const el = PathTransformation_Operation.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.operations!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PathTransformation {
    return {
      $type: PathTransformation.$type,
      operations: globalThis.Array.isArray(object?.operations)
        ? object.operations.map((e: any) => PathTransformation_Operation.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: PathTransformation): unknown {
    const obj: any = {};
    if (message.operations?.length) {
      obj.operations = message.operations.map((e) => PathTransformation_Operation.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PathTransformation>, I>>(base?: I): PathTransformation {
    return PathTransformation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PathTransformation>, I>>(object: I): PathTransformation {
    const message = createBasePathTransformation();
    message.operations = object.operations?.map((e) => PathTransformation_Operation.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(PathTransformation.$type, PathTransformation);

function createBasePathTransformation_Operation(): PathTransformation_Operation {
  return { $type: "envoy.type.http.v3.PathTransformation.Operation", operation_specifier: undefined };
}

export const PathTransformation_Operation: MessageFns<
  PathTransformation_Operation,
  "envoy.type.http.v3.PathTransformation.Operation"
> = {
  $type: "envoy.type.http.v3.PathTransformation.Operation" as const,

  encode(message: PathTransformation_Operation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.operation_specifier?.$case) {
      case "normalize_path_rfc_3986":
        PathTransformation_Operation_NormalizePathRFC3986.encode(
          message.operation_specifier.normalize_path_rfc_3986,
          writer.uint32(18).fork(),
        ).join();
        break;
      case "merge_slashes":
        PathTransformation_Operation_MergeSlashes.encode(
          message.operation_specifier.merge_slashes,
          writer.uint32(26).fork(),
        ).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PathTransformation_Operation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePathTransformation_Operation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.operation_specifier = {
            $case: "normalize_path_rfc_3986",
            normalize_path_rfc_3986: PathTransformation_Operation_NormalizePathRFC3986.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.operation_specifier = {
            $case: "merge_slashes",
            merge_slashes: PathTransformation_Operation_MergeSlashes.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PathTransformation_Operation {
    return {
      $type: PathTransformation_Operation.$type,
      operation_specifier: isSet(object.normalize_path_rfc_3986)
        ? {
          $case: "normalize_path_rfc_3986",
          normalize_path_rfc_3986: PathTransformation_Operation_NormalizePathRFC3986.fromJSON(
            object.normalize_path_rfc_3986,
          ),
        }
        : isSet(object.merge_slashes)
        ? {
          $case: "merge_slashes",
          merge_slashes: PathTransformation_Operation_MergeSlashes.fromJSON(object.merge_slashes),
        }
        : undefined,
    };
  },

  toJSON(message: PathTransformation_Operation): unknown {
    const obj: any = {};
    if (message.operation_specifier?.$case === "normalize_path_rfc_3986") {
      obj.normalize_path_rfc_3986 = PathTransformation_Operation_NormalizePathRFC3986.toJSON(
        message.operation_specifier.normalize_path_rfc_3986,
      );
    }
    if (message.operation_specifier?.$case === "merge_slashes") {
      obj.merge_slashes = PathTransformation_Operation_MergeSlashes.toJSON(message.operation_specifier.merge_slashes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PathTransformation_Operation>, I>>(base?: I): PathTransformation_Operation {
    return PathTransformation_Operation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PathTransformation_Operation>, I>>(object: I): PathTransformation_Operation {
    const message = createBasePathTransformation_Operation();
    if (
      object.operation_specifier?.$case === "normalize_path_rfc_3986" &&
      object.operation_specifier?.normalize_path_rfc_3986 !== undefined &&
      object.operation_specifier?.normalize_path_rfc_3986 !== null
    ) {
      message.operation_specifier = {
        $case: "normalize_path_rfc_3986",
        normalize_path_rfc_3986: PathTransformation_Operation_NormalizePathRFC3986.fromPartial(
          object.operation_specifier.normalize_path_rfc_3986,
        ),
      };
    }
    if (
      object.operation_specifier?.$case === "merge_slashes" &&
      object.operation_specifier?.merge_slashes !== undefined &&
      object.operation_specifier?.merge_slashes !== null
    ) {
      message.operation_specifier = {
        $case: "merge_slashes",
        merge_slashes: PathTransformation_Operation_MergeSlashes.fromPartial(object.operation_specifier.merge_slashes),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(PathTransformation_Operation.$type, PathTransformation_Operation);

function createBasePathTransformation_Operation_NormalizePathRFC3986(): PathTransformation_Operation_NormalizePathRFC3986 {
  return { $type: "envoy.type.http.v3.PathTransformation.Operation.NormalizePathRFC3986" };
}

export const PathTransformation_Operation_NormalizePathRFC3986: MessageFns<
  PathTransformation_Operation_NormalizePathRFC3986,
  "envoy.type.http.v3.PathTransformation.Operation.NormalizePathRFC3986"
> = {
  $type: "envoy.type.http.v3.PathTransformation.Operation.NormalizePathRFC3986" as const,

  encode(
    _: PathTransformation_Operation_NormalizePathRFC3986,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PathTransformation_Operation_NormalizePathRFC3986 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePathTransformation_Operation_NormalizePathRFC3986();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PathTransformation_Operation_NormalizePathRFC3986 {
    return { $type: PathTransformation_Operation_NormalizePathRFC3986.$type };
  },

  toJSON(_: PathTransformation_Operation_NormalizePathRFC3986): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<PathTransformation_Operation_NormalizePathRFC3986>, I>>(
    base?: I,
  ): PathTransformation_Operation_NormalizePathRFC3986 {
    return PathTransformation_Operation_NormalizePathRFC3986.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PathTransformation_Operation_NormalizePathRFC3986>, I>>(
    _: I,
  ): PathTransformation_Operation_NormalizePathRFC3986 {
    const message = createBasePathTransformation_Operation_NormalizePathRFC3986();
    return message;
  },
};

messageTypeRegistry.set(
  PathTransformation_Operation_NormalizePathRFC3986.$type,
  PathTransformation_Operation_NormalizePathRFC3986,
);

function createBasePathTransformation_Operation_MergeSlashes(): PathTransformation_Operation_MergeSlashes {
  return { $type: "envoy.type.http.v3.PathTransformation.Operation.MergeSlashes" };
}

export const PathTransformation_Operation_MergeSlashes: MessageFns<
  PathTransformation_Operation_MergeSlashes,
  "envoy.type.http.v3.PathTransformation.Operation.MergeSlashes"
> = {
  $type: "envoy.type.http.v3.PathTransformation.Operation.MergeSlashes" as const,

  encode(_: PathTransformation_Operation_MergeSlashes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PathTransformation_Operation_MergeSlashes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePathTransformation_Operation_MergeSlashes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PathTransformation_Operation_MergeSlashes {
    return { $type: PathTransformation_Operation_MergeSlashes.$type };
  },

  toJSON(_: PathTransformation_Operation_MergeSlashes): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<PathTransformation_Operation_MergeSlashes>, I>>(
    base?: I,
  ): PathTransformation_Operation_MergeSlashes {
    return PathTransformation_Operation_MergeSlashes.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PathTransformation_Operation_MergeSlashes>, I>>(
    _: I,
  ): PathTransformation_Operation_MergeSlashes {
    const message = createBasePathTransformation_Operation_MergeSlashes();
    return message;
  },
};

messageTypeRegistry.set(PathTransformation_Operation_MergeSlashes.$type, PathTransformation_Operation_MergeSlashes);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
