// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/service/accesslog/v3/als.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Observable } from "rxjs";
import { map } from "rxjs/operators";
import { messageTypeRegistry } from "../../../../typeRegistry";
import { Node } from "../../../config/core/v3/base";
import { HTTPAccessLogEntry, TCPAccessLogEntry } from "../../../data/accesslog/v3/accesslog";

export const protobufPackage = "envoy.service.accesslog.v3";

/** Empty response for the StreamAccessLogs API. Will never be sent. See below. */
export interface StreamAccessLogsResponse {
  $type: "envoy.service.accesslog.v3.StreamAccessLogsResponse";
}

/**
 * Stream message for the StreamAccessLogs API. Envoy will open a stream to the server and stream
 * access logs without ever expecting a response.
 */
export interface StreamAccessLogsMessage {
  $type: "envoy.service.accesslog.v3.StreamAccessLogsMessage";
  /**
   * Identifier data that will only be sent in the first message on the stream. This is effectively
   * structured metadata and is a performance optimization.
   */
  identifier?:
    | StreamAccessLogsMessage_Identifier
    | undefined;
  /**
   * Batches of log entries of a single type. Generally speaking, a given stream should only
   * ever include one type of log entry.
   */
  log_entries?:
    | //
    { $case: "http_logs"; http_logs: StreamAccessLogsMessage_HTTPAccessLogEntries }
    | //
    { $case: "tcp_logs"; tcp_logs: StreamAccessLogsMessage_TCPAccessLogEntries }
    | undefined;
}

export interface StreamAccessLogsMessage_Identifier {
  $type: "envoy.service.accesslog.v3.StreamAccessLogsMessage.Identifier";
  /** The node sending the access log messages over the stream. */
  node?:
    | Node
    | undefined;
  /**
   * The friendly name of the log configured in :ref:`CommonGrpcAccessLogConfig
   * <envoy_v3_api_msg_extensions.access_loggers.grpc.v3.CommonGrpcAccessLogConfig>`.
   */
  log_name?: string | undefined;
}

/** Wrapper for batches of HTTP access log entries. */
export interface StreamAccessLogsMessage_HTTPAccessLogEntries {
  $type: "envoy.service.accesslog.v3.StreamAccessLogsMessage.HTTPAccessLogEntries";
  log_entry?: HTTPAccessLogEntry[] | undefined;
}

/** Wrapper for batches of TCP access log entries. */
export interface StreamAccessLogsMessage_TCPAccessLogEntries {
  $type: "envoy.service.accesslog.v3.StreamAccessLogsMessage.TCPAccessLogEntries";
  log_entry?: TCPAccessLogEntry[] | undefined;
}

function createBaseStreamAccessLogsResponse(): StreamAccessLogsResponse {
  return { $type: "envoy.service.accesslog.v3.StreamAccessLogsResponse" };
}

export const StreamAccessLogsResponse: MessageFns<
  StreamAccessLogsResponse,
  "envoy.service.accesslog.v3.StreamAccessLogsResponse"
> = {
  $type: "envoy.service.accesslog.v3.StreamAccessLogsResponse" as const,

  encode(_: StreamAccessLogsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamAccessLogsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamAccessLogsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): StreamAccessLogsResponse {
    return { $type: StreamAccessLogsResponse.$type };
  },

  toJSON(_: StreamAccessLogsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamAccessLogsResponse>, I>>(base?: I): StreamAccessLogsResponse {
    return StreamAccessLogsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamAccessLogsResponse>, I>>(_: I): StreamAccessLogsResponse {
    const message = createBaseStreamAccessLogsResponse();
    return message;
  },
};

messageTypeRegistry.set(StreamAccessLogsResponse.$type, StreamAccessLogsResponse);

function createBaseStreamAccessLogsMessage(): StreamAccessLogsMessage {
  return { $type: "envoy.service.accesslog.v3.StreamAccessLogsMessage", log_entries: undefined };
}

export const StreamAccessLogsMessage: MessageFns<
  StreamAccessLogsMessage,
  "envoy.service.accesslog.v3.StreamAccessLogsMessage"
> = {
  $type: "envoy.service.accesslog.v3.StreamAccessLogsMessage" as const,

  encode(message: StreamAccessLogsMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.identifier !== undefined) {
      StreamAccessLogsMessage_Identifier.encode(message.identifier, writer.uint32(10).fork()).join();
    }
    switch (message.log_entries?.$case) {
      case "http_logs":
        StreamAccessLogsMessage_HTTPAccessLogEntries.encode(message.log_entries.http_logs, writer.uint32(18).fork())
          .join();
        break;
      case "tcp_logs":
        StreamAccessLogsMessage_TCPAccessLogEntries.encode(message.log_entries.tcp_logs, writer.uint32(26).fork())
          .join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamAccessLogsMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamAccessLogsMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.identifier = StreamAccessLogsMessage_Identifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.log_entries = {
            $case: "http_logs",
            http_logs: StreamAccessLogsMessage_HTTPAccessLogEntries.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.log_entries = {
            $case: "tcp_logs",
            tcp_logs: StreamAccessLogsMessage_TCPAccessLogEntries.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamAccessLogsMessage {
    return {
      $type: StreamAccessLogsMessage.$type,
      identifier: isSet(object.identifier) ? StreamAccessLogsMessage_Identifier.fromJSON(object.identifier) : undefined,
      log_entries: isSet(object.http_logs)
        ? { $case: "http_logs", http_logs: StreamAccessLogsMessage_HTTPAccessLogEntries.fromJSON(object.http_logs) }
        : isSet(object.tcp_logs)
        ? { $case: "tcp_logs", tcp_logs: StreamAccessLogsMessage_TCPAccessLogEntries.fromJSON(object.tcp_logs) }
        : undefined,
    };
  },

  toJSON(message: StreamAccessLogsMessage): unknown {
    const obj: any = {};
    if (message.identifier !== undefined) {
      obj.identifier = StreamAccessLogsMessage_Identifier.toJSON(message.identifier);
    }
    if (message.log_entries?.$case === "http_logs") {
      obj.http_logs = StreamAccessLogsMessage_HTTPAccessLogEntries.toJSON(message.log_entries.http_logs);
    }
    if (message.log_entries?.$case === "tcp_logs") {
      obj.tcp_logs = StreamAccessLogsMessage_TCPAccessLogEntries.toJSON(message.log_entries.tcp_logs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamAccessLogsMessage>, I>>(base?: I): StreamAccessLogsMessage {
    return StreamAccessLogsMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamAccessLogsMessage>, I>>(object: I): StreamAccessLogsMessage {
    const message = createBaseStreamAccessLogsMessage();
    message.identifier = (object.identifier !== undefined && object.identifier !== null)
      ? StreamAccessLogsMessage_Identifier.fromPartial(object.identifier)
      : undefined;
    if (
      object.log_entries?.$case === "http_logs" &&
      object.log_entries?.http_logs !== undefined &&
      object.log_entries?.http_logs !== null
    ) {
      message.log_entries = {
        $case: "http_logs",
        http_logs: StreamAccessLogsMessage_HTTPAccessLogEntries.fromPartial(object.log_entries.http_logs),
      };
    }
    if (
      object.log_entries?.$case === "tcp_logs" &&
      object.log_entries?.tcp_logs !== undefined &&
      object.log_entries?.tcp_logs !== null
    ) {
      message.log_entries = {
        $case: "tcp_logs",
        tcp_logs: StreamAccessLogsMessage_TCPAccessLogEntries.fromPartial(object.log_entries.tcp_logs),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(StreamAccessLogsMessage.$type, StreamAccessLogsMessage);

function createBaseStreamAccessLogsMessage_Identifier(): StreamAccessLogsMessage_Identifier {
  return { $type: "envoy.service.accesslog.v3.StreamAccessLogsMessage.Identifier" };
}

export const StreamAccessLogsMessage_Identifier: MessageFns<
  StreamAccessLogsMessage_Identifier,
  "envoy.service.accesslog.v3.StreamAccessLogsMessage.Identifier"
> = {
  $type: "envoy.service.accesslog.v3.StreamAccessLogsMessage.Identifier" as const,

  encode(message: StreamAccessLogsMessage_Identifier, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.node !== undefined) {
      Node.encode(message.node, writer.uint32(10).fork()).join();
    }
    if (message.log_name !== undefined && message.log_name !== "") {
      writer.uint32(18).string(message.log_name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamAccessLogsMessage_Identifier {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamAccessLogsMessage_Identifier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.node = Node.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.log_name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamAccessLogsMessage_Identifier {
    return {
      $type: StreamAccessLogsMessage_Identifier.$type,
      node: isSet(object.node) ? Node.fromJSON(object.node) : undefined,
      log_name: isSet(object.log_name) ? globalThis.String(object.log_name) : undefined,
    };
  },

  toJSON(message: StreamAccessLogsMessage_Identifier): unknown {
    const obj: any = {};
    if (message.node !== undefined) {
      obj.node = Node.toJSON(message.node);
    }
    if (message.log_name !== undefined) {
      obj.log_name = message.log_name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamAccessLogsMessage_Identifier>, I>>(
    base?: I,
  ): StreamAccessLogsMessage_Identifier {
    return StreamAccessLogsMessage_Identifier.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamAccessLogsMessage_Identifier>, I>>(
    object: I,
  ): StreamAccessLogsMessage_Identifier {
    const message = createBaseStreamAccessLogsMessage_Identifier();
    message.node = (object.node !== undefined && object.node !== null) ? Node.fromPartial(object.node) : undefined;
    message.log_name = object.log_name ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(StreamAccessLogsMessage_Identifier.$type, StreamAccessLogsMessage_Identifier);

function createBaseStreamAccessLogsMessage_HTTPAccessLogEntries(): StreamAccessLogsMessage_HTTPAccessLogEntries {
  return { $type: "envoy.service.accesslog.v3.StreamAccessLogsMessage.HTTPAccessLogEntries" };
}

export const StreamAccessLogsMessage_HTTPAccessLogEntries: MessageFns<
  StreamAccessLogsMessage_HTTPAccessLogEntries,
  "envoy.service.accesslog.v3.StreamAccessLogsMessage.HTTPAccessLogEntries"
> = {
  $type: "envoy.service.accesslog.v3.StreamAccessLogsMessage.HTTPAccessLogEntries" as const,

  encode(
    message: StreamAccessLogsMessage_HTTPAccessLogEntries,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.log_entry !== undefined && message.log_entry.length !== 0) {
      for (const v of message.log_entry) {
        HTTPAccessLogEntry.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamAccessLogsMessage_HTTPAccessLogEntries {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamAccessLogsMessage_HTTPAccessLogEntries();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.log_entry === undefined) {
            message.log_entry = [];
          }
          const el = HTTPAccessLogEntry.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.log_entry!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamAccessLogsMessage_HTTPAccessLogEntries {
    return {
      $type: StreamAccessLogsMessage_HTTPAccessLogEntries.$type,
      log_entry: globalThis.Array.isArray(object?.log_entry)
        ? object.log_entry.map((e: any) => HTTPAccessLogEntry.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: StreamAccessLogsMessage_HTTPAccessLogEntries): unknown {
    const obj: any = {};
    if (message.log_entry?.length) {
      obj.log_entry = message.log_entry.map((e) => HTTPAccessLogEntry.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamAccessLogsMessage_HTTPAccessLogEntries>, I>>(
    base?: I,
  ): StreamAccessLogsMessage_HTTPAccessLogEntries {
    return StreamAccessLogsMessage_HTTPAccessLogEntries.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamAccessLogsMessage_HTTPAccessLogEntries>, I>>(
    object: I,
  ): StreamAccessLogsMessage_HTTPAccessLogEntries {
    const message = createBaseStreamAccessLogsMessage_HTTPAccessLogEntries();
    message.log_entry = object.log_entry?.map((e) => HTTPAccessLogEntry.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(
  StreamAccessLogsMessage_HTTPAccessLogEntries.$type,
  StreamAccessLogsMessage_HTTPAccessLogEntries,
);

function createBaseStreamAccessLogsMessage_TCPAccessLogEntries(): StreamAccessLogsMessage_TCPAccessLogEntries {
  return { $type: "envoy.service.accesslog.v3.StreamAccessLogsMessage.TCPAccessLogEntries" };
}

export const StreamAccessLogsMessage_TCPAccessLogEntries: MessageFns<
  StreamAccessLogsMessage_TCPAccessLogEntries,
  "envoy.service.accesslog.v3.StreamAccessLogsMessage.TCPAccessLogEntries"
> = {
  $type: "envoy.service.accesslog.v3.StreamAccessLogsMessage.TCPAccessLogEntries" as const,

  encode(
    message: StreamAccessLogsMessage_TCPAccessLogEntries,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.log_entry !== undefined && message.log_entry.length !== 0) {
      for (const v of message.log_entry) {
        TCPAccessLogEntry.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamAccessLogsMessage_TCPAccessLogEntries {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamAccessLogsMessage_TCPAccessLogEntries();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.log_entry === undefined) {
            message.log_entry = [];
          }
          const el = TCPAccessLogEntry.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.log_entry!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamAccessLogsMessage_TCPAccessLogEntries {
    return {
      $type: StreamAccessLogsMessage_TCPAccessLogEntries.$type,
      log_entry: globalThis.Array.isArray(object?.log_entry)
        ? object.log_entry.map((e: any) => TCPAccessLogEntry.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: StreamAccessLogsMessage_TCPAccessLogEntries): unknown {
    const obj: any = {};
    if (message.log_entry?.length) {
      obj.log_entry = message.log_entry.map((e) => TCPAccessLogEntry.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamAccessLogsMessage_TCPAccessLogEntries>, I>>(
    base?: I,
  ): StreamAccessLogsMessage_TCPAccessLogEntries {
    return StreamAccessLogsMessage_TCPAccessLogEntries.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamAccessLogsMessage_TCPAccessLogEntries>, I>>(
    object: I,
  ): StreamAccessLogsMessage_TCPAccessLogEntries {
    const message = createBaseStreamAccessLogsMessage_TCPAccessLogEntries();
    message.log_entry = object.log_entry?.map((e) => TCPAccessLogEntry.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(StreamAccessLogsMessage_TCPAccessLogEntries.$type, StreamAccessLogsMessage_TCPAccessLogEntries);

/** Service for streaming access logs from Envoy to an access log server. */
export interface AccessLogService {
  /**
   * Envoy will connect and send StreamAccessLogsMessage messages forever. It does not expect any
   * response to be sent as nothing would be done in the case of failure. The server should
   * disconnect if it expects Envoy to reconnect. In the future we may decide to add a different
   * API for "critical" access logs in which Envoy will buffer access logs for some period of time
   * until it gets an ACK so it could then retry. This API is designed for high throughput with the
   * expectation that it might be lossy.
   */
  StreamAccessLogs(request: Observable<StreamAccessLogsMessage>): Promise<StreamAccessLogsResponse>;
}

export const AccessLogServiceServiceName = "envoy.service.accesslog.v3.AccessLogService";
export class AccessLogServiceClientImpl implements AccessLogService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || AccessLogServiceServiceName;
    this.rpc = rpc;
    this.StreamAccessLogs = this.StreamAccessLogs.bind(this);
  }
  StreamAccessLogs(request: Observable<StreamAccessLogsMessage>): Promise<StreamAccessLogsResponse> {
    const data = request.pipe(map((request) => StreamAccessLogsMessage.encode(request).finish()));
    const promise = this.rpc.clientStreamingRequest(this.service, "StreamAccessLogs", data);
    return promise.then((data) => StreamAccessLogsResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
  clientStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Promise<Uint8Array>;
  serverStreamingRequest(service: string, method: string, data: Uint8Array): Observable<Uint8Array>;
  bidirectionalStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Observable<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
