// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/service/network_ext_proc/v3/network_external_processor.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Observable } from "rxjs";
import { map } from "rxjs/operators";
import { Struct } from "../../../../google/protobuf/struct";
import { messageTypeRegistry } from "../../../../typeRegistry";
import { Metadata } from "../../../config/core/v3/base";

export const protobufPackage = "envoy.service.network_ext_proc.v3";

/** The payload data from network layer */
export interface Data {
  $type: "envoy.service.network_ext_proc.v3.Data";
  /** The raw payload data */
  data?:
    | Uint8Array
    | undefined;
  /**
   * Indicates whether this is the last data frame in the current direction.
   * The external processor should still respond to this message even
   * if there is no more data expected in this direction.
   */
  end_of_stream?: boolean | undefined;
}

/**
 * ProcessingRequest contains data sent from Envoy to the external processing server.
 * Each request contains either read data (from client) or write data (to client)
 * along with optional metadata.
 */
export interface ProcessingRequest {
  $type: "envoy.service.network_ext_proc.v3.ProcessingRequest";
  /**
   * ReadData contains the network data intercepted in the request path (client to server).
   * This is sent to the external processor when data arrives from the downstream client.
   * If this is set, write_data should not be set.
   */
  read_data?:
    | Data
    | undefined;
  /**
   * WriteData contains the network data intercepted in the response path (server to client).
   * This is sent to the external processor when data arrives from the upstream server.
   * If this is set, read_data should not be set.
   */
  write_data?:
    | Data
    | undefined;
  /**
   * Optional metadata associated with the request.
   * This can include connection properties, filter configuration, and any other
   * contextual information that might be useful for processing decisions.
   *
   * The metadata is not automatically propagated from request to response.
   * The external processor must include any needed metadata in its response.
   */
  metadata?: Metadata | undefined;
}

/**
 * ProcessingResponse contains the response from the external processing server to Envoy.
 * Each response corresponds to a ProcessingRequest and indicates how the network
 * traffic should be handled.
 * [#next-free-field: 6]
 */
export interface ProcessingResponse {
  $type: "envoy.service.network_ext_proc.v3.ProcessingResponse";
  /**
   * The processed ReadData containing potentially modified data for the request path.
   * This should be sent in response to a ProcessingRequest with read_data, and the
   * previous data in ProcessingRequest will be replaced by the new data in Envoy's data plane.
   * If this is set, write_data should not be set.
   */
  read_data?:
    | Data
    | undefined;
  /**
   * The processed WriteData containing potentially modified data for the response path.
   * This should be sent in response to a ProcessingRequest with write_data, and the
   * previous data in ProcessingRequest will be replaced by the new data in Envoy's data plane.
   * If this is set, read_data should not be set.
   */
  write_data?:
    | Data
    | undefined;
  /**
   * Indicates whether the data was modified or not.
   * This is mandatory and tells Envoy whether to use the original or modified data.
   */
  data_processing_status?:
    | ProcessingResponse_DataProcessedStatus
    | undefined;
  /**
   * Optional: Determines the connection behavior after processing.
   * If not specified, CONTINUE is assumed, and the connection proceeds normally.
   * Use CLOSE or CLOSE_RST to terminate the connection based on processing results.
   */
  connection_status?:
    | ProcessingResponse_ConnectionStatus
    | undefined;
  /**
   * Optional metadata associated with the request.
   * This can include connection properties, filter configuration, and any other
   * contextual information that might be useful for processing decisions.
   *
   * The metadata is not automatically propagated from request to response.
   * The external processor must include any needed metadata in its response.
   */
  dynamic_metadata?: { [key: string]: any } | undefined;
}

/** DataProcessedStatus indicates whether the data was modified by the external processor. */
export enum ProcessingResponse_DataProcessedStatus {
  /** UNKNOWN - The data processed status is unknown. */
  UNKNOWN = "UNKNOWN",
  /**
   * UNMODIFIED - The data remains unchanged. Envoy will use the original data.
   * This is useful when the processor only wants to inspect but not modify the traffic.
   */
  UNMODIFIED = "UNMODIFIED",
  /**
   * MODIFIED - The data has been modified. Envoy will use the modified data provided in the response.
   * This allows the processor to transform the network traffic as needed.
   */
  MODIFIED = "MODIFIED",
}

export function processingResponse_DataProcessedStatusFromJSON(object: any): ProcessingResponse_DataProcessedStatus {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return ProcessingResponse_DataProcessedStatus.UNKNOWN;
    case 1:
    case "UNMODIFIED":
      return ProcessingResponse_DataProcessedStatus.UNMODIFIED;
    case 2:
    case "MODIFIED":
      return ProcessingResponse_DataProcessedStatus.MODIFIED;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum ProcessingResponse_DataProcessedStatus",
      );
  }
}

export function processingResponse_DataProcessedStatusToJSON(object: ProcessingResponse_DataProcessedStatus): string {
  switch (object) {
    case ProcessingResponse_DataProcessedStatus.UNKNOWN:
      return "UNKNOWN";
    case ProcessingResponse_DataProcessedStatus.UNMODIFIED:
      return "UNMODIFIED";
    case ProcessingResponse_DataProcessedStatus.MODIFIED:
      return "MODIFIED";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum ProcessingResponse_DataProcessedStatus",
      );
  }
}

export function processingResponse_DataProcessedStatusToNumber(object: ProcessingResponse_DataProcessedStatus): number {
  switch (object) {
    case ProcessingResponse_DataProcessedStatus.UNKNOWN:
      return 0;
    case ProcessingResponse_DataProcessedStatus.UNMODIFIED:
      return 1;
    case ProcessingResponse_DataProcessedStatus.MODIFIED:
      return 2;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum ProcessingResponse_DataProcessedStatus",
      );
  }
}

/** ConnectionStatus determines what happens to the connection after processing. */
export enum ProcessingResponse_ConnectionStatus {
  /**
   * CONTINUE - Continue normal processing of the connection.
   * This is the default behavior and allows traffic to flow normally.
   */
  CONTINUE = "CONTINUE",
  /**
   * CLOSE - Close the connection with normal TCP FIN.
   * This allows for clean connection termination with a normal close sequence.
   * Any buffered data will be sent before closing.
   */
  CLOSE = "CLOSE",
  /**
   * CLOSE_RST - Immediately reset the connection with TCP RST.
   * This forcibly terminates the connection without a clean shutdown,
   * discarding any buffered data. Use this for security-critical situations
   * or when immediate termination is required.
   */
  CLOSE_RST = "CLOSE_RST",
}

export function processingResponse_ConnectionStatusFromJSON(object: any): ProcessingResponse_ConnectionStatus {
  switch (object) {
    case 0:
    case "CONTINUE":
      return ProcessingResponse_ConnectionStatus.CONTINUE;
    case 1:
    case "CLOSE":
      return ProcessingResponse_ConnectionStatus.CLOSE;
    case 2:
    case "CLOSE_RST":
      return ProcessingResponse_ConnectionStatus.CLOSE_RST;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ProcessingResponse_ConnectionStatus");
  }
}

export function processingResponse_ConnectionStatusToJSON(object: ProcessingResponse_ConnectionStatus): string {
  switch (object) {
    case ProcessingResponse_ConnectionStatus.CONTINUE:
      return "CONTINUE";
    case ProcessingResponse_ConnectionStatus.CLOSE:
      return "CLOSE";
    case ProcessingResponse_ConnectionStatus.CLOSE_RST:
      return "CLOSE_RST";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ProcessingResponse_ConnectionStatus");
  }
}

export function processingResponse_ConnectionStatusToNumber(object: ProcessingResponse_ConnectionStatus): number {
  switch (object) {
    case ProcessingResponse_ConnectionStatus.CONTINUE:
      return 0;
    case ProcessingResponse_ConnectionStatus.CLOSE:
      return 1;
    case ProcessingResponse_ConnectionStatus.CLOSE_RST:
      return 2;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ProcessingResponse_ConnectionStatus");
  }
}

function createBaseData(): Data {
  return { $type: "envoy.service.network_ext_proc.v3.Data" };
}

export const Data: MessageFns<Data, "envoy.service.network_ext_proc.v3.Data"> = {
  $type: "envoy.service.network_ext_proc.v3.Data" as const,

  encode(message: Data, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data !== undefined && message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    if (message.end_of_stream !== undefined && message.end_of_stream !== false) {
      writer.uint32(16).bool(message.end_of_stream);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Data {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.end_of_stream = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Data {
    return {
      $type: Data.$type,
      data: isSet(object.data) ? bytesFromBase64(object.data) : undefined,
      end_of_stream: isSet(object.end_of_stream) ? globalThis.Boolean(object.end_of_stream) : undefined,
    };
  },

  toJSON(message: Data): unknown {
    const obj: any = {};
    if (message.data !== undefined) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.end_of_stream !== undefined) {
      obj.end_of_stream = message.end_of_stream;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Data>, I>>(base?: I): Data {
    return Data.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Data>, I>>(object: I): Data {
    const message = createBaseData();
    message.data = object.data ?? undefined;
    message.end_of_stream = object.end_of_stream ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Data.$type, Data);

function createBaseProcessingRequest(): ProcessingRequest {
  return { $type: "envoy.service.network_ext_proc.v3.ProcessingRequest" };
}

export const ProcessingRequest: MessageFns<ProcessingRequest, "envoy.service.network_ext_proc.v3.ProcessingRequest"> = {
  $type: "envoy.service.network_ext_proc.v3.ProcessingRequest" as const,

  encode(message: ProcessingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.read_data !== undefined) {
      Data.encode(message.read_data, writer.uint32(10).fork()).join();
    }
    if (message.write_data !== undefined) {
      Data.encode(message.write_data, writer.uint32(18).fork()).join();
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.read_data = Data.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.write_data = Data.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessingRequest {
    return {
      $type: ProcessingRequest.$type,
      read_data: isSet(object.read_data) ? Data.fromJSON(object.read_data) : undefined,
      write_data: isSet(object.write_data) ? Data.fromJSON(object.write_data) : undefined,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: ProcessingRequest): unknown {
    const obj: any = {};
    if (message.read_data !== undefined) {
      obj.read_data = Data.toJSON(message.read_data);
    }
    if (message.write_data !== undefined) {
      obj.write_data = Data.toJSON(message.write_data);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessingRequest>, I>>(base?: I): ProcessingRequest {
    return ProcessingRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessingRequest>, I>>(object: I): ProcessingRequest {
    const message = createBaseProcessingRequest();
    message.read_data = (object.read_data !== undefined && object.read_data !== null)
      ? Data.fromPartial(object.read_data)
      : undefined;
    message.write_data = (object.write_data !== undefined && object.write_data !== null)
      ? Data.fromPartial(object.write_data)
      : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(ProcessingRequest.$type, ProcessingRequest);

function createBaseProcessingResponse(): ProcessingResponse {
  return { $type: "envoy.service.network_ext_proc.v3.ProcessingResponse" };
}

export const ProcessingResponse: MessageFns<
  ProcessingResponse,
  "envoy.service.network_ext_proc.v3.ProcessingResponse"
> = {
  $type: "envoy.service.network_ext_proc.v3.ProcessingResponse" as const,

  encode(message: ProcessingResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.read_data !== undefined) {
      Data.encode(message.read_data, writer.uint32(10).fork()).join();
    }
    if (message.write_data !== undefined) {
      Data.encode(message.write_data, writer.uint32(18).fork()).join();
    }
    if (
      message.data_processing_status !== undefined &&
      message.data_processing_status !== ProcessingResponse_DataProcessedStatus.UNKNOWN
    ) {
      writer.uint32(24).int32(processingResponse_DataProcessedStatusToNumber(message.data_processing_status));
    }
    if (
      message.connection_status !== undefined &&
      message.connection_status !== ProcessingResponse_ConnectionStatus.CONTINUE
    ) {
      writer.uint32(32).int32(processingResponse_ConnectionStatusToNumber(message.connection_status));
    }
    if (message.dynamic_metadata !== undefined) {
      Struct.encode(Struct.wrap(message.dynamic_metadata), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessingResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.read_data = Data.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.write_data = Data.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.data_processing_status = processingResponse_DataProcessedStatusFromJSON(reader.int32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.connection_status = processingResponse_ConnectionStatusFromJSON(reader.int32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.dynamic_metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessingResponse {
    return {
      $type: ProcessingResponse.$type,
      read_data: isSet(object.read_data) ? Data.fromJSON(object.read_data) : undefined,
      write_data: isSet(object.write_data) ? Data.fromJSON(object.write_data) : undefined,
      data_processing_status: isSet(object.data_processing_status)
        ? processingResponse_DataProcessedStatusFromJSON(object.data_processing_status)
        : undefined,
      connection_status: isSet(object.connection_status)
        ? processingResponse_ConnectionStatusFromJSON(object.connection_status)
        : undefined,
      dynamic_metadata: isObject(object.dynamic_metadata) ? object.dynamic_metadata : undefined,
    };
  },

  toJSON(message: ProcessingResponse): unknown {
    const obj: any = {};
    if (message.read_data !== undefined) {
      obj.read_data = Data.toJSON(message.read_data);
    }
    if (message.write_data !== undefined) {
      obj.write_data = Data.toJSON(message.write_data);
    }
    if (message.data_processing_status !== undefined) {
      obj.data_processing_status = processingResponse_DataProcessedStatusToJSON(message.data_processing_status);
    }
    if (message.connection_status !== undefined) {
      obj.connection_status = processingResponse_ConnectionStatusToJSON(message.connection_status);
    }
    if (message.dynamic_metadata !== undefined) {
      obj.dynamic_metadata = message.dynamic_metadata;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessingResponse>, I>>(base?: I): ProcessingResponse {
    return ProcessingResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessingResponse>, I>>(object: I): ProcessingResponse {
    const message = createBaseProcessingResponse();
    message.read_data = (object.read_data !== undefined && object.read_data !== null)
      ? Data.fromPartial(object.read_data)
      : undefined;
    message.write_data = (object.write_data !== undefined && object.write_data !== null)
      ? Data.fromPartial(object.write_data)
      : undefined;
    message.data_processing_status = object.data_processing_status ?? undefined;
    message.connection_status = object.connection_status ?? undefined;
    message.dynamic_metadata = object.dynamic_metadata ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ProcessingResponse.$type, ProcessingResponse);

/**
 * NetworkExternalProcessor service defines the contract between Envoy and
 * external processing servers for L4 network traffic.
 */
export interface NetworkExternalProcessor {
  /**
   * Process establishes a bidirectional stream between Envoy and the external
   * processing server. Envoy sends ProcessingRequests containing network data
   * and the server responds with ProcessingResponses containing processing
   * decisions and potentially modified data.
   *
   * The server should handle processing timeout properly to avoid blocking
   * network traffic for extended periods. Any uncaught exceptions will
   * be treated as errors and will terminate the stream.
   *
   * Implementation note: The server should process requests in the order
   * they are received to maintain proper sequencing of network traffic.
   */
  Process(request: Observable<ProcessingRequest>): Observable<ProcessingResponse>;
}

export const NetworkExternalProcessorServiceName = "envoy.service.network_ext_proc.v3.NetworkExternalProcessor";
export class NetworkExternalProcessorClientImpl implements NetworkExternalProcessor {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || NetworkExternalProcessorServiceName;
    this.rpc = rpc;
    this.Process = this.Process.bind(this);
  }
  Process(request: Observable<ProcessingRequest>): Observable<ProcessingResponse> {
    const data = request.pipe(map((request) => ProcessingRequest.encode(request).finish()));
    const result = this.rpc.bidirectionalStreamingRequest(this.service, "Process", data);
    return result.pipe(map((data) => ProcessingResponse.decode(new BinaryReader(data))));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
  clientStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Promise<Uint8Array>;
  serverStreamingRequest(service: string, method: string, data: Uint8Array): Observable<Uint8Array>;
  bidirectionalStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Observable<Uint8Array>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
