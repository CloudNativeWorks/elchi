// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/config/bootstrap/v3/bootstrap.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../../google/protobuf/duration";
import { Struct } from "../../../../google/protobuf/struct";
import { UInt64Value } from "../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../typeRegistry";
import { Secret } from "../../../extensions/transport_sockets/tls/v3/secret";
import { Percent } from "../../../type/v3/percent";
import { AccessLog } from "../../accesslog/v3/accesslog";
import { Cluster } from "../../cluster/v3/cluster";
import { Address, BindConfig } from "../../core/v3/address";
import { Node } from "../../core/v3/base";
import { ApiConfigSource, ConfigSource } from "../../core/v3/config_source";
import { EventServiceConfig } from "../../core/v3/event_service_config";
import { TypedExtensionConfig } from "../../core/v3/extension";
import { DnsResolutionConfig } from "../../core/v3/resolver";
import { SocketOption } from "../../core/v3/socket_option";
import { Listener } from "../../listener/v3/listener";
import { StatsConfig, StatsSink } from "../../metrics/v3/stats";
import { OverloadManager } from "../../overload/v3/overload";
import { Tracing } from "../../trace/v3/http_tracer";

export const protobufPackage = "envoy.config.bootstrap.v3";

/**
 * Bootstrap :ref:`configuration overview <config_overview_bootstrap>`.
 * [#next-free-field: 42]
 */
export interface Bootstrap {
  $type: "envoy.config.bootstrap.v3.Bootstrap";
  /**
   * Node identity to present to the management server and for instance
   * identification purposes (e.g. in generated headers).
   */
  node?:
    | Node
    | undefined;
  /**
   * A list of :ref:`Node <envoy_v3_api_msg_config.core.v3.Node>` field names
   * that will be included in the context parameters of the effective
   * xdstp:// URL that is sent in a discovery request when resource
   * locators are used for LDS/CDS. Any non-string field will have its JSON
   * encoding set as the context parameter value, with the exception of
   * metadata, which will be flattened (see example below). The supported field
   * names are:
   * - "cluster"
   * - "id"
   * - "locality.region"
   * - "locality.sub_zone"
   * - "locality.zone"
   * - "metadata"
   * - "user_agent_build_version.metadata"
   * - "user_agent_build_version.version"
   * - "user_agent_name"
   * - "user_agent_version"
   *
   * The node context parameters act as a base layer dictionary for the context
   * parameters (i.e. more specific resource specific context parameters will
   * override). Field names will be prefixed with “udpa.node.” when included in
   * context parameters.
   *
   * For example, if node_context_params is ``["user_agent_name", "metadata"]``,
   * the implied context parameters might be::
   *
   *   node.user_agent_name: "envoy"
   *   node.metadata.foo: "{\"bar\": \"baz\"}"
   *   node.metadata.some: "42"
   *   node.metadata.thing: "\"thing\""
   *
   * [#not-implemented-hide:]
   */
  node_context_params?:
    | string[]
    | undefined;
  /** Statically specified resources. */
  static_resources?:
    | Bootstrap_StaticResources
    | undefined;
  /** xDS configuration sources. */
  dynamic_resources?:
    | Bootstrap_DynamicResources
    | undefined;
  /**
   * Configuration for the cluster manager which owns all upstream clusters
   * within the server.
   */
  cluster_manager?:
    | ClusterManager
    | undefined;
  /**
   * Health discovery service config option.
   * (:ref:`core.ApiConfigSource <envoy_v3_api_msg_config.core.v3.ApiConfigSource>`)
   */
  hds_config?:
    | ApiConfigSource
    | undefined;
  /** Optional file system path to search for startup flag files. */
  flags_path?:
    | string
    | undefined;
  /** Optional set of stats sinks. */
  stats_sinks?:
    | StatsSink[]
    | undefined;
  /** Options to control behaviors of deferred creation compatible stats. */
  deferred_stat_options?:
    | Bootstrap_DeferredStatOptions
    | undefined;
  /** Configuration for internal processing of stats. */
  stats_config?:
    | StatsConfig
    | undefined;
  /**
   * Optional duration between flushes to configured stats sinks. For
   * performance reasons Envoy latches counters and only flushes counters and
   * gauges at a periodic interval. If not specified the default is 5000ms (5
   * seconds). Only one of ``stats_flush_interval`` or ``stats_flush_on_admin``
   * can be set.
   * Duration must be at least 1ms and at most 5 min.
   */
  stats_flush_interval?: Duration | undefined;
  stats_flush?:
    | //
    /**
     * Flush stats to sinks only when queried for on the admin interface. If set,
     * a flush timer is not created. Only one of ``stats_flush_on_admin`` or
     * ``stats_flush_interval`` can be set.
     */
    { $case: "stats_flush_on_admin"; stats_flush_on_admin: boolean }
    | undefined;
  /**
   * Optional watchdog configuration.
   * This is for a single watchdog configuration for the entire system.
   * Deprecated in favor of ``watchdogs`` which has finer granularity.
   *
   * @deprecated
   */
  watchdog?:
    | Watchdog
    | undefined;
  /**
   * Optional watchdogs configuration.
   * This is used for specifying different watchdogs for the different subsystems.
   * [#extension-category: envoy.guarddog_actions]
   */
  watchdogs?:
    | Watchdogs
    | undefined;
  /**
   * Configuration for an external tracing provider.
   *
   * .. attention::
   *  This field has been deprecated in favor of :ref:`HttpConnectionManager.Tracing.provider
   *  <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.provider>`.
   *
   * @deprecated
   */
  tracing?:
    | Tracing
    | undefined;
  /**
   * Configuration for the runtime configuration provider. If not
   * specified, a “null” provider will be used which will result in all defaults
   * being used.
   */
  layered_runtime?:
    | LayeredRuntime
    | undefined;
  /** Configuration for the local administration HTTP server. */
  admin?:
    | Admin
    | undefined;
  /** Optional overload manager configuration. */
  overload_manager?:
    | OverloadManager
    | undefined;
  /**
   * Enable :ref:`stats for event dispatcher <operations_performance>`, defaults to false.
   * Note that this records a value for each iteration of the event loop on every thread. This
   * should normally be minimal overhead, but when using
   * :ref:`statsd <envoy_v3_api_msg_config.metrics.v3.StatsdSink>`, it will send each observed value
   * over the wire individually because the statsd protocol doesn't have any way to represent a
   * histogram summary. Be aware that this can be a very large volume of data.
   */
  enable_dispatcher_stats?:
    | boolean
    | undefined;
  /**
   * Optional string which will be used in lieu of x-envoy in prefixing headers.
   *
   * For example, if this string is present and set to X-Foo, then x-envoy-retry-on will be
   * transformed into x-foo-retry-on etc.
   *
   * Note this applies to the headers Envoy will generate, the headers Envoy will sanitize, and the
   * headers Envoy will trust for core code and core extensions only. Be VERY careful making
   * changes to this string, especially in multi-layer Envoy deployments or deployments using
   * extensions which are not upstream.
   */
  header_prefix?:
    | string
    | undefined;
  /**
   * Optional proxy version which will be used to set the value of :ref:`server.version statistic
   * <server_statistics>` if specified. Envoy will not process this value, it will be sent as is to
   * :ref:`stats sinks <envoy_v3_api_msg_config.metrics.v3.StatsSink>`.
   */
  stats_server_version_override?:
    | number
    | undefined;
  /**
   * Always use TCP queries instead of UDP queries for DNS lookups.
   * This may be overridden on a per-cluster basis in cds_config,
   * when :ref:`dns_resolvers <envoy_v3_api_field_config.cluster.v3.Cluster.dns_resolvers>` and
   * :ref:`use_tcp_for_dns_lookups <envoy_v3_api_field_config.cluster.v3.Cluster.use_tcp_for_dns_lookups>` are
   * specified.
   * This field is deprecated in favor of ``dns_resolution_config``
   * which aggregates all of the DNS resolver configuration in a single message.
   *
   * @deprecated
   */
  use_tcp_for_dns_lookups?:
    | boolean
    | undefined;
  /**
   * DNS resolution configuration which includes the underlying dns resolver addresses and options.
   * This may be overridden on a per-cluster basis in cds_config, when
   * :ref:`dns_resolution_config <envoy_v3_api_field_config.cluster.v3.Cluster.dns_resolution_config>`
   * is specified.
   * This field is deprecated in favor of
   * :ref:`typed_dns_resolver_config <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.typed_dns_resolver_config>`.
   *
   * @deprecated
   */
  dns_resolution_config?:
    | DnsResolutionConfig
    | undefined;
  /**
   * DNS resolver type configuration extension. This extension can be used to configure c-ares, apple,
   * or any other DNS resolver types and the related parameters.
   * For example, an object of
   * :ref:`CaresDnsResolverConfig <envoy_v3_api_msg_extensions.network.dns_resolver.cares.v3.CaresDnsResolverConfig>`
   * can be packed into this ``typed_dns_resolver_config``. This configuration replaces the
   * :ref:`dns_resolution_config <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.dns_resolution_config>`
   * configuration.
   * During the transition period when both ``dns_resolution_config`` and ``typed_dns_resolver_config`` exists,
   * when ``typed_dns_resolver_config`` is in place, Envoy will use it and ignore ``dns_resolution_config``.
   * When ``typed_dns_resolver_config`` is missing, the default behavior is in place.
   * [#extension-category: envoy.network.dns_resolver]
   */
  typed_dns_resolver_config?:
    | TypedExtensionConfig
    | undefined;
  /**
   * Specifies optional bootstrap extensions to be instantiated at startup time.
   * Each item contains extension specific configuration.
   * [#extension-category: envoy.bootstrap]
   */
  bootstrap_extensions?:
    | TypedExtensionConfig[]
    | undefined;
  /**
   * Specifies optional extensions instantiated at startup time and
   * invoked during crash time on the request that caused the crash.
   */
  fatal_actions?:
    | FatalAction[]
    | undefined;
  /**
   * Configuration sources that will participate in
   * xdstp:// URL authority resolution. The algorithm is as
   * follows:
   * 1. The authority field is taken from the xdstp:// URL, call
   *    this ``resource_authority``.
   * 2. ``resource_authority`` is compared against the authorities in any peer
   *    ``ConfigSource``. The peer ``ConfigSource`` is the configuration source
   *    message which would have been used unconditionally for resolution
   *    with opaque resource names. If there is a match with an authority, the
   *    peer ``ConfigSource`` message is used.
   * 3. ``resource_authority`` is compared sequentially with the authorities in
   *    each configuration source in ``config_sources``. The first ``ConfigSource``
   *    to match wins.
   * 4. As a fallback, if no configuration source matches, then
   *    ``default_config_source`` is used.
   * 5. If ``default_config_source`` is not specified, resolution fails.
   * [#not-implemented-hide:]
   */
  config_sources?:
    | ConfigSource[]
    | undefined;
  /**
   * Default configuration source for xdstp:// URLs if all
   * other resolution fails.
   * [#not-implemented-hide:]
   */
  default_config_source?:
    | ConfigSource
    | undefined;
  /**
   * Optional overriding of default socket interface. The value must be the name of one of the
   * socket interface factories initialized through a bootstrap extension
   */
  default_socket_interface?:
    | string
    | undefined;
  /**
   * Global map of CertificateProvider instances. These instances are referred to by name in the
   * :ref:`CommonTlsContext.CertificateProviderInstance.instance_name
   * <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderInstance.instance_name>`
   * field.
   * [#not-implemented-hide:]
   */
  certificate_provider_instances?:
    | Map<string, TypedExtensionConfig>
    | undefined;
  /**
   * Specifies a set of headers that need to be registered as inline header. This configuration
   * allows users to customize the inline headers on-demand at Envoy startup without modifying
   * Envoy's source code.
   *
   * Note that the 'set-cookie' header cannot be registered as inline header.
   */
  inline_headers?:
    | CustomInlineHeader[]
    | undefined;
  /**
   * Optional path to a file with performance tracing data created by "Perfetto" SDK in binary
   * ProtoBuf format. The default value is "envoy.pftrace".
   */
  perf_tracing_file_path?:
    | string
    | undefined;
  /**
   * Optional overriding of default regex engine.
   * If the value is not specified, Google RE2 will be used by default.
   * [#extension-category: envoy.regex_engines]
   */
  default_regex_engine?:
    | TypedExtensionConfig
    | undefined;
  /**
   * Optional XdsResourcesDelegate configuration, which allows plugging custom logic into both
   * fetch and load events during xDS processing.
   * If a value is not specified, no XdsResourcesDelegate will be used.
   * TODO(abeyad): Add public-facing documentation.
   * [#not-implemented-hide:]
   */
  xds_delegate_extension?:
    | TypedExtensionConfig
    | undefined;
  /**
   * Optional XdsConfigTracker configuration, which allows tracking xDS responses in external components,
   * e.g., external tracer or monitor. It provides the process point when receive, ingest, or fail to
   * process xDS resources and messages. If a value is not specified, no XdsConfigTracker will be used.
   *
   * .. note::
   *
   *    There are no in-repo extensions currently, and the :repo:`XdsConfigTracker <envoy/config/xds_config_tracker.h>`
   *    interface should be implemented before using.
   *    See :repo:`xds_config_tracker_integration_test <test/integration/xds_config_tracker_integration_test.cc>`
   *    for an example usage of the interface.
   */
  xds_config_tracker_extension?:
    | TypedExtensionConfig
    | undefined;
  /**
   * [#not-implemented-hide:]
   * This controls the type of listener manager configured for Envoy. Currently
   * Envoy only supports ListenerManager for this field and Envoy Mobile
   * supports ApiListenerManager.
   */
  listener_manager?:
    | TypedExtensionConfig
    | undefined;
  /** Optional application log configuration. */
  application_log_config?:
    | Bootstrap_ApplicationLogConfig
    | undefined;
  /** Optional gRPC async manager config. */
  grpc_async_client_manager_config?:
    | Bootstrap_GrpcAsyncClientManagerConfig
    | undefined;
  /**
   * Optional configuration for memory allocation manager.
   * Memory releasing is only supported for `tcmalloc allocator <https://github.com/google/tcmalloc>`_.
   */
  memory_allocator_manager?: MemoryAllocatorManager | undefined;
}

export interface Bootstrap_StaticResources {
  $type: "envoy.config.bootstrap.v3.Bootstrap.StaticResources";
  /**
   * Static :ref:`Listeners <envoy_v3_api_msg_config.listener.v3.Listener>`. These listeners are
   * available regardless of LDS configuration.
   */
  listeners?:
    | Listener[]
    | undefined;
  /**
   * If a network based configuration source is specified for :ref:`cds_config
   * <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.DynamicResources.cds_config>`, it's necessary
   * to have some initial cluster definitions available to allow Envoy to know
   * how to speak to the management server. These cluster definitions may not
   * use :ref:`EDS <arch_overview_dynamic_config_eds>` (i.e. they should be static
   * IP or DNS-based).
   */
  clusters?:
    | Cluster[]
    | undefined;
  /**
   * These static secrets can be used by :ref:`SdsSecretConfig
   * <envoy_v3_api_msg_extensions.transport_sockets.tls.v3.SdsSecretConfig>`
   */
  secrets?: Secret[] | undefined;
}

/** [#next-free-field: 7] */
export interface Bootstrap_DynamicResources {
  $type: "envoy.config.bootstrap.v3.Bootstrap.DynamicResources";
  /**
   * All :ref:`Listeners <envoy_v3_api_msg_config.listener.v3.Listener>` are provided by a single
   * :ref:`LDS <arch_overview_dynamic_config_lds>` configuration source.
   */
  lds_config?:
    | ConfigSource
    | undefined;
  /**
   * xdstp:// resource locator for listener collection.
   * [#not-implemented-hide:]
   */
  lds_resources_locator?:
    | string
    | undefined;
  /**
   * All post-bootstrap :ref:`Cluster <envoy_v3_api_msg_config.cluster.v3.Cluster>` definitions are
   * provided by a single :ref:`CDS <arch_overview_dynamic_config_cds>`
   * configuration source.
   */
  cds_config?:
    | ConfigSource
    | undefined;
  /**
   * xdstp:// resource locator for cluster collection.
   * [#not-implemented-hide:]
   */
  cds_resources_locator?:
    | string
    | undefined;
  /**
   * A single :ref:`ADS <config_overview_ads>` source may be optionally
   * specified. This must have :ref:`api_type
   * <envoy_v3_api_field_config.core.v3.ApiConfigSource.api_type>` :ref:`GRPC
   * <envoy_v3_api_enum_value_config.core.v3.ApiConfigSource.ApiType.GRPC>`. Only
   * :ref:`ConfigSources <envoy_v3_api_msg_config.core.v3.ConfigSource>` that have
   * the :ref:`ads <envoy_v3_api_field_config.core.v3.ConfigSource.ads>` field set will be
   * streamed on the ADS channel.
   */
  ads_config?: ApiConfigSource | undefined;
}

export interface Bootstrap_ApplicationLogConfig {
  $type: "envoy.config.bootstrap.v3.Bootstrap.ApplicationLogConfig";
  /**
   * Optional field to set the application logs format. If this field is set, it will override
   * the default log format. Setting both this field and :option:`--log-format` command line
   * option is not allowed, and will cause a bootstrap error.
   */
  log_format?: Bootstrap_ApplicationLogConfig_LogFormat | undefined;
}

export interface Bootstrap_ApplicationLogConfig_LogFormat {
  $type: "envoy.config.bootstrap.v3.Bootstrap.ApplicationLogConfig.LogFormat";
  log_format?:
    | //
    /**
     * Flush application logs in JSON format. The configured JSON struct can
     * support all the format flags specified in the :option:`--log-format`
     * command line options section, except for the ``%v`` and ``%_`` flags.
     */
    { $case: "json_format"; json_format: { [key: string]: any } | undefined }
    | //
    /**
     * Flush application log in a format defined by a string. The text format
     * can support all the format flags specified in the :option:`--log-format`
     * command line option section.
     */
    { $case: "text_format"; text_format: string }
    | undefined;
}

export interface Bootstrap_DeferredStatOptions {
  $type: "envoy.config.bootstrap.v3.Bootstrap.DeferredStatOptions";
  /**
   * When the flag is enabled, Envoy will lazily initialize a subset of the stats (see below).
   * This will save memory and CPU cycles when creating the objects that own these stats, if those
   * stats are never referenced throughout the lifetime of the process. However, it will incur additional
   * memory overhead for these objects, and a small increase of CPU usage when a at least one of the stats
   * is updated for the first time.
   * Groups of stats that will be lazily initialized:
   * - Cluster traffic stats: a subgroup of the :ref:`cluster statistics <config_cluster_manager_cluster_stats>`
   * that are used when requests are routed to the cluster.
   */
  enable_deferred_creation_stats?: boolean | undefined;
}

export interface Bootstrap_GrpcAsyncClientManagerConfig {
  $type: "envoy.config.bootstrap.v3.Bootstrap.GrpcAsyncClientManagerConfig";
  /**
   * Optional field to set the expiration time for the cached gRPC client object.
   * The minimal value is 5s and the default is 50s.
   */
  max_cached_entry_idle_duration?: Duration | undefined;
}

export interface Bootstrap_CertificateProviderInstancesEntry {
  $type: "envoy.config.bootstrap.v3.Bootstrap.CertificateProviderInstancesEntry";
  key: string;
  value?: TypedExtensionConfig | undefined;
}

/**
 * Administration interface :ref:`operations documentation
 * <operations_admin_interface>`.
 * [#next-free-field: 7]
 */
export interface Admin {
  $type: "envoy.config.bootstrap.v3.Admin";
  /**
   * Configuration for :ref:`access logs <arch_overview_access_logs>`
   * emitted by the administration server.
   */
  access_log?:
    | AccessLog[]
    | undefined;
  /**
   * The path to write the access log for the administration server. If no
   * access log is desired specify ‘/dev/null’. This is only required if
   * :ref:`address <envoy_v3_api_field_config.bootstrap.v3.Admin.address>` is set.
   * Deprecated in favor of ``access_log`` which offers more options.
   *
   * @deprecated
   */
  access_log_path?:
    | string
    | undefined;
  /**
   * The cpu profiler output path for the administration server. If no profile
   * path is specified, the default is ‘/var/log/envoy/envoy.prof’.
   */
  profile_path?:
    | string
    | undefined;
  /**
   * The TCP address that the administration server will listen on.
   * If not specified, Envoy will not start an administration server.
   */
  address?:
    | Address
    | undefined;
  /**
   * Additional socket options that may not be present in Envoy source code or
   * precompiled binaries.
   */
  socket_options?:
    | SocketOption[]
    | undefined;
  /**
   * Indicates whether :ref:`global_downstream_max_connections <config_overload_manager_limiting_connections>`
   * should apply to the admin interface or not.
   */
  ignore_global_conn_limit?: boolean | undefined;
}

/**
 * Cluster manager :ref:`architecture overview <arch_overview_cluster_manager>`.
 * [#next-free-field: 6]
 */
export interface ClusterManager {
  $type: "envoy.config.bootstrap.v3.ClusterManager";
  /**
   * Name of the local cluster (i.e., the cluster that owns the Envoy running
   * this configuration). In order to enable :ref:`zone aware routing
   * <arch_overview_load_balancing_zone_aware_routing>` this option must be set.
   * If ``local_cluster_name`` is defined then :ref:`clusters
   * <envoy_v3_api_msg_config.cluster.v3.Cluster>` must be defined in the :ref:`Bootstrap
   * static cluster resources
   * <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.StaticResources.clusters>`. This is unrelated to
   * the :option:`--service-cluster` option which does not `affect zone aware
   * routing <https://github.com/envoyproxy/envoy/issues/774>`_.
   */
  local_cluster_name?:
    | string
    | undefined;
  /** Optional global configuration for outlier detection. */
  outlier_detection?:
    | ClusterManager_OutlierDetection
    | undefined;
  /**
   * Optional configuration used to bind newly established upstream connections.
   * This may be overridden on a per-cluster basis by upstream_bind_config in the cds_config.
   */
  upstream_bind_config?:
    | BindConfig
    | undefined;
  /**
   * A management server endpoint to stream load stats to via
   * ``StreamLoadStats``. This must have :ref:`api_type
   * <envoy_v3_api_field_config.core.v3.ApiConfigSource.api_type>` :ref:`GRPC
   * <envoy_v3_api_enum_value_config.core.v3.ApiConfigSource.ApiType.GRPC>`.
   */
  load_stats_config?:
    | ApiConfigSource
    | undefined;
  /**
   * Whether the ClusterManager will create clusters on the worker threads
   * inline during requests. This will save memory and CPU cycles in cases where
   * there are lots of inactive clusters and > 1 worker thread.
   */
  enable_deferred_cluster_creation?: boolean | undefined;
}

export interface ClusterManager_OutlierDetection {
  $type: "envoy.config.bootstrap.v3.ClusterManager.OutlierDetection";
  /** Specifies the path to the outlier event log. */
  event_log_path?:
    | string
    | undefined;
  /**
   * [#not-implemented-hide:]
   * The gRPC service for the outlier detection event service.
   * If empty, outlier detection events won't be sent to a remote endpoint.
   */
  event_service?: EventServiceConfig | undefined;
}

/**
 * Allows you to specify different watchdog configs for different subsystems.
 * This allows finer tuned policies for the watchdog. If a subsystem is omitted
 * the default values for that system will be used.
 */
export interface Watchdogs {
  $type: "envoy.config.bootstrap.v3.Watchdogs";
  /** Watchdog for the main thread. */
  main_thread_watchdog?:
    | Watchdog
    | undefined;
  /** Watchdog for the worker threads. */
  worker_watchdog?: Watchdog | undefined;
}

/**
 * Envoy process watchdog configuration. When configured, this monitors for
 * nonresponsive threads and kills the process after the configured thresholds.
 * See the :ref:`watchdog documentation <operations_performance_watchdog>` for more information.
 * [#next-free-field: 8]
 */
export interface Watchdog {
  $type: "envoy.config.bootstrap.v3.Watchdog";
  /**
   * Register actions that will fire on given WatchDog events.
   * See ``WatchDogAction`` for priority of events.
   */
  actions?:
    | Watchdog_WatchdogAction[]
    | undefined;
  /**
   * The duration after which Envoy counts a nonresponsive thread in the
   * ``watchdog_miss`` statistic. If not specified the default is 200ms.
   */
  miss_timeout?:
    | Duration
    | undefined;
  /**
   * The duration after which Envoy counts a nonresponsive thread in the
   * ``watchdog_mega_miss`` statistic. If not specified the default is
   * 1000ms.
   */
  megamiss_timeout?:
    | Duration
    | undefined;
  /**
   * If a watched thread has been nonresponsive for this duration, assume a
   * programming error and kill the entire Envoy process. Set to 0 to disable
   * kill behavior. If not specified the default is 0 (disabled).
   */
  kill_timeout?:
    | Duration
    | undefined;
  /**
   * Defines the maximum jitter used to adjust the ``kill_timeout`` if ``kill_timeout`` is
   * enabled. Enabling this feature would help to reduce risk of synchronized
   * watchdog kill events across proxies due to external triggers. Set to 0 to
   * disable. If not specified the default is 0 (disabled).
   */
  max_kill_timeout_jitter?:
    | Duration
    | undefined;
  /**
   * If ``max(2, ceil(registered_threads * Fraction(*multikill_threshold*)))``
   * threads have been nonresponsive for at least this duration kill the entire
   * Envoy process. Set to 0 to disable this behavior. If not specified the
   * default is 0 (disabled).
   */
  multikill_timeout?:
    | Duration
    | undefined;
  /**
   * Sets the threshold for ``multikill_timeout`` in terms of the percentage of
   * nonresponsive threads required for the ``multikill_timeout``.
   * If not specified the default is 0.
   */
  multikill_threshold?: Percent | undefined;
}

export interface Watchdog_WatchdogAction {
  $type: "envoy.config.bootstrap.v3.Watchdog.WatchdogAction";
  /** Extension specific configuration for the action. */
  config?: TypedExtensionConfig | undefined;
  event?: Watchdog_WatchdogAction_WatchdogEvent | undefined;
}

/**
 * The events are fired in this order: KILL, MULTIKILL, MEGAMISS, MISS.
 * Within an event type, actions execute in the order they are configured.
 * For KILL/MULTIKILL there is a default PANIC that will run after the
 * registered actions and kills the process if it wasn't already killed.
 * It might be useful to specify several debug actions, and possibly an
 * alternate FATAL action.
 */
export enum Watchdog_WatchdogAction_WatchdogEvent {
  UNKNOWN = "UNKNOWN",
  KILL = "KILL",
  MULTIKILL = "MULTIKILL",
  MEGAMISS = "MEGAMISS",
  MISS = "MISS",
}

export function watchdog_WatchdogAction_WatchdogEventFromJSON(object: any): Watchdog_WatchdogAction_WatchdogEvent {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return Watchdog_WatchdogAction_WatchdogEvent.UNKNOWN;
    case 1:
    case "KILL":
      return Watchdog_WatchdogAction_WatchdogEvent.KILL;
    case 2:
    case "MULTIKILL":
      return Watchdog_WatchdogAction_WatchdogEvent.MULTIKILL;
    case 3:
    case "MEGAMISS":
      return Watchdog_WatchdogAction_WatchdogEvent.MEGAMISS;
    case 4:
    case "MISS":
      return Watchdog_WatchdogAction_WatchdogEvent.MISS;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum Watchdog_WatchdogAction_WatchdogEvent",
      );
  }
}

export function watchdog_WatchdogAction_WatchdogEventToJSON(object: Watchdog_WatchdogAction_WatchdogEvent): string {
  switch (object) {
    case Watchdog_WatchdogAction_WatchdogEvent.UNKNOWN:
      return "UNKNOWN";
    case Watchdog_WatchdogAction_WatchdogEvent.KILL:
      return "KILL";
    case Watchdog_WatchdogAction_WatchdogEvent.MULTIKILL:
      return "MULTIKILL";
    case Watchdog_WatchdogAction_WatchdogEvent.MEGAMISS:
      return "MEGAMISS";
    case Watchdog_WatchdogAction_WatchdogEvent.MISS:
      return "MISS";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum Watchdog_WatchdogAction_WatchdogEvent",
      );
  }
}

export function watchdog_WatchdogAction_WatchdogEventToNumber(object: Watchdog_WatchdogAction_WatchdogEvent): number {
  switch (object) {
    case Watchdog_WatchdogAction_WatchdogEvent.UNKNOWN:
      return 0;
    case Watchdog_WatchdogAction_WatchdogEvent.KILL:
      return 1;
    case Watchdog_WatchdogAction_WatchdogEvent.MULTIKILL:
      return 2;
    case Watchdog_WatchdogAction_WatchdogEvent.MEGAMISS:
      return 3;
    case Watchdog_WatchdogAction_WatchdogEvent.MISS:
      return 4;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum Watchdog_WatchdogAction_WatchdogEvent",
      );
  }
}

/**
 * Fatal actions to run while crashing. Actions can be safe (meaning they are
 * async-signal safe) or unsafe. We run all safe actions before we run unsafe actions.
 * If using an unsafe action that could get stuck or deadlock, it important to
 * have an out of band system to terminate the process.
 *
 * The interface for the extension is ``Envoy::Server::Configuration::FatalAction``.
 * ``FatalAction`` extensions live in the ``envoy.extensions.fatal_actions`` API
 * namespace.
 */
export interface FatalAction {
  $type: "envoy.config.bootstrap.v3.FatalAction";
  /**
   * Extension specific configuration for the action. It's expected to conform
   * to the ``Envoy::Server::Configuration::FatalAction`` interface.
   */
  config?: TypedExtensionConfig | undefined;
}

/** Runtime :ref:`configuration overview <config_runtime>` (deprecated). */
export interface Runtime {
  $type: "envoy.config.bootstrap.v3.Runtime";
  /**
   * The implementation assumes that the file system tree is accessed via a
   * symbolic link. An atomic link swap is used when a new tree should be
   * switched to. This parameter specifies the path to the symbolic link. Envoy
   * will watch the location for changes and reload the file system tree when
   * they happen. If this parameter is not set, there will be no disk based
   * runtime.
   */
  symlink_root?:
    | string
    | undefined;
  /**
   * Specifies the subdirectory to load within the root directory. This is
   * useful if multiple systems share the same delivery mechanism. Envoy
   * configuration elements can be contained in a dedicated subdirectory.
   */
  subdirectory?:
    | string
    | undefined;
  /**
   * Specifies an optional subdirectory to load within the root directory. If
   * specified and the directory exists, configuration values within this
   * directory will override those found in the primary subdirectory. This is
   * useful when Envoy is deployed across many different types of servers.
   * Sometimes it is useful to have a per service cluster directory for runtime
   * configuration. See below for exactly how the override directory is used.
   */
  override_subdirectory?:
    | string
    | undefined;
  /**
   * Static base runtime. This will be :ref:`overridden
   * <config_runtime_layering>` by other runtime layers, e.g.
   * disk or admin. This follows the :ref:`runtime protobuf JSON representation
   * encoding <config_runtime_proto_json>`.
   */
  base?: { [key: string]: any } | undefined;
}

/** [#next-free-field: 6] */
export interface RuntimeLayer {
  $type: "envoy.config.bootstrap.v3.RuntimeLayer";
  /**
   * Descriptive name for the runtime layer. This is only used for the runtime
   * :http:get:`/runtime` output.
   */
  name?: string | undefined;
  layer_specifier?:
    | //
    /**
     * :ref:`Static runtime <config_runtime_bootstrap>` layer.
     * This follows the :ref:`runtime protobuf JSON representation encoding
     * <config_runtime_proto_json>`. Unlike static xDS resources, this static
     * layer is overridable by later layers in the runtime virtual filesystem.
     */
    { $case: "static_layer"; static_layer: { [key: string]: any } | undefined }
    | //
    { $case: "disk_layer"; disk_layer: RuntimeLayer_DiskLayer }
    | //
    { $case: "admin_layer"; admin_layer: RuntimeLayer_AdminLayer }
    | //
    { $case: "rtds_layer"; rtds_layer: RuntimeLayer_RtdsLayer }
    | undefined;
}

/** :ref:`Disk runtime <config_runtime_local_disk>` layer. */
export interface RuntimeLayer_DiskLayer {
  $type: "envoy.config.bootstrap.v3.RuntimeLayer.DiskLayer";
  /**
   * The implementation assumes that the file system tree is accessed via a
   * symbolic link. An atomic link swap is used when a new tree should be
   * switched to. This parameter specifies the path to the symbolic link.
   * Envoy will watch the location for changes and reload the file system tree
   * when they happen. See documentation on runtime :ref:`atomicity
   * <config_runtime_atomicity>` for further details on how reloads are
   * treated.
   */
  symlink_root?:
    | string
    | undefined;
  /**
   * Specifies the subdirectory to load within the root directory. This is
   * useful if multiple systems share the same delivery mechanism. Envoy
   * configuration elements can be contained in a dedicated subdirectory.
   */
  subdirectory?:
    | string
    | undefined;
  /**
   * :ref:`Append <config_runtime_local_disk_service_cluster_subdirs>` the
   * service cluster to the path under symlink root.
   */
  append_service_cluster?: boolean | undefined;
}

/** :ref:`Admin console runtime <config_runtime_admin>` layer. */
export interface RuntimeLayer_AdminLayer {
  $type: "envoy.config.bootstrap.v3.RuntimeLayer.AdminLayer";
}

/** :ref:`Runtime Discovery Service (RTDS) <config_runtime_rtds>` layer. */
export interface RuntimeLayer_RtdsLayer {
  $type: "envoy.config.bootstrap.v3.RuntimeLayer.RtdsLayer";
  /** Resource to subscribe to at ``rtds_config`` for the RTDS layer. */
  name?:
    | string
    | undefined;
  /** RTDS configuration source. */
  rtds_config?: ConfigSource | undefined;
}

/** Runtime :ref:`configuration overview <config_runtime>`. */
export interface LayeredRuntime {
  $type: "envoy.config.bootstrap.v3.LayeredRuntime";
  /**
   * The :ref:`layers <config_runtime_layering>` of the runtime. This is ordered
   * such that later layers in the list overlay earlier entries.
   */
  layers?: RuntimeLayer[] | undefined;
}

/**
 * Used to specify the header that needs to be registered as an inline header.
 *
 * If request or response contain multiple headers with the same name and the header
 * name is registered as an inline header. Then multiple headers will be folded
 * into one, and multiple header values will be concatenated by a suitable delimiter.
 * The delimiter is generally a comma.
 *
 * For example, if 'foo' is registered as an inline header, and the headers contains
 * the following two headers:
 *
 * .. code-block:: text
 *
 *   foo: bar
 *   foo: eep
 *
 * Then they will eventually be folded into:
 *
 * .. code-block:: text
 *
 *   foo: bar, eep
 *
 * Inline headers provide O(1) search performance, but each inline header imposes
 * an additional memory overhead on all instances of the corresponding type of
 * HeaderMap or TrailerMap.
 */
export interface CustomInlineHeader {
  $type: "envoy.config.bootstrap.v3.CustomInlineHeader";
  /** The name of the header that is expected to be set as the inline header. */
  inline_header_name?:
    | string
    | undefined;
  /** The type of the header that is expected to be set as the inline header. */
  inline_header_type?: CustomInlineHeader_InlineHeaderType | undefined;
}

export enum CustomInlineHeader_InlineHeaderType {
  REQUEST_HEADER = "REQUEST_HEADER",
  REQUEST_TRAILER = "REQUEST_TRAILER",
  RESPONSE_HEADER = "RESPONSE_HEADER",
  RESPONSE_TRAILER = "RESPONSE_TRAILER",
}

export function customInlineHeader_InlineHeaderTypeFromJSON(object: any): CustomInlineHeader_InlineHeaderType {
  switch (object) {
    case 0:
    case "REQUEST_HEADER":
      return CustomInlineHeader_InlineHeaderType.REQUEST_HEADER;
    case 1:
    case "REQUEST_TRAILER":
      return CustomInlineHeader_InlineHeaderType.REQUEST_TRAILER;
    case 2:
    case "RESPONSE_HEADER":
      return CustomInlineHeader_InlineHeaderType.RESPONSE_HEADER;
    case 3:
    case "RESPONSE_TRAILER":
      return CustomInlineHeader_InlineHeaderType.RESPONSE_TRAILER;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CustomInlineHeader_InlineHeaderType");
  }
}

export function customInlineHeader_InlineHeaderTypeToJSON(object: CustomInlineHeader_InlineHeaderType): string {
  switch (object) {
    case CustomInlineHeader_InlineHeaderType.REQUEST_HEADER:
      return "REQUEST_HEADER";
    case CustomInlineHeader_InlineHeaderType.REQUEST_TRAILER:
      return "REQUEST_TRAILER";
    case CustomInlineHeader_InlineHeaderType.RESPONSE_HEADER:
      return "RESPONSE_HEADER";
    case CustomInlineHeader_InlineHeaderType.RESPONSE_TRAILER:
      return "RESPONSE_TRAILER";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CustomInlineHeader_InlineHeaderType");
  }
}

export function customInlineHeader_InlineHeaderTypeToNumber(object: CustomInlineHeader_InlineHeaderType): number {
  switch (object) {
    case CustomInlineHeader_InlineHeaderType.REQUEST_HEADER:
      return 0;
    case CustomInlineHeader_InlineHeaderType.REQUEST_TRAILER:
      return 1;
    case CustomInlineHeader_InlineHeaderType.RESPONSE_HEADER:
      return 2;
    case CustomInlineHeader_InlineHeaderType.RESPONSE_TRAILER:
      return 3;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CustomInlineHeader_InlineHeaderType");
  }
}

export interface MemoryAllocatorManager {
  $type: "envoy.config.bootstrap.v3.MemoryAllocatorManager";
  /**
   * Configures tcmalloc to perform background release of free memory in amount of bytes per ``memory_release_interval`` interval.
   * If equals to ``0``, no memory release will occur. Defaults to ``0``.
   */
  bytes_to_release?:
    | number
    | undefined;
  /**
   * Interval in milliseconds for memory releasing. If specified, during every
   * interval Envoy will try to release ``bytes_to_release`` of free memory back to operating system for reuse.
   * Defaults to 1000 milliseconds.
   */
  memory_release_interval?: Duration | undefined;
}

function createBaseBootstrap(): Bootstrap {
  return { $type: "envoy.config.bootstrap.v3.Bootstrap", stats_flush: undefined };
}

export const Bootstrap: MessageFns<Bootstrap, "envoy.config.bootstrap.v3.Bootstrap"> = {
  $type: "envoy.config.bootstrap.v3.Bootstrap" as const,

  encode(message: Bootstrap, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.node !== undefined) {
      Node.encode(message.node, writer.uint32(10).fork()).join();
    }
    if (message.node_context_params !== undefined && message.node_context_params.length !== 0) {
      for (const v of message.node_context_params) {
        writer.uint32(210).string(v!);
      }
    }
    if (message.static_resources !== undefined) {
      Bootstrap_StaticResources.encode(message.static_resources, writer.uint32(18).fork()).join();
    }
    if (message.dynamic_resources !== undefined) {
      Bootstrap_DynamicResources.encode(message.dynamic_resources, writer.uint32(26).fork()).join();
    }
    if (message.cluster_manager !== undefined) {
      ClusterManager.encode(message.cluster_manager, writer.uint32(34).fork()).join();
    }
    if (message.hds_config !== undefined) {
      ApiConfigSource.encode(message.hds_config, writer.uint32(114).fork()).join();
    }
    if (message.flags_path !== undefined && message.flags_path !== "") {
      writer.uint32(42).string(message.flags_path);
    }
    if (message.stats_sinks !== undefined && message.stats_sinks.length !== 0) {
      for (const v of message.stats_sinks) {
        StatsSink.encode(v!, writer.uint32(50).fork()).join();
      }
    }
    if (message.deferred_stat_options !== undefined) {
      Bootstrap_DeferredStatOptions.encode(message.deferred_stat_options, writer.uint32(314).fork()).join();
    }
    if (message.stats_config !== undefined) {
      StatsConfig.encode(message.stats_config, writer.uint32(106).fork()).join();
    }
    if (message.stats_flush_interval !== undefined) {
      Duration.encode(message.stats_flush_interval, writer.uint32(58).fork()).join();
    }
    switch (message.stats_flush?.$case) {
      case "stats_flush_on_admin":
        writer.uint32(232).bool(message.stats_flush.stats_flush_on_admin);
        break;
    }
    if (message.watchdog !== undefined) {
      Watchdog.encode(message.watchdog, writer.uint32(66).fork()).join();
    }
    if (message.watchdogs !== undefined) {
      Watchdogs.encode(message.watchdogs, writer.uint32(218).fork()).join();
    }
    if (message.tracing !== undefined) {
      Tracing.encode(message.tracing, writer.uint32(74).fork()).join();
    }
    if (message.layered_runtime !== undefined) {
      LayeredRuntime.encode(message.layered_runtime, writer.uint32(138).fork()).join();
    }
    if (message.admin !== undefined) {
      Admin.encode(message.admin, writer.uint32(98).fork()).join();
    }
    if (message.overload_manager !== undefined) {
      OverloadManager.encode(message.overload_manager, writer.uint32(122).fork()).join();
    }
    if (message.enable_dispatcher_stats !== undefined && message.enable_dispatcher_stats !== false) {
      writer.uint32(128).bool(message.enable_dispatcher_stats);
    }
    if (message.header_prefix !== undefined && message.header_prefix !== "") {
      writer.uint32(146).string(message.header_prefix);
    }
    if (message.stats_server_version_override !== undefined) {
      UInt64Value.encode(
        { $type: "google.protobuf.UInt64Value", value: message.stats_server_version_override! },
        writer.uint32(154).fork(),
      ).join();
    }
    if (message.use_tcp_for_dns_lookups !== undefined && message.use_tcp_for_dns_lookups !== false) {
      writer.uint32(160).bool(message.use_tcp_for_dns_lookups);
    }
    if (message.dns_resolution_config !== undefined) {
      DnsResolutionConfig.encode(message.dns_resolution_config, writer.uint32(242).fork()).join();
    }
    if (message.typed_dns_resolver_config !== undefined) {
      TypedExtensionConfig.encode(message.typed_dns_resolver_config, writer.uint32(250).fork()).join();
    }
    if (message.bootstrap_extensions !== undefined && message.bootstrap_extensions.length !== 0) {
      for (const v of message.bootstrap_extensions) {
        TypedExtensionConfig.encode(v!, writer.uint32(170).fork()).join();
      }
    }
    if (message.fatal_actions !== undefined && message.fatal_actions.length !== 0) {
      for (const v of message.fatal_actions) {
        FatalAction.encode(v!, writer.uint32(226).fork()).join();
      }
    }
    if (message.config_sources !== undefined && message.config_sources.length !== 0) {
      for (const v of message.config_sources) {
        ConfigSource.encode(v!, writer.uint32(178).fork()).join();
      }
    }
    if (message.default_config_source !== undefined) {
      ConfigSource.encode(message.default_config_source, writer.uint32(186).fork()).join();
    }
    if (message.default_socket_interface !== undefined && message.default_socket_interface !== "") {
      writer.uint32(194).string(message.default_socket_interface);
    }
    (message.certificate_provider_instances || new Map()).forEach((value, key) => {
      Bootstrap_CertificateProviderInstancesEntry.encode({
        $type: "envoy.config.bootstrap.v3.Bootstrap.CertificateProviderInstancesEntry",
        key: key as any,
        value,
      }, writer.uint32(202).fork()).join();
    });
    if (message.inline_headers !== undefined && message.inline_headers.length !== 0) {
      for (const v of message.inline_headers) {
        CustomInlineHeader.encode(v!, writer.uint32(258).fork()).join();
      }
    }
    if (message.perf_tracing_file_path !== undefined && message.perf_tracing_file_path !== "") {
      writer.uint32(266).string(message.perf_tracing_file_path);
    }
    if (message.default_regex_engine !== undefined) {
      TypedExtensionConfig.encode(message.default_regex_engine, writer.uint32(274).fork()).join();
    }
    if (message.xds_delegate_extension !== undefined) {
      TypedExtensionConfig.encode(message.xds_delegate_extension, writer.uint32(282).fork()).join();
    }
    if (message.xds_config_tracker_extension !== undefined) {
      TypedExtensionConfig.encode(message.xds_config_tracker_extension, writer.uint32(290).fork()).join();
    }
    if (message.listener_manager !== undefined) {
      TypedExtensionConfig.encode(message.listener_manager, writer.uint32(298).fork()).join();
    }
    if (message.application_log_config !== undefined) {
      Bootstrap_ApplicationLogConfig.encode(message.application_log_config, writer.uint32(306).fork()).join();
    }
    if (message.grpc_async_client_manager_config !== undefined) {
      Bootstrap_GrpcAsyncClientManagerConfig.encode(message.grpc_async_client_manager_config, writer.uint32(322).fork())
        .join();
    }
    if (message.memory_allocator_manager !== undefined) {
      MemoryAllocatorManager.encode(message.memory_allocator_manager, writer.uint32(330).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Bootstrap {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBootstrap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.node = Node.decode(reader, reader.uint32());
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          if (message.node_context_params === undefined) {
            message.node_context_params = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.node_context_params!.push(el);
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.static_resources = Bootstrap_StaticResources.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.dynamic_resources = Bootstrap_DynamicResources.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.cluster_manager = ClusterManager.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.hds_config = ApiConfigSource.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.flags_path = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          if (message.stats_sinks === undefined) {
            message.stats_sinks = [];
          }
          const el = StatsSink.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.stats_sinks!.push(el);
          }
          continue;
        }
        case 39: {
          if (tag !== 314) {
            break;
          }

          message.deferred_stat_options = Bootstrap_DeferredStatOptions.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.stats_config = StatsConfig.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.stats_flush_interval = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 29: {
          if (tag !== 232) {
            break;
          }

          message.stats_flush = { $case: "stats_flush_on_admin", stats_flush_on_admin: reader.bool() };
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.watchdog = Watchdog.decode(reader, reader.uint32());
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.watchdogs = Watchdogs.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.tracing = Tracing.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.layered_runtime = LayeredRuntime.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.admin = Admin.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.overload_manager = OverloadManager.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.enable_dispatcher_stats = reader.bool();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.header_prefix = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.stats_server_version_override = UInt64Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.use_tcp_for_dns_lookups = reader.bool();
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.dns_resolution_config = DnsResolutionConfig.decode(reader, reader.uint32());
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.typed_dns_resolver_config = TypedExtensionConfig.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          if (message.bootstrap_extensions === undefined) {
            message.bootstrap_extensions = [];
          }
          const el = TypedExtensionConfig.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.bootstrap_extensions!.push(el);
          }
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          if (message.fatal_actions === undefined) {
            message.fatal_actions = [];
          }
          const el = FatalAction.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.fatal_actions!.push(el);
          }
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          if (message.config_sources === undefined) {
            message.config_sources = [];
          }
          const el = ConfigSource.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.config_sources!.push(el);
          }
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.default_config_source = ConfigSource.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.default_socket_interface = reader.string();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          const entry25 = Bootstrap_CertificateProviderInstancesEntry.decode(reader, reader.uint32());
          if (entry25.value !== undefined) {
            if (message.certificate_provider_instances === undefined) {
              message.certificate_provider_instances = new Map();
            }
            message.certificate_provider_instances!.set(entry25.key, entry25.value);
          }
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          if (message.inline_headers === undefined) {
            message.inline_headers = [];
          }
          const el = CustomInlineHeader.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.inline_headers!.push(el);
          }
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }

          message.perf_tracing_file_path = reader.string();
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          message.default_regex_engine = TypedExtensionConfig.decode(reader, reader.uint32());
          continue;
        }
        case 35: {
          if (tag !== 282) {
            break;
          }

          message.xds_delegate_extension = TypedExtensionConfig.decode(reader, reader.uint32());
          continue;
        }
        case 36: {
          if (tag !== 290) {
            break;
          }

          message.xds_config_tracker_extension = TypedExtensionConfig.decode(reader, reader.uint32());
          continue;
        }
        case 37: {
          if (tag !== 298) {
            break;
          }

          message.listener_manager = TypedExtensionConfig.decode(reader, reader.uint32());
          continue;
        }
        case 38: {
          if (tag !== 306) {
            break;
          }

          message.application_log_config = Bootstrap_ApplicationLogConfig.decode(reader, reader.uint32());
          continue;
        }
        case 40: {
          if (tag !== 322) {
            break;
          }

          message.grpc_async_client_manager_config = Bootstrap_GrpcAsyncClientManagerConfig.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 41: {
          if (tag !== 330) {
            break;
          }

          message.memory_allocator_manager = MemoryAllocatorManager.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bootstrap {
    return {
      $type: Bootstrap.$type,
      node: isSet(object.node) ? Node.fromJSON(object.node) : undefined,
      node_context_params: globalThis.Array.isArray(object?.node_context_params)
        ? object.node_context_params.map((e: any) => globalThis.String(e))
        : undefined,
      static_resources: isSet(object.static_resources)
        ? Bootstrap_StaticResources.fromJSON(object.static_resources)
        : undefined,
      dynamic_resources: isSet(object.dynamic_resources)
        ? Bootstrap_DynamicResources.fromJSON(object.dynamic_resources)
        : undefined,
      cluster_manager: isSet(object.cluster_manager) ? ClusterManager.fromJSON(object.cluster_manager) : undefined,
      hds_config: isSet(object.hds_config) ? ApiConfigSource.fromJSON(object.hds_config) : undefined,
      flags_path: isSet(object.flags_path) ? globalThis.String(object.flags_path) : undefined,
      stats_sinks: globalThis.Array.isArray(object?.stats_sinks)
        ? object.stats_sinks.map((e: any) => StatsSink.fromJSON(e))
        : undefined,
      deferred_stat_options: isSet(object.deferred_stat_options)
        ? Bootstrap_DeferredStatOptions.fromJSON(object.deferred_stat_options)
        : undefined,
      stats_config: isSet(object.stats_config) ? StatsConfig.fromJSON(object.stats_config) : undefined,
      stats_flush_interval: isSet(object.stats_flush_interval)
        ? Duration.fromJSON(object.stats_flush_interval)
        : undefined,
      stats_flush: isSet(object.stats_flush_on_admin)
        ? { $case: "stats_flush_on_admin", stats_flush_on_admin: globalThis.Boolean(object.stats_flush_on_admin) }
        : undefined,
      watchdog: isSet(object.watchdog) ? Watchdog.fromJSON(object.watchdog) : undefined,
      watchdogs: isSet(object.watchdogs) ? Watchdogs.fromJSON(object.watchdogs) : undefined,
      tracing: isSet(object.tracing) ? Tracing.fromJSON(object.tracing) : undefined,
      layered_runtime: isSet(object.layered_runtime) ? LayeredRuntime.fromJSON(object.layered_runtime) : undefined,
      admin: isSet(object.admin) ? Admin.fromJSON(object.admin) : undefined,
      overload_manager: isSet(object.overload_manager) ? OverloadManager.fromJSON(object.overload_manager) : undefined,
      enable_dispatcher_stats: isSet(object.enable_dispatcher_stats)
        ? globalThis.Boolean(object.enable_dispatcher_stats)
        : undefined,
      header_prefix: isSet(object.header_prefix) ? globalThis.String(object.header_prefix) : undefined,
      stats_server_version_override: isSet(object.stats_server_version_override)
        ? Number(object.stats_server_version_override)
        : undefined,
      use_tcp_for_dns_lookups: isSet(object.use_tcp_for_dns_lookups)
        ? globalThis.Boolean(object.use_tcp_for_dns_lookups)
        : undefined,
      dns_resolution_config: isSet(object.dns_resolution_config)
        ? DnsResolutionConfig.fromJSON(object.dns_resolution_config)
        : undefined,
      typed_dns_resolver_config: isSet(object.typed_dns_resolver_config)
        ? TypedExtensionConfig.fromJSON(object.typed_dns_resolver_config)
        : undefined,
      bootstrap_extensions: globalThis.Array.isArray(object?.bootstrap_extensions)
        ? object.bootstrap_extensions.map((e: any) => TypedExtensionConfig.fromJSON(e))
        : undefined,
      fatal_actions: globalThis.Array.isArray(object?.fatal_actions)
        ? object.fatal_actions.map((e: any) => FatalAction.fromJSON(e))
        : undefined,
      config_sources: globalThis.Array.isArray(object?.config_sources)
        ? object.config_sources.map((e: any) => ConfigSource.fromJSON(e))
        : undefined,
      default_config_source: isSet(object.default_config_source)
        ? ConfigSource.fromJSON(object.default_config_source)
        : undefined,
      default_socket_interface: isSet(object.default_socket_interface)
        ? globalThis.String(object.default_socket_interface)
        : undefined,
      certificate_provider_instances: isObject(object.certificate_provider_instances)
        ? Object.entries(object.certificate_provider_instances).reduce<Map<string, TypedExtensionConfig>>(
          (acc, [key, value]) => {
            acc.set(key, TypedExtensionConfig.fromJSON(value));
            return acc;
          },
          new Map(),
        )
        : undefined,
      inline_headers: globalThis.Array.isArray(object?.inline_headers)
        ? object.inline_headers.map((e: any) => CustomInlineHeader.fromJSON(e))
        : undefined,
      perf_tracing_file_path: isSet(object.perf_tracing_file_path)
        ? globalThis.String(object.perf_tracing_file_path)
        : undefined,
      default_regex_engine: isSet(object.default_regex_engine)
        ? TypedExtensionConfig.fromJSON(object.default_regex_engine)
        : undefined,
      xds_delegate_extension: isSet(object.xds_delegate_extension)
        ? TypedExtensionConfig.fromJSON(object.xds_delegate_extension)
        : undefined,
      xds_config_tracker_extension: isSet(object.xds_config_tracker_extension)
        ? TypedExtensionConfig.fromJSON(object.xds_config_tracker_extension)
        : undefined,
      listener_manager: isSet(object.listener_manager)
        ? TypedExtensionConfig.fromJSON(object.listener_manager)
        : undefined,
      application_log_config: isSet(object.application_log_config)
        ? Bootstrap_ApplicationLogConfig.fromJSON(object.application_log_config)
        : undefined,
      grpc_async_client_manager_config: isSet(object.grpc_async_client_manager_config)
        ? Bootstrap_GrpcAsyncClientManagerConfig.fromJSON(object.grpc_async_client_manager_config)
        : undefined,
      memory_allocator_manager: isSet(object.memory_allocator_manager)
        ? MemoryAllocatorManager.fromJSON(object.memory_allocator_manager)
        : undefined,
    };
  },

  toJSON(message: Bootstrap): unknown {
    const obj: any = {};
    if (message.node !== undefined) {
      obj.node = Node.toJSON(message.node);
    }
    if (message.node_context_params?.length) {
      obj.node_context_params = message.node_context_params;
    }
    if (message.static_resources !== undefined) {
      obj.static_resources = Bootstrap_StaticResources.toJSON(message.static_resources);
    }
    if (message.dynamic_resources !== undefined) {
      obj.dynamic_resources = Bootstrap_DynamicResources.toJSON(message.dynamic_resources);
    }
    if (message.cluster_manager !== undefined) {
      obj.cluster_manager = ClusterManager.toJSON(message.cluster_manager);
    }
    if (message.hds_config !== undefined) {
      obj.hds_config = ApiConfigSource.toJSON(message.hds_config);
    }
    if (message.flags_path !== undefined) {
      obj.flags_path = message.flags_path;
    }
    if (message.stats_sinks?.length) {
      obj.stats_sinks = message.stats_sinks.map((e) => StatsSink.toJSON(e));
    }
    if (message.deferred_stat_options !== undefined) {
      obj.deferred_stat_options = Bootstrap_DeferredStatOptions.toJSON(message.deferred_stat_options);
    }
    if (message.stats_config !== undefined) {
      obj.stats_config = StatsConfig.toJSON(message.stats_config);
    }
    if (message.stats_flush_interval !== undefined) {
      obj.stats_flush_interval = Duration.toJSON(message.stats_flush_interval);
    }
    if (message.stats_flush?.$case === "stats_flush_on_admin") {
      obj.stats_flush_on_admin = message.stats_flush.stats_flush_on_admin;
    }
    if (message.watchdog !== undefined) {
      obj.watchdog = Watchdog.toJSON(message.watchdog);
    }
    if (message.watchdogs !== undefined) {
      obj.watchdogs = Watchdogs.toJSON(message.watchdogs);
    }
    if (message.tracing !== undefined) {
      obj.tracing = Tracing.toJSON(message.tracing);
    }
    if (message.layered_runtime !== undefined) {
      obj.layered_runtime = LayeredRuntime.toJSON(message.layered_runtime);
    }
    if (message.admin !== undefined) {
      obj.admin = Admin.toJSON(message.admin);
    }
    if (message.overload_manager !== undefined) {
      obj.overload_manager = OverloadManager.toJSON(message.overload_manager);
    }
    if (message.enable_dispatcher_stats !== undefined) {
      obj.enable_dispatcher_stats = message.enable_dispatcher_stats;
    }
    if (message.header_prefix !== undefined) {
      obj.header_prefix = message.header_prefix;
    }
    if (message.stats_server_version_override !== undefined) {
      obj.stats_server_version_override = message.stats_server_version_override;
    }
    if (message.use_tcp_for_dns_lookups !== undefined) {
      obj.use_tcp_for_dns_lookups = message.use_tcp_for_dns_lookups;
    }
    if (message.dns_resolution_config !== undefined) {
      obj.dns_resolution_config = DnsResolutionConfig.toJSON(message.dns_resolution_config);
    }
    if (message.typed_dns_resolver_config !== undefined) {
      obj.typed_dns_resolver_config = TypedExtensionConfig.toJSON(message.typed_dns_resolver_config);
    }
    if (message.bootstrap_extensions?.length) {
      obj.bootstrap_extensions = message.bootstrap_extensions.map((e) => TypedExtensionConfig.toJSON(e));
    }
    if (message.fatal_actions?.length) {
      obj.fatal_actions = message.fatal_actions.map((e) => FatalAction.toJSON(e));
    }
    if (message.config_sources?.length) {
      obj.config_sources = message.config_sources.map((e) => ConfigSource.toJSON(e));
    }
    if (message.default_config_source !== undefined) {
      obj.default_config_source = ConfigSource.toJSON(message.default_config_source);
    }
    if (message.default_socket_interface !== undefined) {
      obj.default_socket_interface = message.default_socket_interface;
    }
    if (message.certificate_provider_instances?.size) {
      obj.certificate_provider_instances = {};
      message.certificate_provider_instances.forEach((v, k) => {
        obj.certificate_provider_instances[k] = TypedExtensionConfig.toJSON(v);
      });
    }
    if (message.inline_headers?.length) {
      obj.inline_headers = message.inline_headers.map((e) => CustomInlineHeader.toJSON(e));
    }
    if (message.perf_tracing_file_path !== undefined) {
      obj.perf_tracing_file_path = message.perf_tracing_file_path;
    }
    if (message.default_regex_engine !== undefined) {
      obj.default_regex_engine = TypedExtensionConfig.toJSON(message.default_regex_engine);
    }
    if (message.xds_delegate_extension !== undefined) {
      obj.xds_delegate_extension = TypedExtensionConfig.toJSON(message.xds_delegate_extension);
    }
    if (message.xds_config_tracker_extension !== undefined) {
      obj.xds_config_tracker_extension = TypedExtensionConfig.toJSON(message.xds_config_tracker_extension);
    }
    if (message.listener_manager !== undefined) {
      obj.listener_manager = TypedExtensionConfig.toJSON(message.listener_manager);
    }
    if (message.application_log_config !== undefined) {
      obj.application_log_config = Bootstrap_ApplicationLogConfig.toJSON(message.application_log_config);
    }
    if (message.grpc_async_client_manager_config !== undefined) {
      obj.grpc_async_client_manager_config = Bootstrap_GrpcAsyncClientManagerConfig.toJSON(
        message.grpc_async_client_manager_config,
      );
    }
    if (message.memory_allocator_manager !== undefined) {
      obj.memory_allocator_manager = MemoryAllocatorManager.toJSON(message.memory_allocator_manager);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Bootstrap>, I>>(base?: I): Bootstrap {
    return Bootstrap.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Bootstrap>, I>>(object: I): Bootstrap {
    const message = createBaseBootstrap();
    message.node = (object.node !== undefined && object.node !== null) ? Node.fromPartial(object.node) : undefined;
    message.node_context_params = object.node_context_params?.map((e) => e) || undefined;
    message.static_resources = (object.static_resources !== undefined && object.static_resources !== null)
      ? Bootstrap_StaticResources.fromPartial(object.static_resources)
      : undefined;
    message.dynamic_resources = (object.dynamic_resources !== undefined && object.dynamic_resources !== null)
      ? Bootstrap_DynamicResources.fromPartial(object.dynamic_resources)
      : undefined;
    message.cluster_manager = (object.cluster_manager !== undefined && object.cluster_manager !== null)
      ? ClusterManager.fromPartial(object.cluster_manager)
      : undefined;
    message.hds_config = (object.hds_config !== undefined && object.hds_config !== null)
      ? ApiConfigSource.fromPartial(object.hds_config)
      : undefined;
    message.flags_path = object.flags_path ?? undefined;
    message.stats_sinks = object.stats_sinks?.map((e) => StatsSink.fromPartial(e)) || undefined;
    message.deferred_stat_options =
      (object.deferred_stat_options !== undefined && object.deferred_stat_options !== null)
        ? Bootstrap_DeferredStatOptions.fromPartial(object.deferred_stat_options)
        : undefined;
    message.stats_config = (object.stats_config !== undefined && object.stats_config !== null)
      ? StatsConfig.fromPartial(object.stats_config)
      : undefined;
    message.stats_flush_interval = (object.stats_flush_interval !== undefined && object.stats_flush_interval !== null)
      ? Duration.fromPartial(object.stats_flush_interval)
      : undefined;
    if (
      object.stats_flush?.$case === "stats_flush_on_admin" &&
      object.stats_flush?.stats_flush_on_admin !== undefined &&
      object.stats_flush?.stats_flush_on_admin !== null
    ) {
      message.stats_flush = {
        $case: "stats_flush_on_admin",
        stats_flush_on_admin: object.stats_flush.stats_flush_on_admin,
      };
    }
    message.watchdog = (object.watchdog !== undefined && object.watchdog !== null)
      ? Watchdog.fromPartial(object.watchdog)
      : undefined;
    message.watchdogs = (object.watchdogs !== undefined && object.watchdogs !== null)
      ? Watchdogs.fromPartial(object.watchdogs)
      : undefined;
    message.tracing = (object.tracing !== undefined && object.tracing !== null)
      ? Tracing.fromPartial(object.tracing)
      : undefined;
    message.layered_runtime = (object.layered_runtime !== undefined && object.layered_runtime !== null)
      ? LayeredRuntime.fromPartial(object.layered_runtime)
      : undefined;
    message.admin = (object.admin !== undefined && object.admin !== null) ? Admin.fromPartial(object.admin) : undefined;
    message.overload_manager = (object.overload_manager !== undefined && object.overload_manager !== null)
      ? OverloadManager.fromPartial(object.overload_manager)
      : undefined;
    message.enable_dispatcher_stats = object.enable_dispatcher_stats ?? undefined;
    message.header_prefix = object.header_prefix ?? undefined;
    message.stats_server_version_override = object.stats_server_version_override ?? undefined;
    message.use_tcp_for_dns_lookups = object.use_tcp_for_dns_lookups ?? undefined;
    message.dns_resolution_config =
      (object.dns_resolution_config !== undefined && object.dns_resolution_config !== null)
        ? DnsResolutionConfig.fromPartial(object.dns_resolution_config)
        : undefined;
    message.typed_dns_resolver_config =
      (object.typed_dns_resolver_config !== undefined && object.typed_dns_resolver_config !== null)
        ? TypedExtensionConfig.fromPartial(object.typed_dns_resolver_config)
        : undefined;
    message.bootstrap_extensions = object.bootstrap_extensions?.map((e) => TypedExtensionConfig.fromPartial(e)) ||
      undefined;
    message.fatal_actions = object.fatal_actions?.map((e) => FatalAction.fromPartial(e)) || undefined;
    message.config_sources = object.config_sources?.map((e) => ConfigSource.fromPartial(e)) || undefined;
    message.default_config_source =
      (object.default_config_source !== undefined && object.default_config_source !== null)
        ? ConfigSource.fromPartial(object.default_config_source)
        : undefined;
    message.default_socket_interface = object.default_socket_interface ?? undefined;
    message.certificate_provider_instances =
      (object.certificate_provider_instances === undefined || object.certificate_provider_instances === null)
        ? undefined
        : (() => {
          const m = new Map();
          (object.certificate_provider_instances as Map<string, TypedExtensionConfig> ?? new Map()).forEach(
            (value, key) => {
              if (value !== undefined) {
                m.set(key, TypedExtensionConfig.fromPartial(value));
              }
            },
          );
          return m;
        })();
    message.inline_headers = object.inline_headers?.map((e) => CustomInlineHeader.fromPartial(e)) || undefined;
    message.perf_tracing_file_path = object.perf_tracing_file_path ?? undefined;
    message.default_regex_engine = (object.default_regex_engine !== undefined && object.default_regex_engine !== null)
      ? TypedExtensionConfig.fromPartial(object.default_regex_engine)
      : undefined;
    message.xds_delegate_extension =
      (object.xds_delegate_extension !== undefined && object.xds_delegate_extension !== null)
        ? TypedExtensionConfig.fromPartial(object.xds_delegate_extension)
        : undefined;
    message.xds_config_tracker_extension =
      (object.xds_config_tracker_extension !== undefined && object.xds_config_tracker_extension !== null)
        ? TypedExtensionConfig.fromPartial(object.xds_config_tracker_extension)
        : undefined;
    message.listener_manager = (object.listener_manager !== undefined && object.listener_manager !== null)
      ? TypedExtensionConfig.fromPartial(object.listener_manager)
      : undefined;
    message.application_log_config =
      (object.application_log_config !== undefined && object.application_log_config !== null)
        ? Bootstrap_ApplicationLogConfig.fromPartial(object.application_log_config)
        : undefined;
    message.grpc_async_client_manager_config =
      (object.grpc_async_client_manager_config !== undefined && object.grpc_async_client_manager_config !== null)
        ? Bootstrap_GrpcAsyncClientManagerConfig.fromPartial(object.grpc_async_client_manager_config)
        : undefined;
    message.memory_allocator_manager =
      (object.memory_allocator_manager !== undefined && object.memory_allocator_manager !== null)
        ? MemoryAllocatorManager.fromPartial(object.memory_allocator_manager)
        : undefined;
    return message;
  },
};

messageTypeRegistry.set(Bootstrap.$type, Bootstrap);

function createBaseBootstrap_StaticResources(): Bootstrap_StaticResources {
  return { $type: "envoy.config.bootstrap.v3.Bootstrap.StaticResources" };
}

export const Bootstrap_StaticResources: MessageFns<
  Bootstrap_StaticResources,
  "envoy.config.bootstrap.v3.Bootstrap.StaticResources"
> = {
  $type: "envoy.config.bootstrap.v3.Bootstrap.StaticResources" as const,

  encode(message: Bootstrap_StaticResources, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.listeners !== undefined && message.listeners.length !== 0) {
      for (const v of message.listeners) {
        Listener.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    if (message.clusters !== undefined && message.clusters.length !== 0) {
      for (const v of message.clusters) {
        Cluster.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.secrets !== undefined && message.secrets.length !== 0) {
      for (const v of message.secrets) {
        Secret.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Bootstrap_StaticResources {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBootstrap_StaticResources();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.listeners === undefined) {
            message.listeners = [];
          }
          const el = Listener.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.listeners!.push(el);
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.clusters === undefined) {
            message.clusters = [];
          }
          const el = Cluster.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.clusters!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.secrets === undefined) {
            message.secrets = [];
          }
          const el = Secret.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.secrets!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bootstrap_StaticResources {
    return {
      $type: Bootstrap_StaticResources.$type,
      listeners: globalThis.Array.isArray(object?.listeners)
        ? object.listeners.map((e: any) => Listener.fromJSON(e))
        : undefined,
      clusters: globalThis.Array.isArray(object?.clusters)
        ? object.clusters.map((e: any) => Cluster.fromJSON(e))
        : undefined,
      secrets: globalThis.Array.isArray(object?.secrets)
        ? object.secrets.map((e: any) => Secret.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: Bootstrap_StaticResources): unknown {
    const obj: any = {};
    if (message.listeners?.length) {
      obj.listeners = message.listeners.map((e) => Listener.toJSON(e));
    }
    if (message.clusters?.length) {
      obj.clusters = message.clusters.map((e) => Cluster.toJSON(e));
    }
    if (message.secrets?.length) {
      obj.secrets = message.secrets.map((e) => Secret.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Bootstrap_StaticResources>, I>>(base?: I): Bootstrap_StaticResources {
    return Bootstrap_StaticResources.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Bootstrap_StaticResources>, I>>(object: I): Bootstrap_StaticResources {
    const message = createBaseBootstrap_StaticResources();
    message.listeners = object.listeners?.map((e) => Listener.fromPartial(e)) || undefined;
    message.clusters = object.clusters?.map((e) => Cluster.fromPartial(e)) || undefined;
    message.secrets = object.secrets?.map((e) => Secret.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(Bootstrap_StaticResources.$type, Bootstrap_StaticResources);

function createBaseBootstrap_DynamicResources(): Bootstrap_DynamicResources {
  return { $type: "envoy.config.bootstrap.v3.Bootstrap.DynamicResources" };
}

export const Bootstrap_DynamicResources: MessageFns<
  Bootstrap_DynamicResources,
  "envoy.config.bootstrap.v3.Bootstrap.DynamicResources"
> = {
  $type: "envoy.config.bootstrap.v3.Bootstrap.DynamicResources" as const,

  encode(message: Bootstrap_DynamicResources, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lds_config !== undefined) {
      ConfigSource.encode(message.lds_config, writer.uint32(10).fork()).join();
    }
    if (message.lds_resources_locator !== undefined && message.lds_resources_locator !== "") {
      writer.uint32(42).string(message.lds_resources_locator);
    }
    if (message.cds_config !== undefined) {
      ConfigSource.encode(message.cds_config, writer.uint32(18).fork()).join();
    }
    if (message.cds_resources_locator !== undefined && message.cds_resources_locator !== "") {
      writer.uint32(50).string(message.cds_resources_locator);
    }
    if (message.ads_config !== undefined) {
      ApiConfigSource.encode(message.ads_config, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Bootstrap_DynamicResources {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBootstrap_DynamicResources();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.lds_config = ConfigSource.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.lds_resources_locator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cds_config = ConfigSource.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.cds_resources_locator = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ads_config = ApiConfigSource.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bootstrap_DynamicResources {
    return {
      $type: Bootstrap_DynamicResources.$type,
      lds_config: isSet(object.lds_config) ? ConfigSource.fromJSON(object.lds_config) : undefined,
      lds_resources_locator: isSet(object.lds_resources_locator)
        ? globalThis.String(object.lds_resources_locator)
        : undefined,
      cds_config: isSet(object.cds_config) ? ConfigSource.fromJSON(object.cds_config) : undefined,
      cds_resources_locator: isSet(object.cds_resources_locator)
        ? globalThis.String(object.cds_resources_locator)
        : undefined,
      ads_config: isSet(object.ads_config) ? ApiConfigSource.fromJSON(object.ads_config) : undefined,
    };
  },

  toJSON(message: Bootstrap_DynamicResources): unknown {
    const obj: any = {};
    if (message.lds_config !== undefined) {
      obj.lds_config = ConfigSource.toJSON(message.lds_config);
    }
    if (message.lds_resources_locator !== undefined) {
      obj.lds_resources_locator = message.lds_resources_locator;
    }
    if (message.cds_config !== undefined) {
      obj.cds_config = ConfigSource.toJSON(message.cds_config);
    }
    if (message.cds_resources_locator !== undefined) {
      obj.cds_resources_locator = message.cds_resources_locator;
    }
    if (message.ads_config !== undefined) {
      obj.ads_config = ApiConfigSource.toJSON(message.ads_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Bootstrap_DynamicResources>, I>>(base?: I): Bootstrap_DynamicResources {
    return Bootstrap_DynamicResources.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Bootstrap_DynamicResources>, I>>(object: I): Bootstrap_DynamicResources {
    const message = createBaseBootstrap_DynamicResources();
    message.lds_config = (object.lds_config !== undefined && object.lds_config !== null)
      ? ConfigSource.fromPartial(object.lds_config)
      : undefined;
    message.lds_resources_locator = object.lds_resources_locator ?? undefined;
    message.cds_config = (object.cds_config !== undefined && object.cds_config !== null)
      ? ConfigSource.fromPartial(object.cds_config)
      : undefined;
    message.cds_resources_locator = object.cds_resources_locator ?? undefined;
    message.ads_config = (object.ads_config !== undefined && object.ads_config !== null)
      ? ApiConfigSource.fromPartial(object.ads_config)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Bootstrap_DynamicResources.$type, Bootstrap_DynamicResources);

function createBaseBootstrap_ApplicationLogConfig(): Bootstrap_ApplicationLogConfig {
  return { $type: "envoy.config.bootstrap.v3.Bootstrap.ApplicationLogConfig" };
}

export const Bootstrap_ApplicationLogConfig: MessageFns<
  Bootstrap_ApplicationLogConfig,
  "envoy.config.bootstrap.v3.Bootstrap.ApplicationLogConfig"
> = {
  $type: "envoy.config.bootstrap.v3.Bootstrap.ApplicationLogConfig" as const,

  encode(message: Bootstrap_ApplicationLogConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.log_format !== undefined) {
      Bootstrap_ApplicationLogConfig_LogFormat.encode(message.log_format, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Bootstrap_ApplicationLogConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBootstrap_ApplicationLogConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.log_format = Bootstrap_ApplicationLogConfig_LogFormat.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bootstrap_ApplicationLogConfig {
    return {
      $type: Bootstrap_ApplicationLogConfig.$type,
      log_format: isSet(object.log_format)
        ? Bootstrap_ApplicationLogConfig_LogFormat.fromJSON(object.log_format)
        : undefined,
    };
  },

  toJSON(message: Bootstrap_ApplicationLogConfig): unknown {
    const obj: any = {};
    if (message.log_format !== undefined) {
      obj.log_format = Bootstrap_ApplicationLogConfig_LogFormat.toJSON(message.log_format);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Bootstrap_ApplicationLogConfig>, I>>(base?: I): Bootstrap_ApplicationLogConfig {
    return Bootstrap_ApplicationLogConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Bootstrap_ApplicationLogConfig>, I>>(
    object: I,
  ): Bootstrap_ApplicationLogConfig {
    const message = createBaseBootstrap_ApplicationLogConfig();
    message.log_format = (object.log_format !== undefined && object.log_format !== null)
      ? Bootstrap_ApplicationLogConfig_LogFormat.fromPartial(object.log_format)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Bootstrap_ApplicationLogConfig.$type, Bootstrap_ApplicationLogConfig);

function createBaseBootstrap_ApplicationLogConfig_LogFormat(): Bootstrap_ApplicationLogConfig_LogFormat {
  return { $type: "envoy.config.bootstrap.v3.Bootstrap.ApplicationLogConfig.LogFormat", log_format: undefined };
}

export const Bootstrap_ApplicationLogConfig_LogFormat: MessageFns<
  Bootstrap_ApplicationLogConfig_LogFormat,
  "envoy.config.bootstrap.v3.Bootstrap.ApplicationLogConfig.LogFormat"
> = {
  $type: "envoy.config.bootstrap.v3.Bootstrap.ApplicationLogConfig.LogFormat" as const,

  encode(message: Bootstrap_ApplicationLogConfig_LogFormat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.log_format?.$case) {
      case "json_format":
        Struct.encode(Struct.wrap(message.log_format.json_format), writer.uint32(10).fork()).join();
        break;
      case "text_format":
        writer.uint32(18).string(message.log_format.text_format);
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Bootstrap_ApplicationLogConfig_LogFormat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBootstrap_ApplicationLogConfig_LogFormat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.log_format = {
            $case: "json_format",
            json_format: Struct.unwrap(Struct.decode(reader, reader.uint32())),
          };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.log_format = { $case: "text_format", text_format: reader.string() };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bootstrap_ApplicationLogConfig_LogFormat {
    return {
      $type: Bootstrap_ApplicationLogConfig_LogFormat.$type,
      log_format: isSet(object.json_format)
        ? { $case: "json_format", json_format: object.json_format }
        : isSet(object.text_format)
        ? { $case: "text_format", text_format: globalThis.String(object.text_format) }
        : undefined,
    };
  },

  toJSON(message: Bootstrap_ApplicationLogConfig_LogFormat): unknown {
    const obj: any = {};
    if (message.log_format?.$case === "json_format") {
      obj.json_format = message.log_format.json_format;
    }
    if (message.log_format?.$case === "text_format") {
      obj.text_format = message.log_format.text_format;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Bootstrap_ApplicationLogConfig_LogFormat>, I>>(
    base?: I,
  ): Bootstrap_ApplicationLogConfig_LogFormat {
    return Bootstrap_ApplicationLogConfig_LogFormat.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Bootstrap_ApplicationLogConfig_LogFormat>, I>>(
    object: I,
  ): Bootstrap_ApplicationLogConfig_LogFormat {
    const message = createBaseBootstrap_ApplicationLogConfig_LogFormat();
    if (
      object.log_format?.$case === "json_format" &&
      object.log_format?.json_format !== undefined &&
      object.log_format?.json_format !== null
    ) {
      message.log_format = { $case: "json_format", json_format: object.log_format.json_format };
    }
    if (
      object.log_format?.$case === "text_format" &&
      object.log_format?.text_format !== undefined &&
      object.log_format?.text_format !== null
    ) {
      message.log_format = { $case: "text_format", text_format: object.log_format.text_format };
    }
    return message;
  },
};

messageTypeRegistry.set(Bootstrap_ApplicationLogConfig_LogFormat.$type, Bootstrap_ApplicationLogConfig_LogFormat);

function createBaseBootstrap_DeferredStatOptions(): Bootstrap_DeferredStatOptions {
  return { $type: "envoy.config.bootstrap.v3.Bootstrap.DeferredStatOptions" };
}

export const Bootstrap_DeferredStatOptions: MessageFns<
  Bootstrap_DeferredStatOptions,
  "envoy.config.bootstrap.v3.Bootstrap.DeferredStatOptions"
> = {
  $type: "envoy.config.bootstrap.v3.Bootstrap.DeferredStatOptions" as const,

  encode(message: Bootstrap_DeferredStatOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enable_deferred_creation_stats !== undefined && message.enable_deferred_creation_stats !== false) {
      writer.uint32(8).bool(message.enable_deferred_creation_stats);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Bootstrap_DeferredStatOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBootstrap_DeferredStatOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.enable_deferred_creation_stats = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bootstrap_DeferredStatOptions {
    return {
      $type: Bootstrap_DeferredStatOptions.$type,
      enable_deferred_creation_stats: isSet(object.enable_deferred_creation_stats)
        ? globalThis.Boolean(object.enable_deferred_creation_stats)
        : undefined,
    };
  },

  toJSON(message: Bootstrap_DeferredStatOptions): unknown {
    const obj: any = {};
    if (message.enable_deferred_creation_stats !== undefined) {
      obj.enable_deferred_creation_stats = message.enable_deferred_creation_stats;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Bootstrap_DeferredStatOptions>, I>>(base?: I): Bootstrap_DeferredStatOptions {
    return Bootstrap_DeferredStatOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Bootstrap_DeferredStatOptions>, I>>(
    object: I,
  ): Bootstrap_DeferredStatOptions {
    const message = createBaseBootstrap_DeferredStatOptions();
    message.enable_deferred_creation_stats = object.enable_deferred_creation_stats ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Bootstrap_DeferredStatOptions.$type, Bootstrap_DeferredStatOptions);

function createBaseBootstrap_GrpcAsyncClientManagerConfig(): Bootstrap_GrpcAsyncClientManagerConfig {
  return { $type: "envoy.config.bootstrap.v3.Bootstrap.GrpcAsyncClientManagerConfig" };
}

export const Bootstrap_GrpcAsyncClientManagerConfig: MessageFns<
  Bootstrap_GrpcAsyncClientManagerConfig,
  "envoy.config.bootstrap.v3.Bootstrap.GrpcAsyncClientManagerConfig"
> = {
  $type: "envoy.config.bootstrap.v3.Bootstrap.GrpcAsyncClientManagerConfig" as const,

  encode(message: Bootstrap_GrpcAsyncClientManagerConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.max_cached_entry_idle_duration !== undefined) {
      Duration.encode(message.max_cached_entry_idle_duration, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Bootstrap_GrpcAsyncClientManagerConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBootstrap_GrpcAsyncClientManagerConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.max_cached_entry_idle_duration = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bootstrap_GrpcAsyncClientManagerConfig {
    return {
      $type: Bootstrap_GrpcAsyncClientManagerConfig.$type,
      max_cached_entry_idle_duration: isSet(object.max_cached_entry_idle_duration)
        ? Duration.fromJSON(object.max_cached_entry_idle_duration)
        : undefined,
    };
  },

  toJSON(message: Bootstrap_GrpcAsyncClientManagerConfig): unknown {
    const obj: any = {};
    if (message.max_cached_entry_idle_duration !== undefined) {
      obj.max_cached_entry_idle_duration = Duration.toJSON(message.max_cached_entry_idle_duration);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Bootstrap_GrpcAsyncClientManagerConfig>, I>>(
    base?: I,
  ): Bootstrap_GrpcAsyncClientManagerConfig {
    return Bootstrap_GrpcAsyncClientManagerConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Bootstrap_GrpcAsyncClientManagerConfig>, I>>(
    object: I,
  ): Bootstrap_GrpcAsyncClientManagerConfig {
    const message = createBaseBootstrap_GrpcAsyncClientManagerConfig();
    message.max_cached_entry_idle_duration =
      (object.max_cached_entry_idle_duration !== undefined && object.max_cached_entry_idle_duration !== null)
        ? Duration.fromPartial(object.max_cached_entry_idle_duration)
        : undefined;
    return message;
  },
};

messageTypeRegistry.set(Bootstrap_GrpcAsyncClientManagerConfig.$type, Bootstrap_GrpcAsyncClientManagerConfig);

function createBaseBootstrap_CertificateProviderInstancesEntry(): Bootstrap_CertificateProviderInstancesEntry {
  return { $type: "envoy.config.bootstrap.v3.Bootstrap.CertificateProviderInstancesEntry", key: "" };
}

export const Bootstrap_CertificateProviderInstancesEntry: MessageFns<
  Bootstrap_CertificateProviderInstancesEntry,
  "envoy.config.bootstrap.v3.Bootstrap.CertificateProviderInstancesEntry"
> = {
  $type: "envoy.config.bootstrap.v3.Bootstrap.CertificateProviderInstancesEntry" as const,

  encode(
    message: Bootstrap_CertificateProviderInstancesEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      TypedExtensionConfig.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Bootstrap_CertificateProviderInstancesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBootstrap_CertificateProviderInstancesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = TypedExtensionConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bootstrap_CertificateProviderInstancesEntry {
    return {
      $type: Bootstrap_CertificateProviderInstancesEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? TypedExtensionConfig.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Bootstrap_CertificateProviderInstancesEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = TypedExtensionConfig.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Bootstrap_CertificateProviderInstancesEntry>, I>>(
    base?: I,
  ): Bootstrap_CertificateProviderInstancesEntry {
    return Bootstrap_CertificateProviderInstancesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Bootstrap_CertificateProviderInstancesEntry>, I>>(
    object: I,
  ): Bootstrap_CertificateProviderInstancesEntry {
    const message = createBaseBootstrap_CertificateProviderInstancesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? TypedExtensionConfig.fromPartial(object.value)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Bootstrap_CertificateProviderInstancesEntry.$type, Bootstrap_CertificateProviderInstancesEntry);

function createBaseAdmin(): Admin {
  return { $type: "envoy.config.bootstrap.v3.Admin" };
}

export const Admin: MessageFns<Admin, "envoy.config.bootstrap.v3.Admin"> = {
  $type: "envoy.config.bootstrap.v3.Admin" as const,

  encode(message: Admin, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.access_log !== undefined && message.access_log.length !== 0) {
      for (const v of message.access_log) {
        AccessLog.encode(v!, writer.uint32(42).fork()).join();
      }
    }
    if (message.access_log_path !== undefined && message.access_log_path !== "") {
      writer.uint32(10).string(message.access_log_path);
    }
    if (message.profile_path !== undefined && message.profile_path !== "") {
      writer.uint32(18).string(message.profile_path);
    }
    if (message.address !== undefined) {
      Address.encode(message.address, writer.uint32(26).fork()).join();
    }
    if (message.socket_options !== undefined && message.socket_options.length !== 0) {
      for (const v of message.socket_options) {
        SocketOption.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    if (message.ignore_global_conn_limit !== undefined && message.ignore_global_conn_limit !== false) {
      writer.uint32(48).bool(message.ignore_global_conn_limit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Admin {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdmin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5: {
          if (tag !== 42) {
            break;
          }

          if (message.access_log === undefined) {
            message.access_log = [];
          }
          const el = AccessLog.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.access_log!.push(el);
          }
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.access_log_path = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.profile_path = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.address = Address.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          if (message.socket_options === undefined) {
            message.socket_options = [];
          }
          const el = SocketOption.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.socket_options!.push(el);
          }
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.ignore_global_conn_limit = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Admin {
    return {
      $type: Admin.$type,
      access_log: globalThis.Array.isArray(object?.access_log)
        ? object.access_log.map((e: any) => AccessLog.fromJSON(e))
        : undefined,
      access_log_path: isSet(object.access_log_path) ? globalThis.String(object.access_log_path) : undefined,
      profile_path: isSet(object.profile_path) ? globalThis.String(object.profile_path) : undefined,
      address: isSet(object.address) ? Address.fromJSON(object.address) : undefined,
      socket_options: globalThis.Array.isArray(object?.socket_options)
        ? object.socket_options.map((e: any) => SocketOption.fromJSON(e))
        : undefined,
      ignore_global_conn_limit: isSet(object.ignore_global_conn_limit)
        ? globalThis.Boolean(object.ignore_global_conn_limit)
        : undefined,
    };
  },

  toJSON(message: Admin): unknown {
    const obj: any = {};
    if (message.access_log?.length) {
      obj.access_log = message.access_log.map((e) => AccessLog.toJSON(e));
    }
    if (message.access_log_path !== undefined) {
      obj.access_log_path = message.access_log_path;
    }
    if (message.profile_path !== undefined) {
      obj.profile_path = message.profile_path;
    }
    if (message.address !== undefined) {
      obj.address = Address.toJSON(message.address);
    }
    if (message.socket_options?.length) {
      obj.socket_options = message.socket_options.map((e) => SocketOption.toJSON(e));
    }
    if (message.ignore_global_conn_limit !== undefined) {
      obj.ignore_global_conn_limit = message.ignore_global_conn_limit;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Admin>, I>>(base?: I): Admin {
    return Admin.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Admin>, I>>(object: I): Admin {
    const message = createBaseAdmin();
    message.access_log = object.access_log?.map((e) => AccessLog.fromPartial(e)) || undefined;
    message.access_log_path = object.access_log_path ?? undefined;
    message.profile_path = object.profile_path ?? undefined;
    message.address = (object.address !== undefined && object.address !== null)
      ? Address.fromPartial(object.address)
      : undefined;
    message.socket_options = object.socket_options?.map((e) => SocketOption.fromPartial(e)) || undefined;
    message.ignore_global_conn_limit = object.ignore_global_conn_limit ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Admin.$type, Admin);

function createBaseClusterManager(): ClusterManager {
  return { $type: "envoy.config.bootstrap.v3.ClusterManager" };
}

export const ClusterManager: MessageFns<ClusterManager, "envoy.config.bootstrap.v3.ClusterManager"> = {
  $type: "envoy.config.bootstrap.v3.ClusterManager" as const,

  encode(message: ClusterManager, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.local_cluster_name !== undefined && message.local_cluster_name !== "") {
      writer.uint32(10).string(message.local_cluster_name);
    }
    if (message.outlier_detection !== undefined) {
      ClusterManager_OutlierDetection.encode(message.outlier_detection, writer.uint32(18).fork()).join();
    }
    if (message.upstream_bind_config !== undefined) {
      BindConfig.encode(message.upstream_bind_config, writer.uint32(26).fork()).join();
    }
    if (message.load_stats_config !== undefined) {
      ApiConfigSource.encode(message.load_stats_config, writer.uint32(34).fork()).join();
    }
    if (message.enable_deferred_cluster_creation !== undefined && message.enable_deferred_cluster_creation !== false) {
      writer.uint32(40).bool(message.enable_deferred_cluster_creation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClusterManager {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClusterManager();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.local_cluster_name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.outlier_detection = ClusterManager_OutlierDetection.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.upstream_bind_config = BindConfig.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.load_stats_config = ApiConfigSource.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.enable_deferred_cluster_creation = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClusterManager {
    return {
      $type: ClusterManager.$type,
      local_cluster_name: isSet(object.local_cluster_name) ? globalThis.String(object.local_cluster_name) : undefined,
      outlier_detection: isSet(object.outlier_detection)
        ? ClusterManager_OutlierDetection.fromJSON(object.outlier_detection)
        : undefined,
      upstream_bind_config: isSet(object.upstream_bind_config)
        ? BindConfig.fromJSON(object.upstream_bind_config)
        : undefined,
      load_stats_config: isSet(object.load_stats_config)
        ? ApiConfigSource.fromJSON(object.load_stats_config)
        : undefined,
      enable_deferred_cluster_creation: isSet(object.enable_deferred_cluster_creation)
        ? globalThis.Boolean(object.enable_deferred_cluster_creation)
        : undefined,
    };
  },

  toJSON(message: ClusterManager): unknown {
    const obj: any = {};
    if (message.local_cluster_name !== undefined) {
      obj.local_cluster_name = message.local_cluster_name;
    }
    if (message.outlier_detection !== undefined) {
      obj.outlier_detection = ClusterManager_OutlierDetection.toJSON(message.outlier_detection);
    }
    if (message.upstream_bind_config !== undefined) {
      obj.upstream_bind_config = BindConfig.toJSON(message.upstream_bind_config);
    }
    if (message.load_stats_config !== undefined) {
      obj.load_stats_config = ApiConfigSource.toJSON(message.load_stats_config);
    }
    if (message.enable_deferred_cluster_creation !== undefined) {
      obj.enable_deferred_cluster_creation = message.enable_deferred_cluster_creation;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClusterManager>, I>>(base?: I): ClusterManager {
    return ClusterManager.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClusterManager>, I>>(object: I): ClusterManager {
    const message = createBaseClusterManager();
    message.local_cluster_name = object.local_cluster_name ?? undefined;
    message.outlier_detection = (object.outlier_detection !== undefined && object.outlier_detection !== null)
      ? ClusterManager_OutlierDetection.fromPartial(object.outlier_detection)
      : undefined;
    message.upstream_bind_config = (object.upstream_bind_config !== undefined && object.upstream_bind_config !== null)
      ? BindConfig.fromPartial(object.upstream_bind_config)
      : undefined;
    message.load_stats_config = (object.load_stats_config !== undefined && object.load_stats_config !== null)
      ? ApiConfigSource.fromPartial(object.load_stats_config)
      : undefined;
    message.enable_deferred_cluster_creation = object.enable_deferred_cluster_creation ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ClusterManager.$type, ClusterManager);

function createBaseClusterManager_OutlierDetection(): ClusterManager_OutlierDetection {
  return { $type: "envoy.config.bootstrap.v3.ClusterManager.OutlierDetection" };
}

export const ClusterManager_OutlierDetection: MessageFns<
  ClusterManager_OutlierDetection,
  "envoy.config.bootstrap.v3.ClusterManager.OutlierDetection"
> = {
  $type: "envoy.config.bootstrap.v3.ClusterManager.OutlierDetection" as const,

  encode(message: ClusterManager_OutlierDetection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.event_log_path !== undefined && message.event_log_path !== "") {
      writer.uint32(10).string(message.event_log_path);
    }
    if (message.event_service !== undefined) {
      EventServiceConfig.encode(message.event_service, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClusterManager_OutlierDetection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClusterManager_OutlierDetection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.event_log_path = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.event_service = EventServiceConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClusterManager_OutlierDetection {
    return {
      $type: ClusterManager_OutlierDetection.$type,
      event_log_path: isSet(object.event_log_path) ? globalThis.String(object.event_log_path) : undefined,
      event_service: isSet(object.event_service) ? EventServiceConfig.fromJSON(object.event_service) : undefined,
    };
  },

  toJSON(message: ClusterManager_OutlierDetection): unknown {
    const obj: any = {};
    if (message.event_log_path !== undefined) {
      obj.event_log_path = message.event_log_path;
    }
    if (message.event_service !== undefined) {
      obj.event_service = EventServiceConfig.toJSON(message.event_service);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClusterManager_OutlierDetection>, I>>(base?: I): ClusterManager_OutlierDetection {
    return ClusterManager_OutlierDetection.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClusterManager_OutlierDetection>, I>>(
    object: I,
  ): ClusterManager_OutlierDetection {
    const message = createBaseClusterManager_OutlierDetection();
    message.event_log_path = object.event_log_path ?? undefined;
    message.event_service = (object.event_service !== undefined && object.event_service !== null)
      ? EventServiceConfig.fromPartial(object.event_service)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(ClusterManager_OutlierDetection.$type, ClusterManager_OutlierDetection);

function createBaseWatchdogs(): Watchdogs {
  return { $type: "envoy.config.bootstrap.v3.Watchdogs" };
}

export const Watchdogs: MessageFns<Watchdogs, "envoy.config.bootstrap.v3.Watchdogs"> = {
  $type: "envoy.config.bootstrap.v3.Watchdogs" as const,

  encode(message: Watchdogs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.main_thread_watchdog !== undefined) {
      Watchdog.encode(message.main_thread_watchdog, writer.uint32(10).fork()).join();
    }
    if (message.worker_watchdog !== undefined) {
      Watchdog.encode(message.worker_watchdog, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Watchdogs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWatchdogs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.main_thread_watchdog = Watchdog.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.worker_watchdog = Watchdog.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Watchdogs {
    return {
      $type: Watchdogs.$type,
      main_thread_watchdog: isSet(object.main_thread_watchdog)
        ? Watchdog.fromJSON(object.main_thread_watchdog)
        : undefined,
      worker_watchdog: isSet(object.worker_watchdog) ? Watchdog.fromJSON(object.worker_watchdog) : undefined,
    };
  },

  toJSON(message: Watchdogs): unknown {
    const obj: any = {};
    if (message.main_thread_watchdog !== undefined) {
      obj.main_thread_watchdog = Watchdog.toJSON(message.main_thread_watchdog);
    }
    if (message.worker_watchdog !== undefined) {
      obj.worker_watchdog = Watchdog.toJSON(message.worker_watchdog);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Watchdogs>, I>>(base?: I): Watchdogs {
    return Watchdogs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Watchdogs>, I>>(object: I): Watchdogs {
    const message = createBaseWatchdogs();
    message.main_thread_watchdog = (object.main_thread_watchdog !== undefined && object.main_thread_watchdog !== null)
      ? Watchdog.fromPartial(object.main_thread_watchdog)
      : undefined;
    message.worker_watchdog = (object.worker_watchdog !== undefined && object.worker_watchdog !== null)
      ? Watchdog.fromPartial(object.worker_watchdog)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Watchdogs.$type, Watchdogs);

function createBaseWatchdog(): Watchdog {
  return { $type: "envoy.config.bootstrap.v3.Watchdog" };
}

export const Watchdog: MessageFns<Watchdog, "envoy.config.bootstrap.v3.Watchdog"> = {
  $type: "envoy.config.bootstrap.v3.Watchdog" as const,

  encode(message: Watchdog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.actions !== undefined && message.actions.length !== 0) {
      for (const v of message.actions) {
        Watchdog_WatchdogAction.encode(v!, writer.uint32(58).fork()).join();
      }
    }
    if (message.miss_timeout !== undefined) {
      Duration.encode(message.miss_timeout, writer.uint32(10).fork()).join();
    }
    if (message.megamiss_timeout !== undefined) {
      Duration.encode(message.megamiss_timeout, writer.uint32(18).fork()).join();
    }
    if (message.kill_timeout !== undefined) {
      Duration.encode(message.kill_timeout, writer.uint32(26).fork()).join();
    }
    if (message.max_kill_timeout_jitter !== undefined) {
      Duration.encode(message.max_kill_timeout_jitter, writer.uint32(50).fork()).join();
    }
    if (message.multikill_timeout !== undefined) {
      Duration.encode(message.multikill_timeout, writer.uint32(34).fork()).join();
    }
    if (message.multikill_threshold !== undefined) {
      Percent.encode(message.multikill_threshold, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Watchdog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWatchdog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 7: {
          if (tag !== 58) {
            break;
          }

          if (message.actions === undefined) {
            message.actions = [];
          }
          const el = Watchdog_WatchdogAction.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.actions!.push(el);
          }
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.miss_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.megamiss_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.kill_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.max_kill_timeout_jitter = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.multikill_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.multikill_threshold = Percent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Watchdog {
    return {
      $type: Watchdog.$type,
      actions: globalThis.Array.isArray(object?.actions)
        ? object.actions.map((e: any) => Watchdog_WatchdogAction.fromJSON(e))
        : undefined,
      miss_timeout: isSet(object.miss_timeout) ? Duration.fromJSON(object.miss_timeout) : undefined,
      megamiss_timeout: isSet(object.megamiss_timeout) ? Duration.fromJSON(object.megamiss_timeout) : undefined,
      kill_timeout: isSet(object.kill_timeout) ? Duration.fromJSON(object.kill_timeout) : undefined,
      max_kill_timeout_jitter: isSet(object.max_kill_timeout_jitter)
        ? Duration.fromJSON(object.max_kill_timeout_jitter)
        : undefined,
      multikill_timeout: isSet(object.multikill_timeout) ? Duration.fromJSON(object.multikill_timeout) : undefined,
      multikill_threshold: isSet(object.multikill_threshold) ? Percent.fromJSON(object.multikill_threshold) : undefined,
    };
  },

  toJSON(message: Watchdog): unknown {
    const obj: any = {};
    if (message.actions?.length) {
      obj.actions = message.actions.map((e) => Watchdog_WatchdogAction.toJSON(e));
    }
    if (message.miss_timeout !== undefined) {
      obj.miss_timeout = Duration.toJSON(message.miss_timeout);
    }
    if (message.megamiss_timeout !== undefined) {
      obj.megamiss_timeout = Duration.toJSON(message.megamiss_timeout);
    }
    if (message.kill_timeout !== undefined) {
      obj.kill_timeout = Duration.toJSON(message.kill_timeout);
    }
    if (message.max_kill_timeout_jitter !== undefined) {
      obj.max_kill_timeout_jitter = Duration.toJSON(message.max_kill_timeout_jitter);
    }
    if (message.multikill_timeout !== undefined) {
      obj.multikill_timeout = Duration.toJSON(message.multikill_timeout);
    }
    if (message.multikill_threshold !== undefined) {
      obj.multikill_threshold = Percent.toJSON(message.multikill_threshold);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Watchdog>, I>>(base?: I): Watchdog {
    return Watchdog.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Watchdog>, I>>(object: I): Watchdog {
    const message = createBaseWatchdog();
    message.actions = object.actions?.map((e) => Watchdog_WatchdogAction.fromPartial(e)) || undefined;
    message.miss_timeout = (object.miss_timeout !== undefined && object.miss_timeout !== null)
      ? Duration.fromPartial(object.miss_timeout)
      : undefined;
    message.megamiss_timeout = (object.megamiss_timeout !== undefined && object.megamiss_timeout !== null)
      ? Duration.fromPartial(object.megamiss_timeout)
      : undefined;
    message.kill_timeout = (object.kill_timeout !== undefined && object.kill_timeout !== null)
      ? Duration.fromPartial(object.kill_timeout)
      : undefined;
    message.max_kill_timeout_jitter =
      (object.max_kill_timeout_jitter !== undefined && object.max_kill_timeout_jitter !== null)
        ? Duration.fromPartial(object.max_kill_timeout_jitter)
        : undefined;
    message.multikill_timeout = (object.multikill_timeout !== undefined && object.multikill_timeout !== null)
      ? Duration.fromPartial(object.multikill_timeout)
      : undefined;
    message.multikill_threshold = (object.multikill_threshold !== undefined && object.multikill_threshold !== null)
      ? Percent.fromPartial(object.multikill_threshold)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Watchdog.$type, Watchdog);

function createBaseWatchdog_WatchdogAction(): Watchdog_WatchdogAction {
  return { $type: "envoy.config.bootstrap.v3.Watchdog.WatchdogAction" };
}

export const Watchdog_WatchdogAction: MessageFns<
  Watchdog_WatchdogAction,
  "envoy.config.bootstrap.v3.Watchdog.WatchdogAction"
> = {
  $type: "envoy.config.bootstrap.v3.Watchdog.WatchdogAction" as const,

  encode(message: Watchdog_WatchdogAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.config !== undefined) {
      TypedExtensionConfig.encode(message.config, writer.uint32(10).fork()).join();
    }
    if (message.event !== undefined && message.event !== Watchdog_WatchdogAction_WatchdogEvent.UNKNOWN) {
      writer.uint32(16).int32(watchdog_WatchdogAction_WatchdogEventToNumber(message.event));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Watchdog_WatchdogAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWatchdog_WatchdogAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.config = TypedExtensionConfig.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.event = watchdog_WatchdogAction_WatchdogEventFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Watchdog_WatchdogAction {
    return {
      $type: Watchdog_WatchdogAction.$type,
      config: isSet(object.config) ? TypedExtensionConfig.fromJSON(object.config) : undefined,
      event: isSet(object.event) ? watchdog_WatchdogAction_WatchdogEventFromJSON(object.event) : undefined,
    };
  },

  toJSON(message: Watchdog_WatchdogAction): unknown {
    const obj: any = {};
    if (message.config !== undefined) {
      obj.config = TypedExtensionConfig.toJSON(message.config);
    }
    if (message.event !== undefined) {
      obj.event = watchdog_WatchdogAction_WatchdogEventToJSON(message.event);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Watchdog_WatchdogAction>, I>>(base?: I): Watchdog_WatchdogAction {
    return Watchdog_WatchdogAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Watchdog_WatchdogAction>, I>>(object: I): Watchdog_WatchdogAction {
    const message = createBaseWatchdog_WatchdogAction();
    message.config = (object.config !== undefined && object.config !== null)
      ? TypedExtensionConfig.fromPartial(object.config)
      : undefined;
    message.event = object.event ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Watchdog_WatchdogAction.$type, Watchdog_WatchdogAction);

function createBaseFatalAction(): FatalAction {
  return { $type: "envoy.config.bootstrap.v3.FatalAction" };
}

export const FatalAction: MessageFns<FatalAction, "envoy.config.bootstrap.v3.FatalAction"> = {
  $type: "envoy.config.bootstrap.v3.FatalAction" as const,

  encode(message: FatalAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.config !== undefined) {
      TypedExtensionConfig.encode(message.config, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FatalAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFatalAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.config = TypedExtensionConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FatalAction {
    return {
      $type: FatalAction.$type,
      config: isSet(object.config) ? TypedExtensionConfig.fromJSON(object.config) : undefined,
    };
  },

  toJSON(message: FatalAction): unknown {
    const obj: any = {};
    if (message.config !== undefined) {
      obj.config = TypedExtensionConfig.toJSON(message.config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FatalAction>, I>>(base?: I): FatalAction {
    return FatalAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FatalAction>, I>>(object: I): FatalAction {
    const message = createBaseFatalAction();
    message.config = (object.config !== undefined && object.config !== null)
      ? TypedExtensionConfig.fromPartial(object.config)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(FatalAction.$type, FatalAction);

function createBaseRuntime(): Runtime {
  return { $type: "envoy.config.bootstrap.v3.Runtime" };
}

export const Runtime: MessageFns<Runtime, "envoy.config.bootstrap.v3.Runtime"> = {
  $type: "envoy.config.bootstrap.v3.Runtime" as const,

  encode(message: Runtime, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.symlink_root !== undefined && message.symlink_root !== "") {
      writer.uint32(10).string(message.symlink_root);
    }
    if (message.subdirectory !== undefined && message.subdirectory !== "") {
      writer.uint32(18).string(message.subdirectory);
    }
    if (message.override_subdirectory !== undefined && message.override_subdirectory !== "") {
      writer.uint32(26).string(message.override_subdirectory);
    }
    if (message.base !== undefined) {
      Struct.encode(Struct.wrap(message.base), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Runtime {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuntime();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.symlink_root = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.subdirectory = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.override_subdirectory = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.base = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Runtime {
    return {
      $type: Runtime.$type,
      symlink_root: isSet(object.symlink_root) ? globalThis.String(object.symlink_root) : undefined,
      subdirectory: isSet(object.subdirectory) ? globalThis.String(object.subdirectory) : undefined,
      override_subdirectory: isSet(object.override_subdirectory)
        ? globalThis.String(object.override_subdirectory)
        : undefined,
      base: isObject(object.base) ? object.base : undefined,
    };
  },

  toJSON(message: Runtime): unknown {
    const obj: any = {};
    if (message.symlink_root !== undefined) {
      obj.symlink_root = message.symlink_root;
    }
    if (message.subdirectory !== undefined) {
      obj.subdirectory = message.subdirectory;
    }
    if (message.override_subdirectory !== undefined) {
      obj.override_subdirectory = message.override_subdirectory;
    }
    if (message.base !== undefined) {
      obj.base = message.base;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Runtime>, I>>(base?: I): Runtime {
    return Runtime.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Runtime>, I>>(object: I): Runtime {
    const message = createBaseRuntime();
    message.symlink_root = object.symlink_root ?? undefined;
    message.subdirectory = object.subdirectory ?? undefined;
    message.override_subdirectory = object.override_subdirectory ?? undefined;
    message.base = object.base ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Runtime.$type, Runtime);

function createBaseRuntimeLayer(): RuntimeLayer {
  return { $type: "envoy.config.bootstrap.v3.RuntimeLayer", layer_specifier: undefined };
}

export const RuntimeLayer: MessageFns<RuntimeLayer, "envoy.config.bootstrap.v3.RuntimeLayer"> = {
  $type: "envoy.config.bootstrap.v3.RuntimeLayer" as const,

  encode(message: RuntimeLayer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    switch (message.layer_specifier?.$case) {
      case "static_layer":
        Struct.encode(Struct.wrap(message.layer_specifier.static_layer), writer.uint32(18).fork()).join();
        break;
      case "disk_layer":
        RuntimeLayer_DiskLayer.encode(message.layer_specifier.disk_layer, writer.uint32(26).fork()).join();
        break;
      case "admin_layer":
        RuntimeLayer_AdminLayer.encode(message.layer_specifier.admin_layer, writer.uint32(34).fork()).join();
        break;
      case "rtds_layer":
        RuntimeLayer_RtdsLayer.encode(message.layer_specifier.rtds_layer, writer.uint32(42).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuntimeLayer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuntimeLayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.layer_specifier = {
            $case: "static_layer",
            static_layer: Struct.unwrap(Struct.decode(reader, reader.uint32())),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.layer_specifier = {
            $case: "disk_layer",
            disk_layer: RuntimeLayer_DiskLayer.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.layer_specifier = {
            $case: "admin_layer",
            admin_layer: RuntimeLayer_AdminLayer.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.layer_specifier = {
            $case: "rtds_layer",
            rtds_layer: RuntimeLayer_RtdsLayer.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuntimeLayer {
    return {
      $type: RuntimeLayer.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      layer_specifier: isSet(object.static_layer)
        ? { $case: "static_layer", static_layer: object.static_layer }
        : isSet(object.disk_layer)
        ? { $case: "disk_layer", disk_layer: RuntimeLayer_DiskLayer.fromJSON(object.disk_layer) }
        : isSet(object.admin_layer)
        ? { $case: "admin_layer", admin_layer: RuntimeLayer_AdminLayer.fromJSON(object.admin_layer) }
        : isSet(object.rtds_layer)
        ? { $case: "rtds_layer", rtds_layer: RuntimeLayer_RtdsLayer.fromJSON(object.rtds_layer) }
        : undefined,
    };
  },

  toJSON(message: RuntimeLayer): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.layer_specifier?.$case === "static_layer") {
      obj.static_layer = message.layer_specifier.static_layer;
    }
    if (message.layer_specifier?.$case === "disk_layer") {
      obj.disk_layer = RuntimeLayer_DiskLayer.toJSON(message.layer_specifier.disk_layer);
    }
    if (message.layer_specifier?.$case === "admin_layer") {
      obj.admin_layer = RuntimeLayer_AdminLayer.toJSON(message.layer_specifier.admin_layer);
    }
    if (message.layer_specifier?.$case === "rtds_layer") {
      obj.rtds_layer = RuntimeLayer_RtdsLayer.toJSON(message.layer_specifier.rtds_layer);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RuntimeLayer>, I>>(base?: I): RuntimeLayer {
    return RuntimeLayer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RuntimeLayer>, I>>(object: I): RuntimeLayer {
    const message = createBaseRuntimeLayer();
    message.name = object.name ?? undefined;
    if (
      object.layer_specifier?.$case === "static_layer" &&
      object.layer_specifier?.static_layer !== undefined &&
      object.layer_specifier?.static_layer !== null
    ) {
      message.layer_specifier = { $case: "static_layer", static_layer: object.layer_specifier.static_layer };
    }
    if (
      object.layer_specifier?.$case === "disk_layer" &&
      object.layer_specifier?.disk_layer !== undefined &&
      object.layer_specifier?.disk_layer !== null
    ) {
      message.layer_specifier = {
        $case: "disk_layer",
        disk_layer: RuntimeLayer_DiskLayer.fromPartial(object.layer_specifier.disk_layer),
      };
    }
    if (
      object.layer_specifier?.$case === "admin_layer" &&
      object.layer_specifier?.admin_layer !== undefined &&
      object.layer_specifier?.admin_layer !== null
    ) {
      message.layer_specifier = {
        $case: "admin_layer",
        admin_layer: RuntimeLayer_AdminLayer.fromPartial(object.layer_specifier.admin_layer),
      };
    }
    if (
      object.layer_specifier?.$case === "rtds_layer" &&
      object.layer_specifier?.rtds_layer !== undefined &&
      object.layer_specifier?.rtds_layer !== null
    ) {
      message.layer_specifier = {
        $case: "rtds_layer",
        rtds_layer: RuntimeLayer_RtdsLayer.fromPartial(object.layer_specifier.rtds_layer),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(RuntimeLayer.$type, RuntimeLayer);

function createBaseRuntimeLayer_DiskLayer(): RuntimeLayer_DiskLayer {
  return { $type: "envoy.config.bootstrap.v3.RuntimeLayer.DiskLayer" };
}

export const RuntimeLayer_DiskLayer: MessageFns<
  RuntimeLayer_DiskLayer,
  "envoy.config.bootstrap.v3.RuntimeLayer.DiskLayer"
> = {
  $type: "envoy.config.bootstrap.v3.RuntimeLayer.DiskLayer" as const,

  encode(message: RuntimeLayer_DiskLayer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.symlink_root !== undefined && message.symlink_root !== "") {
      writer.uint32(10).string(message.symlink_root);
    }
    if (message.subdirectory !== undefined && message.subdirectory !== "") {
      writer.uint32(26).string(message.subdirectory);
    }
    if (message.append_service_cluster !== undefined && message.append_service_cluster !== false) {
      writer.uint32(16).bool(message.append_service_cluster);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuntimeLayer_DiskLayer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuntimeLayer_DiskLayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.symlink_root = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.subdirectory = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.append_service_cluster = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuntimeLayer_DiskLayer {
    return {
      $type: RuntimeLayer_DiskLayer.$type,
      symlink_root: isSet(object.symlink_root) ? globalThis.String(object.symlink_root) : undefined,
      subdirectory: isSet(object.subdirectory) ? globalThis.String(object.subdirectory) : undefined,
      append_service_cluster: isSet(object.append_service_cluster)
        ? globalThis.Boolean(object.append_service_cluster)
        : undefined,
    };
  },

  toJSON(message: RuntimeLayer_DiskLayer): unknown {
    const obj: any = {};
    if (message.symlink_root !== undefined) {
      obj.symlink_root = message.symlink_root;
    }
    if (message.subdirectory !== undefined) {
      obj.subdirectory = message.subdirectory;
    }
    if (message.append_service_cluster !== undefined) {
      obj.append_service_cluster = message.append_service_cluster;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RuntimeLayer_DiskLayer>, I>>(base?: I): RuntimeLayer_DiskLayer {
    return RuntimeLayer_DiskLayer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RuntimeLayer_DiskLayer>, I>>(object: I): RuntimeLayer_DiskLayer {
    const message = createBaseRuntimeLayer_DiskLayer();
    message.symlink_root = object.symlink_root ?? undefined;
    message.subdirectory = object.subdirectory ?? undefined;
    message.append_service_cluster = object.append_service_cluster ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RuntimeLayer_DiskLayer.$type, RuntimeLayer_DiskLayer);

function createBaseRuntimeLayer_AdminLayer(): RuntimeLayer_AdminLayer {
  return { $type: "envoy.config.bootstrap.v3.RuntimeLayer.AdminLayer" };
}

export const RuntimeLayer_AdminLayer: MessageFns<
  RuntimeLayer_AdminLayer,
  "envoy.config.bootstrap.v3.RuntimeLayer.AdminLayer"
> = {
  $type: "envoy.config.bootstrap.v3.RuntimeLayer.AdminLayer" as const,

  encode(_: RuntimeLayer_AdminLayer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuntimeLayer_AdminLayer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuntimeLayer_AdminLayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RuntimeLayer_AdminLayer {
    return { $type: RuntimeLayer_AdminLayer.$type };
  },

  toJSON(_: RuntimeLayer_AdminLayer): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RuntimeLayer_AdminLayer>, I>>(base?: I): RuntimeLayer_AdminLayer {
    return RuntimeLayer_AdminLayer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RuntimeLayer_AdminLayer>, I>>(_: I): RuntimeLayer_AdminLayer {
    const message = createBaseRuntimeLayer_AdminLayer();
    return message;
  },
};

messageTypeRegistry.set(RuntimeLayer_AdminLayer.$type, RuntimeLayer_AdminLayer);

function createBaseRuntimeLayer_RtdsLayer(): RuntimeLayer_RtdsLayer {
  return { $type: "envoy.config.bootstrap.v3.RuntimeLayer.RtdsLayer" };
}

export const RuntimeLayer_RtdsLayer: MessageFns<
  RuntimeLayer_RtdsLayer,
  "envoy.config.bootstrap.v3.RuntimeLayer.RtdsLayer"
> = {
  $type: "envoy.config.bootstrap.v3.RuntimeLayer.RtdsLayer" as const,

  encode(message: RuntimeLayer_RtdsLayer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.rtds_config !== undefined) {
      ConfigSource.encode(message.rtds_config, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuntimeLayer_RtdsLayer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuntimeLayer_RtdsLayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rtds_config = ConfigSource.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuntimeLayer_RtdsLayer {
    return {
      $type: RuntimeLayer_RtdsLayer.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      rtds_config: isSet(object.rtds_config) ? ConfigSource.fromJSON(object.rtds_config) : undefined,
    };
  },

  toJSON(message: RuntimeLayer_RtdsLayer): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.rtds_config !== undefined) {
      obj.rtds_config = ConfigSource.toJSON(message.rtds_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RuntimeLayer_RtdsLayer>, I>>(base?: I): RuntimeLayer_RtdsLayer {
    return RuntimeLayer_RtdsLayer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RuntimeLayer_RtdsLayer>, I>>(object: I): RuntimeLayer_RtdsLayer {
    const message = createBaseRuntimeLayer_RtdsLayer();
    message.name = object.name ?? undefined;
    message.rtds_config = (object.rtds_config !== undefined && object.rtds_config !== null)
      ? ConfigSource.fromPartial(object.rtds_config)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(RuntimeLayer_RtdsLayer.$type, RuntimeLayer_RtdsLayer);

function createBaseLayeredRuntime(): LayeredRuntime {
  return { $type: "envoy.config.bootstrap.v3.LayeredRuntime" };
}

export const LayeredRuntime: MessageFns<LayeredRuntime, "envoy.config.bootstrap.v3.LayeredRuntime"> = {
  $type: "envoy.config.bootstrap.v3.LayeredRuntime" as const,

  encode(message: LayeredRuntime, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.layers !== undefined && message.layers.length !== 0) {
      for (const v of message.layers) {
        RuntimeLayer.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LayeredRuntime {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLayeredRuntime();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.layers === undefined) {
            message.layers = [];
          }
          const el = RuntimeLayer.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.layers!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LayeredRuntime {
    return {
      $type: LayeredRuntime.$type,
      layers: globalThis.Array.isArray(object?.layers)
        ? object.layers.map((e: any) => RuntimeLayer.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: LayeredRuntime): unknown {
    const obj: any = {};
    if (message.layers?.length) {
      obj.layers = message.layers.map((e) => RuntimeLayer.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LayeredRuntime>, I>>(base?: I): LayeredRuntime {
    return LayeredRuntime.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LayeredRuntime>, I>>(object: I): LayeredRuntime {
    const message = createBaseLayeredRuntime();
    message.layers = object.layers?.map((e) => RuntimeLayer.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(LayeredRuntime.$type, LayeredRuntime);

function createBaseCustomInlineHeader(): CustomInlineHeader {
  return { $type: "envoy.config.bootstrap.v3.CustomInlineHeader" };
}

export const CustomInlineHeader: MessageFns<CustomInlineHeader, "envoy.config.bootstrap.v3.CustomInlineHeader"> = {
  $type: "envoy.config.bootstrap.v3.CustomInlineHeader" as const,

  encode(message: CustomInlineHeader, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inline_header_name !== undefined && message.inline_header_name !== "") {
      writer.uint32(10).string(message.inline_header_name);
    }
    if (
      message.inline_header_type !== undefined &&
      message.inline_header_type !== CustomInlineHeader_InlineHeaderType.REQUEST_HEADER
    ) {
      writer.uint32(16).int32(customInlineHeader_InlineHeaderTypeToNumber(message.inline_header_type));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomInlineHeader {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomInlineHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.inline_header_name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.inline_header_type = customInlineHeader_InlineHeaderTypeFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomInlineHeader {
    return {
      $type: CustomInlineHeader.$type,
      inline_header_name: isSet(object.inline_header_name) ? globalThis.String(object.inline_header_name) : undefined,
      inline_header_type: isSet(object.inline_header_type)
        ? customInlineHeader_InlineHeaderTypeFromJSON(object.inline_header_type)
        : undefined,
    };
  },

  toJSON(message: CustomInlineHeader): unknown {
    const obj: any = {};
    if (message.inline_header_name !== undefined) {
      obj.inline_header_name = message.inline_header_name;
    }
    if (message.inline_header_type !== undefined) {
      obj.inline_header_type = customInlineHeader_InlineHeaderTypeToJSON(message.inline_header_type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CustomInlineHeader>, I>>(base?: I): CustomInlineHeader {
    return CustomInlineHeader.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustomInlineHeader>, I>>(object: I): CustomInlineHeader {
    const message = createBaseCustomInlineHeader();
    message.inline_header_name = object.inline_header_name ?? undefined;
    message.inline_header_type = object.inline_header_type ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(CustomInlineHeader.$type, CustomInlineHeader);

function createBaseMemoryAllocatorManager(): MemoryAllocatorManager {
  return { $type: "envoy.config.bootstrap.v3.MemoryAllocatorManager" };
}

export const MemoryAllocatorManager: MessageFns<
  MemoryAllocatorManager,
  "envoy.config.bootstrap.v3.MemoryAllocatorManager"
> = {
  $type: "envoy.config.bootstrap.v3.MemoryAllocatorManager" as const,

  encode(message: MemoryAllocatorManager, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bytes_to_release !== undefined && message.bytes_to_release !== 0) {
      writer.uint32(8).uint64(message.bytes_to_release);
    }
    if (message.memory_release_interval !== undefined) {
      Duration.encode(message.memory_release_interval, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MemoryAllocatorManager {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemoryAllocatorManager();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.bytes_to_release = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.memory_release_interval = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MemoryAllocatorManager {
    return {
      $type: MemoryAllocatorManager.$type,
      bytes_to_release: isSet(object.bytes_to_release) ? globalThis.Number(object.bytes_to_release) : undefined,
      memory_release_interval: isSet(object.memory_release_interval)
        ? Duration.fromJSON(object.memory_release_interval)
        : undefined,
    };
  },

  toJSON(message: MemoryAllocatorManager): unknown {
    const obj: any = {};
    if (message.bytes_to_release !== undefined) {
      obj.bytes_to_release = Math.round(message.bytes_to_release);
    }
    if (message.memory_release_interval !== undefined) {
      obj.memory_release_interval = Duration.toJSON(message.memory_release_interval);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MemoryAllocatorManager>, I>>(base?: I): MemoryAllocatorManager {
    return MemoryAllocatorManager.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MemoryAllocatorManager>, I>>(object: I): MemoryAllocatorManager {
    const message = createBaseMemoryAllocatorManager();
    message.bytes_to_release = object.bytes_to_release ?? undefined;
    message.memory_release_interval =
      (object.memory_release_interval !== undefined && object.memory_release_interval !== null)
        ? Duration.fromPartial(object.memory_release_interval)
        : undefined;
    return message;
  },
};

messageTypeRegistry.set(MemoryAllocatorManager.$type, MemoryAllocatorManager);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
