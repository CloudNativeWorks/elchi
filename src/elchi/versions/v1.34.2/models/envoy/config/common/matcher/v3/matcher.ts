// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/config/common/matcher/v3/matcher.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { messageTypeRegistry } from "../../../../../typeRegistry";
import { StringMatcher } from "../../../../type/matcher/v3/string";
import { TypedExtensionConfig } from "../../../core/v3/extension";
import { HeaderMatcher } from "../../../route/v3/route_components";

export const protobufPackage = "envoy.config.common.matcher.v3";

/**
 * A matcher, which may traverse a matching tree in order to result in a match action.
 * During matching, the tree will be traversed until a match is found, or if no match
 * is found the action specified by the most specific on_no_match will be evaluated.
 * As an on_no_match might result in another matching tree being evaluated, this process
 * might repeat several times until the final OnMatch (or no match) is decided.
 *
 * .. note::
 *   Please use the syntactically equivalent :ref:`matching API <envoy_v3_api_msg_.xds.type.matcher.v3.Matcher>`
 */
export interface Matcher {
  $type: "envoy.config.common.matcher.v3.Matcher";
  matcher_type?:
    | //
    /** A linear list of matchers to evaluate. */
    { $case: "matcher_list"; matcher_list: Matcher_MatcherList }
    | //
    /** A match tree to evaluate. */
    { $case: "matcher_tree"; matcher_tree: Matcher_MatcherTree }
    | undefined;
  /**
   * Optional OnMatch to use if the matcher failed.
   * If specified, the OnMatch is used, and the matcher is considered
   * to have matched.
   * If not specified, the matcher is considered not to have matched.
   */
  on_no_match?: Matcher_OnMatch | undefined;
}

/** What to do if a match is successful. */
export interface Matcher_OnMatch {
  $type: "envoy.config.common.matcher.v3.Matcher.OnMatch";
  on_match?:
    | //
    /**
     * Nested matcher to evaluate.
     * If the nested matcher does not match and does not specify
     * on_no_match, then this matcher is considered not to have
     * matched, even if a predicate at this level or above returned
     * true.
     */
    { $case: "matcher"; matcher: Matcher }
    | //
    /** Protocol-specific action to take. */
    { $case: "action"; action: TypedExtensionConfig }
    | undefined;
}

/**
 * A linear list of field matchers.
 * The field matchers are evaluated in order, and the first match
 * wins.
 */
export interface Matcher_MatcherList {
  $type: "envoy.config.common.matcher.v3.Matcher.MatcherList";
  /** A list of matchers. First match wins. */
  matchers?: Matcher_MatcherList_FieldMatcher[] | undefined;
}

/** Predicate to determine if a match is successful. */
export interface Matcher_MatcherList_Predicate {
  $type: "envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate";
  match_type?:
    | //
    /** A single predicate to evaluate. */
    { $case: "single_predicate"; single_predicate: Matcher_MatcherList_Predicate_SinglePredicate }
    | //
    /** A list of predicates to be OR-ed together. */
    { $case: "or_matcher"; or_matcher: Matcher_MatcherList_Predicate_PredicateList }
    | //
    /** A list of predicates to be AND-ed together. */
    { $case: "and_matcher"; and_matcher: Matcher_MatcherList_Predicate_PredicateList }
    | //
    /** The invert of a predicate */
    { $case: "not_matcher"; not_matcher: Matcher_MatcherList_Predicate }
    | undefined;
}

/** Predicate for a single input field. */
export interface Matcher_MatcherList_Predicate_SinglePredicate {
  $type: "envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.SinglePredicate";
  /**
   * Protocol-specific specification of input field to match on.
   * [#extension-category: envoy.matching.common_inputs]
   */
  input?: TypedExtensionConfig | undefined;
  matcher?:
    | //
    /** Built-in string matcher. */
    { $case: "value_match"; value_match: StringMatcher }
    | //
    /**
     * Extension for custom matching logic.
     * [#extension-category: envoy.matching.input_matchers]
     */
    { $case: "custom_match"; custom_match: TypedExtensionConfig }
    | undefined;
}

/** A list of two or more matchers. Used to allow using a list within a oneof. */
export interface Matcher_MatcherList_Predicate_PredicateList {
  $type: "envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.PredicateList";
  predicate?: Matcher_MatcherList_Predicate[] | undefined;
}

/** An individual matcher. */
export interface Matcher_MatcherList_FieldMatcher {
  $type: "envoy.config.common.matcher.v3.Matcher.MatcherList.FieldMatcher";
  /** Determines if the match succeeds. */
  predicate?:
    | Matcher_MatcherList_Predicate
    | undefined;
  /** What to do if the match succeeds. */
  on_match?: Matcher_OnMatch | undefined;
}

export interface Matcher_MatcherTree {
  $type: "envoy.config.common.matcher.v3.Matcher.MatcherTree";
  /** Protocol-specific specification of input field to match on. */
  input?:
    | TypedExtensionConfig
    | undefined;
  /**
   * Exact or prefix match maps in which to look up the input value.
   * If the lookup succeeds, the match is considered successful, and
   * the corresponding OnMatch is used.
   */
  tree_type?:
    | //
    { $case: "exact_match_map"; exact_match_map: Matcher_MatcherTree_MatchMap }
    | //
    /** Longest matching prefix wins. */
    { $case: "prefix_match_map"; prefix_match_map: Matcher_MatcherTree_MatchMap }
    | //
    /** Extension for custom matching logic. */
    { $case: "custom_match"; custom_match: TypedExtensionConfig }
    | undefined;
}

/** A map of configured matchers. Used to allow using a map within a oneof. */
export interface Matcher_MatcherTree_MatchMap {
  $type: "envoy.config.common.matcher.v3.Matcher.MatcherTree.MatchMap";
  map?: Map<string, Matcher_OnMatch> | undefined;
}

export interface Matcher_MatcherTree_MatchMap_MapEntry {
  $type: "envoy.config.common.matcher.v3.Matcher.MatcherTree.MatchMap.MapEntry";
  key: string;
  value?: Matcher_OnMatch | undefined;
}

/**
 * Match configuration. This is a recursive structure which allows complex nested match
 * configurations to be built using various logical operators.
 * [#next-free-field: 11]
 */
export interface MatchPredicate {
  $type: "envoy.config.common.matcher.v3.MatchPredicate";
  rule?:
    | //
    /**
     * A set that describes a logical OR. If any member of the set matches, the match configuration
     * matches.
     */
    { $case: "or_match"; or_match: MatchPredicate_MatchSet }
    | //
    /**
     * A set that describes a logical AND. If all members of the set match, the match configuration
     * matches.
     */
    { $case: "and_match"; and_match: MatchPredicate_MatchSet }
    | //
    /** A negation match. The match configuration will match if the negated match condition matches. */
    { $case: "not_match"; not_match: MatchPredicate }
    | //
    /** The match configuration will always match. */
    { $case: "any_match"; any_match: boolean }
    | //
    /** HTTP request headers match configuration. */
    { $case: "http_request_headers_match"; http_request_headers_match: HttpHeadersMatch }
    | //
    /** HTTP request trailers match configuration. */
    { $case: "http_request_trailers_match"; http_request_trailers_match: HttpHeadersMatch }
    | //
    /** HTTP response headers match configuration. */
    { $case: "http_response_headers_match"; http_response_headers_match: HttpHeadersMatch }
    | //
    /** HTTP response trailers match configuration. */
    { $case: "http_response_trailers_match"; http_response_trailers_match: HttpHeadersMatch }
    | //
    /** HTTP request generic body match configuration. */
    { $case: "http_request_generic_body_match"; http_request_generic_body_match: HttpGenericBodyMatch }
    | //
    /** HTTP response generic body match configuration. */
    { $case: "http_response_generic_body_match"; http_response_generic_body_match: HttpGenericBodyMatch }
    | undefined;
}

/** A set of match configurations used for logical operations. */
export interface MatchPredicate_MatchSet {
  $type: "envoy.config.common.matcher.v3.MatchPredicate.MatchSet";
  /** The list of rules that make up the set. */
  rules?: MatchPredicate[] | undefined;
}

/** HTTP headers match configuration. */
export interface HttpHeadersMatch {
  $type: "envoy.config.common.matcher.v3.HttpHeadersMatch";
  /** HTTP headers to match. */
  headers?: HeaderMatcher[] | undefined;
}

/**
 * HTTP generic body match configuration.
 * List of text strings and hex strings to be located in HTTP body.
 * All specified strings must be found in the HTTP body for positive match.
 * The search may be limited to specified number of bytes from the body start.
 *
 * .. attention::
 *
 *   Searching for patterns in HTTP body is potentially cpu intensive. For each specified pattern, http body is scanned byte by byte to find a match.
 *   If multiple patterns are specified, the process is repeated for each pattern. If location of a pattern is known, ``bytes_limit`` should be specified
 *   to scan only part of the http body.
 */
export interface HttpGenericBodyMatch {
  $type: "envoy.config.common.matcher.v3.HttpGenericBodyMatch";
  /** Limits search to specified number of bytes - default zero (no limit - match entire captured buffer). */
  bytes_limit?:
    | number
    | undefined;
  /** List of patterns to match. */
  patterns?: HttpGenericBodyMatch_GenericTextMatch[] | undefined;
}

export interface HttpGenericBodyMatch_GenericTextMatch {
  $type: "envoy.config.common.matcher.v3.HttpGenericBodyMatch.GenericTextMatch";
  rule?:
    | //
    /** Text string to be located in HTTP body. */
    { $case: "string_match"; string_match: string }
    | //
    /** Sequence of bytes to be located in HTTP body. */
    { $case: "binary_match"; binary_match: Uint8Array }
    | undefined;
}

function createBaseMatcher(): Matcher {
  return { $type: "envoy.config.common.matcher.v3.Matcher", matcher_type: undefined };
}

export const Matcher: MessageFns<Matcher, "envoy.config.common.matcher.v3.Matcher"> = {
  $type: "envoy.config.common.matcher.v3.Matcher" as const,

  encode(message: Matcher, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.matcher_type?.$case) {
      case "matcher_list":
        Matcher_MatcherList.encode(message.matcher_type.matcher_list, writer.uint32(10).fork()).join();
        break;
      case "matcher_tree":
        Matcher_MatcherTree.encode(message.matcher_type.matcher_tree, writer.uint32(18).fork()).join();
        break;
    }
    if (message.on_no_match !== undefined) {
      Matcher_OnMatch.encode(message.on_no_match, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Matcher {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatcher();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.matcher_type = {
            $case: "matcher_list",
            matcher_list: Matcher_MatcherList.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.matcher_type = {
            $case: "matcher_tree",
            matcher_tree: Matcher_MatcherTree.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.on_no_match = Matcher_OnMatch.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Matcher {
    return {
      $type: Matcher.$type,
      matcher_type: isSet(object.matcher_list)
        ? { $case: "matcher_list", matcher_list: Matcher_MatcherList.fromJSON(object.matcher_list) }
        : isSet(object.matcher_tree)
        ? { $case: "matcher_tree", matcher_tree: Matcher_MatcherTree.fromJSON(object.matcher_tree) }
        : undefined,
      on_no_match: isSet(object.on_no_match) ? Matcher_OnMatch.fromJSON(object.on_no_match) : undefined,
    };
  },

  toJSON(message: Matcher): unknown {
    const obj: any = {};
    if (message.matcher_type?.$case === "matcher_list") {
      obj.matcher_list = Matcher_MatcherList.toJSON(message.matcher_type.matcher_list);
    }
    if (message.matcher_type?.$case === "matcher_tree") {
      obj.matcher_tree = Matcher_MatcherTree.toJSON(message.matcher_type.matcher_tree);
    }
    if (message.on_no_match !== undefined) {
      obj.on_no_match = Matcher_OnMatch.toJSON(message.on_no_match);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Matcher>, I>>(base?: I): Matcher {
    return Matcher.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Matcher>, I>>(object: I): Matcher {
    const message = createBaseMatcher();
    if (
      object.matcher_type?.$case === "matcher_list" &&
      object.matcher_type?.matcher_list !== undefined &&
      object.matcher_type?.matcher_list !== null
    ) {
      message.matcher_type = {
        $case: "matcher_list",
        matcher_list: Matcher_MatcherList.fromPartial(object.matcher_type.matcher_list),
      };
    }
    if (
      object.matcher_type?.$case === "matcher_tree" &&
      object.matcher_type?.matcher_tree !== undefined &&
      object.matcher_type?.matcher_tree !== null
    ) {
      message.matcher_type = {
        $case: "matcher_tree",
        matcher_tree: Matcher_MatcherTree.fromPartial(object.matcher_type.matcher_tree),
      };
    }
    message.on_no_match = (object.on_no_match !== undefined && object.on_no_match !== null)
      ? Matcher_OnMatch.fromPartial(object.on_no_match)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Matcher.$type, Matcher);

function createBaseMatcher_OnMatch(): Matcher_OnMatch {
  return { $type: "envoy.config.common.matcher.v3.Matcher.OnMatch", on_match: undefined };
}

export const Matcher_OnMatch: MessageFns<Matcher_OnMatch, "envoy.config.common.matcher.v3.Matcher.OnMatch"> = {
  $type: "envoy.config.common.matcher.v3.Matcher.OnMatch" as const,

  encode(message: Matcher_OnMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.on_match?.$case) {
      case "matcher":
        Matcher.encode(message.on_match.matcher, writer.uint32(10).fork()).join();
        break;
      case "action":
        TypedExtensionConfig.encode(message.on_match.action, writer.uint32(18).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Matcher_OnMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatcher_OnMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.on_match = { $case: "matcher", matcher: Matcher.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.on_match = { $case: "action", action: TypedExtensionConfig.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Matcher_OnMatch {
    return {
      $type: Matcher_OnMatch.$type,
      on_match: isSet(object.matcher)
        ? { $case: "matcher", matcher: Matcher.fromJSON(object.matcher) }
        : isSet(object.action)
        ? { $case: "action", action: TypedExtensionConfig.fromJSON(object.action) }
        : undefined,
    };
  },

  toJSON(message: Matcher_OnMatch): unknown {
    const obj: any = {};
    if (message.on_match?.$case === "matcher") {
      obj.matcher = Matcher.toJSON(message.on_match.matcher);
    }
    if (message.on_match?.$case === "action") {
      obj.action = TypedExtensionConfig.toJSON(message.on_match.action);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Matcher_OnMatch>, I>>(base?: I): Matcher_OnMatch {
    return Matcher_OnMatch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Matcher_OnMatch>, I>>(object: I): Matcher_OnMatch {
    const message = createBaseMatcher_OnMatch();
    if (
      object.on_match?.$case === "matcher" &&
      object.on_match?.matcher !== undefined &&
      object.on_match?.matcher !== null
    ) {
      message.on_match = { $case: "matcher", matcher: Matcher.fromPartial(object.on_match.matcher) };
    }
    if (
      object.on_match?.$case === "action" && object.on_match?.action !== undefined && object.on_match?.action !== null
    ) {
      message.on_match = { $case: "action", action: TypedExtensionConfig.fromPartial(object.on_match.action) };
    }
    return message;
  },
};

messageTypeRegistry.set(Matcher_OnMatch.$type, Matcher_OnMatch);

function createBaseMatcher_MatcherList(): Matcher_MatcherList {
  return { $type: "envoy.config.common.matcher.v3.Matcher.MatcherList" };
}

export const Matcher_MatcherList: MessageFns<
  Matcher_MatcherList,
  "envoy.config.common.matcher.v3.Matcher.MatcherList"
> = {
  $type: "envoy.config.common.matcher.v3.Matcher.MatcherList" as const,

  encode(message: Matcher_MatcherList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.matchers !== undefined && message.matchers.length !== 0) {
      for (const v of message.matchers) {
        Matcher_MatcherList_FieldMatcher.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Matcher_MatcherList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatcher_MatcherList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.matchers === undefined) {
            message.matchers = [];
          }
          const el = Matcher_MatcherList_FieldMatcher.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.matchers!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Matcher_MatcherList {
    return {
      $type: Matcher_MatcherList.$type,
      matchers: globalThis.Array.isArray(object?.matchers)
        ? object.matchers.map((e: any) => Matcher_MatcherList_FieldMatcher.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: Matcher_MatcherList): unknown {
    const obj: any = {};
    if (message.matchers?.length) {
      obj.matchers = message.matchers.map((e) => Matcher_MatcherList_FieldMatcher.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Matcher_MatcherList>, I>>(base?: I): Matcher_MatcherList {
    return Matcher_MatcherList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Matcher_MatcherList>, I>>(object: I): Matcher_MatcherList {
    const message = createBaseMatcher_MatcherList();
    message.matchers = object.matchers?.map((e) => Matcher_MatcherList_FieldMatcher.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(Matcher_MatcherList.$type, Matcher_MatcherList);

function createBaseMatcher_MatcherList_Predicate(): Matcher_MatcherList_Predicate {
  return { $type: "envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate", match_type: undefined };
}

export const Matcher_MatcherList_Predicate: MessageFns<
  Matcher_MatcherList_Predicate,
  "envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate"
> = {
  $type: "envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate" as const,

  encode(message: Matcher_MatcherList_Predicate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.match_type?.$case) {
      case "single_predicate":
        Matcher_MatcherList_Predicate_SinglePredicate.encode(
          message.match_type.single_predicate,
          writer.uint32(10).fork(),
        ).join();
        break;
      case "or_matcher":
        Matcher_MatcherList_Predicate_PredicateList.encode(message.match_type.or_matcher, writer.uint32(18).fork())
          .join();
        break;
      case "and_matcher":
        Matcher_MatcherList_Predicate_PredicateList.encode(message.match_type.and_matcher, writer.uint32(26).fork())
          .join();
        break;
      case "not_matcher":
        Matcher_MatcherList_Predicate.encode(message.match_type.not_matcher, writer.uint32(34).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Matcher_MatcherList_Predicate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatcher_MatcherList_Predicate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.match_type = {
            $case: "single_predicate",
            single_predicate: Matcher_MatcherList_Predicate_SinglePredicate.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.match_type = {
            $case: "or_matcher",
            or_matcher: Matcher_MatcherList_Predicate_PredicateList.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.match_type = {
            $case: "and_matcher",
            and_matcher: Matcher_MatcherList_Predicate_PredicateList.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.match_type = {
            $case: "not_matcher",
            not_matcher: Matcher_MatcherList_Predicate.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Matcher_MatcherList_Predicate {
    return {
      $type: Matcher_MatcherList_Predicate.$type,
      match_type: isSet(object.single_predicate)
        ? {
          $case: "single_predicate",
          single_predicate: Matcher_MatcherList_Predicate_SinglePredicate.fromJSON(object.single_predicate),
        }
        : isSet(object.or_matcher)
        ? { $case: "or_matcher", or_matcher: Matcher_MatcherList_Predicate_PredicateList.fromJSON(object.or_matcher) }
        : isSet(object.and_matcher)
        ? {
          $case: "and_matcher",
          and_matcher: Matcher_MatcherList_Predicate_PredicateList.fromJSON(object.and_matcher),
        }
        : isSet(object.not_matcher)
        ? { $case: "not_matcher", not_matcher: Matcher_MatcherList_Predicate.fromJSON(object.not_matcher) }
        : undefined,
    };
  },

  toJSON(message: Matcher_MatcherList_Predicate): unknown {
    const obj: any = {};
    if (message.match_type?.$case === "single_predicate") {
      obj.single_predicate = Matcher_MatcherList_Predicate_SinglePredicate.toJSON(message.match_type.single_predicate);
    }
    if (message.match_type?.$case === "or_matcher") {
      obj.or_matcher = Matcher_MatcherList_Predicate_PredicateList.toJSON(message.match_type.or_matcher);
    }
    if (message.match_type?.$case === "and_matcher") {
      obj.and_matcher = Matcher_MatcherList_Predicate_PredicateList.toJSON(message.match_type.and_matcher);
    }
    if (message.match_type?.$case === "not_matcher") {
      obj.not_matcher = Matcher_MatcherList_Predicate.toJSON(message.match_type.not_matcher);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Matcher_MatcherList_Predicate>, I>>(base?: I): Matcher_MatcherList_Predicate {
    return Matcher_MatcherList_Predicate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Matcher_MatcherList_Predicate>, I>>(
    object: I,
  ): Matcher_MatcherList_Predicate {
    const message = createBaseMatcher_MatcherList_Predicate();
    if (
      object.match_type?.$case === "single_predicate" &&
      object.match_type?.single_predicate !== undefined &&
      object.match_type?.single_predicate !== null
    ) {
      message.match_type = {
        $case: "single_predicate",
        single_predicate: Matcher_MatcherList_Predicate_SinglePredicate.fromPartial(object.match_type.single_predicate),
      };
    }
    if (
      object.match_type?.$case === "or_matcher" &&
      object.match_type?.or_matcher !== undefined &&
      object.match_type?.or_matcher !== null
    ) {
      message.match_type = {
        $case: "or_matcher",
        or_matcher: Matcher_MatcherList_Predicate_PredicateList.fromPartial(object.match_type.or_matcher),
      };
    }
    if (
      object.match_type?.$case === "and_matcher" &&
      object.match_type?.and_matcher !== undefined &&
      object.match_type?.and_matcher !== null
    ) {
      message.match_type = {
        $case: "and_matcher",
        and_matcher: Matcher_MatcherList_Predicate_PredicateList.fromPartial(object.match_type.and_matcher),
      };
    }
    if (
      object.match_type?.$case === "not_matcher" &&
      object.match_type?.not_matcher !== undefined &&
      object.match_type?.not_matcher !== null
    ) {
      message.match_type = {
        $case: "not_matcher",
        not_matcher: Matcher_MatcherList_Predicate.fromPartial(object.match_type.not_matcher),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(Matcher_MatcherList_Predicate.$type, Matcher_MatcherList_Predicate);

function createBaseMatcher_MatcherList_Predicate_SinglePredicate(): Matcher_MatcherList_Predicate_SinglePredicate {
  return { $type: "envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.SinglePredicate", matcher: undefined };
}

export const Matcher_MatcherList_Predicate_SinglePredicate: MessageFns<
  Matcher_MatcherList_Predicate_SinglePredicate,
  "envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.SinglePredicate"
> = {
  $type: "envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.SinglePredicate" as const,

  encode(
    message: Matcher_MatcherList_Predicate_SinglePredicate,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.input !== undefined) {
      TypedExtensionConfig.encode(message.input, writer.uint32(10).fork()).join();
    }
    switch (message.matcher?.$case) {
      case "value_match":
        StringMatcher.encode(message.matcher.value_match, writer.uint32(18).fork()).join();
        break;
      case "custom_match":
        TypedExtensionConfig.encode(message.matcher.custom_match, writer.uint32(26).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Matcher_MatcherList_Predicate_SinglePredicate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatcher_MatcherList_Predicate_SinglePredicate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.input = TypedExtensionConfig.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.matcher = { $case: "value_match", value_match: StringMatcher.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.matcher = {
            $case: "custom_match",
            custom_match: TypedExtensionConfig.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Matcher_MatcherList_Predicate_SinglePredicate {
    return {
      $type: Matcher_MatcherList_Predicate_SinglePredicate.$type,
      input: isSet(object.input) ? TypedExtensionConfig.fromJSON(object.input) : undefined,
      matcher: isSet(object.value_match)
        ? { $case: "value_match", value_match: StringMatcher.fromJSON(object.value_match) }
        : isSet(object.custom_match)
        ? { $case: "custom_match", custom_match: TypedExtensionConfig.fromJSON(object.custom_match) }
        : undefined,
    };
  },

  toJSON(message: Matcher_MatcherList_Predicate_SinglePredicate): unknown {
    const obj: any = {};
    if (message.input !== undefined) {
      obj.input = TypedExtensionConfig.toJSON(message.input);
    }
    if (message.matcher?.$case === "value_match") {
      obj.value_match = StringMatcher.toJSON(message.matcher.value_match);
    }
    if (message.matcher?.$case === "custom_match") {
      obj.custom_match = TypedExtensionConfig.toJSON(message.matcher.custom_match);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Matcher_MatcherList_Predicate_SinglePredicate>, I>>(
    base?: I,
  ): Matcher_MatcherList_Predicate_SinglePredicate {
    return Matcher_MatcherList_Predicate_SinglePredicate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Matcher_MatcherList_Predicate_SinglePredicate>, I>>(
    object: I,
  ): Matcher_MatcherList_Predicate_SinglePredicate {
    const message = createBaseMatcher_MatcherList_Predicate_SinglePredicate();
    message.input = (object.input !== undefined && object.input !== null)
      ? TypedExtensionConfig.fromPartial(object.input)
      : undefined;
    if (
      object.matcher?.$case === "value_match" &&
      object.matcher?.value_match !== undefined &&
      object.matcher?.value_match !== null
    ) {
      message.matcher = { $case: "value_match", value_match: StringMatcher.fromPartial(object.matcher.value_match) };
    }
    if (
      object.matcher?.$case === "custom_match" &&
      object.matcher?.custom_match !== undefined &&
      object.matcher?.custom_match !== null
    ) {
      message.matcher = {
        $case: "custom_match",
        custom_match: TypedExtensionConfig.fromPartial(object.matcher.custom_match),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(
  Matcher_MatcherList_Predicate_SinglePredicate.$type,
  Matcher_MatcherList_Predicate_SinglePredicate,
);

function createBaseMatcher_MatcherList_Predicate_PredicateList(): Matcher_MatcherList_Predicate_PredicateList {
  return { $type: "envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.PredicateList" };
}

export const Matcher_MatcherList_Predicate_PredicateList: MessageFns<
  Matcher_MatcherList_Predicate_PredicateList,
  "envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.PredicateList"
> = {
  $type: "envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.PredicateList" as const,

  encode(
    message: Matcher_MatcherList_Predicate_PredicateList,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.predicate !== undefined && message.predicate.length !== 0) {
      for (const v of message.predicate) {
        Matcher_MatcherList_Predicate.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Matcher_MatcherList_Predicate_PredicateList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatcher_MatcherList_Predicate_PredicateList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.predicate === undefined) {
            message.predicate = [];
          }
          const el = Matcher_MatcherList_Predicate.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.predicate!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Matcher_MatcherList_Predicate_PredicateList {
    return {
      $type: Matcher_MatcherList_Predicate_PredicateList.$type,
      predicate: globalThis.Array.isArray(object?.predicate)
        ? object.predicate.map((e: any) => Matcher_MatcherList_Predicate.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: Matcher_MatcherList_Predicate_PredicateList): unknown {
    const obj: any = {};
    if (message.predicate?.length) {
      obj.predicate = message.predicate.map((e) => Matcher_MatcherList_Predicate.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Matcher_MatcherList_Predicate_PredicateList>, I>>(
    base?: I,
  ): Matcher_MatcherList_Predicate_PredicateList {
    return Matcher_MatcherList_Predicate_PredicateList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Matcher_MatcherList_Predicate_PredicateList>, I>>(
    object: I,
  ): Matcher_MatcherList_Predicate_PredicateList {
    const message = createBaseMatcher_MatcherList_Predicate_PredicateList();
    message.predicate = object.predicate?.map((e) => Matcher_MatcherList_Predicate.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(Matcher_MatcherList_Predicate_PredicateList.$type, Matcher_MatcherList_Predicate_PredicateList);

function createBaseMatcher_MatcherList_FieldMatcher(): Matcher_MatcherList_FieldMatcher {
  return { $type: "envoy.config.common.matcher.v3.Matcher.MatcherList.FieldMatcher" };
}

export const Matcher_MatcherList_FieldMatcher: MessageFns<
  Matcher_MatcherList_FieldMatcher,
  "envoy.config.common.matcher.v3.Matcher.MatcherList.FieldMatcher"
> = {
  $type: "envoy.config.common.matcher.v3.Matcher.MatcherList.FieldMatcher" as const,

  encode(message: Matcher_MatcherList_FieldMatcher, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.predicate !== undefined) {
      Matcher_MatcherList_Predicate.encode(message.predicate, writer.uint32(10).fork()).join();
    }
    if (message.on_match !== undefined) {
      Matcher_OnMatch.encode(message.on_match, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Matcher_MatcherList_FieldMatcher {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatcher_MatcherList_FieldMatcher();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.predicate = Matcher_MatcherList_Predicate.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.on_match = Matcher_OnMatch.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Matcher_MatcherList_FieldMatcher {
    return {
      $type: Matcher_MatcherList_FieldMatcher.$type,
      predicate: isSet(object.predicate) ? Matcher_MatcherList_Predicate.fromJSON(object.predicate) : undefined,
      on_match: isSet(object.on_match) ? Matcher_OnMatch.fromJSON(object.on_match) : undefined,
    };
  },

  toJSON(message: Matcher_MatcherList_FieldMatcher): unknown {
    const obj: any = {};
    if (message.predicate !== undefined) {
      obj.predicate = Matcher_MatcherList_Predicate.toJSON(message.predicate);
    }
    if (message.on_match !== undefined) {
      obj.on_match = Matcher_OnMatch.toJSON(message.on_match);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Matcher_MatcherList_FieldMatcher>, I>>(
    base?: I,
  ): Matcher_MatcherList_FieldMatcher {
    return Matcher_MatcherList_FieldMatcher.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Matcher_MatcherList_FieldMatcher>, I>>(
    object: I,
  ): Matcher_MatcherList_FieldMatcher {
    const message = createBaseMatcher_MatcherList_FieldMatcher();
    message.predicate = (object.predicate !== undefined && object.predicate !== null)
      ? Matcher_MatcherList_Predicate.fromPartial(object.predicate)
      : undefined;
    message.on_match = (object.on_match !== undefined && object.on_match !== null)
      ? Matcher_OnMatch.fromPartial(object.on_match)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Matcher_MatcherList_FieldMatcher.$type, Matcher_MatcherList_FieldMatcher);

function createBaseMatcher_MatcherTree(): Matcher_MatcherTree {
  return { $type: "envoy.config.common.matcher.v3.Matcher.MatcherTree", tree_type: undefined };
}

export const Matcher_MatcherTree: MessageFns<
  Matcher_MatcherTree,
  "envoy.config.common.matcher.v3.Matcher.MatcherTree"
> = {
  $type: "envoy.config.common.matcher.v3.Matcher.MatcherTree" as const,

  encode(message: Matcher_MatcherTree, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.input !== undefined) {
      TypedExtensionConfig.encode(message.input, writer.uint32(10).fork()).join();
    }
    switch (message.tree_type?.$case) {
      case "exact_match_map":
        Matcher_MatcherTree_MatchMap.encode(message.tree_type.exact_match_map, writer.uint32(18).fork()).join();
        break;
      case "prefix_match_map":
        Matcher_MatcherTree_MatchMap.encode(message.tree_type.prefix_match_map, writer.uint32(26).fork()).join();
        break;
      case "custom_match":
        TypedExtensionConfig.encode(message.tree_type.custom_match, writer.uint32(34).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Matcher_MatcherTree {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatcher_MatcherTree();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.input = TypedExtensionConfig.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tree_type = {
            $case: "exact_match_map",
            exact_match_map: Matcher_MatcherTree_MatchMap.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tree_type = {
            $case: "prefix_match_map",
            prefix_match_map: Matcher_MatcherTree_MatchMap.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tree_type = {
            $case: "custom_match",
            custom_match: TypedExtensionConfig.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Matcher_MatcherTree {
    return {
      $type: Matcher_MatcherTree.$type,
      input: isSet(object.input) ? TypedExtensionConfig.fromJSON(object.input) : undefined,
      tree_type: isSet(object.exact_match_map)
        ? { $case: "exact_match_map", exact_match_map: Matcher_MatcherTree_MatchMap.fromJSON(object.exact_match_map) }
        : isSet(object.prefix_match_map)
        ? {
          $case: "prefix_match_map",
          prefix_match_map: Matcher_MatcherTree_MatchMap.fromJSON(object.prefix_match_map),
        }
        : isSet(object.custom_match)
        ? { $case: "custom_match", custom_match: TypedExtensionConfig.fromJSON(object.custom_match) }
        : undefined,
    };
  },

  toJSON(message: Matcher_MatcherTree): unknown {
    const obj: any = {};
    if (message.input !== undefined) {
      obj.input = TypedExtensionConfig.toJSON(message.input);
    }
    if (message.tree_type?.$case === "exact_match_map") {
      obj.exact_match_map = Matcher_MatcherTree_MatchMap.toJSON(message.tree_type.exact_match_map);
    }
    if (message.tree_type?.$case === "prefix_match_map") {
      obj.prefix_match_map = Matcher_MatcherTree_MatchMap.toJSON(message.tree_type.prefix_match_map);
    }
    if (message.tree_type?.$case === "custom_match") {
      obj.custom_match = TypedExtensionConfig.toJSON(message.tree_type.custom_match);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Matcher_MatcherTree>, I>>(base?: I): Matcher_MatcherTree {
    return Matcher_MatcherTree.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Matcher_MatcherTree>, I>>(object: I): Matcher_MatcherTree {
    const message = createBaseMatcher_MatcherTree();
    message.input = (object.input !== undefined && object.input !== null)
      ? TypedExtensionConfig.fromPartial(object.input)
      : undefined;
    if (
      object.tree_type?.$case === "exact_match_map" &&
      object.tree_type?.exact_match_map !== undefined &&
      object.tree_type?.exact_match_map !== null
    ) {
      message.tree_type = {
        $case: "exact_match_map",
        exact_match_map: Matcher_MatcherTree_MatchMap.fromPartial(object.tree_type.exact_match_map),
      };
    }
    if (
      object.tree_type?.$case === "prefix_match_map" &&
      object.tree_type?.prefix_match_map !== undefined &&
      object.tree_type?.prefix_match_map !== null
    ) {
      message.tree_type = {
        $case: "prefix_match_map",
        prefix_match_map: Matcher_MatcherTree_MatchMap.fromPartial(object.tree_type.prefix_match_map),
      };
    }
    if (
      object.tree_type?.$case === "custom_match" &&
      object.tree_type?.custom_match !== undefined &&
      object.tree_type?.custom_match !== null
    ) {
      message.tree_type = {
        $case: "custom_match",
        custom_match: TypedExtensionConfig.fromPartial(object.tree_type.custom_match),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(Matcher_MatcherTree.$type, Matcher_MatcherTree);

function createBaseMatcher_MatcherTree_MatchMap(): Matcher_MatcherTree_MatchMap {
  return { $type: "envoy.config.common.matcher.v3.Matcher.MatcherTree.MatchMap" };
}

export const Matcher_MatcherTree_MatchMap: MessageFns<
  Matcher_MatcherTree_MatchMap,
  "envoy.config.common.matcher.v3.Matcher.MatcherTree.MatchMap"
> = {
  $type: "envoy.config.common.matcher.v3.Matcher.MatcherTree.MatchMap" as const,

  encode(message: Matcher_MatcherTree_MatchMap, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    (message.map || new Map()).forEach((value, key) => {
      Matcher_MatcherTree_MatchMap_MapEntry.encode({
        $type: "envoy.config.common.matcher.v3.Matcher.MatcherTree.MatchMap.MapEntry",
        key: key as any,
        value,
      }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Matcher_MatcherTree_MatchMap {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatcher_MatcherTree_MatchMap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = Matcher_MatcherTree_MatchMap_MapEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            if (message.map === undefined) {
              message.map = new Map();
            }
            message.map!.set(entry1.key, entry1.value);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Matcher_MatcherTree_MatchMap {
    return {
      $type: Matcher_MatcherTree_MatchMap.$type,
      map: isObject(object.map)
        ? Object.entries(object.map).reduce<Map<string, Matcher_OnMatch>>((acc, [key, value]) => {
          acc.set(key, Matcher_OnMatch.fromJSON(value));
          return acc;
        }, new Map())
        : undefined,
    };
  },

  toJSON(message: Matcher_MatcherTree_MatchMap): unknown {
    const obj: any = {};
    if (message.map?.size) {
      obj.map = {};
      message.map.forEach((v, k) => {
        obj.map[k] = Matcher_OnMatch.toJSON(v);
      });
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Matcher_MatcherTree_MatchMap>, I>>(base?: I): Matcher_MatcherTree_MatchMap {
    return Matcher_MatcherTree_MatchMap.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Matcher_MatcherTree_MatchMap>, I>>(object: I): Matcher_MatcherTree_MatchMap {
    const message = createBaseMatcher_MatcherTree_MatchMap();
    message.map = (object.map === undefined || object.map === null) ? undefined : (() => {
      const m = new Map();
      (object.map as Map<string, Matcher_OnMatch> ?? new Map()).forEach((value, key) => {
        if (value !== undefined) {
          m.set(key, Matcher_OnMatch.fromPartial(value));
        }
      });
      return m;
    })();
    return message;
  },
};

messageTypeRegistry.set(Matcher_MatcherTree_MatchMap.$type, Matcher_MatcherTree_MatchMap);

function createBaseMatcher_MatcherTree_MatchMap_MapEntry(): Matcher_MatcherTree_MatchMap_MapEntry {
  return { $type: "envoy.config.common.matcher.v3.Matcher.MatcherTree.MatchMap.MapEntry", key: "" };
}

export const Matcher_MatcherTree_MatchMap_MapEntry: MessageFns<
  Matcher_MatcherTree_MatchMap_MapEntry,
  "envoy.config.common.matcher.v3.Matcher.MatcherTree.MatchMap.MapEntry"
> = {
  $type: "envoy.config.common.matcher.v3.Matcher.MatcherTree.MatchMap.MapEntry" as const,

  encode(message: Matcher_MatcherTree_MatchMap_MapEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Matcher_OnMatch.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Matcher_MatcherTree_MatchMap_MapEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatcher_MatcherTree_MatchMap_MapEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Matcher_OnMatch.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Matcher_MatcherTree_MatchMap_MapEntry {
    return {
      $type: Matcher_MatcherTree_MatchMap_MapEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Matcher_OnMatch.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Matcher_MatcherTree_MatchMap_MapEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Matcher_OnMatch.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Matcher_MatcherTree_MatchMap_MapEntry>, I>>(
    base?: I,
  ): Matcher_MatcherTree_MatchMap_MapEntry {
    return Matcher_MatcherTree_MatchMap_MapEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Matcher_MatcherTree_MatchMap_MapEntry>, I>>(
    object: I,
  ): Matcher_MatcherTree_MatchMap_MapEntry {
    const message = createBaseMatcher_MatcherTree_MatchMap_MapEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Matcher_OnMatch.fromPartial(object.value)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Matcher_MatcherTree_MatchMap_MapEntry.$type, Matcher_MatcherTree_MatchMap_MapEntry);

function createBaseMatchPredicate(): MatchPredicate {
  return { $type: "envoy.config.common.matcher.v3.MatchPredicate", rule: undefined };
}

export const MatchPredicate: MessageFns<MatchPredicate, "envoy.config.common.matcher.v3.MatchPredicate"> = {
  $type: "envoy.config.common.matcher.v3.MatchPredicate" as const,

  encode(message: MatchPredicate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.rule?.$case) {
      case "or_match":
        MatchPredicate_MatchSet.encode(message.rule.or_match, writer.uint32(10).fork()).join();
        break;
      case "and_match":
        MatchPredicate_MatchSet.encode(message.rule.and_match, writer.uint32(18).fork()).join();
        break;
      case "not_match":
        MatchPredicate.encode(message.rule.not_match, writer.uint32(26).fork()).join();
        break;
      case "any_match":
        writer.uint32(32).bool(message.rule.any_match);
        break;
      case "http_request_headers_match":
        HttpHeadersMatch.encode(message.rule.http_request_headers_match, writer.uint32(42).fork()).join();
        break;
      case "http_request_trailers_match":
        HttpHeadersMatch.encode(message.rule.http_request_trailers_match, writer.uint32(50).fork()).join();
        break;
      case "http_response_headers_match":
        HttpHeadersMatch.encode(message.rule.http_response_headers_match, writer.uint32(58).fork()).join();
        break;
      case "http_response_trailers_match":
        HttpHeadersMatch.encode(message.rule.http_response_trailers_match, writer.uint32(66).fork()).join();
        break;
      case "http_request_generic_body_match":
        HttpGenericBodyMatch.encode(message.rule.http_request_generic_body_match, writer.uint32(74).fork()).join();
        break;
      case "http_response_generic_body_match":
        HttpGenericBodyMatch.encode(message.rule.http_response_generic_body_match, writer.uint32(82).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MatchPredicate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatchPredicate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rule = { $case: "or_match", or_match: MatchPredicate_MatchSet.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rule = { $case: "and_match", and_match: MatchPredicate_MatchSet.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rule = { $case: "not_match", not_match: MatchPredicate.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.rule = { $case: "any_match", any_match: reader.bool() };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.rule = {
            $case: "http_request_headers_match",
            http_request_headers_match: HttpHeadersMatch.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.rule = {
            $case: "http_request_trailers_match",
            http_request_trailers_match: HttpHeadersMatch.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.rule = {
            $case: "http_response_headers_match",
            http_response_headers_match: HttpHeadersMatch.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.rule = {
            $case: "http_response_trailers_match",
            http_response_trailers_match: HttpHeadersMatch.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.rule = {
            $case: "http_request_generic_body_match",
            http_request_generic_body_match: HttpGenericBodyMatch.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.rule = {
            $case: "http_response_generic_body_match",
            http_response_generic_body_match: HttpGenericBodyMatch.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MatchPredicate {
    return {
      $type: MatchPredicate.$type,
      rule: isSet(object.or_match)
        ? { $case: "or_match", or_match: MatchPredicate_MatchSet.fromJSON(object.or_match) }
        : isSet(object.and_match)
        ? { $case: "and_match", and_match: MatchPredicate_MatchSet.fromJSON(object.and_match) }
        : isSet(object.not_match)
        ? { $case: "not_match", not_match: MatchPredicate.fromJSON(object.not_match) }
        : isSet(object.any_match)
        ? { $case: "any_match", any_match: globalThis.Boolean(object.any_match) }
        : isSet(object.http_request_headers_match)
        ? {
          $case: "http_request_headers_match",
          http_request_headers_match: HttpHeadersMatch.fromJSON(object.http_request_headers_match),
        }
        : isSet(object.http_request_trailers_match)
        ? {
          $case: "http_request_trailers_match",
          http_request_trailers_match: HttpHeadersMatch.fromJSON(object.http_request_trailers_match),
        }
        : isSet(object.http_response_headers_match)
        ? {
          $case: "http_response_headers_match",
          http_response_headers_match: HttpHeadersMatch.fromJSON(object.http_response_headers_match),
        }
        : isSet(object.http_response_trailers_match)
        ? {
          $case: "http_response_trailers_match",
          http_response_trailers_match: HttpHeadersMatch.fromJSON(object.http_response_trailers_match),
        }
        : isSet(object.http_request_generic_body_match)
        ? {
          $case: "http_request_generic_body_match",
          http_request_generic_body_match: HttpGenericBodyMatch.fromJSON(object.http_request_generic_body_match),
        }
        : isSet(object.http_response_generic_body_match)
        ? {
          $case: "http_response_generic_body_match",
          http_response_generic_body_match: HttpGenericBodyMatch.fromJSON(object.http_response_generic_body_match),
        }
        : undefined,
    };
  },

  toJSON(message: MatchPredicate): unknown {
    const obj: any = {};
    if (message.rule?.$case === "or_match") {
      obj.or_match = MatchPredicate_MatchSet.toJSON(message.rule.or_match);
    }
    if (message.rule?.$case === "and_match") {
      obj.and_match = MatchPredicate_MatchSet.toJSON(message.rule.and_match);
    }
    if (message.rule?.$case === "not_match") {
      obj.not_match = MatchPredicate.toJSON(message.rule.not_match);
    }
    if (message.rule?.$case === "any_match") {
      obj.any_match = message.rule.any_match;
    }
    if (message.rule?.$case === "http_request_headers_match") {
      obj.http_request_headers_match = HttpHeadersMatch.toJSON(message.rule.http_request_headers_match);
    }
    if (message.rule?.$case === "http_request_trailers_match") {
      obj.http_request_trailers_match = HttpHeadersMatch.toJSON(message.rule.http_request_trailers_match);
    }
    if (message.rule?.$case === "http_response_headers_match") {
      obj.http_response_headers_match = HttpHeadersMatch.toJSON(message.rule.http_response_headers_match);
    }
    if (message.rule?.$case === "http_response_trailers_match") {
      obj.http_response_trailers_match = HttpHeadersMatch.toJSON(message.rule.http_response_trailers_match);
    }
    if (message.rule?.$case === "http_request_generic_body_match") {
      obj.http_request_generic_body_match = HttpGenericBodyMatch.toJSON(message.rule.http_request_generic_body_match);
    }
    if (message.rule?.$case === "http_response_generic_body_match") {
      obj.http_response_generic_body_match = HttpGenericBodyMatch.toJSON(message.rule.http_response_generic_body_match);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MatchPredicate>, I>>(base?: I): MatchPredicate {
    return MatchPredicate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MatchPredicate>, I>>(object: I): MatchPredicate {
    const message = createBaseMatchPredicate();
    if (object.rule?.$case === "or_match" && object.rule?.or_match !== undefined && object.rule?.or_match !== null) {
      message.rule = { $case: "or_match", or_match: MatchPredicate_MatchSet.fromPartial(object.rule.or_match) };
    }
    if (object.rule?.$case === "and_match" && object.rule?.and_match !== undefined && object.rule?.and_match !== null) {
      message.rule = { $case: "and_match", and_match: MatchPredicate_MatchSet.fromPartial(object.rule.and_match) };
    }
    if (object.rule?.$case === "not_match" && object.rule?.not_match !== undefined && object.rule?.not_match !== null) {
      message.rule = { $case: "not_match", not_match: MatchPredicate.fromPartial(object.rule.not_match) };
    }
    if (object.rule?.$case === "any_match" && object.rule?.any_match !== undefined && object.rule?.any_match !== null) {
      message.rule = { $case: "any_match", any_match: object.rule.any_match };
    }
    if (
      object.rule?.$case === "http_request_headers_match" &&
      object.rule?.http_request_headers_match !== undefined &&
      object.rule?.http_request_headers_match !== null
    ) {
      message.rule = {
        $case: "http_request_headers_match",
        http_request_headers_match: HttpHeadersMatch.fromPartial(object.rule.http_request_headers_match),
      };
    }
    if (
      object.rule?.$case === "http_request_trailers_match" &&
      object.rule?.http_request_trailers_match !== undefined &&
      object.rule?.http_request_trailers_match !== null
    ) {
      message.rule = {
        $case: "http_request_trailers_match",
        http_request_trailers_match: HttpHeadersMatch.fromPartial(object.rule.http_request_trailers_match),
      };
    }
    if (
      object.rule?.$case === "http_response_headers_match" &&
      object.rule?.http_response_headers_match !== undefined &&
      object.rule?.http_response_headers_match !== null
    ) {
      message.rule = {
        $case: "http_response_headers_match",
        http_response_headers_match: HttpHeadersMatch.fromPartial(object.rule.http_response_headers_match),
      };
    }
    if (
      object.rule?.$case === "http_response_trailers_match" &&
      object.rule?.http_response_trailers_match !== undefined &&
      object.rule?.http_response_trailers_match !== null
    ) {
      message.rule = {
        $case: "http_response_trailers_match",
        http_response_trailers_match: HttpHeadersMatch.fromPartial(object.rule.http_response_trailers_match),
      };
    }
    if (
      object.rule?.$case === "http_request_generic_body_match" &&
      object.rule?.http_request_generic_body_match !== undefined &&
      object.rule?.http_request_generic_body_match !== null
    ) {
      message.rule = {
        $case: "http_request_generic_body_match",
        http_request_generic_body_match: HttpGenericBodyMatch.fromPartial(object.rule.http_request_generic_body_match),
      };
    }
    if (
      object.rule?.$case === "http_response_generic_body_match" &&
      object.rule?.http_response_generic_body_match !== undefined &&
      object.rule?.http_response_generic_body_match !== null
    ) {
      message.rule = {
        $case: "http_response_generic_body_match",
        http_response_generic_body_match: HttpGenericBodyMatch.fromPartial(
          object.rule.http_response_generic_body_match,
        ),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(MatchPredicate.$type, MatchPredicate);

function createBaseMatchPredicate_MatchSet(): MatchPredicate_MatchSet {
  return { $type: "envoy.config.common.matcher.v3.MatchPredicate.MatchSet" };
}

export const MatchPredicate_MatchSet: MessageFns<
  MatchPredicate_MatchSet,
  "envoy.config.common.matcher.v3.MatchPredicate.MatchSet"
> = {
  $type: "envoy.config.common.matcher.v3.MatchPredicate.MatchSet" as const,

  encode(message: MatchPredicate_MatchSet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rules !== undefined && message.rules.length !== 0) {
      for (const v of message.rules) {
        MatchPredicate.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MatchPredicate_MatchSet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatchPredicate_MatchSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.rules === undefined) {
            message.rules = [];
          }
          const el = MatchPredicate.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.rules!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MatchPredicate_MatchSet {
    return {
      $type: MatchPredicate_MatchSet.$type,
      rules: globalThis.Array.isArray(object?.rules)
        ? object.rules.map((e: any) => MatchPredicate.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: MatchPredicate_MatchSet): unknown {
    const obj: any = {};
    if (message.rules?.length) {
      obj.rules = message.rules.map((e) => MatchPredicate.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MatchPredicate_MatchSet>, I>>(base?: I): MatchPredicate_MatchSet {
    return MatchPredicate_MatchSet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MatchPredicate_MatchSet>, I>>(object: I): MatchPredicate_MatchSet {
    const message = createBaseMatchPredicate_MatchSet();
    message.rules = object.rules?.map((e) => MatchPredicate.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(MatchPredicate_MatchSet.$type, MatchPredicate_MatchSet);

function createBaseHttpHeadersMatch(): HttpHeadersMatch {
  return { $type: "envoy.config.common.matcher.v3.HttpHeadersMatch" };
}

export const HttpHeadersMatch: MessageFns<HttpHeadersMatch, "envoy.config.common.matcher.v3.HttpHeadersMatch"> = {
  $type: "envoy.config.common.matcher.v3.HttpHeadersMatch" as const,

  encode(message: HttpHeadersMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.headers !== undefined && message.headers.length !== 0) {
      for (const v of message.headers) {
        HeaderMatcher.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpHeadersMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpHeadersMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.headers === undefined) {
            message.headers = [];
          }
          const el = HeaderMatcher.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.headers!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpHeadersMatch {
    return {
      $type: HttpHeadersMatch.$type,
      headers: globalThis.Array.isArray(object?.headers)
        ? object.headers.map((e: any) => HeaderMatcher.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: HttpHeadersMatch): unknown {
    const obj: any = {};
    if (message.headers?.length) {
      obj.headers = message.headers.map((e) => HeaderMatcher.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpHeadersMatch>, I>>(base?: I): HttpHeadersMatch {
    return HttpHeadersMatch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpHeadersMatch>, I>>(object: I): HttpHeadersMatch {
    const message = createBaseHttpHeadersMatch();
    message.headers = object.headers?.map((e) => HeaderMatcher.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(HttpHeadersMatch.$type, HttpHeadersMatch);

function createBaseHttpGenericBodyMatch(): HttpGenericBodyMatch {
  return { $type: "envoy.config.common.matcher.v3.HttpGenericBodyMatch" };
}

export const HttpGenericBodyMatch: MessageFns<
  HttpGenericBodyMatch,
  "envoy.config.common.matcher.v3.HttpGenericBodyMatch"
> = {
  $type: "envoy.config.common.matcher.v3.HttpGenericBodyMatch" as const,

  encode(message: HttpGenericBodyMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bytes_limit !== undefined && message.bytes_limit !== 0) {
      writer.uint32(8).uint32(message.bytes_limit);
    }
    if (message.patterns !== undefined && message.patterns.length !== 0) {
      for (const v of message.patterns) {
        HttpGenericBodyMatch_GenericTextMatch.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpGenericBodyMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpGenericBodyMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.bytes_limit = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.patterns === undefined) {
            message.patterns = [];
          }
          const el = HttpGenericBodyMatch_GenericTextMatch.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.patterns!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpGenericBodyMatch {
    return {
      $type: HttpGenericBodyMatch.$type,
      bytes_limit: isSet(object.bytes_limit) ? globalThis.Number(object.bytes_limit) : undefined,
      patterns: globalThis.Array.isArray(object?.patterns)
        ? object.patterns.map((e: any) => HttpGenericBodyMatch_GenericTextMatch.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: HttpGenericBodyMatch): unknown {
    const obj: any = {};
    if (message.bytes_limit !== undefined) {
      obj.bytes_limit = Math.round(message.bytes_limit);
    }
    if (message.patterns?.length) {
      obj.patterns = message.patterns.map((e) => HttpGenericBodyMatch_GenericTextMatch.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpGenericBodyMatch>, I>>(base?: I): HttpGenericBodyMatch {
    return HttpGenericBodyMatch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpGenericBodyMatch>, I>>(object: I): HttpGenericBodyMatch {
    const message = createBaseHttpGenericBodyMatch();
    message.bytes_limit = object.bytes_limit ?? undefined;
    message.patterns = object.patterns?.map((e) => HttpGenericBodyMatch_GenericTextMatch.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(HttpGenericBodyMatch.$type, HttpGenericBodyMatch);

function createBaseHttpGenericBodyMatch_GenericTextMatch(): HttpGenericBodyMatch_GenericTextMatch {
  return { $type: "envoy.config.common.matcher.v3.HttpGenericBodyMatch.GenericTextMatch", rule: undefined };
}

export const HttpGenericBodyMatch_GenericTextMatch: MessageFns<
  HttpGenericBodyMatch_GenericTextMatch,
  "envoy.config.common.matcher.v3.HttpGenericBodyMatch.GenericTextMatch"
> = {
  $type: "envoy.config.common.matcher.v3.HttpGenericBodyMatch.GenericTextMatch" as const,

  encode(message: HttpGenericBodyMatch_GenericTextMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.rule?.$case) {
      case "string_match":
        writer.uint32(10).string(message.rule.string_match);
        break;
      case "binary_match":
        writer.uint32(18).bytes(message.rule.binary_match);
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpGenericBodyMatch_GenericTextMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpGenericBodyMatch_GenericTextMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rule = { $case: "string_match", string_match: reader.string() };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rule = { $case: "binary_match", binary_match: reader.bytes() };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpGenericBodyMatch_GenericTextMatch {
    return {
      $type: HttpGenericBodyMatch_GenericTextMatch.$type,
      rule: isSet(object.string_match)
        ? { $case: "string_match", string_match: globalThis.String(object.string_match) }
        : isSet(object.binary_match)
        ? { $case: "binary_match", binary_match: bytesFromBase64(object.binary_match) }
        : undefined,
    };
  },

  toJSON(message: HttpGenericBodyMatch_GenericTextMatch): unknown {
    const obj: any = {};
    if (message.rule?.$case === "string_match") {
      obj.string_match = message.rule.string_match;
    }
    if (message.rule?.$case === "binary_match") {
      obj.binary_match = base64FromBytes(message.rule.binary_match);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpGenericBodyMatch_GenericTextMatch>, I>>(
    base?: I,
  ): HttpGenericBodyMatch_GenericTextMatch {
    return HttpGenericBodyMatch_GenericTextMatch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpGenericBodyMatch_GenericTextMatch>, I>>(
    object: I,
  ): HttpGenericBodyMatch_GenericTextMatch {
    const message = createBaseHttpGenericBodyMatch_GenericTextMatch();
    if (
      object.rule?.$case === "string_match" &&
      object.rule?.string_match !== undefined &&
      object.rule?.string_match !== null
    ) {
      message.rule = { $case: "string_match", string_match: object.rule.string_match };
    }
    if (
      object.rule?.$case === "binary_match" &&
      object.rule?.binary_match !== undefined &&
      object.rule?.binary_match !== null
    ) {
      message.rule = { $case: "binary_match", binary_match: object.rule.binary_match };
    }
    return message;
  },
};

messageTypeRegistry.set(HttpGenericBodyMatch_GenericTextMatch.$type, HttpGenericBodyMatch_GenericTextMatch);

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
