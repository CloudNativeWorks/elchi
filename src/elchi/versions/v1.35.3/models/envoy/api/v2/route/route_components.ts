// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/api/v2/route/route_components.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Any } from "../../../../google/protobuf/any";
import { Duration } from "../../../../google/protobuf/duration";
import { Struct } from "../../../../google/protobuf/struct";
import { BoolValue, UInt32Value } from "../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../typeRegistry";
import { RegexMatchAndSubstitute, RegexMatcher } from "../../../type/matcher/regex";
import { StringMatcher } from "../../../type/matcher/string";
import { FractionalPercent } from "../../../type/percent";
import { Int64Range } from "../../../type/range";
import { CustomTag } from "../../../type/tracing/v2/custom_tag";
import {
  DataSource,
  HeaderValueOption,
  Metadata,
  RequestMethod,
  requestMethodFromJSON,
  requestMethodToJSON,
  requestMethodToNumber,
  RoutingPriority,
  routingPriorityFromJSON,
  routingPriorityToJSON,
  routingPriorityToNumber,
  RuntimeFractionalPercent,
} from "../core/base";

export const protobufPackage = "envoy.api.v2.route";

/**
 * The top level element in the routing configuration is a virtual host. Each virtual host has
 * a logical name as well as a set of domains that get routed to it based on the incoming request's
 * host header. This allows a single listener to service multiple top level domain path trees. Once
 * a virtual host is selected based on the domain, the routes are processed in order to see which
 * upstream cluster to route to or whether to perform a redirect.
 * [#next-free-field: 21]
 */
export interface VirtualHost {
  $type: "envoy.api.v2.route.VirtualHost";
  /**
   * The logical name of the virtual host. This is used when emitting certain
   * statistics but is not relevant for routing.
   */
  name?:
    | string
    | undefined;
  /**
   * A list of domains (host/authority header) that will be matched to this
   * virtual host. Wildcard hosts are supported in the suffix or prefix form.
   *
   * Domain search order:
   *  1. Exact domain names: ``www.foo.com``.
   *  2. Suffix domain wildcards: ``*.foo.com`` or ``*-bar.foo.com``.
   *  3. Prefix domain wildcards: ``foo.*`` or ``foo-*``.
   *  4. Special wildcard ``*`` matching any domain.
   *
   * .. note::
   *
   *   The wildcard will not match the empty string.
   *   e.g. ``*-bar.foo.com`` will match ``baz-bar.foo.com`` but not ``-bar.foo.com``.
   *   The longest wildcards match first.
   *   Only a single virtual host in the entire route configuration can match on ``*``. A domain
   *   must be unique across all virtual hosts or the config will fail to load.
   *
   * Domains cannot contain control characters. This is validated by the well_known_regex HTTP_HEADER_VALUE.
   */
  domains?:
    | string[]
    | undefined;
  /**
   * The list of routes that will be matched, in order, for incoming requests.
   * The first route that matches will be used.
   */
  routes?:
    | Route[]
    | undefined;
  /**
   * Specifies the type of TLS enforcement the virtual host expects. If this option is not
   * specified, there is no TLS requirement for the virtual host.
   */
  require_tls?:
    | VirtualHost_TlsRequirementType
    | undefined;
  /**
   * A list of virtual clusters defined for this virtual host. Virtual clusters
   * are used for additional statistics gathering.
   */
  virtual_clusters?:
    | VirtualCluster[]
    | undefined;
  /**
   * Specifies a set of rate limit configurations that will be applied to the
   * virtual host.
   */
  rate_limits?:
    | RateLimit[]
    | undefined;
  /**
   * Specifies a list of HTTP headers that should be added to each request
   * handled by this virtual host. Headers specified at this level are applied
   * after headers from enclosed :ref:`envoy_api_msg_route.Route` and before headers from the
   * enclosing :ref:`envoy_api_msg_RouteConfiguration`. For more information, including
   * details on header value syntax, see the documentation on :ref:`custom request headers
   * <config_http_conn_man_headers_custom_request_headers>`.
   */
  request_headers_to_add?:
    | HeaderValueOption[]
    | undefined;
  /**
   * Specifies a list of HTTP headers that should be removed from each request
   * handled by this virtual host.
   */
  request_headers_to_remove?:
    | string[]
    | undefined;
  /**
   * Specifies a list of HTTP headers that should be added to each response
   * handled by this virtual host. Headers specified at this level are applied
   * after headers from enclosed :ref:`envoy_api_msg_route.Route` and before headers from the
   * enclosing :ref:`envoy_api_msg_RouteConfiguration`. For more information, including
   * details on header value syntax, see the documentation on :ref:`custom request headers
   * <config_http_conn_man_headers_custom_request_headers>`.
   */
  response_headers_to_add?:
    | HeaderValueOption[]
    | undefined;
  /**
   * Specifies a list of HTTP headers that should be removed from each response
   * handled by this virtual host.
   */
  response_headers_to_remove?:
    | string[]
    | undefined;
  /** Indicates that the virtual host has a CORS policy. */
  cors?:
    | CorsPolicy
    | undefined;
  /**
   * The per_filter_config field can be used to provide virtual host-specific
   * configurations for filters. The key should match the filter name, such as
   * *envoy.filters.http.buffer* for the HTTP buffer filter. Use of this field is filter
   * specific; see the :ref:`HTTP filter documentation <config_http_filters>`
   * for if and how it is utilized.
   *
   * @deprecated
   */
  per_filter_config?:
    | Map<string, { [key: string]: any } | undefined>
    | undefined;
  /**
   * The per_filter_config field can be used to provide virtual host-specific
   * configurations for filters. The key should match the filter name, such as
   * *envoy.filters.http.buffer* for the HTTP buffer filter. Use of this field is filter
   * specific; see the :ref:`HTTP filter documentation <config_http_filters>`
   * for if and how it is utilized.
   */
  typed_per_filter_config?:
    | Map<string, Any>
    | undefined;
  /**
   * Decides whether the :ref:`x-envoy-attempt-count
   * <config_http_filters_router_x-envoy-attempt-count>` header should be included
   * in the upstream request. Setting this option will cause it to override any existing header
   * value, so in the case of two Envoys on the request path with this option enabled, the upstream
   * will see the attempt count as perceived by the second Envoy. Defaults to false.
   * This header is unaffected by the
   * :ref:`suppress_envoy_headers
   * <envoy_api_field_config.filter.http.router.v2.Router.suppress_envoy_headers>` flag.
   *
   * [#next-major-version: rename to include_attempt_count_in_request.]
   */
  include_request_attempt_count?:
    | boolean
    | undefined;
  /**
   * Decides whether the :ref:`x-envoy-attempt-count
   * <config_http_filters_router_x-envoy-attempt-count>` header should be included
   * in the downstream response. Setting this option will cause the router to override any existing header
   * value, so in the case of two Envoys on the request path with this option enabled, the downstream
   * will see the attempt count as perceived by the Envoy closest upstream from itself. Defaults to false.
   * This header is unaffected by the
   * :ref:`suppress_envoy_headers
   * <envoy_api_field_config.filter.http.router.v2.Router.suppress_envoy_headers>` flag.
   */
  include_attempt_count_in_response?:
    | boolean
    | undefined;
  /**
   * Indicates the retry policy for all routes in this virtual host. Note that setting a
   * route level entry will take precedence over this config and it'll be treated
   * independently (e.g.: values are not inherited).
   */
  retry_policy?:
    | RetryPolicy
    | undefined;
  /**
   * [#not-implemented-hide:]
   * Specifies the configuration for retry policy extension. Note that setting a route level entry
   * will take precedence over this config and it'll be treated independently (e.g.: values are not
   * inherited). :ref:`Retry policy <envoy_api_field_route.VirtualHost.retry_policy>` should not be
   * set if this field is used.
   */
  retry_policy_typed_config?:
    | Any
    | undefined;
  /**
   * Indicates the hedge policy for all routes in this virtual host. Note that setting a
   * route level entry will take precedence over this config and it'll be treated
   * independently (e.g.: values are not inherited).
   */
  hedge_policy?:
    | HedgePolicy
    | undefined;
  /**
   * The maximum bytes which will be buffered for retries and shadowing.
   * If set and a route-specific limit is not set, the bytes actually buffered will be the minimum
   * value of this and the listener per_connection_buffer_limit_bytes.
   */
  per_request_buffer_limit_bytes?: number | undefined;
}

export enum VirtualHost_TlsRequirementType {
  /** NONE - No TLS requirement for the virtual host. */
  NONE = "NONE",
  /**
   * EXTERNAL_ONLY - External requests must use TLS. If a request is external and it is not
   * using TLS, a 301 redirect will be sent telling the client to use HTTPS.
   */
  EXTERNAL_ONLY = "EXTERNAL_ONLY",
  /**
   * ALL - All requests must use TLS. If a request is not using TLS, a 301 redirect
   * will be sent telling the client to use HTTPS.
   */
  ALL = "ALL",
}

export function virtualHost_TlsRequirementTypeFromJSON(object: any): VirtualHost_TlsRequirementType {
  switch (object) {
    case 0:
    case "NONE":
      return VirtualHost_TlsRequirementType.NONE;
    case 1:
    case "EXTERNAL_ONLY":
      return VirtualHost_TlsRequirementType.EXTERNAL_ONLY;
    case 2:
    case "ALL":
      return VirtualHost_TlsRequirementType.ALL;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum VirtualHost_TlsRequirementType");
  }
}

export function virtualHost_TlsRequirementTypeToJSON(object: VirtualHost_TlsRequirementType): string {
  switch (object) {
    case VirtualHost_TlsRequirementType.NONE:
      return "NONE";
    case VirtualHost_TlsRequirementType.EXTERNAL_ONLY:
      return "EXTERNAL_ONLY";
    case VirtualHost_TlsRequirementType.ALL:
      return "ALL";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum VirtualHost_TlsRequirementType");
  }
}

export function virtualHost_TlsRequirementTypeToNumber(object: VirtualHost_TlsRequirementType): number {
  switch (object) {
    case VirtualHost_TlsRequirementType.NONE:
      return 0;
    case VirtualHost_TlsRequirementType.EXTERNAL_ONLY:
      return 1;
    case VirtualHost_TlsRequirementType.ALL:
      return 2;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum VirtualHost_TlsRequirementType");
  }
}

export interface VirtualHost_PerFilterConfigEntry {
  $type: "envoy.api.v2.route.VirtualHost.PerFilterConfigEntry";
  key: string;
  value?: { [key: string]: any } | undefined;
}

export interface VirtualHost_TypedPerFilterConfigEntry {
  $type: "envoy.api.v2.route.VirtualHost.TypedPerFilterConfigEntry";
  key: string;
  value?: Any | undefined;
}

/** A filter-defined action type. */
export interface FilterAction {
  $type: "envoy.api.v2.route.FilterAction";
  action?: Any | undefined;
}

/**
 * A route is both a specification of how to match a request as well as an indication of what to do
 * next (e.g., redirect, forward, rewrite, etc.).
 *
 * .. attention::
 *
 *   Envoy supports routing on HTTP method via :ref:`header matching
 *   <envoy_api_msg_route.HeaderMatcher>`.
 * [#next-free-field: 18]
 */
export interface Route {
  $type: "envoy.api.v2.route.Route";
  /** Name for the route. */
  name?:
    | string
    | undefined;
  /** Route matching parameters. */
  match?: RouteMatch | undefined;
  action?:
    | //
    /** Route request to some upstream cluster. */
    { $case: "route"; route: RouteAction }
    | //
    /** Return a redirect. */
    { $case: "redirect"; redirect: RedirectAction }
    | //
    /** Return an arbitrary HTTP response directly, without proxying. */
    { $case: "direct_response"; direct_response: DirectResponseAction }
    | //
    /**
     * [#not-implemented-hide:]
     * If true, a filter will define the action (e.g., it could dynamically generate the
     * RouteAction).
     */
    { $case: "filter_action"; filter_action: FilterAction }
    | undefined;
  /**
   * The Metadata field can be used to provide additional information
   * about the route. It can be used for configuration, stats, and logging.
   * The metadata should go under the filter namespace that will need it.
   * For instance, if the metadata is intended for the Router filter,
   * the filter name should be specified as *envoy.filters.http.router*.
   */
  metadata?:
    | Metadata
    | undefined;
  /** Decorator for the matched route. */
  decorator?:
    | Decorator
    | undefined;
  /**
   * The per_filter_config field can be used to provide route-specific
   * configurations for filters. The key should match the filter name, such as
   * *envoy.filters.http.buffer* for the HTTP buffer filter. Use of this field is filter
   * specific; see the :ref:`HTTP filter documentation <config_http_filters>` for
   * if and how it is utilized.
   *
   * @deprecated
   */
  per_filter_config?:
    | Map<string, { [key: string]: any } | undefined>
    | undefined;
  /**
   * The typed_per_filter_config field can be used to provide route-specific
   * configurations for filters. The key should match the filter name, such as
   * *envoy.filters.http.buffer* for the HTTP buffer filter. Use of this field is filter
   * specific; see the :ref:`HTTP filter documentation <config_http_filters>` for
   * if and how it is utilized.
   */
  typed_per_filter_config?:
    | Map<string, Any>
    | undefined;
  /**
   * Specifies a set of headers that will be added to requests matching this
   * route. Headers specified at this level are applied before headers from the
   * enclosing :ref:`envoy_api_msg_route.VirtualHost` and
   * :ref:`envoy_api_msg_RouteConfiguration`. For more information, including details on
   * header value syntax, see the documentation on :ref:`custom request headers
   * <config_http_conn_man_headers_custom_request_headers>`.
   */
  request_headers_to_add?:
    | HeaderValueOption[]
    | undefined;
  /**
   * Specifies a list of HTTP headers that should be removed from each request
   * matching this route.
   */
  request_headers_to_remove?:
    | string[]
    | undefined;
  /**
   * Specifies a set of headers that will be added to responses to requests
   * matching this route. Headers specified at this level are applied before
   * headers from the enclosing :ref:`envoy_api_msg_route.VirtualHost` and
   * :ref:`envoy_api_msg_RouteConfiguration`. For more information, including
   * details on header value syntax, see the documentation on
   * :ref:`custom request headers <config_http_conn_man_headers_custom_request_headers>`.
   */
  response_headers_to_add?:
    | HeaderValueOption[]
    | undefined;
  /**
   * Specifies a list of HTTP headers that should be removed from each response
   * to requests matching this route.
   */
  response_headers_to_remove?:
    | string[]
    | undefined;
  /**
   * Presence of the object defines whether the connection manager's tracing configuration
   * is overridden by this route specific instance.
   */
  tracing?:
    | Tracing
    | undefined;
  /**
   * The maximum bytes which will be buffered for retries and shadowing.
   * If set, the bytes actually buffered will be the minimum value of this and the
   * listener per_connection_buffer_limit_bytes.
   */
  per_request_buffer_limit_bytes?: number | undefined;
}

export interface Route_PerFilterConfigEntry {
  $type: "envoy.api.v2.route.Route.PerFilterConfigEntry";
  key: string;
  value?: { [key: string]: any } | undefined;
}

export interface Route_TypedPerFilterConfigEntry {
  $type: "envoy.api.v2.route.Route.TypedPerFilterConfigEntry";
  key: string;
  value?: Any | undefined;
}

/**
 * Compared to the :ref:`cluster <envoy_api_field_route.RouteAction.cluster>` field that specifies a
 * single upstream cluster as the target of a request, the :ref:`weighted_clusters
 * <envoy_api_field_route.RouteAction.weighted_clusters>` option allows for specification of
 * multiple upstream clusters along with weights that indicate the percentage of
 * traffic to be forwarded to each cluster. The router selects an upstream cluster based on the
 * weights.
 */
export interface WeightedCluster {
  $type: "envoy.api.v2.route.WeightedCluster";
  /** Specifies one or more upstream clusters associated with the route. */
  clusters?:
    | WeightedCluster_ClusterWeight[]
    | undefined;
  /**
   * Specifies the total weight across all clusters. The sum of all cluster weights must equal this
   * value, which must be greater than 0. Defaults to 100.
   */
  total_weight?:
    | number
    | undefined;
  /**
   * Specifies the runtime key prefix that should be used to construct the
   * runtime keys associated with each cluster. When the *runtime_key_prefix* is
   * specified, the router will look for weights associated with each upstream
   * cluster under the key *runtime_key_prefix* + "." + *cluster[i].name* where
   * *cluster[i]* denotes an entry in the clusters array field. If the runtime
   * key for the cluster does not exist, the value specified in the
   * configuration file will be used as the default weight. See the :ref:`runtime documentation
   * <operations_runtime>` for how key names map to the underlying implementation.
   */
  runtime_key_prefix?: string | undefined;
}

/** [#next-free-field: 11] */
export interface WeightedCluster_ClusterWeight {
  $type: "envoy.api.v2.route.WeightedCluster.ClusterWeight";
  /**
   * Name of the upstream cluster. The cluster must exist in the
   * :ref:`cluster manager configuration <config_cluster_manager>`.
   */
  name?:
    | string
    | undefined;
  /**
   * An integer between 0 and :ref:`total_weight
   * <envoy_api_field_route.WeightedCluster.total_weight>`. When a request matches the route,
   * the choice of an upstream cluster is determined by its weight. The sum of weights across all
   * entries in the clusters array must add up to the total_weight, if total_weight is greater than 0.
   */
  weight?:
    | number
    | undefined;
  /**
   * Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints in
   * the upstream cluster with metadata matching what is set in this field will be considered for
   * load balancing. Note that this will be merged with what's provided in
   * :ref:`RouteAction.metadata_match <envoy_api_field_route.RouteAction.metadata_match>`, with
   * values here taking precedence. The filter name should be specified as *envoy.lb*.
   */
  metadata_match?:
    | Metadata
    | undefined;
  /**
   * Specifies a list of headers to be added to requests when this cluster is selected
   * through the enclosing :ref:`envoy_api_msg_route.RouteAction`.
   * Headers specified at this level are applied before headers from the enclosing
   * :ref:`envoy_api_msg_route.Route`, :ref:`envoy_api_msg_route.VirtualHost`, and
   * :ref:`envoy_api_msg_RouteConfiguration`. For more information, including details on
   * header value syntax, see the documentation on :ref:`custom request headers
   * <config_http_conn_man_headers_custom_request_headers>`.
   */
  request_headers_to_add?:
    | HeaderValueOption[]
    | undefined;
  /**
   * Specifies a list of HTTP headers that should be removed from each request when
   * this cluster is selected through the enclosing :ref:`envoy_api_msg_route.RouteAction`.
   */
  request_headers_to_remove?:
    | string[]
    | undefined;
  /**
   * Specifies a list of headers to be added to responses when this cluster is selected
   * through the enclosing :ref:`envoy_api_msg_route.RouteAction`.
   * Headers specified at this level are applied before headers from the enclosing
   * :ref:`envoy_api_msg_route.Route`, :ref:`envoy_api_msg_route.VirtualHost`, and
   * :ref:`envoy_api_msg_RouteConfiguration`. For more information, including details on
   * header value syntax, see the documentation on :ref:`custom request headers
   * <config_http_conn_man_headers_custom_request_headers>`.
   */
  response_headers_to_add?:
    | HeaderValueOption[]
    | undefined;
  /**
   * Specifies a list of headers to be removed from responses when this cluster is selected
   * through the enclosing :ref:`envoy_api_msg_route.RouteAction`.
   */
  response_headers_to_remove?:
    | string[]
    | undefined;
  /**
   * The per_filter_config field can be used to provide weighted cluster-specific
   * configurations for filters. The key should match the filter name, such as
   * *envoy.filters.http.buffer* for the HTTP buffer filter. Use of this field is filter
   * specific; see the :ref:`HTTP filter documentation <config_http_filters>`
   * for if and how it is utilized.
   *
   * @deprecated
   */
  per_filter_config?:
    | Map<string, { [key: string]: any } | undefined>
    | undefined;
  /**
   * The per_filter_config field can be used to provide weighted cluster-specific
   * configurations for filters. The key should match the filter name, such as
   * *envoy.filters.http.buffer* for the HTTP buffer filter. Use of this field is filter
   * specific; see the :ref:`HTTP filter documentation <config_http_filters>`
   * for if and how it is utilized.
   */
  typed_per_filter_config?: Map<string, Any> | undefined;
}

export interface WeightedCluster_ClusterWeight_PerFilterConfigEntry {
  $type: "envoy.api.v2.route.WeightedCluster.ClusterWeight.PerFilterConfigEntry";
  key: string;
  value?: { [key: string]: any } | undefined;
}

export interface WeightedCluster_ClusterWeight_TypedPerFilterConfigEntry {
  $type: "envoy.api.v2.route.WeightedCluster.ClusterWeight.TypedPerFilterConfigEntry";
  key: string;
  value?: Any | undefined;
}

/** [#next-free-field: 12] */
export interface RouteMatch {
  $type: "envoy.api.v2.route.RouteMatch";
  path_specifier?:
    | //
    /**
     * If specified, the route is a prefix rule meaning that the prefix must
     * match the beginning of the *:path* header.
     */
    { $case: "prefix"; prefix: string }
    | //
    /**
     * If specified, the route is an exact path rule meaning that the path must
     * exactly match the *:path* header once the query string is removed.
     */
    { $case: "path"; path: string }
    | //
    /**
     * If specified, the route is a regular expression rule meaning that the
     * regex must match the *:path* header once the query string is removed. The entire path
     * (without the query string) must match the regex. The rule will not match if only a
     * subsequence of the *:path* header matches the regex. The regex grammar is defined `here
     * <https://en.cppreference.com/w/cpp/regex/ecmascript>`_.
     *
     * Examples:
     *
     * * The regex ``/b[io]t`` matches the path * /bit*
     * * The regex ``/b[io]t`` matches the path * /bot*
     * * The regex ``/b[io]t`` does not match the path * /bite*
     * * The regex ``/b[io]t`` does not match the path * /bit/bot*
     *
     * .. attention::
     *   This field has been deprecated in favor of `safe_regex` as it is not safe for use with
     *   untrusted input in all cases.
     */
    { $case: "regex"; regex: string }
    | //
    /**
     * If specified, the route is a regular expression rule meaning that the
     * regex must match the *:path* header once the query string is removed. The entire path
     * (without the query string) must match the regex. The rule will not match if only a
     * subsequence of the *:path* header matches the regex.
     *
     * [#next-major-version: In the v3 API we should redo how path specification works such
     * that we utilize StringMatcher, and additionally have consistent options around whether we
     * strip query strings, do a case sensitive match, etc. In the interim it will be too disruptive
     * to deprecate the existing options. We should even consider whether we want to do away with
     * path_specifier entirely and just rely on a set of header matchers which can already match
     * on :path, etc. The issue with that is it is unclear how to generically deal with query string
     * stripping. This needs more thought.]
     */
    { $case: "safe_regex"; safe_regex: RegexMatcher }
    | undefined;
  /**
   * Indicates that prefix/path matching should be case sensitive. The default
   * is true.
   */
  case_sensitive?:
    | boolean
    | undefined;
  /**
   * Indicates that the route should additionally match on a runtime key. Every time the route
   * is considered for a match, it must also fall under the percentage of matches indicated by
   * this field. For some fraction N/D, a random number in the range [0,D) is selected. If the
   * number is <= the value of the numerator N, or if the key is not present, the default
   * value, the router continues to evaluate the remaining match criteria. A runtime_fraction
   * route configuration can be used to roll out route changes in a gradual manner without full
   * code/config deploys. Refer to the :ref:`traffic shifting
   * <config_http_conn_man_route_table_traffic_splitting_shift>` docs for additional documentation.
   *
   * .. note::
   *
   *    Parsing this field is implemented such that the runtime key's data may be represented
   *    as a FractionalPercent proto represented as JSON/YAML and may also be represented as an
   *    integer with the assumption that the value is an integral percentage out of 100. For
   *    instance, a runtime key lookup returning the value "42" would parse as a FractionalPercent
   *    whose numerator is 42 and denominator is HUNDRED. This preserves legacy semantics.
   */
  runtime_fraction?:
    | RuntimeFractionalPercent
    | undefined;
  /**
   * Specifies a set of headers that the route should match on. The router will
   * check the requestâ€™s headers against all the specified headers in the route
   * config. A match will happen if all the headers in the route are present in
   * the request with the same values (or based on presence if the value field
   * is not in the config).
   */
  headers?:
    | HeaderMatcher[]
    | undefined;
  /**
   * Specifies a set of URL query parameters on which the route should
   * match. The router will check the query string from the *path* header
   * against all the specified query parameters. If the number of specified
   * query parameters is nonzero, they all must match the *path* header's
   * query string for a match to occur.
   */
  query_parameters?:
    | QueryParameterMatcher[]
    | undefined;
  /**
   * If specified, only gRPC requests will be matched. The router will check
   * that the content-type header has a application/grpc or one of the various
   * application/grpc+ values.
   */
  grpc?:
    | RouteMatch_GrpcRouteMatchOptions
    | undefined;
  /**
   * If specified, the client tls context will be matched against the defined
   * match options.
   *
   * [#next-major-version: unify with RBAC]
   */
  tls_context?: RouteMatch_TlsContextMatchOptions | undefined;
}

export interface RouteMatch_GrpcRouteMatchOptions {
  $type: "envoy.api.v2.route.RouteMatch.GrpcRouteMatchOptions";
}

export interface RouteMatch_TlsContextMatchOptions {
  $type: "envoy.api.v2.route.RouteMatch.TlsContextMatchOptions";
  /**
   * If specified, the route will match against whether or not a certificate is presented.
   * If not specified, certificate presentation status (true or false) will not be considered when route matching.
   */
  presented?:
    | boolean
    | undefined;
  /**
   * If specified, the route will match against whether or not a certificate is validated.
   * If not specified, certificate validation status (true or false) will not be considered when route matching.
   */
  validated?: boolean | undefined;
}

/** [#next-free-field: 12] */
export interface CorsPolicy {
  $type: "envoy.api.v2.route.CorsPolicy";
  /**
   * Specifies the origins that will be allowed to do CORS requests.
   *
   * An origin is allowed if either allow_origin or allow_origin_regex match.
   *
   * .. attention::
   *  This field has been deprecated in favor of `allow_origin_string_match`.
   *
   * @deprecated
   */
  allow_origin?:
    | string[]
    | undefined;
  /**
   * Specifies regex patterns that match allowed origins.
   *
   * An origin is allowed if either allow_origin or allow_origin_regex match.
   *
   * .. attention::
   *   This field has been deprecated in favor of `allow_origin_string_match` as it is not safe for
   *   use with untrusted input in all cases.
   *
   * @deprecated
   */
  allow_origin_regex?:
    | string[]
    | undefined;
  /**
   * Specifies string patterns that match allowed origins. An origin is allowed if any of the
   * string matchers match.
   */
  allow_origin_string_match?:
    | StringMatcher[]
    | undefined;
  /** Specifies the content for the *access-control-allow-methods* header. */
  allow_methods?:
    | string
    | undefined;
  /** Specifies the content for the *access-control-allow-headers* header. */
  allow_headers?:
    | string
    | undefined;
  /** Specifies the content for the *access-control-expose-headers* header. */
  expose_headers?:
    | string
    | undefined;
  /** Specifies the content for the *access-control-max-age* header. */
  max_age?:
    | string
    | undefined;
  /** Specifies whether the resource allows credentials. */
  allow_credentials?: boolean | undefined;
  enabled_specifier?:
    | //
    /**
     * Specifies if the CORS filter is enabled. Defaults to true. Only effective on route.
     *
     * .. attention::
     *
     *   **This field is deprecated**. Set the
     *   :ref:`filter_enabled<envoy_api_field_route.CorsPolicy.filter_enabled>` field instead.
     */
    { $case: "enabled"; enabled: boolean | undefined }
    | //
    /**
     * Specifies the % of requests for which the CORS filter is enabled.
     *
     * If neither ``enabled``, ``filter_enabled``, nor ``shadow_enabled`` are specified, the CORS
     * filter will be enabled for 100% of the requests.
     *
     * If :ref:`runtime_key <envoy_api_field_core.RuntimeFractionalPercent.runtime_key>` is
     * specified, Envoy will lookup the runtime key to get the percentage of requests to filter.
     */
    { $case: "filter_enabled"; filter_enabled: RuntimeFractionalPercent }
    | undefined;
  /**
   * Specifies the % of requests for which the CORS policies will be evaluated and tracked, but not
   * enforced.
   *
   * This field is intended to be used when ``filter_enabled`` and ``enabled`` are off. One of those
   * fields have to explicitly disable the filter in order for this setting to take effect.
   *
   * If :ref:`runtime_key <envoy_api_field_core.RuntimeFractionalPercent.runtime_key>` is specified,
   * Envoy will lookup the runtime key to get the percentage of requests for which it will evaluate
   * and track the request's *Origin* to determine if it's valid but will not enforce any policies.
   */
  shadow_enabled?: RuntimeFractionalPercent | undefined;
}

/** [#next-free-field: 34] */
export interface RouteAction {
  $type: "envoy.api.v2.route.RouteAction";
  cluster_specifier?:
    | //
    /**
     * Indicates the upstream cluster to which the request should be routed
     * to.
     */
    { $case: "cluster"; cluster: string }
    | //
    /**
     * Envoy will determine the cluster to route to by reading the value of the
     * HTTP header named by cluster_header from the request headers. If the
     * header is not found or the referenced cluster does not exist, Envoy will
     * return a 404 response.
     *
     * .. attention::
     *
     *   Internally, Envoy always uses the HTTP/2 *:authority* header to represent the HTTP/1
     *   *Host* header. Thus, if attempting to match on *Host*, match on *:authority* instead.
     *
     * .. note::
     *
     *   If the header appears multiple times only the first value is used.
     */
    { $case: "cluster_header"; cluster_header: string }
    | //
    /**
     * Multiple upstream clusters can be specified for a given route. The
     * request is routed to one of the upstream clusters based on weights
     * assigned to each cluster. See
     * :ref:`traffic splitting <config_http_conn_man_route_table_traffic_splitting_split>`
     * for additional documentation.
     */
    { $case: "weighted_clusters"; weighted_clusters: WeightedCluster }
    | undefined;
  /**
   * The HTTP status code to use when configured cluster is not found.
   * The default response code is 503 Service Unavailable.
   */
  cluster_not_found_response_code?:
    | RouteAction_ClusterNotFoundResponseCode
    | undefined;
  /**
   * Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints
   * in the upstream cluster with metadata matching what's set in this field will be considered
   * for load balancing. If using :ref:`weighted_clusters
   * <envoy_api_field_route.RouteAction.weighted_clusters>`, metadata will be merged, with values
   * provided there taking precedence. The filter name should be specified as *envoy.lb*.
   */
  metadata_match?:
    | Metadata
    | undefined;
  /**
   * Indicates that during forwarding, the matched prefix (or path) should be
   * swapped with this value. This option allows application URLs to be rooted
   * at a different path from those exposed at the reverse proxy layer. The router filter will
   * place the original path before rewrite into the :ref:`x-envoy-original-path
   * <config_http_filters_router_x-envoy-original-path>` header.
   *
   * Only one of *prefix_rewrite* or
   * :ref:`regex_rewrite <envoy_api_field_route.RouteAction.regex_rewrite>`
   * may be specified.
   *
   * .. attention::
   *
   *   Pay careful attention to the use of trailing slashes in the
   *   :ref:`route's match <envoy_api_field_route.Route.match>` prefix value.
   *   Stripping a prefix from a path requires multiple Routes to handle all cases. For example,
   *   rewriting * /prefix* to * /* and * /prefix/etc* to * /etc* cannot be done in a single
   *   :ref:`Route <envoy_api_msg_route.Route>`, as shown by the below config entries:
   *
   *   .. code-block:: yaml
   *
   *     - match:
   *         prefix: "/prefix/"
   *       route:
   *         prefix_rewrite: "/"
   *     - match:
   *         prefix: "/prefix"
   *       route:
   *         prefix_rewrite: "/"
   *
   *   Having above entries in the config, requests to * /prefix* will be stripped to * /*, while
   *   requests to * /prefix/etc* will be stripped to * /etc*.
   */
  prefix_rewrite?:
    | string
    | undefined;
  /**
   * Indicates that during forwarding, portions of the path that match the
   * pattern should be rewritten, even allowing the substitution of capture
   * groups from the pattern into the new path as specified by the rewrite
   * substitution string. This is useful to allow application paths to be
   * rewritten in a way that is aware of segments with variable content like
   * identifiers. The router filter will place the original path as it was
   * before the rewrite into the :ref:`x-envoy-original-path
   * <config_http_filters_router_x-envoy-original-path>` header.
   *
   * Only one of :ref:`prefix_rewrite <envoy_api_field_route.RouteAction.prefix_rewrite>`
   * or *regex_rewrite* may be specified.
   *
   * Examples using Google's `RE2 <https://github.com/google/re2>`_ engine:
   *
   * * The path pattern ``^/service/([^/]+)(/.*)$`` paired with a substitution
   *   string of ``\2/instance/\1`` would transform ``/service/foo/v1/api``
   *   into ``/v1/api/instance/foo``.
   *
   * * The pattern ``one`` paired with a substitution string of ``two`` would
   *   transform ``/xxx/one/yyy/one/zzz`` into ``/xxx/two/yyy/two/zzz``.
   *
   * * The pattern ``^(.*?)one(.*)$`` paired with a substitution string of
   *   ``\1two\2`` would replace only the first occurrence of ``one``,
   *   transforming path ``/xxx/one/yyy/one/zzz`` into ``/xxx/two/yyy/one/zzz``.
   *
   * * The pattern ``(?i)/xxx/`` paired with a substitution string of ``/yyy/``
   *   would do a case-insensitive match and transform path ``/aaa/XxX/bbb`` to
   *   ``/aaa/yyy/bbb``.
   */
  regex_rewrite?: RegexMatchAndSubstitute | undefined;
  host_rewrite_specifier?:
    | //
    /**
     * Indicates that during forwarding, the host header will be swapped with
     * this value.
     */
    { $case: "host_rewrite"; host_rewrite: string }
    | //
    /**
     * Indicates that during forwarding, the host header will be swapped with
     * the hostname of the upstream host chosen by the cluster manager. This
     * option is applicable only when the destination cluster for a route is of
     * type ``STRICT_DNS``,  ``LOGICAL_DNS`` or ``STATIC``. For ``STATIC`` clusters, the
     * hostname attribute of the endpoint must be configured. Setting this to true
     * with other cluster types has no effect.
     */
    { $case: "auto_host_rewrite"; auto_host_rewrite: boolean | undefined }
    | //
    /**
     * Indicates that during forwarding, the host header will be swapped with the content of given
     * downstream or :ref:`custom <config_http_conn_man_headers_custom_request_headers>` header.
     * If header value is empty, host header is left intact.
     *
     * .. attention::
     *
     *   Pay attention to the potential security implications of using this option. Provided header
     *   must come from trusted source.
     *
     * .. note::
     *
     *   If the header appears multiple times only the first value is used.
     */
    { $case: "auto_host_rewrite_header"; auto_host_rewrite_header: string }
    | undefined;
  /**
   * Specifies the upstream timeout for the route. If not specified, the default is 15s. This
   * spans between the point at which the entire downstream request (i.e. end-of-stream) has been
   * processed and when the upstream response has been completely processed. A value of 0 will
   * disable the route's timeout.
   *
   * .. note::
   *
   *   This timeout includes all retries. See also
   *   :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`,
   *   :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms`, and the
   *   :ref:`retry overview <arch_overview_http_routing_retry>`.
   */
  timeout?:
    | Duration
    | undefined;
  /**
   * Specifies the idle timeout for the route. If not specified, there is no per-route idle timeout,
   * although the connection manager wide :ref:`stream_idle_timeout
   * <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.stream_idle_timeout>`
   * will still apply. A value of 0 will completely disable the route's idle timeout, even if a
   * connection manager stream idle timeout is configured.
   *
   * The idle timeout is distinct to :ref:`timeout
   * <envoy_api_field_route.RouteAction.timeout>`, which provides an upper bound
   * on the upstream response time; :ref:`idle_timeout
   * <envoy_api_field_route.RouteAction.idle_timeout>` instead bounds the amount
   * of time the request's stream may be idle.
   *
   * After header decoding, the idle timeout will apply on downstream and
   * upstream request events. Each time an encode/decode event for headers or
   * data is processed for the stream, the timer will be reset. If the timeout
   * fires, the stream is terminated with a 408 Request Timeout error code if no
   * upstream response header has been received, otherwise a stream reset
   * occurs.
   */
  idle_timeout?:
    | Duration
    | undefined;
  /**
   * Indicates that the route has a retry policy. Note that if this is set,
   * it'll take precedence over the virtual host level retry policy entirely
   * (e.g.: policies are not merged, most internal one becomes the enforced policy).
   */
  retry_policy?:
    | RetryPolicy
    | undefined;
  /**
   * [#not-implemented-hide:]
   * Specifies the configuration for retry policy extension. Note that if this is set, it'll take
   * precedence over the virtual host level retry policy entirely (e.g.: policies are not merged,
   * most internal one becomes the enforced policy). :ref:`Retry policy <envoy_api_field_route.VirtualHost.retry_policy>`
   * should not be set if this field is used.
   */
  retry_policy_typed_config?:
    | Any
    | undefined;
  /**
   * Indicates that the route has a request mirroring policy.
   *
   * .. attention::
   *   This field has been deprecated in favor of `request_mirror_policies` which supports one or
   *   more mirroring policies.
   *
   * @deprecated
   */
  request_mirror_policy?:
    | RouteAction_RequestMirrorPolicy
    | undefined;
  /** Indicates that the route has request mirroring policies. */
  request_mirror_policies?:
    | RouteAction_RequestMirrorPolicy[]
    | undefined;
  /** Optionally specifies the :ref:`routing priority <arch_overview_http_routing_priority>`. */
  priority?:
    | RoutingPriority
    | undefined;
  /**
   * Specifies a set of rate limit configurations that could be applied to the
   * route.
   */
  rate_limits?:
    | RateLimit[]
    | undefined;
  /**
   * Specifies if the rate limit filter should include the virtual host rate
   * limits. By default, if the route configured rate limits, the virtual host
   * :ref:`rate_limits <envoy_api_field_route.VirtualHost.rate_limits>` are not applied to the
   * request.
   */
  include_vh_rate_limits?:
    | boolean
    | undefined;
  /**
   * Specifies a list of hash policies to use for ring hash load balancing. Each
   * hash policy is evaluated individually and the combined result is used to
   * route the request. The method of combination is deterministic such that
   * identical lists of hash policies will produce the same hash. Since a hash
   * policy examines specific parts of a request, it can fail to produce a hash
   * (i.e. if the hashed header is not present). If (and only if) all configured
   * hash policies fail to generate a hash, no hash will be produced for
   * the route. In this case, the behavior is the same as if no hash policies
   * were specified (i.e. the ring hash load balancer will choose a random
   * backend). If a hash policy has the "terminal" attribute set to true, and
   * there is already a hash generated, the hash is returned immediately,
   * ignoring the rest of the hash policy list.
   */
  hash_policy?:
    | RouteAction_HashPolicy[]
    | undefined;
  /** Indicates that the route has a CORS policy. */
  cors?:
    | CorsPolicy
    | undefined;
  /**
   * If present, and the request is a gRPC request, use the
   * `grpc-timeout header <https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md>`_,
   * or its default value (infinity) instead of
   * :ref:`timeout <envoy_api_field_route.RouteAction.timeout>`, but limit the applied timeout
   * to the maximum value specified here. If configured as 0, the maximum allowed timeout for
   * gRPC requests is infinity. If not configured at all, the `grpc-timeout` header is not used
   * and gRPC requests time out like any other requests using
   * :ref:`timeout <envoy_api_field_route.RouteAction.timeout>` or its default.
   * This can be used to prevent unexpected upstream request timeouts due to potentially long
   * time gaps between gRPC request and response in gRPC streaming mode.
   *
   * .. note::
   *
   *    If a timeout is specified using :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`, it takes
   *    precedence over `grpc-timeout header <https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md>`_, when
   *    both are present. See also
   *    :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`,
   *    :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms`, and the
   *    :ref:`retry overview <arch_overview_http_routing_retry>`.
   */
  max_grpc_timeout?:
    | Duration
    | undefined;
  /**
   * If present, Envoy will adjust the timeout provided by the `grpc-timeout` header by subtracting
   * the provided duration from the header. This is useful in allowing Envoy to set its global
   * timeout to be less than that of the deadline imposed by the calling client, which makes it more
   * likely that Envoy will handle the timeout instead of having the call canceled by the client.
   * The offset will only be applied if the provided grpc_timeout is greater than the offset. This
   * ensures that the offset will only ever decrease the timeout and never set it to 0 (meaning
   * infinity).
   */
  grpc_timeout_offset?: Duration | undefined;
  upgrade_configs?: RouteAction_UpgradeConfig[] | undefined;
  internal_redirect_action?:
    | RouteAction_InternalRedirectAction
    | undefined;
  /**
   * An internal redirect is handled, iff the number of previous internal redirects that a
   * downstream request has encountered is lower than this value, and
   * :ref:`internal_redirect_action <envoy_api_field_route.RouteAction.internal_redirect_action>`
   * is set to :ref:`HANDLE_INTERNAL_REDIRECT
   * <envoy_api_enum_value_route.RouteAction.InternalRedirectAction.HANDLE_INTERNAL_REDIRECT>`
   * In the case where a downstream request is bounced among multiple routes by internal redirect,
   * the first route that hits this threshold, or has
   * :ref:`internal_redirect_action <envoy_api_field_route.RouteAction.internal_redirect_action>`
   * set to
   * :ref:`PASS_THROUGH_INTERNAL_REDIRECT
   * <envoy_api_enum_value_route.RouteAction.InternalRedirectAction.PASS_THROUGH_INTERNAL_REDIRECT>`
   * will pass the redirect back to downstream.
   *
   * If not specified, at most one redirect will be followed.
   */
  max_internal_redirects?:
    | number
    | undefined;
  /**
   * Indicates that the route has a hedge policy. Note that if this is set,
   * it'll take precedence over the virtual host level hedge policy entirely
   * (e.g.: policies are not merged, most internal one becomes the enforced policy).
   */
  hedge_policy?: HedgePolicy | undefined;
}

export enum RouteAction_ClusterNotFoundResponseCode {
  /** SERVICE_UNAVAILABLE - HTTP status code - 503 Service Unavailable. */
  SERVICE_UNAVAILABLE = "SERVICE_UNAVAILABLE",
  /** NOT_FOUND - HTTP status code - 404 Not Found. */
  NOT_FOUND = "NOT_FOUND",
}

export function routeAction_ClusterNotFoundResponseCodeFromJSON(object: any): RouteAction_ClusterNotFoundResponseCode {
  switch (object) {
    case 0:
    case "SERVICE_UNAVAILABLE":
      return RouteAction_ClusterNotFoundResponseCode.SERVICE_UNAVAILABLE;
    case 1:
    case "NOT_FOUND":
      return RouteAction_ClusterNotFoundResponseCode.NOT_FOUND;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum RouteAction_ClusterNotFoundResponseCode",
      );
  }
}

export function routeAction_ClusterNotFoundResponseCodeToJSON(object: RouteAction_ClusterNotFoundResponseCode): string {
  switch (object) {
    case RouteAction_ClusterNotFoundResponseCode.SERVICE_UNAVAILABLE:
      return "SERVICE_UNAVAILABLE";
    case RouteAction_ClusterNotFoundResponseCode.NOT_FOUND:
      return "NOT_FOUND";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum RouteAction_ClusterNotFoundResponseCode",
      );
  }
}

export function routeAction_ClusterNotFoundResponseCodeToNumber(
  object: RouteAction_ClusterNotFoundResponseCode,
): number {
  switch (object) {
    case RouteAction_ClusterNotFoundResponseCode.SERVICE_UNAVAILABLE:
      return 0;
    case RouteAction_ClusterNotFoundResponseCode.NOT_FOUND:
      return 1;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum RouteAction_ClusterNotFoundResponseCode",
      );
  }
}

/** Configures :ref:`internal redirect <arch_overview_internal_redirects>` behavior. */
export enum RouteAction_InternalRedirectAction {
  PASS_THROUGH_INTERNAL_REDIRECT = "PASS_THROUGH_INTERNAL_REDIRECT",
  HANDLE_INTERNAL_REDIRECT = "HANDLE_INTERNAL_REDIRECT",
}

export function routeAction_InternalRedirectActionFromJSON(object: any): RouteAction_InternalRedirectAction {
  switch (object) {
    case 0:
    case "PASS_THROUGH_INTERNAL_REDIRECT":
      return RouteAction_InternalRedirectAction.PASS_THROUGH_INTERNAL_REDIRECT;
    case 1:
    case "HANDLE_INTERNAL_REDIRECT":
      return RouteAction_InternalRedirectAction.HANDLE_INTERNAL_REDIRECT;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RouteAction_InternalRedirectAction");
  }
}

export function routeAction_InternalRedirectActionToJSON(object: RouteAction_InternalRedirectAction): string {
  switch (object) {
    case RouteAction_InternalRedirectAction.PASS_THROUGH_INTERNAL_REDIRECT:
      return "PASS_THROUGH_INTERNAL_REDIRECT";
    case RouteAction_InternalRedirectAction.HANDLE_INTERNAL_REDIRECT:
      return "HANDLE_INTERNAL_REDIRECT";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RouteAction_InternalRedirectAction");
  }
}

export function routeAction_InternalRedirectActionToNumber(object: RouteAction_InternalRedirectAction): number {
  switch (object) {
    case RouteAction_InternalRedirectAction.PASS_THROUGH_INTERNAL_REDIRECT:
      return 0;
    case RouteAction_InternalRedirectAction.HANDLE_INTERNAL_REDIRECT:
      return 1;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RouteAction_InternalRedirectAction");
  }
}

/**
 * The router is capable of shadowing traffic from one cluster to another. The current
 * implementation is "fire and forget," meaning Envoy will not wait for the shadow cluster to
 * respond before returning the response from the primary cluster. All normal statistics are
 * collected for the shadow cluster making this feature useful for testing.
 *
 * During shadowing, the host/authority header is altered such that *-shadow* is appended. This is
 * useful for logging. For example, *cluster1* becomes *cluster1-shadow*.
 *
 * .. note::
 *
 *   Shadowing will not be triggered if the primary cluster does not exist.
 */
export interface RouteAction_RequestMirrorPolicy {
  $type: "envoy.api.v2.route.RouteAction.RequestMirrorPolicy";
  /**
   * Specifies the cluster that requests will be mirrored to. The cluster must
   * exist in the cluster manager configuration.
   */
  cluster?:
    | string
    | undefined;
  /**
   * If not specified, all requests to the target cluster will be mirrored. If
   * specified, Envoy will lookup the runtime key to get the % of requests to
   * mirror. Valid values are from 0 to 10000, allowing for increments of
   * 0.01% of requests to be mirrored. If the runtime key is specified in the
   * configuration but not present in runtime, 0 is the default and thus 0% of
   * requests will be mirrored.
   *
   * .. attention::
   *
   *   **This field is deprecated**. Set the
   *   :ref:`runtime_fraction
   *   <envoy_api_field_route.RouteAction.RequestMirrorPolicy.runtime_fraction>`
   *   field instead. Mirroring occurs if both this and
   *   <envoy_api_field_route.RouteAction.RequestMirrorPolicy.runtime_fraction>`
   *   are not set.
   *
   * @deprecated
   */
  runtime_key?:
    | string
    | undefined;
  /**
   * If not specified, all requests to the target cluster will be mirrored.
   *
   * If specified, this field takes precedence over the `runtime_key` field and requests must also
   * fall under the percentage of matches indicated by this field.
   *
   * For some fraction N/D, a random number in the range [0,D) is selected. If the
   * number is <= the value of the numerator N, or if the key is not present, the default
   * value, the request will be mirrored.
   */
  runtime_fraction?:
    | RuntimeFractionalPercent
    | undefined;
  /** Determines if the trace span should be sampled. Defaults to true. */
  trace_sampled?: boolean | undefined;
}

/**
 * Specifies the route's hashing policy if the upstream cluster uses a hashing :ref:`load balancer
 * <arch_overview_load_balancing_types>`.
 * [#next-free-field: 7]
 */
export interface RouteAction_HashPolicy {
  $type: "envoy.api.v2.route.RouteAction.HashPolicy";
  policy_specifier?:
    | //
    /** Header hash policy. */
    { $case: "header"; header: RouteAction_HashPolicy_Header }
    | //
    /** Cookie hash policy. */
    { $case: "cookie"; cookie: RouteAction_HashPolicy_Cookie }
    | //
    /** Connection properties hash policy. */
    { $case: "connection_properties"; connection_properties: RouteAction_HashPolicy_ConnectionProperties }
    | //
    /** Query parameter hash policy. */
    { $case: "query_parameter"; query_parameter: RouteAction_HashPolicy_QueryParameter }
    | //
    /** Filter state hash policy. */
    { $case: "filter_state"; filter_state: RouteAction_HashPolicy_FilterState }
    | undefined;
  /**
   * The flag that short-circuits the hash computing. This field provides a
   * 'fallback' style of configuration: "if a terminal policy doesn't work,
   * fallback to rest of the policy list", it saves time when the terminal
   * policy works.
   *
   * If true, and there is already a hash computed, ignore rest of the
   * list of hash polices.
   * For example, if the following hash methods are configured:
   *
   *  ========= ========
   *  specifier terminal
   *  ========= ========
   *  Header A  true
   *  Header B  false
   *  Header C  false
   *  ========= ========
   *
   * The generateHash process ends if policy "header A" generates a hash, as
   * it's a terminal policy.
   */
  terminal?: boolean | undefined;
}

export interface RouteAction_HashPolicy_Header {
  $type: "envoy.api.v2.route.RouteAction.HashPolicy.Header";
  /**
   * The name of the request header that will be used to obtain the hash
   * key. If the request header is not present, no hash will be produced.
   */
  header_name?: string | undefined;
}

/**
 * Envoy supports two types of cookie affinity:
 *
 * 1. Passive. Envoy takes a cookie that's present in the cookies header and
 *    hashes on its value.
 *
 * 2. Generated. Envoy generates and sets a cookie with an expiration (TTL)
 *    on the first request from the client in its response to the client,
 *    based on the endpoint the request gets sent to. The client then
 *    presents this on the next and all subsequent requests. The hash of
 *    this is sufficient to ensure these requests get sent to the same
 *    endpoint. The cookie is generated by hashing the source and
 *    destination ports and addresses so that multiple independent HTTP2
 *    streams on the same connection will independently receive the same
 *    cookie, even if they arrive at the Envoy simultaneously.
 */
export interface RouteAction_HashPolicy_Cookie {
  $type: "envoy.api.v2.route.RouteAction.HashPolicy.Cookie";
  /**
   * The name of the cookie that will be used to obtain the hash key. If the
   * cookie is not present and ttl below is not set, no hash will be
   * produced.
   */
  name?:
    | string
    | undefined;
  /**
   * If specified, a cookie with the TTL will be generated if the cookie is
   * not present. If the TTL is present and zero, the generated cookie will
   * be a session cookie.
   */
  ttl?:
    | Duration
    | undefined;
  /**
   * The name of the path for the cookie. If no path is specified here, no path
   * will be set for the cookie.
   */
  path?: string | undefined;
}

export interface RouteAction_HashPolicy_ConnectionProperties {
  $type: "envoy.api.v2.route.RouteAction.HashPolicy.ConnectionProperties";
  /** Hash on source IP address. */
  source_ip?: boolean | undefined;
}

export interface RouteAction_HashPolicy_QueryParameter {
  $type: "envoy.api.v2.route.RouteAction.HashPolicy.QueryParameter";
  /**
   * The name of the URL query parameter that will be used to obtain the hash
   * key. If the parameter is not present, no hash will be produced. Query
   * parameter names are case-sensitive.
   */
  name?: string | undefined;
}

export interface RouteAction_HashPolicy_FilterState {
  $type: "envoy.api.v2.route.RouteAction.HashPolicy.FilterState";
  /**
   * The name of the Object in the per-request filterState, which is an
   * Envoy::Hashable object. If there is no data associated with the key,
   * or the stored object is not Envoy::Hashable, no hash will be produced.
   */
  key?: string | undefined;
}

/**
 * Allows enabling and disabling upgrades on a per-route basis.
 * This overrides any enabled/disabled upgrade filter chain specified in the
 * HttpConnectionManager
 * :ref:`upgrade_configs
 * <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.upgrade_configs>`
 * but does not affect any custom filter chain specified there.
 */
export interface RouteAction_UpgradeConfig {
  $type: "envoy.api.v2.route.RouteAction.UpgradeConfig";
  /**
   * The case-insensitive name of this upgrade, e.g. "websocket".
   * For each upgrade type present in upgrade_configs, requests with
   * Upgrade: [upgrade_type] will be proxied upstream.
   */
  upgrade_type?:
    | string
    | undefined;
  /** Determines if upgrades are available on this route. Defaults to true. */
  enabled?: boolean | undefined;
}

/**
 * HTTP retry :ref:`architecture overview <arch_overview_http_routing_retry>`.
 * [#next-free-field: 11]
 */
export interface RetryPolicy {
  $type: "envoy.api.v2.route.RetryPolicy";
  /**
   * Specifies the conditions under which retry takes place. These are the same
   * conditions documented for :ref:`config_http_filters_router_x-envoy-retry-on` and
   * :ref:`config_http_filters_router_x-envoy-retry-grpc-on`.
   */
  retry_on?:
    | string
    | undefined;
  /**
   * Specifies the allowed number of retries. This parameter is optional and
   * defaults to 1. These are the same conditions documented for
   * :ref:`config_http_filters_router_x-envoy-max-retries`.
   */
  num_retries?:
    | number
    | undefined;
  /**
   * Specifies a non-zero upstream timeout per retry attempt. This parameter is optional. The
   * same conditions documented for
   * :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms` apply.
   *
   * .. note::
   *
   *   If left unspecified, Envoy will use the global
   *   :ref:`route timeout <envoy_api_field_route.RouteAction.timeout>` for the request.
   *   Consequently, when using a :ref:`5xx <config_http_filters_router_x-envoy-retry-on>` based
   *   retry policy, a request that times out will not be retried as the total timeout budget
   *   would have been exhausted.
   */
  per_try_timeout?:
    | Duration
    | undefined;
  /**
   * Specifies an implementation of a RetryPriority which is used to determine the
   * distribution of load across priorities used for retries. Refer to
   * :ref:`retry plugin configuration <arch_overview_http_retry_plugins>` for more details.
   */
  retry_priority?:
    | RetryPolicy_RetryPriority
    | undefined;
  /**
   * Specifies a collection of RetryHostPredicates that will be consulted when selecting a host
   * for retries. If any of the predicates reject the host, host selection will be reattempted.
   * Refer to :ref:`retry plugin configuration <arch_overview_http_retry_plugins>` for more
   * details.
   */
  retry_host_predicate?:
    | RetryPolicy_RetryHostPredicate[]
    | undefined;
  /**
   * The maximum number of times host selection will be reattempted before giving up, at which
   * point the host that was last selected will be routed to. If unspecified, this will default to
   * retrying once.
   */
  host_selection_retry_max_attempts?:
    | number
    | undefined;
  /** HTTP status codes that should trigger a retry in addition to those specified by retry_on. */
  retriable_status_codes?:
    | number[]
    | undefined;
  /**
   * Specifies parameters that control retry back off. This parameter is optional, in which case the
   * default base interval is 25 milliseconds or, if set, the current value of the
   * `upstream.base_retry_backoff_ms` runtime parameter. The default maximum interval is 10 times
   * the base interval. The documentation for :ref:`config_http_filters_router_x-envoy-max-retries`
   * describes Envoy's back-off algorithm.
   */
  retry_back_off?:
    | RetryPolicy_RetryBackOff
    | undefined;
  /**
   * HTTP response headers that trigger a retry if present in the response. A retry will be
   * triggered if any of the header matches match the upstream response headers.
   * The field is only consulted if 'retriable-headers' retry policy is active.
   */
  retriable_headers?:
    | HeaderMatcher[]
    | undefined;
  /** HTTP headers which must be present in the request for retries to be attempted. */
  retriable_request_headers?: HeaderMatcher[] | undefined;
}

export interface RetryPolicy_RetryPriority {
  $type: "envoy.api.v2.route.RetryPolicy.RetryPriority";
  name?: string | undefined;
  config_type?:
    | //
    { $case: "config"; config: { [key: string]: any } | undefined }
    | //
    { $case: "typed_config"; typed_config: Any }
    | undefined;
}

export interface RetryPolicy_RetryHostPredicate {
  $type: "envoy.api.v2.route.RetryPolicy.RetryHostPredicate";
  name?: string | undefined;
  config_type?:
    | //
    { $case: "config"; config: { [key: string]: any } | undefined }
    | //
    { $case: "typed_config"; typed_config: Any }
    | undefined;
}

export interface RetryPolicy_RetryBackOff {
  $type: "envoy.api.v2.route.RetryPolicy.RetryBackOff";
  /**
   * Specifies the base interval between retries. This parameter is required and must be greater
   * than zero. Values less than 1 ms are rounded up to 1 ms.
   * See :ref:`config_http_filters_router_x-envoy-max-retries` for a discussion of Envoy's
   * back-off algorithm.
   */
  base_interval?:
    | Duration
    | undefined;
  /**
   * Specifies the maximum interval between retries. This parameter is optional, but must be
   * greater than or equal to the `base_interval` if set. The default is 10 times the
   * `base_interval`. See :ref:`config_http_filters_router_x-envoy-max-retries` for a discussion
   * of Envoy's back-off algorithm.
   */
  max_interval?: Duration | undefined;
}

/** HTTP request hedging :ref:`architecture overview <arch_overview_http_routing_hedging>`. */
export interface HedgePolicy {
  $type: "envoy.api.v2.route.HedgePolicy";
  /**
   * Specifies the number of initial requests that should be sent upstream.
   * Must be at least 1.
   * Defaults to 1.
   * [#not-implemented-hide:]
   */
  initial_requests?:
    | number
    | undefined;
  /**
   * Specifies a probability that an additional upstream request should be sent
   * on top of what is specified by initial_requests.
   * Defaults to 0.
   * [#not-implemented-hide:]
   */
  additional_request_chance?:
    | FractionalPercent
    | undefined;
  /**
   * Indicates that a hedged request should be sent when the per-try timeout is hit.
   * This means that a retry will be issued without resetting the original request, leaving multiple upstream requests in flight.
   * The first request to complete successfully will be the one returned to the caller.
   *
   * * At any time, a successful response (i.e. not triggering any of the retry-on conditions) would be returned to the client.
   * * Before per-try timeout, an error response (per retry-on conditions) would be retried immediately or returned ot the client
   *   if there are no more retries left.
   * * After per-try timeout, an error response would be discarded, as a retry in the form of a hedged request is already in progress.
   *
   * Note: For this to have effect, you must have a :ref:`RetryPolicy <envoy_api_msg_route.RetryPolicy>` that retries at least
   * one error code and specifies a maximum number of retries.
   *
   * Defaults to false.
   */
  hedge_on_per_try_timeout?: boolean | undefined;
}

/** [#next-free-field: 9] */
export interface RedirectAction {
  $type: "envoy.api.v2.route.RedirectAction";
  /**
   * When the scheme redirection take place, the following rules apply:
   *  1. If the source URI scheme is `http` and the port is explicitly
   *     set to `:80`, the port will be removed after the redirection
   *  2. If the source URI scheme is `https` and the port is explicitly
   *     set to `:443`, the port will be removed after the redirection
   */
  scheme_rewrite_specifier?:
    | //
    /** The scheme portion of the URL will be swapped with "https". */
    { $case: "https_redirect"; https_redirect: boolean }
    | //
    /** The scheme portion of the URL will be swapped with this value. */
    { $case: "scheme_redirect"; scheme_redirect: string }
    | undefined;
  /** The host portion of the URL will be swapped with this value. */
  host_redirect?:
    | string
    | undefined;
  /** The port value of the URL will be swapped with this value. */
  port_redirect?: number | undefined;
  path_rewrite_specifier?:
    | //
    /**
     * The path portion of the URL will be swapped with this value.
     * Please note that query string in path_redirect will override the
     * request's query string and will not be stripped.
     *
     * For example, let's say we have the following routes:
     *
     * - match: { path: "/old-path-1" }
     *   redirect: { path_redirect: "/new-path-1" }
     * - match: { path: "/old-path-2" }
     *   redirect: { path_redirect: "/new-path-2", strip-query: "true" }
     * - match: { path: "/old-path-3" }
     *   redirect: { path_redirect: "/new-path-3?foo=1", strip_query: "true" }
     *
     * 1. if request uri is "/old-path-1?bar=1", users will be redirected to "/new-path-1?bar=1"
     * 2. if request uri is "/old-path-2?bar=1", users will be redirected to "/new-path-2"
     * 3. if request uri is "/old-path-3?bar=1", users will be redirected to "/new-path-3?foo=1"
     */
    { $case: "path_redirect"; path_redirect: string }
    | //
    /**
     * Indicates that during redirection, the matched prefix (or path)
     * should be swapped with this value. This option allows redirect URLs be dynamically created
     * based on the request.
     *
     * .. attention::
     *
     *   Pay attention to the use of trailing slashes as mentioned in
     *   :ref:`RouteAction's prefix_rewrite <envoy_api_field_route.RouteAction.prefix_rewrite>`.
     */
    { $case: "prefix_rewrite"; prefix_rewrite: string }
    | undefined;
  /**
   * The HTTP status code to use in the redirect response. The default response
   * code is MOVED_PERMANENTLY (301).
   */
  response_code?:
    | RedirectAction_RedirectResponseCode
    | undefined;
  /**
   * Indicates that during redirection, the query portion of the URL will
   * be removed. Default value is false.
   */
  strip_query?: boolean | undefined;
}

export enum RedirectAction_RedirectResponseCode {
  /** MOVED_PERMANENTLY - Moved Permanently HTTP Status Code - 301. */
  MOVED_PERMANENTLY = "MOVED_PERMANENTLY",
  /** FOUND - Found HTTP Status Code - 302. */
  FOUND = "FOUND",
  /** SEE_OTHER - See Other HTTP Status Code - 303. */
  SEE_OTHER = "SEE_OTHER",
  /** TEMPORARY_REDIRECT - Temporary Redirect HTTP Status Code - 307. */
  TEMPORARY_REDIRECT = "TEMPORARY_REDIRECT",
  /** PERMANENT_REDIRECT - Permanent Redirect HTTP Status Code - 308. */
  PERMANENT_REDIRECT = "PERMANENT_REDIRECT",
}

export function redirectAction_RedirectResponseCodeFromJSON(object: any): RedirectAction_RedirectResponseCode {
  switch (object) {
    case 0:
    case "MOVED_PERMANENTLY":
      return RedirectAction_RedirectResponseCode.MOVED_PERMANENTLY;
    case 1:
    case "FOUND":
      return RedirectAction_RedirectResponseCode.FOUND;
    case 2:
    case "SEE_OTHER":
      return RedirectAction_RedirectResponseCode.SEE_OTHER;
    case 3:
    case "TEMPORARY_REDIRECT":
      return RedirectAction_RedirectResponseCode.TEMPORARY_REDIRECT;
    case 4:
    case "PERMANENT_REDIRECT":
      return RedirectAction_RedirectResponseCode.PERMANENT_REDIRECT;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RedirectAction_RedirectResponseCode");
  }
}

export function redirectAction_RedirectResponseCodeToJSON(object: RedirectAction_RedirectResponseCode): string {
  switch (object) {
    case RedirectAction_RedirectResponseCode.MOVED_PERMANENTLY:
      return "MOVED_PERMANENTLY";
    case RedirectAction_RedirectResponseCode.FOUND:
      return "FOUND";
    case RedirectAction_RedirectResponseCode.SEE_OTHER:
      return "SEE_OTHER";
    case RedirectAction_RedirectResponseCode.TEMPORARY_REDIRECT:
      return "TEMPORARY_REDIRECT";
    case RedirectAction_RedirectResponseCode.PERMANENT_REDIRECT:
      return "PERMANENT_REDIRECT";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RedirectAction_RedirectResponseCode");
  }
}

export function redirectAction_RedirectResponseCodeToNumber(object: RedirectAction_RedirectResponseCode): number {
  switch (object) {
    case RedirectAction_RedirectResponseCode.MOVED_PERMANENTLY:
      return 0;
    case RedirectAction_RedirectResponseCode.FOUND:
      return 1;
    case RedirectAction_RedirectResponseCode.SEE_OTHER:
      return 2;
    case RedirectAction_RedirectResponseCode.TEMPORARY_REDIRECT:
      return 3;
    case RedirectAction_RedirectResponseCode.PERMANENT_REDIRECT:
      return 4;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RedirectAction_RedirectResponseCode");
  }
}

export interface DirectResponseAction {
  $type: "envoy.api.v2.route.DirectResponseAction";
  /** Specifies the HTTP response status to be returned. */
  status?:
    | number
    | undefined;
  /**
   * Specifies the content of the response body. If this setting is omitted,
   * no body is included in the generated response.
   *
   * .. note::
   *
   *   Headers can be specified using *response_headers_to_add* in the enclosing
   *   :ref:`envoy_api_msg_route.Route`, :ref:`envoy_api_msg_RouteConfiguration` or
   *   :ref:`envoy_api_msg_route.VirtualHost`.
   */
  body?: DataSource | undefined;
}

export interface Decorator {
  $type: "envoy.api.v2.route.Decorator";
  /**
   * The operation name associated with the request matched to this route. If tracing is
   * enabled, this information will be used as the span name reported for this request.
   *
   * .. note::
   *
   *   For ingress (inbound) requests, or egress (outbound) responses, this value may be overridden
   *   by the :ref:`x-envoy-decorator-operation
   *   <config_http_filters_router_x-envoy-decorator-operation>` header.
   */
  operation?:
    | string
    | undefined;
  /** Whether the decorated details should be propagated to the other party. The default is true. */
  propagate?: boolean | undefined;
}

export interface Tracing {
  $type: "envoy.api.v2.route.Tracing";
  /**
   * Target percentage of requests managed by this HTTP connection manager that will be force
   * traced if the :ref:`x-client-trace-id <config_http_conn_man_headers_x-client-trace-id>`
   * header is set. This field is a direct analog for the runtime variable
   * 'tracing.client_enabled' in the :ref:`HTTP Connection Manager
   * <config_http_conn_man_runtime>`.
   * Default: 100%
   */
  client_sampling?:
    | FractionalPercent
    | undefined;
  /**
   * Target percentage of requests managed by this HTTP connection manager that will be randomly
   * selected for trace generation, if not requested by the client or not forced. This field is
   * a direct analog for the runtime variable 'tracing.random_sampling' in the
   * :ref:`HTTP Connection Manager <config_http_conn_man_runtime>`.
   * Default: 100%
   */
  random_sampling?:
    | FractionalPercent
    | undefined;
  /**
   * Target percentage of requests managed by this HTTP connection manager that will be traced
   * after all other sampling checks have been applied (client-directed, force tracing, random
   * sampling). This field functions as an upper limit on the total configured sampling rate. For
   * instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
   * of client requests with the appropriate headers to be force traced. This field is a direct
   * analog for the runtime variable 'tracing.global_enabled' in the
   * :ref:`HTTP Connection Manager <config_http_conn_man_runtime>`.
   * Default: 100%
   */
  overall_sampling?:
    | FractionalPercent
    | undefined;
  /**
   * A list of custom tags with unique tag name to create tags for the active span.
   * It will take effect after merging with the :ref:`corresponding configuration
   * <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.Tracing.custom_tags>`
   * configured in the HTTP connection manager. If two tags with the same name are configured
   * each in the HTTP connection manager and the route level, the one configured here takes
   * priority.
   */
  custom_tags?: CustomTag[] | undefined;
}

/**
 * A virtual cluster is a way of specifying a regex matching rule against
 * certain important endpoints such that statistics are generated explicitly for
 * the matched requests. The reason this is useful is that when doing
 * prefix/path matching Envoy does not always know what the application
 * considers to be an endpoint. Thus, itâ€™s impossible for Envoy to generically
 * emit per endpoint statistics. However, often systems have highly critical
 * endpoints that they wish to get â€œperfectâ€ statistics on. Virtual cluster
 * statistics are perfect in the sense that they are emitted on the downstream
 * side such that they include network level failures.
 *
 * Documentation for :ref:`virtual cluster statistics <config_http_filters_router_vcluster_stats>`.
 *
 * .. note::
 *
 *    Virtual clusters are a useful tool, but we do not recommend setting up a virtual cluster for
 *    every application endpoint. This is both not easily maintainable and as well the matching and
 *    statistics output are not free.
 */
export interface VirtualCluster {
  $type: "envoy.api.v2.route.VirtualCluster";
  /**
   * Specifies a regex pattern to use for matching requests. The entire path of the request
   * must match the regex. The regex grammar used is defined `here
   * <https://en.cppreference.com/w/cpp/regex/ecmascript>`_.
   *
   * Examples:
   *
   * * The regex ``/rides/\d+`` matches the path * /rides/0*
   * * The regex ``/rides/\d+`` matches the path * /rides/123*
   * * The regex ``/rides/\d+`` does not match the path * /rides/123/456*
   *
   * .. attention::
   *   This field has been deprecated in favor of `headers` as it is not safe for use with
   *   untrusted input in all cases.
   *
   * @deprecated
   */
  pattern?:
    | string
    | undefined;
  /**
   * Specifies a list of header matchers to use for matching requests. Each specified header must
   * match. The pseudo-headers `:path` and `:method` can be used to match the request path and
   * method, respectively.
   */
  headers?:
    | HeaderMatcher[]
    | undefined;
  /**
   * Specifies the name of the virtual cluster. The virtual cluster name as well
   * as the virtual host name are used when emitting statistics. The statistics are emitted by the
   * router filter and are documented :ref:`here <config_http_filters_router_stats>`.
   */
  name?:
    | string
    | undefined;
  /**
   * Optionally specifies the HTTP method to match on. For example GET, PUT,
   * etc.
   *
   * .. attention::
   *   This field has been deprecated in favor of `headers`.
   *
   * @deprecated
   */
  method?: RequestMethod | undefined;
}

/** Global rate limiting :ref:`architecture overview <arch_overview_global_rate_limit>`. */
export interface RateLimit {
  $type: "envoy.api.v2.route.RateLimit";
  /**
   * Refers to the stage set in the filter. The rate limit configuration only
   * applies to filters with the same stage number. The default stage number is
   * 0.
   *
   * .. note::
   *
   *   The filter supports a range of 0 - 10 inclusively for stage numbers.
   */
  stage?:
    | number
    | undefined;
  /** The key to be set in runtime to disable this rate limit configuration. */
  disable_key?:
    | string
    | undefined;
  /**
   * A list of actions that are to be applied for this rate limit configuration.
   * Order matters as the actions are processed sequentially and the descriptor
   * is composed by appending descriptor entries in that sequence. If an action
   * cannot append a descriptor entry, no descriptor is generated for the
   * configuration. See :ref:`composing actions
   * <config_http_filters_rate_limit_composing_actions>` for additional documentation.
   */
  actions?: RateLimit_Action[] | undefined;
}

/** [#next-free-field: 7] */
export interface RateLimit_Action {
  $type: "envoy.api.v2.route.RateLimit.Action";
  action_specifier?:
    | //
    /** Rate limit on source cluster. */
    { $case: "source_cluster"; source_cluster: RateLimit_Action_SourceCluster }
    | //
    /** Rate limit on destination cluster. */
    { $case: "destination_cluster"; destination_cluster: RateLimit_Action_DestinationCluster }
    | //
    /** Rate limit on request headers. */
    { $case: "request_headers"; request_headers: RateLimit_Action_RequestHeaders }
    | //
    /** Rate limit on remote address. */
    { $case: "remote_address"; remote_address: RateLimit_Action_RemoteAddress }
    | //
    /** Rate limit on a generic key. */
    { $case: "generic_key"; generic_key: RateLimit_Action_GenericKey }
    | //
    /** Rate limit on the existence of request headers. */
    { $case: "header_value_match"; header_value_match: RateLimit_Action_HeaderValueMatch }
    | undefined;
}

/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("source_cluster", "<local service cluster>")
 *
 * <local service cluster> is derived from the :option:`--service-cluster` option.
 */
export interface RateLimit_Action_SourceCluster {
  $type: "envoy.api.v2.route.RateLimit.Action.SourceCluster";
}

/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("destination_cluster", "<routed target cluster>")
 *
 * Once a request matches against a route table rule, a routed cluster is determined by one of
 * the following :ref:`route table configuration <envoy_api_msg_RouteConfiguration>`
 * settings:
 *
 * * :ref:`cluster <envoy_api_field_route.RouteAction.cluster>` indicates the upstream cluster
 *   to route to.
 * * :ref:`weighted_clusters <envoy_api_field_route.RouteAction.weighted_clusters>`
 *   chooses a cluster randomly from a set of clusters with attributed weight.
 * * :ref:`cluster_header <envoy_api_field_route.RouteAction.cluster_header>` indicates which
 *   header in the request contains the target cluster.
 */
export interface RateLimit_Action_DestinationCluster {
  $type: "envoy.api.v2.route.RateLimit.Action.DestinationCluster";
}

/**
 * The following descriptor entry is appended when a header contains a key that matches the
 * *header_name*:
 *
 * .. code-block:: cpp
 *
 *   ("<descriptor_key>", "<header_value_queried_from_header>")
 */
export interface RateLimit_Action_RequestHeaders {
  $type: "envoy.api.v2.route.RateLimit.Action.RequestHeaders";
  /**
   * The header name to be queried from the request headers. The headerâ€™s
   * value is used to populate the value of the descriptor entry for the
   * descriptor_key.
   */
  header_name?:
    | string
    | undefined;
  /** The key to use in the descriptor entry. */
  descriptor_key?: string | undefined;
}

/**
 * The following descriptor entry is appended to the descriptor and is populated using the
 * trusted address from :ref:`x-forwarded-for <config_http_conn_man_headers_x-forwarded-for>`:
 *
 * .. code-block:: cpp
 *
 *   ("remote_address", "<trusted address from x-forwarded-for>")
 */
export interface RateLimit_Action_RemoteAddress {
  $type: "envoy.api.v2.route.RateLimit.Action.RemoteAddress";
}

/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("generic_key", "<descriptor_value>")
 */
export interface RateLimit_Action_GenericKey {
  $type: "envoy.api.v2.route.RateLimit.Action.GenericKey";
  /** The value to use in the descriptor entry. */
  descriptor_value?: string | undefined;
}

/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("header_match", "<descriptor_value>")
 */
export interface RateLimit_Action_HeaderValueMatch {
  $type: "envoy.api.v2.route.RateLimit.Action.HeaderValueMatch";
  /** The value to use in the descriptor entry. */
  descriptor_value?:
    | string
    | undefined;
  /**
   * If set to true, the action will append a descriptor entry when the
   * request matches the headers. If set to false, the action will append a
   * descriptor entry when the request does not match the headers. The
   * default value is true.
   */
  expect_match?:
    | boolean
    | undefined;
  /**
   * Specifies a set of headers that the rate limit action should match
   * on. The action will check the requestâ€™s headers against all the
   * specified headers in the config. A match will happen if all the
   * headers in the config are present in the request with the same values
   * (or based on presence if the value field is not in the config).
   */
  headers?: HeaderMatcher[] | undefined;
}

/**
 * .. attention::
 *
 *   Internally, Envoy always uses the HTTP/2 *:authority* header to represent the HTTP/1 *Host*
 *   header. Thus, if attempting to match on *Host*, match on *:authority* instead.
 *
 * .. attention::
 *
 *   To route on HTTP method, use the special HTTP/2 *:method* header. This works for both
 *   HTTP/1 and HTTP/2 as Envoy normalizes headers. E.g.,
 *
 *   .. code-block:: json
 *
 *     {
 *       "name": ":method",
 *       "exact_match": "POST"
 *     }
 *
 * .. attention::
 *   In the absence of any header match specifier, match will default to :ref:`present_match
 *   <envoy_api_field_route.HeaderMatcher.present_match>`. i.e, a request that has the :ref:`name
 *   <envoy_api_field_route.HeaderMatcher.name>` header will match, regardless of the header's
 *   value.
 *
 *  [#next-major-version: HeaderMatcher should be refactored to use StringMatcher.]
 * [#next-free-field: 12]
 */
export interface HeaderMatcher {
  $type: "envoy.api.v2.route.HeaderMatcher";
  /** Specifies the name of the header in the request. */
  name?:
    | string
    | undefined;
  /** Specifies how the header match will be performed to route the request. */
  header_match_specifier?:
    | //
    /** If specified, header match will be performed based on the value of the header. */
    { $case: "exact_match"; exact_match: string }
    | //
    /**
     * If specified, this regex string is a regular expression rule which implies the entire request
     * header value must match the regex. The rule will not match if only a subsequence of the
     * request header value matches the regex. The regex grammar used in the value field is defined
     * `here <https://en.cppreference.com/w/cpp/regex/ecmascript>`_.
     *
     * Examples:
     *
     * * The regex ``\d{3}`` matches the value *123*
     * * The regex ``\d{3}`` does not match the value *1234*
     * * The regex ``\d{3}`` does not match the value *123.456*
     *
     * .. attention::
     *   This field has been deprecated in favor of `safe_regex_match` as it is not safe for use
     *   with untrusted input in all cases.
     */
    { $case: "regex_match"; regex_match: string }
    | //
    /**
     * If specified, this regex string is a regular expression rule which implies the entire request
     * header value must match the regex. The rule will not match if only a subsequence of the
     * request header value matches the regex.
     */
    { $case: "safe_regex_match"; safe_regex_match: RegexMatcher }
    | //
    /**
     * If specified, header match will be performed based on range.
     * The rule will match if the request header value is within this range.
     * The entire request header value must represent an integer in base 10 notation: consisting of
     * an optional plus or minus sign followed by a sequence of digits. The rule will not match if
     * the header value does not represent an integer. Match will fail for empty values, floating
     * point numbers or if only a subsequence of the header value is an integer.
     *
     * Examples:
     *
     * * For range [-10,0), route will match for header value -1, but not for 0, "somestring", 10.9,
     *   "-1somestring"
     */
    { $case: "range_match"; range_match: Int64Range }
    | //
    /**
     * If specified, header match will be performed based on whether the header is in the
     * request.
     */
    { $case: "present_match"; present_match: boolean }
    | //
    /**
     * If specified, header match will be performed based on the prefix of the header value.
     * Note: empty prefix is not allowed, please use present_match instead.
     *
     * Examples:
     *
     * * The prefix *abcd* matches the value *abcdxyz*, but not for *abcxyz*.
     */
    { $case: "prefix_match"; prefix_match: string }
    | //
    /**
     * If specified, header match will be performed based on the suffix of the header value.
     * Note: empty suffix is not allowed, please use present_match instead.
     *
     * Examples:
     *
     * * The suffix *abcd* matches the value *xyzabcd*, but not for *xyzbcd*.
     */
    { $case: "suffix_match"; suffix_match: string }
    | undefined;
  /**
   * If specified, the match result will be inverted before checking. Defaults to false.
   *
   * Examples:
   *
   * * The regex ``\d{3}`` does not match the value *1234*, so it will match when inverted.
   * * The range [-10,0) will match the value -1, so it will not match when inverted.
   */
  invert_match?: boolean | undefined;
}

/**
 * Query parameter matching treats the query string of a request's :path header
 * as an ampersand-separated list of keys and/or key=value elements.
 * [#next-free-field: 7]
 */
export interface QueryParameterMatcher {
  $type: "envoy.api.v2.route.QueryParameterMatcher";
  /**
   * Specifies the name of a key that must be present in the requested
   * *path*'s query string.
   */
  name?:
    | string
    | undefined;
  /**
   * Specifies the value of the key. If the value is absent, a request
   * that contains the key in its query string will match, whether the
   * key appears with a value (e.g., "?debug=true") or not (e.g., "?debug")
   *
   * ..attention::
   *   This field is deprecated. Use an `exact` match inside the `string_match` field.
   *
   * @deprecated
   */
  value?:
    | string
    | undefined;
  /**
   * Specifies whether the query parameter value is a regular expression.
   * Defaults to false. The entire query parameter value (i.e., the part to
   * the right of the equals sign in "key=value") must match the regex.
   * E.g., the regex ``\d+$`` will match *123* but not *a123* or *123a*.
   *
   * ..attention::
   *   This field is deprecated. Use a `safe_regex` match inside the `string_match` field.
   *
   * @deprecated
   */
  regex?: boolean | undefined;
  query_parameter_match_specifier?:
    | //
    /** Specifies whether a query parameter value should match against a string. */
    { $case: "string_match"; string_match: StringMatcher }
    | //
    /** Specifies whether a query parameter should be present. */
    { $case: "present_match"; present_match: boolean }
    | undefined;
}

function createBaseVirtualHost(): VirtualHost {
  return { $type: "envoy.api.v2.route.VirtualHost" };
}

export const VirtualHost: MessageFns<VirtualHost, "envoy.api.v2.route.VirtualHost"> = {
  $type: "envoy.api.v2.route.VirtualHost" as const,

  encode(message: VirtualHost, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.domains !== undefined && message.domains.length !== 0) {
      for (const v of message.domains) {
        writer.uint32(18).string(v!);
      }
    }
    if (message.routes !== undefined && message.routes.length !== 0) {
      for (const v of message.routes) {
        Route.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    if (message.require_tls !== undefined && message.require_tls !== VirtualHost_TlsRequirementType.NONE) {
      writer.uint32(32).int32(virtualHost_TlsRequirementTypeToNumber(message.require_tls));
    }
    if (message.virtual_clusters !== undefined && message.virtual_clusters.length !== 0) {
      for (const v of message.virtual_clusters) {
        VirtualCluster.encode(v!, writer.uint32(42).fork()).join();
      }
    }
    if (message.rate_limits !== undefined && message.rate_limits.length !== 0) {
      for (const v of message.rate_limits) {
        RateLimit.encode(v!, writer.uint32(50).fork()).join();
      }
    }
    if (message.request_headers_to_add !== undefined && message.request_headers_to_add.length !== 0) {
      for (const v of message.request_headers_to_add) {
        HeaderValueOption.encode(v!, writer.uint32(58).fork()).join();
      }
    }
    if (message.request_headers_to_remove !== undefined && message.request_headers_to_remove.length !== 0) {
      for (const v of message.request_headers_to_remove) {
        writer.uint32(106).string(v!);
      }
    }
    if (message.response_headers_to_add !== undefined && message.response_headers_to_add.length !== 0) {
      for (const v of message.response_headers_to_add) {
        HeaderValueOption.encode(v!, writer.uint32(82).fork()).join();
      }
    }
    if (message.response_headers_to_remove !== undefined && message.response_headers_to_remove.length !== 0) {
      for (const v of message.response_headers_to_remove) {
        writer.uint32(90).string(v!);
      }
    }
    if (message.cors !== undefined) {
      CorsPolicy.encode(message.cors, writer.uint32(66).fork()).join();
    }
    (message.per_filter_config || new Map()).forEach((value, key) => {
      if (value !== undefined) {
        VirtualHost_PerFilterConfigEntry.encode({
          $type: "envoy.api.v2.route.VirtualHost.PerFilterConfigEntry",
          key: key as any,
          value,
        }, writer.uint32(98).fork()).join();
      }
    });
    (message.typed_per_filter_config || new Map()).forEach((value, key) => {
      VirtualHost_TypedPerFilterConfigEntry.encode({
        $type: "envoy.api.v2.route.VirtualHost.TypedPerFilterConfigEntry",
        key: key as any,
        value,
      }, writer.uint32(122).fork()).join();
    });
    if (message.include_request_attempt_count !== undefined && message.include_request_attempt_count !== false) {
      writer.uint32(112).bool(message.include_request_attempt_count);
    }
    if (
      message.include_attempt_count_in_response !== undefined && message.include_attempt_count_in_response !== false
    ) {
      writer.uint32(152).bool(message.include_attempt_count_in_response);
    }
    if (message.retry_policy !== undefined) {
      RetryPolicy.encode(message.retry_policy, writer.uint32(130).fork()).join();
    }
    if (message.retry_policy_typed_config !== undefined) {
      Any.encode(message.retry_policy_typed_config, writer.uint32(162).fork()).join();
    }
    if (message.hedge_policy !== undefined) {
      HedgePolicy.encode(message.hedge_policy, writer.uint32(138).fork()).join();
    }
    if (message.per_request_buffer_limit_bytes !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.per_request_buffer_limit_bytes! },
        writer.uint32(146).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VirtualHost {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVirtualHost();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.domains === undefined) {
            message.domains = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.domains!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.routes === undefined) {
            message.routes = [];
          }
          const el = Route.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.routes!.push(el);
          }
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.require_tls = virtualHost_TlsRequirementTypeFromJSON(reader.int32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          if (message.virtual_clusters === undefined) {
            message.virtual_clusters = [];
          }
          const el = VirtualCluster.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.virtual_clusters!.push(el);
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          if (message.rate_limits === undefined) {
            message.rate_limits = [];
          }
          const el = RateLimit.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.rate_limits!.push(el);
          }
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          if (message.request_headers_to_add === undefined) {
            message.request_headers_to_add = [];
          }
          const el = HeaderValueOption.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.request_headers_to_add!.push(el);
          }
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          if (message.request_headers_to_remove === undefined) {
            message.request_headers_to_remove = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.request_headers_to_remove!.push(el);
          }
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          if (message.response_headers_to_add === undefined) {
            message.response_headers_to_add = [];
          }
          const el = HeaderValueOption.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.response_headers_to_add!.push(el);
          }
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          if (message.response_headers_to_remove === undefined) {
            message.response_headers_to_remove = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.response_headers_to_remove!.push(el);
          }
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.cors = CorsPolicy.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          const entry12 = VirtualHost_PerFilterConfigEntry.decode(reader, reader.uint32());
          if (entry12.value !== undefined) {
            if (message.per_filter_config === undefined) {
              message.per_filter_config = new Map();
            }
            message.per_filter_config!.set(entry12.key, entry12.value);
          }
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          const entry15 = VirtualHost_TypedPerFilterConfigEntry.decode(reader, reader.uint32());
          if (entry15.value !== undefined) {
            if (message.typed_per_filter_config === undefined) {
              message.typed_per_filter_config = new Map();
            }
            message.typed_per_filter_config!.set(entry15.key, entry15.value);
          }
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.include_request_attempt_count = reader.bool();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.include_attempt_count_in_response = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.retry_policy = RetryPolicy.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.retry_policy_typed_config = Any.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.hedge_policy = HedgePolicy.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.per_request_buffer_limit_bytes = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VirtualHost {
    return {
      $type: VirtualHost.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      domains: globalThis.Array.isArray(object?.domains)
        ? object.domains.map((e: any) => globalThis.String(e))
        : undefined,
      routes: globalThis.Array.isArray(object?.routes) ? object.routes.map((e: any) => Route.fromJSON(e)) : undefined,
      require_tls: isSet(object.require_tls) ? virtualHost_TlsRequirementTypeFromJSON(object.require_tls) : undefined,
      virtual_clusters: globalThis.Array.isArray(object?.virtual_clusters)
        ? object.virtual_clusters.map((e: any) => VirtualCluster.fromJSON(e))
        : undefined,
      rate_limits: globalThis.Array.isArray(object?.rate_limits)
        ? object.rate_limits.map((e: any) => RateLimit.fromJSON(e))
        : undefined,
      request_headers_to_add: globalThis.Array.isArray(object?.request_headers_to_add)
        ? object.request_headers_to_add.map((e: any) => HeaderValueOption.fromJSON(e))
        : undefined,
      request_headers_to_remove: globalThis.Array.isArray(object?.request_headers_to_remove)
        ? object.request_headers_to_remove.map((e: any) => globalThis.String(e))
        : undefined,
      response_headers_to_add: globalThis.Array.isArray(object?.response_headers_to_add)
        ? object.response_headers_to_add.map((e: any) => HeaderValueOption.fromJSON(e))
        : undefined,
      response_headers_to_remove: globalThis.Array.isArray(object?.response_headers_to_remove)
        ? object.response_headers_to_remove.map((e: any) => globalThis.String(e))
        : undefined,
      cors: isSet(object.cors) ? CorsPolicy.fromJSON(object.cors) : undefined,
      per_filter_config: isObject(object.per_filter_config)
        ? Object.entries(object.per_filter_config).reduce<Map<string, { [key: string]: any } | undefined>>(
          (acc, [key, value]) => {
            acc.set(key, value as { [key: string]: any } | undefined);
            return acc;
          },
          new Map(),
        )
        : undefined,
      typed_per_filter_config: isObject(object.typed_per_filter_config)
        ? Object.entries(object.typed_per_filter_config).reduce<Map<string, Any>>((acc, [key, value]) => {
          acc.set(key, Any.fromJSON(value));
          return acc;
        }, new Map())
        : undefined,
      include_request_attempt_count: isSet(object.include_request_attempt_count)
        ? globalThis.Boolean(object.include_request_attempt_count)
        : undefined,
      include_attempt_count_in_response: isSet(object.include_attempt_count_in_response)
        ? globalThis.Boolean(object.include_attempt_count_in_response)
        : undefined,
      retry_policy: isSet(object.retry_policy) ? RetryPolicy.fromJSON(object.retry_policy) : undefined,
      retry_policy_typed_config: isSet(object.retry_policy_typed_config)
        ? Any.fromJSON(object.retry_policy_typed_config)
        : undefined,
      hedge_policy: isSet(object.hedge_policy) ? HedgePolicy.fromJSON(object.hedge_policy) : undefined,
      per_request_buffer_limit_bytes: isSet(object.per_request_buffer_limit_bytes)
        ? Number(object.per_request_buffer_limit_bytes)
        : undefined,
    };
  },

  toJSON(message: VirtualHost): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.domains?.length) {
      obj.domains = message.domains;
    }
    if (message.routes?.length) {
      obj.routes = message.routes.map((e) => Route.toJSON(e));
    }
    if (message.require_tls !== undefined) {
      obj.require_tls = virtualHost_TlsRequirementTypeToJSON(message.require_tls);
    }
    if (message.virtual_clusters?.length) {
      obj.virtual_clusters = message.virtual_clusters.map((e) => VirtualCluster.toJSON(e));
    }
    if (message.rate_limits?.length) {
      obj.rate_limits = message.rate_limits.map((e) => RateLimit.toJSON(e));
    }
    if (message.request_headers_to_add?.length) {
      obj.request_headers_to_add = message.request_headers_to_add.map((e) => HeaderValueOption.toJSON(e));
    }
    if (message.request_headers_to_remove?.length) {
      obj.request_headers_to_remove = message.request_headers_to_remove;
    }
    if (message.response_headers_to_add?.length) {
      obj.response_headers_to_add = message.response_headers_to_add.map((e) => HeaderValueOption.toJSON(e));
    }
    if (message.response_headers_to_remove?.length) {
      obj.response_headers_to_remove = message.response_headers_to_remove;
    }
    if (message.cors !== undefined) {
      obj.cors = CorsPolicy.toJSON(message.cors);
    }
    if (message.per_filter_config?.size) {
      obj.per_filter_config = {};
      message.per_filter_config.forEach((v, k) => {
        obj.per_filter_config[k] = v;
      });
    }
    if (message.typed_per_filter_config?.size) {
      obj.typed_per_filter_config = {};
      message.typed_per_filter_config.forEach((v, k) => {
        obj.typed_per_filter_config[k] = Any.toJSON(v);
      });
    }
    if (message.include_request_attempt_count !== undefined) {
      obj.include_request_attempt_count = message.include_request_attempt_count;
    }
    if (message.include_attempt_count_in_response !== undefined) {
      obj.include_attempt_count_in_response = message.include_attempt_count_in_response;
    }
    if (message.retry_policy !== undefined) {
      obj.retry_policy = RetryPolicy.toJSON(message.retry_policy);
    }
    if (message.retry_policy_typed_config !== undefined) {
      obj.retry_policy_typed_config = Any.toJSON(message.retry_policy_typed_config);
    }
    if (message.hedge_policy !== undefined) {
      obj.hedge_policy = HedgePolicy.toJSON(message.hedge_policy);
    }
    if (message.per_request_buffer_limit_bytes !== undefined) {
      obj.per_request_buffer_limit_bytes = message.per_request_buffer_limit_bytes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VirtualHost>, I>>(base?: I): VirtualHost {
    return VirtualHost.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VirtualHost>, I>>(object: I): VirtualHost {
    const message = createBaseVirtualHost();
    message.name = object.name ?? undefined;
    message.domains = object.domains?.map((e) => e) || undefined;
    message.routes = object.routes?.map((e) => Route.fromPartial(e)) || undefined;
    message.require_tls = object.require_tls ?? undefined;
    message.virtual_clusters = object.virtual_clusters?.map((e) => VirtualCluster.fromPartial(e)) || undefined;
    message.rate_limits = object.rate_limits?.map((e) => RateLimit.fromPartial(e)) || undefined;
    message.request_headers_to_add = object.request_headers_to_add?.map((e) => HeaderValueOption.fromPartial(e)) ||
      undefined;
    message.request_headers_to_remove = object.request_headers_to_remove?.map((e) => e) || undefined;
    message.response_headers_to_add = object.response_headers_to_add?.map((e) => HeaderValueOption.fromPartial(e)) ||
      undefined;
    message.response_headers_to_remove = object.response_headers_to_remove?.map((e) => e) || undefined;
    message.cors = (object.cors !== undefined && object.cors !== null)
      ? CorsPolicy.fromPartial(object.cors)
      : undefined;
    message.per_filter_config = (object.per_filter_config === undefined || object.per_filter_config === null)
      ? undefined
      : (() => {
        const m = new Map();
        (object.per_filter_config as Map<string, { [key: string]: any } | undefined> ?? new Map()).forEach(
          (value, key) => {
            if (value !== undefined) {
              m.set(key, value);
            }
          },
        );
        return m;
      })();
    message.typed_per_filter_config =
      (object.typed_per_filter_config === undefined || object.typed_per_filter_config === null) ? undefined : (() => {
        const m = new Map();
        (object.typed_per_filter_config as Map<string, Any> ?? new Map()).forEach((value, key) => {
          if (value !== undefined) {
            m.set(key, Any.fromPartial(value));
          }
        });
        return m;
      })();
    message.include_request_attempt_count = object.include_request_attempt_count ?? undefined;
    message.include_attempt_count_in_response = object.include_attempt_count_in_response ?? undefined;
    message.retry_policy = (object.retry_policy !== undefined && object.retry_policy !== null)
      ? RetryPolicy.fromPartial(object.retry_policy)
      : undefined;
    message.retry_policy_typed_config =
      (object.retry_policy_typed_config !== undefined && object.retry_policy_typed_config !== null)
        ? Any.fromPartial(object.retry_policy_typed_config)
        : undefined;
    message.hedge_policy = (object.hedge_policy !== undefined && object.hedge_policy !== null)
      ? HedgePolicy.fromPartial(object.hedge_policy)
      : undefined;
    message.per_request_buffer_limit_bytes = object.per_request_buffer_limit_bytes ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(VirtualHost.$type, VirtualHost);

function createBaseVirtualHost_PerFilterConfigEntry(): VirtualHost_PerFilterConfigEntry {
  return { $type: "envoy.api.v2.route.VirtualHost.PerFilterConfigEntry", key: "" };
}

export const VirtualHost_PerFilterConfigEntry: MessageFns<
  VirtualHost_PerFilterConfigEntry,
  "envoy.api.v2.route.VirtualHost.PerFilterConfigEntry"
> = {
  $type: "envoy.api.v2.route.VirtualHost.PerFilterConfigEntry" as const,

  encode(message: VirtualHost_PerFilterConfigEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Struct.encode(Struct.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VirtualHost_PerFilterConfigEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVirtualHost_PerFilterConfigEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VirtualHost_PerFilterConfigEntry {
    return {
      $type: VirtualHost_PerFilterConfigEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isObject(object.value) ? object.value : undefined,
    };
  },

  toJSON(message: VirtualHost_PerFilterConfigEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VirtualHost_PerFilterConfigEntry>, I>>(
    base?: I,
  ): VirtualHost_PerFilterConfigEntry {
    return VirtualHost_PerFilterConfigEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VirtualHost_PerFilterConfigEntry>, I>>(
    object: I,
  ): VirtualHost_PerFilterConfigEntry {
    const message = createBaseVirtualHost_PerFilterConfigEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(VirtualHost_PerFilterConfigEntry.$type, VirtualHost_PerFilterConfigEntry);

function createBaseVirtualHost_TypedPerFilterConfigEntry(): VirtualHost_TypedPerFilterConfigEntry {
  return { $type: "envoy.api.v2.route.VirtualHost.TypedPerFilterConfigEntry", key: "" };
}

export const VirtualHost_TypedPerFilterConfigEntry: MessageFns<
  VirtualHost_TypedPerFilterConfigEntry,
  "envoy.api.v2.route.VirtualHost.TypedPerFilterConfigEntry"
> = {
  $type: "envoy.api.v2.route.VirtualHost.TypedPerFilterConfigEntry" as const,

  encode(message: VirtualHost_TypedPerFilterConfigEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Any.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VirtualHost_TypedPerFilterConfigEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVirtualHost_TypedPerFilterConfigEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VirtualHost_TypedPerFilterConfigEntry {
    return {
      $type: VirtualHost_TypedPerFilterConfigEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Any.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: VirtualHost_TypedPerFilterConfigEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Any.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VirtualHost_TypedPerFilterConfigEntry>, I>>(
    base?: I,
  ): VirtualHost_TypedPerFilterConfigEntry {
    return VirtualHost_TypedPerFilterConfigEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VirtualHost_TypedPerFilterConfigEntry>, I>>(
    object: I,
  ): VirtualHost_TypedPerFilterConfigEntry {
    const message = createBaseVirtualHost_TypedPerFilterConfigEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Any.fromPartial(object.value) : undefined;
    return message;
  },
};

messageTypeRegistry.set(VirtualHost_TypedPerFilterConfigEntry.$type, VirtualHost_TypedPerFilterConfigEntry);

function createBaseFilterAction(): FilterAction {
  return { $type: "envoy.api.v2.route.FilterAction" };
}

export const FilterAction: MessageFns<FilterAction, "envoy.api.v2.route.FilterAction"> = {
  $type: "envoy.api.v2.route.FilterAction" as const,

  encode(message: FilterAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.action !== undefined) {
      Any.encode(message.action, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FilterAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilterAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.action = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FilterAction {
    return { $type: FilterAction.$type, action: isSet(object.action) ? Any.fromJSON(object.action) : undefined };
  },

  toJSON(message: FilterAction): unknown {
    const obj: any = {};
    if (message.action !== undefined) {
      obj.action = Any.toJSON(message.action);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FilterAction>, I>>(base?: I): FilterAction {
    return FilterAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FilterAction>, I>>(object: I): FilterAction {
    const message = createBaseFilterAction();
    message.action = (object.action !== undefined && object.action !== null)
      ? Any.fromPartial(object.action)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(FilterAction.$type, FilterAction);

function createBaseRoute(): Route {
  return { $type: "envoy.api.v2.route.Route", action: undefined };
}

export const Route: MessageFns<Route, "envoy.api.v2.route.Route"> = {
  $type: "envoy.api.v2.route.Route" as const,

  encode(message: Route, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(114).string(message.name);
    }
    if (message.match !== undefined) {
      RouteMatch.encode(message.match, writer.uint32(10).fork()).join();
    }
    switch (message.action?.$case) {
      case "route":
        RouteAction.encode(message.action.route, writer.uint32(18).fork()).join();
        break;
      case "redirect":
        RedirectAction.encode(message.action.redirect, writer.uint32(26).fork()).join();
        break;
      case "direct_response":
        DirectResponseAction.encode(message.action.direct_response, writer.uint32(58).fork()).join();
        break;
      case "filter_action":
        FilterAction.encode(message.action.filter_action, writer.uint32(138).fork()).join();
        break;
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.decorator !== undefined) {
      Decorator.encode(message.decorator, writer.uint32(42).fork()).join();
    }
    (message.per_filter_config || new Map()).forEach((value, key) => {
      if (value !== undefined) {
        Route_PerFilterConfigEntry.encode({
          $type: "envoy.api.v2.route.Route.PerFilterConfigEntry",
          key: key as any,
          value,
        }, writer.uint32(66).fork()).join();
      }
    });
    (message.typed_per_filter_config || new Map()).forEach((value, key) => {
      Route_TypedPerFilterConfigEntry.encode({
        $type: "envoy.api.v2.route.Route.TypedPerFilterConfigEntry",
        key: key as any,
        value,
      }, writer.uint32(106).fork()).join();
    });
    if (message.request_headers_to_add !== undefined && message.request_headers_to_add.length !== 0) {
      for (const v of message.request_headers_to_add) {
        HeaderValueOption.encode(v!, writer.uint32(74).fork()).join();
      }
    }
    if (message.request_headers_to_remove !== undefined && message.request_headers_to_remove.length !== 0) {
      for (const v of message.request_headers_to_remove) {
        writer.uint32(98).string(v!);
      }
    }
    if (message.response_headers_to_add !== undefined && message.response_headers_to_add.length !== 0) {
      for (const v of message.response_headers_to_add) {
        HeaderValueOption.encode(v!, writer.uint32(82).fork()).join();
      }
    }
    if (message.response_headers_to_remove !== undefined && message.response_headers_to_remove.length !== 0) {
      for (const v of message.response_headers_to_remove) {
        writer.uint32(90).string(v!);
      }
    }
    if (message.tracing !== undefined) {
      Tracing.encode(message.tracing, writer.uint32(122).fork()).join();
    }
    if (message.per_request_buffer_limit_bytes !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.per_request_buffer_limit_bytes! },
        writer.uint32(130).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Route {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.match = RouteMatch.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.action = { $case: "route", route: RouteAction.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.action = { $case: "redirect", redirect: RedirectAction.decode(reader, reader.uint32()) };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.action = {
            $case: "direct_response",
            direct_response: DirectResponseAction.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.action = { $case: "filter_action", filter_action: FilterAction.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.decorator = Decorator.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const entry8 = Route_PerFilterConfigEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            if (message.per_filter_config === undefined) {
              message.per_filter_config = new Map();
            }
            message.per_filter_config!.set(entry8.key, entry8.value);
          }
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          const entry13 = Route_TypedPerFilterConfigEntry.decode(reader, reader.uint32());
          if (entry13.value !== undefined) {
            if (message.typed_per_filter_config === undefined) {
              message.typed_per_filter_config = new Map();
            }
            message.typed_per_filter_config!.set(entry13.key, entry13.value);
          }
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          if (message.request_headers_to_add === undefined) {
            message.request_headers_to_add = [];
          }
          const el = HeaderValueOption.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.request_headers_to_add!.push(el);
          }
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          if (message.request_headers_to_remove === undefined) {
            message.request_headers_to_remove = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.request_headers_to_remove!.push(el);
          }
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          if (message.response_headers_to_add === undefined) {
            message.response_headers_to_add = [];
          }
          const el = HeaderValueOption.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.response_headers_to_add!.push(el);
          }
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          if (message.response_headers_to_remove === undefined) {
            message.response_headers_to_remove = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.response_headers_to_remove!.push(el);
          }
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.tracing = Tracing.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.per_request_buffer_limit_bytes = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Route {
    return {
      $type: Route.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      match: isSet(object.match) ? RouteMatch.fromJSON(object.match) : undefined,
      action: isSet(object.route)
        ? { $case: "route", route: RouteAction.fromJSON(object.route) }
        : isSet(object.redirect)
        ? { $case: "redirect", redirect: RedirectAction.fromJSON(object.redirect) }
        : isSet(object.direct_response)
        ? { $case: "direct_response", direct_response: DirectResponseAction.fromJSON(object.direct_response) }
        : isSet(object.filter_action)
        ? { $case: "filter_action", filter_action: FilterAction.fromJSON(object.filter_action) }
        : undefined,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      decorator: isSet(object.decorator) ? Decorator.fromJSON(object.decorator) : undefined,
      per_filter_config: isObject(object.per_filter_config)
        ? Object.entries(object.per_filter_config).reduce<Map<string, { [key: string]: any } | undefined>>(
          (acc, [key, value]) => {
            acc.set(key, value as { [key: string]: any } | undefined);
            return acc;
          },
          new Map(),
        )
        : undefined,
      typed_per_filter_config: isObject(object.typed_per_filter_config)
        ? Object.entries(object.typed_per_filter_config).reduce<Map<string, Any>>((acc, [key, value]) => {
          acc.set(key, Any.fromJSON(value));
          return acc;
        }, new Map())
        : undefined,
      request_headers_to_add: globalThis.Array.isArray(object?.request_headers_to_add)
        ? object.request_headers_to_add.map((e: any) => HeaderValueOption.fromJSON(e))
        : undefined,
      request_headers_to_remove: globalThis.Array.isArray(object?.request_headers_to_remove)
        ? object.request_headers_to_remove.map((e: any) => globalThis.String(e))
        : undefined,
      response_headers_to_add: globalThis.Array.isArray(object?.response_headers_to_add)
        ? object.response_headers_to_add.map((e: any) => HeaderValueOption.fromJSON(e))
        : undefined,
      response_headers_to_remove: globalThis.Array.isArray(object?.response_headers_to_remove)
        ? object.response_headers_to_remove.map((e: any) => globalThis.String(e))
        : undefined,
      tracing: isSet(object.tracing) ? Tracing.fromJSON(object.tracing) : undefined,
      per_request_buffer_limit_bytes: isSet(object.per_request_buffer_limit_bytes)
        ? Number(object.per_request_buffer_limit_bytes)
        : undefined,
    };
  },

  toJSON(message: Route): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.match !== undefined) {
      obj.match = RouteMatch.toJSON(message.match);
    }
    if (message.action?.$case === "route") {
      obj.route = RouteAction.toJSON(message.action.route);
    }
    if (message.action?.$case === "redirect") {
      obj.redirect = RedirectAction.toJSON(message.action.redirect);
    }
    if (message.action?.$case === "direct_response") {
      obj.direct_response = DirectResponseAction.toJSON(message.action.direct_response);
    }
    if (message.action?.$case === "filter_action") {
      obj.filter_action = FilterAction.toJSON(message.action.filter_action);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.decorator !== undefined) {
      obj.decorator = Decorator.toJSON(message.decorator);
    }
    if (message.per_filter_config?.size) {
      obj.per_filter_config = {};
      message.per_filter_config.forEach((v, k) => {
        obj.per_filter_config[k] = v;
      });
    }
    if (message.typed_per_filter_config?.size) {
      obj.typed_per_filter_config = {};
      message.typed_per_filter_config.forEach((v, k) => {
        obj.typed_per_filter_config[k] = Any.toJSON(v);
      });
    }
    if (message.request_headers_to_add?.length) {
      obj.request_headers_to_add = message.request_headers_to_add.map((e) => HeaderValueOption.toJSON(e));
    }
    if (message.request_headers_to_remove?.length) {
      obj.request_headers_to_remove = message.request_headers_to_remove;
    }
    if (message.response_headers_to_add?.length) {
      obj.response_headers_to_add = message.response_headers_to_add.map((e) => HeaderValueOption.toJSON(e));
    }
    if (message.response_headers_to_remove?.length) {
      obj.response_headers_to_remove = message.response_headers_to_remove;
    }
    if (message.tracing !== undefined) {
      obj.tracing = Tracing.toJSON(message.tracing);
    }
    if (message.per_request_buffer_limit_bytes !== undefined) {
      obj.per_request_buffer_limit_bytes = message.per_request_buffer_limit_bytes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Route>, I>>(base?: I): Route {
    return Route.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Route>, I>>(object: I): Route {
    const message = createBaseRoute();
    message.name = object.name ?? undefined;
    message.match = (object.match !== undefined && object.match !== null)
      ? RouteMatch.fromPartial(object.match)
      : undefined;
    if (object.action?.$case === "route" && object.action?.route !== undefined && object.action?.route !== null) {
      message.action = { $case: "route", route: RouteAction.fromPartial(object.action.route) };
    }
    if (
      object.action?.$case === "redirect" && object.action?.redirect !== undefined && object.action?.redirect !== null
    ) {
      message.action = { $case: "redirect", redirect: RedirectAction.fromPartial(object.action.redirect) };
    }
    if (
      object.action?.$case === "direct_response" &&
      object.action?.direct_response !== undefined &&
      object.action?.direct_response !== null
    ) {
      message.action = {
        $case: "direct_response",
        direct_response: DirectResponseAction.fromPartial(object.action.direct_response),
      };
    }
    if (
      object.action?.$case === "filter_action" &&
      object.action?.filter_action !== undefined &&
      object.action?.filter_action !== null
    ) {
      message.action = { $case: "filter_action", filter_action: FilterAction.fromPartial(object.action.filter_action) };
    }
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.decorator = (object.decorator !== undefined && object.decorator !== null)
      ? Decorator.fromPartial(object.decorator)
      : undefined;
    message.per_filter_config = (object.per_filter_config === undefined || object.per_filter_config === null)
      ? undefined
      : (() => {
        const m = new Map();
        (object.per_filter_config as Map<string, { [key: string]: any } | undefined> ?? new Map()).forEach(
          (value, key) => {
            if (value !== undefined) {
              m.set(key, value);
            }
          },
        );
        return m;
      })();
    message.typed_per_filter_config =
      (object.typed_per_filter_config === undefined || object.typed_per_filter_config === null) ? undefined : (() => {
        const m = new Map();
        (object.typed_per_filter_config as Map<string, Any> ?? new Map()).forEach((value, key) => {
          if (value !== undefined) {
            m.set(key, Any.fromPartial(value));
          }
        });
        return m;
      })();
    message.request_headers_to_add = object.request_headers_to_add?.map((e) => HeaderValueOption.fromPartial(e)) ||
      undefined;
    message.request_headers_to_remove = object.request_headers_to_remove?.map((e) => e) || undefined;
    message.response_headers_to_add = object.response_headers_to_add?.map((e) => HeaderValueOption.fromPartial(e)) ||
      undefined;
    message.response_headers_to_remove = object.response_headers_to_remove?.map((e) => e) || undefined;
    message.tracing = (object.tracing !== undefined && object.tracing !== null)
      ? Tracing.fromPartial(object.tracing)
      : undefined;
    message.per_request_buffer_limit_bytes = object.per_request_buffer_limit_bytes ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Route.$type, Route);

function createBaseRoute_PerFilterConfigEntry(): Route_PerFilterConfigEntry {
  return { $type: "envoy.api.v2.route.Route.PerFilterConfigEntry", key: "" };
}

export const Route_PerFilterConfigEntry: MessageFns<
  Route_PerFilterConfigEntry,
  "envoy.api.v2.route.Route.PerFilterConfigEntry"
> = {
  $type: "envoy.api.v2.route.Route.PerFilterConfigEntry" as const,

  encode(message: Route_PerFilterConfigEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Struct.encode(Struct.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Route_PerFilterConfigEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoute_PerFilterConfigEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Route_PerFilterConfigEntry {
    return {
      $type: Route_PerFilterConfigEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isObject(object.value) ? object.value : undefined,
    };
  },

  toJSON(message: Route_PerFilterConfigEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Route_PerFilterConfigEntry>, I>>(base?: I): Route_PerFilterConfigEntry {
    return Route_PerFilterConfigEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Route_PerFilterConfigEntry>, I>>(object: I): Route_PerFilterConfigEntry {
    const message = createBaseRoute_PerFilterConfigEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Route_PerFilterConfigEntry.$type, Route_PerFilterConfigEntry);

function createBaseRoute_TypedPerFilterConfigEntry(): Route_TypedPerFilterConfigEntry {
  return { $type: "envoy.api.v2.route.Route.TypedPerFilterConfigEntry", key: "" };
}

export const Route_TypedPerFilterConfigEntry: MessageFns<
  Route_TypedPerFilterConfigEntry,
  "envoy.api.v2.route.Route.TypedPerFilterConfigEntry"
> = {
  $type: "envoy.api.v2.route.Route.TypedPerFilterConfigEntry" as const,

  encode(message: Route_TypedPerFilterConfigEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Any.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Route_TypedPerFilterConfigEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoute_TypedPerFilterConfigEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Route_TypedPerFilterConfigEntry {
    return {
      $type: Route_TypedPerFilterConfigEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Any.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Route_TypedPerFilterConfigEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Any.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Route_TypedPerFilterConfigEntry>, I>>(base?: I): Route_TypedPerFilterConfigEntry {
    return Route_TypedPerFilterConfigEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Route_TypedPerFilterConfigEntry>, I>>(
    object: I,
  ): Route_TypedPerFilterConfigEntry {
    const message = createBaseRoute_TypedPerFilterConfigEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Any.fromPartial(object.value) : undefined;
    return message;
  },
};

messageTypeRegistry.set(Route_TypedPerFilterConfigEntry.$type, Route_TypedPerFilterConfigEntry);

function createBaseWeightedCluster(): WeightedCluster {
  return { $type: "envoy.api.v2.route.WeightedCluster" };
}

export const WeightedCluster: MessageFns<WeightedCluster, "envoy.api.v2.route.WeightedCluster"> = {
  $type: "envoy.api.v2.route.WeightedCluster" as const,

  encode(message: WeightedCluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clusters !== undefined && message.clusters.length !== 0) {
      for (const v of message.clusters) {
        WeightedCluster_ClusterWeight.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    if (message.total_weight !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.total_weight! },
        writer.uint32(26).fork(),
      ).join();
    }
    if (message.runtime_key_prefix !== undefined && message.runtime_key_prefix !== "") {
      writer.uint32(18).string(message.runtime_key_prefix);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WeightedCluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWeightedCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.clusters === undefined) {
            message.clusters = [];
          }
          const el = WeightedCluster_ClusterWeight.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.clusters!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.total_weight = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.runtime_key_prefix = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WeightedCluster {
    return {
      $type: WeightedCluster.$type,
      clusters: globalThis.Array.isArray(object?.clusters)
        ? object.clusters.map((e: any) => WeightedCluster_ClusterWeight.fromJSON(e))
        : undefined,
      total_weight: isSet(object.total_weight) ? Number(object.total_weight) : undefined,
      runtime_key_prefix: isSet(object.runtime_key_prefix) ? globalThis.String(object.runtime_key_prefix) : undefined,
    };
  },

  toJSON(message: WeightedCluster): unknown {
    const obj: any = {};
    if (message.clusters?.length) {
      obj.clusters = message.clusters.map((e) => WeightedCluster_ClusterWeight.toJSON(e));
    }
    if (message.total_weight !== undefined) {
      obj.total_weight = message.total_weight;
    }
    if (message.runtime_key_prefix !== undefined) {
      obj.runtime_key_prefix = message.runtime_key_prefix;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WeightedCluster>, I>>(base?: I): WeightedCluster {
    return WeightedCluster.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WeightedCluster>, I>>(object: I): WeightedCluster {
    const message = createBaseWeightedCluster();
    message.clusters = object.clusters?.map((e) => WeightedCluster_ClusterWeight.fromPartial(e)) || undefined;
    message.total_weight = object.total_weight ?? undefined;
    message.runtime_key_prefix = object.runtime_key_prefix ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(WeightedCluster.$type, WeightedCluster);

function createBaseWeightedCluster_ClusterWeight(): WeightedCluster_ClusterWeight {
  return { $type: "envoy.api.v2.route.WeightedCluster.ClusterWeight" };
}

export const WeightedCluster_ClusterWeight: MessageFns<
  WeightedCluster_ClusterWeight,
  "envoy.api.v2.route.WeightedCluster.ClusterWeight"
> = {
  $type: "envoy.api.v2.route.WeightedCluster.ClusterWeight" as const,

  encode(message: WeightedCluster_ClusterWeight, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.weight !== undefined) {
      UInt32Value.encode({ $type: "google.protobuf.UInt32Value", value: message.weight! }, writer.uint32(18).fork())
        .join();
    }
    if (message.metadata_match !== undefined) {
      Metadata.encode(message.metadata_match, writer.uint32(26).fork()).join();
    }
    if (message.request_headers_to_add !== undefined && message.request_headers_to_add.length !== 0) {
      for (const v of message.request_headers_to_add) {
        HeaderValueOption.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    if (message.request_headers_to_remove !== undefined && message.request_headers_to_remove.length !== 0) {
      for (const v of message.request_headers_to_remove) {
        writer.uint32(74).string(v!);
      }
    }
    if (message.response_headers_to_add !== undefined && message.response_headers_to_add.length !== 0) {
      for (const v of message.response_headers_to_add) {
        HeaderValueOption.encode(v!, writer.uint32(42).fork()).join();
      }
    }
    if (message.response_headers_to_remove !== undefined && message.response_headers_to_remove.length !== 0) {
      for (const v of message.response_headers_to_remove) {
        writer.uint32(50).string(v!);
      }
    }
    (message.per_filter_config || new Map()).forEach((value, key) => {
      if (value !== undefined) {
        WeightedCluster_ClusterWeight_PerFilterConfigEntry.encode({
          $type: "envoy.api.v2.route.WeightedCluster.ClusterWeight.PerFilterConfigEntry",
          key: key as any,
          value,
        }, writer.uint32(66).fork()).join();
      }
    });
    (message.typed_per_filter_config || new Map()).forEach((value, key) => {
      WeightedCluster_ClusterWeight_TypedPerFilterConfigEntry.encode({
        $type: "envoy.api.v2.route.WeightedCluster.ClusterWeight.TypedPerFilterConfigEntry",
        key: key as any,
        value,
      }, writer.uint32(82).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WeightedCluster_ClusterWeight {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWeightedCluster_ClusterWeight();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.weight = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata_match = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          if (message.request_headers_to_add === undefined) {
            message.request_headers_to_add = [];
          }
          const el = HeaderValueOption.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.request_headers_to_add!.push(el);
          }
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          if (message.request_headers_to_remove === undefined) {
            message.request_headers_to_remove = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.request_headers_to_remove!.push(el);
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          if (message.response_headers_to_add === undefined) {
            message.response_headers_to_add = [];
          }
          const el = HeaderValueOption.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.response_headers_to_add!.push(el);
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          if (message.response_headers_to_remove === undefined) {
            message.response_headers_to_remove = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.response_headers_to_remove!.push(el);
          }
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const entry8 = WeightedCluster_ClusterWeight_PerFilterConfigEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            if (message.per_filter_config === undefined) {
              message.per_filter_config = new Map();
            }
            message.per_filter_config!.set(entry8.key, entry8.value);
          }
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          const entry10 = WeightedCluster_ClusterWeight_TypedPerFilterConfigEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            if (message.typed_per_filter_config === undefined) {
              message.typed_per_filter_config = new Map();
            }
            message.typed_per_filter_config!.set(entry10.key, entry10.value);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WeightedCluster_ClusterWeight {
    return {
      $type: WeightedCluster_ClusterWeight.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      weight: isSet(object.weight) ? Number(object.weight) : undefined,
      metadata_match: isSet(object.metadata_match) ? Metadata.fromJSON(object.metadata_match) : undefined,
      request_headers_to_add: globalThis.Array.isArray(object?.request_headers_to_add)
        ? object.request_headers_to_add.map((e: any) => HeaderValueOption.fromJSON(e))
        : undefined,
      request_headers_to_remove: globalThis.Array.isArray(object?.request_headers_to_remove)
        ? object.request_headers_to_remove.map((e: any) => globalThis.String(e))
        : undefined,
      response_headers_to_add: globalThis.Array.isArray(object?.response_headers_to_add)
        ? object.response_headers_to_add.map((e: any) => HeaderValueOption.fromJSON(e))
        : undefined,
      response_headers_to_remove: globalThis.Array.isArray(object?.response_headers_to_remove)
        ? object.response_headers_to_remove.map((e: any) => globalThis.String(e))
        : undefined,
      per_filter_config: isObject(object.per_filter_config)
        ? Object.entries(object.per_filter_config).reduce<Map<string, { [key: string]: any } | undefined>>(
          (acc, [key, value]) => {
            acc.set(key, value as { [key: string]: any } | undefined);
            return acc;
          },
          new Map(),
        )
        : undefined,
      typed_per_filter_config: isObject(object.typed_per_filter_config)
        ? Object.entries(object.typed_per_filter_config).reduce<Map<string, Any>>((acc, [key, value]) => {
          acc.set(key, Any.fromJSON(value));
          return acc;
        }, new Map())
        : undefined,
    };
  },

  toJSON(message: WeightedCluster_ClusterWeight): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.weight !== undefined) {
      obj.weight = message.weight;
    }
    if (message.metadata_match !== undefined) {
      obj.metadata_match = Metadata.toJSON(message.metadata_match);
    }
    if (message.request_headers_to_add?.length) {
      obj.request_headers_to_add = message.request_headers_to_add.map((e) => HeaderValueOption.toJSON(e));
    }
    if (message.request_headers_to_remove?.length) {
      obj.request_headers_to_remove = message.request_headers_to_remove;
    }
    if (message.response_headers_to_add?.length) {
      obj.response_headers_to_add = message.response_headers_to_add.map((e) => HeaderValueOption.toJSON(e));
    }
    if (message.response_headers_to_remove?.length) {
      obj.response_headers_to_remove = message.response_headers_to_remove;
    }
    if (message.per_filter_config?.size) {
      obj.per_filter_config = {};
      message.per_filter_config.forEach((v, k) => {
        obj.per_filter_config[k] = v;
      });
    }
    if (message.typed_per_filter_config?.size) {
      obj.typed_per_filter_config = {};
      message.typed_per_filter_config.forEach((v, k) => {
        obj.typed_per_filter_config[k] = Any.toJSON(v);
      });
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WeightedCluster_ClusterWeight>, I>>(base?: I): WeightedCluster_ClusterWeight {
    return WeightedCluster_ClusterWeight.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WeightedCluster_ClusterWeight>, I>>(
    object: I,
  ): WeightedCluster_ClusterWeight {
    const message = createBaseWeightedCluster_ClusterWeight();
    message.name = object.name ?? undefined;
    message.weight = object.weight ?? undefined;
    message.metadata_match = (object.metadata_match !== undefined && object.metadata_match !== null)
      ? Metadata.fromPartial(object.metadata_match)
      : undefined;
    message.request_headers_to_add = object.request_headers_to_add?.map((e) => HeaderValueOption.fromPartial(e)) ||
      undefined;
    message.request_headers_to_remove = object.request_headers_to_remove?.map((e) => e) || undefined;
    message.response_headers_to_add = object.response_headers_to_add?.map((e) => HeaderValueOption.fromPartial(e)) ||
      undefined;
    message.response_headers_to_remove = object.response_headers_to_remove?.map((e) => e) || undefined;
    message.per_filter_config = (object.per_filter_config === undefined || object.per_filter_config === null)
      ? undefined
      : (() => {
        const m = new Map();
        (object.per_filter_config as Map<string, { [key: string]: any } | undefined> ?? new Map()).forEach(
          (value, key) => {
            if (value !== undefined) {
              m.set(key, value);
            }
          },
        );
        return m;
      })();
    message.typed_per_filter_config =
      (object.typed_per_filter_config === undefined || object.typed_per_filter_config === null) ? undefined : (() => {
        const m = new Map();
        (object.typed_per_filter_config as Map<string, Any> ?? new Map()).forEach((value, key) => {
          if (value !== undefined) {
            m.set(key, Any.fromPartial(value));
          }
        });
        return m;
      })();
    return message;
  },
};

messageTypeRegistry.set(WeightedCluster_ClusterWeight.$type, WeightedCluster_ClusterWeight);

function createBaseWeightedCluster_ClusterWeight_PerFilterConfigEntry(): WeightedCluster_ClusterWeight_PerFilterConfigEntry {
  return { $type: "envoy.api.v2.route.WeightedCluster.ClusterWeight.PerFilterConfigEntry", key: "" };
}

export const WeightedCluster_ClusterWeight_PerFilterConfigEntry: MessageFns<
  WeightedCluster_ClusterWeight_PerFilterConfigEntry,
  "envoy.api.v2.route.WeightedCluster.ClusterWeight.PerFilterConfigEntry"
> = {
  $type: "envoy.api.v2.route.WeightedCluster.ClusterWeight.PerFilterConfigEntry" as const,

  encode(
    message: WeightedCluster_ClusterWeight_PerFilterConfigEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Struct.encode(Struct.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WeightedCluster_ClusterWeight_PerFilterConfigEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWeightedCluster_ClusterWeight_PerFilterConfigEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WeightedCluster_ClusterWeight_PerFilterConfigEntry {
    return {
      $type: WeightedCluster_ClusterWeight_PerFilterConfigEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isObject(object.value) ? object.value : undefined,
    };
  },

  toJSON(message: WeightedCluster_ClusterWeight_PerFilterConfigEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WeightedCluster_ClusterWeight_PerFilterConfigEntry>, I>>(
    base?: I,
  ): WeightedCluster_ClusterWeight_PerFilterConfigEntry {
    return WeightedCluster_ClusterWeight_PerFilterConfigEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WeightedCluster_ClusterWeight_PerFilterConfigEntry>, I>>(
    object: I,
  ): WeightedCluster_ClusterWeight_PerFilterConfigEntry {
    const message = createBaseWeightedCluster_ClusterWeight_PerFilterConfigEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(
  WeightedCluster_ClusterWeight_PerFilterConfigEntry.$type,
  WeightedCluster_ClusterWeight_PerFilterConfigEntry,
);

function createBaseWeightedCluster_ClusterWeight_TypedPerFilterConfigEntry(): WeightedCluster_ClusterWeight_TypedPerFilterConfigEntry {
  return { $type: "envoy.api.v2.route.WeightedCluster.ClusterWeight.TypedPerFilterConfigEntry", key: "" };
}

export const WeightedCluster_ClusterWeight_TypedPerFilterConfigEntry: MessageFns<
  WeightedCluster_ClusterWeight_TypedPerFilterConfigEntry,
  "envoy.api.v2.route.WeightedCluster.ClusterWeight.TypedPerFilterConfigEntry"
> = {
  $type: "envoy.api.v2.route.WeightedCluster.ClusterWeight.TypedPerFilterConfigEntry" as const,

  encode(
    message: WeightedCluster_ClusterWeight_TypedPerFilterConfigEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Any.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WeightedCluster_ClusterWeight_TypedPerFilterConfigEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWeightedCluster_ClusterWeight_TypedPerFilterConfigEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WeightedCluster_ClusterWeight_TypedPerFilterConfigEntry {
    return {
      $type: WeightedCluster_ClusterWeight_TypedPerFilterConfigEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Any.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: WeightedCluster_ClusterWeight_TypedPerFilterConfigEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Any.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WeightedCluster_ClusterWeight_TypedPerFilterConfigEntry>, I>>(
    base?: I,
  ): WeightedCluster_ClusterWeight_TypedPerFilterConfigEntry {
    return WeightedCluster_ClusterWeight_TypedPerFilterConfigEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WeightedCluster_ClusterWeight_TypedPerFilterConfigEntry>, I>>(
    object: I,
  ): WeightedCluster_ClusterWeight_TypedPerFilterConfigEntry {
    const message = createBaseWeightedCluster_ClusterWeight_TypedPerFilterConfigEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Any.fromPartial(object.value) : undefined;
    return message;
  },
};

messageTypeRegistry.set(
  WeightedCluster_ClusterWeight_TypedPerFilterConfigEntry.$type,
  WeightedCluster_ClusterWeight_TypedPerFilterConfigEntry,
);

function createBaseRouteMatch(): RouteMatch {
  return { $type: "envoy.api.v2.route.RouteMatch", path_specifier: undefined };
}

export const RouteMatch: MessageFns<RouteMatch, "envoy.api.v2.route.RouteMatch"> = {
  $type: "envoy.api.v2.route.RouteMatch" as const,

  encode(message: RouteMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.path_specifier?.$case) {
      case "prefix":
        writer.uint32(10).string(message.path_specifier.prefix);
        break;
      case "path":
        writer.uint32(18).string(message.path_specifier.path);
        break;
      case "regex":
        writer.uint32(26).string(message.path_specifier.regex);
        break;
      case "safe_regex":
        RegexMatcher.encode(message.path_specifier.safe_regex, writer.uint32(82).fork()).join();
        break;
    }
    if (message.case_sensitive !== undefined) {
      BoolValue.encode({ $type: "google.protobuf.BoolValue", value: message.case_sensitive! }, writer.uint32(34).fork())
        .join();
    }
    if (message.runtime_fraction !== undefined) {
      RuntimeFractionalPercent.encode(message.runtime_fraction, writer.uint32(74).fork()).join();
    }
    if (message.headers !== undefined && message.headers.length !== 0) {
      for (const v of message.headers) {
        HeaderMatcher.encode(v!, writer.uint32(50).fork()).join();
      }
    }
    if (message.query_parameters !== undefined && message.query_parameters.length !== 0) {
      for (const v of message.query_parameters) {
        QueryParameterMatcher.encode(v!, writer.uint32(58).fork()).join();
      }
    }
    if (message.grpc !== undefined) {
      RouteMatch_GrpcRouteMatchOptions.encode(message.grpc, writer.uint32(66).fork()).join();
    }
    if (message.tls_context !== undefined) {
      RouteMatch_TlsContextMatchOptions.encode(message.tls_context, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path_specifier = { $case: "prefix", prefix: reader.string() };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.path_specifier = { $case: "path", path: reader.string() };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.path_specifier = { $case: "regex", regex: reader.string() };
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.path_specifier = { $case: "safe_regex", safe_regex: RegexMatcher.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.case_sensitive = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.runtime_fraction = RuntimeFractionalPercent.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          if (message.headers === undefined) {
            message.headers = [];
          }
          const el = HeaderMatcher.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.headers!.push(el);
          }
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          if (message.query_parameters === undefined) {
            message.query_parameters = [];
          }
          const el = QueryParameterMatcher.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.query_parameters!.push(el);
          }
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.grpc = RouteMatch_GrpcRouteMatchOptions.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.tls_context = RouteMatch_TlsContextMatchOptions.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteMatch {
    return {
      $type: RouteMatch.$type,
      path_specifier: isSet(object.prefix)
        ? { $case: "prefix", prefix: globalThis.String(object.prefix) }
        : isSet(object.path)
        ? { $case: "path", path: globalThis.String(object.path) }
        : isSet(object.regex)
        ? { $case: "regex", regex: globalThis.String(object.regex) }
        : isSet(object.safe_regex)
        ? { $case: "safe_regex", safe_regex: RegexMatcher.fromJSON(object.safe_regex) }
        : undefined,
      case_sensitive: isSet(object.case_sensitive) ? Boolean(object.case_sensitive) : undefined,
      runtime_fraction: isSet(object.runtime_fraction)
        ? RuntimeFractionalPercent.fromJSON(object.runtime_fraction)
        : undefined,
      headers: globalThis.Array.isArray(object?.headers)
        ? object.headers.map((e: any) => HeaderMatcher.fromJSON(e))
        : undefined,
      query_parameters: globalThis.Array.isArray(object?.query_parameters)
        ? object.query_parameters.map((e: any) => QueryParameterMatcher.fromJSON(e))
        : undefined,
      grpc: isSet(object.grpc) ? RouteMatch_GrpcRouteMatchOptions.fromJSON(object.grpc) : undefined,
      tls_context: isSet(object.tls_context)
        ? RouteMatch_TlsContextMatchOptions.fromJSON(object.tls_context)
        : undefined,
    };
  },

  toJSON(message: RouteMatch): unknown {
    const obj: any = {};
    if (message.path_specifier?.$case === "prefix") {
      obj.prefix = message.path_specifier.prefix;
    }
    if (message.path_specifier?.$case === "path") {
      obj.path = message.path_specifier.path;
    }
    if (message.path_specifier?.$case === "regex") {
      obj.regex = message.path_specifier.regex;
    }
    if (message.path_specifier?.$case === "safe_regex") {
      obj.safe_regex = RegexMatcher.toJSON(message.path_specifier.safe_regex);
    }
    if (message.case_sensitive !== undefined) {
      obj.case_sensitive = message.case_sensitive;
    }
    if (message.runtime_fraction !== undefined) {
      obj.runtime_fraction = RuntimeFractionalPercent.toJSON(message.runtime_fraction);
    }
    if (message.headers?.length) {
      obj.headers = message.headers.map((e) => HeaderMatcher.toJSON(e));
    }
    if (message.query_parameters?.length) {
      obj.query_parameters = message.query_parameters.map((e) => QueryParameterMatcher.toJSON(e));
    }
    if (message.grpc !== undefined) {
      obj.grpc = RouteMatch_GrpcRouteMatchOptions.toJSON(message.grpc);
    }
    if (message.tls_context !== undefined) {
      obj.tls_context = RouteMatch_TlsContextMatchOptions.toJSON(message.tls_context);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RouteMatch>, I>>(base?: I): RouteMatch {
    return RouteMatch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RouteMatch>, I>>(object: I): RouteMatch {
    const message = createBaseRouteMatch();
    if (
      object.path_specifier?.$case === "prefix" &&
      object.path_specifier?.prefix !== undefined &&
      object.path_specifier?.prefix !== null
    ) {
      message.path_specifier = { $case: "prefix", prefix: object.path_specifier.prefix };
    }
    if (
      object.path_specifier?.$case === "path" &&
      object.path_specifier?.path !== undefined &&
      object.path_specifier?.path !== null
    ) {
      message.path_specifier = { $case: "path", path: object.path_specifier.path };
    }
    if (
      object.path_specifier?.$case === "regex" &&
      object.path_specifier?.regex !== undefined &&
      object.path_specifier?.regex !== null
    ) {
      message.path_specifier = { $case: "regex", regex: object.path_specifier.regex };
    }
    if (
      object.path_specifier?.$case === "safe_regex" &&
      object.path_specifier?.safe_regex !== undefined &&
      object.path_specifier?.safe_regex !== null
    ) {
      message.path_specifier = {
        $case: "safe_regex",
        safe_regex: RegexMatcher.fromPartial(object.path_specifier.safe_regex),
      };
    }
    message.case_sensitive = object.case_sensitive ?? undefined;
    message.runtime_fraction = (object.runtime_fraction !== undefined && object.runtime_fraction !== null)
      ? RuntimeFractionalPercent.fromPartial(object.runtime_fraction)
      : undefined;
    message.headers = object.headers?.map((e) => HeaderMatcher.fromPartial(e)) || undefined;
    message.query_parameters = object.query_parameters?.map((e) => QueryParameterMatcher.fromPartial(e)) || undefined;
    message.grpc = (object.grpc !== undefined && object.grpc !== null)
      ? RouteMatch_GrpcRouteMatchOptions.fromPartial(object.grpc)
      : undefined;
    message.tls_context = (object.tls_context !== undefined && object.tls_context !== null)
      ? RouteMatch_TlsContextMatchOptions.fromPartial(object.tls_context)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(RouteMatch.$type, RouteMatch);

function createBaseRouteMatch_GrpcRouteMatchOptions(): RouteMatch_GrpcRouteMatchOptions {
  return { $type: "envoy.api.v2.route.RouteMatch.GrpcRouteMatchOptions" };
}

export const RouteMatch_GrpcRouteMatchOptions: MessageFns<
  RouteMatch_GrpcRouteMatchOptions,
  "envoy.api.v2.route.RouteMatch.GrpcRouteMatchOptions"
> = {
  $type: "envoy.api.v2.route.RouteMatch.GrpcRouteMatchOptions" as const,

  encode(_: RouteMatch_GrpcRouteMatchOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteMatch_GrpcRouteMatchOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteMatch_GrpcRouteMatchOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RouteMatch_GrpcRouteMatchOptions {
    return { $type: RouteMatch_GrpcRouteMatchOptions.$type };
  },

  toJSON(_: RouteMatch_GrpcRouteMatchOptions): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RouteMatch_GrpcRouteMatchOptions>, I>>(
    base?: I,
  ): RouteMatch_GrpcRouteMatchOptions {
    return RouteMatch_GrpcRouteMatchOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RouteMatch_GrpcRouteMatchOptions>, I>>(
    _: I,
  ): RouteMatch_GrpcRouteMatchOptions {
    const message = createBaseRouteMatch_GrpcRouteMatchOptions();
    return message;
  },
};

messageTypeRegistry.set(RouteMatch_GrpcRouteMatchOptions.$type, RouteMatch_GrpcRouteMatchOptions);

function createBaseRouteMatch_TlsContextMatchOptions(): RouteMatch_TlsContextMatchOptions {
  return { $type: "envoy.api.v2.route.RouteMatch.TlsContextMatchOptions" };
}

export const RouteMatch_TlsContextMatchOptions: MessageFns<
  RouteMatch_TlsContextMatchOptions,
  "envoy.api.v2.route.RouteMatch.TlsContextMatchOptions"
> = {
  $type: "envoy.api.v2.route.RouteMatch.TlsContextMatchOptions" as const,

  encode(message: RouteMatch_TlsContextMatchOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.presented !== undefined) {
      BoolValue.encode({ $type: "google.protobuf.BoolValue", value: message.presented! }, writer.uint32(10).fork())
        .join();
    }
    if (message.validated !== undefined) {
      BoolValue.encode({ $type: "google.protobuf.BoolValue", value: message.validated! }, writer.uint32(18).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteMatch_TlsContextMatchOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteMatch_TlsContextMatchOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.presented = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.validated = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteMatch_TlsContextMatchOptions {
    return {
      $type: RouteMatch_TlsContextMatchOptions.$type,
      presented: isSet(object.presented) ? Boolean(object.presented) : undefined,
      validated: isSet(object.validated) ? Boolean(object.validated) : undefined,
    };
  },

  toJSON(message: RouteMatch_TlsContextMatchOptions): unknown {
    const obj: any = {};
    if (message.presented !== undefined) {
      obj.presented = message.presented;
    }
    if (message.validated !== undefined) {
      obj.validated = message.validated;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RouteMatch_TlsContextMatchOptions>, I>>(
    base?: I,
  ): RouteMatch_TlsContextMatchOptions {
    return RouteMatch_TlsContextMatchOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RouteMatch_TlsContextMatchOptions>, I>>(
    object: I,
  ): RouteMatch_TlsContextMatchOptions {
    const message = createBaseRouteMatch_TlsContextMatchOptions();
    message.presented = object.presented ?? undefined;
    message.validated = object.validated ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RouteMatch_TlsContextMatchOptions.$type, RouteMatch_TlsContextMatchOptions);

function createBaseCorsPolicy(): CorsPolicy {
  return { $type: "envoy.api.v2.route.CorsPolicy", enabled_specifier: undefined };
}

export const CorsPolicy: MessageFns<CorsPolicy, "envoy.api.v2.route.CorsPolicy"> = {
  $type: "envoy.api.v2.route.CorsPolicy" as const,

  encode(message: CorsPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.allow_origin !== undefined && message.allow_origin.length !== 0) {
      for (const v of message.allow_origin) {
        writer.uint32(10).string(v!);
      }
    }
    if (message.allow_origin_regex !== undefined && message.allow_origin_regex.length !== 0) {
      for (const v of message.allow_origin_regex) {
        writer.uint32(66).string(v!);
      }
    }
    if (message.allow_origin_string_match !== undefined && message.allow_origin_string_match.length !== 0) {
      for (const v of message.allow_origin_string_match) {
        StringMatcher.encode(v!, writer.uint32(90).fork()).join();
      }
    }
    if (message.allow_methods !== undefined && message.allow_methods !== "") {
      writer.uint32(18).string(message.allow_methods);
    }
    if (message.allow_headers !== undefined && message.allow_headers !== "") {
      writer.uint32(26).string(message.allow_headers);
    }
    if (message.expose_headers !== undefined && message.expose_headers !== "") {
      writer.uint32(34).string(message.expose_headers);
    }
    if (message.max_age !== undefined && message.max_age !== "") {
      writer.uint32(42).string(message.max_age);
    }
    if (message.allow_credentials !== undefined) {
      BoolValue.encode(
        { $type: "google.protobuf.BoolValue", value: message.allow_credentials! },
        writer.uint32(50).fork(),
      ).join();
    }
    switch (message.enabled_specifier?.$case) {
      case "enabled":
        BoolValue.encode(
          { $type: "google.protobuf.BoolValue", value: message.enabled_specifier.enabled! },
          writer.uint32(58).fork(),
        ).join();
        break;
      case "filter_enabled":
        RuntimeFractionalPercent.encode(message.enabled_specifier.filter_enabled, writer.uint32(74).fork()).join();
        break;
    }
    if (message.shadow_enabled !== undefined) {
      RuntimeFractionalPercent.encode(message.shadow_enabled, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CorsPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCorsPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.allow_origin === undefined) {
            message.allow_origin = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.allow_origin!.push(el);
          }
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          if (message.allow_origin_regex === undefined) {
            message.allow_origin_regex = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.allow_origin_regex!.push(el);
          }
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          if (message.allow_origin_string_match === undefined) {
            message.allow_origin_string_match = [];
          }
          const el = StringMatcher.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.allow_origin_string_match!.push(el);
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.allow_methods = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.allow_headers = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.expose_headers = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.max_age = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.allow_credentials = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.enabled_specifier = { $case: "enabled", enabled: BoolValue.decode(reader, reader.uint32()).value };
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.enabled_specifier = {
            $case: "filter_enabled",
            filter_enabled: RuntimeFractionalPercent.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.shadow_enabled = RuntimeFractionalPercent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CorsPolicy {
    return {
      $type: CorsPolicy.$type,
      allow_origin: globalThis.Array.isArray(object?.allow_origin)
        ? object.allow_origin.map((e: any) => globalThis.String(e))
        : undefined,
      allow_origin_regex: globalThis.Array.isArray(object?.allow_origin_regex)
        ? object.allow_origin_regex.map((e: any) => globalThis.String(e))
        : undefined,
      allow_origin_string_match: globalThis.Array.isArray(object?.allow_origin_string_match)
        ? object.allow_origin_string_match.map((e: any) => StringMatcher.fromJSON(e))
        : undefined,
      allow_methods: isSet(object.allow_methods) ? globalThis.String(object.allow_methods) : undefined,
      allow_headers: isSet(object.allow_headers) ? globalThis.String(object.allow_headers) : undefined,
      expose_headers: isSet(object.expose_headers) ? globalThis.String(object.expose_headers) : undefined,
      max_age: isSet(object.max_age) ? globalThis.String(object.max_age) : undefined,
      allow_credentials: isSet(object.allow_credentials) ? Boolean(object.allow_credentials) : undefined,
      enabled_specifier: isSet(object.enabled)
        ? { $case: "enabled", enabled: Boolean(object.enabled) }
        : isSet(object.filter_enabled)
        ? { $case: "filter_enabled", filter_enabled: RuntimeFractionalPercent.fromJSON(object.filter_enabled) }
        : undefined,
      shadow_enabled: isSet(object.shadow_enabled)
        ? RuntimeFractionalPercent.fromJSON(object.shadow_enabled)
        : undefined,
    };
  },

  toJSON(message: CorsPolicy): unknown {
    const obj: any = {};
    if (message.allow_origin?.length) {
      obj.allow_origin = message.allow_origin;
    }
    if (message.allow_origin_regex?.length) {
      obj.allow_origin_regex = message.allow_origin_regex;
    }
    if (message.allow_origin_string_match?.length) {
      obj.allow_origin_string_match = message.allow_origin_string_match.map((e) => StringMatcher.toJSON(e));
    }
    if (message.allow_methods !== undefined) {
      obj.allow_methods = message.allow_methods;
    }
    if (message.allow_headers !== undefined) {
      obj.allow_headers = message.allow_headers;
    }
    if (message.expose_headers !== undefined) {
      obj.expose_headers = message.expose_headers;
    }
    if (message.max_age !== undefined) {
      obj.max_age = message.max_age;
    }
    if (message.allow_credentials !== undefined) {
      obj.allow_credentials = message.allow_credentials;
    }
    if (message.enabled_specifier?.$case === "enabled") {
      obj.enabled = message.enabled_specifier.enabled;
    }
    if (message.enabled_specifier?.$case === "filter_enabled") {
      obj.filter_enabled = RuntimeFractionalPercent.toJSON(message.enabled_specifier.filter_enabled);
    }
    if (message.shadow_enabled !== undefined) {
      obj.shadow_enabled = RuntimeFractionalPercent.toJSON(message.shadow_enabled);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CorsPolicy>, I>>(base?: I): CorsPolicy {
    return CorsPolicy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CorsPolicy>, I>>(object: I): CorsPolicy {
    const message = createBaseCorsPolicy();
    message.allow_origin = object.allow_origin?.map((e) => e) || undefined;
    message.allow_origin_regex = object.allow_origin_regex?.map((e) => e) || undefined;
    message.allow_origin_string_match = object.allow_origin_string_match?.map((e) => StringMatcher.fromPartial(e)) ||
      undefined;
    message.allow_methods = object.allow_methods ?? undefined;
    message.allow_headers = object.allow_headers ?? undefined;
    message.expose_headers = object.expose_headers ?? undefined;
    message.max_age = object.max_age ?? undefined;
    message.allow_credentials = object.allow_credentials ?? undefined;
    if (
      object.enabled_specifier?.$case === "enabled" &&
      object.enabled_specifier?.enabled !== undefined &&
      object.enabled_specifier?.enabled !== null
    ) {
      message.enabled_specifier = { $case: "enabled", enabled: object.enabled_specifier.enabled };
    }
    if (
      object.enabled_specifier?.$case === "filter_enabled" &&
      object.enabled_specifier?.filter_enabled !== undefined &&
      object.enabled_specifier?.filter_enabled !== null
    ) {
      message.enabled_specifier = {
        $case: "filter_enabled",
        filter_enabled: RuntimeFractionalPercent.fromPartial(object.enabled_specifier.filter_enabled),
      };
    }
    message.shadow_enabled = (object.shadow_enabled !== undefined && object.shadow_enabled !== null)
      ? RuntimeFractionalPercent.fromPartial(object.shadow_enabled)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(CorsPolicy.$type, CorsPolicy);

function createBaseRouteAction(): RouteAction {
  return { $type: "envoy.api.v2.route.RouteAction", cluster_specifier: undefined, host_rewrite_specifier: undefined };
}

export const RouteAction: MessageFns<RouteAction, "envoy.api.v2.route.RouteAction"> = {
  $type: "envoy.api.v2.route.RouteAction" as const,

  encode(message: RouteAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.cluster_specifier?.$case) {
      case "cluster":
        writer.uint32(10).string(message.cluster_specifier.cluster);
        break;
      case "cluster_header":
        writer.uint32(18).string(message.cluster_specifier.cluster_header);
        break;
      case "weighted_clusters":
        WeightedCluster.encode(message.cluster_specifier.weighted_clusters, writer.uint32(26).fork()).join();
        break;
    }
    if (
      message.cluster_not_found_response_code !== undefined &&
      message.cluster_not_found_response_code !== RouteAction_ClusterNotFoundResponseCode.SERVICE_UNAVAILABLE
    ) {
      writer.uint32(160).int32(
        routeAction_ClusterNotFoundResponseCodeToNumber(message.cluster_not_found_response_code),
      );
    }
    if (message.metadata_match !== undefined) {
      Metadata.encode(message.metadata_match, writer.uint32(34).fork()).join();
    }
    if (message.prefix_rewrite !== undefined && message.prefix_rewrite !== "") {
      writer.uint32(42).string(message.prefix_rewrite);
    }
    if (message.regex_rewrite !== undefined) {
      RegexMatchAndSubstitute.encode(message.regex_rewrite, writer.uint32(258).fork()).join();
    }
    switch (message.host_rewrite_specifier?.$case) {
      case "host_rewrite":
        writer.uint32(50).string(message.host_rewrite_specifier.host_rewrite);
        break;
      case "auto_host_rewrite":
        BoolValue.encode({
          $type: "google.protobuf.BoolValue",
          value: message.host_rewrite_specifier.auto_host_rewrite!,
        }, writer.uint32(58).fork()).join();
        break;
      case "auto_host_rewrite_header":
        writer.uint32(234).string(message.host_rewrite_specifier.auto_host_rewrite_header);
        break;
    }
    if (message.timeout !== undefined) {
      Duration.encode(message.timeout, writer.uint32(66).fork()).join();
    }
    if (message.idle_timeout !== undefined) {
      Duration.encode(message.idle_timeout, writer.uint32(194).fork()).join();
    }
    if (message.retry_policy !== undefined) {
      RetryPolicy.encode(message.retry_policy, writer.uint32(74).fork()).join();
    }
    if (message.retry_policy_typed_config !== undefined) {
      Any.encode(message.retry_policy_typed_config, writer.uint32(266).fork()).join();
    }
    if (message.request_mirror_policy !== undefined) {
      RouteAction_RequestMirrorPolicy.encode(message.request_mirror_policy, writer.uint32(82).fork()).join();
    }
    if (message.request_mirror_policies !== undefined && message.request_mirror_policies.length !== 0) {
      for (const v of message.request_mirror_policies) {
        RouteAction_RequestMirrorPolicy.encode(v!, writer.uint32(242).fork()).join();
      }
    }
    if (message.priority !== undefined && message.priority !== RoutingPriority.DEFAULT) {
      writer.uint32(88).int32(routingPriorityToNumber(message.priority));
    }
    if (message.rate_limits !== undefined && message.rate_limits.length !== 0) {
      for (const v of message.rate_limits) {
        RateLimit.encode(v!, writer.uint32(106).fork()).join();
      }
    }
    if (message.include_vh_rate_limits !== undefined) {
      BoolValue.encode(
        { $type: "google.protobuf.BoolValue", value: message.include_vh_rate_limits! },
        writer.uint32(114).fork(),
      ).join();
    }
    if (message.hash_policy !== undefined && message.hash_policy.length !== 0) {
      for (const v of message.hash_policy) {
        RouteAction_HashPolicy.encode(v!, writer.uint32(122).fork()).join();
      }
    }
    if (message.cors !== undefined) {
      CorsPolicy.encode(message.cors, writer.uint32(138).fork()).join();
    }
    if (message.max_grpc_timeout !== undefined) {
      Duration.encode(message.max_grpc_timeout, writer.uint32(186).fork()).join();
    }
    if (message.grpc_timeout_offset !== undefined) {
      Duration.encode(message.grpc_timeout_offset, writer.uint32(226).fork()).join();
    }
    if (message.upgrade_configs !== undefined && message.upgrade_configs.length !== 0) {
      for (const v of message.upgrade_configs) {
        RouteAction_UpgradeConfig.encode(v!, writer.uint32(202).fork()).join();
      }
    }
    if (
      message.internal_redirect_action !== undefined &&
      message.internal_redirect_action !== RouteAction_InternalRedirectAction.PASS_THROUGH_INTERNAL_REDIRECT
    ) {
      writer.uint32(208).int32(routeAction_InternalRedirectActionToNumber(message.internal_redirect_action));
    }
    if (message.max_internal_redirects !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.max_internal_redirects! },
        writer.uint32(250).fork(),
      ).join();
    }
    if (message.hedge_policy !== undefined) {
      HedgePolicy.encode(message.hedge_policy, writer.uint32(218).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cluster_specifier = { $case: "cluster", cluster: reader.string() };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cluster_specifier = { $case: "cluster_header", cluster_header: reader.string() };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.cluster_specifier = {
            $case: "weighted_clusters",
            weighted_clusters: WeightedCluster.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.cluster_not_found_response_code = routeAction_ClusterNotFoundResponseCodeFromJSON(reader.int32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata_match = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.prefix_rewrite = reader.string();
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.regex_rewrite = RegexMatchAndSubstitute.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.host_rewrite_specifier = { $case: "host_rewrite", host_rewrite: reader.string() };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.host_rewrite_specifier = {
            $case: "auto_host_rewrite",
            auto_host_rewrite: BoolValue.decode(reader, reader.uint32()).value,
          };
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.host_rewrite_specifier = {
            $case: "auto_host_rewrite_header",
            auto_host_rewrite_header: reader.string(),
          };
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.idle_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.retry_policy = RetryPolicy.decode(reader, reader.uint32());
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }

          message.retry_policy_typed_config = Any.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.request_mirror_policy = RouteAction_RequestMirrorPolicy.decode(reader, reader.uint32());
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          if (message.request_mirror_policies === undefined) {
            message.request_mirror_policies = [];
          }
          const el = RouteAction_RequestMirrorPolicy.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.request_mirror_policies!.push(el);
          }
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.priority = routingPriorityFromJSON(reader.int32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          if (message.rate_limits === undefined) {
            message.rate_limits = [];
          }
          const el = RateLimit.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.rate_limits!.push(el);
          }
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.include_vh_rate_limits = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          if (message.hash_policy === undefined) {
            message.hash_policy = [];
          }
          const el = RouteAction_HashPolicy.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.hash_policy!.push(el);
          }
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.cors = CorsPolicy.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.max_grpc_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.grpc_timeout_offset = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          if (message.upgrade_configs === undefined) {
            message.upgrade_configs = [];
          }
          const el = RouteAction_UpgradeConfig.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.upgrade_configs!.push(el);
          }
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.internal_redirect_action = routeAction_InternalRedirectActionFromJSON(reader.int32());
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.max_internal_redirects = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.hedge_policy = HedgePolicy.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteAction {
    return {
      $type: RouteAction.$type,
      cluster_specifier: isSet(object.cluster)
        ? { $case: "cluster", cluster: globalThis.String(object.cluster) }
        : isSet(object.cluster_header)
        ? { $case: "cluster_header", cluster_header: globalThis.String(object.cluster_header) }
        : isSet(object.weighted_clusters)
        ? { $case: "weighted_clusters", weighted_clusters: WeightedCluster.fromJSON(object.weighted_clusters) }
        : undefined,
      cluster_not_found_response_code: isSet(object.cluster_not_found_response_code)
        ? routeAction_ClusterNotFoundResponseCodeFromJSON(object.cluster_not_found_response_code)
        : undefined,
      metadata_match: isSet(object.metadata_match) ? Metadata.fromJSON(object.metadata_match) : undefined,
      prefix_rewrite: isSet(object.prefix_rewrite) ? globalThis.String(object.prefix_rewrite) : undefined,
      regex_rewrite: isSet(object.regex_rewrite) ? RegexMatchAndSubstitute.fromJSON(object.regex_rewrite) : undefined,
      host_rewrite_specifier: isSet(object.host_rewrite)
        ? { $case: "host_rewrite", host_rewrite: globalThis.String(object.host_rewrite) }
        : isSet(object.auto_host_rewrite)
        ? { $case: "auto_host_rewrite", auto_host_rewrite: Boolean(object.auto_host_rewrite) }
        : isSet(object.auto_host_rewrite_header)
        ? {
          $case: "auto_host_rewrite_header",
          auto_host_rewrite_header: globalThis.String(object.auto_host_rewrite_header),
        }
        : undefined,
      timeout: isSet(object.timeout) ? Duration.fromJSON(object.timeout) : undefined,
      idle_timeout: isSet(object.idle_timeout) ? Duration.fromJSON(object.idle_timeout) : undefined,
      retry_policy: isSet(object.retry_policy) ? RetryPolicy.fromJSON(object.retry_policy) : undefined,
      retry_policy_typed_config: isSet(object.retry_policy_typed_config)
        ? Any.fromJSON(object.retry_policy_typed_config)
        : undefined,
      request_mirror_policy: isSet(object.request_mirror_policy)
        ? RouteAction_RequestMirrorPolicy.fromJSON(object.request_mirror_policy)
        : undefined,
      request_mirror_policies: globalThis.Array.isArray(object?.request_mirror_policies)
        ? object.request_mirror_policies.map((e: any) => RouteAction_RequestMirrorPolicy.fromJSON(e))
        : undefined,
      priority: isSet(object.priority) ? routingPriorityFromJSON(object.priority) : undefined,
      rate_limits: globalThis.Array.isArray(object?.rate_limits)
        ? object.rate_limits.map((e: any) => RateLimit.fromJSON(e))
        : undefined,
      include_vh_rate_limits: isSet(object.include_vh_rate_limits) ? Boolean(object.include_vh_rate_limits) : undefined,
      hash_policy: globalThis.Array.isArray(object?.hash_policy)
        ? object.hash_policy.map((e: any) => RouteAction_HashPolicy.fromJSON(e))
        : undefined,
      cors: isSet(object.cors) ? CorsPolicy.fromJSON(object.cors) : undefined,
      max_grpc_timeout: isSet(object.max_grpc_timeout) ? Duration.fromJSON(object.max_grpc_timeout) : undefined,
      grpc_timeout_offset: isSet(object.grpc_timeout_offset)
        ? Duration.fromJSON(object.grpc_timeout_offset)
        : undefined,
      upgrade_configs: globalThis.Array.isArray(object?.upgrade_configs)
        ? object.upgrade_configs.map((e: any) => RouteAction_UpgradeConfig.fromJSON(e))
        : undefined,
      internal_redirect_action: isSet(object.internal_redirect_action)
        ? routeAction_InternalRedirectActionFromJSON(object.internal_redirect_action)
        : undefined,
      max_internal_redirects: isSet(object.max_internal_redirects) ? Number(object.max_internal_redirects) : undefined,
      hedge_policy: isSet(object.hedge_policy) ? HedgePolicy.fromJSON(object.hedge_policy) : undefined,
    };
  },

  toJSON(message: RouteAction): unknown {
    const obj: any = {};
    if (message.cluster_specifier?.$case === "cluster") {
      obj.cluster = message.cluster_specifier.cluster;
    }
    if (message.cluster_specifier?.$case === "cluster_header") {
      obj.cluster_header = message.cluster_specifier.cluster_header;
    }
    if (message.cluster_specifier?.$case === "weighted_clusters") {
      obj.weighted_clusters = WeightedCluster.toJSON(message.cluster_specifier.weighted_clusters);
    }
    if (message.cluster_not_found_response_code !== undefined) {
      obj.cluster_not_found_response_code = routeAction_ClusterNotFoundResponseCodeToJSON(
        message.cluster_not_found_response_code,
      );
    }
    if (message.metadata_match !== undefined) {
      obj.metadata_match = Metadata.toJSON(message.metadata_match);
    }
    if (message.prefix_rewrite !== undefined) {
      obj.prefix_rewrite = message.prefix_rewrite;
    }
    if (message.regex_rewrite !== undefined) {
      obj.regex_rewrite = RegexMatchAndSubstitute.toJSON(message.regex_rewrite);
    }
    if (message.host_rewrite_specifier?.$case === "host_rewrite") {
      obj.host_rewrite = message.host_rewrite_specifier.host_rewrite;
    }
    if (message.host_rewrite_specifier?.$case === "auto_host_rewrite") {
      obj.auto_host_rewrite = message.host_rewrite_specifier.auto_host_rewrite;
    }
    if (message.host_rewrite_specifier?.$case === "auto_host_rewrite_header") {
      obj.auto_host_rewrite_header = message.host_rewrite_specifier.auto_host_rewrite_header;
    }
    if (message.timeout !== undefined) {
      obj.timeout = Duration.toJSON(message.timeout);
    }
    if (message.idle_timeout !== undefined) {
      obj.idle_timeout = Duration.toJSON(message.idle_timeout);
    }
    if (message.retry_policy !== undefined) {
      obj.retry_policy = RetryPolicy.toJSON(message.retry_policy);
    }
    if (message.retry_policy_typed_config !== undefined) {
      obj.retry_policy_typed_config = Any.toJSON(message.retry_policy_typed_config);
    }
    if (message.request_mirror_policy !== undefined) {
      obj.request_mirror_policy = RouteAction_RequestMirrorPolicy.toJSON(message.request_mirror_policy);
    }
    if (message.request_mirror_policies?.length) {
      obj.request_mirror_policies = message.request_mirror_policies.map((e) =>
        RouteAction_RequestMirrorPolicy.toJSON(e)
      );
    }
    if (message.priority !== undefined) {
      obj.priority = routingPriorityToJSON(message.priority);
    }
    if (message.rate_limits?.length) {
      obj.rate_limits = message.rate_limits.map((e) => RateLimit.toJSON(e));
    }
    if (message.include_vh_rate_limits !== undefined) {
      obj.include_vh_rate_limits = message.include_vh_rate_limits;
    }
    if (message.hash_policy?.length) {
      obj.hash_policy = message.hash_policy.map((e) => RouteAction_HashPolicy.toJSON(e));
    }
    if (message.cors !== undefined) {
      obj.cors = CorsPolicy.toJSON(message.cors);
    }
    if (message.max_grpc_timeout !== undefined) {
      obj.max_grpc_timeout = Duration.toJSON(message.max_grpc_timeout);
    }
    if (message.grpc_timeout_offset !== undefined) {
      obj.grpc_timeout_offset = Duration.toJSON(message.grpc_timeout_offset);
    }
    if (message.upgrade_configs?.length) {
      obj.upgrade_configs = message.upgrade_configs.map((e) => RouteAction_UpgradeConfig.toJSON(e));
    }
    if (message.internal_redirect_action !== undefined) {
      obj.internal_redirect_action = routeAction_InternalRedirectActionToJSON(message.internal_redirect_action);
    }
    if (message.max_internal_redirects !== undefined) {
      obj.max_internal_redirects = message.max_internal_redirects;
    }
    if (message.hedge_policy !== undefined) {
      obj.hedge_policy = HedgePolicy.toJSON(message.hedge_policy);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RouteAction>, I>>(base?: I): RouteAction {
    return RouteAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RouteAction>, I>>(object: I): RouteAction {
    const message = createBaseRouteAction();
    if (
      object.cluster_specifier?.$case === "cluster" &&
      object.cluster_specifier?.cluster !== undefined &&
      object.cluster_specifier?.cluster !== null
    ) {
      message.cluster_specifier = { $case: "cluster", cluster: object.cluster_specifier.cluster };
    }
    if (
      object.cluster_specifier?.$case === "cluster_header" &&
      object.cluster_specifier?.cluster_header !== undefined &&
      object.cluster_specifier?.cluster_header !== null
    ) {
      message.cluster_specifier = { $case: "cluster_header", cluster_header: object.cluster_specifier.cluster_header };
    }
    if (
      object.cluster_specifier?.$case === "weighted_clusters" &&
      object.cluster_specifier?.weighted_clusters !== undefined &&
      object.cluster_specifier?.weighted_clusters !== null
    ) {
      message.cluster_specifier = {
        $case: "weighted_clusters",
        weighted_clusters: WeightedCluster.fromPartial(object.cluster_specifier.weighted_clusters),
      };
    }
    message.cluster_not_found_response_code = object.cluster_not_found_response_code ?? undefined;
    message.metadata_match = (object.metadata_match !== undefined && object.metadata_match !== null)
      ? Metadata.fromPartial(object.metadata_match)
      : undefined;
    message.prefix_rewrite = object.prefix_rewrite ?? undefined;
    message.regex_rewrite = (object.regex_rewrite !== undefined && object.regex_rewrite !== null)
      ? RegexMatchAndSubstitute.fromPartial(object.regex_rewrite)
      : undefined;
    if (
      object.host_rewrite_specifier?.$case === "host_rewrite" &&
      object.host_rewrite_specifier?.host_rewrite !== undefined &&
      object.host_rewrite_specifier?.host_rewrite !== null
    ) {
      message.host_rewrite_specifier = {
        $case: "host_rewrite",
        host_rewrite: object.host_rewrite_specifier.host_rewrite,
      };
    }
    if (
      object.host_rewrite_specifier?.$case === "auto_host_rewrite" &&
      object.host_rewrite_specifier?.auto_host_rewrite !== undefined &&
      object.host_rewrite_specifier?.auto_host_rewrite !== null
    ) {
      message.host_rewrite_specifier = {
        $case: "auto_host_rewrite",
        auto_host_rewrite: object.host_rewrite_specifier.auto_host_rewrite,
      };
    }
    if (
      object.host_rewrite_specifier?.$case === "auto_host_rewrite_header" &&
      object.host_rewrite_specifier?.auto_host_rewrite_header !== undefined &&
      object.host_rewrite_specifier?.auto_host_rewrite_header !== null
    ) {
      message.host_rewrite_specifier = {
        $case: "auto_host_rewrite_header",
        auto_host_rewrite_header: object.host_rewrite_specifier.auto_host_rewrite_header,
      };
    }
    message.timeout = (object.timeout !== undefined && object.timeout !== null)
      ? Duration.fromPartial(object.timeout)
      : undefined;
    message.idle_timeout = (object.idle_timeout !== undefined && object.idle_timeout !== null)
      ? Duration.fromPartial(object.idle_timeout)
      : undefined;
    message.retry_policy = (object.retry_policy !== undefined && object.retry_policy !== null)
      ? RetryPolicy.fromPartial(object.retry_policy)
      : undefined;
    message.retry_policy_typed_config =
      (object.retry_policy_typed_config !== undefined && object.retry_policy_typed_config !== null)
        ? Any.fromPartial(object.retry_policy_typed_config)
        : undefined;
    message.request_mirror_policy =
      (object.request_mirror_policy !== undefined && object.request_mirror_policy !== null)
        ? RouteAction_RequestMirrorPolicy.fromPartial(object.request_mirror_policy)
        : undefined;
    message.request_mirror_policies =
      object.request_mirror_policies?.map((e) => RouteAction_RequestMirrorPolicy.fromPartial(e)) || undefined;
    message.priority = object.priority ?? undefined;
    message.rate_limits = object.rate_limits?.map((e) => RateLimit.fromPartial(e)) || undefined;
    message.include_vh_rate_limits = object.include_vh_rate_limits ?? undefined;
    message.hash_policy = object.hash_policy?.map((e) => RouteAction_HashPolicy.fromPartial(e)) || undefined;
    message.cors = (object.cors !== undefined && object.cors !== null)
      ? CorsPolicy.fromPartial(object.cors)
      : undefined;
    message.max_grpc_timeout = (object.max_grpc_timeout !== undefined && object.max_grpc_timeout !== null)
      ? Duration.fromPartial(object.max_grpc_timeout)
      : undefined;
    message.grpc_timeout_offset = (object.grpc_timeout_offset !== undefined && object.grpc_timeout_offset !== null)
      ? Duration.fromPartial(object.grpc_timeout_offset)
      : undefined;
    message.upgrade_configs = object.upgrade_configs?.map((e) => RouteAction_UpgradeConfig.fromPartial(e)) || undefined;
    message.internal_redirect_action = object.internal_redirect_action ?? undefined;
    message.max_internal_redirects = object.max_internal_redirects ?? undefined;
    message.hedge_policy = (object.hedge_policy !== undefined && object.hedge_policy !== null)
      ? HedgePolicy.fromPartial(object.hedge_policy)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(RouteAction.$type, RouteAction);

function createBaseRouteAction_RequestMirrorPolicy(): RouteAction_RequestMirrorPolicy {
  return { $type: "envoy.api.v2.route.RouteAction.RequestMirrorPolicy" };
}

export const RouteAction_RequestMirrorPolicy: MessageFns<
  RouteAction_RequestMirrorPolicy,
  "envoy.api.v2.route.RouteAction.RequestMirrorPolicy"
> = {
  $type: "envoy.api.v2.route.RouteAction.RequestMirrorPolicy" as const,

  encode(message: RouteAction_RequestMirrorPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cluster !== undefined && message.cluster !== "") {
      writer.uint32(10).string(message.cluster);
    }
    if (message.runtime_key !== undefined && message.runtime_key !== "") {
      writer.uint32(18).string(message.runtime_key);
    }
    if (message.runtime_fraction !== undefined) {
      RuntimeFractionalPercent.encode(message.runtime_fraction, writer.uint32(26).fork()).join();
    }
    if (message.trace_sampled !== undefined) {
      BoolValue.encode({ $type: "google.protobuf.BoolValue", value: message.trace_sampled! }, writer.uint32(34).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteAction_RequestMirrorPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteAction_RequestMirrorPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cluster = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.runtime_key = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.runtime_fraction = RuntimeFractionalPercent.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.trace_sampled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteAction_RequestMirrorPolicy {
    return {
      $type: RouteAction_RequestMirrorPolicy.$type,
      cluster: isSet(object.cluster) ? globalThis.String(object.cluster) : undefined,
      runtime_key: isSet(object.runtime_key) ? globalThis.String(object.runtime_key) : undefined,
      runtime_fraction: isSet(object.runtime_fraction)
        ? RuntimeFractionalPercent.fromJSON(object.runtime_fraction)
        : undefined,
      trace_sampled: isSet(object.trace_sampled) ? Boolean(object.trace_sampled) : undefined,
    };
  },

  toJSON(message: RouteAction_RequestMirrorPolicy): unknown {
    const obj: any = {};
    if (message.cluster !== undefined) {
      obj.cluster = message.cluster;
    }
    if (message.runtime_key !== undefined) {
      obj.runtime_key = message.runtime_key;
    }
    if (message.runtime_fraction !== undefined) {
      obj.runtime_fraction = RuntimeFractionalPercent.toJSON(message.runtime_fraction);
    }
    if (message.trace_sampled !== undefined) {
      obj.trace_sampled = message.trace_sampled;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RouteAction_RequestMirrorPolicy>, I>>(base?: I): RouteAction_RequestMirrorPolicy {
    return RouteAction_RequestMirrorPolicy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RouteAction_RequestMirrorPolicy>, I>>(
    object: I,
  ): RouteAction_RequestMirrorPolicy {
    const message = createBaseRouteAction_RequestMirrorPolicy();
    message.cluster = object.cluster ?? undefined;
    message.runtime_key = object.runtime_key ?? undefined;
    message.runtime_fraction = (object.runtime_fraction !== undefined && object.runtime_fraction !== null)
      ? RuntimeFractionalPercent.fromPartial(object.runtime_fraction)
      : undefined;
    message.trace_sampled = object.trace_sampled ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RouteAction_RequestMirrorPolicy.$type, RouteAction_RequestMirrorPolicy);

function createBaseRouteAction_HashPolicy(): RouteAction_HashPolicy {
  return { $type: "envoy.api.v2.route.RouteAction.HashPolicy", policy_specifier: undefined };
}

export const RouteAction_HashPolicy: MessageFns<RouteAction_HashPolicy, "envoy.api.v2.route.RouteAction.HashPolicy"> = {
  $type: "envoy.api.v2.route.RouteAction.HashPolicy" as const,

  encode(message: RouteAction_HashPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.policy_specifier?.$case) {
      case "header":
        RouteAction_HashPolicy_Header.encode(message.policy_specifier.header, writer.uint32(10).fork()).join();
        break;
      case "cookie":
        RouteAction_HashPolicy_Cookie.encode(message.policy_specifier.cookie, writer.uint32(18).fork()).join();
        break;
      case "connection_properties":
        RouteAction_HashPolicy_ConnectionProperties.encode(
          message.policy_specifier.connection_properties,
          writer.uint32(26).fork(),
        ).join();
        break;
      case "query_parameter":
        RouteAction_HashPolicy_QueryParameter.encode(message.policy_specifier.query_parameter, writer.uint32(42).fork())
          .join();
        break;
      case "filter_state":
        RouteAction_HashPolicy_FilterState.encode(message.policy_specifier.filter_state, writer.uint32(50).fork())
          .join();
        break;
    }
    if (message.terminal !== undefined && message.terminal !== false) {
      writer.uint32(32).bool(message.terminal);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteAction_HashPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteAction_HashPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.policy_specifier = {
            $case: "header",
            header: RouteAction_HashPolicy_Header.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.policy_specifier = {
            $case: "cookie",
            cookie: RouteAction_HashPolicy_Cookie.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.policy_specifier = {
            $case: "connection_properties",
            connection_properties: RouteAction_HashPolicy_ConnectionProperties.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.policy_specifier = {
            $case: "query_parameter",
            query_parameter: RouteAction_HashPolicy_QueryParameter.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.policy_specifier = {
            $case: "filter_state",
            filter_state: RouteAction_HashPolicy_FilterState.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.terminal = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteAction_HashPolicy {
    return {
      $type: RouteAction_HashPolicy.$type,
      policy_specifier: isSet(object.header)
        ? { $case: "header", header: RouteAction_HashPolicy_Header.fromJSON(object.header) }
        : isSet(object.cookie)
        ? { $case: "cookie", cookie: RouteAction_HashPolicy_Cookie.fromJSON(object.cookie) }
        : isSet(object.connection_properties)
        ? {
          $case: "connection_properties",
          connection_properties: RouteAction_HashPolicy_ConnectionProperties.fromJSON(object.connection_properties),
        }
        : isSet(object.query_parameter)
        ? {
          $case: "query_parameter",
          query_parameter: RouteAction_HashPolicy_QueryParameter.fromJSON(object.query_parameter),
        }
        : isSet(object.filter_state)
        ? { $case: "filter_state", filter_state: RouteAction_HashPolicy_FilterState.fromJSON(object.filter_state) }
        : undefined,
      terminal: isSet(object.terminal) ? globalThis.Boolean(object.terminal) : undefined,
    };
  },

  toJSON(message: RouteAction_HashPolicy): unknown {
    const obj: any = {};
    if (message.policy_specifier?.$case === "header") {
      obj.header = RouteAction_HashPolicy_Header.toJSON(message.policy_specifier.header);
    }
    if (message.policy_specifier?.$case === "cookie") {
      obj.cookie = RouteAction_HashPolicy_Cookie.toJSON(message.policy_specifier.cookie);
    }
    if (message.policy_specifier?.$case === "connection_properties") {
      obj.connection_properties = RouteAction_HashPolicy_ConnectionProperties.toJSON(
        message.policy_specifier.connection_properties,
      );
    }
    if (message.policy_specifier?.$case === "query_parameter") {
      obj.query_parameter = RouteAction_HashPolicy_QueryParameter.toJSON(message.policy_specifier.query_parameter);
    }
    if (message.policy_specifier?.$case === "filter_state") {
      obj.filter_state = RouteAction_HashPolicy_FilterState.toJSON(message.policy_specifier.filter_state);
    }
    if (message.terminal !== undefined) {
      obj.terminal = message.terminal;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RouteAction_HashPolicy>, I>>(base?: I): RouteAction_HashPolicy {
    return RouteAction_HashPolicy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RouteAction_HashPolicy>, I>>(object: I): RouteAction_HashPolicy {
    const message = createBaseRouteAction_HashPolicy();
    if (
      object.policy_specifier?.$case === "header" &&
      object.policy_specifier?.header !== undefined &&
      object.policy_specifier?.header !== null
    ) {
      message.policy_specifier = {
        $case: "header",
        header: RouteAction_HashPolicy_Header.fromPartial(object.policy_specifier.header),
      };
    }
    if (
      object.policy_specifier?.$case === "cookie" &&
      object.policy_specifier?.cookie !== undefined &&
      object.policy_specifier?.cookie !== null
    ) {
      message.policy_specifier = {
        $case: "cookie",
        cookie: RouteAction_HashPolicy_Cookie.fromPartial(object.policy_specifier.cookie),
      };
    }
    if (
      object.policy_specifier?.$case === "connection_properties" &&
      object.policy_specifier?.connection_properties !== undefined &&
      object.policy_specifier?.connection_properties !== null
    ) {
      message.policy_specifier = {
        $case: "connection_properties",
        connection_properties: RouteAction_HashPolicy_ConnectionProperties.fromPartial(
          object.policy_specifier.connection_properties,
        ),
      };
    }
    if (
      object.policy_specifier?.$case === "query_parameter" &&
      object.policy_specifier?.query_parameter !== undefined &&
      object.policy_specifier?.query_parameter !== null
    ) {
      message.policy_specifier = {
        $case: "query_parameter",
        query_parameter: RouteAction_HashPolicy_QueryParameter.fromPartial(object.policy_specifier.query_parameter),
      };
    }
    if (
      object.policy_specifier?.$case === "filter_state" &&
      object.policy_specifier?.filter_state !== undefined &&
      object.policy_specifier?.filter_state !== null
    ) {
      message.policy_specifier = {
        $case: "filter_state",
        filter_state: RouteAction_HashPolicy_FilterState.fromPartial(object.policy_specifier.filter_state),
      };
    }
    message.terminal = object.terminal ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RouteAction_HashPolicy.$type, RouteAction_HashPolicy);

function createBaseRouteAction_HashPolicy_Header(): RouteAction_HashPolicy_Header {
  return { $type: "envoy.api.v2.route.RouteAction.HashPolicy.Header" };
}

export const RouteAction_HashPolicy_Header: MessageFns<
  RouteAction_HashPolicy_Header,
  "envoy.api.v2.route.RouteAction.HashPolicy.Header"
> = {
  $type: "envoy.api.v2.route.RouteAction.HashPolicy.Header" as const,

  encode(message: RouteAction_HashPolicy_Header, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header_name !== undefined && message.header_name !== "") {
      writer.uint32(10).string(message.header_name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteAction_HashPolicy_Header {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteAction_HashPolicy_Header();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header_name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteAction_HashPolicy_Header {
    return {
      $type: RouteAction_HashPolicy_Header.$type,
      header_name: isSet(object.header_name) ? globalThis.String(object.header_name) : undefined,
    };
  },

  toJSON(message: RouteAction_HashPolicy_Header): unknown {
    const obj: any = {};
    if (message.header_name !== undefined) {
      obj.header_name = message.header_name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RouteAction_HashPolicy_Header>, I>>(base?: I): RouteAction_HashPolicy_Header {
    return RouteAction_HashPolicy_Header.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RouteAction_HashPolicy_Header>, I>>(
    object: I,
  ): RouteAction_HashPolicy_Header {
    const message = createBaseRouteAction_HashPolicy_Header();
    message.header_name = object.header_name ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RouteAction_HashPolicy_Header.$type, RouteAction_HashPolicy_Header);

function createBaseRouteAction_HashPolicy_Cookie(): RouteAction_HashPolicy_Cookie {
  return { $type: "envoy.api.v2.route.RouteAction.HashPolicy.Cookie" };
}

export const RouteAction_HashPolicy_Cookie: MessageFns<
  RouteAction_HashPolicy_Cookie,
  "envoy.api.v2.route.RouteAction.HashPolicy.Cookie"
> = {
  $type: "envoy.api.v2.route.RouteAction.HashPolicy.Cookie" as const,

  encode(message: RouteAction_HashPolicy_Cookie, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.ttl !== undefined) {
      Duration.encode(message.ttl, writer.uint32(18).fork()).join();
    }
    if (message.path !== undefined && message.path !== "") {
      writer.uint32(26).string(message.path);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteAction_HashPolicy_Cookie {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteAction_HashPolicy_Cookie();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ttl = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.path = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteAction_HashPolicy_Cookie {
    return {
      $type: RouteAction_HashPolicy_Cookie.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      ttl: isSet(object.ttl) ? Duration.fromJSON(object.ttl) : undefined,
      path: isSet(object.path) ? globalThis.String(object.path) : undefined,
    };
  },

  toJSON(message: RouteAction_HashPolicy_Cookie): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.ttl !== undefined) {
      obj.ttl = Duration.toJSON(message.ttl);
    }
    if (message.path !== undefined) {
      obj.path = message.path;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RouteAction_HashPolicy_Cookie>, I>>(base?: I): RouteAction_HashPolicy_Cookie {
    return RouteAction_HashPolicy_Cookie.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RouteAction_HashPolicy_Cookie>, I>>(
    object: I,
  ): RouteAction_HashPolicy_Cookie {
    const message = createBaseRouteAction_HashPolicy_Cookie();
    message.name = object.name ?? undefined;
    message.ttl = (object.ttl !== undefined && object.ttl !== null) ? Duration.fromPartial(object.ttl) : undefined;
    message.path = object.path ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RouteAction_HashPolicy_Cookie.$type, RouteAction_HashPolicy_Cookie);

function createBaseRouteAction_HashPolicy_ConnectionProperties(): RouteAction_HashPolicy_ConnectionProperties {
  return { $type: "envoy.api.v2.route.RouteAction.HashPolicy.ConnectionProperties" };
}

export const RouteAction_HashPolicy_ConnectionProperties: MessageFns<
  RouteAction_HashPolicy_ConnectionProperties,
  "envoy.api.v2.route.RouteAction.HashPolicy.ConnectionProperties"
> = {
  $type: "envoy.api.v2.route.RouteAction.HashPolicy.ConnectionProperties" as const,

  encode(
    message: RouteAction_HashPolicy_ConnectionProperties,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.source_ip !== undefined && message.source_ip !== false) {
      writer.uint32(8).bool(message.source_ip);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteAction_HashPolicy_ConnectionProperties {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteAction_HashPolicy_ConnectionProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.source_ip = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteAction_HashPolicy_ConnectionProperties {
    return {
      $type: RouteAction_HashPolicy_ConnectionProperties.$type,
      source_ip: isSet(object.source_ip) ? globalThis.Boolean(object.source_ip) : undefined,
    };
  },

  toJSON(message: RouteAction_HashPolicy_ConnectionProperties): unknown {
    const obj: any = {};
    if (message.source_ip !== undefined) {
      obj.source_ip = message.source_ip;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RouteAction_HashPolicy_ConnectionProperties>, I>>(
    base?: I,
  ): RouteAction_HashPolicy_ConnectionProperties {
    return RouteAction_HashPolicy_ConnectionProperties.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RouteAction_HashPolicy_ConnectionProperties>, I>>(
    object: I,
  ): RouteAction_HashPolicy_ConnectionProperties {
    const message = createBaseRouteAction_HashPolicy_ConnectionProperties();
    message.source_ip = object.source_ip ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RouteAction_HashPolicy_ConnectionProperties.$type, RouteAction_HashPolicy_ConnectionProperties);

function createBaseRouteAction_HashPolicy_QueryParameter(): RouteAction_HashPolicy_QueryParameter {
  return { $type: "envoy.api.v2.route.RouteAction.HashPolicy.QueryParameter" };
}

export const RouteAction_HashPolicy_QueryParameter: MessageFns<
  RouteAction_HashPolicy_QueryParameter,
  "envoy.api.v2.route.RouteAction.HashPolicy.QueryParameter"
> = {
  $type: "envoy.api.v2.route.RouteAction.HashPolicy.QueryParameter" as const,

  encode(message: RouteAction_HashPolicy_QueryParameter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteAction_HashPolicy_QueryParameter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteAction_HashPolicy_QueryParameter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteAction_HashPolicy_QueryParameter {
    return {
      $type: RouteAction_HashPolicy_QueryParameter.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
    };
  },

  toJSON(message: RouteAction_HashPolicy_QueryParameter): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RouteAction_HashPolicy_QueryParameter>, I>>(
    base?: I,
  ): RouteAction_HashPolicy_QueryParameter {
    return RouteAction_HashPolicy_QueryParameter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RouteAction_HashPolicy_QueryParameter>, I>>(
    object: I,
  ): RouteAction_HashPolicy_QueryParameter {
    const message = createBaseRouteAction_HashPolicy_QueryParameter();
    message.name = object.name ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RouteAction_HashPolicy_QueryParameter.$type, RouteAction_HashPolicy_QueryParameter);

function createBaseRouteAction_HashPolicy_FilterState(): RouteAction_HashPolicy_FilterState {
  return { $type: "envoy.api.v2.route.RouteAction.HashPolicy.FilterState" };
}

export const RouteAction_HashPolicy_FilterState: MessageFns<
  RouteAction_HashPolicy_FilterState,
  "envoy.api.v2.route.RouteAction.HashPolicy.FilterState"
> = {
  $type: "envoy.api.v2.route.RouteAction.HashPolicy.FilterState" as const,

  encode(message: RouteAction_HashPolicy_FilterState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined && message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteAction_HashPolicy_FilterState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteAction_HashPolicy_FilterState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteAction_HashPolicy_FilterState {
    return {
      $type: RouteAction_HashPolicy_FilterState.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : undefined,
    };
  },

  toJSON(message: RouteAction_HashPolicy_FilterState): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RouteAction_HashPolicy_FilterState>, I>>(
    base?: I,
  ): RouteAction_HashPolicy_FilterState {
    return RouteAction_HashPolicy_FilterState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RouteAction_HashPolicy_FilterState>, I>>(
    object: I,
  ): RouteAction_HashPolicy_FilterState {
    const message = createBaseRouteAction_HashPolicy_FilterState();
    message.key = object.key ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RouteAction_HashPolicy_FilterState.$type, RouteAction_HashPolicy_FilterState);

function createBaseRouteAction_UpgradeConfig(): RouteAction_UpgradeConfig {
  return { $type: "envoy.api.v2.route.RouteAction.UpgradeConfig" };
}

export const RouteAction_UpgradeConfig: MessageFns<
  RouteAction_UpgradeConfig,
  "envoy.api.v2.route.RouteAction.UpgradeConfig"
> = {
  $type: "envoy.api.v2.route.RouteAction.UpgradeConfig" as const,

  encode(message: RouteAction_UpgradeConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.upgrade_type !== undefined && message.upgrade_type !== "") {
      writer.uint32(10).string(message.upgrade_type);
    }
    if (message.enabled !== undefined) {
      BoolValue.encode({ $type: "google.protobuf.BoolValue", value: message.enabled! }, writer.uint32(18).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteAction_UpgradeConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteAction_UpgradeConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.upgrade_type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.enabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteAction_UpgradeConfig {
    return {
      $type: RouteAction_UpgradeConfig.$type,
      upgrade_type: isSet(object.upgrade_type) ? globalThis.String(object.upgrade_type) : undefined,
      enabled: isSet(object.enabled) ? Boolean(object.enabled) : undefined,
    };
  },

  toJSON(message: RouteAction_UpgradeConfig): unknown {
    const obj: any = {};
    if (message.upgrade_type !== undefined) {
      obj.upgrade_type = message.upgrade_type;
    }
    if (message.enabled !== undefined) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RouteAction_UpgradeConfig>, I>>(base?: I): RouteAction_UpgradeConfig {
    return RouteAction_UpgradeConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RouteAction_UpgradeConfig>, I>>(object: I): RouteAction_UpgradeConfig {
    const message = createBaseRouteAction_UpgradeConfig();
    message.upgrade_type = object.upgrade_type ?? undefined;
    message.enabled = object.enabled ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RouteAction_UpgradeConfig.$type, RouteAction_UpgradeConfig);

function createBaseRetryPolicy(): RetryPolicy {
  return { $type: "envoy.api.v2.route.RetryPolicy" };
}

export const RetryPolicy: MessageFns<RetryPolicy, "envoy.api.v2.route.RetryPolicy"> = {
  $type: "envoy.api.v2.route.RetryPolicy" as const,

  encode(message: RetryPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.retry_on !== undefined && message.retry_on !== "") {
      writer.uint32(10).string(message.retry_on);
    }
    if (message.num_retries !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.num_retries! },
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.per_try_timeout !== undefined) {
      Duration.encode(message.per_try_timeout, writer.uint32(26).fork()).join();
    }
    if (message.retry_priority !== undefined) {
      RetryPolicy_RetryPriority.encode(message.retry_priority, writer.uint32(34).fork()).join();
    }
    if (message.retry_host_predicate !== undefined && message.retry_host_predicate.length !== 0) {
      for (const v of message.retry_host_predicate) {
        RetryPolicy_RetryHostPredicate.encode(v!, writer.uint32(42).fork()).join();
      }
    }
    if (message.host_selection_retry_max_attempts !== undefined && message.host_selection_retry_max_attempts !== 0) {
      writer.uint32(48).int64(message.host_selection_retry_max_attempts);
    }
    if (message.retriable_status_codes !== undefined && message.retriable_status_codes.length !== 0) {
      writer.uint32(58).fork();
      for (const v of message.retriable_status_codes) {
        writer.uint32(v);
      }
      writer.join();
    }
    if (message.retry_back_off !== undefined) {
      RetryPolicy_RetryBackOff.encode(message.retry_back_off, writer.uint32(66).fork()).join();
    }
    if (message.retriable_headers !== undefined && message.retriable_headers.length !== 0) {
      for (const v of message.retriable_headers) {
        HeaderMatcher.encode(v!, writer.uint32(74).fork()).join();
      }
    }
    if (message.retriable_request_headers !== undefined && message.retriable_request_headers.length !== 0) {
      for (const v of message.retriable_request_headers) {
        HeaderMatcher.encode(v!, writer.uint32(82).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.retry_on = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.num_retries = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.per_try_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.retry_priority = RetryPolicy_RetryPriority.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          if (message.retry_host_predicate === undefined) {
            message.retry_host_predicate = [];
          }
          const el = RetryPolicy_RetryHostPredicate.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.retry_host_predicate!.push(el);
          }
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.host_selection_retry_max_attempts = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag === 56) {
            if (message.retriable_status_codes === undefined) {
              message.retriable_status_codes = [];
            }
            message.retriable_status_codes!.push(reader.uint32());

            continue;
          }

          if (tag === 58) {
            if (message.retriable_status_codes === undefined) {
              message.retriable_status_codes = [];
            }
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.retriable_status_codes!.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.retry_back_off = RetryPolicy_RetryBackOff.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          if (message.retriable_headers === undefined) {
            message.retriable_headers = [];
          }
          const el = HeaderMatcher.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.retriable_headers!.push(el);
          }
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          if (message.retriable_request_headers === undefined) {
            message.retriable_request_headers = [];
          }
          const el = HeaderMatcher.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.retriable_request_headers!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetryPolicy {
    return {
      $type: RetryPolicy.$type,
      retry_on: isSet(object.retry_on) ? globalThis.String(object.retry_on) : undefined,
      num_retries: isSet(object.num_retries) ? Number(object.num_retries) : undefined,
      per_try_timeout: isSet(object.per_try_timeout) ? Duration.fromJSON(object.per_try_timeout) : undefined,
      retry_priority: isSet(object.retry_priority)
        ? RetryPolicy_RetryPriority.fromJSON(object.retry_priority)
        : undefined,
      retry_host_predicate: globalThis.Array.isArray(object?.retry_host_predicate)
        ? object.retry_host_predicate.map((e: any) => RetryPolicy_RetryHostPredicate.fromJSON(e))
        : undefined,
      host_selection_retry_max_attempts: isSet(object.host_selection_retry_max_attempts)
        ? globalThis.Number(object.host_selection_retry_max_attempts)
        : undefined,
      retriable_status_codes: globalThis.Array.isArray(object?.retriable_status_codes)
        ? object.retriable_status_codes.map((e: any) => globalThis.Number(e))
        : undefined,
      retry_back_off: isSet(object.retry_back_off)
        ? RetryPolicy_RetryBackOff.fromJSON(object.retry_back_off)
        : undefined,
      retriable_headers: globalThis.Array.isArray(object?.retriable_headers)
        ? object.retriable_headers.map((e: any) => HeaderMatcher.fromJSON(e))
        : undefined,
      retriable_request_headers: globalThis.Array.isArray(object?.retriable_request_headers)
        ? object.retriable_request_headers.map((e: any) => HeaderMatcher.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: RetryPolicy): unknown {
    const obj: any = {};
    if (message.retry_on !== undefined) {
      obj.retry_on = message.retry_on;
    }
    if (message.num_retries !== undefined) {
      obj.num_retries = message.num_retries;
    }
    if (message.per_try_timeout !== undefined) {
      obj.per_try_timeout = Duration.toJSON(message.per_try_timeout);
    }
    if (message.retry_priority !== undefined) {
      obj.retry_priority = RetryPolicy_RetryPriority.toJSON(message.retry_priority);
    }
    if (message.retry_host_predicate?.length) {
      obj.retry_host_predicate = message.retry_host_predicate.map((e) => RetryPolicy_RetryHostPredicate.toJSON(e));
    }
    if (message.host_selection_retry_max_attempts !== undefined) {
      obj.host_selection_retry_max_attempts = Math.round(message.host_selection_retry_max_attempts);
    }
    if (message.retriable_status_codes?.length) {
      obj.retriable_status_codes = message.retriable_status_codes.map((e) => Math.round(e));
    }
    if (message.retry_back_off !== undefined) {
      obj.retry_back_off = RetryPolicy_RetryBackOff.toJSON(message.retry_back_off);
    }
    if (message.retriable_headers?.length) {
      obj.retriable_headers = message.retriable_headers.map((e) => HeaderMatcher.toJSON(e));
    }
    if (message.retriable_request_headers?.length) {
      obj.retriable_request_headers = message.retriable_request_headers.map((e) => HeaderMatcher.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetryPolicy>, I>>(base?: I): RetryPolicy {
    return RetryPolicy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetryPolicy>, I>>(object: I): RetryPolicy {
    const message = createBaseRetryPolicy();
    message.retry_on = object.retry_on ?? undefined;
    message.num_retries = object.num_retries ?? undefined;
    message.per_try_timeout = (object.per_try_timeout !== undefined && object.per_try_timeout !== null)
      ? Duration.fromPartial(object.per_try_timeout)
      : undefined;
    message.retry_priority = (object.retry_priority !== undefined && object.retry_priority !== null)
      ? RetryPolicy_RetryPriority.fromPartial(object.retry_priority)
      : undefined;
    message.retry_host_predicate =
      object.retry_host_predicate?.map((e) => RetryPolicy_RetryHostPredicate.fromPartial(e)) || undefined;
    message.host_selection_retry_max_attempts = object.host_selection_retry_max_attempts ?? undefined;
    message.retriable_status_codes = object.retriable_status_codes?.map((e) => e) || undefined;
    message.retry_back_off = (object.retry_back_off !== undefined && object.retry_back_off !== null)
      ? RetryPolicy_RetryBackOff.fromPartial(object.retry_back_off)
      : undefined;
    message.retriable_headers = object.retriable_headers?.map((e) => HeaderMatcher.fromPartial(e)) || undefined;
    message.retriable_request_headers = object.retriable_request_headers?.map((e) => HeaderMatcher.fromPartial(e)) ||
      undefined;
    return message;
  },
};

messageTypeRegistry.set(RetryPolicy.$type, RetryPolicy);

function createBaseRetryPolicy_RetryPriority(): RetryPolicy_RetryPriority {
  return { $type: "envoy.api.v2.route.RetryPolicy.RetryPriority", config_type: undefined };
}

export const RetryPolicy_RetryPriority: MessageFns<
  RetryPolicy_RetryPriority,
  "envoy.api.v2.route.RetryPolicy.RetryPriority"
> = {
  $type: "envoy.api.v2.route.RetryPolicy.RetryPriority" as const,

  encode(message: RetryPolicy_RetryPriority, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    switch (message.config_type?.$case) {
      case "config":
        Struct.encode(Struct.wrap(message.config_type.config), writer.uint32(18).fork()).join();
        break;
      case "typed_config":
        Any.encode(message.config_type.typed_config, writer.uint32(26).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryPolicy_RetryPriority {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryPolicy_RetryPriority();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.config_type = { $case: "config", config: Struct.unwrap(Struct.decode(reader, reader.uint32())) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.config_type = { $case: "typed_config", typed_config: Any.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetryPolicy_RetryPriority {
    return {
      $type: RetryPolicy_RetryPriority.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      config_type: isSet(object.config)
        ? { $case: "config", config: object.config }
        : isSet(object.typed_config)
        ? { $case: "typed_config", typed_config: Any.fromJSON(object.typed_config) }
        : undefined,
    };
  },

  toJSON(message: RetryPolicy_RetryPriority): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.config_type?.$case === "config") {
      obj.config = message.config_type.config;
    }
    if (message.config_type?.$case === "typed_config") {
      obj.typed_config = Any.toJSON(message.config_type.typed_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetryPolicy_RetryPriority>, I>>(base?: I): RetryPolicy_RetryPriority {
    return RetryPolicy_RetryPriority.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetryPolicy_RetryPriority>, I>>(object: I): RetryPolicy_RetryPriority {
    const message = createBaseRetryPolicy_RetryPriority();
    message.name = object.name ?? undefined;
    if (
      object.config_type?.$case === "config" &&
      object.config_type?.config !== undefined &&
      object.config_type?.config !== null
    ) {
      message.config_type = { $case: "config", config: object.config_type.config };
    }
    if (
      object.config_type?.$case === "typed_config" &&
      object.config_type?.typed_config !== undefined &&
      object.config_type?.typed_config !== null
    ) {
      message.config_type = { $case: "typed_config", typed_config: Any.fromPartial(object.config_type.typed_config) };
    }
    return message;
  },
};

messageTypeRegistry.set(RetryPolicy_RetryPriority.$type, RetryPolicy_RetryPriority);

function createBaseRetryPolicy_RetryHostPredicate(): RetryPolicy_RetryHostPredicate {
  return { $type: "envoy.api.v2.route.RetryPolicy.RetryHostPredicate", config_type: undefined };
}

export const RetryPolicy_RetryHostPredicate: MessageFns<
  RetryPolicy_RetryHostPredicate,
  "envoy.api.v2.route.RetryPolicy.RetryHostPredicate"
> = {
  $type: "envoy.api.v2.route.RetryPolicy.RetryHostPredicate" as const,

  encode(message: RetryPolicy_RetryHostPredicate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    switch (message.config_type?.$case) {
      case "config":
        Struct.encode(Struct.wrap(message.config_type.config), writer.uint32(18).fork()).join();
        break;
      case "typed_config":
        Any.encode(message.config_type.typed_config, writer.uint32(26).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryPolicy_RetryHostPredicate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryPolicy_RetryHostPredicate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.config_type = { $case: "config", config: Struct.unwrap(Struct.decode(reader, reader.uint32())) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.config_type = { $case: "typed_config", typed_config: Any.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetryPolicy_RetryHostPredicate {
    return {
      $type: RetryPolicy_RetryHostPredicate.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      config_type: isSet(object.config)
        ? { $case: "config", config: object.config }
        : isSet(object.typed_config)
        ? { $case: "typed_config", typed_config: Any.fromJSON(object.typed_config) }
        : undefined,
    };
  },

  toJSON(message: RetryPolicy_RetryHostPredicate): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.config_type?.$case === "config") {
      obj.config = message.config_type.config;
    }
    if (message.config_type?.$case === "typed_config") {
      obj.typed_config = Any.toJSON(message.config_type.typed_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetryPolicy_RetryHostPredicate>, I>>(base?: I): RetryPolicy_RetryHostPredicate {
    return RetryPolicy_RetryHostPredicate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetryPolicy_RetryHostPredicate>, I>>(
    object: I,
  ): RetryPolicy_RetryHostPredicate {
    const message = createBaseRetryPolicy_RetryHostPredicate();
    message.name = object.name ?? undefined;
    if (
      object.config_type?.$case === "config" &&
      object.config_type?.config !== undefined &&
      object.config_type?.config !== null
    ) {
      message.config_type = { $case: "config", config: object.config_type.config };
    }
    if (
      object.config_type?.$case === "typed_config" &&
      object.config_type?.typed_config !== undefined &&
      object.config_type?.typed_config !== null
    ) {
      message.config_type = { $case: "typed_config", typed_config: Any.fromPartial(object.config_type.typed_config) };
    }
    return message;
  },
};

messageTypeRegistry.set(RetryPolicy_RetryHostPredicate.$type, RetryPolicy_RetryHostPredicate);

function createBaseRetryPolicy_RetryBackOff(): RetryPolicy_RetryBackOff {
  return { $type: "envoy.api.v2.route.RetryPolicy.RetryBackOff" };
}

export const RetryPolicy_RetryBackOff: MessageFns<
  RetryPolicy_RetryBackOff,
  "envoy.api.v2.route.RetryPolicy.RetryBackOff"
> = {
  $type: "envoy.api.v2.route.RetryPolicy.RetryBackOff" as const,

  encode(message: RetryPolicy_RetryBackOff, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.base_interval !== undefined) {
      Duration.encode(message.base_interval, writer.uint32(10).fork()).join();
    }
    if (message.max_interval !== undefined) {
      Duration.encode(message.max_interval, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryPolicy_RetryBackOff {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryPolicy_RetryBackOff();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.base_interval = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.max_interval = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetryPolicy_RetryBackOff {
    return {
      $type: RetryPolicy_RetryBackOff.$type,
      base_interval: isSet(object.base_interval) ? Duration.fromJSON(object.base_interval) : undefined,
      max_interval: isSet(object.max_interval) ? Duration.fromJSON(object.max_interval) : undefined,
    };
  },

  toJSON(message: RetryPolicy_RetryBackOff): unknown {
    const obj: any = {};
    if (message.base_interval !== undefined) {
      obj.base_interval = Duration.toJSON(message.base_interval);
    }
    if (message.max_interval !== undefined) {
      obj.max_interval = Duration.toJSON(message.max_interval);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetryPolicy_RetryBackOff>, I>>(base?: I): RetryPolicy_RetryBackOff {
    return RetryPolicy_RetryBackOff.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetryPolicy_RetryBackOff>, I>>(object: I): RetryPolicy_RetryBackOff {
    const message = createBaseRetryPolicy_RetryBackOff();
    message.base_interval = (object.base_interval !== undefined && object.base_interval !== null)
      ? Duration.fromPartial(object.base_interval)
      : undefined;
    message.max_interval = (object.max_interval !== undefined && object.max_interval !== null)
      ? Duration.fromPartial(object.max_interval)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(RetryPolicy_RetryBackOff.$type, RetryPolicy_RetryBackOff);

function createBaseHedgePolicy(): HedgePolicy {
  return { $type: "envoy.api.v2.route.HedgePolicy" };
}

export const HedgePolicy: MessageFns<HedgePolicy, "envoy.api.v2.route.HedgePolicy"> = {
  $type: "envoy.api.v2.route.HedgePolicy" as const,

  encode(message: HedgePolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.initial_requests !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.initial_requests! },
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.additional_request_chance !== undefined) {
      FractionalPercent.encode(message.additional_request_chance, writer.uint32(18).fork()).join();
    }
    if (message.hedge_on_per_try_timeout !== undefined && message.hedge_on_per_try_timeout !== false) {
      writer.uint32(24).bool(message.hedge_on_per_try_timeout);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HedgePolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHedgePolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.initial_requests = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.additional_request_chance = FractionalPercent.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.hedge_on_per_try_timeout = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HedgePolicy {
    return {
      $type: HedgePolicy.$type,
      initial_requests: isSet(object.initial_requests) ? Number(object.initial_requests) : undefined,
      additional_request_chance: isSet(object.additional_request_chance)
        ? FractionalPercent.fromJSON(object.additional_request_chance)
        : undefined,
      hedge_on_per_try_timeout: isSet(object.hedge_on_per_try_timeout)
        ? globalThis.Boolean(object.hedge_on_per_try_timeout)
        : undefined,
    };
  },

  toJSON(message: HedgePolicy): unknown {
    const obj: any = {};
    if (message.initial_requests !== undefined) {
      obj.initial_requests = message.initial_requests;
    }
    if (message.additional_request_chance !== undefined) {
      obj.additional_request_chance = FractionalPercent.toJSON(message.additional_request_chance);
    }
    if (message.hedge_on_per_try_timeout !== undefined) {
      obj.hedge_on_per_try_timeout = message.hedge_on_per_try_timeout;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HedgePolicy>, I>>(base?: I): HedgePolicy {
    return HedgePolicy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HedgePolicy>, I>>(object: I): HedgePolicy {
    const message = createBaseHedgePolicy();
    message.initial_requests = object.initial_requests ?? undefined;
    message.additional_request_chance =
      (object.additional_request_chance !== undefined && object.additional_request_chance !== null)
        ? FractionalPercent.fromPartial(object.additional_request_chance)
        : undefined;
    message.hedge_on_per_try_timeout = object.hedge_on_per_try_timeout ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(HedgePolicy.$type, HedgePolicy);

function createBaseRedirectAction(): RedirectAction {
  return {
    $type: "envoy.api.v2.route.RedirectAction",
    scheme_rewrite_specifier: undefined,
    path_rewrite_specifier: undefined,
  };
}

export const RedirectAction: MessageFns<RedirectAction, "envoy.api.v2.route.RedirectAction"> = {
  $type: "envoy.api.v2.route.RedirectAction" as const,

  encode(message: RedirectAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.scheme_rewrite_specifier?.$case) {
      case "https_redirect":
        writer.uint32(32).bool(message.scheme_rewrite_specifier.https_redirect);
        break;
      case "scheme_redirect":
        writer.uint32(58).string(message.scheme_rewrite_specifier.scheme_redirect);
        break;
    }
    if (message.host_redirect !== undefined && message.host_redirect !== "") {
      writer.uint32(10).string(message.host_redirect);
    }
    if (message.port_redirect !== undefined && message.port_redirect !== 0) {
      writer.uint32(64).uint32(message.port_redirect);
    }
    switch (message.path_rewrite_specifier?.$case) {
      case "path_redirect":
        writer.uint32(18).string(message.path_rewrite_specifier.path_redirect);
        break;
      case "prefix_rewrite":
        writer.uint32(42).string(message.path_rewrite_specifier.prefix_rewrite);
        break;
    }
    if (
      message.response_code !== undefined &&
      message.response_code !== RedirectAction_RedirectResponseCode.MOVED_PERMANENTLY
    ) {
      writer.uint32(24).int32(redirectAction_RedirectResponseCodeToNumber(message.response_code));
    }
    if (message.strip_query !== undefined && message.strip_query !== false) {
      writer.uint32(48).bool(message.strip_query);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RedirectAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRedirectAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.scheme_rewrite_specifier = { $case: "https_redirect", https_redirect: reader.bool() };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.scheme_rewrite_specifier = { $case: "scheme_redirect", scheme_redirect: reader.string() };
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.host_redirect = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.port_redirect = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.path_rewrite_specifier = { $case: "path_redirect", path_redirect: reader.string() };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.path_rewrite_specifier = { $case: "prefix_rewrite", prefix_rewrite: reader.string() };
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.response_code = redirectAction_RedirectResponseCodeFromJSON(reader.int32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.strip_query = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RedirectAction {
    return {
      $type: RedirectAction.$type,
      scheme_rewrite_specifier: isSet(object.https_redirect)
        ? { $case: "https_redirect", https_redirect: globalThis.Boolean(object.https_redirect) }
        : isSet(object.scheme_redirect)
        ? { $case: "scheme_redirect", scheme_redirect: globalThis.String(object.scheme_redirect) }
        : undefined,
      host_redirect: isSet(object.host_redirect) ? globalThis.String(object.host_redirect) : undefined,
      port_redirect: isSet(object.port_redirect) ? globalThis.Number(object.port_redirect) : undefined,
      path_rewrite_specifier: isSet(object.path_redirect)
        ? { $case: "path_redirect", path_redirect: globalThis.String(object.path_redirect) }
        : isSet(object.prefix_rewrite)
        ? { $case: "prefix_rewrite", prefix_rewrite: globalThis.String(object.prefix_rewrite) }
        : undefined,
      response_code: isSet(object.response_code)
        ? redirectAction_RedirectResponseCodeFromJSON(object.response_code)
        : undefined,
      strip_query: isSet(object.strip_query) ? globalThis.Boolean(object.strip_query) : undefined,
    };
  },

  toJSON(message: RedirectAction): unknown {
    const obj: any = {};
    if (message.scheme_rewrite_specifier?.$case === "https_redirect") {
      obj.https_redirect = message.scheme_rewrite_specifier.https_redirect;
    }
    if (message.scheme_rewrite_specifier?.$case === "scheme_redirect") {
      obj.scheme_redirect = message.scheme_rewrite_specifier.scheme_redirect;
    }
    if (message.host_redirect !== undefined) {
      obj.host_redirect = message.host_redirect;
    }
    if (message.port_redirect !== undefined) {
      obj.port_redirect = Math.round(message.port_redirect);
    }
    if (message.path_rewrite_specifier?.$case === "path_redirect") {
      obj.path_redirect = message.path_rewrite_specifier.path_redirect;
    }
    if (message.path_rewrite_specifier?.$case === "prefix_rewrite") {
      obj.prefix_rewrite = message.path_rewrite_specifier.prefix_rewrite;
    }
    if (message.response_code !== undefined) {
      obj.response_code = redirectAction_RedirectResponseCodeToJSON(message.response_code);
    }
    if (message.strip_query !== undefined) {
      obj.strip_query = message.strip_query;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RedirectAction>, I>>(base?: I): RedirectAction {
    return RedirectAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RedirectAction>, I>>(object: I): RedirectAction {
    const message = createBaseRedirectAction();
    if (
      object.scheme_rewrite_specifier?.$case === "https_redirect" &&
      object.scheme_rewrite_specifier?.https_redirect !== undefined &&
      object.scheme_rewrite_specifier?.https_redirect !== null
    ) {
      message.scheme_rewrite_specifier = {
        $case: "https_redirect",
        https_redirect: object.scheme_rewrite_specifier.https_redirect,
      };
    }
    if (
      object.scheme_rewrite_specifier?.$case === "scheme_redirect" &&
      object.scheme_rewrite_specifier?.scheme_redirect !== undefined &&
      object.scheme_rewrite_specifier?.scheme_redirect !== null
    ) {
      message.scheme_rewrite_specifier = {
        $case: "scheme_redirect",
        scheme_redirect: object.scheme_rewrite_specifier.scheme_redirect,
      };
    }
    message.host_redirect = object.host_redirect ?? undefined;
    message.port_redirect = object.port_redirect ?? undefined;
    if (
      object.path_rewrite_specifier?.$case === "path_redirect" &&
      object.path_rewrite_specifier?.path_redirect !== undefined &&
      object.path_rewrite_specifier?.path_redirect !== null
    ) {
      message.path_rewrite_specifier = {
        $case: "path_redirect",
        path_redirect: object.path_rewrite_specifier.path_redirect,
      };
    }
    if (
      object.path_rewrite_specifier?.$case === "prefix_rewrite" &&
      object.path_rewrite_specifier?.prefix_rewrite !== undefined &&
      object.path_rewrite_specifier?.prefix_rewrite !== null
    ) {
      message.path_rewrite_specifier = {
        $case: "prefix_rewrite",
        prefix_rewrite: object.path_rewrite_specifier.prefix_rewrite,
      };
    }
    message.response_code = object.response_code ?? undefined;
    message.strip_query = object.strip_query ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RedirectAction.$type, RedirectAction);

function createBaseDirectResponseAction(): DirectResponseAction {
  return { $type: "envoy.api.v2.route.DirectResponseAction" };
}

export const DirectResponseAction: MessageFns<DirectResponseAction, "envoy.api.v2.route.DirectResponseAction"> = {
  $type: "envoy.api.v2.route.DirectResponseAction" as const,

  encode(message: DirectResponseAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined && message.status !== 0) {
      writer.uint32(8).uint32(message.status);
    }
    if (message.body !== undefined) {
      DataSource.encode(message.body, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DirectResponseAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDirectResponseAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.body = DataSource.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DirectResponseAction {
    return {
      $type: DirectResponseAction.$type,
      status: isSet(object.status) ? globalThis.Number(object.status) : undefined,
      body: isSet(object.body) ? DataSource.fromJSON(object.body) : undefined,
    };
  },

  toJSON(message: DirectResponseAction): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Math.round(message.status);
    }
    if (message.body !== undefined) {
      obj.body = DataSource.toJSON(message.body);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DirectResponseAction>, I>>(base?: I): DirectResponseAction {
    return DirectResponseAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DirectResponseAction>, I>>(object: I): DirectResponseAction {
    const message = createBaseDirectResponseAction();
    message.status = object.status ?? undefined;
    message.body = (object.body !== undefined && object.body !== null)
      ? DataSource.fromPartial(object.body)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(DirectResponseAction.$type, DirectResponseAction);

function createBaseDecorator(): Decorator {
  return { $type: "envoy.api.v2.route.Decorator" };
}

export const Decorator: MessageFns<Decorator, "envoy.api.v2.route.Decorator"> = {
  $type: "envoy.api.v2.route.Decorator" as const,

  encode(message: Decorator, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operation !== undefined && message.operation !== "") {
      writer.uint32(10).string(message.operation);
    }
    if (message.propagate !== undefined) {
      BoolValue.encode({ $type: "google.protobuf.BoolValue", value: message.propagate! }, writer.uint32(18).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Decorator {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecorator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.operation = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.propagate = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Decorator {
    return {
      $type: Decorator.$type,
      operation: isSet(object.operation) ? globalThis.String(object.operation) : undefined,
      propagate: isSet(object.propagate) ? Boolean(object.propagate) : undefined,
    };
  },

  toJSON(message: Decorator): unknown {
    const obj: any = {};
    if (message.operation !== undefined) {
      obj.operation = message.operation;
    }
    if (message.propagate !== undefined) {
      obj.propagate = message.propagate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Decorator>, I>>(base?: I): Decorator {
    return Decorator.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Decorator>, I>>(object: I): Decorator {
    const message = createBaseDecorator();
    message.operation = object.operation ?? undefined;
    message.propagate = object.propagate ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Decorator.$type, Decorator);

function createBaseTracing(): Tracing {
  return { $type: "envoy.api.v2.route.Tracing" };
}

export const Tracing: MessageFns<Tracing, "envoy.api.v2.route.Tracing"> = {
  $type: "envoy.api.v2.route.Tracing" as const,

  encode(message: Tracing, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.client_sampling !== undefined) {
      FractionalPercent.encode(message.client_sampling, writer.uint32(10).fork()).join();
    }
    if (message.random_sampling !== undefined) {
      FractionalPercent.encode(message.random_sampling, writer.uint32(18).fork()).join();
    }
    if (message.overall_sampling !== undefined) {
      FractionalPercent.encode(message.overall_sampling, writer.uint32(26).fork()).join();
    }
    if (message.custom_tags !== undefined && message.custom_tags.length !== 0) {
      for (const v of message.custom_tags) {
        CustomTag.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Tracing {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTracing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.client_sampling = FractionalPercent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.random_sampling = FractionalPercent.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.overall_sampling = FractionalPercent.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          if (message.custom_tags === undefined) {
            message.custom_tags = [];
          }
          const el = CustomTag.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.custom_tags!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Tracing {
    return {
      $type: Tracing.$type,
      client_sampling: isSet(object.client_sampling) ? FractionalPercent.fromJSON(object.client_sampling) : undefined,
      random_sampling: isSet(object.random_sampling) ? FractionalPercent.fromJSON(object.random_sampling) : undefined,
      overall_sampling: isSet(object.overall_sampling)
        ? FractionalPercent.fromJSON(object.overall_sampling)
        : undefined,
      custom_tags: globalThis.Array.isArray(object?.custom_tags)
        ? object.custom_tags.map((e: any) => CustomTag.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: Tracing): unknown {
    const obj: any = {};
    if (message.client_sampling !== undefined) {
      obj.client_sampling = FractionalPercent.toJSON(message.client_sampling);
    }
    if (message.random_sampling !== undefined) {
      obj.random_sampling = FractionalPercent.toJSON(message.random_sampling);
    }
    if (message.overall_sampling !== undefined) {
      obj.overall_sampling = FractionalPercent.toJSON(message.overall_sampling);
    }
    if (message.custom_tags?.length) {
      obj.custom_tags = message.custom_tags.map((e) => CustomTag.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Tracing>, I>>(base?: I): Tracing {
    return Tracing.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Tracing>, I>>(object: I): Tracing {
    const message = createBaseTracing();
    message.client_sampling = (object.client_sampling !== undefined && object.client_sampling !== null)
      ? FractionalPercent.fromPartial(object.client_sampling)
      : undefined;
    message.random_sampling = (object.random_sampling !== undefined && object.random_sampling !== null)
      ? FractionalPercent.fromPartial(object.random_sampling)
      : undefined;
    message.overall_sampling = (object.overall_sampling !== undefined && object.overall_sampling !== null)
      ? FractionalPercent.fromPartial(object.overall_sampling)
      : undefined;
    message.custom_tags = object.custom_tags?.map((e) => CustomTag.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(Tracing.$type, Tracing);

function createBaseVirtualCluster(): VirtualCluster {
  return { $type: "envoy.api.v2.route.VirtualCluster" };
}

export const VirtualCluster: MessageFns<VirtualCluster, "envoy.api.v2.route.VirtualCluster"> = {
  $type: "envoy.api.v2.route.VirtualCluster" as const,

  encode(message: VirtualCluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pattern !== undefined && message.pattern !== "") {
      writer.uint32(10).string(message.pattern);
    }
    if (message.headers !== undefined && message.headers.length !== 0) {
      for (const v of message.headers) {
        HeaderMatcher.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.method !== undefined && message.method !== RequestMethod.METHOD_UNSPECIFIED) {
      writer.uint32(24).int32(requestMethodToNumber(message.method));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VirtualCluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVirtualCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pattern = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          if (message.headers === undefined) {
            message.headers = [];
          }
          const el = HeaderMatcher.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.headers!.push(el);
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.method = requestMethodFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VirtualCluster {
    return {
      $type: VirtualCluster.$type,
      pattern: isSet(object.pattern) ? globalThis.String(object.pattern) : undefined,
      headers: globalThis.Array.isArray(object?.headers)
        ? object.headers.map((e: any) => HeaderMatcher.fromJSON(e))
        : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      method: isSet(object.method) ? requestMethodFromJSON(object.method) : undefined,
    };
  },

  toJSON(message: VirtualCluster): unknown {
    const obj: any = {};
    if (message.pattern !== undefined) {
      obj.pattern = message.pattern;
    }
    if (message.headers?.length) {
      obj.headers = message.headers.map((e) => HeaderMatcher.toJSON(e));
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.method !== undefined) {
      obj.method = requestMethodToJSON(message.method);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VirtualCluster>, I>>(base?: I): VirtualCluster {
    return VirtualCluster.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VirtualCluster>, I>>(object: I): VirtualCluster {
    const message = createBaseVirtualCluster();
    message.pattern = object.pattern ?? undefined;
    message.headers = object.headers?.map((e) => HeaderMatcher.fromPartial(e)) || undefined;
    message.name = object.name ?? undefined;
    message.method = object.method ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(VirtualCluster.$type, VirtualCluster);

function createBaseRateLimit(): RateLimit {
  return { $type: "envoy.api.v2.route.RateLimit" };
}

export const RateLimit: MessageFns<RateLimit, "envoy.api.v2.route.RateLimit"> = {
  $type: "envoy.api.v2.route.RateLimit" as const,

  encode(message: RateLimit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stage !== undefined) {
      UInt32Value.encode({ $type: "google.protobuf.UInt32Value", value: message.stage! }, writer.uint32(10).fork())
        .join();
    }
    if (message.disable_key !== undefined && message.disable_key !== "") {
      writer.uint32(18).string(message.disable_key);
    }
    if (message.actions !== undefined && message.actions.length !== 0) {
      for (const v of message.actions) {
        RateLimit_Action.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stage = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.disable_key = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.actions === undefined) {
            message.actions = [];
          }
          const el = RateLimit_Action.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.actions!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimit {
    return {
      $type: RateLimit.$type,
      stage: isSet(object.stage) ? Number(object.stage) : undefined,
      disable_key: isSet(object.disable_key) ? globalThis.String(object.disable_key) : undefined,
      actions: globalThis.Array.isArray(object?.actions)
        ? object.actions.map((e: any) => RateLimit_Action.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: RateLimit): unknown {
    const obj: any = {};
    if (message.stage !== undefined) {
      obj.stage = message.stage;
    }
    if (message.disable_key !== undefined) {
      obj.disable_key = message.disable_key;
    }
    if (message.actions?.length) {
      obj.actions = message.actions.map((e) => RateLimit_Action.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimit>, I>>(base?: I): RateLimit {
    return RateLimit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimit>, I>>(object: I): RateLimit {
    const message = createBaseRateLimit();
    message.stage = object.stage ?? undefined;
    message.disable_key = object.disable_key ?? undefined;
    message.actions = object.actions?.map((e) => RateLimit_Action.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(RateLimit.$type, RateLimit);

function createBaseRateLimit_Action(): RateLimit_Action {
  return { $type: "envoy.api.v2.route.RateLimit.Action", action_specifier: undefined };
}

export const RateLimit_Action: MessageFns<RateLimit_Action, "envoy.api.v2.route.RateLimit.Action"> = {
  $type: "envoy.api.v2.route.RateLimit.Action" as const,

  encode(message: RateLimit_Action, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.action_specifier?.$case) {
      case "source_cluster":
        RateLimit_Action_SourceCluster.encode(message.action_specifier.source_cluster, writer.uint32(10).fork()).join();
        break;
      case "destination_cluster":
        RateLimit_Action_DestinationCluster.encode(
          message.action_specifier.destination_cluster,
          writer.uint32(18).fork(),
        ).join();
        break;
      case "request_headers":
        RateLimit_Action_RequestHeaders.encode(message.action_specifier.request_headers, writer.uint32(26).fork())
          .join();
        break;
      case "remote_address":
        RateLimit_Action_RemoteAddress.encode(message.action_specifier.remote_address, writer.uint32(34).fork()).join();
        break;
      case "generic_key":
        RateLimit_Action_GenericKey.encode(message.action_specifier.generic_key, writer.uint32(42).fork()).join();
        break;
      case "header_value_match":
        RateLimit_Action_HeaderValueMatch.encode(message.action_specifier.header_value_match, writer.uint32(50).fork())
          .join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimit_Action {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimit_Action();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.action_specifier = {
            $case: "source_cluster",
            source_cluster: RateLimit_Action_SourceCluster.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.action_specifier = {
            $case: "destination_cluster",
            destination_cluster: RateLimit_Action_DestinationCluster.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.action_specifier = {
            $case: "request_headers",
            request_headers: RateLimit_Action_RequestHeaders.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.action_specifier = {
            $case: "remote_address",
            remote_address: RateLimit_Action_RemoteAddress.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.action_specifier = {
            $case: "generic_key",
            generic_key: RateLimit_Action_GenericKey.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.action_specifier = {
            $case: "header_value_match",
            header_value_match: RateLimit_Action_HeaderValueMatch.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimit_Action {
    return {
      $type: RateLimit_Action.$type,
      action_specifier: isSet(object.source_cluster)
        ? { $case: "source_cluster", source_cluster: RateLimit_Action_SourceCluster.fromJSON(object.source_cluster) }
        : isSet(object.destination_cluster)
        ? {
          $case: "destination_cluster",
          destination_cluster: RateLimit_Action_DestinationCluster.fromJSON(object.destination_cluster),
        }
        : isSet(object.request_headers)
        ? {
          $case: "request_headers",
          request_headers: RateLimit_Action_RequestHeaders.fromJSON(object.request_headers),
        }
        : isSet(object.remote_address)
        ? { $case: "remote_address", remote_address: RateLimit_Action_RemoteAddress.fromJSON(object.remote_address) }
        : isSet(object.generic_key)
        ? { $case: "generic_key", generic_key: RateLimit_Action_GenericKey.fromJSON(object.generic_key) }
        : isSet(object.header_value_match)
        ? {
          $case: "header_value_match",
          header_value_match: RateLimit_Action_HeaderValueMatch.fromJSON(object.header_value_match),
        }
        : undefined,
    };
  },

  toJSON(message: RateLimit_Action): unknown {
    const obj: any = {};
    if (message.action_specifier?.$case === "source_cluster") {
      obj.source_cluster = RateLimit_Action_SourceCluster.toJSON(message.action_specifier.source_cluster);
    }
    if (message.action_specifier?.$case === "destination_cluster") {
      obj.destination_cluster = RateLimit_Action_DestinationCluster.toJSON(
        message.action_specifier.destination_cluster,
      );
    }
    if (message.action_specifier?.$case === "request_headers") {
      obj.request_headers = RateLimit_Action_RequestHeaders.toJSON(message.action_specifier.request_headers);
    }
    if (message.action_specifier?.$case === "remote_address") {
      obj.remote_address = RateLimit_Action_RemoteAddress.toJSON(message.action_specifier.remote_address);
    }
    if (message.action_specifier?.$case === "generic_key") {
      obj.generic_key = RateLimit_Action_GenericKey.toJSON(message.action_specifier.generic_key);
    }
    if (message.action_specifier?.$case === "header_value_match") {
      obj.header_value_match = RateLimit_Action_HeaderValueMatch.toJSON(message.action_specifier.header_value_match);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimit_Action>, I>>(base?: I): RateLimit_Action {
    return RateLimit_Action.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimit_Action>, I>>(object: I): RateLimit_Action {
    const message = createBaseRateLimit_Action();
    if (
      object.action_specifier?.$case === "source_cluster" &&
      object.action_specifier?.source_cluster !== undefined &&
      object.action_specifier?.source_cluster !== null
    ) {
      message.action_specifier = {
        $case: "source_cluster",
        source_cluster: RateLimit_Action_SourceCluster.fromPartial(object.action_specifier.source_cluster),
      };
    }
    if (
      object.action_specifier?.$case === "destination_cluster" &&
      object.action_specifier?.destination_cluster !== undefined &&
      object.action_specifier?.destination_cluster !== null
    ) {
      message.action_specifier = {
        $case: "destination_cluster",
        destination_cluster: RateLimit_Action_DestinationCluster.fromPartial(
          object.action_specifier.destination_cluster,
        ),
      };
    }
    if (
      object.action_specifier?.$case === "request_headers" &&
      object.action_specifier?.request_headers !== undefined &&
      object.action_specifier?.request_headers !== null
    ) {
      message.action_specifier = {
        $case: "request_headers",
        request_headers: RateLimit_Action_RequestHeaders.fromPartial(object.action_specifier.request_headers),
      };
    }
    if (
      object.action_specifier?.$case === "remote_address" &&
      object.action_specifier?.remote_address !== undefined &&
      object.action_specifier?.remote_address !== null
    ) {
      message.action_specifier = {
        $case: "remote_address",
        remote_address: RateLimit_Action_RemoteAddress.fromPartial(object.action_specifier.remote_address),
      };
    }
    if (
      object.action_specifier?.$case === "generic_key" &&
      object.action_specifier?.generic_key !== undefined &&
      object.action_specifier?.generic_key !== null
    ) {
      message.action_specifier = {
        $case: "generic_key",
        generic_key: RateLimit_Action_GenericKey.fromPartial(object.action_specifier.generic_key),
      };
    }
    if (
      object.action_specifier?.$case === "header_value_match" &&
      object.action_specifier?.header_value_match !== undefined &&
      object.action_specifier?.header_value_match !== null
    ) {
      message.action_specifier = {
        $case: "header_value_match",
        header_value_match: RateLimit_Action_HeaderValueMatch.fromPartial(object.action_specifier.header_value_match),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(RateLimit_Action.$type, RateLimit_Action);

function createBaseRateLimit_Action_SourceCluster(): RateLimit_Action_SourceCluster {
  return { $type: "envoy.api.v2.route.RateLimit.Action.SourceCluster" };
}

export const RateLimit_Action_SourceCluster: MessageFns<
  RateLimit_Action_SourceCluster,
  "envoy.api.v2.route.RateLimit.Action.SourceCluster"
> = {
  $type: "envoy.api.v2.route.RateLimit.Action.SourceCluster" as const,

  encode(_: RateLimit_Action_SourceCluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimit_Action_SourceCluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimit_Action_SourceCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RateLimit_Action_SourceCluster {
    return { $type: RateLimit_Action_SourceCluster.$type };
  },

  toJSON(_: RateLimit_Action_SourceCluster): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimit_Action_SourceCluster>, I>>(base?: I): RateLimit_Action_SourceCluster {
    return RateLimit_Action_SourceCluster.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimit_Action_SourceCluster>, I>>(_: I): RateLimit_Action_SourceCluster {
    const message = createBaseRateLimit_Action_SourceCluster();
    return message;
  },
};

messageTypeRegistry.set(RateLimit_Action_SourceCluster.$type, RateLimit_Action_SourceCluster);

function createBaseRateLimit_Action_DestinationCluster(): RateLimit_Action_DestinationCluster {
  return { $type: "envoy.api.v2.route.RateLimit.Action.DestinationCluster" };
}

export const RateLimit_Action_DestinationCluster: MessageFns<
  RateLimit_Action_DestinationCluster,
  "envoy.api.v2.route.RateLimit.Action.DestinationCluster"
> = {
  $type: "envoy.api.v2.route.RateLimit.Action.DestinationCluster" as const,

  encode(_: RateLimit_Action_DestinationCluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimit_Action_DestinationCluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimit_Action_DestinationCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RateLimit_Action_DestinationCluster {
    return { $type: RateLimit_Action_DestinationCluster.$type };
  },

  toJSON(_: RateLimit_Action_DestinationCluster): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimit_Action_DestinationCluster>, I>>(
    base?: I,
  ): RateLimit_Action_DestinationCluster {
    return RateLimit_Action_DestinationCluster.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimit_Action_DestinationCluster>, I>>(
    _: I,
  ): RateLimit_Action_DestinationCluster {
    const message = createBaseRateLimit_Action_DestinationCluster();
    return message;
  },
};

messageTypeRegistry.set(RateLimit_Action_DestinationCluster.$type, RateLimit_Action_DestinationCluster);

function createBaseRateLimit_Action_RequestHeaders(): RateLimit_Action_RequestHeaders {
  return { $type: "envoy.api.v2.route.RateLimit.Action.RequestHeaders" };
}

export const RateLimit_Action_RequestHeaders: MessageFns<
  RateLimit_Action_RequestHeaders,
  "envoy.api.v2.route.RateLimit.Action.RequestHeaders"
> = {
  $type: "envoy.api.v2.route.RateLimit.Action.RequestHeaders" as const,

  encode(message: RateLimit_Action_RequestHeaders, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header_name !== undefined && message.header_name !== "") {
      writer.uint32(10).string(message.header_name);
    }
    if (message.descriptor_key !== undefined && message.descriptor_key !== "") {
      writer.uint32(18).string(message.descriptor_key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimit_Action_RequestHeaders {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimit_Action_RequestHeaders();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header_name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.descriptor_key = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimit_Action_RequestHeaders {
    return {
      $type: RateLimit_Action_RequestHeaders.$type,
      header_name: isSet(object.header_name) ? globalThis.String(object.header_name) : undefined,
      descriptor_key: isSet(object.descriptor_key) ? globalThis.String(object.descriptor_key) : undefined,
    };
  },

  toJSON(message: RateLimit_Action_RequestHeaders): unknown {
    const obj: any = {};
    if (message.header_name !== undefined) {
      obj.header_name = message.header_name;
    }
    if (message.descriptor_key !== undefined) {
      obj.descriptor_key = message.descriptor_key;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimit_Action_RequestHeaders>, I>>(base?: I): RateLimit_Action_RequestHeaders {
    return RateLimit_Action_RequestHeaders.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimit_Action_RequestHeaders>, I>>(
    object: I,
  ): RateLimit_Action_RequestHeaders {
    const message = createBaseRateLimit_Action_RequestHeaders();
    message.header_name = object.header_name ?? undefined;
    message.descriptor_key = object.descriptor_key ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RateLimit_Action_RequestHeaders.$type, RateLimit_Action_RequestHeaders);

function createBaseRateLimit_Action_RemoteAddress(): RateLimit_Action_RemoteAddress {
  return { $type: "envoy.api.v2.route.RateLimit.Action.RemoteAddress" };
}

export const RateLimit_Action_RemoteAddress: MessageFns<
  RateLimit_Action_RemoteAddress,
  "envoy.api.v2.route.RateLimit.Action.RemoteAddress"
> = {
  $type: "envoy.api.v2.route.RateLimit.Action.RemoteAddress" as const,

  encode(_: RateLimit_Action_RemoteAddress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimit_Action_RemoteAddress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimit_Action_RemoteAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RateLimit_Action_RemoteAddress {
    return { $type: RateLimit_Action_RemoteAddress.$type };
  },

  toJSON(_: RateLimit_Action_RemoteAddress): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimit_Action_RemoteAddress>, I>>(base?: I): RateLimit_Action_RemoteAddress {
    return RateLimit_Action_RemoteAddress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimit_Action_RemoteAddress>, I>>(_: I): RateLimit_Action_RemoteAddress {
    const message = createBaseRateLimit_Action_RemoteAddress();
    return message;
  },
};

messageTypeRegistry.set(RateLimit_Action_RemoteAddress.$type, RateLimit_Action_RemoteAddress);

function createBaseRateLimit_Action_GenericKey(): RateLimit_Action_GenericKey {
  return { $type: "envoy.api.v2.route.RateLimit.Action.GenericKey" };
}

export const RateLimit_Action_GenericKey: MessageFns<
  RateLimit_Action_GenericKey,
  "envoy.api.v2.route.RateLimit.Action.GenericKey"
> = {
  $type: "envoy.api.v2.route.RateLimit.Action.GenericKey" as const,

  encode(message: RateLimit_Action_GenericKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.descriptor_value !== undefined && message.descriptor_value !== "") {
      writer.uint32(10).string(message.descriptor_value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimit_Action_GenericKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimit_Action_GenericKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.descriptor_value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimit_Action_GenericKey {
    return {
      $type: RateLimit_Action_GenericKey.$type,
      descriptor_value: isSet(object.descriptor_value) ? globalThis.String(object.descriptor_value) : undefined,
    };
  },

  toJSON(message: RateLimit_Action_GenericKey): unknown {
    const obj: any = {};
    if (message.descriptor_value !== undefined) {
      obj.descriptor_value = message.descriptor_value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimit_Action_GenericKey>, I>>(base?: I): RateLimit_Action_GenericKey {
    return RateLimit_Action_GenericKey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimit_Action_GenericKey>, I>>(object: I): RateLimit_Action_GenericKey {
    const message = createBaseRateLimit_Action_GenericKey();
    message.descriptor_value = object.descriptor_value ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RateLimit_Action_GenericKey.$type, RateLimit_Action_GenericKey);

function createBaseRateLimit_Action_HeaderValueMatch(): RateLimit_Action_HeaderValueMatch {
  return { $type: "envoy.api.v2.route.RateLimit.Action.HeaderValueMatch" };
}

export const RateLimit_Action_HeaderValueMatch: MessageFns<
  RateLimit_Action_HeaderValueMatch,
  "envoy.api.v2.route.RateLimit.Action.HeaderValueMatch"
> = {
  $type: "envoy.api.v2.route.RateLimit.Action.HeaderValueMatch" as const,

  encode(message: RateLimit_Action_HeaderValueMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.descriptor_value !== undefined && message.descriptor_value !== "") {
      writer.uint32(10).string(message.descriptor_value);
    }
    if (message.expect_match !== undefined) {
      BoolValue.encode({ $type: "google.protobuf.BoolValue", value: message.expect_match! }, writer.uint32(18).fork())
        .join();
    }
    if (message.headers !== undefined && message.headers.length !== 0) {
      for (const v of message.headers) {
        HeaderMatcher.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimit_Action_HeaderValueMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimit_Action_HeaderValueMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.descriptor_value = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.expect_match = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.headers === undefined) {
            message.headers = [];
          }
          const el = HeaderMatcher.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.headers!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimit_Action_HeaderValueMatch {
    return {
      $type: RateLimit_Action_HeaderValueMatch.$type,
      descriptor_value: isSet(object.descriptor_value) ? globalThis.String(object.descriptor_value) : undefined,
      expect_match: isSet(object.expect_match) ? Boolean(object.expect_match) : undefined,
      headers: globalThis.Array.isArray(object?.headers)
        ? object.headers.map((e: any) => HeaderMatcher.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: RateLimit_Action_HeaderValueMatch): unknown {
    const obj: any = {};
    if (message.descriptor_value !== undefined) {
      obj.descriptor_value = message.descriptor_value;
    }
    if (message.expect_match !== undefined) {
      obj.expect_match = message.expect_match;
    }
    if (message.headers?.length) {
      obj.headers = message.headers.map((e) => HeaderMatcher.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimit_Action_HeaderValueMatch>, I>>(
    base?: I,
  ): RateLimit_Action_HeaderValueMatch {
    return RateLimit_Action_HeaderValueMatch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimit_Action_HeaderValueMatch>, I>>(
    object: I,
  ): RateLimit_Action_HeaderValueMatch {
    const message = createBaseRateLimit_Action_HeaderValueMatch();
    message.descriptor_value = object.descriptor_value ?? undefined;
    message.expect_match = object.expect_match ?? undefined;
    message.headers = object.headers?.map((e) => HeaderMatcher.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(RateLimit_Action_HeaderValueMatch.$type, RateLimit_Action_HeaderValueMatch);

function createBaseHeaderMatcher(): HeaderMatcher {
  return { $type: "envoy.api.v2.route.HeaderMatcher", header_match_specifier: undefined };
}

export const HeaderMatcher: MessageFns<HeaderMatcher, "envoy.api.v2.route.HeaderMatcher"> = {
  $type: "envoy.api.v2.route.HeaderMatcher" as const,

  encode(message: HeaderMatcher, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    switch (message.header_match_specifier?.$case) {
      case "exact_match":
        writer.uint32(34).string(message.header_match_specifier.exact_match);
        break;
      case "regex_match":
        writer.uint32(42).string(message.header_match_specifier.regex_match);
        break;
      case "safe_regex_match":
        RegexMatcher.encode(message.header_match_specifier.safe_regex_match, writer.uint32(90).fork()).join();
        break;
      case "range_match":
        Int64Range.encode(message.header_match_specifier.range_match, writer.uint32(50).fork()).join();
        break;
      case "present_match":
        writer.uint32(56).bool(message.header_match_specifier.present_match);
        break;
      case "prefix_match":
        writer.uint32(74).string(message.header_match_specifier.prefix_match);
        break;
      case "suffix_match":
        writer.uint32(82).string(message.header_match_specifier.suffix_match);
        break;
    }
    if (message.invert_match !== undefined && message.invert_match !== false) {
      writer.uint32(64).bool(message.invert_match);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeaderMatcher {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeaderMatcher();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.header_match_specifier = { $case: "exact_match", exact_match: reader.string() };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.header_match_specifier = { $case: "regex_match", regex_match: reader.string() };
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.header_match_specifier = {
            $case: "safe_regex_match",
            safe_regex_match: RegexMatcher.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.header_match_specifier = {
            $case: "range_match",
            range_match: Int64Range.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.header_match_specifier = { $case: "present_match", present_match: reader.bool() };
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.header_match_specifier = { $case: "prefix_match", prefix_match: reader.string() };
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.header_match_specifier = { $case: "suffix_match", suffix_match: reader.string() };
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.invert_match = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeaderMatcher {
    return {
      $type: HeaderMatcher.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      header_match_specifier: isSet(object.exact_match)
        ? { $case: "exact_match", exact_match: globalThis.String(object.exact_match) }
        : isSet(object.regex_match)
        ? { $case: "regex_match", regex_match: globalThis.String(object.regex_match) }
        : isSet(object.safe_regex_match)
        ? { $case: "safe_regex_match", safe_regex_match: RegexMatcher.fromJSON(object.safe_regex_match) }
        : isSet(object.range_match)
        ? { $case: "range_match", range_match: Int64Range.fromJSON(object.range_match) }
        : isSet(object.present_match)
        ? { $case: "present_match", present_match: globalThis.Boolean(object.present_match) }
        : isSet(object.prefix_match)
        ? { $case: "prefix_match", prefix_match: globalThis.String(object.prefix_match) }
        : isSet(object.suffix_match)
        ? { $case: "suffix_match", suffix_match: globalThis.String(object.suffix_match) }
        : undefined,
      invert_match: isSet(object.invert_match) ? globalThis.Boolean(object.invert_match) : undefined,
    };
  },

  toJSON(message: HeaderMatcher): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.header_match_specifier?.$case === "exact_match") {
      obj.exact_match = message.header_match_specifier.exact_match;
    }
    if (message.header_match_specifier?.$case === "regex_match") {
      obj.regex_match = message.header_match_specifier.regex_match;
    }
    if (message.header_match_specifier?.$case === "safe_regex_match") {
      obj.safe_regex_match = RegexMatcher.toJSON(message.header_match_specifier.safe_regex_match);
    }
    if (message.header_match_specifier?.$case === "range_match") {
      obj.range_match = Int64Range.toJSON(message.header_match_specifier.range_match);
    }
    if (message.header_match_specifier?.$case === "present_match") {
      obj.present_match = message.header_match_specifier.present_match;
    }
    if (message.header_match_specifier?.$case === "prefix_match") {
      obj.prefix_match = message.header_match_specifier.prefix_match;
    }
    if (message.header_match_specifier?.$case === "suffix_match") {
      obj.suffix_match = message.header_match_specifier.suffix_match;
    }
    if (message.invert_match !== undefined) {
      obj.invert_match = message.invert_match;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HeaderMatcher>, I>>(base?: I): HeaderMatcher {
    return HeaderMatcher.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HeaderMatcher>, I>>(object: I): HeaderMatcher {
    const message = createBaseHeaderMatcher();
    message.name = object.name ?? undefined;
    if (
      object.header_match_specifier?.$case === "exact_match" &&
      object.header_match_specifier?.exact_match !== undefined &&
      object.header_match_specifier?.exact_match !== null
    ) {
      message.header_match_specifier = { $case: "exact_match", exact_match: object.header_match_specifier.exact_match };
    }
    if (
      object.header_match_specifier?.$case === "regex_match" &&
      object.header_match_specifier?.regex_match !== undefined &&
      object.header_match_specifier?.regex_match !== null
    ) {
      message.header_match_specifier = { $case: "regex_match", regex_match: object.header_match_specifier.regex_match };
    }
    if (
      object.header_match_specifier?.$case === "safe_regex_match" &&
      object.header_match_specifier?.safe_regex_match !== undefined &&
      object.header_match_specifier?.safe_regex_match !== null
    ) {
      message.header_match_specifier = {
        $case: "safe_regex_match",
        safe_regex_match: RegexMatcher.fromPartial(object.header_match_specifier.safe_regex_match),
      };
    }
    if (
      object.header_match_specifier?.$case === "range_match" &&
      object.header_match_specifier?.range_match !== undefined &&
      object.header_match_specifier?.range_match !== null
    ) {
      message.header_match_specifier = {
        $case: "range_match",
        range_match: Int64Range.fromPartial(object.header_match_specifier.range_match),
      };
    }
    if (
      object.header_match_specifier?.$case === "present_match" &&
      object.header_match_specifier?.present_match !== undefined &&
      object.header_match_specifier?.present_match !== null
    ) {
      message.header_match_specifier = {
        $case: "present_match",
        present_match: object.header_match_specifier.present_match,
      };
    }
    if (
      object.header_match_specifier?.$case === "prefix_match" &&
      object.header_match_specifier?.prefix_match !== undefined &&
      object.header_match_specifier?.prefix_match !== null
    ) {
      message.header_match_specifier = {
        $case: "prefix_match",
        prefix_match: object.header_match_specifier.prefix_match,
      };
    }
    if (
      object.header_match_specifier?.$case === "suffix_match" &&
      object.header_match_specifier?.suffix_match !== undefined &&
      object.header_match_specifier?.suffix_match !== null
    ) {
      message.header_match_specifier = {
        $case: "suffix_match",
        suffix_match: object.header_match_specifier.suffix_match,
      };
    }
    message.invert_match = object.invert_match ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(HeaderMatcher.$type, HeaderMatcher);

function createBaseQueryParameterMatcher(): QueryParameterMatcher {
  return { $type: "envoy.api.v2.route.QueryParameterMatcher", query_parameter_match_specifier: undefined };
}

export const QueryParameterMatcher: MessageFns<QueryParameterMatcher, "envoy.api.v2.route.QueryParameterMatcher"> = {
  $type: "envoy.api.v2.route.QueryParameterMatcher" as const,

  encode(message: QueryParameterMatcher, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== undefined && message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    if (message.regex !== undefined) {
      BoolValue.encode({ $type: "google.protobuf.BoolValue", value: message.regex! }, writer.uint32(34).fork()).join();
    }
    switch (message.query_parameter_match_specifier?.$case) {
      case "string_match":
        StringMatcher.encode(message.query_parameter_match_specifier.string_match, writer.uint32(42).fork()).join();
        break;
      case "present_match":
        writer.uint32(48).bool(message.query_parameter_match_specifier.present_match);
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryParameterMatcher {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParameterMatcher();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.regex = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.query_parameter_match_specifier = {
            $case: "string_match",
            string_match: StringMatcher.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.query_parameter_match_specifier = { $case: "present_match", present_match: reader.bool() };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryParameterMatcher {
    return {
      $type: QueryParameterMatcher.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      value: isSet(object.value) ? globalThis.String(object.value) : undefined,
      regex: isSet(object.regex) ? Boolean(object.regex) : undefined,
      query_parameter_match_specifier: isSet(object.string_match)
        ? { $case: "string_match", string_match: StringMatcher.fromJSON(object.string_match) }
        : isSet(object.present_match)
        ? { $case: "present_match", present_match: globalThis.Boolean(object.present_match) }
        : undefined,
    };
  },

  toJSON(message: QueryParameterMatcher): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    if (message.regex !== undefined) {
      obj.regex = message.regex;
    }
    if (message.query_parameter_match_specifier?.$case === "string_match") {
      obj.string_match = StringMatcher.toJSON(message.query_parameter_match_specifier.string_match);
    }
    if (message.query_parameter_match_specifier?.$case === "present_match") {
      obj.present_match = message.query_parameter_match_specifier.present_match;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParameterMatcher>, I>>(base?: I): QueryParameterMatcher {
    return QueryParameterMatcher.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParameterMatcher>, I>>(object: I): QueryParameterMatcher {
    const message = createBaseQueryParameterMatcher();
    message.name = object.name ?? undefined;
    message.value = object.value ?? undefined;
    message.regex = object.regex ?? undefined;
    if (
      object.query_parameter_match_specifier?.$case === "string_match" &&
      object.query_parameter_match_specifier?.string_match !== undefined &&
      object.query_parameter_match_specifier?.string_match !== null
    ) {
      message.query_parameter_match_specifier = {
        $case: "string_match",
        string_match: StringMatcher.fromPartial(object.query_parameter_match_specifier.string_match),
      };
    }
    if (
      object.query_parameter_match_specifier?.$case === "present_match" &&
      object.query_parameter_match_specifier?.present_match !== undefined &&
      object.query_parameter_match_specifier?.present_match !== null
    ) {
      message.query_parameter_match_specifier = {
        $case: "present_match",
        present_match: object.query_parameter_match_specifier.present_match,
      };
    }
    return message;
  },
};

messageTypeRegistry.set(QueryParameterMatcher.$type, QueryParameterMatcher);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
