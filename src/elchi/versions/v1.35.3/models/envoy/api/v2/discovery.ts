// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/api/v2/discovery.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Any } from "../../../google/protobuf/any";
import { Status } from "../../../google/rpc/status";
import { messageTypeRegistry } from "../../../typeRegistry";
import { ControlPlane, Node } from "./core/base";

export const protobufPackage = "envoy.api.v2";

/**
 * A DiscoveryRequest requests a set of versioned resources of the same type for
 * a given Envoy node on some API.
 * [#next-free-field: 7]
 */
export interface DiscoveryRequest {
  $type: "envoy.api.v2.DiscoveryRequest";
  /**
   * The version_info provided in the request messages will be the version_info
   * received with the most recent successfully processed response or empty on
   * the first request. It is expected that no new request is sent after a
   * response is received until the Envoy instance is ready to ACK/NACK the new
   * configuration. ACK/NACK takes place by returning the new API config version
   * as applied or the previous API config version respectively. Each type_url
   * (see below) has an independent version associated with it.
   */
  version_info?:
    | string
    | undefined;
  /** The node making the request. */
  node?:
    | Node
    | undefined;
  /**
   * List of resources to subscribe to, e.g. list of cluster names or a route
   * configuration name. If this is empty, all resources for the API are
   * returned. LDS/CDS may have empty resource_names, which will cause all
   * resources for the Envoy instance to be returned. The LDS and CDS responses
   * will then imply a number of resources that need to be fetched via EDS/RDS,
   * which will be explicitly enumerated in resource_names.
   */
  resource_names?:
    | string[]
    | undefined;
  /**
   * Type of the resource that is being requested, e.g.
   * "type.googleapis.com/envoy.api.v2.ClusterLoadAssignment". This is implicit
   * in requests made via singleton xDS APIs such as CDS, LDS, etc. but is
   * required for ADS.
   */
  type_url?:
    | string
    | undefined;
  /**
   * nonce corresponding to DiscoveryResponse being ACK/NACKed. See above
   * discussion on version_info and the DiscoveryResponse nonce comment. This
   * may be empty only if 1) this is a non-persistent-stream xDS such as HTTP,
   * or 2) the client has not yet accepted an update in this xDS stream (unlike
   * delta, where it is populated only for new explicit ACKs).
   */
  response_nonce?:
    | string
    | undefined;
  /**
   * This is populated when the previous :ref:`DiscoveryResponse <envoy_api_msg_DiscoveryResponse>`
   * failed to update configuration. The *message* field in *error_details* provides the Envoy
   * internal exception related to the failure. It is only intended for consumption during manual
   * debugging, the string provided is not guaranteed to be stable across Envoy versions.
   */
  error_detail?: Status | undefined;
}

/** [#next-free-field: 7] */
export interface DiscoveryResponse {
  $type: "envoy.api.v2.DiscoveryResponse";
  /** The version of the response data. */
  version_info?:
    | string
    | undefined;
  /** The response resources. These resources are typed and depend on the API being called. */
  resources?:
    | Any[]
    | undefined;
  /**
   * [#not-implemented-hide:]
   * Canary is used to support two Envoy command line flags:
   *
   * * --terminate-on-canary-transition-failure. When set, Envoy is able to
   *   terminate if it detects that configuration is stuck at canary. Consider
   *   this example sequence of updates:
   *   - Management server applies a canary config successfully.
   *   - Management server rolls back to a production config.
   *   - Envoy rejects the new production config.
   *   Since there is no sensible way to continue receiving configuration
   *   updates, Envoy will then terminate and apply production config from a
   *   clean slate.
   * * --dry-run-canary. When set, a canary response will never be applied, only
   *   validated via a dry run.
   */
  canary?:
    | boolean
    | undefined;
  /**
   * Type URL for resources. Identifies the xDS API when muxing over ADS.
   * Must be consistent with the type_url in the 'resources' repeated Any (if non-empty).
   */
  type_url?:
    | string
    | undefined;
  /**
   * For gRPC based subscriptions, the nonce provides a way to explicitly ack a
   * specific DiscoveryResponse in a following DiscoveryRequest. Additional
   * messages may have been sent by Envoy to the management server for the
   * previous version on the stream prior to this DiscoveryResponse, that were
   * unprocessed at response send time. The nonce allows the management server
   * to ignore any further DiscoveryRequests for the previous version until a
   * DiscoveryRequest bearing the nonce. The nonce is optional and is not
   * required for non-stream based xDS implementations.
   */
  nonce?:
    | string
    | undefined;
  /**
   * [#not-implemented-hide:]
   * The control plane instance that sent the response.
   */
  control_plane?: ControlPlane | undefined;
}

/**
 * DeltaDiscoveryRequest and DeltaDiscoveryResponse are used in a new gRPC
 * endpoint for Delta xDS.
 *
 * With Delta xDS, the DeltaDiscoveryResponses do not need to include a full
 * snapshot of the tracked resources. Instead, DeltaDiscoveryResponses are a
 * diff to the state of a xDS client.
 * In Delta XDS there are per-resource versions, which allow tracking state at
 * the resource granularity.
 * An xDS Delta session is always in the context of a gRPC bidirectional
 * stream. This allows the xDS server to keep track of the state of xDS clients
 * connected to it.
 *
 * In Delta xDS the nonce field is required and used to pair
 * DeltaDiscoveryResponse to a DeltaDiscoveryRequest ACK or NACK.
 * Optionally, a response message level system_version_info is present for
 * debugging purposes only.
 *
 * DeltaDiscoveryRequest plays two independent roles. Any DeltaDiscoveryRequest
 * can be either or both of: [1] informing the server of what resources the
 * client has gained/lost interest in (using resource_names_subscribe and
 * resource_names_unsubscribe), or [2] (N)ACKing an earlier resource update from
 * the server (using response_nonce, with presence of error_detail making it a NACK).
 * Additionally, the first message (for a given type_url) of a reconnected gRPC stream
 * has a third role: informing the server of the resources (and their versions)
 * that the client already possesses, using the initial_resource_versions field.
 *
 * As with state-of-the-world, when multiple resource types are multiplexed (ADS),
 * all requests/acknowledgments/updates are logically walled off by type_url:
 * a Cluster ACK exists in a completely separate world from a prior Route NACK.
 * In particular, initial_resource_versions being sent at the "start" of every
 * gRPC stream actually entails a message for each type_url, each with its own
 * initial_resource_versions.
 * [#next-free-field: 8]
 */
export interface DeltaDiscoveryRequest {
  $type: "envoy.api.v2.DeltaDiscoveryRequest";
  /** The node making the request. */
  node?:
    | Node
    | undefined;
  /**
   * Type of the resource that is being requested, e.g.
   * "type.googleapis.com/envoy.api.v2.ClusterLoadAssignment".
   */
  type_url?:
    | string
    | undefined;
  /**
   * DeltaDiscoveryRequests allow the client to add or remove individual
   * resources to the set of tracked resources in the context of a stream.
   * All resource names in the resource_names_subscribe list are added to the
   * set of tracked resources and all resource names in the resource_names_unsubscribe
   * list are removed from the set of tracked resources.
   *
   * *Unlike* state-of-the-world xDS, an empty resource_names_subscribe or
   * resource_names_unsubscribe list simply means that no resources are to be
   * added or removed to the resource list.
   * *Like* state-of-the-world xDS, the server must send updates for all tracked
   * resources, but can also send updates for resources the client has not subscribed to.
   *
   * NOTE: the server must respond with all resources listed in resource_names_subscribe,
   * even if it believes the client has the most recent version of them. The reason:
   * the client may have dropped them, but then regained interest before it had a chance
   * to send the unsubscribe message. See DeltaSubscriptionStateTest.RemoveThenAdd.
   *
   * These two fields can be set in any DeltaDiscoveryRequest, including ACKs
   * and initial_resource_versions.
   *
   * A list of Resource names to add to the list of tracked resources.
   */
  resource_names_subscribe?:
    | string[]
    | undefined;
  /** A list of Resource names to remove from the list of tracked resources. */
  resource_names_unsubscribe?:
    | string[]
    | undefined;
  /**
   * Informs the server of the versions of the resources the xDS client knows of, to enable the
   * client to continue the same logical xDS session even in the face of gRPC stream reconnection.
   * It will not be populated: [1] in the very first stream of a session, since the client will
   * not yet have any resources,  [2] in any message after the first in a stream (for a given
   * type_url), since the server will already be correctly tracking the client's state.
   * (In ADS, the first message *of each type_url* of a reconnected stream populates this map.)
   * The map's keys are names of xDS resources known to the xDS client.
   * The map's values are opaque resource versions.
   */
  initial_resource_versions?:
    | Map<string, string>
    | undefined;
  /**
   * When the DeltaDiscoveryRequest is a ACK or NACK message in response
   * to a previous DeltaDiscoveryResponse, the response_nonce must be the
   * nonce in the DeltaDiscoveryResponse.
   * Otherwise (unlike in DiscoveryRequest) response_nonce must be omitted.
   */
  response_nonce?:
    | string
    | undefined;
  /**
   * This is populated when the previous :ref:`DiscoveryResponse <envoy_api_msg_DiscoveryResponse>`
   * failed to update configuration. The *message* field in *error_details*
   * provides the Envoy internal exception related to the failure.
   */
  error_detail?: Status | undefined;
}

export interface DeltaDiscoveryRequest_InitialResourceVersionsEntry {
  $type: "envoy.api.v2.DeltaDiscoveryRequest.InitialResourceVersionsEntry";
  key: string;
  value: string;
}

/** [#next-free-field: 7] */
export interface DeltaDiscoveryResponse {
  $type: "envoy.api.v2.DeltaDiscoveryResponse";
  /** The version of the response data (used for debugging). */
  system_version_info?:
    | string
    | undefined;
  /**
   * The response resources. These are typed resources, whose types must match
   * the type_url field.
   */
  resources?:
    | Resource[]
    | undefined;
  /**
   * Type URL for resources. Identifies the xDS API when muxing over ADS.
   * Must be consistent with the type_url in the Any within 'resources' if 'resources' is non-empty.
   */
  type_url?:
    | string
    | undefined;
  /**
   * Resources names of resources that have be deleted and to be removed from the xDS Client.
   * Removed resources for missing resources can be ignored.
   */
  removed_resources?:
    | string[]
    | undefined;
  /**
   * The nonce provides a way for DeltaDiscoveryRequests to uniquely
   * reference a DeltaDiscoveryResponse when (N)ACKing. The nonce is required.
   */
  nonce?: string | undefined;
}

export interface Resource {
  $type: "envoy.api.v2.Resource";
  /** The resource's name, to distinguish it from others of the same type of resource. */
  name?:
    | string
    | undefined;
  /** The aliases are a list of other names that this resource can go by. */
  aliases?:
    | string[]
    | undefined;
  /**
   * The resource level version. It allows xDS to track the state of individual
   * resources.
   */
  version?:
    | string
    | undefined;
  /** The resource being tracked. */
  resource?: Any | undefined;
}

function createBaseDiscoveryRequest(): DiscoveryRequest {
  return { $type: "envoy.api.v2.DiscoveryRequest" };
}

export const DiscoveryRequest: MessageFns<DiscoveryRequest, "envoy.api.v2.DiscoveryRequest"> = {
  $type: "envoy.api.v2.DiscoveryRequest" as const,

  encode(message: DiscoveryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version_info !== undefined && message.version_info !== "") {
      writer.uint32(10).string(message.version_info);
    }
    if (message.node !== undefined) {
      Node.encode(message.node, writer.uint32(18).fork()).join();
    }
    if (message.resource_names !== undefined && message.resource_names.length !== 0) {
      for (const v of message.resource_names) {
        writer.uint32(26).string(v!);
      }
    }
    if (message.type_url !== undefined && message.type_url !== "") {
      writer.uint32(34).string(message.type_url);
    }
    if (message.response_nonce !== undefined && message.response_nonce !== "") {
      writer.uint32(42).string(message.response_nonce);
    }
    if (message.error_detail !== undefined) {
      Status.encode(message.error_detail, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiscoveryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiscoveryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version_info = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.node = Node.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.resource_names === undefined) {
            message.resource_names = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.resource_names!.push(el);
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.type_url = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.response_nonce = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.error_detail = Status.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiscoveryRequest {
    return {
      $type: DiscoveryRequest.$type,
      version_info: isSet(object.version_info) ? globalThis.String(object.version_info) : undefined,
      node: isSet(object.node) ? Node.fromJSON(object.node) : undefined,
      resource_names: globalThis.Array.isArray(object?.resource_names)
        ? object.resource_names.map((e: any) => globalThis.String(e))
        : undefined,
      type_url: isSet(object.type_url) ? globalThis.String(object.type_url) : undefined,
      response_nonce: isSet(object.response_nonce) ? globalThis.String(object.response_nonce) : undefined,
      error_detail: isSet(object.error_detail) ? Status.fromJSON(object.error_detail) : undefined,
    };
  },

  toJSON(message: DiscoveryRequest): unknown {
    const obj: any = {};
    if (message.version_info !== undefined) {
      obj.version_info = message.version_info;
    }
    if (message.node !== undefined) {
      obj.node = Node.toJSON(message.node);
    }
    if (message.resource_names?.length) {
      obj.resource_names = message.resource_names;
    }
    if (message.type_url !== undefined) {
      obj.type_url = message.type_url;
    }
    if (message.response_nonce !== undefined) {
      obj.response_nonce = message.response_nonce;
    }
    if (message.error_detail !== undefined) {
      obj.error_detail = Status.toJSON(message.error_detail);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DiscoveryRequest>, I>>(base?: I): DiscoveryRequest {
    return DiscoveryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DiscoveryRequest>, I>>(object: I): DiscoveryRequest {
    const message = createBaseDiscoveryRequest();
    message.version_info = object.version_info ?? undefined;
    message.node = (object.node !== undefined && object.node !== null) ? Node.fromPartial(object.node) : undefined;
    message.resource_names = object.resource_names?.map((e) => e) || undefined;
    message.type_url = object.type_url ?? undefined;
    message.response_nonce = object.response_nonce ?? undefined;
    message.error_detail = (object.error_detail !== undefined && object.error_detail !== null)
      ? Status.fromPartial(object.error_detail)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(DiscoveryRequest.$type, DiscoveryRequest);

function createBaseDiscoveryResponse(): DiscoveryResponse {
  return { $type: "envoy.api.v2.DiscoveryResponse" };
}

export const DiscoveryResponse: MessageFns<DiscoveryResponse, "envoy.api.v2.DiscoveryResponse"> = {
  $type: "envoy.api.v2.DiscoveryResponse" as const,

  encode(message: DiscoveryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version_info !== undefined && message.version_info !== "") {
      writer.uint32(10).string(message.version_info);
    }
    if (message.resources !== undefined && message.resources.length !== 0) {
      for (const v of message.resources) {
        Any.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.canary !== undefined && message.canary !== false) {
      writer.uint32(24).bool(message.canary);
    }
    if (message.type_url !== undefined && message.type_url !== "") {
      writer.uint32(34).string(message.type_url);
    }
    if (message.nonce !== undefined && message.nonce !== "") {
      writer.uint32(42).string(message.nonce);
    }
    if (message.control_plane !== undefined) {
      ControlPlane.encode(message.control_plane, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiscoveryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiscoveryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version_info = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.resources === undefined) {
            message.resources = [];
          }
          const el = Any.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.resources!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.canary = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.type_url = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.nonce = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.control_plane = ControlPlane.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiscoveryResponse {
    return {
      $type: DiscoveryResponse.$type,
      version_info: isSet(object.version_info) ? globalThis.String(object.version_info) : undefined,
      resources: globalThis.Array.isArray(object?.resources)
        ? object.resources.map((e: any) => Any.fromJSON(e))
        : undefined,
      canary: isSet(object.canary) ? globalThis.Boolean(object.canary) : undefined,
      type_url: isSet(object.type_url) ? globalThis.String(object.type_url) : undefined,
      nonce: isSet(object.nonce) ? globalThis.String(object.nonce) : undefined,
      control_plane: isSet(object.control_plane) ? ControlPlane.fromJSON(object.control_plane) : undefined,
    };
  },

  toJSON(message: DiscoveryResponse): unknown {
    const obj: any = {};
    if (message.version_info !== undefined) {
      obj.version_info = message.version_info;
    }
    if (message.resources?.length) {
      obj.resources = message.resources.map((e) => Any.toJSON(e));
    }
    if (message.canary !== undefined) {
      obj.canary = message.canary;
    }
    if (message.type_url !== undefined) {
      obj.type_url = message.type_url;
    }
    if (message.nonce !== undefined) {
      obj.nonce = message.nonce;
    }
    if (message.control_plane !== undefined) {
      obj.control_plane = ControlPlane.toJSON(message.control_plane);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DiscoveryResponse>, I>>(base?: I): DiscoveryResponse {
    return DiscoveryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DiscoveryResponse>, I>>(object: I): DiscoveryResponse {
    const message = createBaseDiscoveryResponse();
    message.version_info = object.version_info ?? undefined;
    message.resources = object.resources?.map((e) => Any.fromPartial(e)) || undefined;
    message.canary = object.canary ?? undefined;
    message.type_url = object.type_url ?? undefined;
    message.nonce = object.nonce ?? undefined;
    message.control_plane = (object.control_plane !== undefined && object.control_plane !== null)
      ? ControlPlane.fromPartial(object.control_plane)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(DiscoveryResponse.$type, DiscoveryResponse);

function createBaseDeltaDiscoveryRequest(): DeltaDiscoveryRequest {
  return { $type: "envoy.api.v2.DeltaDiscoveryRequest" };
}

export const DeltaDiscoveryRequest: MessageFns<DeltaDiscoveryRequest, "envoy.api.v2.DeltaDiscoveryRequest"> = {
  $type: "envoy.api.v2.DeltaDiscoveryRequest" as const,

  encode(message: DeltaDiscoveryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.node !== undefined) {
      Node.encode(message.node, writer.uint32(10).fork()).join();
    }
    if (message.type_url !== undefined && message.type_url !== "") {
      writer.uint32(18).string(message.type_url);
    }
    if (message.resource_names_subscribe !== undefined && message.resource_names_subscribe.length !== 0) {
      for (const v of message.resource_names_subscribe) {
        writer.uint32(26).string(v!);
      }
    }
    if (message.resource_names_unsubscribe !== undefined && message.resource_names_unsubscribe.length !== 0) {
      for (const v of message.resource_names_unsubscribe) {
        writer.uint32(34).string(v!);
      }
    }
    (message.initial_resource_versions || new Map()).forEach((value, key) => {
      DeltaDiscoveryRequest_InitialResourceVersionsEntry.encode({
        $type: "envoy.api.v2.DeltaDiscoveryRequest.InitialResourceVersionsEntry",
        key: key as any,
        value,
      }, writer.uint32(42).fork()).join();
    });
    if (message.response_nonce !== undefined && message.response_nonce !== "") {
      writer.uint32(50).string(message.response_nonce);
    }
    if (message.error_detail !== undefined) {
      Status.encode(message.error_detail, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeltaDiscoveryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeltaDiscoveryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.node = Node.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type_url = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.resource_names_subscribe === undefined) {
            message.resource_names_subscribe = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.resource_names_subscribe!.push(el);
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          if (message.resource_names_unsubscribe === undefined) {
            message.resource_names_unsubscribe = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.resource_names_unsubscribe!.push(el);
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = DeltaDiscoveryRequest_InitialResourceVersionsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            if (message.initial_resource_versions === undefined) {
              message.initial_resource_versions = new Map();
            }
            message.initial_resource_versions!.set(entry5.key, entry5.value);
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.response_nonce = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.error_detail = Status.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeltaDiscoveryRequest {
    return {
      $type: DeltaDiscoveryRequest.$type,
      node: isSet(object.node) ? Node.fromJSON(object.node) : undefined,
      type_url: isSet(object.type_url) ? globalThis.String(object.type_url) : undefined,
      resource_names_subscribe: globalThis.Array.isArray(object?.resource_names_subscribe)
        ? object.resource_names_subscribe.map((e: any) => globalThis.String(e))
        : undefined,
      resource_names_unsubscribe: globalThis.Array.isArray(object?.resource_names_unsubscribe)
        ? object.resource_names_unsubscribe.map((e: any) => globalThis.String(e))
        : undefined,
      initial_resource_versions: isObject(object.initial_resource_versions)
        ? Object.entries(object.initial_resource_versions).reduce<Map<string, string>>((acc, [key, value]) => {
          acc.set(key, String(value));
          return acc;
        }, new Map())
        : undefined,
      response_nonce: isSet(object.response_nonce) ? globalThis.String(object.response_nonce) : undefined,
      error_detail: isSet(object.error_detail) ? Status.fromJSON(object.error_detail) : undefined,
    };
  },

  toJSON(message: DeltaDiscoveryRequest): unknown {
    const obj: any = {};
    if (message.node !== undefined) {
      obj.node = Node.toJSON(message.node);
    }
    if (message.type_url !== undefined) {
      obj.type_url = message.type_url;
    }
    if (message.resource_names_subscribe?.length) {
      obj.resource_names_subscribe = message.resource_names_subscribe;
    }
    if (message.resource_names_unsubscribe?.length) {
      obj.resource_names_unsubscribe = message.resource_names_unsubscribe;
    }
    if (message.initial_resource_versions?.size) {
      obj.initial_resource_versions = {};
      message.initial_resource_versions.forEach((v, k) => {
        obj.initial_resource_versions[k] = v;
      });
    }
    if (message.response_nonce !== undefined) {
      obj.response_nonce = message.response_nonce;
    }
    if (message.error_detail !== undefined) {
      obj.error_detail = Status.toJSON(message.error_detail);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeltaDiscoveryRequest>, I>>(base?: I): DeltaDiscoveryRequest {
    return DeltaDiscoveryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeltaDiscoveryRequest>, I>>(object: I): DeltaDiscoveryRequest {
    const message = createBaseDeltaDiscoveryRequest();
    message.node = (object.node !== undefined && object.node !== null) ? Node.fromPartial(object.node) : undefined;
    message.type_url = object.type_url ?? undefined;
    message.resource_names_subscribe = object.resource_names_subscribe?.map((e) => e) || undefined;
    message.resource_names_unsubscribe = object.resource_names_unsubscribe?.map((e) => e) || undefined;
    message.initial_resource_versions =
      (object.initial_resource_versions === undefined || object.initial_resource_versions === null)
        ? undefined
        : (() => {
          const m = new Map();
          (object.initial_resource_versions as Map<string, string> ?? new Map()).forEach((value, key) => {
            if (value !== undefined) {
              m.set(key, globalThis.String(value));
            }
          });
          return m;
        })();
    message.response_nonce = object.response_nonce ?? undefined;
    message.error_detail = (object.error_detail !== undefined && object.error_detail !== null)
      ? Status.fromPartial(object.error_detail)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(DeltaDiscoveryRequest.$type, DeltaDiscoveryRequest);

function createBaseDeltaDiscoveryRequest_InitialResourceVersionsEntry(): DeltaDiscoveryRequest_InitialResourceVersionsEntry {
  return { $type: "envoy.api.v2.DeltaDiscoveryRequest.InitialResourceVersionsEntry", key: "", value: "" };
}

export const DeltaDiscoveryRequest_InitialResourceVersionsEntry: MessageFns<
  DeltaDiscoveryRequest_InitialResourceVersionsEntry,
  "envoy.api.v2.DeltaDiscoveryRequest.InitialResourceVersionsEntry"
> = {
  $type: "envoy.api.v2.DeltaDiscoveryRequest.InitialResourceVersionsEntry" as const,

  encode(
    message: DeltaDiscoveryRequest_InitialResourceVersionsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeltaDiscoveryRequest_InitialResourceVersionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeltaDiscoveryRequest_InitialResourceVersionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeltaDiscoveryRequest_InitialResourceVersionsEntry {
    return {
      $type: DeltaDiscoveryRequest_InitialResourceVersionsEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: DeltaDiscoveryRequest_InitialResourceVersionsEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeltaDiscoveryRequest_InitialResourceVersionsEntry>, I>>(
    base?: I,
  ): DeltaDiscoveryRequest_InitialResourceVersionsEntry {
    return DeltaDiscoveryRequest_InitialResourceVersionsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeltaDiscoveryRequest_InitialResourceVersionsEntry>, I>>(
    object: I,
  ): DeltaDiscoveryRequest_InitialResourceVersionsEntry {
    const message = createBaseDeltaDiscoveryRequest_InitialResourceVersionsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

messageTypeRegistry.set(
  DeltaDiscoveryRequest_InitialResourceVersionsEntry.$type,
  DeltaDiscoveryRequest_InitialResourceVersionsEntry,
);

function createBaseDeltaDiscoveryResponse(): DeltaDiscoveryResponse {
  return { $type: "envoy.api.v2.DeltaDiscoveryResponse" };
}

export const DeltaDiscoveryResponse: MessageFns<DeltaDiscoveryResponse, "envoy.api.v2.DeltaDiscoveryResponse"> = {
  $type: "envoy.api.v2.DeltaDiscoveryResponse" as const,

  encode(message: DeltaDiscoveryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.system_version_info !== undefined && message.system_version_info !== "") {
      writer.uint32(10).string(message.system_version_info);
    }
    if (message.resources !== undefined && message.resources.length !== 0) {
      for (const v of message.resources) {
        Resource.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.type_url !== undefined && message.type_url !== "") {
      writer.uint32(34).string(message.type_url);
    }
    if (message.removed_resources !== undefined && message.removed_resources.length !== 0) {
      for (const v of message.removed_resources) {
        writer.uint32(50).string(v!);
      }
    }
    if (message.nonce !== undefined && message.nonce !== "") {
      writer.uint32(42).string(message.nonce);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeltaDiscoveryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeltaDiscoveryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.system_version_info = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.resources === undefined) {
            message.resources = [];
          }
          const el = Resource.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.resources!.push(el);
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.type_url = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          if (message.removed_resources === undefined) {
            message.removed_resources = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.removed_resources!.push(el);
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.nonce = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeltaDiscoveryResponse {
    return {
      $type: DeltaDiscoveryResponse.$type,
      system_version_info: isSet(object.system_version_info)
        ? globalThis.String(object.system_version_info)
        : undefined,
      resources: globalThis.Array.isArray(object?.resources)
        ? object.resources.map((e: any) => Resource.fromJSON(e))
        : undefined,
      type_url: isSet(object.type_url) ? globalThis.String(object.type_url) : undefined,
      removed_resources: globalThis.Array.isArray(object?.removed_resources)
        ? object.removed_resources.map((e: any) => globalThis.String(e))
        : undefined,
      nonce: isSet(object.nonce) ? globalThis.String(object.nonce) : undefined,
    };
  },

  toJSON(message: DeltaDiscoveryResponse): unknown {
    const obj: any = {};
    if (message.system_version_info !== undefined) {
      obj.system_version_info = message.system_version_info;
    }
    if (message.resources?.length) {
      obj.resources = message.resources.map((e) => Resource.toJSON(e));
    }
    if (message.type_url !== undefined) {
      obj.type_url = message.type_url;
    }
    if (message.removed_resources?.length) {
      obj.removed_resources = message.removed_resources;
    }
    if (message.nonce !== undefined) {
      obj.nonce = message.nonce;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeltaDiscoveryResponse>, I>>(base?: I): DeltaDiscoveryResponse {
    return DeltaDiscoveryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeltaDiscoveryResponse>, I>>(object: I): DeltaDiscoveryResponse {
    const message = createBaseDeltaDiscoveryResponse();
    message.system_version_info = object.system_version_info ?? undefined;
    message.resources = object.resources?.map((e) => Resource.fromPartial(e)) || undefined;
    message.type_url = object.type_url ?? undefined;
    message.removed_resources = object.removed_resources?.map((e) => e) || undefined;
    message.nonce = object.nonce ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(DeltaDiscoveryResponse.$type, DeltaDiscoveryResponse);

function createBaseResource(): Resource {
  return { $type: "envoy.api.v2.Resource" };
}

export const Resource: MessageFns<Resource, "envoy.api.v2.Resource"> = {
  $type: "envoy.api.v2.Resource" as const,

  encode(message: Resource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.aliases !== undefined && message.aliases.length !== 0) {
      for (const v of message.aliases) {
        writer.uint32(34).string(v!);
      }
    }
    if (message.version !== undefined && message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    if (message.resource !== undefined) {
      Any.encode(message.resource, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Resource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          if (message.aliases === undefined) {
            message.aliases = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.aliases!.push(el);
          }
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.resource = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Resource {
    return {
      $type: Resource.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      aliases: globalThis.Array.isArray(object?.aliases)
        ? object.aliases.map((e: any) => globalThis.String(e))
        : undefined,
      version: isSet(object.version) ? globalThis.String(object.version) : undefined,
      resource: isSet(object.resource) ? Any.fromJSON(object.resource) : undefined,
    };
  },

  toJSON(message: Resource): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.aliases?.length) {
      obj.aliases = message.aliases;
    }
    if (message.version !== undefined) {
      obj.version = message.version;
    }
    if (message.resource !== undefined) {
      obj.resource = Any.toJSON(message.resource);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Resource>, I>>(base?: I): Resource {
    return Resource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Resource>, I>>(object: I): Resource {
    const message = createBaseResource();
    message.name = object.name ?? undefined;
    message.aliases = object.aliases?.map((e) => e) || undefined;
    message.version = object.version ?? undefined;
    message.resource = (object.resource !== undefined && object.resource !== null)
      ? Any.fromPartial(object.resource)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Resource.$type, Resource);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
