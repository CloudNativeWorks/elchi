// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/load_balancing_policies/common/v3/common.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../../../google/protobuf/duration";
import { UInt32Value, UInt64Value } from "../../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../../typeRegistry";
import { RuntimeDouble } from "../../../../config/core/v3/base";
import { RouteAction_HashPolicy } from "../../../../config/route/v3/route_components";
import { Percent } from "../../../../type/v3/percent";

export const protobufPackage = "envoy.extensions.load_balancing_policies.common.v3";

export interface LocalityLbConfig {
  $type: "envoy.extensions.load_balancing_policies.common.v3.LocalityLbConfig";
  locality_config_specifier?:
    | //
    /** Configuration for local zone aware load balancing. */
    { $case: "zone_aware_lb_config"; zone_aware_lb_config: LocalityLbConfig_ZoneAwareLbConfig }
    | //
    /** Enable locality weighted load balancing. */
    { $case: "locality_weighted_lb_config"; locality_weighted_lb_config: LocalityLbConfig_LocalityWeightedLbConfig }
    | undefined;
}

/**
 * Configuration for :ref:`zone aware routing
 * <arch_overview_load_balancing_zone_aware_routing>`.
 * [#next-free-field: 6]
 */
export interface LocalityLbConfig_ZoneAwareLbConfig {
  $type: "envoy.extensions.load_balancing_policies.common.v3.LocalityLbConfig.ZoneAwareLbConfig";
  /**
   * Configures percentage of requests that will be considered for zone aware routing
   * if zone aware routing is configured. If not specified, the default is 100%.
   * * :ref:`runtime values <config_cluster_manager_cluster_runtime_zone_routing>`.
   * * :ref:`Zone aware routing support <arch_overview_load_balancing_zone_aware_routing>`.
   */
  routing_enabled?:
    | Percent
    | undefined;
  /**
   * Configures minimum upstream cluster size required for zone aware routing
   * If upstream cluster size is less than specified, zone aware routing is not performed
   * even if zone aware routing is configured. If not specified, the default is 6.
   * * :ref:`runtime values <config_cluster_manager_cluster_runtime_zone_routing>`.
   * * :ref:`Zone aware routing support <arch_overview_load_balancing_zone_aware_routing>`.
   */
  min_cluster_size?:
    | number
    | undefined;
  /**
   * If set to true, Envoy will not consider any hosts when the cluster is in :ref:`panic
   * mode<arch_overview_load_balancing_panic_threshold>`. Instead, the cluster will fail all
   * requests as if all hosts are unhealthy. This can help avoid potentially overwhelming a
   * failing service.
   */
  fail_traffic_on_panic?:
    | boolean
    | undefined;
  /**
   * If set to true, Envoy will force LocalityDirect routing if a local locality exists.
   *
   * @deprecated
   */
  force_locality_direct_routing?: boolean | undefined;
  force_local_zone?: LocalityLbConfig_ZoneAwareLbConfig_ForceLocalZone | undefined;
}

/**
 * Configures Envoy to always route requests to the local zone regardless of the
 * upstream zone structure. In Envoy's default configuration, traffic is distributed proportionally
 * across all upstream hosts while trying to maximize local routing when possible. The approach
 * with force_local_zone aims to be more predictable and if there are upstream hosts in the local
 * zone, they will receive all traffic.
 * * :ref:`runtime values <config_cluster_manager_cluster_runtime_zone_routing>`.
 * * :ref:`Zone aware routing support <arch_overview_load_balancing_zone_aware_routing>`.
 */
export interface LocalityLbConfig_ZoneAwareLbConfig_ForceLocalZone {
  $type: "envoy.extensions.load_balancing_policies.common.v3.LocalityLbConfig.ZoneAwareLbConfig.ForceLocalZone";
  /**
   * Configures the minimum number of upstream hosts in the local zone required when force_local_zone
   * is enabled. If the number of upstream hosts in the local zone is less than the specified value,
   * Envoy will fall back to the default proportional-based distribution across localities.
   * If not specified, the default is 1.
   * * :ref:`runtime values <config_cluster_manager_cluster_runtime_zone_routing>`.
   * * :ref:`Zone aware routing support <arch_overview_load_balancing_zone_aware_routing>`.
   */
  min_size?: number | undefined;
}

/**
 * Configuration for :ref:`locality weighted load balancing
 * <arch_overview_load_balancing_locality_weighted_lb>`
 */
export interface LocalityLbConfig_LocalityWeightedLbConfig {
  $type: "envoy.extensions.load_balancing_policies.common.v3.LocalityLbConfig.LocalityWeightedLbConfig";
}

/** Configuration for :ref:`slow start mode <arch_overview_load_balancing_slow_start>`. */
export interface SlowStartConfig {
  $type: "envoy.extensions.load_balancing_policies.common.v3.SlowStartConfig";
  /**
   * Represents the size of slow start window.
   * If set, the newly created host remains in slow start mode starting from its creation time
   * for the duration of slow start window.
   */
  slow_start_window?:
    | Duration
    | undefined;
  /**
   * This parameter controls the speed of traffic increase over the slow start window. Defaults to 1.0,
   * so that endpoint would get linearly increasing amount of traffic.
   * When increasing the value for this parameter, the speed of traffic ramp-up increases non-linearly.
   * The value of aggression parameter should be greater than 0.0.
   * By tuning the parameter, is possible to achieve polynomial or exponential shape of ramp-up curve.
   *
   * During slow start window, effective weight of an endpoint would be scaled with time factor and aggression:
   * ``new_weight = weight * max(min_weight_percent, time_factor ^ (1 / aggression))``,
   * where ``time_factor=(time_since_start_seconds / slow_start_time_seconds)``.
   *
   * As time progresses, more and more traffic would be sent to endpoint, which is in slow start window.
   * Once host exits slow start, time_factor and aggression no longer affect its weight.
   */
  aggression?:
    | RuntimeDouble
    | undefined;
  /**
   * Configures the minimum percentage of origin weight that avoids too small new weight,
   * which may cause endpoints in slow start mode receive no traffic in slow start window.
   * If not specified, the default is 10%.
   */
  min_weight_percent?: Percent | undefined;
}

/** Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.) */
export interface ConsistentHashingLbConfig {
  $type: "envoy.extensions.load_balancing_policies.common.v3.ConsistentHashingLbConfig";
  /**
   * If set to ``true``, the cluster will use hostname instead of the resolved
   * address as the key to consistently hash to an upstream host. Only valid for StrictDNS clusters with hostnames which resolve to a single IP address.
   */
  use_hostname_for_hashing?:
    | boolean
    | undefined;
  /**
   * Configures percentage of average cluster load to bound per upstream host. For example, with a value of 150
   * no upstream host will get a load more than 1.5 times the average load of all the hosts in the cluster.
   * If not specified, the load is not bounded for any upstream host. Typical value for this parameter is between 120 and 200.
   * Minimum is 100.
   *
   * Applies to both Ring Hash and Maglev load balancers.
   *
   * This is implemented based on the method described in the paper https://arxiv.org/abs/1608.01350. For the specified
   * ``hash_balance_factor``, requests to any upstream host are capped at ``hash_balance_factor/100`` times the average number of requests
   * across the cluster. When a request arrives for an upstream host that is currently serving at its max capacity, linear probing
   * is used to identify an eligible host. Further, the linear probe is implemented using a random jump in hosts ring/table to identify
   * the eligible host (this technique is as described in the paper https://arxiv.org/abs/1908.08762 - the random jump avoids the
   * cascading overflow effect when choosing the next host in the ring/table).
   *
   * If weights are specified on the hosts, they are respected.
   *
   * This is an O(N) algorithm, unlike other load balancers. Using a lower ``hash_balance_factor`` results in more hosts
   * being probed, so use a higher value if you require better performance.
   */
  hash_balance_factor?:
    | number
    | undefined;
  /**
   * Specifies a list of hash policies to use for ring hash load balancing. If ``hash_policy`` is
   * set, then
   * :ref:`route level hash policy <envoy_v3_api_field_config.route.v3.RouteAction.hash_policy>`
   * will be ignored.
   */
  hash_policy?: RouteAction_HashPolicy[] | undefined;
}

function createBaseLocalityLbConfig(): LocalityLbConfig {
  return {
    $type: "envoy.extensions.load_balancing_policies.common.v3.LocalityLbConfig",
    locality_config_specifier: undefined,
  };
}

export const LocalityLbConfig: MessageFns<
  LocalityLbConfig,
  "envoy.extensions.load_balancing_policies.common.v3.LocalityLbConfig"
> = {
  $type: "envoy.extensions.load_balancing_policies.common.v3.LocalityLbConfig" as const,

  encode(message: LocalityLbConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.locality_config_specifier?.$case) {
      case "zone_aware_lb_config":
        LocalityLbConfig_ZoneAwareLbConfig.encode(
          message.locality_config_specifier.zone_aware_lb_config,
          writer.uint32(10).fork(),
        ).join();
        break;
      case "locality_weighted_lb_config":
        LocalityLbConfig_LocalityWeightedLbConfig.encode(
          message.locality_config_specifier.locality_weighted_lb_config,
          writer.uint32(18).fork(),
        ).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocalityLbConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocalityLbConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.locality_config_specifier = {
            $case: "zone_aware_lb_config",
            zone_aware_lb_config: LocalityLbConfig_ZoneAwareLbConfig.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.locality_config_specifier = {
            $case: "locality_weighted_lb_config",
            locality_weighted_lb_config: LocalityLbConfig_LocalityWeightedLbConfig.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocalityLbConfig {
    return {
      $type: LocalityLbConfig.$type,
      locality_config_specifier: isSet(object.zone_aware_lb_config)
        ? {
          $case: "zone_aware_lb_config",
          zone_aware_lb_config: LocalityLbConfig_ZoneAwareLbConfig.fromJSON(object.zone_aware_lb_config),
        }
        : isSet(object.locality_weighted_lb_config)
        ? {
          $case: "locality_weighted_lb_config",
          locality_weighted_lb_config: LocalityLbConfig_LocalityWeightedLbConfig.fromJSON(
            object.locality_weighted_lb_config,
          ),
        }
        : undefined,
    };
  },

  toJSON(message: LocalityLbConfig): unknown {
    const obj: any = {};
    if (message.locality_config_specifier?.$case === "zone_aware_lb_config") {
      obj.zone_aware_lb_config = LocalityLbConfig_ZoneAwareLbConfig.toJSON(
        message.locality_config_specifier.zone_aware_lb_config,
      );
    }
    if (message.locality_config_specifier?.$case === "locality_weighted_lb_config") {
      obj.locality_weighted_lb_config = LocalityLbConfig_LocalityWeightedLbConfig.toJSON(
        message.locality_config_specifier.locality_weighted_lb_config,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LocalityLbConfig>, I>>(base?: I): LocalityLbConfig {
    return LocalityLbConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LocalityLbConfig>, I>>(object: I): LocalityLbConfig {
    const message = createBaseLocalityLbConfig();
    if (
      object.locality_config_specifier?.$case === "zone_aware_lb_config" &&
      object.locality_config_specifier?.zone_aware_lb_config !== undefined &&
      object.locality_config_specifier?.zone_aware_lb_config !== null
    ) {
      message.locality_config_specifier = {
        $case: "zone_aware_lb_config",
        zone_aware_lb_config: LocalityLbConfig_ZoneAwareLbConfig.fromPartial(
          object.locality_config_specifier.zone_aware_lb_config,
        ),
      };
    }
    if (
      object.locality_config_specifier?.$case === "locality_weighted_lb_config" &&
      object.locality_config_specifier?.locality_weighted_lb_config !== undefined &&
      object.locality_config_specifier?.locality_weighted_lb_config !== null
    ) {
      message.locality_config_specifier = {
        $case: "locality_weighted_lb_config",
        locality_weighted_lb_config: LocalityLbConfig_LocalityWeightedLbConfig.fromPartial(
          object.locality_config_specifier.locality_weighted_lb_config,
        ),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(LocalityLbConfig.$type, LocalityLbConfig);

function createBaseLocalityLbConfig_ZoneAwareLbConfig(): LocalityLbConfig_ZoneAwareLbConfig {
  return { $type: "envoy.extensions.load_balancing_policies.common.v3.LocalityLbConfig.ZoneAwareLbConfig" };
}

export const LocalityLbConfig_ZoneAwareLbConfig: MessageFns<
  LocalityLbConfig_ZoneAwareLbConfig,
  "envoy.extensions.load_balancing_policies.common.v3.LocalityLbConfig.ZoneAwareLbConfig"
> = {
  $type: "envoy.extensions.load_balancing_policies.common.v3.LocalityLbConfig.ZoneAwareLbConfig" as const,

  encode(message: LocalityLbConfig_ZoneAwareLbConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.routing_enabled !== undefined) {
      Percent.encode(message.routing_enabled, writer.uint32(10).fork()).join();
    }
    if (message.min_cluster_size !== undefined) {
      UInt64Value.encode(
        { $type: "google.protobuf.UInt64Value", value: message.min_cluster_size! },
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.fail_traffic_on_panic !== undefined && message.fail_traffic_on_panic !== false) {
      writer.uint32(24).bool(message.fail_traffic_on_panic);
    }
    if (message.force_locality_direct_routing !== undefined && message.force_locality_direct_routing !== false) {
      writer.uint32(32).bool(message.force_locality_direct_routing);
    }
    if (message.force_local_zone !== undefined) {
      LocalityLbConfig_ZoneAwareLbConfig_ForceLocalZone.encode(message.force_local_zone, writer.uint32(42).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocalityLbConfig_ZoneAwareLbConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocalityLbConfig_ZoneAwareLbConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.routing_enabled = Percent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.min_cluster_size = UInt64Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.fail_traffic_on_panic = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.force_locality_direct_routing = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.force_local_zone = LocalityLbConfig_ZoneAwareLbConfig_ForceLocalZone.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocalityLbConfig_ZoneAwareLbConfig {
    return {
      $type: LocalityLbConfig_ZoneAwareLbConfig.$type,
      routing_enabled: isSet(object.routing_enabled) ? Percent.fromJSON(object.routing_enabled) : undefined,
      min_cluster_size: isSet(object.min_cluster_size) ? Number(object.min_cluster_size) : undefined,
      fail_traffic_on_panic: isSet(object.fail_traffic_on_panic)
        ? globalThis.Boolean(object.fail_traffic_on_panic)
        : undefined,
      force_locality_direct_routing: isSet(object.force_locality_direct_routing)
        ? globalThis.Boolean(object.force_locality_direct_routing)
        : undefined,
      force_local_zone: isSet(object.force_local_zone)
        ? LocalityLbConfig_ZoneAwareLbConfig_ForceLocalZone.fromJSON(object.force_local_zone)
        : undefined,
    };
  },

  toJSON(message: LocalityLbConfig_ZoneAwareLbConfig): unknown {
    const obj: any = {};
    if (message.routing_enabled !== undefined) {
      obj.routing_enabled = Percent.toJSON(message.routing_enabled);
    }
    if (message.min_cluster_size !== undefined) {
      obj.min_cluster_size = message.min_cluster_size;
    }
    if (message.fail_traffic_on_panic !== undefined) {
      obj.fail_traffic_on_panic = message.fail_traffic_on_panic;
    }
    if (message.force_locality_direct_routing !== undefined) {
      obj.force_locality_direct_routing = message.force_locality_direct_routing;
    }
    if (message.force_local_zone !== undefined) {
      obj.force_local_zone = LocalityLbConfig_ZoneAwareLbConfig_ForceLocalZone.toJSON(message.force_local_zone);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LocalityLbConfig_ZoneAwareLbConfig>, I>>(
    base?: I,
  ): LocalityLbConfig_ZoneAwareLbConfig {
    return LocalityLbConfig_ZoneAwareLbConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LocalityLbConfig_ZoneAwareLbConfig>, I>>(
    object: I,
  ): LocalityLbConfig_ZoneAwareLbConfig {
    const message = createBaseLocalityLbConfig_ZoneAwareLbConfig();
    message.routing_enabled = (object.routing_enabled !== undefined && object.routing_enabled !== null)
      ? Percent.fromPartial(object.routing_enabled)
      : undefined;
    message.min_cluster_size = object.min_cluster_size ?? undefined;
    message.fail_traffic_on_panic = object.fail_traffic_on_panic ?? undefined;
    message.force_locality_direct_routing = object.force_locality_direct_routing ?? undefined;
    message.force_local_zone = (object.force_local_zone !== undefined && object.force_local_zone !== null)
      ? LocalityLbConfig_ZoneAwareLbConfig_ForceLocalZone.fromPartial(object.force_local_zone)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(LocalityLbConfig_ZoneAwareLbConfig.$type, LocalityLbConfig_ZoneAwareLbConfig);

function createBaseLocalityLbConfig_ZoneAwareLbConfig_ForceLocalZone(): LocalityLbConfig_ZoneAwareLbConfig_ForceLocalZone {
  return {
    $type: "envoy.extensions.load_balancing_policies.common.v3.LocalityLbConfig.ZoneAwareLbConfig.ForceLocalZone",
  };
}

export const LocalityLbConfig_ZoneAwareLbConfig_ForceLocalZone: MessageFns<
  LocalityLbConfig_ZoneAwareLbConfig_ForceLocalZone,
  "envoy.extensions.load_balancing_policies.common.v3.LocalityLbConfig.ZoneAwareLbConfig.ForceLocalZone"
> = {
  $type:
    "envoy.extensions.load_balancing_policies.common.v3.LocalityLbConfig.ZoneAwareLbConfig.ForceLocalZone" as const,

  encode(
    message: LocalityLbConfig_ZoneAwareLbConfig_ForceLocalZone,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.min_size !== undefined) {
      UInt32Value.encode({ $type: "google.protobuf.UInt32Value", value: message.min_size! }, writer.uint32(10).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocalityLbConfig_ZoneAwareLbConfig_ForceLocalZone {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocalityLbConfig_ZoneAwareLbConfig_ForceLocalZone();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.min_size = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocalityLbConfig_ZoneAwareLbConfig_ForceLocalZone {
    return {
      $type: LocalityLbConfig_ZoneAwareLbConfig_ForceLocalZone.$type,
      min_size: isSet(object.min_size) ? Number(object.min_size) : undefined,
    };
  },

  toJSON(message: LocalityLbConfig_ZoneAwareLbConfig_ForceLocalZone): unknown {
    const obj: any = {};
    if (message.min_size !== undefined) {
      obj.min_size = message.min_size;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LocalityLbConfig_ZoneAwareLbConfig_ForceLocalZone>, I>>(
    base?: I,
  ): LocalityLbConfig_ZoneAwareLbConfig_ForceLocalZone {
    return LocalityLbConfig_ZoneAwareLbConfig_ForceLocalZone.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LocalityLbConfig_ZoneAwareLbConfig_ForceLocalZone>, I>>(
    object: I,
  ): LocalityLbConfig_ZoneAwareLbConfig_ForceLocalZone {
    const message = createBaseLocalityLbConfig_ZoneAwareLbConfig_ForceLocalZone();
    message.min_size = object.min_size ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(
  LocalityLbConfig_ZoneAwareLbConfig_ForceLocalZone.$type,
  LocalityLbConfig_ZoneAwareLbConfig_ForceLocalZone,
);

function createBaseLocalityLbConfig_LocalityWeightedLbConfig(): LocalityLbConfig_LocalityWeightedLbConfig {
  return { $type: "envoy.extensions.load_balancing_policies.common.v3.LocalityLbConfig.LocalityWeightedLbConfig" };
}

export const LocalityLbConfig_LocalityWeightedLbConfig: MessageFns<
  LocalityLbConfig_LocalityWeightedLbConfig,
  "envoy.extensions.load_balancing_policies.common.v3.LocalityLbConfig.LocalityWeightedLbConfig"
> = {
  $type: "envoy.extensions.load_balancing_policies.common.v3.LocalityLbConfig.LocalityWeightedLbConfig" as const,

  encode(_: LocalityLbConfig_LocalityWeightedLbConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocalityLbConfig_LocalityWeightedLbConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocalityLbConfig_LocalityWeightedLbConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): LocalityLbConfig_LocalityWeightedLbConfig {
    return { $type: LocalityLbConfig_LocalityWeightedLbConfig.$type };
  },

  toJSON(_: LocalityLbConfig_LocalityWeightedLbConfig): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<LocalityLbConfig_LocalityWeightedLbConfig>, I>>(
    base?: I,
  ): LocalityLbConfig_LocalityWeightedLbConfig {
    return LocalityLbConfig_LocalityWeightedLbConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LocalityLbConfig_LocalityWeightedLbConfig>, I>>(
    _: I,
  ): LocalityLbConfig_LocalityWeightedLbConfig {
    const message = createBaseLocalityLbConfig_LocalityWeightedLbConfig();
    return message;
  },
};

messageTypeRegistry.set(LocalityLbConfig_LocalityWeightedLbConfig.$type, LocalityLbConfig_LocalityWeightedLbConfig);

function createBaseSlowStartConfig(): SlowStartConfig {
  return { $type: "envoy.extensions.load_balancing_policies.common.v3.SlowStartConfig" };
}

export const SlowStartConfig: MessageFns<
  SlowStartConfig,
  "envoy.extensions.load_balancing_policies.common.v3.SlowStartConfig"
> = {
  $type: "envoy.extensions.load_balancing_policies.common.v3.SlowStartConfig" as const,

  encode(message: SlowStartConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.slow_start_window !== undefined) {
      Duration.encode(message.slow_start_window, writer.uint32(10).fork()).join();
    }
    if (message.aggression !== undefined) {
      RuntimeDouble.encode(message.aggression, writer.uint32(18).fork()).join();
    }
    if (message.min_weight_percent !== undefined) {
      Percent.encode(message.min_weight_percent, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SlowStartConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSlowStartConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.slow_start_window = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.aggression = RuntimeDouble.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.min_weight_percent = Percent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SlowStartConfig {
    return {
      $type: SlowStartConfig.$type,
      slow_start_window: isSet(object.slow_start_window) ? Duration.fromJSON(object.slow_start_window) : undefined,
      aggression: isSet(object.aggression) ? RuntimeDouble.fromJSON(object.aggression) : undefined,
      min_weight_percent: isSet(object.min_weight_percent) ? Percent.fromJSON(object.min_weight_percent) : undefined,
    };
  },

  toJSON(message: SlowStartConfig): unknown {
    const obj: any = {};
    if (message.slow_start_window !== undefined) {
      obj.slow_start_window = Duration.toJSON(message.slow_start_window);
    }
    if (message.aggression !== undefined) {
      obj.aggression = RuntimeDouble.toJSON(message.aggression);
    }
    if (message.min_weight_percent !== undefined) {
      obj.min_weight_percent = Percent.toJSON(message.min_weight_percent);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SlowStartConfig>, I>>(base?: I): SlowStartConfig {
    return SlowStartConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SlowStartConfig>, I>>(object: I): SlowStartConfig {
    const message = createBaseSlowStartConfig();
    message.slow_start_window = (object.slow_start_window !== undefined && object.slow_start_window !== null)
      ? Duration.fromPartial(object.slow_start_window)
      : undefined;
    message.aggression = (object.aggression !== undefined && object.aggression !== null)
      ? RuntimeDouble.fromPartial(object.aggression)
      : undefined;
    message.min_weight_percent = (object.min_weight_percent !== undefined && object.min_weight_percent !== null)
      ? Percent.fromPartial(object.min_weight_percent)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(SlowStartConfig.$type, SlowStartConfig);

function createBaseConsistentHashingLbConfig(): ConsistentHashingLbConfig {
  return { $type: "envoy.extensions.load_balancing_policies.common.v3.ConsistentHashingLbConfig" };
}

export const ConsistentHashingLbConfig: MessageFns<
  ConsistentHashingLbConfig,
  "envoy.extensions.load_balancing_policies.common.v3.ConsistentHashingLbConfig"
> = {
  $type: "envoy.extensions.load_balancing_policies.common.v3.ConsistentHashingLbConfig" as const,

  encode(message: ConsistentHashingLbConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.use_hostname_for_hashing !== undefined && message.use_hostname_for_hashing !== false) {
      writer.uint32(8).bool(message.use_hostname_for_hashing);
    }
    if (message.hash_balance_factor !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.hash_balance_factor! },
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.hash_policy !== undefined && message.hash_policy.length !== 0) {
      for (const v of message.hash_policy) {
        RouteAction_HashPolicy.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConsistentHashingLbConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConsistentHashingLbConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.use_hostname_for_hashing = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.hash_balance_factor = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.hash_policy === undefined) {
            message.hash_policy = [];
          }
          const el = RouteAction_HashPolicy.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.hash_policy!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConsistentHashingLbConfig {
    return {
      $type: ConsistentHashingLbConfig.$type,
      use_hostname_for_hashing: isSet(object.use_hostname_for_hashing)
        ? globalThis.Boolean(object.use_hostname_for_hashing)
        : undefined,
      hash_balance_factor: isSet(object.hash_balance_factor) ? Number(object.hash_balance_factor) : undefined,
      hash_policy: globalThis.Array.isArray(object?.hash_policy)
        ? object.hash_policy.map((e: any) => RouteAction_HashPolicy.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: ConsistentHashingLbConfig): unknown {
    const obj: any = {};
    if (message.use_hostname_for_hashing !== undefined) {
      obj.use_hostname_for_hashing = message.use_hostname_for_hashing;
    }
    if (message.hash_balance_factor !== undefined) {
      obj.hash_balance_factor = message.hash_balance_factor;
    }
    if (message.hash_policy?.length) {
      obj.hash_policy = message.hash_policy.map((e) => RouteAction_HashPolicy.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConsistentHashingLbConfig>, I>>(base?: I): ConsistentHashingLbConfig {
    return ConsistentHashingLbConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConsistentHashingLbConfig>, I>>(object: I): ConsistentHashingLbConfig {
    const message = createBaseConsistentHashingLbConfig();
    message.use_hostname_for_hashing = object.use_hostname_for_hashing ?? undefined;
    message.hash_balance_factor = object.hash_balance_factor ?? undefined;
    message.hash_policy = object.hash_policy?.map((e) => RouteAction_HashPolicy.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(ConsistentHashingLbConfig.$type, ConsistentHashingLbConfig);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
