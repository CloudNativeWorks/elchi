// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/filters/http/api_key_auth/v3/api_key_auth.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { messageTypeRegistry } from "../../../../../../typeRegistry";

export const protobufPackage = "envoy.extensions.filters.http.api_key_auth.v3";

/**
 * API Key HTTP authentication.
 *
 * For example, the following configuration configures the filter to authenticate the clients using
 * the API key from the header ``X-API-KEY``. And only the clients with the key ``real-key`` are
 * considered as authenticated. The client information is configured to be forwarded
 * in the header ``x-client-id``.
 *
 * .. code-block:: yaml
 *
 *    credentials:
 *    - key: real-key
 *      client: user
 *    key_sources:
 *     - header: "X-API-KEY"
 *    forwarding:
 *      header: "x-client-id"
 *      hide_credentials: false
 */
export interface ApiKeyAuth {
  $type: "envoy.extensions.filters.http.api_key_auth.v3.ApiKeyAuth";
  /** The credentials that are used to authenticate the clients. */
  credentials?:
    | Credential[]
    | undefined;
  /** The key sources to fetch the key from the coming request. */
  key_sources?:
    | KeySource[]
    | undefined;
  /** Optional configuration to control what information should be propagated to upstream services. */
  forwarding?: Forwarding | undefined;
}

/** API key auth configuration of per route or per virtual host or per route configuration. */
export interface ApiKeyAuthPerRoute {
  $type: "envoy.extensions.filters.http.api_key_auth.v3.ApiKeyAuthPerRoute";
  /**
   * The credentials that are used to authenticate the clients. If this field is non-empty, then the
   * credentials in the filter level configuration will be ignored and the credentials in this
   * configuration will be used.
   */
  credentials?:
    | Credential[]
    | undefined;
  /**
   * The key sources to fetch the key from the coming request. If this field is non-empty, then the
   * key sources in the filter level configuration will be ignored and the key sources in this
   * configuration will be used.
   */
  key_sources?:
    | KeySource[]
    | undefined;
  /**
   * A list of clients that are allowed to access the route or vhost. The clients listed here
   * should be subset of the clients listed in the ``credentials`` to provide authorization control
   * after the authentication is successful. If the list is empty, then all authenticated clients
   * are allowed. This provides very limited but simple authorization. If more complex authorization
   * is required, then use the :ref:`HTTP RBAC filter <config_http_filters_rbac>` instead.
   *
   * .. note::
   *   Setting this field and ``credentials`` at the same configuration entry is not an error but
   *   also makes no much sense because they provide similar functionality. Please only use
   *   one of them at same configuration entry except for the case that you want to share the same
   *   credentials list across multiple routes but still use different allowed clients for each
   *   route.
   */
  allowed_clients?:
    | string[]
    | undefined;
  /**
   * Optional configuration to control what information should be propagated to upstream services.
   * If this field is non-empty, then the forwarding information in the filter level configuration
   * will be ignored and the forwarding in this configuration will be used.
   */
  forwarding?: Forwarding | undefined;
}

/** Single credential entry that contains the API key and the related client id. */
export interface Credential {
  $type: "envoy.extensions.filters.http.api_key_auth.v3.Credential";
  /** The value of the unique API key. */
  key?:
    | string
    | undefined;
  /** The unique id or identity that used to identify the client or consumer. */
  client?: string | undefined;
}

export interface KeySource {
  $type: "envoy.extensions.filters.http.api_key_auth.v3.KeySource";
  /**
   * The header name to fetch the key. If multiple header values are present, the first one will be
   * used. If the header value starts with 'Bearer ', this prefix will be stripped to get the
   * key value.
   *
   * If set, takes precedence over ``query`` and ``cookie``.
   */
  header?:
    | string
    | undefined;
  /**
   * The query parameter name to fetch the key. If multiple query values are present, the first one
   * will be used.
   *
   * The field will be used if ``header`` is not set. If set, takes precedence over ``cookie``.
   */
  query?:
    | string
    | undefined;
  /**
   * The cookie name to fetch the key.
   *
   * The field will be used if the ``header`` and ``query`` are not set.
   */
  cookie?: string | undefined;
}

export interface Forwarding {
  $type: "envoy.extensions.filters.http.api_key_auth.v3.Forwarding";
  /**
   * The header name in which to store the client information. If this field is non-empty,
   * the client string associated with the matched credential will be injected into
   * the request before forwarding upstream.
   */
  header?:
    | string
    | undefined;
  /**
   * If true, remove the API key from the request before forwarding upstream.
   *
   * This applies to all configured key sources: ``header``, ``query``, and ``cookie``.
   */
  hide_credentials?: boolean | undefined;
}

function createBaseApiKeyAuth(): ApiKeyAuth {
  return { $type: "envoy.extensions.filters.http.api_key_auth.v3.ApiKeyAuth" };
}

export const ApiKeyAuth: MessageFns<ApiKeyAuth, "envoy.extensions.filters.http.api_key_auth.v3.ApiKeyAuth"> = {
  $type: "envoy.extensions.filters.http.api_key_auth.v3.ApiKeyAuth" as const,

  encode(message: ApiKeyAuth, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.credentials !== undefined && message.credentials.length !== 0) {
      for (const v of message.credentials) {
        Credential.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    if (message.key_sources !== undefined && message.key_sources.length !== 0) {
      for (const v of message.key_sources) {
        KeySource.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.forwarding !== undefined) {
      Forwarding.encode(message.forwarding, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApiKeyAuth {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApiKeyAuth();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.credentials === undefined) {
            message.credentials = [];
          }
          const el = Credential.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.credentials!.push(el);
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.key_sources === undefined) {
            message.key_sources = [];
          }
          const el = KeySource.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.key_sources!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.forwarding = Forwarding.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApiKeyAuth {
    return {
      $type: ApiKeyAuth.$type,
      credentials: globalThis.Array.isArray(object?.credentials)
        ? object.credentials.map((e: any) => Credential.fromJSON(e))
        : undefined,
      key_sources: globalThis.Array.isArray(object?.key_sources)
        ? object.key_sources.map((e: any) => KeySource.fromJSON(e))
        : undefined,
      forwarding: isSet(object.forwarding) ? Forwarding.fromJSON(object.forwarding) : undefined,
    };
  },

  toJSON(message: ApiKeyAuth): unknown {
    const obj: any = {};
    if (message.credentials?.length) {
      obj.credentials = message.credentials.map((e) => Credential.toJSON(e));
    }
    if (message.key_sources?.length) {
      obj.key_sources = message.key_sources.map((e) => KeySource.toJSON(e));
    }
    if (message.forwarding !== undefined) {
      obj.forwarding = Forwarding.toJSON(message.forwarding);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApiKeyAuth>, I>>(base?: I): ApiKeyAuth {
    return ApiKeyAuth.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApiKeyAuth>, I>>(object: I): ApiKeyAuth {
    const message = createBaseApiKeyAuth();
    message.credentials = object.credentials?.map((e) => Credential.fromPartial(e)) || undefined;
    message.key_sources = object.key_sources?.map((e) => KeySource.fromPartial(e)) || undefined;
    message.forwarding = (object.forwarding !== undefined && object.forwarding !== null)
      ? Forwarding.fromPartial(object.forwarding)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(ApiKeyAuth.$type, ApiKeyAuth);

function createBaseApiKeyAuthPerRoute(): ApiKeyAuthPerRoute {
  return { $type: "envoy.extensions.filters.http.api_key_auth.v3.ApiKeyAuthPerRoute" };
}

export const ApiKeyAuthPerRoute: MessageFns<
  ApiKeyAuthPerRoute,
  "envoy.extensions.filters.http.api_key_auth.v3.ApiKeyAuthPerRoute"
> = {
  $type: "envoy.extensions.filters.http.api_key_auth.v3.ApiKeyAuthPerRoute" as const,

  encode(message: ApiKeyAuthPerRoute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.credentials !== undefined && message.credentials.length !== 0) {
      for (const v of message.credentials) {
        Credential.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    if (message.key_sources !== undefined && message.key_sources.length !== 0) {
      for (const v of message.key_sources) {
        KeySource.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.allowed_clients !== undefined && message.allowed_clients.length !== 0) {
      for (const v of message.allowed_clients) {
        writer.uint32(26).string(v!);
      }
    }
    if (message.forwarding !== undefined) {
      Forwarding.encode(message.forwarding, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApiKeyAuthPerRoute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApiKeyAuthPerRoute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.credentials === undefined) {
            message.credentials = [];
          }
          const el = Credential.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.credentials!.push(el);
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.key_sources === undefined) {
            message.key_sources = [];
          }
          const el = KeySource.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.key_sources!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.allowed_clients === undefined) {
            message.allowed_clients = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.allowed_clients!.push(el);
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.forwarding = Forwarding.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApiKeyAuthPerRoute {
    return {
      $type: ApiKeyAuthPerRoute.$type,
      credentials: globalThis.Array.isArray(object?.credentials)
        ? object.credentials.map((e: any) => Credential.fromJSON(e))
        : undefined,
      key_sources: globalThis.Array.isArray(object?.key_sources)
        ? object.key_sources.map((e: any) => KeySource.fromJSON(e))
        : undefined,
      allowed_clients: globalThis.Array.isArray(object?.allowed_clients)
        ? object.allowed_clients.map((e: any) => globalThis.String(e))
        : undefined,
      forwarding: isSet(object.forwarding) ? Forwarding.fromJSON(object.forwarding) : undefined,
    };
  },

  toJSON(message: ApiKeyAuthPerRoute): unknown {
    const obj: any = {};
    if (message.credentials?.length) {
      obj.credentials = message.credentials.map((e) => Credential.toJSON(e));
    }
    if (message.key_sources?.length) {
      obj.key_sources = message.key_sources.map((e) => KeySource.toJSON(e));
    }
    if (message.allowed_clients?.length) {
      obj.allowed_clients = message.allowed_clients;
    }
    if (message.forwarding !== undefined) {
      obj.forwarding = Forwarding.toJSON(message.forwarding);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApiKeyAuthPerRoute>, I>>(base?: I): ApiKeyAuthPerRoute {
    return ApiKeyAuthPerRoute.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApiKeyAuthPerRoute>, I>>(object: I): ApiKeyAuthPerRoute {
    const message = createBaseApiKeyAuthPerRoute();
    message.credentials = object.credentials?.map((e) => Credential.fromPartial(e)) || undefined;
    message.key_sources = object.key_sources?.map((e) => KeySource.fromPartial(e)) || undefined;
    message.allowed_clients = object.allowed_clients?.map((e) => e) || undefined;
    message.forwarding = (object.forwarding !== undefined && object.forwarding !== null)
      ? Forwarding.fromPartial(object.forwarding)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(ApiKeyAuthPerRoute.$type, ApiKeyAuthPerRoute);

function createBaseCredential(): Credential {
  return { $type: "envoy.extensions.filters.http.api_key_auth.v3.Credential" };
}

export const Credential: MessageFns<Credential, "envoy.extensions.filters.http.api_key_auth.v3.Credential"> = {
  $type: "envoy.extensions.filters.http.api_key_auth.v3.Credential" as const,

  encode(message: Credential, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined && message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.client !== undefined && message.client !== "") {
      writer.uint32(18).string(message.client);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Credential {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCredential();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.client = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Credential {
    return {
      $type: Credential.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : undefined,
      client: isSet(object.client) ? globalThis.String(object.client) : undefined,
    };
  },

  toJSON(message: Credential): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.client !== undefined) {
      obj.client = message.client;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Credential>, I>>(base?: I): Credential {
    return Credential.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Credential>, I>>(object: I): Credential {
    const message = createBaseCredential();
    message.key = object.key ?? undefined;
    message.client = object.client ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Credential.$type, Credential);

function createBaseKeySource(): KeySource {
  return { $type: "envoy.extensions.filters.http.api_key_auth.v3.KeySource" };
}

export const KeySource: MessageFns<KeySource, "envoy.extensions.filters.http.api_key_auth.v3.KeySource"> = {
  $type: "envoy.extensions.filters.http.api_key_auth.v3.KeySource" as const,

  encode(message: KeySource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined && message.header !== "") {
      writer.uint32(10).string(message.header);
    }
    if (message.query !== undefined && message.query !== "") {
      writer.uint32(18).string(message.query);
    }
    if (message.cookie !== undefined && message.cookie !== "") {
      writer.uint32(26).string(message.cookie);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeySource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeySource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.query = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.cookie = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeySource {
    return {
      $type: KeySource.$type,
      header: isSet(object.header) ? globalThis.String(object.header) : undefined,
      query: isSet(object.query) ? globalThis.String(object.query) : undefined,
      cookie: isSet(object.cookie) ? globalThis.String(object.cookie) : undefined,
    };
  },

  toJSON(message: KeySource): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = message.header;
    }
    if (message.query !== undefined) {
      obj.query = message.query;
    }
    if (message.cookie !== undefined) {
      obj.cookie = message.cookie;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KeySource>, I>>(base?: I): KeySource {
    return KeySource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KeySource>, I>>(object: I): KeySource {
    const message = createBaseKeySource();
    message.header = object.header ?? undefined;
    message.query = object.query ?? undefined;
    message.cookie = object.cookie ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(KeySource.$type, KeySource);

function createBaseForwarding(): Forwarding {
  return { $type: "envoy.extensions.filters.http.api_key_auth.v3.Forwarding" };
}

export const Forwarding: MessageFns<Forwarding, "envoy.extensions.filters.http.api_key_auth.v3.Forwarding"> = {
  $type: "envoy.extensions.filters.http.api_key_auth.v3.Forwarding" as const,

  encode(message: Forwarding, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined && message.header !== "") {
      writer.uint32(10).string(message.header);
    }
    if (message.hide_credentials !== undefined && message.hide_credentials !== false) {
      writer.uint32(16).bool(message.hide_credentials);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Forwarding {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForwarding();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.hide_credentials = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Forwarding {
    return {
      $type: Forwarding.$type,
      header: isSet(object.header) ? globalThis.String(object.header) : undefined,
      hide_credentials: isSet(object.hide_credentials) ? globalThis.Boolean(object.hide_credentials) : undefined,
    };
  },

  toJSON(message: Forwarding): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = message.header;
    }
    if (message.hide_credentials !== undefined) {
      obj.hide_credentials = message.hide_credentials;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Forwarding>, I>>(base?: I): Forwarding {
    return Forwarding.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Forwarding>, I>>(object: I): Forwarding {
    const message = createBaseForwarding();
    message.header = object.header ?? undefined;
    message.hide_credentials = object.hide_credentials ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Forwarding.$type, Forwarding);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
