// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/filters/http/rate_limit_quota/v3/rate_limit_quota.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../../../../google/protobuf/duration";
import { BytesValue } from "../../../../../../google/protobuf/wrappers";
import { Status } from "../../../../../../google/rpc/status";
import { messageTypeRegistry } from "../../../../../../typeRegistry";
import { Matcher } from "../../../../../../xds/type/matcher/v3/matcher";
import { HeaderValueOption, RuntimeFractionalPercent } from "../../../../../config/core/v3/base";
import { TypedExtensionConfig } from "../../../../../config/core/v3/extension";
import { GrpcService } from "../../../../../config/core/v3/grpc_service";
import { HttpStatus } from "../../../../../type/v3/http_status";
import { RateLimitStrategy } from "../../../../../type/v3/ratelimit_strategy";

export const protobufPackage = "envoy.extensions.filters.http.rate_limit_quota.v3";

/**
 * Configures the Rate Limit Quota filter.
 *
 * Can be overridden in the per-route and per-host configurations.
 * The more specific definition completely overrides the less specific definition.
 * [#next-free-field: 7]
 */
export interface RateLimitQuotaFilterConfig {
  $type: "envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaFilterConfig";
  /** Configures the gRPC Rate Limit Quota Service (RLQS) RateLimitQuotaService. */
  rlqs_server?:
    | GrpcService
    | undefined;
  /**
   * The application domain to use when calling the service. This enables sharing the quota
   * server between different applications without fear of overlap.
   * E.g., "envoy".
   */
  domain?:
    | string
    | undefined;
  /**
   * The match tree to use for grouping incoming requests into buckets.
   *
   * Example:
   *
   * .. validated-code-block:: yaml
   *   :type-name: xds.type.matcher.v3.Matcher
   *
   *   matcher_list:
   *     matchers:
   *     # Assign requests with header['env'] set to 'staging' to the bucket { name: 'staging' }
   *     - predicate:
   *         single_predicate:
   *           input:
   *             typed_config:
   *               '@type': type.googleapis.com/envoy.type.matcher.v3.HttpRequestHeaderMatchInput
   *               header_name: env
   *           value_match:
   *             exact: staging
   *       on_match:
   *         action:
   *           typed_config:
   *             '@type': type.googleapis.com/envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings
   *             bucket_id_builder:
   *               bucket_id_builder:
   *                 name:
   *                   string_value: staging
   *
   *     # Assign requests with header['user_group'] set to 'admin' to the bucket { acl: 'admin_users' }
   *     - predicate:
   *         single_predicate:
   *           input:
   *             typed_config:
   *               '@type': type.googleapis.com/xds.type.matcher.v3.HttpAttributesCelMatchInput
   *           custom_match:
   *             typed_config:
   *               '@type': type.googleapis.com/xds.type.matcher.v3.CelMatcher
   *               expr_match:
   *                 # Shortened for illustration purposes. Here should be parsed CEL expression:
   *                 # request.headers['user_group'] == 'admin'
   *                 parsed_expr: {}
   *       on_match:
   *         action:
   *           typed_config:
   *             '@type': type.googleapis.com/envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings
   *             bucket_id_builder:
   *               bucket_id_builder:
   *                 acl:
   *                   string_value: admin_users
   *
   *   # Catch-all clause for the requests not matched by any of the matchers.
   *   # In this example, deny all requests.
   *   on_no_match:
   *     action:
   *       typed_config:
   *         '@type': type.googleapis.com/envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings
   *         no_assignment_behavior:
   *           fallback_rate_limit:
   *             blanket_rule: DENY_ALL
   *
   * .. attention::
   *  The first matched group wins. Once the request is matched into a bucket, matcher
   *  evaluation ends.
   *
   * Use ``on_no_match`` field to assign the catch-all bucket. If a request is not matched
   * into any bucket, and there's no  ``on_no_match`` field configured, the request will be
   * ALLOWED by default. It will NOT be reported to the RLQS server.
   *
   * Refer to :ref:`Unified Matcher API <envoy_v3_api_msg_.xds.type.matcher.v3.Matcher>`
   * documentation for more information on the matcher trees.
   */
  bucket_matchers?:
    | Matcher
    | undefined;
  /**
   * If set, this will enable -- but not necessarily enforce -- the rate limit for the given
   * fraction of requests.
   *
   * Defaults to 100% of requests.
   */
  filter_enabled?:
    | RuntimeFractionalPercent
    | undefined;
  /**
   * If set, this will enforce the rate limit decisions for the given fraction of requests.
   * For requests that are not enforced the filter will still obtain the quota and include it
   * in the load computation, however the request will always be allowed regardless of the outcome
   * of quota application. This allows validation or testing of the rate limiting service
   * infrastructure without disrupting existing traffic.
   *
   * Note: this only applies to the fraction of enabled requests.
   *
   * Defaults to 100% of requests.
   */
  filter_enforced?:
    | RuntimeFractionalPercent
    | undefined;
  /**
   * Specifies a list of HTTP headers that should be added to each request that
   * has been rate limited and is also forwarded upstream. This can only occur when the
   * filter is enabled but not enforced.
   */
  request_headers_to_add_when_not_enforced?: HeaderValueOption[] | undefined;
}

/**
 * Per-route and per-host configuration overrides. The more specific definition completely
 * overrides the less specific definition.
 */
export interface RateLimitQuotaOverride {
  $type: "envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaOverride";
  /**
   * The application domain to use when calling the service. This enables sharing the quota
   * server between different applications without fear of overlap.
   * E.g., "envoy".
   *
   * If empty, inherits the value from the less specific definition.
   */
  domain?:
    | string
    | undefined;
  /**
   * The match tree to use for grouping incoming requests into buckets.
   *
   * If set, fully overrides the bucket matchers provided on the less specific definition.
   * If not set, inherits the value from the less specific definition.
   *
   * See usage example: :ref:`RateLimitQuotaFilterConfig.bucket_matchers
   * <envoy_v3_api_field_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaFilterConfig.bucket_matchers>`.
   */
  bucket_matchers?: Matcher | undefined;
}

/**
 * Rate Limit Quota Bucket Settings to apply on the successful ``bucket_matchers`` match.
 *
 * Specify this message in the :ref:`Matcher.OnMatch.action
 * <envoy_v3_api_field_.xds.type.matcher.v3.Matcher.OnMatch.action>` field of the
 * ``bucket_matchers`` matcher tree to assign the matched requests to the Quota Bucket.
 * Usage example: :ref:`RateLimitQuotaFilterConfig.bucket_matchers
 * <envoy_v3_api_field_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaFilterConfig.bucket_matchers>`.
 * [#next-free-field: 6]
 */
export interface RateLimitQuotaBucketSettings {
  $type: "envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings";
  /**
   * ``BucketId`` builder.
   *
   * :ref:`BucketId <envoy_v3_api_msg_service.rate_limit_quota.v3.BucketId>` is a map from
   * the string key to the string value which serves as bucket identifier common for on
   * the control plane and the data plane.
   *
   * While ``BucketId`` is always static, ``BucketIdBuilder`` allows to populate map values
   * with the dynamic properties associated with the each individual request.
   *
   * Example 1: static fields only
   *
   * ``BucketIdBuilder``:
   *
   * .. validated-code-block:: yaml
   *   :type-name: envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.BucketIdBuilder
   *
   *   bucket_id_builder:
   *     name:
   *       string_value: my_bucket
   *     hello:
   *       string_value: world
   *
   * Produces the following ``BucketId`` for all requests:
   *
   * .. validated-code-block:: yaml
   *   :type-name: envoy.service.rate_limit_quota.v3.BucketId
   *
   *   bucket:
   *     name: my_bucket
   *     hello: world
   *
   * Example 2: static and dynamic fields
   *
   * .. validated-code-block:: yaml
   *   :type-name: envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.BucketIdBuilder
   *
   *   bucket_id_builder:
   *     name:
   *       string_value: my_bucket
   *     env:
   *       custom_value:
   *         typed_config:
   *           '@type': type.googleapis.com/envoy.type.matcher.v3.HttpRequestHeaderMatchInput
   *           header_name: environment
   *
   * In this example, the value of ``BucketId`` key ``env`` is substituted from the ``environment``
   * request header.
   *
   * This is equivalent to the following ``pseudo-code``:
   *
   * .. code-block:: yaml
   *
   *    name: 'my_bucket'
   *    env: $header['environment']
   *
   * For example, the request with the HTTP header ``env`` set to ``staging`` will produce
   * the following ``BucketId``:
   *
   * .. validated-code-block:: yaml
   *   :type-name: envoy.service.rate_limit_quota.v3.BucketId
   *
   *   bucket:
   *     name: my_bucket
   *     env: staging
   *
   * For the request with the HTTP header ``environment`` set to ``prod``, will produce:
   *
   * .. validated-code-block:: yaml
   *   :type-name: envoy.service.rate_limit_quota.v3.BucketId
   *
   *   bucket:
   *     name: my_bucket
   *     env: prod
   *
   * .. note::
   *   The order of ``BucketId`` keys do not matter. Buckets ``{ a: 'A', b: 'B' }`` and
   *   ``{ b: 'B', a: 'A' }`` are identical.
   *
   * If not set, requests will NOT be reported to the server, and will always limited
   * according to :ref:`no_assignment_behavior
   * <envoy_v3_api_field_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.no_assignment_behavior>`
   * configuration.
   */
  bucket_id_builder?:
    | RateLimitQuotaBucketSettings_BucketIdBuilder
    | undefined;
  /**
   * The interval at which the data plane (RLQS client) is to report quota usage for this bucket.
   *
   * When the first request is matched to a bucket with no assignment, the data plane is to report
   * the request immediately in the :ref:`RateLimitQuotaUsageReports
   * <envoy_v3_api_msg_service.rate_limit_quota.v3.RateLimitQuotaUsageReports>` message.
   * For the RLQS server, this signals that the data plane is now subscribed to
   * the quota assignments in this bucket, and will start sending the assignment as described in
   * the :ref:`RLQS documentation <envoy_v3_api_file_envoy/service/rate_limit_quota/v3/rlqs.proto>`.
   *
   * After sending the initial report, the data plane is to continue reporting the bucket usage with
   * the internal specified in this field.
   *
   * If for any reason RLQS client doesn't receive the initial assignment for the reported bucket,
   * the data plane will eventually consider the bucket abandoned and stop sending the usage
   * reports. This is explained in more details at :ref:`Rate Limit Quota Service (RLQS)
   * <envoy_v3_api_file_envoy/service/rate_limit_quota/v3/rlqs.proto>`.
   *
   * [#comment: 100000000 nanoseconds = 0.1 seconds]
   */
  reporting_interval?:
    | Duration
    | undefined;
  /**
   * Customize the deny response to the requests over the rate limit.
   * If not set, the filter will be configured as if an empty message is set,
   * and will behave according to the defaults specified in :ref:`DenyResponseSettings
   * <envoy_v3_api_msg_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.DenyResponseSettings>`.
   */
  deny_response_settings?:
    | RateLimitQuotaBucketSettings_DenyResponseSettings
    | undefined;
  /**
   * Configures the behavior in the "no assignment" state: after the first request has been
   * matched to the bucket, and before the the RLQS server returns the first quota assignment.
   *
   * If not set, the default behavior is to allow all requests.
   */
  no_assignment_behavior?:
    | RateLimitQuotaBucketSettings_NoAssignmentBehavior
    | undefined;
  /**
   * Configures the behavior in the "expired assignment" state: the bucket's assignment has expired,
   * and cannot be refreshed.
   *
   * If not set, the bucket is abandoned when its ``active`` assignment expires.
   * The process of abandoning the bucket, and restarting the subscription is described in the
   * :ref:`AbandonAction <envoy_v3_api_msg_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.AbandonAction>`
   * message.
   */
  expired_assignment_behavior?: RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior | undefined;
}

/**
 * Configures the behavior after the first request has been matched to the bucket, and before the
 * the RLQS server returns the first quota assignment.
 */
export interface RateLimitQuotaBucketSettings_NoAssignmentBehavior {
  $type: "envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.NoAssignmentBehavior";
  no_assignment_behavior?:
    | //
    /** Apply pre-configured rate limiting strategy until the server sends the first assignment. */
    { $case: "fallback_rate_limit"; fallback_rate_limit: RateLimitStrategy }
    | undefined;
}

/**
 * Specifies the behavior when the bucket's assignment has expired, and cannot be refreshed for
 * any reason.
 */
export interface RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior {
  $type: "envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.ExpiredAssignmentBehavior";
  /**
   * Limit the time :ref:`ExpiredAssignmentBehavior
   * <envoy_v3_api_msg_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.ExpiredAssignmentBehavior>`
   * is applied. If the server doesn't respond within this duration:
   *
   * 1. Selected ``ExpiredAssignmentBehavior`` is no longer applied.
   * 2. The bucket is abandoned. The process of abandoning the bucket is described in the
   *    :ref:`AbandonAction <envoy_v3_api_msg_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.AbandonAction>`
   *    message.
   * 3. If a new request is matched into the bucket that has become abandoned,
   *    the data plane restarts the subscription to the bucket. The process of restarting the
   *    subscription is described in the :ref:`AbandonAction
   *    <envoy_v3_api_msg_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.AbandonAction>`
   *    message.
   *
   * If not set, defaults to zero, and the bucket is abandoned immediately.
   */
  expired_assignment_behavior_timeout?: Duration | undefined;
  expired_assignment_behavior?:
    | //
    /**
     * Apply the rate limiting strategy to all requests matched into the bucket until the RLQS
     * server sends a new assignment, or the :ref:`expired_assignment_behavior_timeout
     * <envoy_v3_api_field_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.ExpiredAssignmentBehavior.expired_assignment_behavior_timeout>`
     * runs out.
     */
    { $case: "fallback_rate_limit"; fallback_rate_limit: RateLimitStrategy }
    | //
    /**
     * Reuse the last ``active`` assignment until the RLQS server sends a new assignment, or the
     * :ref:`expired_assignment_behavior_timeout
     * <envoy_v3_api_field_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.ExpiredAssignmentBehavior.expired_assignment_behavior_timeout>`
     * runs out.
     */
    {
      $case: "reuse_last_assignment";
      reuse_last_assignment: RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior_ReuseLastAssignment;
    }
    | undefined;
}

/**
 * Reuse the last known quota assignment, effectively extending it for the duration
 * specified in the :ref:`expired_assignment_behavior_timeout
 * <envoy_v3_api_field_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.ExpiredAssignmentBehavior.expired_assignment_behavior_timeout>`
 * field.
 */
export interface RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior_ReuseLastAssignment {
  $type:
    "envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.ExpiredAssignmentBehavior.ReuseLastAssignment";
}

/** Customize the deny response to the requests over the rate limit. */
export interface RateLimitQuotaBucketSettings_DenyResponseSettings {
  $type: "envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.DenyResponseSettings";
  /**
   * HTTP response code to deny for HTTP requests (gRPC excluded).
   * Defaults to 429 (:ref:`StatusCode.TooManyRequests<envoy_v3_api_enum_value_type.v3.StatusCode.TooManyRequests>`).
   */
  http_status?:
    | HttpStatus
    | undefined;
  /**
   * HTTP response body used to deny for HTTP requests (gRPC excluded).
   * If not set, an empty body is returned.
   */
  http_body?:
    | Uint8Array
    | undefined;
  /**
   * Configure the deny response for gRPC requests over the rate limit.
   * Allows to specify the `RPC status code
   * <https://cloud.google.com/natural-language/docs/reference/rpc/google.rpc#google.rpc.Code>`_,
   * and the error message.
   * Defaults to the Status with the RPC Code ``UNAVAILABLE`` and empty message.
   *
   * To identify gRPC requests, Envoy checks that the ``Content-Type`` header is
   * ``application/grpc``, or one of the various ``application/grpc+`` values.
   *
   * .. note::
   *   The HTTP code for a gRPC response is always 200.
   */
  grpc_status?:
    | Status
    | undefined;
  /**
   * Specifies a list of HTTP headers that should be added to each response for requests that
   * have been rate limited. Applies both to plain HTTP, and gRPC requests.
   * The headers are added even when the rate limit quota was not enforced.
   */
  response_headers_to_add?: HeaderValueOption[] | undefined;
}

/**
 * ``BucketIdBuilder`` makes it possible to build :ref:`BucketId
 * <envoy_v3_api_msg_service.rate_limit_quota.v3.BucketId>` with values substituted
 * from the dynamic properties associated with each individual request. See usage examples in
 * the docs to :ref:`bucket_id_builder
 * <envoy_v3_api_field_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.bucket_id_builder>`
 * field.
 */
export interface RateLimitQuotaBucketSettings_BucketIdBuilder {
  $type: "envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.BucketIdBuilder";
  /**
   * The map translated into the ``BucketId`` map.
   *
   * The ``string key`` of this map and becomes the key of ``BucketId`` map as is.
   *
   * The ``ValueBuilder value`` for the key can be:
   *
   * * static ``StringValue string_value`` — becomes the value in the ``BucketId`` map as is.
   * * dynamic ``TypedExtensionConfig custom_value`` — evaluated for each request. Must produce
   *   a string output, which becomes the value in the the ``BucketId`` map.
   *
   * See usage examples in the docs to :ref:`bucket_id_builder
   * <envoy_v3_api_field_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.bucket_id_builder>`
   * field.
   */
  bucket_id_builder?: Map<string, RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder> | undefined;
}

/**
 * Produces the value of the :ref:`BucketId
 * <envoy_v3_api_msg_service.rate_limit_quota.v3.BucketId>` map.
 */
export interface RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder {
  $type: "envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.BucketIdBuilder.ValueBuilder";
  value_specifier?:
    | //
    /**
     * Static string value — becomes the value in the :ref:`BucketId
     * <envoy_v3_api_msg_service.rate_limit_quota.v3.BucketId>` map as is.
     */
    { $case: "string_value"; string_value: string }
    | //
    /**
     * Dynamic value — evaluated for each request. Must produce a string output, which becomes
     * the value in the :ref:`BucketId <envoy_v3_api_msg_service.rate_limit_quota.v3.BucketId>`
     * map. For example, extensions with the ``envoy.matching.http.input`` category can be used.
     */
    { $case: "custom_value"; custom_value: TypedExtensionConfig }
    | undefined;
}

export interface RateLimitQuotaBucketSettings_BucketIdBuilder_BucketIdBuilderEntry {
  $type:
    "envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.BucketIdBuilder.BucketIdBuilderEntry";
  key: string;
  value?: RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder | undefined;
}

function createBaseRateLimitQuotaFilterConfig(): RateLimitQuotaFilterConfig {
  return { $type: "envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaFilterConfig" };
}

export const RateLimitQuotaFilterConfig: MessageFns<
  RateLimitQuotaFilterConfig,
  "envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaFilterConfig"
> = {
  $type: "envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaFilterConfig" as const,

  encode(message: RateLimitQuotaFilterConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rlqs_server !== undefined) {
      GrpcService.encode(message.rlqs_server, writer.uint32(10).fork()).join();
    }
    if (message.domain !== undefined && message.domain !== "") {
      writer.uint32(18).string(message.domain);
    }
    if (message.bucket_matchers !== undefined) {
      Matcher.encode(message.bucket_matchers, writer.uint32(26).fork()).join();
    }
    if (message.filter_enabled !== undefined) {
      RuntimeFractionalPercent.encode(message.filter_enabled, writer.uint32(34).fork()).join();
    }
    if (message.filter_enforced !== undefined) {
      RuntimeFractionalPercent.encode(message.filter_enforced, writer.uint32(42).fork()).join();
    }
    if (
      message.request_headers_to_add_when_not_enforced !== undefined &&
      message.request_headers_to_add_when_not_enforced.length !== 0
    ) {
      for (const v of message.request_headers_to_add_when_not_enforced) {
        HeaderValueOption.encode(v!, writer.uint32(50).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimitQuotaFilterConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimitQuotaFilterConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rlqs_server = GrpcService.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.domain = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bucket_matchers = Matcher.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.filter_enabled = RuntimeFractionalPercent.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.filter_enforced = RuntimeFractionalPercent.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          if (message.request_headers_to_add_when_not_enforced === undefined) {
            message.request_headers_to_add_when_not_enforced = [];
          }
          const el = HeaderValueOption.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.request_headers_to_add_when_not_enforced!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimitQuotaFilterConfig {
    return {
      $type: RateLimitQuotaFilterConfig.$type,
      rlqs_server: isSet(object.rlqs_server) ? GrpcService.fromJSON(object.rlqs_server) : undefined,
      domain: isSet(object.domain) ? globalThis.String(object.domain) : undefined,
      bucket_matchers: isSet(object.bucket_matchers) ? Matcher.fromJSON(object.bucket_matchers) : undefined,
      filter_enabled: isSet(object.filter_enabled)
        ? RuntimeFractionalPercent.fromJSON(object.filter_enabled)
        : undefined,
      filter_enforced: isSet(object.filter_enforced)
        ? RuntimeFractionalPercent.fromJSON(object.filter_enforced)
        : undefined,
      request_headers_to_add_when_not_enforced:
        globalThis.Array.isArray(object?.request_headers_to_add_when_not_enforced)
          ? object.request_headers_to_add_when_not_enforced.map((e: any) => HeaderValueOption.fromJSON(e))
          : undefined,
    };
  },

  toJSON(message: RateLimitQuotaFilterConfig): unknown {
    const obj: any = {};
    if (message.rlqs_server !== undefined) {
      obj.rlqs_server = GrpcService.toJSON(message.rlqs_server);
    }
    if (message.domain !== undefined) {
      obj.domain = message.domain;
    }
    if (message.bucket_matchers !== undefined) {
      obj.bucket_matchers = Matcher.toJSON(message.bucket_matchers);
    }
    if (message.filter_enabled !== undefined) {
      obj.filter_enabled = RuntimeFractionalPercent.toJSON(message.filter_enabled);
    }
    if (message.filter_enforced !== undefined) {
      obj.filter_enforced = RuntimeFractionalPercent.toJSON(message.filter_enforced);
    }
    if (message.request_headers_to_add_when_not_enforced?.length) {
      obj.request_headers_to_add_when_not_enforced = message.request_headers_to_add_when_not_enforced.map((e) =>
        HeaderValueOption.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimitQuotaFilterConfig>, I>>(base?: I): RateLimitQuotaFilterConfig {
    return RateLimitQuotaFilterConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimitQuotaFilterConfig>, I>>(object: I): RateLimitQuotaFilterConfig {
    const message = createBaseRateLimitQuotaFilterConfig();
    message.rlqs_server = (object.rlqs_server !== undefined && object.rlqs_server !== null)
      ? GrpcService.fromPartial(object.rlqs_server)
      : undefined;
    message.domain = object.domain ?? undefined;
    message.bucket_matchers = (object.bucket_matchers !== undefined && object.bucket_matchers !== null)
      ? Matcher.fromPartial(object.bucket_matchers)
      : undefined;
    message.filter_enabled = (object.filter_enabled !== undefined && object.filter_enabled !== null)
      ? RuntimeFractionalPercent.fromPartial(object.filter_enabled)
      : undefined;
    message.filter_enforced = (object.filter_enforced !== undefined && object.filter_enforced !== null)
      ? RuntimeFractionalPercent.fromPartial(object.filter_enforced)
      : undefined;
    message.request_headers_to_add_when_not_enforced =
      object.request_headers_to_add_when_not_enforced?.map((e) => HeaderValueOption.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(RateLimitQuotaFilterConfig.$type, RateLimitQuotaFilterConfig);

function createBaseRateLimitQuotaOverride(): RateLimitQuotaOverride {
  return { $type: "envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaOverride" };
}

export const RateLimitQuotaOverride: MessageFns<
  RateLimitQuotaOverride,
  "envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaOverride"
> = {
  $type: "envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaOverride" as const,

  encode(message: RateLimitQuotaOverride, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.domain !== undefined && message.domain !== "") {
      writer.uint32(10).string(message.domain);
    }
    if (message.bucket_matchers !== undefined) {
      Matcher.encode(message.bucket_matchers, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimitQuotaOverride {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimitQuotaOverride();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.domain = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bucket_matchers = Matcher.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimitQuotaOverride {
    return {
      $type: RateLimitQuotaOverride.$type,
      domain: isSet(object.domain) ? globalThis.String(object.domain) : undefined,
      bucket_matchers: isSet(object.bucket_matchers) ? Matcher.fromJSON(object.bucket_matchers) : undefined,
    };
  },

  toJSON(message: RateLimitQuotaOverride): unknown {
    const obj: any = {};
    if (message.domain !== undefined) {
      obj.domain = message.domain;
    }
    if (message.bucket_matchers !== undefined) {
      obj.bucket_matchers = Matcher.toJSON(message.bucket_matchers);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimitQuotaOverride>, I>>(base?: I): RateLimitQuotaOverride {
    return RateLimitQuotaOverride.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimitQuotaOverride>, I>>(object: I): RateLimitQuotaOverride {
    const message = createBaseRateLimitQuotaOverride();
    message.domain = object.domain ?? undefined;
    message.bucket_matchers = (object.bucket_matchers !== undefined && object.bucket_matchers !== null)
      ? Matcher.fromPartial(object.bucket_matchers)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(RateLimitQuotaOverride.$type, RateLimitQuotaOverride);

function createBaseRateLimitQuotaBucketSettings(): RateLimitQuotaBucketSettings {
  return { $type: "envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings" };
}

export const RateLimitQuotaBucketSettings: MessageFns<
  RateLimitQuotaBucketSettings,
  "envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings"
> = {
  $type: "envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings" as const,

  encode(message: RateLimitQuotaBucketSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bucket_id_builder !== undefined) {
      RateLimitQuotaBucketSettings_BucketIdBuilder.encode(message.bucket_id_builder, writer.uint32(10).fork()).join();
    }
    if (message.reporting_interval !== undefined) {
      Duration.encode(message.reporting_interval, writer.uint32(18).fork()).join();
    }
    if (message.deny_response_settings !== undefined) {
      RateLimitQuotaBucketSettings_DenyResponseSettings.encode(message.deny_response_settings, writer.uint32(26).fork())
        .join();
    }
    if (message.no_assignment_behavior !== undefined) {
      RateLimitQuotaBucketSettings_NoAssignmentBehavior.encode(message.no_assignment_behavior, writer.uint32(34).fork())
        .join();
    }
    if (message.expired_assignment_behavior !== undefined) {
      RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior.encode(
        message.expired_assignment_behavior,
        writer.uint32(42).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimitQuotaBucketSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimitQuotaBucketSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bucket_id_builder = RateLimitQuotaBucketSettings_BucketIdBuilder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reporting_interval = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deny_response_settings = RateLimitQuotaBucketSettings_DenyResponseSettings.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.no_assignment_behavior = RateLimitQuotaBucketSettings_NoAssignmentBehavior.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.expired_assignment_behavior = RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimitQuotaBucketSettings {
    return {
      $type: RateLimitQuotaBucketSettings.$type,
      bucket_id_builder: isSet(object.bucket_id_builder)
        ? RateLimitQuotaBucketSettings_BucketIdBuilder.fromJSON(object.bucket_id_builder)
        : undefined,
      reporting_interval: isSet(object.reporting_interval) ? Duration.fromJSON(object.reporting_interval) : undefined,
      deny_response_settings: isSet(object.deny_response_settings)
        ? RateLimitQuotaBucketSettings_DenyResponseSettings.fromJSON(object.deny_response_settings)
        : undefined,
      no_assignment_behavior: isSet(object.no_assignment_behavior)
        ? RateLimitQuotaBucketSettings_NoAssignmentBehavior.fromJSON(object.no_assignment_behavior)
        : undefined,
      expired_assignment_behavior: isSet(object.expired_assignment_behavior)
        ? RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior.fromJSON(object.expired_assignment_behavior)
        : undefined,
    };
  },

  toJSON(message: RateLimitQuotaBucketSettings): unknown {
    const obj: any = {};
    if (message.bucket_id_builder !== undefined) {
      obj.bucket_id_builder = RateLimitQuotaBucketSettings_BucketIdBuilder.toJSON(message.bucket_id_builder);
    }
    if (message.reporting_interval !== undefined) {
      obj.reporting_interval = Duration.toJSON(message.reporting_interval);
    }
    if (message.deny_response_settings !== undefined) {
      obj.deny_response_settings = RateLimitQuotaBucketSettings_DenyResponseSettings.toJSON(
        message.deny_response_settings,
      );
    }
    if (message.no_assignment_behavior !== undefined) {
      obj.no_assignment_behavior = RateLimitQuotaBucketSettings_NoAssignmentBehavior.toJSON(
        message.no_assignment_behavior,
      );
    }
    if (message.expired_assignment_behavior !== undefined) {
      obj.expired_assignment_behavior = RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior.toJSON(
        message.expired_assignment_behavior,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimitQuotaBucketSettings>, I>>(base?: I): RateLimitQuotaBucketSettings {
    return RateLimitQuotaBucketSettings.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimitQuotaBucketSettings>, I>>(object: I): RateLimitQuotaBucketSettings {
    const message = createBaseRateLimitQuotaBucketSettings();
    message.bucket_id_builder = (object.bucket_id_builder !== undefined && object.bucket_id_builder !== null)
      ? RateLimitQuotaBucketSettings_BucketIdBuilder.fromPartial(object.bucket_id_builder)
      : undefined;
    message.reporting_interval = (object.reporting_interval !== undefined && object.reporting_interval !== null)
      ? Duration.fromPartial(object.reporting_interval)
      : undefined;
    message.deny_response_settings =
      (object.deny_response_settings !== undefined && object.deny_response_settings !== null)
        ? RateLimitQuotaBucketSettings_DenyResponseSettings.fromPartial(object.deny_response_settings)
        : undefined;
    message.no_assignment_behavior =
      (object.no_assignment_behavior !== undefined && object.no_assignment_behavior !== null)
        ? RateLimitQuotaBucketSettings_NoAssignmentBehavior.fromPartial(object.no_assignment_behavior)
        : undefined;
    message.expired_assignment_behavior =
      (object.expired_assignment_behavior !== undefined && object.expired_assignment_behavior !== null)
        ? RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior.fromPartial(object.expired_assignment_behavior)
        : undefined;
    return message;
  },
};

messageTypeRegistry.set(RateLimitQuotaBucketSettings.$type, RateLimitQuotaBucketSettings);

function createBaseRateLimitQuotaBucketSettings_NoAssignmentBehavior(): RateLimitQuotaBucketSettings_NoAssignmentBehavior {
  return {
    $type: "envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.NoAssignmentBehavior",
    no_assignment_behavior: undefined,
  };
}

export const RateLimitQuotaBucketSettings_NoAssignmentBehavior: MessageFns<
  RateLimitQuotaBucketSettings_NoAssignmentBehavior,
  "envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.NoAssignmentBehavior"
> = {
  $type: "envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.NoAssignmentBehavior" as const,

  encode(
    message: RateLimitQuotaBucketSettings_NoAssignmentBehavior,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    switch (message.no_assignment_behavior?.$case) {
      case "fallback_rate_limit":
        RateLimitStrategy.encode(message.no_assignment_behavior.fallback_rate_limit, writer.uint32(10).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimitQuotaBucketSettings_NoAssignmentBehavior {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimitQuotaBucketSettings_NoAssignmentBehavior();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.no_assignment_behavior = {
            $case: "fallback_rate_limit",
            fallback_rate_limit: RateLimitStrategy.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimitQuotaBucketSettings_NoAssignmentBehavior {
    return {
      $type: RateLimitQuotaBucketSettings_NoAssignmentBehavior.$type,
      no_assignment_behavior: isSet(object.fallback_rate_limit)
        ? { $case: "fallback_rate_limit", fallback_rate_limit: RateLimitStrategy.fromJSON(object.fallback_rate_limit) }
        : undefined,
    };
  },

  toJSON(message: RateLimitQuotaBucketSettings_NoAssignmentBehavior): unknown {
    const obj: any = {};
    if (message.no_assignment_behavior?.$case === "fallback_rate_limit") {
      obj.fallback_rate_limit = RateLimitStrategy.toJSON(message.no_assignment_behavior.fallback_rate_limit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimitQuotaBucketSettings_NoAssignmentBehavior>, I>>(
    base?: I,
  ): RateLimitQuotaBucketSettings_NoAssignmentBehavior {
    return RateLimitQuotaBucketSettings_NoAssignmentBehavior.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimitQuotaBucketSettings_NoAssignmentBehavior>, I>>(
    object: I,
  ): RateLimitQuotaBucketSettings_NoAssignmentBehavior {
    const message = createBaseRateLimitQuotaBucketSettings_NoAssignmentBehavior();
    if (
      object.no_assignment_behavior?.$case === "fallback_rate_limit" &&
      object.no_assignment_behavior?.fallback_rate_limit !== undefined &&
      object.no_assignment_behavior?.fallback_rate_limit !== null
    ) {
      message.no_assignment_behavior = {
        $case: "fallback_rate_limit",
        fallback_rate_limit: RateLimitStrategy.fromPartial(object.no_assignment_behavior.fallback_rate_limit),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(
  RateLimitQuotaBucketSettings_NoAssignmentBehavior.$type,
  RateLimitQuotaBucketSettings_NoAssignmentBehavior,
);

function createBaseRateLimitQuotaBucketSettings_ExpiredAssignmentBehavior(): RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior {
  return {
    $type: "envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.ExpiredAssignmentBehavior",
    expired_assignment_behavior: undefined,
  };
}

export const RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior: MessageFns<
  RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior,
  "envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.ExpiredAssignmentBehavior"
> = {
  $type:
    "envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.ExpiredAssignmentBehavior" as const,

  encode(
    message: RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.expired_assignment_behavior_timeout !== undefined) {
      Duration.encode(message.expired_assignment_behavior_timeout, writer.uint32(10).fork()).join();
    }
    switch (message.expired_assignment_behavior?.$case) {
      case "fallback_rate_limit":
        RateLimitStrategy.encode(message.expired_assignment_behavior.fallback_rate_limit, writer.uint32(18).fork())
          .join();
        break;
      case "reuse_last_assignment":
        RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior_ReuseLastAssignment.encode(
          message.expired_assignment_behavior.reuse_last_assignment,
          writer.uint32(26).fork(),
        ).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimitQuotaBucketSettings_ExpiredAssignmentBehavior();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.expired_assignment_behavior_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.expired_assignment_behavior = {
            $case: "fallback_rate_limit",
            fallback_rate_limit: RateLimitStrategy.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.expired_assignment_behavior = {
            $case: "reuse_last_assignment",
            reuse_last_assignment: RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior_ReuseLastAssignment.decode(
              reader,
              reader.uint32(),
            ),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior {
    return {
      $type: RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior.$type,
      expired_assignment_behavior_timeout: isSet(object.expired_assignment_behavior_timeout)
        ? Duration.fromJSON(object.expired_assignment_behavior_timeout)
        : undefined,
      expired_assignment_behavior: isSet(object.fallback_rate_limit)
        ? { $case: "fallback_rate_limit", fallback_rate_limit: RateLimitStrategy.fromJSON(object.fallback_rate_limit) }
        : isSet(object.reuse_last_assignment)
        ? {
          $case: "reuse_last_assignment",
          reuse_last_assignment: RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior_ReuseLastAssignment.fromJSON(
            object.reuse_last_assignment,
          ),
        }
        : undefined,
    };
  },

  toJSON(message: RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior): unknown {
    const obj: any = {};
    if (message.expired_assignment_behavior_timeout !== undefined) {
      obj.expired_assignment_behavior_timeout = Duration.toJSON(message.expired_assignment_behavior_timeout);
    }
    if (message.expired_assignment_behavior?.$case === "fallback_rate_limit") {
      obj.fallback_rate_limit = RateLimitStrategy.toJSON(message.expired_assignment_behavior.fallback_rate_limit);
    }
    if (message.expired_assignment_behavior?.$case === "reuse_last_assignment") {
      obj.reuse_last_assignment = RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior_ReuseLastAssignment.toJSON(
        message.expired_assignment_behavior.reuse_last_assignment,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior>, I>>(
    base?: I,
  ): RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior {
    return RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior>, I>>(
    object: I,
  ): RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior {
    const message = createBaseRateLimitQuotaBucketSettings_ExpiredAssignmentBehavior();
    message.expired_assignment_behavior_timeout =
      (object.expired_assignment_behavior_timeout !== undefined && object.expired_assignment_behavior_timeout !== null)
        ? Duration.fromPartial(object.expired_assignment_behavior_timeout)
        : undefined;
    if (
      object.expired_assignment_behavior?.$case === "fallback_rate_limit" &&
      object.expired_assignment_behavior?.fallback_rate_limit !== undefined &&
      object.expired_assignment_behavior?.fallback_rate_limit !== null
    ) {
      message.expired_assignment_behavior = {
        $case: "fallback_rate_limit",
        fallback_rate_limit: RateLimitStrategy.fromPartial(object.expired_assignment_behavior.fallback_rate_limit),
      };
    }
    if (
      object.expired_assignment_behavior?.$case === "reuse_last_assignment" &&
      object.expired_assignment_behavior?.reuse_last_assignment !== undefined &&
      object.expired_assignment_behavior?.reuse_last_assignment !== null
    ) {
      message.expired_assignment_behavior = {
        $case: "reuse_last_assignment",
        reuse_last_assignment: RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior_ReuseLastAssignment.fromPartial(
          object.expired_assignment_behavior.reuse_last_assignment,
        ),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(
  RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior.$type,
  RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior,
);

function createBaseRateLimitQuotaBucketSettings_ExpiredAssignmentBehavior_ReuseLastAssignment(): RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior_ReuseLastAssignment {
  return {
    $type:
      "envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.ExpiredAssignmentBehavior.ReuseLastAssignment",
  };
}

export const RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior_ReuseLastAssignment: MessageFns<
  RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior_ReuseLastAssignment,
  "envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.ExpiredAssignmentBehavior.ReuseLastAssignment"
> = {
  $type:
    "envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.ExpiredAssignmentBehavior.ReuseLastAssignment" as const,

  encode(
    _: RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior_ReuseLastAssignment,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior_ReuseLastAssignment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimitQuotaBucketSettings_ExpiredAssignmentBehavior_ReuseLastAssignment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior_ReuseLastAssignment {
    return { $type: RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior_ReuseLastAssignment.$type };
  },

  toJSON(_: RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior_ReuseLastAssignment): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior_ReuseLastAssignment>, I>>(
    base?: I,
  ): RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior_ReuseLastAssignment {
    return RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior_ReuseLastAssignment.fromPartial(base ?? ({} as any));
  },
  fromPartial<
    I extends Exact<DeepPartial<RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior_ReuseLastAssignment>, I>,
  >(_: I): RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior_ReuseLastAssignment {
    const message = createBaseRateLimitQuotaBucketSettings_ExpiredAssignmentBehavior_ReuseLastAssignment();
    return message;
  },
};

messageTypeRegistry.set(
  RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior_ReuseLastAssignment.$type,
  RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior_ReuseLastAssignment,
);

function createBaseRateLimitQuotaBucketSettings_DenyResponseSettings(): RateLimitQuotaBucketSettings_DenyResponseSettings {
  return {
    $type: "envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.DenyResponseSettings",
  };
}

export const RateLimitQuotaBucketSettings_DenyResponseSettings: MessageFns<
  RateLimitQuotaBucketSettings_DenyResponseSettings,
  "envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.DenyResponseSettings"
> = {
  $type: "envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.DenyResponseSettings" as const,

  encode(
    message: RateLimitQuotaBucketSettings_DenyResponseSettings,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.http_status !== undefined) {
      HttpStatus.encode(message.http_status, writer.uint32(10).fork()).join();
    }
    if (message.http_body !== undefined) {
      BytesValue.encode({ $type: "google.protobuf.BytesValue", value: message.http_body! }, writer.uint32(18).fork())
        .join();
    }
    if (message.grpc_status !== undefined) {
      Status.encode(message.grpc_status, writer.uint32(26).fork()).join();
    }
    if (message.response_headers_to_add !== undefined && message.response_headers_to_add.length !== 0) {
      for (const v of message.response_headers_to_add) {
        HeaderValueOption.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimitQuotaBucketSettings_DenyResponseSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimitQuotaBucketSettings_DenyResponseSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.http_status = HttpStatus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.http_body = BytesValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.grpc_status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          if (message.response_headers_to_add === undefined) {
            message.response_headers_to_add = [];
          }
          const el = HeaderValueOption.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.response_headers_to_add!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimitQuotaBucketSettings_DenyResponseSettings {
    return {
      $type: RateLimitQuotaBucketSettings_DenyResponseSettings.$type,
      http_status: isSet(object.http_status) ? HttpStatus.fromJSON(object.http_status) : undefined,
      http_body: isSet(object.http_body) ? new Uint8Array(object.http_body) : undefined,
      grpc_status: isSet(object.grpc_status) ? Status.fromJSON(object.grpc_status) : undefined,
      response_headers_to_add: globalThis.Array.isArray(object?.response_headers_to_add)
        ? object.response_headers_to_add.map((e: any) => HeaderValueOption.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: RateLimitQuotaBucketSettings_DenyResponseSettings): unknown {
    const obj: any = {};
    if (message.http_status !== undefined) {
      obj.http_status = HttpStatus.toJSON(message.http_status);
    }
    if (message.http_body !== undefined) {
      obj.http_body = message.http_body;
    }
    if (message.grpc_status !== undefined) {
      obj.grpc_status = Status.toJSON(message.grpc_status);
    }
    if (message.response_headers_to_add?.length) {
      obj.response_headers_to_add = message.response_headers_to_add.map((e) => HeaderValueOption.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimitQuotaBucketSettings_DenyResponseSettings>, I>>(
    base?: I,
  ): RateLimitQuotaBucketSettings_DenyResponseSettings {
    return RateLimitQuotaBucketSettings_DenyResponseSettings.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimitQuotaBucketSettings_DenyResponseSettings>, I>>(
    object: I,
  ): RateLimitQuotaBucketSettings_DenyResponseSettings {
    const message = createBaseRateLimitQuotaBucketSettings_DenyResponseSettings();
    message.http_status = (object.http_status !== undefined && object.http_status !== null)
      ? HttpStatus.fromPartial(object.http_status)
      : undefined;
    message.http_body = object.http_body ?? undefined;
    message.grpc_status = (object.grpc_status !== undefined && object.grpc_status !== null)
      ? Status.fromPartial(object.grpc_status)
      : undefined;
    message.response_headers_to_add = object.response_headers_to_add?.map((e) => HeaderValueOption.fromPartial(e)) ||
      undefined;
    return message;
  },
};

messageTypeRegistry.set(
  RateLimitQuotaBucketSettings_DenyResponseSettings.$type,
  RateLimitQuotaBucketSettings_DenyResponseSettings,
);

function createBaseRateLimitQuotaBucketSettings_BucketIdBuilder(): RateLimitQuotaBucketSettings_BucketIdBuilder {
  return { $type: "envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.BucketIdBuilder" };
}

export const RateLimitQuotaBucketSettings_BucketIdBuilder: MessageFns<
  RateLimitQuotaBucketSettings_BucketIdBuilder,
  "envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.BucketIdBuilder"
> = {
  $type: "envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.BucketIdBuilder" as const,

  encode(
    message: RateLimitQuotaBucketSettings_BucketIdBuilder,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    (message.bucket_id_builder || new Map()).forEach((value, key) => {
      RateLimitQuotaBucketSettings_BucketIdBuilder_BucketIdBuilderEntry.encode({
        $type:
          "envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.BucketIdBuilder.BucketIdBuilderEntry",
        key: key as any,
        value,
      }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimitQuotaBucketSettings_BucketIdBuilder {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimitQuotaBucketSettings_BucketIdBuilder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = RateLimitQuotaBucketSettings_BucketIdBuilder_BucketIdBuilderEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry1.value !== undefined) {
            if (message.bucket_id_builder === undefined) {
              message.bucket_id_builder = new Map();
            }
            message.bucket_id_builder!.set(entry1.key, entry1.value);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimitQuotaBucketSettings_BucketIdBuilder {
    return {
      $type: RateLimitQuotaBucketSettings_BucketIdBuilder.$type,
      bucket_id_builder: isObject(object.bucket_id_builder)
        ? Object.entries(object.bucket_id_builder).reduce<
          Map<string, RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder>
        >((acc, [key, value]) => {
          acc.set(key, RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder.fromJSON(value));
          return acc;
        }, new Map())
        : undefined,
    };
  },

  toJSON(message: RateLimitQuotaBucketSettings_BucketIdBuilder): unknown {
    const obj: any = {};
    if (message.bucket_id_builder?.size) {
      obj.bucket_id_builder = {};
      message.bucket_id_builder.forEach((v, k) => {
        obj.bucket_id_builder[k] = RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder.toJSON(v);
      });
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimitQuotaBucketSettings_BucketIdBuilder>, I>>(
    base?: I,
  ): RateLimitQuotaBucketSettings_BucketIdBuilder {
    return RateLimitQuotaBucketSettings_BucketIdBuilder.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimitQuotaBucketSettings_BucketIdBuilder>, I>>(
    object: I,
  ): RateLimitQuotaBucketSettings_BucketIdBuilder {
    const message = createBaseRateLimitQuotaBucketSettings_BucketIdBuilder();
    message.bucket_id_builder = (object.bucket_id_builder === undefined || object.bucket_id_builder === null)
      ? undefined
      : (() => {
        const m = new Map();
        (object.bucket_id_builder as Map<string, RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder> ??
          new Map()).forEach((value, key) => {
            if (value !== undefined) {
              m.set(key, RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder.fromPartial(value));
            }
          });
        return m;
      })();
    return message;
  },
};

messageTypeRegistry.set(
  RateLimitQuotaBucketSettings_BucketIdBuilder.$type,
  RateLimitQuotaBucketSettings_BucketIdBuilder,
);

function createBaseRateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder(): RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder {
  return {
    $type:
      "envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.BucketIdBuilder.ValueBuilder",
    value_specifier: undefined,
  };
}

export const RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder: MessageFns<
  RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder,
  "envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.BucketIdBuilder.ValueBuilder"
> = {
  $type:
    "envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.BucketIdBuilder.ValueBuilder" as const,

  encode(
    message: RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    switch (message.value_specifier?.$case) {
      case "string_value":
        writer.uint32(10).string(message.value_specifier.string_value);
        break;
      case "custom_value":
        TypedExtensionConfig.encode(message.value_specifier.custom_value, writer.uint32(18).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value_specifier = { $case: "string_value", string_value: reader.string() };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value_specifier = {
            $case: "custom_value",
            custom_value: TypedExtensionConfig.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder {
    return {
      $type: RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder.$type,
      value_specifier: isSet(object.string_value)
        ? { $case: "string_value", string_value: globalThis.String(object.string_value) }
        : isSet(object.custom_value)
        ? { $case: "custom_value", custom_value: TypedExtensionConfig.fromJSON(object.custom_value) }
        : undefined,
    };
  },

  toJSON(message: RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder): unknown {
    const obj: any = {};
    if (message.value_specifier?.$case === "string_value") {
      obj.string_value = message.value_specifier.string_value;
    }
    if (message.value_specifier?.$case === "custom_value") {
      obj.custom_value = TypedExtensionConfig.toJSON(message.value_specifier.custom_value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder>, I>>(
    base?: I,
  ): RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder {
    return RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder>, I>>(
    object: I,
  ): RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder {
    const message = createBaseRateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder();
    if (
      object.value_specifier?.$case === "string_value" &&
      object.value_specifier?.string_value !== undefined &&
      object.value_specifier?.string_value !== null
    ) {
      message.value_specifier = { $case: "string_value", string_value: object.value_specifier.string_value };
    }
    if (
      object.value_specifier?.$case === "custom_value" &&
      object.value_specifier?.custom_value !== undefined &&
      object.value_specifier?.custom_value !== null
    ) {
      message.value_specifier = {
        $case: "custom_value",
        custom_value: TypedExtensionConfig.fromPartial(object.value_specifier.custom_value),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(
  RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder.$type,
  RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder,
);

function createBaseRateLimitQuotaBucketSettings_BucketIdBuilder_BucketIdBuilderEntry(): RateLimitQuotaBucketSettings_BucketIdBuilder_BucketIdBuilderEntry {
  return {
    $type:
      "envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.BucketIdBuilder.BucketIdBuilderEntry",
    key: "",
  };
}

export const RateLimitQuotaBucketSettings_BucketIdBuilder_BucketIdBuilderEntry: MessageFns<
  RateLimitQuotaBucketSettings_BucketIdBuilder_BucketIdBuilderEntry,
  "envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.BucketIdBuilder.BucketIdBuilderEntry"
> = {
  $type:
    "envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.BucketIdBuilder.BucketIdBuilderEntry" as const,

  encode(
    message: RateLimitQuotaBucketSettings_BucketIdBuilder_BucketIdBuilderEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): RateLimitQuotaBucketSettings_BucketIdBuilder_BucketIdBuilderEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimitQuotaBucketSettings_BucketIdBuilder_BucketIdBuilderEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimitQuotaBucketSettings_BucketIdBuilder_BucketIdBuilderEntry {
    return {
      $type: RateLimitQuotaBucketSettings_BucketIdBuilder_BucketIdBuilderEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value)
        ? RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder.fromJSON(object.value)
        : undefined,
    };
  },

  toJSON(message: RateLimitQuotaBucketSettings_BucketIdBuilder_BucketIdBuilderEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimitQuotaBucketSettings_BucketIdBuilder_BucketIdBuilderEntry>, I>>(
    base?: I,
  ): RateLimitQuotaBucketSettings_BucketIdBuilder_BucketIdBuilderEntry {
    return RateLimitQuotaBucketSettings_BucketIdBuilder_BucketIdBuilderEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimitQuotaBucketSettings_BucketIdBuilder_BucketIdBuilderEntry>, I>>(
    object: I,
  ): RateLimitQuotaBucketSettings_BucketIdBuilder_BucketIdBuilderEntry {
    const message = createBaseRateLimitQuotaBucketSettings_BucketIdBuilder_BucketIdBuilderEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder.fromPartial(object.value)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(
  RateLimitQuotaBucketSettings_BucketIdBuilder_BucketIdBuilderEntry.$type,
  RateLimitQuotaBucketSettings_BucketIdBuilder_BucketIdBuilderEntry,
);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
