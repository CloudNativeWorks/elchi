// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/filters/http/thrift_to_metadata/v3/thrift_to_metadata.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Value } from "../../../../../../google/protobuf/struct";
import { messageTypeRegistry } from "../../../../../../typeRegistry";
import {
  ProtocolType,
  protocolTypeFromJSON,
  protocolTypeToJSON,
  protocolTypeToNumber,
  TransportType,
  transportTypeFromJSON,
  transportTypeToJSON,
  transportTypeToNumber,
} from "../../../network/thrift_proxy/v3/thrift_proxy";

export const protobufPackage = "envoy.extensions.filters.http.thrift_to_metadata.v3";

export enum Field {
  /** METHOD_NAME - The Thrift method name, string value. */
  METHOD_NAME = "METHOD_NAME",
  /**
   * PROTOCOL - The Thrift protocol name, string value. Values are "binary", "binary/non-strict", and "compact", with "(auto)" suffix if
   * :ref:`protocol <envoy_v3_api_field_extensions.filters.http.thrift_to_metadata.v3.ThriftToMetadata.protocol>`
   * is set to :ref:`AUTO_PROTOCOL<envoy_v3_api_enum_value_extensions.filters.network.thrift_proxy.v3.ProtocolType.AUTO_PROTOCOL>`
   */
  PROTOCOL = "PROTOCOL",
  /**
   * TRANSPORT - The Thrift transport name, string value. Values are "framed", "header", and "unframed", with "(auto)" suffix if
   * :ref:`transport <envoy_v3_api_field_extensions.filters.http.thrift_to_metadata.v3.ThriftToMetadata.transport>`
   * is set to :ref:`AUTO_TRANSPORT<envoy_v3_api_enum_value_extensions.filters.network.thrift_proxy.v3.TransportType.AUTO_TRANSPORT>`
   */
  TRANSPORT = "TRANSPORT",
  /** HEADER_FLAGS - The Thrift message type, singed 16-bit integer value. */
  HEADER_FLAGS = "HEADER_FLAGS",
  /** SEQUENCE_ID - The Thrift sequence ID, singed 32-bit integer value. */
  SEQUENCE_ID = "SEQUENCE_ID",
  /** MESSAGE_TYPE - The Thrift message type, string value. Values in request are "call" and "oneway", and in response are "reply" and "exception". */
  MESSAGE_TYPE = "MESSAGE_TYPE",
  /** REPLY_TYPE - The Thrift reply type, string value. This is only valid for response rules. Values are "success" and "error". */
  REPLY_TYPE = "REPLY_TYPE",
}

export function fieldFromJSON(object: any): Field {
  switch (object) {
    case 0:
    case "METHOD_NAME":
      return Field.METHOD_NAME;
    case 1:
    case "PROTOCOL":
      return Field.PROTOCOL;
    case 2:
    case "TRANSPORT":
      return Field.TRANSPORT;
    case 3:
    case "HEADER_FLAGS":
      return Field.HEADER_FLAGS;
    case 4:
    case "SEQUENCE_ID":
      return Field.SEQUENCE_ID;
    case 5:
    case "MESSAGE_TYPE":
      return Field.MESSAGE_TYPE;
    case 6:
    case "REPLY_TYPE":
      return Field.REPLY_TYPE;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Field");
  }
}

export function fieldToJSON(object: Field): string {
  switch (object) {
    case Field.METHOD_NAME:
      return "METHOD_NAME";
    case Field.PROTOCOL:
      return "PROTOCOL";
    case Field.TRANSPORT:
      return "TRANSPORT";
    case Field.HEADER_FLAGS:
      return "HEADER_FLAGS";
    case Field.SEQUENCE_ID:
      return "SEQUENCE_ID";
    case Field.MESSAGE_TYPE:
      return "MESSAGE_TYPE";
    case Field.REPLY_TYPE:
      return "REPLY_TYPE";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Field");
  }
}

export function fieldToNumber(object: Field): number {
  switch (object) {
    case Field.METHOD_NAME:
      return 0;
    case Field.PROTOCOL:
      return 1;
    case Field.TRANSPORT:
      return 2;
    case Field.HEADER_FLAGS:
      return 3;
    case Field.SEQUENCE_ID:
      return 4;
    case Field.MESSAGE_TYPE:
      return 5;
    case Field.REPLY_TYPE:
      return 6;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Field");
  }
}

export interface KeyValuePair {
  $type: "envoy.extensions.filters.http.thrift_to_metadata.v3.KeyValuePair";
  /** The namespace â€” if this is empty, the filter's namespace will be used. */
  metadata_namespace?:
    | string
    | undefined;
  /** The key to use within the namespace. */
  key?:
    | string
    | undefined;
  /**
   * When used for on_present case, if value is non-empty it'll be used instead
   * of the field value.
   *
   * When used for on_missing case, a non-empty value must be provided.
   */
  value?: any | undefined;
}

export interface FieldSelector {
  $type: "envoy.extensions.filters.http.thrift_to_metadata.v3.FieldSelector";
  /** field name to log */
  name?:
    | string
    | undefined;
  /** field id to match */
  id?:
    | number
    | undefined;
  /** next node of the field selector */
  child?: FieldSelector | undefined;
}

/** [#next-free-field: 6] */
export interface Rule {
  $type: "envoy.extensions.filters.http.thrift_to_metadata.v3.Rule";
  /** The field to match on. If set, takes precedence over field_selector. */
  field?:
    | Field
    | undefined;
  /**
   * Specifies that a match will be performed on the value of a field in the thrift body.
   * If set, the whole http body will be buffered to extract the field value, which
   * may have performance implications.
   *
   * It's a thrift over http version of
   * :ref:`field_selector<envoy_v3_api_field_extensions.filters.network.thrift_proxy.filters.payload_to_metadata.v3.PayloadToMetadata.Rule.field_selector>`.
   *
   * See also `payload-to-metadata <https://www.envoyproxy.io/docs/envoy/latest/configuration/other_protocols/thrift_filters/payload_to_metadata_filter>`_
   * for more reference.
   *
   * Example:
   *
   * .. code-block:: yaml
   *
   *    method_name: foo
   *    field_selector:
   *      name: info
   *      id: 2
   *      child:
   *        name: version
   *        id: 1
   *
   * The above yaml will match on value of ``info.version`` in the below thrift schema as input of
   * :ref:`on_present<envoy_v3_api_field_extensions.filters.http.thrift_to_metadata.v3.Rule.on_present>` or
   * :ref:`on_missing<envoy_v3_api_field_extensions.filters.http.thrift_to_metadata.v3.Rule.on_missing>`
   * while we are processing ``foo`` method. This rule won't be applied to ``bar`` method.
   *
   * .. code-block:: thrift
   *
   *    struct Info {
   *      1: required string version;
   *    }
   *    service Server {
   *      bool foo(1: i32 id, 2: Info info);
   *      bool bar(1: i32 id, 2: Info info);
   *    }
   */
  field_selector?:
    | FieldSelector
    | undefined;
  /**
   * If specified, :ref:`field_selector<envoy_v3_api_field_extensions.filters.http.thrift_to_metadata.v3.Rule.field_selector>`
   * will be used to extract the field value *only* on the thrift message with method name.
   */
  method_name?:
    | string
    | undefined;
  /**
   * The key-value pair to set in the *filter metadata* if the field is present
   * in *thrift metadata*.
   *
   * If the value in the KeyValuePair is non-empty, it'll be used instead
   * of field value.
   */
  on_present?:
    | KeyValuePair
    | undefined;
  /**
   * The key-value pair to set in the *filter metadata* if the field is missing
   * in *thrift metadata*.
   *
   * The value in the KeyValuePair must be set, since it'll be used in lieu
   * of the missing field value.
   */
  on_missing?: KeyValuePair | undefined;
}

/**
 * The configuration for transforming thrift metadata into filter metadata.
 *
 * [#next-free-field: 7]
 */
export interface ThriftToMetadata {
  $type: "envoy.extensions.filters.http.thrift_to_metadata.v3.ThriftToMetadata";
  /** The list of rules to apply to http request body to extract thrift metadata. */
  request_rules?:
    | Rule[]
    | undefined;
  /** The list of rules to apply to http response body to extract thrift metadata. */
  response_rules?:
    | Rule[]
    | undefined;
  /**
   * Supplies the type of transport that the Thrift proxy should use. Defaults to
   * :ref:`AUTO_TRANSPORT<envoy_v3_api_enum_value_extensions.filters.network.thrift_proxy.v3.TransportType.AUTO_TRANSPORT>`.
   */
  transport?:
    | TransportType
    | undefined;
  /**
   * Supplies the type of protocol that the Thrift proxy should use. Defaults to
   * :ref:`AUTO_PROTOCOL<envoy_v3_api_enum_value_extensions.filters.network.thrift_proxy.v3.ProtocolType.AUTO_PROTOCOL>`.
   * Note that :ref:`LAX_BINARY<envoy_v3_api_enum_value_extensions.filters.network.thrift_proxy.v3.ProtocolType.LAX_BINARY>`
   * is not distinguished by :ref:`AUTO_PROTOCOL<envoy_v3_api_enum_value_extensions.filters.network.thrift_proxy.v3.ProtocolType.AUTO_PROTOCOL>`,
   * which is the same with :ref:`thrift_proxy network filter <envoy_v3_api_msg_extensions.filters.network.thrift_proxy.v3.ThriftProxy>`.
   * Note that :ref:`TWITTER<envoy_v3_api_enum_value_extensions.filters.network.thrift_proxy.v3.ProtocolType.TWITTER>` is
   * not supported due to deprecation in envoy.
   */
  protocol?:
    | ProtocolType
    | undefined;
  /**
   * Allowed content-type for thrift payload to filter metadata transformation.
   * Default to ``{"application/x-thrift"}``.
   *
   * Set ``allow_empty_content_type`` if empty/missing content-type header
   * is allowed.
   */
  allow_content_types?:
    | string[]
    | undefined;
  /**
   * Allowed empty content-type for thrift payload to filter metadata transformation.
   * Default to false.
   */
  allow_empty_content_type?: boolean | undefined;
}

/**
 * Thrift to metadata configuration on a per-route basis, which overrides the global configuration for
 * request rules and responses rules.
 */
export interface ThriftToMetadataPerRoute {
  $type: "envoy.extensions.filters.http.thrift_to_metadata.v3.ThriftToMetadataPerRoute";
  /** The list of rules to apply to http request body to extract thrift metadata. */
  request_rules?:
    | Rule[]
    | undefined;
  /** The list of rules to apply to http response body to extract thrift metadata. */
  response_rules?: Rule[] | undefined;
}

function createBaseKeyValuePair(): KeyValuePair {
  return { $type: "envoy.extensions.filters.http.thrift_to_metadata.v3.KeyValuePair" };
}

export const KeyValuePair: MessageFns<
  KeyValuePair,
  "envoy.extensions.filters.http.thrift_to_metadata.v3.KeyValuePair"
> = {
  $type: "envoy.extensions.filters.http.thrift_to_metadata.v3.KeyValuePair" as const,

  encode(message: KeyValuePair, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadata_namespace !== undefined && message.metadata_namespace !== "") {
      writer.uint32(10).string(message.metadata_namespace);
    }
    if (message.key !== undefined && message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(Value.wrap(message.value), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyValuePair {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyValuePair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.metadata_namespace = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyValuePair {
    return {
      $type: KeyValuePair.$type,
      metadata_namespace: isSet(object.metadata_namespace) ? globalThis.String(object.metadata_namespace) : undefined,
      key: isSet(object.key) ? globalThis.String(object.key) : undefined,
      value: isSet(object?.value) ? object.value : undefined,
    };
  },

  toJSON(message: KeyValuePair): unknown {
    const obj: any = {};
    if (message.metadata_namespace !== undefined) {
      obj.metadata_namespace = message.metadata_namespace;
    }
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KeyValuePair>, I>>(base?: I): KeyValuePair {
    return KeyValuePair.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KeyValuePair>, I>>(object: I): KeyValuePair {
    const message = createBaseKeyValuePair();
    message.metadata_namespace = object.metadata_namespace ?? undefined;
    message.key = object.key ?? undefined;
    message.value = object.value ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(KeyValuePair.$type, KeyValuePair);

function createBaseFieldSelector(): FieldSelector {
  return { $type: "envoy.extensions.filters.http.thrift_to_metadata.v3.FieldSelector" };
}

export const FieldSelector: MessageFns<
  FieldSelector,
  "envoy.extensions.filters.http.thrift_to_metadata.v3.FieldSelector"
> = {
  $type: "envoy.extensions.filters.http.thrift_to_metadata.v3.FieldSelector" as const,

  encode(message: FieldSelector, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.id !== undefined && message.id !== 0) {
      writer.uint32(16).int32(message.id);
    }
    if (message.child !== undefined) {
      FieldSelector.encode(message.child, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FieldSelector {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFieldSelector();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.child = FieldSelector.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FieldSelector {
    return {
      $type: FieldSelector.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      id: isSet(object.id) ? globalThis.Number(object.id) : undefined,
      child: isSet(object.child) ? FieldSelector.fromJSON(object.child) : undefined,
    };
  },

  toJSON(message: FieldSelector): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.id !== undefined) {
      obj.id = Math.round(message.id);
    }
    if (message.child !== undefined) {
      obj.child = FieldSelector.toJSON(message.child);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FieldSelector>, I>>(base?: I): FieldSelector {
    return FieldSelector.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FieldSelector>, I>>(object: I): FieldSelector {
    const message = createBaseFieldSelector();
    message.name = object.name ?? undefined;
    message.id = object.id ?? undefined;
    message.child = (object.child !== undefined && object.child !== null)
      ? FieldSelector.fromPartial(object.child)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(FieldSelector.$type, FieldSelector);

function createBaseRule(): Rule {
  return { $type: "envoy.extensions.filters.http.thrift_to_metadata.v3.Rule" };
}

export const Rule: MessageFns<Rule, "envoy.extensions.filters.http.thrift_to_metadata.v3.Rule"> = {
  $type: "envoy.extensions.filters.http.thrift_to_metadata.v3.Rule" as const,

  encode(message: Rule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== undefined && message.field !== Field.METHOD_NAME) {
      writer.uint32(8).int32(fieldToNumber(message.field));
    }
    if (message.field_selector !== undefined) {
      FieldSelector.encode(message.field_selector, writer.uint32(18).fork()).join();
    }
    if (message.method_name !== undefined && message.method_name !== "") {
      writer.uint32(26).string(message.method_name);
    }
    if (message.on_present !== undefined) {
      KeyValuePair.encode(message.on_present, writer.uint32(34).fork()).join();
    }
    if (message.on_missing !== undefined) {
      KeyValuePair.encode(message.on_missing, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Rule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.field = fieldFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.field_selector = FieldSelector.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.method_name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.on_present = KeyValuePair.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.on_missing = KeyValuePair.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Rule {
    return {
      $type: Rule.$type,
      field: isSet(object.field) ? fieldFromJSON(object.field) : undefined,
      field_selector: isSet(object.field_selector) ? FieldSelector.fromJSON(object.field_selector) : undefined,
      method_name: isSet(object.method_name) ? globalThis.String(object.method_name) : undefined,
      on_present: isSet(object.on_present) ? KeyValuePair.fromJSON(object.on_present) : undefined,
      on_missing: isSet(object.on_missing) ? KeyValuePair.fromJSON(object.on_missing) : undefined,
    };
  },

  toJSON(message: Rule): unknown {
    const obj: any = {};
    if (message.field !== undefined) {
      obj.field = fieldToJSON(message.field);
    }
    if (message.field_selector !== undefined) {
      obj.field_selector = FieldSelector.toJSON(message.field_selector);
    }
    if (message.method_name !== undefined) {
      obj.method_name = message.method_name;
    }
    if (message.on_present !== undefined) {
      obj.on_present = KeyValuePair.toJSON(message.on_present);
    }
    if (message.on_missing !== undefined) {
      obj.on_missing = KeyValuePair.toJSON(message.on_missing);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Rule>, I>>(base?: I): Rule {
    return Rule.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Rule>, I>>(object: I): Rule {
    const message = createBaseRule();
    message.field = object.field ?? undefined;
    message.field_selector = (object.field_selector !== undefined && object.field_selector !== null)
      ? FieldSelector.fromPartial(object.field_selector)
      : undefined;
    message.method_name = object.method_name ?? undefined;
    message.on_present = (object.on_present !== undefined && object.on_present !== null)
      ? KeyValuePair.fromPartial(object.on_present)
      : undefined;
    message.on_missing = (object.on_missing !== undefined && object.on_missing !== null)
      ? KeyValuePair.fromPartial(object.on_missing)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Rule.$type, Rule);

function createBaseThriftToMetadata(): ThriftToMetadata {
  return { $type: "envoy.extensions.filters.http.thrift_to_metadata.v3.ThriftToMetadata" };
}

export const ThriftToMetadata: MessageFns<
  ThriftToMetadata,
  "envoy.extensions.filters.http.thrift_to_metadata.v3.ThriftToMetadata"
> = {
  $type: "envoy.extensions.filters.http.thrift_to_metadata.v3.ThriftToMetadata" as const,

  encode(message: ThriftToMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request_rules !== undefined && message.request_rules.length !== 0) {
      for (const v of message.request_rules) {
        Rule.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    if (message.response_rules !== undefined && message.response_rules.length !== 0) {
      for (const v of message.response_rules) {
        Rule.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.transport !== undefined && message.transport !== TransportType.AUTO_TRANSPORT) {
      writer.uint32(24).int32(transportTypeToNumber(message.transport));
    }
    if (message.protocol !== undefined && message.protocol !== ProtocolType.AUTO_PROTOCOL) {
      writer.uint32(32).int32(protocolTypeToNumber(message.protocol));
    }
    if (message.allow_content_types !== undefined && message.allow_content_types.length !== 0) {
      for (const v of message.allow_content_types) {
        writer.uint32(42).string(v!);
      }
    }
    if (message.allow_empty_content_type !== undefined && message.allow_empty_content_type !== false) {
      writer.uint32(48).bool(message.allow_empty_content_type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ThriftToMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseThriftToMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.request_rules === undefined) {
            message.request_rules = [];
          }
          const el = Rule.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.request_rules!.push(el);
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.response_rules === undefined) {
            message.response_rules = [];
          }
          const el = Rule.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.response_rules!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.transport = transportTypeFromJSON(reader.int32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.protocol = protocolTypeFromJSON(reader.int32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          if (message.allow_content_types === undefined) {
            message.allow_content_types = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.allow_content_types!.push(el);
          }
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.allow_empty_content_type = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ThriftToMetadata {
    return {
      $type: ThriftToMetadata.$type,
      request_rules: globalThis.Array.isArray(object?.request_rules)
        ? object.request_rules.map((e: any) => Rule.fromJSON(e))
        : undefined,
      response_rules: globalThis.Array.isArray(object?.response_rules)
        ? object.response_rules.map((e: any) => Rule.fromJSON(e))
        : undefined,
      transport: isSet(object.transport) ? transportTypeFromJSON(object.transport) : undefined,
      protocol: isSet(object.protocol) ? protocolTypeFromJSON(object.protocol) : undefined,
      allow_content_types: globalThis.Array.isArray(object?.allow_content_types)
        ? object.allow_content_types.map((e: any) => globalThis.String(e))
        : undefined,
      allow_empty_content_type: isSet(object.allow_empty_content_type)
        ? globalThis.Boolean(object.allow_empty_content_type)
        : undefined,
    };
  },

  toJSON(message: ThriftToMetadata): unknown {
    const obj: any = {};
    if (message.request_rules?.length) {
      obj.request_rules = message.request_rules.map((e) => Rule.toJSON(e));
    }
    if (message.response_rules?.length) {
      obj.response_rules = message.response_rules.map((e) => Rule.toJSON(e));
    }
    if (message.transport !== undefined) {
      obj.transport = transportTypeToJSON(message.transport);
    }
    if (message.protocol !== undefined) {
      obj.protocol = protocolTypeToJSON(message.protocol);
    }
    if (message.allow_content_types?.length) {
      obj.allow_content_types = message.allow_content_types;
    }
    if (message.allow_empty_content_type !== undefined) {
      obj.allow_empty_content_type = message.allow_empty_content_type;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ThriftToMetadata>, I>>(base?: I): ThriftToMetadata {
    return ThriftToMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ThriftToMetadata>, I>>(object: I): ThriftToMetadata {
    const message = createBaseThriftToMetadata();
    message.request_rules = object.request_rules?.map((e) => Rule.fromPartial(e)) || undefined;
    message.response_rules = object.response_rules?.map((e) => Rule.fromPartial(e)) || undefined;
    message.transport = object.transport ?? undefined;
    message.protocol = object.protocol ?? undefined;
    message.allow_content_types = object.allow_content_types?.map((e) => e) || undefined;
    message.allow_empty_content_type = object.allow_empty_content_type ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ThriftToMetadata.$type, ThriftToMetadata);

function createBaseThriftToMetadataPerRoute(): ThriftToMetadataPerRoute {
  return { $type: "envoy.extensions.filters.http.thrift_to_metadata.v3.ThriftToMetadataPerRoute" };
}

export const ThriftToMetadataPerRoute: MessageFns<
  ThriftToMetadataPerRoute,
  "envoy.extensions.filters.http.thrift_to_metadata.v3.ThriftToMetadataPerRoute"
> = {
  $type: "envoy.extensions.filters.http.thrift_to_metadata.v3.ThriftToMetadataPerRoute" as const,

  encode(message: ThriftToMetadataPerRoute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request_rules !== undefined && message.request_rules.length !== 0) {
      for (const v of message.request_rules) {
        Rule.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    if (message.response_rules !== undefined && message.response_rules.length !== 0) {
      for (const v of message.response_rules) {
        Rule.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ThriftToMetadataPerRoute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseThriftToMetadataPerRoute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.request_rules === undefined) {
            message.request_rules = [];
          }
          const el = Rule.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.request_rules!.push(el);
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.response_rules === undefined) {
            message.response_rules = [];
          }
          const el = Rule.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.response_rules!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ThriftToMetadataPerRoute {
    return {
      $type: ThriftToMetadataPerRoute.$type,
      request_rules: globalThis.Array.isArray(object?.request_rules)
        ? object.request_rules.map((e: any) => Rule.fromJSON(e))
        : undefined,
      response_rules: globalThis.Array.isArray(object?.response_rules)
        ? object.response_rules.map((e: any) => Rule.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: ThriftToMetadataPerRoute): unknown {
    const obj: any = {};
    if (message.request_rules?.length) {
      obj.request_rules = message.request_rules.map((e) => Rule.toJSON(e));
    }
    if (message.response_rules?.length) {
      obj.response_rules = message.response_rules.map((e) => Rule.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ThriftToMetadataPerRoute>, I>>(base?: I): ThriftToMetadataPerRoute {
    return ThriftToMetadataPerRoute.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ThriftToMetadataPerRoute>, I>>(object: I): ThriftToMetadataPerRoute {
    const message = createBaseThriftToMetadataPerRoute();
    message.request_rules = object.request_rules?.map((e) => Rule.fromPartial(e)) || undefined;
    message.response_rules = object.response_rules?.map((e) => Rule.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(ThriftToMetadataPerRoute.$type, ThriftToMetadataPerRoute);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
