// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/filters/http/admission_control/v3/admission_control.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../../../../google/protobuf/duration";
import { messageTypeRegistry } from "../../../../../../typeRegistry";
import { RuntimeDouble, RuntimeFeatureFlag, RuntimePercent, RuntimeUInt32 } from "../../../../../config/core/v3/base";
import { Int32Range } from "../../../../../type/v3/range";

export const protobufPackage = "envoy.extensions.filters.http.admission_control.v3";

/** [#next-free-field: 8] */
export interface AdmissionControl {
  $type: "envoy.extensions.filters.http.admission_control.v3.AdmissionControl";
  /**
   * If set to false, the admission control filter will operate as a pass-through filter. If the
   * message is unspecified, the filter will be enabled.
   */
  enabled?:
    | RuntimeFeatureFlag
    | undefined;
  /** Defines how a request is considered a success/failure. */
  evaluation_criteria?:
    | //
    { $case: "success_criteria"; success_criteria: AdmissionControl_SuccessCriteria }
    | undefined;
  /**
   * The sliding time window over which the success rate is calculated. The window is rounded to the
   * nearest second. Defaults to 30s.
   */
  sampling_window?:
    | Duration
    | undefined;
  /**
   * Rejection probability is defined by the formula::
   *
   *     max(0, (rq_count -  rq_success_count / sr_threshold) / (rq_count + 1)) ^ (1 / aggression)
   *
   * The aggression dictates how heavily the admission controller will throttle requests upon SR
   * dropping at or below the threshold. A value of 1 will result in a linear increase in
   * rejection probability as SR drops. Any values less than 1.0, will be set to 1.0. If the
   * message is unspecified, the aggression is 1.0. See `the admission control documentation
   * <https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/admission_control_filter.html>`_
   * for a diagram illustrating this.
   */
  aggression?:
    | RuntimeDouble
    | undefined;
  /**
   * Dictates the success rate at which the rejection probability is non-zero. As success rate drops
   * below this threshold, rejection probability will increase. Any success rate above the threshold
   * results in a rejection probability of 0. Defaults to 95%.
   */
  sr_threshold?:
    | RuntimePercent
    | undefined;
  /**
   * If the average RPS of the sampling window is below this threshold, the request
   * will not be rejected, even if the success rate is lower than sr_threshold.
   * Defaults to 0.
   */
  rps_threshold?:
    | RuntimeUInt32
    | undefined;
  /**
   * The probability of rejection will never exceed this value, even if the failure rate is rising.
   * Defaults to 80%.
   */
  max_rejection_probability?: RuntimePercent | undefined;
}

/**
 * Default method of specifying what constitutes a successful request. All status codes that
 * indicate a successful request must be explicitly specified if not relying on the default
 * values.
 */
export interface AdmissionControl_SuccessCriteria {
  $type: "envoy.extensions.filters.http.admission_control.v3.AdmissionControl.SuccessCriteria";
  /**
   * If HTTP criteria are unspecified, all HTTP status codes below 500 are treated as successful
   * responses.
   *
   * .. note::
   *
   *    The default HTTP codes considered successful by the admission controller are done so due
   *    to the unlikelihood that sending fewer requests would change their behavior (for example:
   *    redirects, unauthorized access, or bad requests won't be alleviated by sending less
   *    traffic).
   */
  http_criteria?:
    | AdmissionControl_SuccessCriteria_HttpCriteria
    | undefined;
  /**
   * GRPC status codes to consider as request successes. If unspecified, defaults to: Ok,
   * Cancelled, Unknown, InvalidArgument, NotFound, AlreadyExists, Unauthenticated,
   * FailedPrecondition, OutOfRange, PermissionDenied, and Unimplemented.
   *
   * .. note::
   *
   *    The default gRPC codes that are considered successful by the admission controller are
   *    chosen because of the unlikelihood that sending fewer requests will change the behavior.
   */
  grpc_criteria?: AdmissionControl_SuccessCriteria_GrpcCriteria | undefined;
}

export interface AdmissionControl_SuccessCriteria_HttpCriteria {
  $type: "envoy.extensions.filters.http.admission_control.v3.AdmissionControl.SuccessCriteria.HttpCriteria";
  /**
   * Status code ranges that constitute a successful request. Configurable codes are in the
   * range [100, 600).
   */
  http_success_status?: Int32Range[] | undefined;
}

export interface AdmissionControl_SuccessCriteria_GrpcCriteria {
  $type: "envoy.extensions.filters.http.admission_control.v3.AdmissionControl.SuccessCriteria.GrpcCriteria";
  /**
   * Status codes that constitute a successful request.
   * Mappings can be found at: https://github.com/grpc/grpc/blob/master/doc/statuscodes.md.
   */
  grpc_success_status?: number[] | undefined;
}

function createBaseAdmissionControl(): AdmissionControl {
  return {
    $type: "envoy.extensions.filters.http.admission_control.v3.AdmissionControl",
    evaluation_criteria: undefined,
  };
}

export const AdmissionControl: MessageFns<
  AdmissionControl,
  "envoy.extensions.filters.http.admission_control.v3.AdmissionControl"
> = {
  $type: "envoy.extensions.filters.http.admission_control.v3.AdmissionControl" as const,

  encode(message: AdmissionControl, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== undefined) {
      RuntimeFeatureFlag.encode(message.enabled, writer.uint32(10).fork()).join();
    }
    switch (message.evaluation_criteria?.$case) {
      case "success_criteria":
        AdmissionControl_SuccessCriteria.encode(message.evaluation_criteria.success_criteria, writer.uint32(18).fork())
          .join();
        break;
    }
    if (message.sampling_window !== undefined) {
      Duration.encode(message.sampling_window, writer.uint32(26).fork()).join();
    }
    if (message.aggression !== undefined) {
      RuntimeDouble.encode(message.aggression, writer.uint32(34).fork()).join();
    }
    if (message.sr_threshold !== undefined) {
      RuntimePercent.encode(message.sr_threshold, writer.uint32(42).fork()).join();
    }
    if (message.rps_threshold !== undefined) {
      RuntimeUInt32.encode(message.rps_threshold, writer.uint32(50).fork()).join();
    }
    if (message.max_rejection_probability !== undefined) {
      RuntimePercent.encode(message.max_rejection_probability, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdmissionControl {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdmissionControl();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.enabled = RuntimeFeatureFlag.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.evaluation_criteria = {
            $case: "success_criteria",
            success_criteria: AdmissionControl_SuccessCriteria.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sampling_window = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.aggression = RuntimeDouble.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.sr_threshold = RuntimePercent.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.rps_threshold = RuntimeUInt32.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.max_rejection_probability = RuntimePercent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdmissionControl {
    return {
      $type: AdmissionControl.$type,
      enabled: isSet(object.enabled) ? RuntimeFeatureFlag.fromJSON(object.enabled) : undefined,
      evaluation_criteria: isSet(object.success_criteria)
        ? {
          $case: "success_criteria",
          success_criteria: AdmissionControl_SuccessCriteria.fromJSON(object.success_criteria),
        }
        : undefined,
      sampling_window: isSet(object.sampling_window) ? Duration.fromJSON(object.sampling_window) : undefined,
      aggression: isSet(object.aggression) ? RuntimeDouble.fromJSON(object.aggression) : undefined,
      sr_threshold: isSet(object.sr_threshold) ? RuntimePercent.fromJSON(object.sr_threshold) : undefined,
      rps_threshold: isSet(object.rps_threshold) ? RuntimeUInt32.fromJSON(object.rps_threshold) : undefined,
      max_rejection_probability: isSet(object.max_rejection_probability)
        ? RuntimePercent.fromJSON(object.max_rejection_probability)
        : undefined,
    };
  },

  toJSON(message: AdmissionControl): unknown {
    const obj: any = {};
    if (message.enabled !== undefined) {
      obj.enabled = RuntimeFeatureFlag.toJSON(message.enabled);
    }
    if (message.evaluation_criteria?.$case === "success_criteria") {
      obj.success_criteria = AdmissionControl_SuccessCriteria.toJSON(message.evaluation_criteria.success_criteria);
    }
    if (message.sampling_window !== undefined) {
      obj.sampling_window = Duration.toJSON(message.sampling_window);
    }
    if (message.aggression !== undefined) {
      obj.aggression = RuntimeDouble.toJSON(message.aggression);
    }
    if (message.sr_threshold !== undefined) {
      obj.sr_threshold = RuntimePercent.toJSON(message.sr_threshold);
    }
    if (message.rps_threshold !== undefined) {
      obj.rps_threshold = RuntimeUInt32.toJSON(message.rps_threshold);
    }
    if (message.max_rejection_probability !== undefined) {
      obj.max_rejection_probability = RuntimePercent.toJSON(message.max_rejection_probability);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AdmissionControl>, I>>(base?: I): AdmissionControl {
    return AdmissionControl.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AdmissionControl>, I>>(object: I): AdmissionControl {
    const message = createBaseAdmissionControl();
    message.enabled = (object.enabled !== undefined && object.enabled !== null)
      ? RuntimeFeatureFlag.fromPartial(object.enabled)
      : undefined;
    if (
      object.evaluation_criteria?.$case === "success_criteria" &&
      object.evaluation_criteria?.success_criteria !== undefined &&
      object.evaluation_criteria?.success_criteria !== null
    ) {
      message.evaluation_criteria = {
        $case: "success_criteria",
        success_criteria: AdmissionControl_SuccessCriteria.fromPartial(object.evaluation_criteria.success_criteria),
      };
    }
    message.sampling_window = (object.sampling_window !== undefined && object.sampling_window !== null)
      ? Duration.fromPartial(object.sampling_window)
      : undefined;
    message.aggression = (object.aggression !== undefined && object.aggression !== null)
      ? RuntimeDouble.fromPartial(object.aggression)
      : undefined;
    message.sr_threshold = (object.sr_threshold !== undefined && object.sr_threshold !== null)
      ? RuntimePercent.fromPartial(object.sr_threshold)
      : undefined;
    message.rps_threshold = (object.rps_threshold !== undefined && object.rps_threshold !== null)
      ? RuntimeUInt32.fromPartial(object.rps_threshold)
      : undefined;
    message.max_rejection_probability =
      (object.max_rejection_probability !== undefined && object.max_rejection_probability !== null)
        ? RuntimePercent.fromPartial(object.max_rejection_probability)
        : undefined;
    return message;
  },
};

messageTypeRegistry.set(AdmissionControl.$type, AdmissionControl);

function createBaseAdmissionControl_SuccessCriteria(): AdmissionControl_SuccessCriteria {
  return { $type: "envoy.extensions.filters.http.admission_control.v3.AdmissionControl.SuccessCriteria" };
}

export const AdmissionControl_SuccessCriteria: MessageFns<
  AdmissionControl_SuccessCriteria,
  "envoy.extensions.filters.http.admission_control.v3.AdmissionControl.SuccessCriteria"
> = {
  $type: "envoy.extensions.filters.http.admission_control.v3.AdmissionControl.SuccessCriteria" as const,

  encode(message: AdmissionControl_SuccessCriteria, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.http_criteria !== undefined) {
      AdmissionControl_SuccessCriteria_HttpCriteria.encode(message.http_criteria, writer.uint32(10).fork()).join();
    }
    if (message.grpc_criteria !== undefined) {
      AdmissionControl_SuccessCriteria_GrpcCriteria.encode(message.grpc_criteria, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdmissionControl_SuccessCriteria {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdmissionControl_SuccessCriteria();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.http_criteria = AdmissionControl_SuccessCriteria_HttpCriteria.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.grpc_criteria = AdmissionControl_SuccessCriteria_GrpcCriteria.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdmissionControl_SuccessCriteria {
    return {
      $type: AdmissionControl_SuccessCriteria.$type,
      http_criteria: isSet(object.http_criteria)
        ? AdmissionControl_SuccessCriteria_HttpCriteria.fromJSON(object.http_criteria)
        : undefined,
      grpc_criteria: isSet(object.grpc_criteria)
        ? AdmissionControl_SuccessCriteria_GrpcCriteria.fromJSON(object.grpc_criteria)
        : undefined,
    };
  },

  toJSON(message: AdmissionControl_SuccessCriteria): unknown {
    const obj: any = {};
    if (message.http_criteria !== undefined) {
      obj.http_criteria = AdmissionControl_SuccessCriteria_HttpCriteria.toJSON(message.http_criteria);
    }
    if (message.grpc_criteria !== undefined) {
      obj.grpc_criteria = AdmissionControl_SuccessCriteria_GrpcCriteria.toJSON(message.grpc_criteria);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AdmissionControl_SuccessCriteria>, I>>(
    base?: I,
  ): AdmissionControl_SuccessCriteria {
    return AdmissionControl_SuccessCriteria.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AdmissionControl_SuccessCriteria>, I>>(
    object: I,
  ): AdmissionControl_SuccessCriteria {
    const message = createBaseAdmissionControl_SuccessCriteria();
    message.http_criteria = (object.http_criteria !== undefined && object.http_criteria !== null)
      ? AdmissionControl_SuccessCriteria_HttpCriteria.fromPartial(object.http_criteria)
      : undefined;
    message.grpc_criteria = (object.grpc_criteria !== undefined && object.grpc_criteria !== null)
      ? AdmissionControl_SuccessCriteria_GrpcCriteria.fromPartial(object.grpc_criteria)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(AdmissionControl_SuccessCriteria.$type, AdmissionControl_SuccessCriteria);

function createBaseAdmissionControl_SuccessCriteria_HttpCriteria(): AdmissionControl_SuccessCriteria_HttpCriteria {
  return { $type: "envoy.extensions.filters.http.admission_control.v3.AdmissionControl.SuccessCriteria.HttpCriteria" };
}

export const AdmissionControl_SuccessCriteria_HttpCriteria: MessageFns<
  AdmissionControl_SuccessCriteria_HttpCriteria,
  "envoy.extensions.filters.http.admission_control.v3.AdmissionControl.SuccessCriteria.HttpCriteria"
> = {
  $type: "envoy.extensions.filters.http.admission_control.v3.AdmissionControl.SuccessCriteria.HttpCriteria" as const,

  encode(
    message: AdmissionControl_SuccessCriteria_HttpCriteria,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.http_success_status !== undefined && message.http_success_status.length !== 0) {
      for (const v of message.http_success_status) {
        Int32Range.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdmissionControl_SuccessCriteria_HttpCriteria {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdmissionControl_SuccessCriteria_HttpCriteria();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.http_success_status === undefined) {
            message.http_success_status = [];
          }
          const el = Int32Range.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.http_success_status!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdmissionControl_SuccessCriteria_HttpCriteria {
    return {
      $type: AdmissionControl_SuccessCriteria_HttpCriteria.$type,
      http_success_status: globalThis.Array.isArray(object?.http_success_status)
        ? object.http_success_status.map((e: any) => Int32Range.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: AdmissionControl_SuccessCriteria_HttpCriteria): unknown {
    const obj: any = {};
    if (message.http_success_status?.length) {
      obj.http_success_status = message.http_success_status.map((e) => Int32Range.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AdmissionControl_SuccessCriteria_HttpCriteria>, I>>(
    base?: I,
  ): AdmissionControl_SuccessCriteria_HttpCriteria {
    return AdmissionControl_SuccessCriteria_HttpCriteria.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AdmissionControl_SuccessCriteria_HttpCriteria>, I>>(
    object: I,
  ): AdmissionControl_SuccessCriteria_HttpCriteria {
    const message = createBaseAdmissionControl_SuccessCriteria_HttpCriteria();
    message.http_success_status = object.http_success_status?.map((e) => Int32Range.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(
  AdmissionControl_SuccessCriteria_HttpCriteria.$type,
  AdmissionControl_SuccessCriteria_HttpCriteria,
);

function createBaseAdmissionControl_SuccessCriteria_GrpcCriteria(): AdmissionControl_SuccessCriteria_GrpcCriteria {
  return { $type: "envoy.extensions.filters.http.admission_control.v3.AdmissionControl.SuccessCriteria.GrpcCriteria" };
}

export const AdmissionControl_SuccessCriteria_GrpcCriteria: MessageFns<
  AdmissionControl_SuccessCriteria_GrpcCriteria,
  "envoy.extensions.filters.http.admission_control.v3.AdmissionControl.SuccessCriteria.GrpcCriteria"
> = {
  $type: "envoy.extensions.filters.http.admission_control.v3.AdmissionControl.SuccessCriteria.GrpcCriteria" as const,

  encode(
    message: AdmissionControl_SuccessCriteria_GrpcCriteria,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.grpc_success_status !== undefined && message.grpc_success_status.length !== 0) {
      writer.uint32(10).fork();
      for (const v of message.grpc_success_status) {
        writer.uint32(v);
      }
      writer.join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdmissionControl_SuccessCriteria_GrpcCriteria {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdmissionControl_SuccessCriteria_GrpcCriteria();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            if (message.grpc_success_status === undefined) {
              message.grpc_success_status = [];
            }
            message.grpc_success_status!.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            if (message.grpc_success_status === undefined) {
              message.grpc_success_status = [];
            }
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.grpc_success_status!.push(reader.uint32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdmissionControl_SuccessCriteria_GrpcCriteria {
    return {
      $type: AdmissionControl_SuccessCriteria_GrpcCriteria.$type,
      grpc_success_status: globalThis.Array.isArray(object?.grpc_success_status)
        ? object.grpc_success_status.map((e: any) => globalThis.Number(e))
        : undefined,
    };
  },

  toJSON(message: AdmissionControl_SuccessCriteria_GrpcCriteria): unknown {
    const obj: any = {};
    if (message.grpc_success_status?.length) {
      obj.grpc_success_status = message.grpc_success_status.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AdmissionControl_SuccessCriteria_GrpcCriteria>, I>>(
    base?: I,
  ): AdmissionControl_SuccessCriteria_GrpcCriteria {
    return AdmissionControl_SuccessCriteria_GrpcCriteria.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AdmissionControl_SuccessCriteria_GrpcCriteria>, I>>(
    object: I,
  ): AdmissionControl_SuccessCriteria_GrpcCriteria {
    const message = createBaseAdmissionControl_SuccessCriteria_GrpcCriteria();
    message.grpc_success_status = object.grpc_success_status?.map((e) => e) || undefined;
    return message;
  },
};

messageTypeRegistry.set(
  AdmissionControl_SuccessCriteria_GrpcCriteria.$type,
  AdmissionControl_SuccessCriteria_GrpcCriteria,
);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
