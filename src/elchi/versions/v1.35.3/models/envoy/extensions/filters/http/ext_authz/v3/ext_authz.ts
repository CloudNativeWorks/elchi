// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/filters/http/ext_authz/v3/ext_authz.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Struct } from "../../../../../../google/protobuf/struct";
import { BoolValue } from "../../../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../../../typeRegistry";
import { HeaderMutationRules } from "../../../../../config/common/mutation_rules/v3/mutation_rules";
import { HeaderValue, RuntimeFeatureFlag, RuntimeFractionalPercent } from "../../../../../config/core/v3/base";
import {
  ApiVersion,
  apiVersionFromJSON,
  apiVersionToJSON,
  apiVersionToNumber,
} from "../../../../../config/core/v3/config_source";
import { GrpcService } from "../../../../../config/core/v3/grpc_service";
import { HttpUri } from "../../../../../config/core/v3/http_uri";
import { MetadataMatcher } from "../../../../../type/matcher/v3/metadata";
import { ListStringMatcher } from "../../../../../type/matcher/v3/string";
import { HttpStatus } from "../../../../../type/v3/http_status";

export const protobufPackage = "envoy.extensions.filters.http.ext_authz.v3";

/** [#next-free-field: 30] */
export interface ExtAuthz {
  $type: "envoy.extensions.filters.http.ext_authz.v3.ExtAuthz";
  /** External authorization service configuration. */
  services?:
    | //
    /** gRPC service configuration (default timeout: 200ms). */
    { $case: "grpc_service"; grpc_service: GrpcService }
    | //
    /** HTTP service configuration (default timeout: 200ms). */
    { $case: "http_service"; http_service: HttpService }
    | undefined;
  /**
   * API version for ext_authz transport protocol. This describes the ext_authz gRPC endpoint and
   * version of messages used on the wire.
   */
  transport_api_version?:
    | ApiVersion
    | undefined;
  /**
   * Changes filter's behavior on errors:
   *
   *  1. When set to true, the filter will ``accept`` client request even if the communication with
   *  the authorization service has failed, or if the authorization service has returned a HTTP 5xx
   *  error.
   *
   *  2. When set to false, ext-authz will ``reject`` client requests and return a ``Forbidden``
   *  response if the communication with the authorization service has failed, or if the
   *  authorization service has returned a HTTP 5xx error.
   *
   * Note that errors can be ``always`` tracked in the :ref:`stats
   * <config_http_filters_ext_authz_stats>`.
   */
  failure_mode_allow?:
    | boolean
    | undefined;
  /**
   * When ``failure_mode_allow`` and ``failure_mode_allow_header_add`` are both set to true,
   * ``x-envoy-auth-failure-mode-allowed: true`` will be added to request headers if the communication
   * with the authorization service has failed, or if the authorization service has returned a
   * HTTP 5xx error.
   */
  failure_mode_allow_header_add?:
    | boolean
    | undefined;
  /**
   * Enables filter to buffer the client request body and send it within the authorization request.
   * A ``x-envoy-auth-partial-body: false|true`` metadata header will be added to the authorization
   * request message indicating if the body data is partial.
   */
  with_request_body?:
    | BufferSettings
    | undefined;
  /**
   * Clears route cache in order to allow the external authorization service to correctly affect
   * routing decisions. Filter clears all cached routes when:
   *
   * 1. The field is set to ``true``.
   *
   * 2. The status returned from the authorization service is a HTTP 200 or gRPC 0.
   *
   * 3. At least one ``authorization response header`` is added to the client request, or is used for
   * altering another client request header.
   */
  clear_route_cache?:
    | boolean
    | undefined;
  /**
   * Sets the HTTP status that is returned to the client when the authorization server returns an error
   * or cannot be reached. The default status is HTTP 403 Forbidden.
   */
  status_on_error?:
    | HttpStatus
    | undefined;
  /**
   * When this is set to true, the filter will check the :ref:`ext_authz response
   * <envoy_v3_api_msg_service.auth.v3.CheckResponse>` for invalid header &
   * query parameter mutations. If the side stream response is invalid, it will send a local reply
   * to the downstream request with status HTTP 500 Internal Server Error.
   *
   * Note that headers_to_remove & query_parameters_to_remove are validated, but invalid elements in
   * those fields should not affect any headers & thus will not cause the filter to send a local
   * reply.
   *
   * When set to false, any invalid mutations will be visible to the rest of envoy and may cause
   * unexpected behavior.
   *
   * If you are using ext_authz with an untrusted ext_authz server, you should set this to true.
   */
  validate_mutations?:
    | boolean
    | undefined;
  /**
   * Specifies a list of metadata namespaces whose values, if present, will be passed to the
   * ext_authz service. The :ref:`filter_metadata <envoy_v3_api_field_config.core.v3.Metadata.filter_metadata>`
   * is passed as an opaque ``protobuf::Struct``.
   *
   * Please note that this field exclusively applies to the gRPC ext_authz service and has no effect on the HTTP service.
   *
   * For example, if the ``jwt_authn`` filter is used and :ref:`payload_in_metadata
   * <envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.JwtProvider.payload_in_metadata>` is set,
   * then the following will pass the jwt payload to the authorization server.
   *
   * .. code-block:: yaml
   *
   *    metadata_context_namespaces:
   *    - envoy.filters.http.jwt_authn
   */
  metadata_context_namespaces?:
    | string[]
    | undefined;
  /**
   * Specifies a list of metadata namespaces whose values, if present, will be passed to the
   * ext_authz service. :ref:`typed_filter_metadata <envoy_v3_api_field_config.core.v3.Metadata.typed_filter_metadata>`
   * is passed as a ``protobuf::Any``.
   *
   * Please note that this field exclusively applies to the gRPC ext_authz service and has no effect on the HTTP service.
   *
   * It works in a way similar to ``metadata_context_namespaces`` but allows Envoy and ext_authz server to share
   * the protobuf message definition in order to do a safe parsing.
   */
  typed_metadata_context_namespaces?:
    | string[]
    | undefined;
  /**
   * Specifies a list of route metadata namespaces whose values, if present, will be passed to the
   * ext_authz service at :ref:`route_metadata_context <envoy_v3_api_field_service.auth.v3.AttributeContext.route_metadata_context>` in
   * :ref:`CheckRequest <envoy_v3_api_field_service.auth.v3.CheckRequest.attributes>`.
   * :ref:`filter_metadata <envoy_v3_api_field_config.core.v3.Metadata.filter_metadata>` is passed as an opaque ``protobuf::Struct``.
   */
  route_metadata_context_namespaces?:
    | string[]
    | undefined;
  /**
   * Specifies a list of route metadata namespaces whose values, if present, will be passed to the
   * ext_authz service at :ref:`route_metadata_context <envoy_v3_api_field_service.auth.v3.AttributeContext.route_metadata_context>` in
   * :ref:`CheckRequest <envoy_v3_api_field_service.auth.v3.CheckRequest.attributes>`.
   * :ref:`typed_filter_metadata <envoy_v3_api_field_config.core.v3.Metadata.typed_filter_metadata>` is passed as an ``protobuf::Any``.
   */
  route_typed_metadata_context_namespaces?:
    | string[]
    | undefined;
  /**
   * Specifies if the filter is enabled.
   *
   * If :ref:`runtime_key <envoy_v3_api_field_config.core.v3.RuntimeFractionalPercent.runtime_key>` is specified,
   * Envoy will lookup the runtime key to get the percentage of requests to filter.
   *
   * If this field is not specified, the filter will be enabled for all requests.
   */
  filter_enabled?:
    | RuntimeFractionalPercent
    | undefined;
  /**
   * Specifies if the filter is enabled with metadata matcher.
   * If this field is not specified, the filter will be enabled for all requests.
   */
  filter_enabled_metadata?:
    | MetadataMatcher
    | undefined;
  /**
   * Specifies whether to deny the requests, when the filter is disabled.
   * If :ref:`runtime_key <envoy_v3_api_field_config.core.v3.RuntimeFeatureFlag.runtime_key>` is specified,
   * Envoy will lookup the runtime key to determine whether to deny request for
   * filter protected path at filter disabling. If filter is disabled in
   * typed_per_filter_config for the path, requests will not be denied.
   *
   * If this field is not specified, all requests will be allowed when disabled.
   *
   * If a request is denied due to this setting, the response code in :ref:`status_on_error
   * <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.status_on_error>` will
   * be returned.
   */
  deny_at_disable?:
    | RuntimeFeatureFlag
    | undefined;
  /**
   * Specifies if the peer certificate is sent to the external service.
   *
   * When this field is true, Envoy will include the peer X.509 certificate, if available, in the
   * :ref:`certificate<envoy_v3_api_field_service.auth.v3.AttributeContext.Peer.certificate>`.
   */
  include_peer_certificate?:
    | boolean
    | undefined;
  /**
   * Optional additional prefix to use when emitting statistics. This allows to distinguish
   * emitted statistics between configured ``ext_authz`` filters in an HTTP filter chain. For example:
   *
   * .. code-block:: yaml
   *
   *   http_filters:
   *     - name: envoy.filters.http.ext_authz
   *       typed_config:
   *         "@type": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz
   *         stat_prefix: waf # This emits ext_authz.waf.ok, ext_authz.waf.denied, etc.
   *     - name: envoy.filters.http.ext_authz
   *       typed_config:
   *         "@type": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz
   *         stat_prefix: blocker # This emits ext_authz.blocker.ok, ext_authz.blocker.denied, etc.
   */
  stat_prefix?:
    | string
    | undefined;
  /**
   * Optional labels that will be passed to :ref:`labels<envoy_v3_api_field_service.auth.v3.AttributeContext.Peer.labels>` in
   * :ref:`destination<envoy_v3_api_field_service.auth.v3.AttributeContext.destination>`.
   * The labels will be read from :ref:`metadata<envoy_v3_api_msg_config.core.v3.Node>` with the specified key.
   */
  bootstrap_metadata_labels_key?:
    | string
    | undefined;
  /**
   * Check request to authorization server will include the client request headers that have a correspondent match
   * in the :ref:`list <envoy_v3_api_msg_type.matcher.v3.ListStringMatcher>`. If this option isn't specified, then
   * all client request headers are included in the check request to a gRPC authorization server, whereas no client request headers
   * (besides the ones allowed by default - see note below) are included in the check request to an HTTP authorization server.
   * This inconsistency between gRPC and HTTP servers is to maintain backwards compatibility with legacy behavior.
   *
   * .. note::
   *
   *  1. For requests to an HTTP authorization server: in addition to the user's supplied matchers, ``Host``, ``Method``, ``Path``,
   *     ``Content-Length``, and ``Authorization`` are **additionally included** in the list.
   *
   * .. note::
   *
   *  2. For requests to an HTTP authorization server: value of ``Content-Length`` will be set to 0 and the request to the
   *  authorization server will not have a message body. However, the check request can include the buffered
   *  client request body (controlled by :ref:`with_request_body
   *  <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.with_request_body>` setting),
   *  consequently the value of *Content-Length* of the authorization request reflects the size of
   *  its payload size.
   *
   * .. note::
   *
   *  3. This can be overridden by the field ``disallowed_headers`` below. That is, if a header
   *  matches for both ``allowed_headers`` and ``disallowed_headers``, the header will NOT be sent.
   */
  allowed_headers?:
    | ListStringMatcher
    | undefined;
  /**
   * If set, specifically disallow any header in this list to be forwarded to the external
   * authentication server. This overrides the above ``allowed_headers`` if a header matches both.
   */
  disallowed_headers?:
    | ListStringMatcher
    | undefined;
  /**
   * Specifies if the TLS session level details like SNI are sent to the external service.
   *
   * When this field is true, Envoy will include the SNI name used for TLSClientHello, if available, in the
   * :ref:`tls_session<envoy_v3_api_field_service.auth.v3.AttributeContext.tls_session>`.
   */
  include_tls_session?:
    | boolean
    | undefined;
  /**
   * Whether to increment cluster statistics (e.g. cluster.<cluster_name>.upstream_rq_*) on authorization failure.
   * Defaults to true.
   */
  charge_cluster_response_stats?:
    | boolean
    | undefined;
  /**
   * Whether to encode the raw headers (i.e. unsanitized values & unconcatenated multi-line headers)
   * in authentication request. Works with both HTTP and gRPC clients.
   *
   * When this is set to true, header values are not sanitized. Headers with the same key will also
   * not be combined into a single, comma-separated header.
   * Requests to gRPC services will populate the field
   * :ref:`header_map<envoy_v3_api_field_service.auth.v3.AttributeContext.HttpRequest.header_map>`.
   * Requests to HTTP services will be constructed with the unsanitized header values and preserved
   * multi-line headers with the same key.
   *
   * If this field is set to false, header values will be sanitized, with any non-UTF-8-compliant
   * bytes replaced with '!'. Headers with the same key will have their values concatenated into a
   * single comma-separated header value.
   * Requests to gRPC services will populate the field
   * :ref:`headers<envoy_v3_api_field_service.auth.v3.AttributeContext.HttpRequest.headers>`.
   * Requests to HTTP services will have their header values sanitized and will not preserve
   * multi-line headers with the same key.
   *
   * It's recommended you set this to true unless you already rely on the old behavior. False is the
   * default only for backwards compatibility.
   */
  encode_raw_headers?:
    | boolean
    | undefined;
  /**
   * Rules for what modifications an ext_authz server may make to the request headers before
   * continuing decoding / forwarding upstream.
   *
   * If set to anything, enables header mutation checking against configured rules. Note that
   * :ref:`HeaderMutationRules <envoy_v3_api_msg_config.common.mutation_rules.v3.HeaderMutationRules>`
   * has defaults that change ext_authz behavior. Also note that if this field is set to anything,
   * ext_authz can no longer append to :-prefixed headers.
   *
   * If empty, header mutation rule checking is completely disabled.
   *
   * Regardless of what is configured here, ext_authz cannot remove :-prefixed headers.
   *
   * This field and ``validate_mutations`` have different use cases. ``validate_mutations`` enables
   * correctness checks for all header / query parameter mutations (e.g. for invalid characters).
   * This field allows the filter to reject mutations to specific headers.
   */
  decoder_header_mutation_rules?:
    | HeaderMutationRules
    | undefined;
  /**
   * Enable / disable ingestion of dynamic metadata from ext_authz service.
   *
   * If false, the filter will ignore dynamic metadata injected by the ext_authz service. If the
   * ext_authz service tries injecting dynamic metadata, the filter will log, increment the
   * ``ignored_dynamic_metadata`` stat, then continue handling the response.
   *
   * If true, the filter will ingest dynamic metadata entries as normal.
   *
   * If unset, defaults to true.
   */
  enable_dynamic_metadata_ingestion?:
    | boolean
    | undefined;
  /**
   * Additional metadata to be added to the filter state for logging purposes. The metadata will be
   * added to StreamInfo's filter state under the namespace corresponding to the ext_authz filter
   * name.
   */
  filter_metadata?:
    | { [key: string]: any }
    | undefined;
  /**
   * When set to true, the filter will emit per-stream stats for access logging. The filter state
   * key will be the same as the filter name.
   *
   * If using Envoy gRPC, emits latency, bytes sent / received, upstream info, and upstream cluster
   * info. If not using Envoy gRPC, emits only latency. Note that stats are ONLY added to filter
   * state if a check request is actually made to an ext_authz service.
   *
   * If this is false the filter will not emit stats, but filter_metadata will still be respected if
   * it has a value.
   *
   * Field ``latency_us`` is exposed for CEL and logging when using gRPC or HTTP service.
   * Fields ``bytesSent`` and ``bytesReceived`` are exposed for CEL and logging only when using gRPC service.
   */
  emit_filter_state_stats?: boolean | undefined;
}

/** Configuration for buffering the request data. */
export interface BufferSettings {
  $type: "envoy.extensions.filters.http.ext_authz.v3.BufferSettings";
  /**
   * Sets the maximum size of a message body that the filter will hold in memory. Envoy will return
   * ``HTTP 413`` and will *not* initiate the authorization process when buffer reaches the number
   * set in this field. Note that this setting will have precedence over :ref:`failure_mode_allow
   * <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.failure_mode_allow>`.
   */
  max_request_bytes?:
    | number
    | undefined;
  /**
   * When this field is true, Envoy will buffer the message until ``max_request_bytes`` is reached.
   * The authorization request will be dispatched and no 413 HTTP error will be returned by the
   * filter.
   */
  allow_partial_message?:
    | boolean
    | undefined;
  /**
   * If true, the body sent to the external authorization service is set with raw bytes, it sets
   * the :ref:`raw_body<envoy_v3_api_field_service.auth.v3.AttributeContext.HttpRequest.raw_body>`
   * field of HTTP request attribute context. Otherwise, :ref:`body
   * <envoy_v3_api_field_service.auth.v3.AttributeContext.HttpRequest.body>` will be filled
   * with UTF-8 string request body.
   *
   * This field only affects configurations using a :ref:`grpc_service
   * <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.grpc_service>`. In configurations that use
   * an :ref:`http_service <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.http_service>`, this
   * has no effect.
   */
  pack_as_bytes?: boolean | undefined;
}

/**
 * HttpService is used for raw HTTP communication between the filter and the authorization service.
 * When configured, the filter will parse the client request and use these attributes to call the
 * authorization server. Depending on the response, the filter may reject or accept the client
 * request. Note that in any of these events, metadata can be added, removed or overridden by the
 * filter:
 *
 * *On authorization request*, a list of allowed request headers may be supplied. See
 * :ref:`allowed_headers
 * <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.AuthorizationRequest.allowed_headers>`
 * for details. Additional headers metadata may be added to the authorization request. See
 * :ref:`headers_to_add
 * <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.AuthorizationRequest.headers_to_add>` for
 * details.
 *
 * On authorization response status HTTP 200 OK, the filter will allow traffic to the upstream and
 * additional headers metadata may be added to the original client request. See
 * :ref:`allowed_upstream_headers
 * <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.AuthorizationResponse.allowed_upstream_headers>`
 * for details. Additionally, the filter may add additional headers to the client's response. See
 * :ref:`allowed_client_headers_on_success
 * <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.AuthorizationResponse.allowed_client_headers_on_success>`
 * for details.
 *
 * On other authorization response statuses, the filter will not allow traffic. Additional headers
 * metadata as well as body may be added to the client's response. See :ref:`allowed_client_headers
 * <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.AuthorizationResponse.allowed_client_headers>`
 * for details.
 * [#next-free-field: 9]
 */
export interface HttpService {
  $type: "envoy.extensions.filters.http.ext_authz.v3.HttpService";
  /** Sets the HTTP server URI which the authorization requests must be sent to. */
  server_uri?:
    | HttpUri
    | undefined;
  /** Sets a prefix to the value of authorization request header ``Path``. */
  path_prefix?:
    | string
    | undefined;
  /** Settings used for controlling authorization request metadata. */
  authorization_request?:
    | AuthorizationRequest
    | undefined;
  /** Settings used for controlling authorization response metadata. */
  authorization_response?: AuthorizationResponse | undefined;
}

export interface AuthorizationRequest {
  $type: "envoy.extensions.filters.http.ext_authz.v3.AuthorizationRequest";
  /**
   * Authorization request includes the client request headers that have a correspondent match
   * in the :ref:`list <envoy_v3_api_msg_type.matcher.v3.ListStringMatcher>`.
   * This field has been deprecated in favor of :ref:`allowed_headers
   * <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.allowed_headers>`.
   *
   * .. note::
   *
   *   In addition to the user's supplied matchers, ``Host``, ``Method``, ``Path``,
   *   ``Content-Length``, and ``Authorization`` are **automatically included** in the list.
   *
   * .. note::
   *
   *   By default, ``Content-Length`` header is set to ``0`` and the request to the authorization
   *   service has no message body. However, the authorization request *may* include the buffered
   *   client request body (controlled by :ref:`with_request_body
   *   <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.with_request_body>`
   *   setting) hence the value of its ``Content-Length`` reflects the size of its payload size.
   *
   * @deprecated
   */
  allowed_headers?:
    | ListStringMatcher
    | undefined;
  /**
   * Sets a list of headers that will be included to the request to authorization service. Note that
   * client request of the same key will be overridden.
   */
  headers_to_add?: HeaderValue[] | undefined;
}

/** [#next-free-field: 6] */
export interface AuthorizationResponse {
  $type: "envoy.extensions.filters.http.ext_authz.v3.AuthorizationResponse";
  /**
   * When this :ref:`list <envoy_v3_api_msg_type.matcher.v3.ListStringMatcher>` is set, authorization
   * response headers that have a correspondent match will be added to the original client request.
   * Note that coexistent headers will be overridden.
   */
  allowed_upstream_headers?:
    | ListStringMatcher
    | undefined;
  /**
   * When this :ref:`list <envoy_v3_api_msg_type.matcher.v3.ListStringMatcher>` is set, authorization
   * response headers that have a correspondent match will be added to the original client request.
   * Note that coexistent headers will be appended.
   */
  allowed_upstream_headers_to_append?:
    | ListStringMatcher
    | undefined;
  /**
   * When this :ref:`list <envoy_v3_api_msg_type.matcher.v3.ListStringMatcher>` is set, authorization
   * response headers that have a correspondent match will be added to the client's response. Note
   * that when this list is *not* set, all the authorization response headers, except ``Authority
   * (Host)`` will be in the response to the client. When a header is included in this list, ``Path``,
   * ``Status``, ``Content-Length``, ``WWWAuthenticate`` and ``Location`` are automatically added.
   */
  allowed_client_headers?:
    | ListStringMatcher
    | undefined;
  /**
   * When this :ref:`list <envoy_v3_api_msg_type.matcher.v3.ListStringMatcher>` is set, authorization
   * response headers that have a correspondent match will be added to the client's response when
   * the authorization response itself is successful, i.e. not failed or denied. When this list is
   * *not* set, no additional headers will be added to the client's response on success.
   */
  allowed_client_headers_on_success?:
    | ListStringMatcher
    | undefined;
  /**
   * When this :ref:`list <envoy_v3_api_msg_type.matcher.v3.ListStringMatcher>` is set, authorization
   * response headers that have a correspondent match will be emitted as dynamic metadata to be consumed
   * by the next filter. This metadata lives in a namespace specified by the canonical name of extension filter
   * that requires it:
   *
   * - :ref:`envoy.filters.http.ext_authz <config_http_filters_ext_authz_dynamic_metadata>` for HTTP filter.
   * - :ref:`envoy.filters.network.ext_authz <config_network_filters_ext_authz_dynamic_metadata>` for network filter.
   */
  dynamic_metadata_from_headers?: ListStringMatcher | undefined;
}

/** Extra settings on a per virtualhost/route/weighted-cluster level. */
export interface ExtAuthzPerRoute {
  $type: "envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute";
  override?:
    | //
    /**
     * Disable the ext auth filter for this particular vhost or route.
     * If disabled is specified in multiple per-filter-configs, the most specific one will be used.
     * If the filter is disabled by default and this is set to false, the filter will be enabled
     * for this vhost or route.
     */
    { $case: "disabled"; disabled: boolean }
    | //
    /** Check request settings for this route. */
    { $case: "check_settings"; check_settings: CheckSettings }
    | undefined;
}

/** Extra settings for the check request. */
export interface CheckSettings {
  $type: "envoy.extensions.filters.http.ext_authz.v3.CheckSettings";
  /**
   * Context extensions to set on the CheckRequest's
   * :ref:`AttributeContext.context_extensions<envoy_v3_api_field_service.auth.v3.AttributeContext.context_extensions>`
   *
   * You can use this to provide extra context for the external authorization server on specific
   * virtual hosts/routes. For example, adding a context extension on the virtual host level can
   * give the ext-authz server information on what virtual host is used without needing to parse the
   * host header. If CheckSettings is specified in multiple per-filter-configs, they will be merged
   * in order, and the result will be used.
   *
   * Merge semantics for this field are such that keys from more specific configs override.
   *
   * .. note::
   *
   *   These settings are only applied to a filter configured with a
   *   :ref:`grpc_service<envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.grpc_service>`.
   */
  context_extensions?:
    | Map<string, string>
    | undefined;
  /**
   * When set to true, disable the configured :ref:`with_request_body
   * <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.with_request_body>` for a specific route.
   *
   * Please note that only one of *disable_request_body_buffering* or
   * :ref:`with_request_body <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.CheckSettings.with_request_body>`
   * may be specified.
   */
  disable_request_body_buffering?:
    | boolean
    | undefined;
  /**
   * Enable or override request body buffering, which is configured using the
   * :ref:`with_request_body <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.with_request_body>`
   * option for a specific route.
   *
   * Please note that only one of ``with_request_body`` or
   * :ref:`disable_request_body_buffering <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.CheckSettings.disable_request_body_buffering>`
   * may be specified.
   */
  with_request_body?: BufferSettings | undefined;
}

export interface CheckSettings_ContextExtensionsEntry {
  $type: "envoy.extensions.filters.http.ext_authz.v3.CheckSettings.ContextExtensionsEntry";
  key: string;
  value: string;
}

function createBaseExtAuthz(): ExtAuthz {
  return { $type: "envoy.extensions.filters.http.ext_authz.v3.ExtAuthz", services: undefined };
}

export const ExtAuthz: MessageFns<ExtAuthz, "envoy.extensions.filters.http.ext_authz.v3.ExtAuthz"> = {
  $type: "envoy.extensions.filters.http.ext_authz.v3.ExtAuthz" as const,

  encode(message: ExtAuthz, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.services?.$case) {
      case "grpc_service":
        GrpcService.encode(message.services.grpc_service, writer.uint32(10).fork()).join();
        break;
      case "http_service":
        HttpService.encode(message.services.http_service, writer.uint32(26).fork()).join();
        break;
    }
    if (message.transport_api_version !== undefined && message.transport_api_version !== ApiVersion.AUTO) {
      writer.uint32(96).int32(apiVersionToNumber(message.transport_api_version));
    }
    if (message.failure_mode_allow !== undefined && message.failure_mode_allow !== false) {
      writer.uint32(16).bool(message.failure_mode_allow);
    }
    if (message.failure_mode_allow_header_add !== undefined && message.failure_mode_allow_header_add !== false) {
      writer.uint32(152).bool(message.failure_mode_allow_header_add);
    }
    if (message.with_request_body !== undefined) {
      BufferSettings.encode(message.with_request_body, writer.uint32(42).fork()).join();
    }
    if (message.clear_route_cache !== undefined && message.clear_route_cache !== false) {
      writer.uint32(48).bool(message.clear_route_cache);
    }
    if (message.status_on_error !== undefined) {
      HttpStatus.encode(message.status_on_error, writer.uint32(58).fork()).join();
    }
    if (message.validate_mutations !== undefined && message.validate_mutations !== false) {
      writer.uint32(192).bool(message.validate_mutations);
    }
    if (message.metadata_context_namespaces !== undefined && message.metadata_context_namespaces.length !== 0) {
      for (const v of message.metadata_context_namespaces) {
        writer.uint32(66).string(v!);
      }
    }
    if (
      message.typed_metadata_context_namespaces !== undefined && message.typed_metadata_context_namespaces.length !== 0
    ) {
      for (const v of message.typed_metadata_context_namespaces) {
        writer.uint32(130).string(v!);
      }
    }
    if (
      message.route_metadata_context_namespaces !== undefined && message.route_metadata_context_namespaces.length !== 0
    ) {
      for (const v of message.route_metadata_context_namespaces) {
        writer.uint32(170).string(v!);
      }
    }
    if (
      message.route_typed_metadata_context_namespaces !== undefined &&
      message.route_typed_metadata_context_namespaces.length !== 0
    ) {
      for (const v of message.route_typed_metadata_context_namespaces) {
        writer.uint32(178).string(v!);
      }
    }
    if (message.filter_enabled !== undefined) {
      RuntimeFractionalPercent.encode(message.filter_enabled, writer.uint32(74).fork()).join();
    }
    if (message.filter_enabled_metadata !== undefined) {
      MetadataMatcher.encode(message.filter_enabled_metadata, writer.uint32(114).fork()).join();
    }
    if (message.deny_at_disable !== undefined) {
      RuntimeFeatureFlag.encode(message.deny_at_disable, writer.uint32(90).fork()).join();
    }
    if (message.include_peer_certificate !== undefined && message.include_peer_certificate !== false) {
      writer.uint32(80).bool(message.include_peer_certificate);
    }
    if (message.stat_prefix !== undefined && message.stat_prefix !== "") {
      writer.uint32(106).string(message.stat_prefix);
    }
    if (message.bootstrap_metadata_labels_key !== undefined && message.bootstrap_metadata_labels_key !== "") {
      writer.uint32(122).string(message.bootstrap_metadata_labels_key);
    }
    if (message.allowed_headers !== undefined) {
      ListStringMatcher.encode(message.allowed_headers, writer.uint32(138).fork()).join();
    }
    if (message.disallowed_headers !== undefined) {
      ListStringMatcher.encode(message.disallowed_headers, writer.uint32(202).fork()).join();
    }
    if (message.include_tls_session !== undefined && message.include_tls_session !== false) {
      writer.uint32(144).bool(message.include_tls_session);
    }
    if (message.charge_cluster_response_stats !== undefined) {
      BoolValue.encode(
        { $type: "google.protobuf.BoolValue", value: message.charge_cluster_response_stats! },
        writer.uint32(162).fork(),
      ).join();
    }
    if (message.encode_raw_headers !== undefined && message.encode_raw_headers !== false) {
      writer.uint32(184).bool(message.encode_raw_headers);
    }
    if (message.decoder_header_mutation_rules !== undefined) {
      HeaderMutationRules.encode(message.decoder_header_mutation_rules, writer.uint32(210).fork()).join();
    }
    if (message.enable_dynamic_metadata_ingestion !== undefined) {
      BoolValue.encode(
        { $type: "google.protobuf.BoolValue", value: message.enable_dynamic_metadata_ingestion! },
        writer.uint32(218).fork(),
      ).join();
    }
    if (message.filter_metadata !== undefined) {
      Struct.encode(Struct.wrap(message.filter_metadata), writer.uint32(226).fork()).join();
    }
    if (message.emit_filter_state_stats !== undefined && message.emit_filter_state_stats !== false) {
      writer.uint32(232).bool(message.emit_filter_state_stats);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExtAuthz {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExtAuthz();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.services = { $case: "grpc_service", grpc_service: GrpcService.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.services = { $case: "http_service", http_service: HttpService.decode(reader, reader.uint32()) };
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.transport_api_version = apiVersionFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.failure_mode_allow = reader.bool();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.failure_mode_allow_header_add = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.with_request_body = BufferSettings.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.clear_route_cache = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.status_on_error = HttpStatus.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.validate_mutations = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          if (message.metadata_context_namespaces === undefined) {
            message.metadata_context_namespaces = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.metadata_context_namespaces!.push(el);
          }
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          if (message.typed_metadata_context_namespaces === undefined) {
            message.typed_metadata_context_namespaces = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.typed_metadata_context_namespaces!.push(el);
          }
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          if (message.route_metadata_context_namespaces === undefined) {
            message.route_metadata_context_namespaces = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.route_metadata_context_namespaces!.push(el);
          }
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          if (message.route_typed_metadata_context_namespaces === undefined) {
            message.route_typed_metadata_context_namespaces = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.route_typed_metadata_context_namespaces!.push(el);
          }
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.filter_enabled = RuntimeFractionalPercent.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.filter_enabled_metadata = MetadataMatcher.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.deny_at_disable = RuntimeFeatureFlag.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.include_peer_certificate = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.stat_prefix = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.bootstrap_metadata_labels_key = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.allowed_headers = ListStringMatcher.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.disallowed_headers = ListStringMatcher.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.include_tls_session = reader.bool();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.charge_cluster_response_stats = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }

          message.encode_raw_headers = reader.bool();
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.decoder_header_mutation_rules = HeaderMutationRules.decode(reader, reader.uint32());
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.enable_dynamic_metadata_ingestion = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.filter_metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 29: {
          if (tag !== 232) {
            break;
          }

          message.emit_filter_state_stats = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExtAuthz {
    return {
      $type: ExtAuthz.$type,
      services: isSet(object.grpc_service)
        ? { $case: "grpc_service", grpc_service: GrpcService.fromJSON(object.grpc_service) }
        : isSet(object.http_service)
        ? { $case: "http_service", http_service: HttpService.fromJSON(object.http_service) }
        : undefined,
      transport_api_version: isSet(object.transport_api_version)
        ? apiVersionFromJSON(object.transport_api_version)
        : undefined,
      failure_mode_allow: isSet(object.failure_mode_allow) ? globalThis.Boolean(object.failure_mode_allow) : undefined,
      failure_mode_allow_header_add: isSet(object.failure_mode_allow_header_add)
        ? globalThis.Boolean(object.failure_mode_allow_header_add)
        : undefined,
      with_request_body: isSet(object.with_request_body)
        ? BufferSettings.fromJSON(object.with_request_body)
        : undefined,
      clear_route_cache: isSet(object.clear_route_cache) ? globalThis.Boolean(object.clear_route_cache) : undefined,
      status_on_error: isSet(object.status_on_error) ? HttpStatus.fromJSON(object.status_on_error) : undefined,
      validate_mutations: isSet(object.validate_mutations) ? globalThis.Boolean(object.validate_mutations) : undefined,
      metadata_context_namespaces: globalThis.Array.isArray(object?.metadata_context_namespaces)
        ? object.metadata_context_namespaces.map((e: any) => globalThis.String(e))
        : undefined,
      typed_metadata_context_namespaces: globalThis.Array.isArray(object?.typed_metadata_context_namespaces)
        ? object.typed_metadata_context_namespaces.map((e: any) => globalThis.String(e))
        : undefined,
      route_metadata_context_namespaces: globalThis.Array.isArray(object?.route_metadata_context_namespaces)
        ? object.route_metadata_context_namespaces.map((e: any) => globalThis.String(e))
        : undefined,
      route_typed_metadata_context_namespaces: globalThis.Array.isArray(object?.route_typed_metadata_context_namespaces)
        ? object.route_typed_metadata_context_namespaces.map((e: any) => globalThis.String(e))
        : undefined,
      filter_enabled: isSet(object.filter_enabled)
        ? RuntimeFractionalPercent.fromJSON(object.filter_enabled)
        : undefined,
      filter_enabled_metadata: isSet(object.filter_enabled_metadata)
        ? MetadataMatcher.fromJSON(object.filter_enabled_metadata)
        : undefined,
      deny_at_disable: isSet(object.deny_at_disable) ? RuntimeFeatureFlag.fromJSON(object.deny_at_disable) : undefined,
      include_peer_certificate: isSet(object.include_peer_certificate)
        ? globalThis.Boolean(object.include_peer_certificate)
        : undefined,
      stat_prefix: isSet(object.stat_prefix) ? globalThis.String(object.stat_prefix) : undefined,
      bootstrap_metadata_labels_key: isSet(object.bootstrap_metadata_labels_key)
        ? globalThis.String(object.bootstrap_metadata_labels_key)
        : undefined,
      allowed_headers: isSet(object.allowed_headers) ? ListStringMatcher.fromJSON(object.allowed_headers) : undefined,
      disallowed_headers: isSet(object.disallowed_headers)
        ? ListStringMatcher.fromJSON(object.disallowed_headers)
        : undefined,
      include_tls_session: isSet(object.include_tls_session)
        ? globalThis.Boolean(object.include_tls_session)
        : undefined,
      charge_cluster_response_stats: isSet(object.charge_cluster_response_stats)
        ? Boolean(object.charge_cluster_response_stats)
        : undefined,
      encode_raw_headers: isSet(object.encode_raw_headers) ? globalThis.Boolean(object.encode_raw_headers) : undefined,
      decoder_header_mutation_rules: isSet(object.decoder_header_mutation_rules)
        ? HeaderMutationRules.fromJSON(object.decoder_header_mutation_rules)
        : undefined,
      enable_dynamic_metadata_ingestion: isSet(object.enable_dynamic_metadata_ingestion)
        ? Boolean(object.enable_dynamic_metadata_ingestion)
        : undefined,
      filter_metadata: isObject(object.filter_metadata) ? object.filter_metadata : undefined,
      emit_filter_state_stats: isSet(object.emit_filter_state_stats)
        ? globalThis.Boolean(object.emit_filter_state_stats)
        : undefined,
    };
  },

  toJSON(message: ExtAuthz): unknown {
    const obj: any = {};
    if (message.services?.$case === "grpc_service") {
      obj.grpc_service = GrpcService.toJSON(message.services.grpc_service);
    }
    if (message.services?.$case === "http_service") {
      obj.http_service = HttpService.toJSON(message.services.http_service);
    }
    if (message.transport_api_version !== undefined) {
      obj.transport_api_version = apiVersionToJSON(message.transport_api_version);
    }
    if (message.failure_mode_allow !== undefined) {
      obj.failure_mode_allow = message.failure_mode_allow;
    }
    if (message.failure_mode_allow_header_add !== undefined) {
      obj.failure_mode_allow_header_add = message.failure_mode_allow_header_add;
    }
    if (message.with_request_body !== undefined) {
      obj.with_request_body = BufferSettings.toJSON(message.with_request_body);
    }
    if (message.clear_route_cache !== undefined) {
      obj.clear_route_cache = message.clear_route_cache;
    }
    if (message.status_on_error !== undefined) {
      obj.status_on_error = HttpStatus.toJSON(message.status_on_error);
    }
    if (message.validate_mutations !== undefined) {
      obj.validate_mutations = message.validate_mutations;
    }
    if (message.metadata_context_namespaces?.length) {
      obj.metadata_context_namespaces = message.metadata_context_namespaces;
    }
    if (message.typed_metadata_context_namespaces?.length) {
      obj.typed_metadata_context_namespaces = message.typed_metadata_context_namespaces;
    }
    if (message.route_metadata_context_namespaces?.length) {
      obj.route_metadata_context_namespaces = message.route_metadata_context_namespaces;
    }
    if (message.route_typed_metadata_context_namespaces?.length) {
      obj.route_typed_metadata_context_namespaces = message.route_typed_metadata_context_namespaces;
    }
    if (message.filter_enabled !== undefined) {
      obj.filter_enabled = RuntimeFractionalPercent.toJSON(message.filter_enabled);
    }
    if (message.filter_enabled_metadata !== undefined) {
      obj.filter_enabled_metadata = MetadataMatcher.toJSON(message.filter_enabled_metadata);
    }
    if (message.deny_at_disable !== undefined) {
      obj.deny_at_disable = RuntimeFeatureFlag.toJSON(message.deny_at_disable);
    }
    if (message.include_peer_certificate !== undefined) {
      obj.include_peer_certificate = message.include_peer_certificate;
    }
    if (message.stat_prefix !== undefined) {
      obj.stat_prefix = message.stat_prefix;
    }
    if (message.bootstrap_metadata_labels_key !== undefined) {
      obj.bootstrap_metadata_labels_key = message.bootstrap_metadata_labels_key;
    }
    if (message.allowed_headers !== undefined) {
      obj.allowed_headers = ListStringMatcher.toJSON(message.allowed_headers);
    }
    if (message.disallowed_headers !== undefined) {
      obj.disallowed_headers = ListStringMatcher.toJSON(message.disallowed_headers);
    }
    if (message.include_tls_session !== undefined) {
      obj.include_tls_session = message.include_tls_session;
    }
    if (message.charge_cluster_response_stats !== undefined) {
      obj.charge_cluster_response_stats = message.charge_cluster_response_stats;
    }
    if (message.encode_raw_headers !== undefined) {
      obj.encode_raw_headers = message.encode_raw_headers;
    }
    if (message.decoder_header_mutation_rules !== undefined) {
      obj.decoder_header_mutation_rules = HeaderMutationRules.toJSON(message.decoder_header_mutation_rules);
    }
    if (message.enable_dynamic_metadata_ingestion !== undefined) {
      obj.enable_dynamic_metadata_ingestion = message.enable_dynamic_metadata_ingestion;
    }
    if (message.filter_metadata !== undefined) {
      obj.filter_metadata = message.filter_metadata;
    }
    if (message.emit_filter_state_stats !== undefined) {
      obj.emit_filter_state_stats = message.emit_filter_state_stats;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExtAuthz>, I>>(base?: I): ExtAuthz {
    return ExtAuthz.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExtAuthz>, I>>(object: I): ExtAuthz {
    const message = createBaseExtAuthz();
    if (
      object.services?.$case === "grpc_service" &&
      object.services?.grpc_service !== undefined &&
      object.services?.grpc_service !== null
    ) {
      message.services = { $case: "grpc_service", grpc_service: GrpcService.fromPartial(object.services.grpc_service) };
    }
    if (
      object.services?.$case === "http_service" &&
      object.services?.http_service !== undefined &&
      object.services?.http_service !== null
    ) {
      message.services = { $case: "http_service", http_service: HttpService.fromPartial(object.services.http_service) };
    }
    message.transport_api_version = object.transport_api_version ?? undefined;
    message.failure_mode_allow = object.failure_mode_allow ?? undefined;
    message.failure_mode_allow_header_add = object.failure_mode_allow_header_add ?? undefined;
    message.with_request_body = (object.with_request_body !== undefined && object.with_request_body !== null)
      ? BufferSettings.fromPartial(object.with_request_body)
      : undefined;
    message.clear_route_cache = object.clear_route_cache ?? undefined;
    message.status_on_error = (object.status_on_error !== undefined && object.status_on_error !== null)
      ? HttpStatus.fromPartial(object.status_on_error)
      : undefined;
    message.validate_mutations = object.validate_mutations ?? undefined;
    message.metadata_context_namespaces = object.metadata_context_namespaces?.map((e) => e) || undefined;
    message.typed_metadata_context_namespaces = object.typed_metadata_context_namespaces?.map((e) => e) || undefined;
    message.route_metadata_context_namespaces = object.route_metadata_context_namespaces?.map((e) => e) || undefined;
    message.route_typed_metadata_context_namespaces = object.route_typed_metadata_context_namespaces?.map((e) => e) ||
      undefined;
    message.filter_enabled = (object.filter_enabled !== undefined && object.filter_enabled !== null)
      ? RuntimeFractionalPercent.fromPartial(object.filter_enabled)
      : undefined;
    message.filter_enabled_metadata =
      (object.filter_enabled_metadata !== undefined && object.filter_enabled_metadata !== null)
        ? MetadataMatcher.fromPartial(object.filter_enabled_metadata)
        : undefined;
    message.deny_at_disable = (object.deny_at_disable !== undefined && object.deny_at_disable !== null)
      ? RuntimeFeatureFlag.fromPartial(object.deny_at_disable)
      : undefined;
    message.include_peer_certificate = object.include_peer_certificate ?? undefined;
    message.stat_prefix = object.stat_prefix ?? undefined;
    message.bootstrap_metadata_labels_key = object.bootstrap_metadata_labels_key ?? undefined;
    message.allowed_headers = (object.allowed_headers !== undefined && object.allowed_headers !== null)
      ? ListStringMatcher.fromPartial(object.allowed_headers)
      : undefined;
    message.disallowed_headers = (object.disallowed_headers !== undefined && object.disallowed_headers !== null)
      ? ListStringMatcher.fromPartial(object.disallowed_headers)
      : undefined;
    message.include_tls_session = object.include_tls_session ?? undefined;
    message.charge_cluster_response_stats = object.charge_cluster_response_stats ?? undefined;
    message.encode_raw_headers = object.encode_raw_headers ?? undefined;
    message.decoder_header_mutation_rules =
      (object.decoder_header_mutation_rules !== undefined && object.decoder_header_mutation_rules !== null)
        ? HeaderMutationRules.fromPartial(object.decoder_header_mutation_rules)
        : undefined;
    message.enable_dynamic_metadata_ingestion = object.enable_dynamic_metadata_ingestion ?? undefined;
    message.filter_metadata = object.filter_metadata ?? undefined;
    message.emit_filter_state_stats = object.emit_filter_state_stats ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ExtAuthz.$type, ExtAuthz);

function createBaseBufferSettings(): BufferSettings {
  return { $type: "envoy.extensions.filters.http.ext_authz.v3.BufferSettings" };
}

export const BufferSettings: MessageFns<BufferSettings, "envoy.extensions.filters.http.ext_authz.v3.BufferSettings"> = {
  $type: "envoy.extensions.filters.http.ext_authz.v3.BufferSettings" as const,

  encode(message: BufferSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.max_request_bytes !== undefined && message.max_request_bytes !== 0) {
      writer.uint32(8).uint32(message.max_request_bytes);
    }
    if (message.allow_partial_message !== undefined && message.allow_partial_message !== false) {
      writer.uint32(16).bool(message.allow_partial_message);
    }
    if (message.pack_as_bytes !== undefined && message.pack_as_bytes !== false) {
      writer.uint32(24).bool(message.pack_as_bytes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BufferSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBufferSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.max_request_bytes = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.allow_partial_message = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pack_as_bytes = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BufferSettings {
    return {
      $type: BufferSettings.$type,
      max_request_bytes: isSet(object.max_request_bytes) ? globalThis.Number(object.max_request_bytes) : undefined,
      allow_partial_message: isSet(object.allow_partial_message)
        ? globalThis.Boolean(object.allow_partial_message)
        : undefined,
      pack_as_bytes: isSet(object.pack_as_bytes) ? globalThis.Boolean(object.pack_as_bytes) : undefined,
    };
  },

  toJSON(message: BufferSettings): unknown {
    const obj: any = {};
    if (message.max_request_bytes !== undefined) {
      obj.max_request_bytes = Math.round(message.max_request_bytes);
    }
    if (message.allow_partial_message !== undefined) {
      obj.allow_partial_message = message.allow_partial_message;
    }
    if (message.pack_as_bytes !== undefined) {
      obj.pack_as_bytes = message.pack_as_bytes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BufferSettings>, I>>(base?: I): BufferSettings {
    return BufferSettings.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BufferSettings>, I>>(object: I): BufferSettings {
    const message = createBaseBufferSettings();
    message.max_request_bytes = object.max_request_bytes ?? undefined;
    message.allow_partial_message = object.allow_partial_message ?? undefined;
    message.pack_as_bytes = object.pack_as_bytes ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(BufferSettings.$type, BufferSettings);

function createBaseHttpService(): HttpService {
  return { $type: "envoy.extensions.filters.http.ext_authz.v3.HttpService" };
}

export const HttpService: MessageFns<HttpService, "envoy.extensions.filters.http.ext_authz.v3.HttpService"> = {
  $type: "envoy.extensions.filters.http.ext_authz.v3.HttpService" as const,

  encode(message: HttpService, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.server_uri !== undefined) {
      HttpUri.encode(message.server_uri, writer.uint32(10).fork()).join();
    }
    if (message.path_prefix !== undefined && message.path_prefix !== "") {
      writer.uint32(18).string(message.path_prefix);
    }
    if (message.authorization_request !== undefined) {
      AuthorizationRequest.encode(message.authorization_request, writer.uint32(58).fork()).join();
    }
    if (message.authorization_response !== undefined) {
      AuthorizationResponse.encode(message.authorization_response, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpService {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpService();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.server_uri = HttpUri.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.path_prefix = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.authorization_request = AuthorizationRequest.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.authorization_response = AuthorizationResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpService {
    return {
      $type: HttpService.$type,
      server_uri: isSet(object.server_uri) ? HttpUri.fromJSON(object.server_uri) : undefined,
      path_prefix: isSet(object.path_prefix) ? globalThis.String(object.path_prefix) : undefined,
      authorization_request: isSet(object.authorization_request)
        ? AuthorizationRequest.fromJSON(object.authorization_request)
        : undefined,
      authorization_response: isSet(object.authorization_response)
        ? AuthorizationResponse.fromJSON(object.authorization_response)
        : undefined,
    };
  },

  toJSON(message: HttpService): unknown {
    const obj: any = {};
    if (message.server_uri !== undefined) {
      obj.server_uri = HttpUri.toJSON(message.server_uri);
    }
    if (message.path_prefix !== undefined) {
      obj.path_prefix = message.path_prefix;
    }
    if (message.authorization_request !== undefined) {
      obj.authorization_request = AuthorizationRequest.toJSON(message.authorization_request);
    }
    if (message.authorization_response !== undefined) {
      obj.authorization_response = AuthorizationResponse.toJSON(message.authorization_response);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpService>, I>>(base?: I): HttpService {
    return HttpService.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpService>, I>>(object: I): HttpService {
    const message = createBaseHttpService();
    message.server_uri = (object.server_uri !== undefined && object.server_uri !== null)
      ? HttpUri.fromPartial(object.server_uri)
      : undefined;
    message.path_prefix = object.path_prefix ?? undefined;
    message.authorization_request =
      (object.authorization_request !== undefined && object.authorization_request !== null)
        ? AuthorizationRequest.fromPartial(object.authorization_request)
        : undefined;
    message.authorization_response =
      (object.authorization_response !== undefined && object.authorization_response !== null)
        ? AuthorizationResponse.fromPartial(object.authorization_response)
        : undefined;
    return message;
  },
};

messageTypeRegistry.set(HttpService.$type, HttpService);

function createBaseAuthorizationRequest(): AuthorizationRequest {
  return { $type: "envoy.extensions.filters.http.ext_authz.v3.AuthorizationRequest" };
}

export const AuthorizationRequest: MessageFns<
  AuthorizationRequest,
  "envoy.extensions.filters.http.ext_authz.v3.AuthorizationRequest"
> = {
  $type: "envoy.extensions.filters.http.ext_authz.v3.AuthorizationRequest" as const,

  encode(message: AuthorizationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.allowed_headers !== undefined) {
      ListStringMatcher.encode(message.allowed_headers, writer.uint32(10).fork()).join();
    }
    if (message.headers_to_add !== undefined && message.headers_to_add.length !== 0) {
      for (const v of message.headers_to_add) {
        HeaderValue.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthorizationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthorizationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.allowed_headers = ListStringMatcher.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.headers_to_add === undefined) {
            message.headers_to_add = [];
          }
          const el = HeaderValue.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.headers_to_add!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthorizationRequest {
    return {
      $type: AuthorizationRequest.$type,
      allowed_headers: isSet(object.allowed_headers) ? ListStringMatcher.fromJSON(object.allowed_headers) : undefined,
      headers_to_add: globalThis.Array.isArray(object?.headers_to_add)
        ? object.headers_to_add.map((e: any) => HeaderValue.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: AuthorizationRequest): unknown {
    const obj: any = {};
    if (message.allowed_headers !== undefined) {
      obj.allowed_headers = ListStringMatcher.toJSON(message.allowed_headers);
    }
    if (message.headers_to_add?.length) {
      obj.headers_to_add = message.headers_to_add.map((e) => HeaderValue.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthorizationRequest>, I>>(base?: I): AuthorizationRequest {
    return AuthorizationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthorizationRequest>, I>>(object: I): AuthorizationRequest {
    const message = createBaseAuthorizationRequest();
    message.allowed_headers = (object.allowed_headers !== undefined && object.allowed_headers !== null)
      ? ListStringMatcher.fromPartial(object.allowed_headers)
      : undefined;
    message.headers_to_add = object.headers_to_add?.map((e) => HeaderValue.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(AuthorizationRequest.$type, AuthorizationRequest);

function createBaseAuthorizationResponse(): AuthorizationResponse {
  return { $type: "envoy.extensions.filters.http.ext_authz.v3.AuthorizationResponse" };
}

export const AuthorizationResponse: MessageFns<
  AuthorizationResponse,
  "envoy.extensions.filters.http.ext_authz.v3.AuthorizationResponse"
> = {
  $type: "envoy.extensions.filters.http.ext_authz.v3.AuthorizationResponse" as const,

  encode(message: AuthorizationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.allowed_upstream_headers !== undefined) {
      ListStringMatcher.encode(message.allowed_upstream_headers, writer.uint32(10).fork()).join();
    }
    if (message.allowed_upstream_headers_to_append !== undefined) {
      ListStringMatcher.encode(message.allowed_upstream_headers_to_append, writer.uint32(26).fork()).join();
    }
    if (message.allowed_client_headers !== undefined) {
      ListStringMatcher.encode(message.allowed_client_headers, writer.uint32(18).fork()).join();
    }
    if (message.allowed_client_headers_on_success !== undefined) {
      ListStringMatcher.encode(message.allowed_client_headers_on_success, writer.uint32(34).fork()).join();
    }
    if (message.dynamic_metadata_from_headers !== undefined) {
      ListStringMatcher.encode(message.dynamic_metadata_from_headers, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthorizationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthorizationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.allowed_upstream_headers = ListStringMatcher.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.allowed_upstream_headers_to_append = ListStringMatcher.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.allowed_client_headers = ListStringMatcher.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.allowed_client_headers_on_success = ListStringMatcher.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.dynamic_metadata_from_headers = ListStringMatcher.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthorizationResponse {
    return {
      $type: AuthorizationResponse.$type,
      allowed_upstream_headers: isSet(object.allowed_upstream_headers)
        ? ListStringMatcher.fromJSON(object.allowed_upstream_headers)
        : undefined,
      allowed_upstream_headers_to_append: isSet(object.allowed_upstream_headers_to_append)
        ? ListStringMatcher.fromJSON(object.allowed_upstream_headers_to_append)
        : undefined,
      allowed_client_headers: isSet(object.allowed_client_headers)
        ? ListStringMatcher.fromJSON(object.allowed_client_headers)
        : undefined,
      allowed_client_headers_on_success: isSet(object.allowed_client_headers_on_success)
        ? ListStringMatcher.fromJSON(object.allowed_client_headers_on_success)
        : undefined,
      dynamic_metadata_from_headers: isSet(object.dynamic_metadata_from_headers)
        ? ListStringMatcher.fromJSON(object.dynamic_metadata_from_headers)
        : undefined,
    };
  },

  toJSON(message: AuthorizationResponse): unknown {
    const obj: any = {};
    if (message.allowed_upstream_headers !== undefined) {
      obj.allowed_upstream_headers = ListStringMatcher.toJSON(message.allowed_upstream_headers);
    }
    if (message.allowed_upstream_headers_to_append !== undefined) {
      obj.allowed_upstream_headers_to_append = ListStringMatcher.toJSON(message.allowed_upstream_headers_to_append);
    }
    if (message.allowed_client_headers !== undefined) {
      obj.allowed_client_headers = ListStringMatcher.toJSON(message.allowed_client_headers);
    }
    if (message.allowed_client_headers_on_success !== undefined) {
      obj.allowed_client_headers_on_success = ListStringMatcher.toJSON(message.allowed_client_headers_on_success);
    }
    if (message.dynamic_metadata_from_headers !== undefined) {
      obj.dynamic_metadata_from_headers = ListStringMatcher.toJSON(message.dynamic_metadata_from_headers);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthorizationResponse>, I>>(base?: I): AuthorizationResponse {
    return AuthorizationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthorizationResponse>, I>>(object: I): AuthorizationResponse {
    const message = createBaseAuthorizationResponse();
    message.allowed_upstream_headers =
      (object.allowed_upstream_headers !== undefined && object.allowed_upstream_headers !== null)
        ? ListStringMatcher.fromPartial(object.allowed_upstream_headers)
        : undefined;
    message.allowed_upstream_headers_to_append =
      (object.allowed_upstream_headers_to_append !== undefined && object.allowed_upstream_headers_to_append !== null)
        ? ListStringMatcher.fromPartial(object.allowed_upstream_headers_to_append)
        : undefined;
    message.allowed_client_headers =
      (object.allowed_client_headers !== undefined && object.allowed_client_headers !== null)
        ? ListStringMatcher.fromPartial(object.allowed_client_headers)
        : undefined;
    message.allowed_client_headers_on_success =
      (object.allowed_client_headers_on_success !== undefined && object.allowed_client_headers_on_success !== null)
        ? ListStringMatcher.fromPartial(object.allowed_client_headers_on_success)
        : undefined;
    message.dynamic_metadata_from_headers =
      (object.dynamic_metadata_from_headers !== undefined && object.dynamic_metadata_from_headers !== null)
        ? ListStringMatcher.fromPartial(object.dynamic_metadata_from_headers)
        : undefined;
    return message;
  },
};

messageTypeRegistry.set(AuthorizationResponse.$type, AuthorizationResponse);

function createBaseExtAuthzPerRoute(): ExtAuthzPerRoute {
  return { $type: "envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute", override: undefined };
}

export const ExtAuthzPerRoute: MessageFns<
  ExtAuthzPerRoute,
  "envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute"
> = {
  $type: "envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute" as const,

  encode(message: ExtAuthzPerRoute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.override?.$case) {
      case "disabled":
        writer.uint32(8).bool(message.override.disabled);
        break;
      case "check_settings":
        CheckSettings.encode(message.override.check_settings, writer.uint32(18).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExtAuthzPerRoute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExtAuthzPerRoute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.override = { $case: "disabled", disabled: reader.bool() };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.override = { $case: "check_settings", check_settings: CheckSettings.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExtAuthzPerRoute {
    return {
      $type: ExtAuthzPerRoute.$type,
      override: isSet(object.disabled)
        ? { $case: "disabled", disabled: globalThis.Boolean(object.disabled) }
        : isSet(object.check_settings)
        ? { $case: "check_settings", check_settings: CheckSettings.fromJSON(object.check_settings) }
        : undefined,
    };
  },

  toJSON(message: ExtAuthzPerRoute): unknown {
    const obj: any = {};
    if (message.override?.$case === "disabled") {
      obj.disabled = message.override.disabled;
    }
    if (message.override?.$case === "check_settings") {
      obj.check_settings = CheckSettings.toJSON(message.override.check_settings);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExtAuthzPerRoute>, I>>(base?: I): ExtAuthzPerRoute {
    return ExtAuthzPerRoute.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExtAuthzPerRoute>, I>>(object: I): ExtAuthzPerRoute {
    const message = createBaseExtAuthzPerRoute();
    if (
      object.override?.$case === "disabled" &&
      object.override?.disabled !== undefined &&
      object.override?.disabled !== null
    ) {
      message.override = { $case: "disabled", disabled: object.override.disabled };
    }
    if (
      object.override?.$case === "check_settings" &&
      object.override?.check_settings !== undefined &&
      object.override?.check_settings !== null
    ) {
      message.override = {
        $case: "check_settings",
        check_settings: CheckSettings.fromPartial(object.override.check_settings),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(ExtAuthzPerRoute.$type, ExtAuthzPerRoute);

function createBaseCheckSettings(): CheckSettings {
  return { $type: "envoy.extensions.filters.http.ext_authz.v3.CheckSettings" };
}

export const CheckSettings: MessageFns<CheckSettings, "envoy.extensions.filters.http.ext_authz.v3.CheckSettings"> = {
  $type: "envoy.extensions.filters.http.ext_authz.v3.CheckSettings" as const,

  encode(message: CheckSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    (message.context_extensions || new Map()).forEach((value, key) => {
      CheckSettings_ContextExtensionsEntry.encode({
        $type: "envoy.extensions.filters.http.ext_authz.v3.CheckSettings.ContextExtensionsEntry",
        key: key as any,
        value,
      }, writer.uint32(10).fork()).join();
    });
    if (message.disable_request_body_buffering !== undefined && message.disable_request_body_buffering !== false) {
      writer.uint32(16).bool(message.disable_request_body_buffering);
    }
    if (message.with_request_body !== undefined) {
      BufferSettings.encode(message.with_request_body, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = CheckSettings_ContextExtensionsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            if (message.context_extensions === undefined) {
              message.context_extensions = new Map();
            }
            message.context_extensions!.set(entry1.key, entry1.value);
          }
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.disable_request_body_buffering = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.with_request_body = BufferSettings.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckSettings {
    return {
      $type: CheckSettings.$type,
      context_extensions: isObject(object.context_extensions)
        ? Object.entries(object.context_extensions).reduce<Map<string, string>>((acc, [key, value]) => {
          acc.set(key, String(value));
          return acc;
        }, new Map())
        : undefined,
      disable_request_body_buffering: isSet(object.disable_request_body_buffering)
        ? globalThis.Boolean(object.disable_request_body_buffering)
        : undefined,
      with_request_body: isSet(object.with_request_body)
        ? BufferSettings.fromJSON(object.with_request_body)
        : undefined,
    };
  },

  toJSON(message: CheckSettings): unknown {
    const obj: any = {};
    if (message.context_extensions?.size) {
      obj.context_extensions = {};
      message.context_extensions.forEach((v, k) => {
        obj.context_extensions[k] = v;
      });
    }
    if (message.disable_request_body_buffering !== undefined) {
      obj.disable_request_body_buffering = message.disable_request_body_buffering;
    }
    if (message.with_request_body !== undefined) {
      obj.with_request_body = BufferSettings.toJSON(message.with_request_body);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckSettings>, I>>(base?: I): CheckSettings {
    return CheckSettings.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckSettings>, I>>(object: I): CheckSettings {
    const message = createBaseCheckSettings();
    message.context_extensions = (object.context_extensions === undefined || object.context_extensions === null)
      ? undefined
      : (() => {
        const m = new Map();
        (object.context_extensions as Map<string, string> ?? new Map()).forEach((value, key) => {
          if (value !== undefined) {
            m.set(key, globalThis.String(value));
          }
        });
        return m;
      })();
    message.disable_request_body_buffering = object.disable_request_body_buffering ?? undefined;
    message.with_request_body = (object.with_request_body !== undefined && object.with_request_body !== null)
      ? BufferSettings.fromPartial(object.with_request_body)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(CheckSettings.$type, CheckSettings);

function createBaseCheckSettings_ContextExtensionsEntry(): CheckSettings_ContextExtensionsEntry {
  return {
    $type: "envoy.extensions.filters.http.ext_authz.v3.CheckSettings.ContextExtensionsEntry",
    key: "",
    value: "",
  };
}

export const CheckSettings_ContextExtensionsEntry: MessageFns<
  CheckSettings_ContextExtensionsEntry,
  "envoy.extensions.filters.http.ext_authz.v3.CheckSettings.ContextExtensionsEntry"
> = {
  $type: "envoy.extensions.filters.http.ext_authz.v3.CheckSettings.ContextExtensionsEntry" as const,

  encode(message: CheckSettings_ContextExtensionsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckSettings_ContextExtensionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckSettings_ContextExtensionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckSettings_ContextExtensionsEntry {
    return {
      $type: CheckSettings_ContextExtensionsEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CheckSettings_ContextExtensionsEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckSettings_ContextExtensionsEntry>, I>>(
    base?: I,
  ): CheckSettings_ContextExtensionsEntry {
    return CheckSettings_ContextExtensionsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckSettings_ContextExtensionsEntry>, I>>(
    object: I,
  ): CheckSettings_ContextExtensionsEntry {
    const message = createBaseCheckSettings_ContextExtensionsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

messageTypeRegistry.set(CheckSettings_ContextExtensionsEntry.$type, CheckSettings_ContextExtensionsEntry);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
