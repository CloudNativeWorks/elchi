// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/config/overload/v2alpha/overload.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Any } from "../../../../google/protobuf/any";
import { Duration } from "../../../../google/protobuf/duration";
import { Struct } from "../../../../google/protobuf/struct";
import { messageTypeRegistry } from "../../../../typeRegistry";

export const protobufPackage = "envoy.config.overload.v2alpha";

export interface ResourceMonitor {
  $type: "envoy.config.overload.v2alpha.ResourceMonitor";
  /**
   * The name of the resource monitor to instantiate. Must match a registered
   * resource monitor type. The built-in resource monitors are:
   *
   * * :ref:`envoy.resource_monitors.fixed_heap
   *   <envoy_api_msg_config.resource_monitor.fixed_heap.v2alpha.FixedHeapConfig>`
   * * :ref:`envoy.resource_monitors.injected_resource
   *   <envoy_api_msg_config.resource_monitor.injected_resource.v2alpha.InjectedResourceConfig>`
   */
  name?:
    | string
    | undefined;
  /** Configuration for the resource monitor being instantiated. */
  config_type?:
    | //
    { $case: "config"; config: { [key: string]: any } | undefined }
    | //
    { $case: "typed_config"; typed_config: Any }
    | undefined;
}

export interface ThresholdTrigger {
  $type: "envoy.config.overload.v2alpha.ThresholdTrigger";
  /**
   * If the resource pressure is greater than or equal to this value, the trigger
   * will fire.
   */
  value?: number | undefined;
}

export interface Trigger {
  $type: "envoy.config.overload.v2alpha.Trigger";
  /** The name of the resource this is a trigger for. */
  name?: string | undefined;
  trigger_oneof?:
    | //
    { $case: "threshold"; threshold: ThresholdTrigger }
    | undefined;
}

export interface OverloadAction {
  $type: "envoy.config.overload.v2alpha.OverloadAction";
  /**
   * The name of the overload action. This is just a well-known string that listeners can
   * use for registering callbacks. Custom overload actions should be named using reverse
   * DNS to ensure uniqueness.
   */
  name?:
    | string
    | undefined;
  /**
   * A set of triggers for this action. If any of these triggers fire the overload action
   * is activated. Listeners are notified when the overload action transitions from
   * inactivated to activated, or vice versa.
   */
  triggers?: Trigger[] | undefined;
}

export interface OverloadManager {
  $type: "envoy.config.overload.v2alpha.OverloadManager";
  /** The interval for refreshing resource usage. */
  refresh_interval?:
    | Duration
    | undefined;
  /** The set of resources to monitor. */
  resource_monitors?:
    | ResourceMonitor[]
    | undefined;
  /** The set of overload actions. */
  actions?: OverloadAction[] | undefined;
}

function createBaseResourceMonitor(): ResourceMonitor {
  return { $type: "envoy.config.overload.v2alpha.ResourceMonitor", config_type: undefined };
}

export const ResourceMonitor: MessageFns<ResourceMonitor, "envoy.config.overload.v2alpha.ResourceMonitor"> = {
  $type: "envoy.config.overload.v2alpha.ResourceMonitor" as const,

  encode(message: ResourceMonitor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    switch (message.config_type?.$case) {
      case "config":
        Struct.encode(Struct.wrap(message.config_type.config), writer.uint32(18).fork()).join();
        break;
      case "typed_config":
        Any.encode(message.config_type.typed_config, writer.uint32(26).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceMonitor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceMonitor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.config_type = { $case: "config", config: Struct.unwrap(Struct.decode(reader, reader.uint32())) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.config_type = { $case: "typed_config", typed_config: Any.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceMonitor {
    return {
      $type: ResourceMonitor.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      config_type: isSet(object.config)
        ? { $case: "config", config: object.config }
        : isSet(object.typed_config)
        ? { $case: "typed_config", typed_config: Any.fromJSON(object.typed_config) }
        : undefined,
    };
  },

  toJSON(message: ResourceMonitor): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.config_type?.$case === "config") {
      obj.config = message.config_type.config;
    }
    if (message.config_type?.$case === "typed_config") {
      obj.typed_config = Any.toJSON(message.config_type.typed_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResourceMonitor>, I>>(base?: I): ResourceMonitor {
    return ResourceMonitor.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResourceMonitor>, I>>(object: I): ResourceMonitor {
    const message = createBaseResourceMonitor();
    message.name = object.name ?? undefined;
    if (
      object.config_type?.$case === "config" &&
      object.config_type?.config !== undefined &&
      object.config_type?.config !== null
    ) {
      message.config_type = { $case: "config", config: object.config_type.config };
    }
    if (
      object.config_type?.$case === "typed_config" &&
      object.config_type?.typed_config !== undefined &&
      object.config_type?.typed_config !== null
    ) {
      message.config_type = { $case: "typed_config", typed_config: Any.fromPartial(object.config_type.typed_config) };
    }
    return message;
  },
};

messageTypeRegistry.set(ResourceMonitor.$type, ResourceMonitor);

function createBaseThresholdTrigger(): ThresholdTrigger {
  return { $type: "envoy.config.overload.v2alpha.ThresholdTrigger" };
}

export const ThresholdTrigger: MessageFns<ThresholdTrigger, "envoy.config.overload.v2alpha.ThresholdTrigger"> = {
  $type: "envoy.config.overload.v2alpha.ThresholdTrigger" as const,

  encode(message: ThresholdTrigger, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined && message.value !== 0) {
      writer.uint32(9).double(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ThresholdTrigger {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseThresholdTrigger();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.value = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ThresholdTrigger {
    return { $type: ThresholdTrigger.$type, value: isSet(object.value) ? globalThis.Number(object.value) : undefined };
  },

  toJSON(message: ThresholdTrigger): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ThresholdTrigger>, I>>(base?: I): ThresholdTrigger {
    return ThresholdTrigger.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ThresholdTrigger>, I>>(object: I): ThresholdTrigger {
    const message = createBaseThresholdTrigger();
    message.value = object.value ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ThresholdTrigger.$type, ThresholdTrigger);

function createBaseTrigger(): Trigger {
  return { $type: "envoy.config.overload.v2alpha.Trigger", trigger_oneof: undefined };
}

export const Trigger: MessageFns<Trigger, "envoy.config.overload.v2alpha.Trigger"> = {
  $type: "envoy.config.overload.v2alpha.Trigger" as const,

  encode(message: Trigger, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    switch (message.trigger_oneof?.$case) {
      case "threshold":
        ThresholdTrigger.encode(message.trigger_oneof.threshold, writer.uint32(18).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Trigger {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrigger();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.trigger_oneof = { $case: "threshold", threshold: ThresholdTrigger.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Trigger {
    return {
      $type: Trigger.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      trigger_oneof: isSet(object.threshold)
        ? { $case: "threshold", threshold: ThresholdTrigger.fromJSON(object.threshold) }
        : undefined,
    };
  },

  toJSON(message: Trigger): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.trigger_oneof?.$case === "threshold") {
      obj.threshold = ThresholdTrigger.toJSON(message.trigger_oneof.threshold);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Trigger>, I>>(base?: I): Trigger {
    return Trigger.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Trigger>, I>>(object: I): Trigger {
    const message = createBaseTrigger();
    message.name = object.name ?? undefined;
    if (
      object.trigger_oneof?.$case === "threshold" &&
      object.trigger_oneof?.threshold !== undefined &&
      object.trigger_oneof?.threshold !== null
    ) {
      message.trigger_oneof = {
        $case: "threshold",
        threshold: ThresholdTrigger.fromPartial(object.trigger_oneof.threshold),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(Trigger.$type, Trigger);

function createBaseOverloadAction(): OverloadAction {
  return { $type: "envoy.config.overload.v2alpha.OverloadAction" };
}

export const OverloadAction: MessageFns<OverloadAction, "envoy.config.overload.v2alpha.OverloadAction"> = {
  $type: "envoy.config.overload.v2alpha.OverloadAction" as const,

  encode(message: OverloadAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.triggers !== undefined && message.triggers.length !== 0) {
      for (const v of message.triggers) {
        Trigger.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OverloadAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOverloadAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.triggers === undefined) {
            message.triggers = [];
          }
          const el = Trigger.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.triggers!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OverloadAction {
    return {
      $type: OverloadAction.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      triggers: globalThis.Array.isArray(object?.triggers)
        ? object.triggers.map((e: any) => Trigger.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: OverloadAction): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.triggers?.length) {
      obj.triggers = message.triggers.map((e) => Trigger.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OverloadAction>, I>>(base?: I): OverloadAction {
    return OverloadAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OverloadAction>, I>>(object: I): OverloadAction {
    const message = createBaseOverloadAction();
    message.name = object.name ?? undefined;
    message.triggers = object.triggers?.map((e) => Trigger.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(OverloadAction.$type, OverloadAction);

function createBaseOverloadManager(): OverloadManager {
  return { $type: "envoy.config.overload.v2alpha.OverloadManager" };
}

export const OverloadManager: MessageFns<OverloadManager, "envoy.config.overload.v2alpha.OverloadManager"> = {
  $type: "envoy.config.overload.v2alpha.OverloadManager" as const,

  encode(message: OverloadManager, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.refresh_interval !== undefined) {
      Duration.encode(message.refresh_interval, writer.uint32(10).fork()).join();
    }
    if (message.resource_monitors !== undefined && message.resource_monitors.length !== 0) {
      for (const v of message.resource_monitors) {
        ResourceMonitor.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.actions !== undefined && message.actions.length !== 0) {
      for (const v of message.actions) {
        OverloadAction.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OverloadManager {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOverloadManager();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.refresh_interval = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.resource_monitors === undefined) {
            message.resource_monitors = [];
          }
          const el = ResourceMonitor.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.resource_monitors!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.actions === undefined) {
            message.actions = [];
          }
          const el = OverloadAction.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.actions!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OverloadManager {
    return {
      $type: OverloadManager.$type,
      refresh_interval: isSet(object.refresh_interval) ? Duration.fromJSON(object.refresh_interval) : undefined,
      resource_monitors: globalThis.Array.isArray(object?.resource_monitors)
        ? object.resource_monitors.map((e: any) => ResourceMonitor.fromJSON(e))
        : undefined,
      actions: globalThis.Array.isArray(object?.actions)
        ? object.actions.map((e: any) => OverloadAction.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: OverloadManager): unknown {
    const obj: any = {};
    if (message.refresh_interval !== undefined) {
      obj.refresh_interval = Duration.toJSON(message.refresh_interval);
    }
    if (message.resource_monitors?.length) {
      obj.resource_monitors = message.resource_monitors.map((e) => ResourceMonitor.toJSON(e));
    }
    if (message.actions?.length) {
      obj.actions = message.actions.map((e) => OverloadAction.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OverloadManager>, I>>(base?: I): OverloadManager {
    return OverloadManager.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OverloadManager>, I>>(object: I): OverloadManager {
    const message = createBaseOverloadManager();
    message.refresh_interval = (object.refresh_interval !== undefined && object.refresh_interval !== null)
      ? Duration.fromPartial(object.refresh_interval)
      : undefined;
    message.resource_monitors = object.resource_monitors?.map((e) => ResourceMonitor.fromPartial(e)) || undefined;
    message.actions = object.actions?.map((e) => OverloadAction.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(OverloadManager.$type, OverloadManager);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
