// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/config/rbac/v2/rbac.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Expr } from "../../../../google/api/expr/v1alpha1/syntax";
import { messageTypeRegistry } from "../../../../typeRegistry";
import { CidrRange } from "../../../api/v2/core/address";
import { HeaderMatcher } from "../../../api/v2/route/route_components";
import { MetadataMatcher } from "../../../type/matcher/metadata";
import { PathMatcher } from "../../../type/matcher/path";
import { StringMatcher } from "../../../type/matcher/string";

export const protobufPackage = "envoy.config.rbac.v2";

/**
 * Role Based Access Control (RBAC) provides service-level and method-level access control for a
 * service. RBAC policies are additive. The policies are examined in order. A request is allowed
 * once a matching policy is found (suppose the `action` is ALLOW).
 *
 * Here is an example of RBAC configuration. It has two policies:
 *
 * * Service account "cluster.local/ns/default/sa/admin" has full access to the service, and so
 *   does "cluster.local/ns/default/sa/superuser".
 *
 * * Any user can read ("GET") the service at paths with prefix "/products", so long as the
 *   destination port is either 80 or 443.
 *
 *  .. code-block:: yaml
 *
 *   action: ALLOW
 *   policies:
 *     "service-admin":
 *       permissions:
 *         - any: true
 *       principals:
 *         - authenticated:
 *             principal_name:
 *               exact: "cluster.local/ns/default/sa/admin"
 *         - authenticated:
 *             principal_name:
 *               exact: "cluster.local/ns/default/sa/superuser"
 *     "product-viewer":
 *       permissions:
 *           - and_rules:
 *               rules:
 *                 - header: { name: ":method", exact_match: "GET" }
 *                 - url_path:
 *                     path: { prefix: "/products" }
 *                 - or_rules:
 *                     rules:
 *                       - destination_port: 80
 *                       - destination_port: 443
 *       principals:
 *         - any: true
 */
export interface RBAC {
  $type: "envoy.config.rbac.v2.RBAC";
  /**
   * The action to take if a policy matches. The request is allowed if and only if:
   *
   *   * `action` is "ALLOWED" and at least one policy matches
   *   * `action` is "DENY" and none of the policies match
   */
  action?:
    | RBAC_Action
    | undefined;
  /** Maps from policy name to policy. A match occurs when at least one policy matches the request. */
  policies?: Map<string, Policy> | undefined;
}

/** Should we do safe-list or block-list style access control? */
export enum RBAC_Action {
  /**
   * ALLOW - The policies grant access to principals. The rest is denied. This is safe-list style
   * access control. This is the default type.
   */
  ALLOW = "ALLOW",
  /**
   * DENY - The policies deny access to principals. The rest is allowed. This is block-list style
   * access control.
   */
  DENY = "DENY",
}

export function rBAC_ActionFromJSON(object: any): RBAC_Action {
  switch (object) {
    case 0:
    case "ALLOW":
      return RBAC_Action.ALLOW;
    case 1:
    case "DENY":
      return RBAC_Action.DENY;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RBAC_Action");
  }
}

export function rBAC_ActionToJSON(object: RBAC_Action): string {
  switch (object) {
    case RBAC_Action.ALLOW:
      return "ALLOW";
    case RBAC_Action.DENY:
      return "DENY";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RBAC_Action");
  }
}

export function rBAC_ActionToNumber(object: RBAC_Action): number {
  switch (object) {
    case RBAC_Action.ALLOW:
      return 0;
    case RBAC_Action.DENY:
      return 1;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RBAC_Action");
  }
}

export interface RBAC_PoliciesEntry {
  $type: "envoy.config.rbac.v2.RBAC.PoliciesEntry";
  key: string;
  value?: Policy | undefined;
}

/**
 * Policy specifies a role and the principals that are assigned/denied the role. A policy matches if
 * and only if at least one of its permissions match the action taking place AND at least one of its
 * principals match the downstream AND the condition is true if specified.
 */
export interface Policy {
  $type: "envoy.config.rbac.v2.Policy";
  /**
   * Required. The set of permissions that define a role. Each permission is matched with OR
   * semantics. To match all actions for this policy, a single Permission with the `any` field set
   * to true should be used.
   */
  permissions?:
    | Permission[]
    | undefined;
  /**
   * Required. The set of principals that are assigned/denied the role based on “action”. Each
   * principal is matched with OR semantics. To match all downstreams for this policy, a single
   * Principal with the `any` field set to true should be used.
   */
  principals?:
    | Principal[]
    | undefined;
  /**
   * An optional symbolic expression specifying an access control
   * :ref:`condition <arch_overview_condition>`. The condition is combined
   * with the permissions and the principals as a clause with AND semantics.
   */
  condition?: Expr | undefined;
}

/**
 * Permission defines an action (or actions) that a principal can take.
 * [#next-free-field: 11]
 */
export interface Permission {
  $type: "envoy.config.rbac.v2.Permission";
  rule?:
    | //
    /** A set of rules that all must match in order to define the action. */
    { $case: "and_rules"; and_rules: Permission_Set }
    | //
    /** A set of rules where at least one must match in order to define the action. */
    { $case: "or_rules"; or_rules: Permission_Set }
    | //
    /** When any is set, it matches any action. */
    { $case: "any"; any: boolean }
    | //
    /**
     * A header (or pseudo-header such as :path or :method) on the incoming HTTP request. Only
     * available for HTTP request.
     * Note: the pseudo-header :path includes the query and fragment string. Use the `url_path`
     * field if you want to match the URL path without the query and fragment string.
     */
    { $case: "header"; header: HeaderMatcher }
    | //
    /** A URL path on the incoming HTTP request. Only available for HTTP. */
    { $case: "url_path"; url_path: PathMatcher }
    | //
    /** A CIDR block that describes the destination IP. */
    { $case: "destination_ip"; destination_ip: CidrRange }
    | //
    /** A port number that describes the destination port connecting to. */
    { $case: "destination_port"; destination_port: number }
    | //
    /** Metadata that describes additional information about the action. */
    { $case: "metadata"; metadata: MetadataMatcher }
    | //
    /**
     * Negates matching the provided permission. For instance, if the value of `not_rule` would
     * match, this permission would not match. Conversely, if the value of `not_rule` would not
     * match, this permission would match.
     */
    { $case: "not_rule"; not_rule: Permission }
    | //
    /**
     * The request server from the client's connection request. This is
     * typically TLS SNI.
     *
     * .. attention::
     *
     *   The behavior of this field may be affected by how Envoy is configured
     *   as explained below.
     *
     *   * If the :ref:`TLS Inspector <config_listener_filters_tls_inspector>`
     *     filter is not added, and if a `FilterChainMatch` is not defined for
     *     the :ref:`server name <envoy_api_field_listener.FilterChainMatch.server_names>`,
     *     a TLS connection's requested SNI server name will be treated as if it
     *     wasn't present.
     *
     *   * A :ref:`listener filter <arch_overview_listener_filters>` may
     *     overwrite a connection's requested server name within Envoy.
     *
     * Please refer to :ref:`this FAQ entry <faq_how_to_setup_sni>` to learn to
     * setup SNI.
     */
    { $case: "requested_server_name"; requested_server_name: StringMatcher }
    | undefined;
}

/**
 * Used in the `and_rules` and `or_rules` fields in the `rule` oneof. Depending on the context,
 * each are applied with the associated behavior.
 */
export interface Permission_Set {
  $type: "envoy.config.rbac.v2.Permission.Set";
  rules?: Permission[] | undefined;
}

/**
 * Principal defines an identity or a group of identities for a downstream subject.
 * [#next-free-field: 12]
 */
export interface Principal {
  $type: "envoy.config.rbac.v2.Principal";
  identifier?:
    | //
    /** A set of identifiers that all must match in order to define the downstream. */
    { $case: "and_ids"; and_ids: Principal_Set }
    | //
    /** A set of identifiers at least one must match in order to define the downstream. */
    { $case: "or_ids"; or_ids: Principal_Set }
    | //
    /** When any is set, it matches any downstream. */
    { $case: "any"; any: boolean }
    | //
    /** Authenticated attributes that identify the downstream. */
    { $case: "authenticated"; authenticated: Principal_Authenticated }
    | //
    /**
     * A CIDR block that describes the downstream IP.
     * This address will honor proxy protocol, but will not honor XFF.
     */
    { $case: "source_ip"; source_ip: CidrRange }
    | //
    /**
     * A CIDR block that describes the downstream remote/origin address.
     * Note: This is always the physical peer even if the
     * :ref:`remote_ip <envoy_api_field_config.rbac.v2.Principal.remote_ip>` is inferred
     * from for example the x-forwarder-for header, proxy protocol, etc.
     */
    { $case: "direct_remote_ip"; direct_remote_ip: CidrRange }
    | //
    /**
     * A CIDR block that describes the downstream remote/origin address.
     * Note: This may not be the physical peer and could be different from the
     * :ref:`direct_remote_ip <envoy_api_field_config.rbac.v2.Principal.direct_remote_ip>`.
     * E.g, if the remote ip is inferred from for example the x-forwarder-for header,
     * proxy protocol, etc.
     */
    { $case: "remote_ip"; remote_ip: CidrRange }
    | //
    /**
     * A header (or pseudo-header such as :path or :method) on the incoming HTTP request. Only
     * available for HTTP request.
     * Note: the pseudo-header :path includes the query and fragment string. Use the `url_path`
     * field if you want to match the URL path without the query and fragment string.
     */
    { $case: "header"; header: HeaderMatcher }
    | //
    /** A URL path on the incoming HTTP request. Only available for HTTP. */
    { $case: "url_path"; url_path: PathMatcher }
    | //
    /** Metadata that describes additional information about the principal. */
    { $case: "metadata"; metadata: MetadataMatcher }
    | //
    /**
     * Negates matching the provided principal. For instance, if the value of `not_id` would match,
     * this principal would not match. Conversely, if the value of `not_id` would not match, this
     * principal would match.
     */
    { $case: "not_id"; not_id: Principal }
    | undefined;
}

/**
 * Used in the `and_ids` and `or_ids` fields in the `identifier` oneof. Depending on the context,
 * each are applied with the associated behavior.
 */
export interface Principal_Set {
  $type: "envoy.config.rbac.v2.Principal.Set";
  ids?: Principal[] | undefined;
}

/** Authentication attributes for a downstream. */
export interface Principal_Authenticated {
  $type: "envoy.config.rbac.v2.Principal.Authenticated";
  /**
   * The name of the principal. If set, The URI SAN or DNS SAN in that order is used from the
   * certificate, otherwise the subject field is used. If unset, it applies to any user that is
   * authenticated.
   */
  principal_name?: StringMatcher | undefined;
}

function createBaseRBAC(): RBAC {
  return { $type: "envoy.config.rbac.v2.RBAC" };
}

export const RBAC: MessageFns<RBAC, "envoy.config.rbac.v2.RBAC"> = {
  $type: "envoy.config.rbac.v2.RBAC" as const,

  encode(message: RBAC, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.action !== undefined && message.action !== RBAC_Action.ALLOW) {
      writer.uint32(8).int32(rBAC_ActionToNumber(message.action));
    }
    (message.policies || new Map()).forEach((value, key) => {
      RBAC_PoliciesEntry.encode(
        { $type: "envoy.config.rbac.v2.RBAC.PoliciesEntry", key: key as any, value },
        writer.uint32(18).fork(),
      ).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RBAC {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRBAC();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.action = rBAC_ActionFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = RBAC_PoliciesEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            if (message.policies === undefined) {
              message.policies = new Map();
            }
            message.policies!.set(entry2.key, entry2.value);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RBAC {
    return {
      $type: RBAC.$type,
      action: isSet(object.action) ? rBAC_ActionFromJSON(object.action) : undefined,
      policies: isObject(object.policies)
        ? Object.entries(object.policies).reduce<Map<string, Policy>>((acc, [key, value]) => {
          acc.set(key, Policy.fromJSON(value));
          return acc;
        }, new Map())
        : undefined,
    };
  },

  toJSON(message: RBAC): unknown {
    const obj: any = {};
    if (message.action !== undefined) {
      obj.action = rBAC_ActionToJSON(message.action);
    }
    if (message.policies?.size) {
      obj.policies = {};
      message.policies.forEach((v, k) => {
        obj.policies[k] = Policy.toJSON(v);
      });
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RBAC>, I>>(base?: I): RBAC {
    return RBAC.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RBAC>, I>>(object: I): RBAC {
    const message = createBaseRBAC();
    message.action = object.action ?? undefined;
    message.policies = (object.policies === undefined || object.policies === null) ? undefined : (() => {
      const m = new Map();
      (object.policies as Map<string, Policy> ?? new Map()).forEach((value, key) => {
        if (value !== undefined) {
          m.set(key, Policy.fromPartial(value));
        }
      });
      return m;
    })();
    return message;
  },
};

messageTypeRegistry.set(RBAC.$type, RBAC);

function createBaseRBAC_PoliciesEntry(): RBAC_PoliciesEntry {
  return { $type: "envoy.config.rbac.v2.RBAC.PoliciesEntry", key: "" };
}

export const RBAC_PoliciesEntry: MessageFns<RBAC_PoliciesEntry, "envoy.config.rbac.v2.RBAC.PoliciesEntry"> = {
  $type: "envoy.config.rbac.v2.RBAC.PoliciesEntry" as const,

  encode(message: RBAC_PoliciesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Policy.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RBAC_PoliciesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRBAC_PoliciesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Policy.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RBAC_PoliciesEntry {
    return {
      $type: RBAC_PoliciesEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Policy.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: RBAC_PoliciesEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Policy.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RBAC_PoliciesEntry>, I>>(base?: I): RBAC_PoliciesEntry {
    return RBAC_PoliciesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RBAC_PoliciesEntry>, I>>(object: I): RBAC_PoliciesEntry {
    const message = createBaseRBAC_PoliciesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Policy.fromPartial(object.value)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(RBAC_PoliciesEntry.$type, RBAC_PoliciesEntry);

function createBasePolicy(): Policy {
  return { $type: "envoy.config.rbac.v2.Policy" };
}

export const Policy: MessageFns<Policy, "envoy.config.rbac.v2.Policy"> = {
  $type: "envoy.config.rbac.v2.Policy" as const,

  encode(message: Policy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.permissions !== undefined && message.permissions.length !== 0) {
      for (const v of message.permissions) {
        Permission.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    if (message.principals !== undefined && message.principals.length !== 0) {
      for (const v of message.principals) {
        Principal.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.condition !== undefined) {
      Expr.encode(message.condition, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Policy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.permissions === undefined) {
            message.permissions = [];
          }
          const el = Permission.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.permissions!.push(el);
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.principals === undefined) {
            message.principals = [];
          }
          const el = Principal.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.principals!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.condition = Expr.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Policy {
    return {
      $type: Policy.$type,
      permissions: globalThis.Array.isArray(object?.permissions)
        ? object.permissions.map((e: any) => Permission.fromJSON(e))
        : undefined,
      principals: globalThis.Array.isArray(object?.principals)
        ? object.principals.map((e: any) => Principal.fromJSON(e))
        : undefined,
      condition: isSet(object.condition) ? Expr.fromJSON(object.condition) : undefined,
    };
  },

  toJSON(message: Policy): unknown {
    const obj: any = {};
    if (message.permissions?.length) {
      obj.permissions = message.permissions.map((e) => Permission.toJSON(e));
    }
    if (message.principals?.length) {
      obj.principals = message.principals.map((e) => Principal.toJSON(e));
    }
    if (message.condition !== undefined) {
      obj.condition = Expr.toJSON(message.condition);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Policy>, I>>(base?: I): Policy {
    return Policy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Policy>, I>>(object: I): Policy {
    const message = createBasePolicy();
    message.permissions = object.permissions?.map((e) => Permission.fromPartial(e)) || undefined;
    message.principals = object.principals?.map((e) => Principal.fromPartial(e)) || undefined;
    message.condition = (object.condition !== undefined && object.condition !== null)
      ? Expr.fromPartial(object.condition)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Policy.$type, Policy);

function createBasePermission(): Permission {
  return { $type: "envoy.config.rbac.v2.Permission", rule: undefined };
}

export const Permission: MessageFns<Permission, "envoy.config.rbac.v2.Permission"> = {
  $type: "envoy.config.rbac.v2.Permission" as const,

  encode(message: Permission, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.rule?.$case) {
      case "and_rules":
        Permission_Set.encode(message.rule.and_rules, writer.uint32(10).fork()).join();
        break;
      case "or_rules":
        Permission_Set.encode(message.rule.or_rules, writer.uint32(18).fork()).join();
        break;
      case "any":
        writer.uint32(24).bool(message.rule.any);
        break;
      case "header":
        HeaderMatcher.encode(message.rule.header, writer.uint32(34).fork()).join();
        break;
      case "url_path":
        PathMatcher.encode(message.rule.url_path, writer.uint32(82).fork()).join();
        break;
      case "destination_ip":
        CidrRange.encode(message.rule.destination_ip, writer.uint32(42).fork()).join();
        break;
      case "destination_port":
        writer.uint32(48).uint32(message.rule.destination_port);
        break;
      case "metadata":
        MetadataMatcher.encode(message.rule.metadata, writer.uint32(58).fork()).join();
        break;
      case "not_rule":
        Permission.encode(message.rule.not_rule, writer.uint32(66).fork()).join();
        break;
      case "requested_server_name":
        StringMatcher.encode(message.rule.requested_server_name, writer.uint32(74).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Permission {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePermission();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rule = { $case: "and_rules", and_rules: Permission_Set.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rule = { $case: "or_rules", or_rules: Permission_Set.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.rule = { $case: "any", any: reader.bool() };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.rule = { $case: "header", header: HeaderMatcher.decode(reader, reader.uint32()) };
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.rule = { $case: "url_path", url_path: PathMatcher.decode(reader, reader.uint32()) };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.rule = { $case: "destination_ip", destination_ip: CidrRange.decode(reader, reader.uint32()) };
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.rule = { $case: "destination_port", destination_port: reader.uint32() };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.rule = { $case: "metadata", metadata: MetadataMatcher.decode(reader, reader.uint32()) };
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.rule = { $case: "not_rule", not_rule: Permission.decode(reader, reader.uint32()) };
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.rule = {
            $case: "requested_server_name",
            requested_server_name: StringMatcher.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Permission {
    return {
      $type: Permission.$type,
      rule: isSet(object.and_rules)
        ? { $case: "and_rules", and_rules: Permission_Set.fromJSON(object.and_rules) }
        : isSet(object.or_rules)
        ? { $case: "or_rules", or_rules: Permission_Set.fromJSON(object.or_rules) }
        : isSet(object.any)
        ? { $case: "any", any: globalThis.Boolean(object.any) }
        : isSet(object.header)
        ? { $case: "header", header: HeaderMatcher.fromJSON(object.header) }
        : isSet(object.url_path)
        ? { $case: "url_path", url_path: PathMatcher.fromJSON(object.url_path) }
        : isSet(object.destination_ip)
        ? { $case: "destination_ip", destination_ip: CidrRange.fromJSON(object.destination_ip) }
        : isSet(object.destination_port)
        ? { $case: "destination_port", destination_port: globalThis.Number(object.destination_port) }
        : isSet(object.metadata)
        ? { $case: "metadata", metadata: MetadataMatcher.fromJSON(object.metadata) }
        : isSet(object.not_rule)
        ? { $case: "not_rule", not_rule: Permission.fromJSON(object.not_rule) }
        : isSet(object.requested_server_name)
        ? {
          $case: "requested_server_name",
          requested_server_name: StringMatcher.fromJSON(object.requested_server_name),
        }
        : undefined,
    };
  },

  toJSON(message: Permission): unknown {
    const obj: any = {};
    if (message.rule?.$case === "and_rules") {
      obj.and_rules = Permission_Set.toJSON(message.rule.and_rules);
    }
    if (message.rule?.$case === "or_rules") {
      obj.or_rules = Permission_Set.toJSON(message.rule.or_rules);
    }
    if (message.rule?.$case === "any") {
      obj.any = message.rule.any;
    }
    if (message.rule?.$case === "header") {
      obj.header = HeaderMatcher.toJSON(message.rule.header);
    }
    if (message.rule?.$case === "url_path") {
      obj.url_path = PathMatcher.toJSON(message.rule.url_path);
    }
    if (message.rule?.$case === "destination_ip") {
      obj.destination_ip = CidrRange.toJSON(message.rule.destination_ip);
    }
    if (message.rule?.$case === "destination_port") {
      obj.destination_port = Math.round(message.rule.destination_port);
    }
    if (message.rule?.$case === "metadata") {
      obj.metadata = MetadataMatcher.toJSON(message.rule.metadata);
    }
    if (message.rule?.$case === "not_rule") {
      obj.not_rule = Permission.toJSON(message.rule.not_rule);
    }
    if (message.rule?.$case === "requested_server_name") {
      obj.requested_server_name = StringMatcher.toJSON(message.rule.requested_server_name);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Permission>, I>>(base?: I): Permission {
    return Permission.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Permission>, I>>(object: I): Permission {
    const message = createBasePermission();
    if (object.rule?.$case === "and_rules" && object.rule?.and_rules !== undefined && object.rule?.and_rules !== null) {
      message.rule = { $case: "and_rules", and_rules: Permission_Set.fromPartial(object.rule.and_rules) };
    }
    if (object.rule?.$case === "or_rules" && object.rule?.or_rules !== undefined && object.rule?.or_rules !== null) {
      message.rule = { $case: "or_rules", or_rules: Permission_Set.fromPartial(object.rule.or_rules) };
    }
    if (object.rule?.$case === "any" && object.rule?.any !== undefined && object.rule?.any !== null) {
      message.rule = { $case: "any", any: object.rule.any };
    }
    if (object.rule?.$case === "header" && object.rule?.header !== undefined && object.rule?.header !== null) {
      message.rule = { $case: "header", header: HeaderMatcher.fromPartial(object.rule.header) };
    }
    if (object.rule?.$case === "url_path" && object.rule?.url_path !== undefined && object.rule?.url_path !== null) {
      message.rule = { $case: "url_path", url_path: PathMatcher.fromPartial(object.rule.url_path) };
    }
    if (
      object.rule?.$case === "destination_ip" &&
      object.rule?.destination_ip !== undefined &&
      object.rule?.destination_ip !== null
    ) {
      message.rule = { $case: "destination_ip", destination_ip: CidrRange.fromPartial(object.rule.destination_ip) };
    }
    if (
      object.rule?.$case === "destination_port" &&
      object.rule?.destination_port !== undefined &&
      object.rule?.destination_port !== null
    ) {
      message.rule = { $case: "destination_port", destination_port: object.rule.destination_port };
    }
    if (object.rule?.$case === "metadata" && object.rule?.metadata !== undefined && object.rule?.metadata !== null) {
      message.rule = { $case: "metadata", metadata: MetadataMatcher.fromPartial(object.rule.metadata) };
    }
    if (object.rule?.$case === "not_rule" && object.rule?.not_rule !== undefined && object.rule?.not_rule !== null) {
      message.rule = { $case: "not_rule", not_rule: Permission.fromPartial(object.rule.not_rule) };
    }
    if (
      object.rule?.$case === "requested_server_name" &&
      object.rule?.requested_server_name !== undefined &&
      object.rule?.requested_server_name !== null
    ) {
      message.rule = {
        $case: "requested_server_name",
        requested_server_name: StringMatcher.fromPartial(object.rule.requested_server_name),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(Permission.$type, Permission);

function createBasePermission_Set(): Permission_Set {
  return { $type: "envoy.config.rbac.v2.Permission.Set" };
}

export const Permission_Set: MessageFns<Permission_Set, "envoy.config.rbac.v2.Permission.Set"> = {
  $type: "envoy.config.rbac.v2.Permission.Set" as const,

  encode(message: Permission_Set, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rules !== undefined && message.rules.length !== 0) {
      for (const v of message.rules) {
        Permission.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Permission_Set {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePermission_Set();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.rules === undefined) {
            message.rules = [];
          }
          const el = Permission.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.rules!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Permission_Set {
    return {
      $type: Permission_Set.$type,
      rules: globalThis.Array.isArray(object?.rules) ? object.rules.map((e: any) => Permission.fromJSON(e)) : undefined,
    };
  },

  toJSON(message: Permission_Set): unknown {
    const obj: any = {};
    if (message.rules?.length) {
      obj.rules = message.rules.map((e) => Permission.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Permission_Set>, I>>(base?: I): Permission_Set {
    return Permission_Set.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Permission_Set>, I>>(object: I): Permission_Set {
    const message = createBasePermission_Set();
    message.rules = object.rules?.map((e) => Permission.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(Permission_Set.$type, Permission_Set);

function createBasePrincipal(): Principal {
  return { $type: "envoy.config.rbac.v2.Principal", identifier: undefined };
}

export const Principal: MessageFns<Principal, "envoy.config.rbac.v2.Principal"> = {
  $type: "envoy.config.rbac.v2.Principal" as const,

  encode(message: Principal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.identifier?.$case) {
      case "and_ids":
        Principal_Set.encode(message.identifier.and_ids, writer.uint32(10).fork()).join();
        break;
      case "or_ids":
        Principal_Set.encode(message.identifier.or_ids, writer.uint32(18).fork()).join();
        break;
      case "any":
        writer.uint32(24).bool(message.identifier.any);
        break;
      case "authenticated":
        Principal_Authenticated.encode(message.identifier.authenticated, writer.uint32(34).fork()).join();
        break;
      case "source_ip":
        CidrRange.encode(message.identifier.source_ip, writer.uint32(42).fork()).join();
        break;
      case "direct_remote_ip":
        CidrRange.encode(message.identifier.direct_remote_ip, writer.uint32(82).fork()).join();
        break;
      case "remote_ip":
        CidrRange.encode(message.identifier.remote_ip, writer.uint32(90).fork()).join();
        break;
      case "header":
        HeaderMatcher.encode(message.identifier.header, writer.uint32(50).fork()).join();
        break;
      case "url_path":
        PathMatcher.encode(message.identifier.url_path, writer.uint32(74).fork()).join();
        break;
      case "metadata":
        MetadataMatcher.encode(message.identifier.metadata, writer.uint32(58).fork()).join();
        break;
      case "not_id":
        Principal.encode(message.identifier.not_id, writer.uint32(66).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Principal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrincipal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.identifier = { $case: "and_ids", and_ids: Principal_Set.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.identifier = { $case: "or_ids", or_ids: Principal_Set.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.identifier = { $case: "any", any: reader.bool() };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.identifier = {
            $case: "authenticated",
            authenticated: Principal_Authenticated.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.identifier = { $case: "source_ip", source_ip: CidrRange.decode(reader, reader.uint32()) };
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.identifier = {
            $case: "direct_remote_ip",
            direct_remote_ip: CidrRange.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.identifier = { $case: "remote_ip", remote_ip: CidrRange.decode(reader, reader.uint32()) };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.identifier = { $case: "header", header: HeaderMatcher.decode(reader, reader.uint32()) };
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.identifier = { $case: "url_path", url_path: PathMatcher.decode(reader, reader.uint32()) };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.identifier = { $case: "metadata", metadata: MetadataMatcher.decode(reader, reader.uint32()) };
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.identifier = { $case: "not_id", not_id: Principal.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Principal {
    return {
      $type: Principal.$type,
      identifier: isSet(object.and_ids)
        ? { $case: "and_ids", and_ids: Principal_Set.fromJSON(object.and_ids) }
        : isSet(object.or_ids)
        ? { $case: "or_ids", or_ids: Principal_Set.fromJSON(object.or_ids) }
        : isSet(object.any)
        ? { $case: "any", any: globalThis.Boolean(object.any) }
        : isSet(object.authenticated)
        ? { $case: "authenticated", authenticated: Principal_Authenticated.fromJSON(object.authenticated) }
        : isSet(object.source_ip)
        ? { $case: "source_ip", source_ip: CidrRange.fromJSON(object.source_ip) }
        : isSet(object.direct_remote_ip)
        ? { $case: "direct_remote_ip", direct_remote_ip: CidrRange.fromJSON(object.direct_remote_ip) }
        : isSet(object.remote_ip)
        ? { $case: "remote_ip", remote_ip: CidrRange.fromJSON(object.remote_ip) }
        : isSet(object.header)
        ? { $case: "header", header: HeaderMatcher.fromJSON(object.header) }
        : isSet(object.url_path)
        ? { $case: "url_path", url_path: PathMatcher.fromJSON(object.url_path) }
        : isSet(object.metadata)
        ? { $case: "metadata", metadata: MetadataMatcher.fromJSON(object.metadata) }
        : isSet(object.not_id)
        ? { $case: "not_id", not_id: Principal.fromJSON(object.not_id) }
        : undefined,
    };
  },

  toJSON(message: Principal): unknown {
    const obj: any = {};
    if (message.identifier?.$case === "and_ids") {
      obj.and_ids = Principal_Set.toJSON(message.identifier.and_ids);
    }
    if (message.identifier?.$case === "or_ids") {
      obj.or_ids = Principal_Set.toJSON(message.identifier.or_ids);
    }
    if (message.identifier?.$case === "any") {
      obj.any = message.identifier.any;
    }
    if (message.identifier?.$case === "authenticated") {
      obj.authenticated = Principal_Authenticated.toJSON(message.identifier.authenticated);
    }
    if (message.identifier?.$case === "source_ip") {
      obj.source_ip = CidrRange.toJSON(message.identifier.source_ip);
    }
    if (message.identifier?.$case === "direct_remote_ip") {
      obj.direct_remote_ip = CidrRange.toJSON(message.identifier.direct_remote_ip);
    }
    if (message.identifier?.$case === "remote_ip") {
      obj.remote_ip = CidrRange.toJSON(message.identifier.remote_ip);
    }
    if (message.identifier?.$case === "header") {
      obj.header = HeaderMatcher.toJSON(message.identifier.header);
    }
    if (message.identifier?.$case === "url_path") {
      obj.url_path = PathMatcher.toJSON(message.identifier.url_path);
    }
    if (message.identifier?.$case === "metadata") {
      obj.metadata = MetadataMatcher.toJSON(message.identifier.metadata);
    }
    if (message.identifier?.$case === "not_id") {
      obj.not_id = Principal.toJSON(message.identifier.not_id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Principal>, I>>(base?: I): Principal {
    return Principal.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Principal>, I>>(object: I): Principal {
    const message = createBasePrincipal();
    if (
      object.identifier?.$case === "and_ids" &&
      object.identifier?.and_ids !== undefined &&
      object.identifier?.and_ids !== null
    ) {
      message.identifier = { $case: "and_ids", and_ids: Principal_Set.fromPartial(object.identifier.and_ids) };
    }
    if (
      object.identifier?.$case === "or_ids" &&
      object.identifier?.or_ids !== undefined &&
      object.identifier?.or_ids !== null
    ) {
      message.identifier = { $case: "or_ids", or_ids: Principal_Set.fromPartial(object.identifier.or_ids) };
    }
    if (object.identifier?.$case === "any" && object.identifier?.any !== undefined && object.identifier?.any !== null) {
      message.identifier = { $case: "any", any: object.identifier.any };
    }
    if (
      object.identifier?.$case === "authenticated" &&
      object.identifier?.authenticated !== undefined &&
      object.identifier?.authenticated !== null
    ) {
      message.identifier = {
        $case: "authenticated",
        authenticated: Principal_Authenticated.fromPartial(object.identifier.authenticated),
      };
    }
    if (
      object.identifier?.$case === "source_ip" &&
      object.identifier?.source_ip !== undefined &&
      object.identifier?.source_ip !== null
    ) {
      message.identifier = { $case: "source_ip", source_ip: CidrRange.fromPartial(object.identifier.source_ip) };
    }
    if (
      object.identifier?.$case === "direct_remote_ip" &&
      object.identifier?.direct_remote_ip !== undefined &&
      object.identifier?.direct_remote_ip !== null
    ) {
      message.identifier = {
        $case: "direct_remote_ip",
        direct_remote_ip: CidrRange.fromPartial(object.identifier.direct_remote_ip),
      };
    }
    if (
      object.identifier?.$case === "remote_ip" &&
      object.identifier?.remote_ip !== undefined &&
      object.identifier?.remote_ip !== null
    ) {
      message.identifier = { $case: "remote_ip", remote_ip: CidrRange.fromPartial(object.identifier.remote_ip) };
    }
    if (
      object.identifier?.$case === "header" &&
      object.identifier?.header !== undefined &&
      object.identifier?.header !== null
    ) {
      message.identifier = { $case: "header", header: HeaderMatcher.fromPartial(object.identifier.header) };
    }
    if (
      object.identifier?.$case === "url_path" &&
      object.identifier?.url_path !== undefined &&
      object.identifier?.url_path !== null
    ) {
      message.identifier = { $case: "url_path", url_path: PathMatcher.fromPartial(object.identifier.url_path) };
    }
    if (
      object.identifier?.$case === "metadata" &&
      object.identifier?.metadata !== undefined &&
      object.identifier?.metadata !== null
    ) {
      message.identifier = { $case: "metadata", metadata: MetadataMatcher.fromPartial(object.identifier.metadata) };
    }
    if (
      object.identifier?.$case === "not_id" &&
      object.identifier?.not_id !== undefined &&
      object.identifier?.not_id !== null
    ) {
      message.identifier = { $case: "not_id", not_id: Principal.fromPartial(object.identifier.not_id) };
    }
    return message;
  },
};

messageTypeRegistry.set(Principal.$type, Principal);

function createBasePrincipal_Set(): Principal_Set {
  return { $type: "envoy.config.rbac.v2.Principal.Set" };
}

export const Principal_Set: MessageFns<Principal_Set, "envoy.config.rbac.v2.Principal.Set"> = {
  $type: "envoy.config.rbac.v2.Principal.Set" as const,

  encode(message: Principal_Set, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ids !== undefined && message.ids.length !== 0) {
      for (const v of message.ids) {
        Principal.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Principal_Set {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrincipal_Set();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.ids === undefined) {
            message.ids = [];
          }
          const el = Principal.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.ids!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Principal_Set {
    return {
      $type: Principal_Set.$type,
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => Principal.fromJSON(e)) : undefined,
    };
  },

  toJSON(message: Principal_Set): unknown {
    const obj: any = {};
    if (message.ids?.length) {
      obj.ids = message.ids.map((e) => Principal.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Principal_Set>, I>>(base?: I): Principal_Set {
    return Principal_Set.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Principal_Set>, I>>(object: I): Principal_Set {
    const message = createBasePrincipal_Set();
    message.ids = object.ids?.map((e) => Principal.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(Principal_Set.$type, Principal_Set);

function createBasePrincipal_Authenticated(): Principal_Authenticated {
  return { $type: "envoy.config.rbac.v2.Principal.Authenticated" };
}

export const Principal_Authenticated: MessageFns<
  Principal_Authenticated,
  "envoy.config.rbac.v2.Principal.Authenticated"
> = {
  $type: "envoy.config.rbac.v2.Principal.Authenticated" as const,

  encode(message: Principal_Authenticated, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.principal_name !== undefined) {
      StringMatcher.encode(message.principal_name, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Principal_Authenticated {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrincipal_Authenticated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.principal_name = StringMatcher.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Principal_Authenticated {
    return {
      $type: Principal_Authenticated.$type,
      principal_name: isSet(object.principal_name) ? StringMatcher.fromJSON(object.principal_name) : undefined,
    };
  },

  toJSON(message: Principal_Authenticated): unknown {
    const obj: any = {};
    if (message.principal_name !== undefined) {
      obj.principal_name = StringMatcher.toJSON(message.principal_name);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Principal_Authenticated>, I>>(base?: I): Principal_Authenticated {
    return Principal_Authenticated.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Principal_Authenticated>, I>>(object: I): Principal_Authenticated {
    const message = createBasePrincipal_Authenticated();
    message.principal_name = (object.principal_name !== undefined && object.principal_name !== null)
      ? StringMatcher.fromPartial(object.principal_name)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Principal_Authenticated.$type, Principal_Authenticated);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
