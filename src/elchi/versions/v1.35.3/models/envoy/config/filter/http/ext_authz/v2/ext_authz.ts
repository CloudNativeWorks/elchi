// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/config/filter/http/ext_authz/v2/ext_authz.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { messageTypeRegistry } from "../../../../../../typeRegistry";
import { HeaderValue, RuntimeFeatureFlag, RuntimeFractionalPercent } from "../../../../../api/v2/core/base";
import { GrpcService } from "../../../../../api/v2/core/grpc_service";
import { HttpUri } from "../../../../../api/v2/core/http_uri";
import { HttpStatus } from "../../../../../type/http_status";
import { ListStringMatcher } from "../../../../../type/matcher/string";

export const protobufPackage = "envoy.config.filter.http.ext_authz.v2";

/** [#next-free-field: 12] */
export interface ExtAuthz {
  $type: "envoy.config.filter.http.ext_authz.v2.ExtAuthz";
  /** External authorization service configuration. */
  services?:
    | //
    /** gRPC service configuration (default timeout: 200ms). */
    { $case: "grpc_service"; grpc_service: GrpcService }
    | //
    /** HTTP service configuration (default timeout: 200ms). */
    { $case: "http_service"; http_service: HttpService }
    | undefined;
  /**
   * Changes filter's behaviour on errors:
   *
   *  1. When set to true, the filter will *accept* client request even if the communication with
   *  the authorization service has failed, or if the authorization service has returned a HTTP 5xx
   *  error.
   *
   *  2. When set to false, ext-authz will *reject* client requests and return a *Forbidden*
   *  response if the communication with the authorization service has failed, or if the
   *  authorization service has returned a HTTP 5xx error.
   *
   * Note that errors can be *always* tracked in the :ref:`stats
   * <config_http_filters_ext_authz_stats>`.
   */
  failure_mode_allow?:
    | boolean
    | undefined;
  /**
   * [#not-implemented-hide: Support for this field has been removed.]
   *
   * @deprecated
   */
  use_alpha?:
    | boolean
    | undefined;
  /**
   * Enables filter to buffer the client request body and send it within the authorization request.
   * A ``x-envoy-auth-partial-body: false|true`` metadata header will be added to the authorization
   * request message indicating if the body data is partial.
   */
  with_request_body?:
    | BufferSettings
    | undefined;
  /**
   * Clears route cache in order to allow the external authorization service to correctly affect
   * routing decisions. Filter clears all cached routes when:
   *
   * 1. The field is set to *true*.
   *
   * 2. The status returned from the authorization service is a HTTP 200 or gRPC 0.
   *
   * 3. At least one *authorization response header* is added to the client request, or is used for
   * altering another client request header.
   */
  clear_route_cache?:
    | boolean
    | undefined;
  /**
   * Sets the HTTP status that is returned to the client when there is a network error between the
   * filter and the authorization server. The default status is HTTP 403 Forbidden.
   */
  status_on_error?:
    | HttpStatus
    | undefined;
  /**
   * Specifies a list of metadata namespaces whose values, if present, will be passed to the
   * ext_authz service as an opaque *protobuf::Struct*.
   *
   * For example, if the *jwt_authn* filter is used and :ref:`payload_in_metadata
   * <envoy_api_field_config.filter.http.jwt_authn.v2alpha.JwtProvider.payload_in_metadata>` is set,
   * then the following will pass the jwt payload to the authorization server.
   *
   * .. code-block:: yaml
   *
   *    metadata_context_namespaces:
   *    - envoy.filters.http.jwt_authn
   */
  metadata_context_namespaces?:
    | string[]
    | undefined;
  /**
   * Specifies if the filter is enabled.
   *
   * If :ref:`runtime_key <envoy_api_field_core.RuntimeFractionalPercent.runtime_key>` is specified,
   * Envoy will lookup the runtime key to get the percentage of requests to filter.
   *
   * If this field is not specified, the filter will be enabled for all requests.
   */
  filter_enabled?:
    | RuntimeFractionalPercent
    | undefined;
  /**
   * Specifies whether to deny the requests, when the filter is disabled.
   * If :ref:`runtime_key <envoy_api_field_core.RuntimeFeatureFlag.runtime_key>` is specified,
   * Envoy will lookup the runtime key to determine whether to deny request for
   * filter protected path at filter disabling. If filter is disabled in
   * typed_per_filter_config for the path, requests will not be denied.
   *
   * If this field is not specified, all requests will be allowed when disabled.
   */
  deny_at_disable?:
    | RuntimeFeatureFlag
    | undefined;
  /**
   * Specifies if the peer certificate is sent to the external service.
   *
   * When this field is true, Envoy will include the peer X.509 certificate, if available, in the
   * :ref:`certificate<envoy_api_field_service.auth.v2.AttributeContext.Peer.certificate>`.
   */
  include_peer_certificate?: boolean | undefined;
}

/** Configuration for buffering the request data. */
export interface BufferSettings {
  $type: "envoy.config.filter.http.ext_authz.v2.BufferSettings";
  /**
   * Sets the maximum size of a message body that the filter will hold in memory. Envoy will return
   * *HTTP 413* and will *not* initiate the authorization process when buffer reaches the number
   * set in this field. Note that this setting will have precedence over :ref:`failure_mode_allow
   * <envoy_api_field_config.filter.http.ext_authz.v2.ExtAuthz.failure_mode_allow>`.
   */
  max_request_bytes?:
    | number
    | undefined;
  /**
   * When this field is true, Envoy will buffer the message until *max_request_bytes* is reached.
   * The authorization request will be dispatched and no 413 HTTP error will be returned by the
   * filter.
   */
  allow_partial_message?: boolean | undefined;
}

/**
 * HttpService is used for raw HTTP communication between the filter and the authorization service.
 * When configured, the filter will parse the client request and use these attributes to call the
 * authorization server. Depending on the response, the filter may reject or accept the client
 * request. Note that in any of these events, metadata can be added, removed or overridden by the
 * filter:
 *
 * *On authorization request*, a list of allowed request headers may be supplied. See
 * :ref:`allowed_headers
 * <envoy_api_field_config.filter.http.ext_authz.v2.AuthorizationRequest.allowed_headers>`
 * for details. Additional headers metadata may be added to the authorization request. See
 * :ref:`headers_to_add
 * <envoy_api_field_config.filter.http.ext_authz.v2.AuthorizationRequest.headers_to_add>` for
 * details.
 *
 * On authorization response status HTTP 200 OK, the filter will allow traffic to the upstream and
 * additional headers metadata may be added to the original client request. See
 * :ref:`allowed_upstream_headers
 * <envoy_api_field_config.filter.http.ext_authz.v2.AuthorizationResponse.allowed_upstream_headers>`
 * for details.
 *
 * On other authorization response statuses, the filter will not allow traffic. Additional headers
 * metadata as well as body may be added to the client's response. See :ref:`allowed_client_headers
 * <envoy_api_field_config.filter.http.ext_authz.v2.AuthorizationResponse.allowed_client_headers>`
 * for details.
 * [#next-free-field: 9]
 */
export interface HttpService {
  $type: "envoy.config.filter.http.ext_authz.v2.HttpService";
  /** Sets the HTTP server URI which the authorization requests must be sent to. */
  server_uri?:
    | HttpUri
    | undefined;
  /** Sets a prefix to the value of authorization request header *Path*. */
  path_prefix?:
    | string
    | undefined;
  /** Settings used for controlling authorization request metadata. */
  authorization_request?:
    | AuthorizationRequest
    | undefined;
  /** Settings used for controlling authorization response metadata. */
  authorization_response?: AuthorizationResponse | undefined;
}

export interface AuthorizationRequest {
  $type: "envoy.config.filter.http.ext_authz.v2.AuthorizationRequest";
  /**
   * Authorization request will include the client request headers that have a correspondent match
   * in the :ref:`list <envoy_api_msg_type.matcher.ListStringMatcher>`. Note that in addition to the
   * user's supplied matchers:
   *
   * 1. *Host*, *Method*, *Path* and *Content-Length* are automatically included to the list.
   *
   * 2. *Content-Length* will be set to 0 and the request to the authorization service will not have
   * a message body. However, the authorization request can include the buffered client request body
   * (controlled by :ref:`with_request_body
   * <envoy_api_field_config.filter.http.ext_authz.v2.ExtAuthz.with_request_body>` setting),
   * consequently the value of *Content-Length* of the authorization request reflects the size of
   * its payload size.
   */
  allowed_headers?:
    | ListStringMatcher
    | undefined;
  /**
   * Sets a list of headers that will be included to the request to authorization service. Note that
   * client request of the same key will be overridden.
   */
  headers_to_add?: HeaderValue[] | undefined;
}

export interface AuthorizationResponse {
  $type: "envoy.config.filter.http.ext_authz.v2.AuthorizationResponse";
  /**
   * When this :ref:`list <envoy_api_msg_type.matcher.ListStringMatcher>` is set, authorization
   * response headers that have a correspondent match will be added to the original client request.
   * Note that coexistent headers will be overridden.
   */
  allowed_upstream_headers?:
    | ListStringMatcher
    | undefined;
  /**
   * When this :ref:`list <envoy_api_msg_type.matcher.ListStringMatcher>` is set, authorization
   * response headers that have a correspondent match will be added to the client's response. Note
   * that when this list is *not* set, all the authorization response headers, except *Authority
   * (Host)* will be in the response to the client. When a header is included in this list, *Path*,
   * *Status*, *Content-Length*, *WWWAuthenticate* and *Location* are automatically added.
   */
  allowed_client_headers?: ListStringMatcher | undefined;
}

/** Extra settings on a per virtualhost/route/weighted-cluster level. */
export interface ExtAuthzPerRoute {
  $type: "envoy.config.filter.http.ext_authz.v2.ExtAuthzPerRoute";
  override?:
    | //
    /**
     * Disable the ext auth filter for this particular vhost or route.
     * If disabled is specified in multiple per-filter-configs, the most specific one will be used.
     */
    { $case: "disabled"; disabled: boolean }
    | //
    /** Check request settings for this route. */
    { $case: "check_settings"; check_settings: CheckSettings }
    | undefined;
}

/**
 * Extra settings for the check request. You can use this to provide extra context for the
 * external authorization server on specific virtual hosts \ routes. For example, adding a context
 * extension on the virtual host level can give the ext-authz server information on what virtual
 * host is used without needing to parse the host header. If CheckSettings is specified in multiple
 * per-filter-configs, they will be merged in order, and the result will be used.
 */
export interface CheckSettings {
  $type: "envoy.config.filter.http.ext_authz.v2.CheckSettings";
  /**
   * Context extensions to set on the CheckRequest's
   * :ref:`AttributeContext.context_extensions<envoy_api_field_service.auth.v2.AttributeContext.context_extensions>`
   *
   * Merge semantics for this field are such that keys from more specific configs override.
   *
   * .. note::
   *
   *   These settings are only applied to a filter configured with a
   *   :ref:`grpc_service<envoy_api_field_config.filter.http.ext_authz.v2.ExtAuthz.grpc_service>`.
   */
  context_extensions?: Map<string, string> | undefined;
}

export interface CheckSettings_ContextExtensionsEntry {
  $type: "envoy.config.filter.http.ext_authz.v2.CheckSettings.ContextExtensionsEntry";
  key: string;
  value: string;
}

function createBaseExtAuthz(): ExtAuthz {
  return { $type: "envoy.config.filter.http.ext_authz.v2.ExtAuthz", services: undefined };
}

export const ExtAuthz: MessageFns<ExtAuthz, "envoy.config.filter.http.ext_authz.v2.ExtAuthz"> = {
  $type: "envoy.config.filter.http.ext_authz.v2.ExtAuthz" as const,

  encode(message: ExtAuthz, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.services?.$case) {
      case "grpc_service":
        GrpcService.encode(message.services.grpc_service, writer.uint32(10).fork()).join();
        break;
      case "http_service":
        HttpService.encode(message.services.http_service, writer.uint32(26).fork()).join();
        break;
    }
    if (message.failure_mode_allow !== undefined && message.failure_mode_allow !== false) {
      writer.uint32(16).bool(message.failure_mode_allow);
    }
    if (message.use_alpha !== undefined && message.use_alpha !== false) {
      writer.uint32(32).bool(message.use_alpha);
    }
    if (message.with_request_body !== undefined) {
      BufferSettings.encode(message.with_request_body, writer.uint32(42).fork()).join();
    }
    if (message.clear_route_cache !== undefined && message.clear_route_cache !== false) {
      writer.uint32(48).bool(message.clear_route_cache);
    }
    if (message.status_on_error !== undefined) {
      HttpStatus.encode(message.status_on_error, writer.uint32(58).fork()).join();
    }
    if (message.metadata_context_namespaces !== undefined && message.metadata_context_namespaces.length !== 0) {
      for (const v of message.metadata_context_namespaces) {
        writer.uint32(66).string(v!);
      }
    }
    if (message.filter_enabled !== undefined) {
      RuntimeFractionalPercent.encode(message.filter_enabled, writer.uint32(74).fork()).join();
    }
    if (message.deny_at_disable !== undefined) {
      RuntimeFeatureFlag.encode(message.deny_at_disable, writer.uint32(90).fork()).join();
    }
    if (message.include_peer_certificate !== undefined && message.include_peer_certificate !== false) {
      writer.uint32(80).bool(message.include_peer_certificate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExtAuthz {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExtAuthz();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.services = { $case: "grpc_service", grpc_service: GrpcService.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.services = { $case: "http_service", http_service: HttpService.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.failure_mode_allow = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.use_alpha = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.with_request_body = BufferSettings.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.clear_route_cache = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.status_on_error = HttpStatus.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          if (message.metadata_context_namespaces === undefined) {
            message.metadata_context_namespaces = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.metadata_context_namespaces!.push(el);
          }
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.filter_enabled = RuntimeFractionalPercent.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.deny_at_disable = RuntimeFeatureFlag.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.include_peer_certificate = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExtAuthz {
    return {
      $type: ExtAuthz.$type,
      services: isSet(object.grpc_service)
        ? { $case: "grpc_service", grpc_service: GrpcService.fromJSON(object.grpc_service) }
        : isSet(object.http_service)
        ? { $case: "http_service", http_service: HttpService.fromJSON(object.http_service) }
        : undefined,
      failure_mode_allow: isSet(object.failure_mode_allow) ? globalThis.Boolean(object.failure_mode_allow) : undefined,
      use_alpha: isSet(object.use_alpha) ? globalThis.Boolean(object.use_alpha) : undefined,
      with_request_body: isSet(object.with_request_body)
        ? BufferSettings.fromJSON(object.with_request_body)
        : undefined,
      clear_route_cache: isSet(object.clear_route_cache) ? globalThis.Boolean(object.clear_route_cache) : undefined,
      status_on_error: isSet(object.status_on_error) ? HttpStatus.fromJSON(object.status_on_error) : undefined,
      metadata_context_namespaces: globalThis.Array.isArray(object?.metadata_context_namespaces)
        ? object.metadata_context_namespaces.map((e: any) => globalThis.String(e))
        : undefined,
      filter_enabled: isSet(object.filter_enabled)
        ? RuntimeFractionalPercent.fromJSON(object.filter_enabled)
        : undefined,
      deny_at_disable: isSet(object.deny_at_disable) ? RuntimeFeatureFlag.fromJSON(object.deny_at_disable) : undefined,
      include_peer_certificate: isSet(object.include_peer_certificate)
        ? globalThis.Boolean(object.include_peer_certificate)
        : undefined,
    };
  },

  toJSON(message: ExtAuthz): unknown {
    const obj: any = {};
    if (message.services?.$case === "grpc_service") {
      obj.grpc_service = GrpcService.toJSON(message.services.grpc_service);
    }
    if (message.services?.$case === "http_service") {
      obj.http_service = HttpService.toJSON(message.services.http_service);
    }
    if (message.failure_mode_allow !== undefined) {
      obj.failure_mode_allow = message.failure_mode_allow;
    }
    if (message.use_alpha !== undefined) {
      obj.use_alpha = message.use_alpha;
    }
    if (message.with_request_body !== undefined) {
      obj.with_request_body = BufferSettings.toJSON(message.with_request_body);
    }
    if (message.clear_route_cache !== undefined) {
      obj.clear_route_cache = message.clear_route_cache;
    }
    if (message.status_on_error !== undefined) {
      obj.status_on_error = HttpStatus.toJSON(message.status_on_error);
    }
    if (message.metadata_context_namespaces?.length) {
      obj.metadata_context_namespaces = message.metadata_context_namespaces;
    }
    if (message.filter_enabled !== undefined) {
      obj.filter_enabled = RuntimeFractionalPercent.toJSON(message.filter_enabled);
    }
    if (message.deny_at_disable !== undefined) {
      obj.deny_at_disable = RuntimeFeatureFlag.toJSON(message.deny_at_disable);
    }
    if (message.include_peer_certificate !== undefined) {
      obj.include_peer_certificate = message.include_peer_certificate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExtAuthz>, I>>(base?: I): ExtAuthz {
    return ExtAuthz.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExtAuthz>, I>>(object: I): ExtAuthz {
    const message = createBaseExtAuthz();
    if (
      object.services?.$case === "grpc_service" &&
      object.services?.grpc_service !== undefined &&
      object.services?.grpc_service !== null
    ) {
      message.services = { $case: "grpc_service", grpc_service: GrpcService.fromPartial(object.services.grpc_service) };
    }
    if (
      object.services?.$case === "http_service" &&
      object.services?.http_service !== undefined &&
      object.services?.http_service !== null
    ) {
      message.services = { $case: "http_service", http_service: HttpService.fromPartial(object.services.http_service) };
    }
    message.failure_mode_allow = object.failure_mode_allow ?? undefined;
    message.use_alpha = object.use_alpha ?? undefined;
    message.with_request_body = (object.with_request_body !== undefined && object.with_request_body !== null)
      ? BufferSettings.fromPartial(object.with_request_body)
      : undefined;
    message.clear_route_cache = object.clear_route_cache ?? undefined;
    message.status_on_error = (object.status_on_error !== undefined && object.status_on_error !== null)
      ? HttpStatus.fromPartial(object.status_on_error)
      : undefined;
    message.metadata_context_namespaces = object.metadata_context_namespaces?.map((e) => e) || undefined;
    message.filter_enabled = (object.filter_enabled !== undefined && object.filter_enabled !== null)
      ? RuntimeFractionalPercent.fromPartial(object.filter_enabled)
      : undefined;
    message.deny_at_disable = (object.deny_at_disable !== undefined && object.deny_at_disable !== null)
      ? RuntimeFeatureFlag.fromPartial(object.deny_at_disable)
      : undefined;
    message.include_peer_certificate = object.include_peer_certificate ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ExtAuthz.$type, ExtAuthz);

function createBaseBufferSettings(): BufferSettings {
  return { $type: "envoy.config.filter.http.ext_authz.v2.BufferSettings" };
}

export const BufferSettings: MessageFns<BufferSettings, "envoy.config.filter.http.ext_authz.v2.BufferSettings"> = {
  $type: "envoy.config.filter.http.ext_authz.v2.BufferSettings" as const,

  encode(message: BufferSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.max_request_bytes !== undefined && message.max_request_bytes !== 0) {
      writer.uint32(8).uint32(message.max_request_bytes);
    }
    if (message.allow_partial_message !== undefined && message.allow_partial_message !== false) {
      writer.uint32(16).bool(message.allow_partial_message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BufferSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBufferSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.max_request_bytes = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.allow_partial_message = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BufferSettings {
    return {
      $type: BufferSettings.$type,
      max_request_bytes: isSet(object.max_request_bytes) ? globalThis.Number(object.max_request_bytes) : undefined,
      allow_partial_message: isSet(object.allow_partial_message)
        ? globalThis.Boolean(object.allow_partial_message)
        : undefined,
    };
  },

  toJSON(message: BufferSettings): unknown {
    const obj: any = {};
    if (message.max_request_bytes !== undefined) {
      obj.max_request_bytes = Math.round(message.max_request_bytes);
    }
    if (message.allow_partial_message !== undefined) {
      obj.allow_partial_message = message.allow_partial_message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BufferSettings>, I>>(base?: I): BufferSettings {
    return BufferSettings.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BufferSettings>, I>>(object: I): BufferSettings {
    const message = createBaseBufferSettings();
    message.max_request_bytes = object.max_request_bytes ?? undefined;
    message.allow_partial_message = object.allow_partial_message ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(BufferSettings.$type, BufferSettings);

function createBaseHttpService(): HttpService {
  return { $type: "envoy.config.filter.http.ext_authz.v2.HttpService" };
}

export const HttpService: MessageFns<HttpService, "envoy.config.filter.http.ext_authz.v2.HttpService"> = {
  $type: "envoy.config.filter.http.ext_authz.v2.HttpService" as const,

  encode(message: HttpService, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.server_uri !== undefined) {
      HttpUri.encode(message.server_uri, writer.uint32(10).fork()).join();
    }
    if (message.path_prefix !== undefined && message.path_prefix !== "") {
      writer.uint32(18).string(message.path_prefix);
    }
    if (message.authorization_request !== undefined) {
      AuthorizationRequest.encode(message.authorization_request, writer.uint32(58).fork()).join();
    }
    if (message.authorization_response !== undefined) {
      AuthorizationResponse.encode(message.authorization_response, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpService {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpService();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.server_uri = HttpUri.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.path_prefix = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.authorization_request = AuthorizationRequest.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.authorization_response = AuthorizationResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpService {
    return {
      $type: HttpService.$type,
      server_uri: isSet(object.server_uri) ? HttpUri.fromJSON(object.server_uri) : undefined,
      path_prefix: isSet(object.path_prefix) ? globalThis.String(object.path_prefix) : undefined,
      authorization_request: isSet(object.authorization_request)
        ? AuthorizationRequest.fromJSON(object.authorization_request)
        : undefined,
      authorization_response: isSet(object.authorization_response)
        ? AuthorizationResponse.fromJSON(object.authorization_response)
        : undefined,
    };
  },

  toJSON(message: HttpService): unknown {
    const obj: any = {};
    if (message.server_uri !== undefined) {
      obj.server_uri = HttpUri.toJSON(message.server_uri);
    }
    if (message.path_prefix !== undefined) {
      obj.path_prefix = message.path_prefix;
    }
    if (message.authorization_request !== undefined) {
      obj.authorization_request = AuthorizationRequest.toJSON(message.authorization_request);
    }
    if (message.authorization_response !== undefined) {
      obj.authorization_response = AuthorizationResponse.toJSON(message.authorization_response);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpService>, I>>(base?: I): HttpService {
    return HttpService.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpService>, I>>(object: I): HttpService {
    const message = createBaseHttpService();
    message.server_uri = (object.server_uri !== undefined && object.server_uri !== null)
      ? HttpUri.fromPartial(object.server_uri)
      : undefined;
    message.path_prefix = object.path_prefix ?? undefined;
    message.authorization_request =
      (object.authorization_request !== undefined && object.authorization_request !== null)
        ? AuthorizationRequest.fromPartial(object.authorization_request)
        : undefined;
    message.authorization_response =
      (object.authorization_response !== undefined && object.authorization_response !== null)
        ? AuthorizationResponse.fromPartial(object.authorization_response)
        : undefined;
    return message;
  },
};

messageTypeRegistry.set(HttpService.$type, HttpService);

function createBaseAuthorizationRequest(): AuthorizationRequest {
  return { $type: "envoy.config.filter.http.ext_authz.v2.AuthorizationRequest" };
}

export const AuthorizationRequest: MessageFns<
  AuthorizationRequest,
  "envoy.config.filter.http.ext_authz.v2.AuthorizationRequest"
> = {
  $type: "envoy.config.filter.http.ext_authz.v2.AuthorizationRequest" as const,

  encode(message: AuthorizationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.allowed_headers !== undefined) {
      ListStringMatcher.encode(message.allowed_headers, writer.uint32(10).fork()).join();
    }
    if (message.headers_to_add !== undefined && message.headers_to_add.length !== 0) {
      for (const v of message.headers_to_add) {
        HeaderValue.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthorizationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthorizationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.allowed_headers = ListStringMatcher.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.headers_to_add === undefined) {
            message.headers_to_add = [];
          }
          const el = HeaderValue.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.headers_to_add!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthorizationRequest {
    return {
      $type: AuthorizationRequest.$type,
      allowed_headers: isSet(object.allowed_headers) ? ListStringMatcher.fromJSON(object.allowed_headers) : undefined,
      headers_to_add: globalThis.Array.isArray(object?.headers_to_add)
        ? object.headers_to_add.map((e: any) => HeaderValue.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: AuthorizationRequest): unknown {
    const obj: any = {};
    if (message.allowed_headers !== undefined) {
      obj.allowed_headers = ListStringMatcher.toJSON(message.allowed_headers);
    }
    if (message.headers_to_add?.length) {
      obj.headers_to_add = message.headers_to_add.map((e) => HeaderValue.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthorizationRequest>, I>>(base?: I): AuthorizationRequest {
    return AuthorizationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthorizationRequest>, I>>(object: I): AuthorizationRequest {
    const message = createBaseAuthorizationRequest();
    message.allowed_headers = (object.allowed_headers !== undefined && object.allowed_headers !== null)
      ? ListStringMatcher.fromPartial(object.allowed_headers)
      : undefined;
    message.headers_to_add = object.headers_to_add?.map((e) => HeaderValue.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(AuthorizationRequest.$type, AuthorizationRequest);

function createBaseAuthorizationResponse(): AuthorizationResponse {
  return { $type: "envoy.config.filter.http.ext_authz.v2.AuthorizationResponse" };
}

export const AuthorizationResponse: MessageFns<
  AuthorizationResponse,
  "envoy.config.filter.http.ext_authz.v2.AuthorizationResponse"
> = {
  $type: "envoy.config.filter.http.ext_authz.v2.AuthorizationResponse" as const,

  encode(message: AuthorizationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.allowed_upstream_headers !== undefined) {
      ListStringMatcher.encode(message.allowed_upstream_headers, writer.uint32(10).fork()).join();
    }
    if (message.allowed_client_headers !== undefined) {
      ListStringMatcher.encode(message.allowed_client_headers, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthorizationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthorizationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.allowed_upstream_headers = ListStringMatcher.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.allowed_client_headers = ListStringMatcher.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthorizationResponse {
    return {
      $type: AuthorizationResponse.$type,
      allowed_upstream_headers: isSet(object.allowed_upstream_headers)
        ? ListStringMatcher.fromJSON(object.allowed_upstream_headers)
        : undefined,
      allowed_client_headers: isSet(object.allowed_client_headers)
        ? ListStringMatcher.fromJSON(object.allowed_client_headers)
        : undefined,
    };
  },

  toJSON(message: AuthorizationResponse): unknown {
    const obj: any = {};
    if (message.allowed_upstream_headers !== undefined) {
      obj.allowed_upstream_headers = ListStringMatcher.toJSON(message.allowed_upstream_headers);
    }
    if (message.allowed_client_headers !== undefined) {
      obj.allowed_client_headers = ListStringMatcher.toJSON(message.allowed_client_headers);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthorizationResponse>, I>>(base?: I): AuthorizationResponse {
    return AuthorizationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthorizationResponse>, I>>(object: I): AuthorizationResponse {
    const message = createBaseAuthorizationResponse();
    message.allowed_upstream_headers =
      (object.allowed_upstream_headers !== undefined && object.allowed_upstream_headers !== null)
        ? ListStringMatcher.fromPartial(object.allowed_upstream_headers)
        : undefined;
    message.allowed_client_headers =
      (object.allowed_client_headers !== undefined && object.allowed_client_headers !== null)
        ? ListStringMatcher.fromPartial(object.allowed_client_headers)
        : undefined;
    return message;
  },
};

messageTypeRegistry.set(AuthorizationResponse.$type, AuthorizationResponse);

function createBaseExtAuthzPerRoute(): ExtAuthzPerRoute {
  return { $type: "envoy.config.filter.http.ext_authz.v2.ExtAuthzPerRoute", override: undefined };
}

export const ExtAuthzPerRoute: MessageFns<ExtAuthzPerRoute, "envoy.config.filter.http.ext_authz.v2.ExtAuthzPerRoute"> =
  {
    $type: "envoy.config.filter.http.ext_authz.v2.ExtAuthzPerRoute" as const,

    encode(message: ExtAuthzPerRoute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
      switch (message.override?.$case) {
        case "disabled":
          writer.uint32(8).bool(message.override.disabled);
          break;
        case "check_settings":
          CheckSettings.encode(message.override.check_settings, writer.uint32(18).fork()).join();
          break;
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): ExtAuthzPerRoute {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseExtAuthzPerRoute();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.override = { $case: "disabled", disabled: reader.bool() };
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.override = {
              $case: "check_settings",
              check_settings: CheckSettings.decode(reader, reader.uint32()),
            };
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): ExtAuthzPerRoute {
      return {
        $type: ExtAuthzPerRoute.$type,
        override: isSet(object.disabled)
          ? { $case: "disabled", disabled: globalThis.Boolean(object.disabled) }
          : isSet(object.check_settings)
          ? { $case: "check_settings", check_settings: CheckSettings.fromJSON(object.check_settings) }
          : undefined,
      };
    },

    toJSON(message: ExtAuthzPerRoute): unknown {
      const obj: any = {};
      if (message.override?.$case === "disabled") {
        obj.disabled = message.override.disabled;
      }
      if (message.override?.$case === "check_settings") {
        obj.check_settings = CheckSettings.toJSON(message.override.check_settings);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<ExtAuthzPerRoute>, I>>(base?: I): ExtAuthzPerRoute {
      return ExtAuthzPerRoute.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<ExtAuthzPerRoute>, I>>(object: I): ExtAuthzPerRoute {
      const message = createBaseExtAuthzPerRoute();
      if (
        object.override?.$case === "disabled" &&
        object.override?.disabled !== undefined &&
        object.override?.disabled !== null
      ) {
        message.override = { $case: "disabled", disabled: object.override.disabled };
      }
      if (
        object.override?.$case === "check_settings" &&
        object.override?.check_settings !== undefined &&
        object.override?.check_settings !== null
      ) {
        message.override = {
          $case: "check_settings",
          check_settings: CheckSettings.fromPartial(object.override.check_settings),
        };
      }
      return message;
    },
  };

messageTypeRegistry.set(ExtAuthzPerRoute.$type, ExtAuthzPerRoute);

function createBaseCheckSettings(): CheckSettings {
  return { $type: "envoy.config.filter.http.ext_authz.v2.CheckSettings" };
}

export const CheckSettings: MessageFns<CheckSettings, "envoy.config.filter.http.ext_authz.v2.CheckSettings"> = {
  $type: "envoy.config.filter.http.ext_authz.v2.CheckSettings" as const,

  encode(message: CheckSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    (message.context_extensions || new Map()).forEach((value, key) => {
      CheckSettings_ContextExtensionsEntry.encode({
        $type: "envoy.config.filter.http.ext_authz.v2.CheckSettings.ContextExtensionsEntry",
        key: key as any,
        value,
      }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = CheckSettings_ContextExtensionsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            if (message.context_extensions === undefined) {
              message.context_extensions = new Map();
            }
            message.context_extensions!.set(entry1.key, entry1.value);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckSettings {
    return {
      $type: CheckSettings.$type,
      context_extensions: isObject(object.context_extensions)
        ? Object.entries(object.context_extensions).reduce<Map<string, string>>((acc, [key, value]) => {
          acc.set(key, String(value));
          return acc;
        }, new Map())
        : undefined,
    };
  },

  toJSON(message: CheckSettings): unknown {
    const obj: any = {};
    if (message.context_extensions?.size) {
      obj.context_extensions = {};
      message.context_extensions.forEach((v, k) => {
        obj.context_extensions[k] = v;
      });
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckSettings>, I>>(base?: I): CheckSettings {
    return CheckSettings.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckSettings>, I>>(object: I): CheckSettings {
    const message = createBaseCheckSettings();
    message.context_extensions = (object.context_extensions === undefined || object.context_extensions === null)
      ? undefined
      : (() => {
        const m = new Map();
        (object.context_extensions as Map<string, string> ?? new Map()).forEach((value, key) => {
          if (value !== undefined) {
            m.set(key, globalThis.String(value));
          }
        });
        return m;
      })();
    return message;
  },
};

messageTypeRegistry.set(CheckSettings.$type, CheckSettings);

function createBaseCheckSettings_ContextExtensionsEntry(): CheckSettings_ContextExtensionsEntry {
  return { $type: "envoy.config.filter.http.ext_authz.v2.CheckSettings.ContextExtensionsEntry", key: "", value: "" };
}

export const CheckSettings_ContextExtensionsEntry: MessageFns<
  CheckSettings_ContextExtensionsEntry,
  "envoy.config.filter.http.ext_authz.v2.CheckSettings.ContextExtensionsEntry"
> = {
  $type: "envoy.config.filter.http.ext_authz.v2.CheckSettings.ContextExtensionsEntry" as const,

  encode(message: CheckSettings_ContextExtensionsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckSettings_ContextExtensionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckSettings_ContextExtensionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckSettings_ContextExtensionsEntry {
    return {
      $type: CheckSettings_ContextExtensionsEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CheckSettings_ContextExtensionsEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckSettings_ContextExtensionsEntry>, I>>(
    base?: I,
  ): CheckSettings_ContextExtensionsEntry {
    return CheckSettings_ContextExtensionsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckSettings_ContextExtensionsEntry>, I>>(
    object: I,
  ): CheckSettings_ContextExtensionsEntry {
    const message = createBaseCheckSettings_ContextExtensionsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

messageTypeRegistry.set(CheckSettings_ContextExtensionsEntry.$type, CheckSettings_ContextExtensionsEntry);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
