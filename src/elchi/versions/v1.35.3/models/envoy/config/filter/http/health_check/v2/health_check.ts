// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/config/filter/http/health_check/v2/health_check.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../../../../google/protobuf/duration";
import { BoolValue } from "../../../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../../../typeRegistry";
import { HeaderMatcher } from "../../../../../api/v2/route/route_components";
import { Percent } from "../../../../../type/percent";

export const protobufPackage = "envoy.config.filter.http.health_check.v2";

/** [#next-free-field: 6] */
export interface HealthCheck {
  $type: "envoy.config.filter.http.health_check.v2.HealthCheck";
  /** Specifies whether the filter operates in pass through mode or not. */
  pass_through_mode?:
    | boolean
    | undefined;
  /**
   * If operating in pass through mode, the amount of time in milliseconds
   * that the filter should cache the upstream response.
   */
  cache_time?:
    | Duration
    | undefined;
  /**
   * If operating in non-pass-through mode, specifies a set of upstream cluster
   * names and the minimum percentage of servers in each of those clusters that
   * must be healthy or degraded in order for the filter to return a 200.
   *
   * .. note::
   *
   *    This value is interpreted as an integer by truncating, so 12.50% will be calculated
   *    as if it were 12%.
   */
  cluster_min_healthy_percentages?:
    | Map<string, Percent>
    | undefined;
  /**
   * Specifies a set of health check request headers to match on. The health check filter will
   * check a requestâ€™s headers against all the specified headers. To specify the health check
   * endpoint, set the ``:path`` header to match on.
   */
  headers?: HeaderMatcher[] | undefined;
}

export interface HealthCheck_ClusterMinHealthyPercentagesEntry {
  $type: "envoy.config.filter.http.health_check.v2.HealthCheck.ClusterMinHealthyPercentagesEntry";
  key: string;
  value?: Percent | undefined;
}

function createBaseHealthCheck(): HealthCheck {
  return { $type: "envoy.config.filter.http.health_check.v2.HealthCheck" };
}

export const HealthCheck: MessageFns<HealthCheck, "envoy.config.filter.http.health_check.v2.HealthCheck"> = {
  $type: "envoy.config.filter.http.health_check.v2.HealthCheck" as const,

  encode(message: HealthCheck, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pass_through_mode !== undefined) {
      BoolValue.encode(
        { $type: "google.protobuf.BoolValue", value: message.pass_through_mode! },
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.cache_time !== undefined) {
      Duration.encode(message.cache_time, writer.uint32(26).fork()).join();
    }
    (message.cluster_min_healthy_percentages || new Map()).forEach((value, key) => {
      HealthCheck_ClusterMinHealthyPercentagesEntry.encode({
        $type: "envoy.config.filter.http.health_check.v2.HealthCheck.ClusterMinHealthyPercentagesEntry",
        key: key as any,
        value,
      }, writer.uint32(34).fork()).join();
    });
    if (message.headers !== undefined && message.headers.length !== 0) {
      for (const v of message.headers) {
        HeaderMatcher.encode(v!, writer.uint32(42).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheck {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pass_through_mode = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.cache_time = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = HealthCheck_ClusterMinHealthyPercentagesEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            if (message.cluster_min_healthy_percentages === undefined) {
              message.cluster_min_healthy_percentages = new Map();
            }
            message.cluster_min_healthy_percentages!.set(entry4.key, entry4.value);
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          if (message.headers === undefined) {
            message.headers = [];
          }
          const el = HeaderMatcher.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.headers!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheck {
    return {
      $type: HealthCheck.$type,
      pass_through_mode: isSet(object.pass_through_mode) ? Boolean(object.pass_through_mode) : undefined,
      cache_time: isSet(object.cache_time) ? Duration.fromJSON(object.cache_time) : undefined,
      cluster_min_healthy_percentages: isObject(object.cluster_min_healthy_percentages)
        ? Object.entries(object.cluster_min_healthy_percentages).reduce<Map<string, Percent>>((acc, [key, value]) => {
          acc.set(key, Percent.fromJSON(value));
          return acc;
        }, new Map())
        : undefined,
      headers: globalThis.Array.isArray(object?.headers)
        ? object.headers.map((e: any) => HeaderMatcher.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: HealthCheck): unknown {
    const obj: any = {};
    if (message.pass_through_mode !== undefined) {
      obj.pass_through_mode = message.pass_through_mode;
    }
    if (message.cache_time !== undefined) {
      obj.cache_time = Duration.toJSON(message.cache_time);
    }
    if (message.cluster_min_healthy_percentages?.size) {
      obj.cluster_min_healthy_percentages = {};
      message.cluster_min_healthy_percentages.forEach((v, k) => {
        obj.cluster_min_healthy_percentages[k] = Percent.toJSON(v);
      });
    }
    if (message.headers?.length) {
      obj.headers = message.headers.map((e) => HeaderMatcher.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheck>, I>>(base?: I): HealthCheck {
    return HealthCheck.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheck>, I>>(object: I): HealthCheck {
    const message = createBaseHealthCheck();
    message.pass_through_mode = object.pass_through_mode ?? undefined;
    message.cache_time = (object.cache_time !== undefined && object.cache_time !== null)
      ? Duration.fromPartial(object.cache_time)
      : undefined;
    message.cluster_min_healthy_percentages =
      (object.cluster_min_healthy_percentages === undefined || object.cluster_min_healthy_percentages === null)
        ? undefined
        : (() => {
          const m = new Map();
          (object.cluster_min_healthy_percentages as Map<string, Percent> ?? new Map()).forEach((value, key) => {
            if (value !== undefined) {
              m.set(key, Percent.fromPartial(value));
            }
          });
          return m;
        })();
    message.headers = object.headers?.map((e) => HeaderMatcher.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(HealthCheck.$type, HealthCheck);

function createBaseHealthCheck_ClusterMinHealthyPercentagesEntry(): HealthCheck_ClusterMinHealthyPercentagesEntry {
  return { $type: "envoy.config.filter.http.health_check.v2.HealthCheck.ClusterMinHealthyPercentagesEntry", key: "" };
}

export const HealthCheck_ClusterMinHealthyPercentagesEntry: MessageFns<
  HealthCheck_ClusterMinHealthyPercentagesEntry,
  "envoy.config.filter.http.health_check.v2.HealthCheck.ClusterMinHealthyPercentagesEntry"
> = {
  $type: "envoy.config.filter.http.health_check.v2.HealthCheck.ClusterMinHealthyPercentagesEntry" as const,

  encode(
    message: HealthCheck_ClusterMinHealthyPercentagesEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Percent.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheck_ClusterMinHealthyPercentagesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheck_ClusterMinHealthyPercentagesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Percent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheck_ClusterMinHealthyPercentagesEntry {
    return {
      $type: HealthCheck_ClusterMinHealthyPercentagesEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Percent.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: HealthCheck_ClusterMinHealthyPercentagesEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Percent.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheck_ClusterMinHealthyPercentagesEntry>, I>>(
    base?: I,
  ): HealthCheck_ClusterMinHealthyPercentagesEntry {
    return HealthCheck_ClusterMinHealthyPercentagesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheck_ClusterMinHealthyPercentagesEntry>, I>>(
    object: I,
  ): HealthCheck_ClusterMinHealthyPercentagesEntry {
    const message = createBaseHealthCheck_ClusterMinHealthyPercentagesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Percent.fromPartial(object.value)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(
  HealthCheck_ClusterMinHealthyPercentagesEntry.$type,
  HealthCheck_ClusterMinHealthyPercentagesEntry,
);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
