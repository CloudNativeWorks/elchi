// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/service/discovery/v3/discovery.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Any } from "../../../../google/protobuf/any";
import { Duration } from "../../../../google/protobuf/duration";
import { Status } from "../../../../google/rpc/status";
import { messageTypeRegistry } from "../../../../typeRegistry";
import { ControlPlane, Metadata, Node } from "../../../config/core/v3/base";

export const protobufPackage = "envoy.service.discovery.v3";

/** Specifies a resource to be subscribed to. */
export interface ResourceLocator {
  $type: "envoy.service.discovery.v3.ResourceLocator";
  /** The resource name to subscribe to. */
  name?:
    | string
    | undefined;
  /**
   * A set of dynamic parameters used to match against the dynamic parameter
   * constraints on the resource. This allows clients to select between
   * multiple variants of the same resource.
   */
  dynamic_parameters?: Map<string, string> | undefined;
}

export interface ResourceLocator_DynamicParametersEntry {
  $type: "envoy.service.discovery.v3.ResourceLocator.DynamicParametersEntry";
  key: string;
  value: string;
}

/** Specifies a concrete resource name. */
export interface ResourceName {
  $type: "envoy.service.discovery.v3.ResourceName";
  /** The name of the resource. */
  name?:
    | string
    | undefined;
  /**
   * Dynamic parameter constraints associated with this resource. To be used by client-side caches
   * (including xDS proxies) when matching subscribed resource locators.
   */
  dynamic_parameter_constraints?: DynamicParameterConstraints | undefined;
}

/**
 * [#not-implemented-hide:]
 * An error associated with a specific resource name, returned to the
 * client by the server.
 */
export interface ResourceError {
  $type: "envoy.service.discovery.v3.ResourceError";
  /** The name of the resource. */
  resource_name?:
    | ResourceName
    | undefined;
  /** The error reported for the resource. */
  error_detail?: Status | undefined;
}

/**
 * A DiscoveryRequest requests a set of versioned resources of the same type for
 * a given Envoy node on some API.
 * [#next-free-field: 8]
 */
export interface DiscoveryRequest {
  $type: "envoy.service.discovery.v3.DiscoveryRequest";
  /**
   * The ``version_info`` provided in the request messages will be the ``version_info``
   * received with the most recent successfully processed response or empty on
   * the first request. It is expected that no new request is sent after a
   * response is received until the Envoy instance is ready to ACK/NACK the new
   * configuration. ACK/NACK takes place by returning the new API config version
   * as applied or the previous API config version respectively. Each ``type_url``
   * (see below) has an independent version associated with it.
   */
  version_info?:
    | string
    | undefined;
  /** The node making the request. */
  node?:
    | Node
    | undefined;
  /**
   * List of resources to subscribe to, e.g. list of cluster names or a route
   * configuration name. If this is empty, all resources for the API are
   * returned. LDS/CDS may have empty ``resource_names``, which will cause all
   * resources for the Envoy instance to be returned. The LDS and CDS responses
   * will then imply a number of resources that need to be fetched via EDS/RDS,
   * which will be explicitly enumerated in ``resource_names``.
   */
  resource_names?:
    | string[]
    | undefined;
  /**
   * [#not-implemented-hide:]
   * Alternative to ``resource_names`` field that allows specifying dynamic
   * parameters along with each resource name. Clients that populate this
   * field must be able to handle responses from the server where resources
   * are wrapped in a Resource message.
   *
   * .. note::
   *   It is legal for a request to have some resources listed
   *   in ``resource_names`` and others in ``resource_locators``.
   */
  resource_locators?:
    | ResourceLocator[]
    | undefined;
  /**
   * Type of the resource that is being requested, e.g.
   * ``type.googleapis.com/envoy.api.v2.ClusterLoadAssignment``. This is implicit
   * in requests made via singleton xDS APIs such as CDS, LDS, etc. but is
   * required for ADS.
   */
  type_url?:
    | string
    | undefined;
  /**
   * nonce corresponding to ``DiscoveryResponse`` being ACK/NACKed. See above
   * discussion on ``version_info`` and the ``DiscoveryResponse`` nonce comment. This
   * may be empty only if:
   *
   * * This is a non-persistent-stream xDS such as HTTP, or
   * * The client has not yet accepted an update in this xDS stream (unlike
   *   delta, where it is populated only for new explicit ACKs).
   */
  response_nonce?:
    | string
    | undefined;
  /**
   * This is populated when the previous :ref:`DiscoveryResponse <envoy_v3_api_msg_service.discovery.v3.DiscoveryResponse>`
   * failed to update configuration. The ``message`` field in ``error_details`` provides the Envoy
   * internal exception related to the failure. It is only intended for consumption during manual
   * debugging, the string provided is not guaranteed to be stable across Envoy versions.
   */
  error_detail?: Status | undefined;
}

/** [#next-free-field: 8] */
export interface DiscoveryResponse {
  $type: "envoy.service.discovery.v3.DiscoveryResponse";
  /** The version of the response data. */
  version_info?:
    | string
    | undefined;
  /** The response resources. These resources are typed and depend on the API being called. */
  resources?:
    | Any[]
    | undefined;
  /**
   * [#not-implemented-hide:]
   * Canary is used to support two Envoy command line flags:
   *
   * * ``--terminate-on-canary-transition-failure``. When set, Envoy is able to
   *   terminate if it detects that configuration is stuck at canary. Consider
   *   this example sequence of updates:
   *
   *   * Management server applies a canary config successfully.
   *   * Management server rolls back to a production config.
   *   * Envoy rejects the new production config.
   *
   *   Since there is no sensible way to continue receiving configuration
   *   updates, Envoy will then terminate and apply production config from a
   *   clean slate.
   *
   * * ``--dry-run-canary``. When set, a canary response will never be applied, only
   *   validated via a dry run.
   */
  canary?:
    | boolean
    | undefined;
  /**
   * Type URL for resources. Identifies the xDS API when muxing over ADS.
   * Must be consistent with the ``type_url`` in the 'resources' repeated Any (if non-empty).
   */
  type_url?:
    | string
    | undefined;
  /**
   * For gRPC based subscriptions, the nonce provides a way to explicitly ack a
   * specific ``DiscoveryResponse`` in a following ``DiscoveryRequest``. Additional
   * messages may have been sent by Envoy to the management server for the
   * previous version on the stream prior to this ``DiscoveryResponse``, that were
   * unprocessed at response send time. The nonce allows the management server
   * to ignore any further ``DiscoveryRequests`` for the previous version until a
   * ``DiscoveryRequest`` bearing the nonce. The nonce is optional and is not
   * required for non-stream based xDS implementations.
   */
  nonce?:
    | string
    | undefined;
  /** The control plane instance that sent the response. */
  control_plane?:
    | ControlPlane
    | undefined;
  /**
   * [#not-implemented-hide:]
   * Errors associated with specific resources. Clients are expected to
   * remember the most recent error for a given resource across responses;
   * the error condition is not considered to be cleared until a response is
   * received that contains the resource in the 'resources' field.
   */
  resource_errors?: ResourceError[] | undefined;
}

/**
 * DeltaDiscoveryRequest and DeltaDiscoveryResponse are used in a new gRPC
 * endpoint for Delta xDS.
 *
 * With Delta xDS, the DeltaDiscoveryResponses do not need to include a full
 * snapshot of the tracked resources. Instead, DeltaDiscoveryResponses are a
 * diff to the state of a xDS client.
 * In Delta XDS there are per-resource versions, which allow tracking state at
 * the resource granularity.
 * An xDS Delta session is always in the context of a gRPC bidirectional
 * stream. This allows the xDS server to keep track of the state of xDS clients
 * connected to it.
 *
 * In Delta xDS the nonce field is required and used to pair
 * ``DeltaDiscoveryResponse`` to a ``DeltaDiscoveryRequest`` ACK or NACK.
 * Optionally, a response message level ``system_version_info`` is present for
 * debugging purposes only.
 *
 * ``DeltaDiscoveryRequest`` plays two independent roles. Any ``DeltaDiscoveryRequest``
 * can be either or both of:
 *
 * * Informing the server of what resources the client has gained/lost interest in
 *   (using ``resource_names_subscribe`` and ``resource_names_unsubscribe``), or
 * * (N)ACKing an earlier resource update from the server (using ``response_nonce``,
 *   with presence of ``error_detail`` making it a NACK).
 *
 * Additionally, the first message (for a given ``type_url``) of a reconnected gRPC stream
 * has a third role: informing the server of the resources (and their versions)
 * that the client already possesses, using the ``initial_resource_versions`` field.
 *
 * As with state-of-the-world, when multiple resource types are multiplexed (ADS),
 * all requests/acknowledgments/updates are logically walled off by ``type_url``:
 * a Cluster ACK exists in a completely separate world from a prior Route NACK.
 * In particular, ``initial_resource_versions`` being sent at the "start" of every
 * gRPC stream actually entails a message for each ``type_url``, each with its own
 * ``initial_resource_versions``.
 * [#next-free-field: 10]
 */
export interface DeltaDiscoveryRequest {
  $type: "envoy.service.discovery.v3.DeltaDiscoveryRequest";
  /** The node making the request. */
  node?:
    | Node
    | undefined;
  /**
   * Type of the resource that is being requested, e.g.
   * ``type.googleapis.com/envoy.api.v2.ClusterLoadAssignment``. This does not need to be set if
   * resources are only referenced via ``xds_resource_subscribe`` and
   * ``xds_resources_unsubscribe``.
   */
  type_url?:
    | string
    | undefined;
  /**
   * DeltaDiscoveryRequests allow the client to add or remove individual
   * resources to the set of tracked resources in the context of a stream.
   * All resource names in the ``resource_names_subscribe`` list are added to the
   * set of tracked resources and all resource names in the ``resource_names_unsubscribe``
   * list are removed from the set of tracked resources.
   *
   * *Unlike* state-of-the-world xDS, an empty ``resource_names_subscribe`` or
   * ``resource_names_unsubscribe`` list simply means that no resources are to be
   * added or removed to the resource list.
   * *Like* state-of-the-world xDS, the server must send updates for all tracked
   * resources, but can also send updates for resources the client has not subscribed to.
   *
   * .. note::
   *   The server must respond with all resources listed in ``resource_names_subscribe``,
   *   even if it believes the client has the most recent version of them. The reason:
   *   the client may have dropped them, but then regained interest before it had a chance
   *   to send the unsubscribe message. See DeltaSubscriptionStateTest.RemoveThenAdd.
   *
   * These two fields can be set in any ``DeltaDiscoveryRequest``, including ACKs
   * and ``initial_resource_versions``.
   *
   * A list of Resource names to add to the list of tracked resources.
   */
  resource_names_subscribe?:
    | string[]
    | undefined;
  /** A list of Resource names to remove from the list of tracked resources. */
  resource_names_unsubscribe?:
    | string[]
    | undefined;
  /**
   * [#not-implemented-hide:]
   * Alternative to ``resource_names_subscribe`` field that allows specifying dynamic parameters
   * along with each resource name.
   *
   * .. note::
   *   It is legal for a request to have some resources listed
   *   in ``resource_names_subscribe`` and others in ``resource_locators_subscribe``.
   */
  resource_locators_subscribe?:
    | ResourceLocator[]
    | undefined;
  /**
   * [#not-implemented-hide:]
   * Alternative to ``resource_names_unsubscribe`` field that allows specifying dynamic parameters
   * along with each resource name.
   *
   * .. note::
   *   It is legal for a request to have some resources listed
   *   in ``resource_names_unsubscribe`` and others in ``resource_locators_unsubscribe``.
   */
  resource_locators_unsubscribe?:
    | ResourceLocator[]
    | undefined;
  /**
   * Informs the server of the versions of the resources the xDS client knows of, to enable the
   * client to continue the same logical xDS session even in the face of gRPC stream reconnection.
   * It will not be populated:
   *
   * * In the very first stream of a session, since the client will not yet have any resources.
   * * In any message after the first in a stream (for a given ``type_url``), since the server will
   *   already be correctly tracking the client's state.
   *
   * (In ADS, the first message ``of each type_url`` of a reconnected stream populates this map.)
   * The map's keys are names of xDS resources known to the xDS client.
   * The map's values are opaque resource versions.
   */
  initial_resource_versions?:
    | Map<string, string>
    | undefined;
  /**
   * When the ``DeltaDiscoveryRequest`` is a ACK or NACK message in response
   * to a previous ``DeltaDiscoveryResponse``, the ``response_nonce`` must be the
   * nonce in the ``DeltaDiscoveryResponse``.
   * Otherwise (unlike in ``DiscoveryRequest``) ``response_nonce`` must be omitted.
   */
  response_nonce?:
    | string
    | undefined;
  /**
   * This is populated when the previous :ref:`DiscoveryResponse <envoy_v3_api_msg_service.discovery.v3.DiscoveryResponse>`
   * failed to update configuration. The ``message`` field in ``error_details``
   * provides the Envoy internal exception related to the failure.
   */
  error_detail?: Status | undefined;
}

export interface DeltaDiscoveryRequest_InitialResourceVersionsEntry {
  $type: "envoy.service.discovery.v3.DeltaDiscoveryRequest.InitialResourceVersionsEntry";
  key: string;
  value: string;
}

/** [#next-free-field: 10] */
export interface DeltaDiscoveryResponse {
  $type: "envoy.service.discovery.v3.DeltaDiscoveryResponse";
  /** The version of the response data (used for debugging). */
  system_version_info?:
    | string
    | undefined;
  /**
   * The response resources. These are typed resources, whose types must match
   * the ``type_url`` field.
   */
  resources?:
    | Resource[]
    | undefined;
  /**
   * Type URL for resources. Identifies the xDS API when muxing over ADS.
   * Must be consistent with the ``type_url`` in the Any within 'resources' if 'resources' is non-empty.
   */
  type_url?:
    | string
    | undefined;
  /**
   * Resource names of resources that have been deleted and to be removed from the xDS Client.
   * Removed resources for missing resources can be ignored.
   */
  removed_resources?:
    | string[]
    | undefined;
  /**
   * Alternative to ``removed_resources`` that allows specifying which variant of
   * a resource is being removed. This variant must be used for any resource
   * for which dynamic parameter constraints were sent to the client.
   */
  removed_resource_names?:
    | ResourceName[]
    | undefined;
  /**
   * The nonce provides a way for ``DeltaDiscoveryRequests`` to uniquely
   * reference a ``DeltaDiscoveryResponse`` when (N)ACKing. The nonce is required.
   */
  nonce?:
    | string
    | undefined;
  /**
   * [#not-implemented-hide:]
   * The control plane instance that sent the response.
   */
  control_plane?:
    | ControlPlane
    | undefined;
  /**
   * [#not-implemented-hide:]
   * Errors associated with specific resources.
   *
   * .. note::
   *   A resource in this field with a status of NOT_FOUND should be treated the same as
   *   a resource listed in the ``removed_resources`` or ``removed_resource_names`` fields.
   */
  resource_errors?: ResourceError[] | undefined;
}

/**
 * A set of dynamic parameter constraints associated with a variant of an individual xDS resource.
 * These constraints determine whether the resource matches a subscription based on the set of
 * dynamic parameters in the subscription, as specified in the
 * :ref:`ResourceLocator.dynamic_parameters <envoy_v3_api_field_service.discovery.v3.ResourceLocator.dynamic_parameters>`
 * field. This allows xDS implementations (clients, servers, and caching proxies) to determine
 * which variant of a resource is appropriate for a given client.
 */
export interface DynamicParameterConstraints {
  $type: "envoy.service.discovery.v3.DynamicParameterConstraints";
  type?:
    | //
    /** A single constraint to evaluate. */
    { $case: "constraint"; constraint: DynamicParameterConstraints_SingleConstraint }
    | //
    /**
     * A list of constraints that match if any one constraint in the list
     * matches.
     */
    { $case: "or_constraints"; or_constraints: DynamicParameterConstraints_ConstraintList }
    | //
    /** A list of constraints that must all match. */
    { $case: "and_constraints"; and_constraints: DynamicParameterConstraints_ConstraintList }
    | //
    /** The inverse (NOT) of a set of constraints. */
    { $case: "not_constraints"; not_constraints: DynamicParameterConstraints }
    | undefined;
}

/** A single constraint for a given key. */
export interface DynamicParameterConstraints_SingleConstraint {
  $type: "envoy.service.discovery.v3.DynamicParameterConstraints.SingleConstraint";
  /** The key to match against. */
  key?: string | undefined;
  constraint_type?:
    | //
    /** Matches this exact value. */
    { $case: "value"; value: string }
    | //
    /**
     * Key is present (matches any value except for the key being absent).
     * This allows setting a default constraint for clients that do
     * not send a key at all, while there may be other clients that need
     * special configuration based on that key.
     */
    { $case: "exists"; exists: DynamicParameterConstraints_SingleConstraint_Exists }
    | undefined;
}

export interface DynamicParameterConstraints_SingleConstraint_Exists {
  $type: "envoy.service.discovery.v3.DynamicParameterConstraints.SingleConstraint.Exists";
}

export interface DynamicParameterConstraints_ConstraintList {
  $type: "envoy.service.discovery.v3.DynamicParameterConstraints.ConstraintList";
  constraints?: DynamicParameterConstraints[] | undefined;
}

/** [#next-free-field: 10] */
export interface Resource {
  $type: "envoy.service.discovery.v3.Resource";
  /**
   * The resource's name, to distinguish it from others of the same type of resource.
   * Only one of ``name`` or ``resource_name`` may be set.
   */
  name?:
    | string
    | undefined;
  /**
   * Alternative to the ``name`` field, to be used when the server supports
   * multiple variants of the named resource that are differentiated by
   * dynamic parameter constraints.
   * Only one of ``name`` or ``resource_name`` may be set.
   */
  resource_name?:
    | ResourceName
    | undefined;
  /** The aliases are a list of other names that this resource can go by. */
  aliases?:
    | string[]
    | undefined;
  /**
   * The resource level version. It allows xDS to track the state of individual
   * resources.
   */
  version?:
    | string
    | undefined;
  /** The resource being tracked. */
  resource?:
    | Any
    | undefined;
  /**
   * Time-to-live value for the resource. For each resource, a timer is started. The timer is
   * reset each time the resource is received with a new TTL. If the resource is received with
   * no TTL set, the timer is removed for the resource. Upon expiration of the timer, the
   * configuration for the resource will be removed.
   *
   * The TTL can be refreshed or changed by sending a response that doesn't change the resource
   * version. In this case the ``resource`` field does not need to be populated, which allows for
   * light-weight "heartbeat" updates to keep a resource with a TTL alive.
   *
   * The TTL feature is meant to support configurations that should be removed in the event of
   * a management server failure. For example, the feature may be used for fault injection
   * testing where the fault injection should be terminated in the event that Envoy loses contact
   * with the management server.
   */
  ttl?:
    | Duration
    | undefined;
  /**
   * Cache control properties for the resource.
   * [#not-implemented-hide:]
   */
  cache_control?:
    | Resource_CacheControl
    | undefined;
  /**
   * The Metadata field can be used to provide additional information for the resource.
   * E.g. the trace data for debugging.
   */
  metadata?: Metadata | undefined;
}

/**
 * Cache control properties for the resource.
 * [#not-implemented-hide:]
 */
export interface Resource_CacheControl {
  $type: "envoy.service.discovery.v3.Resource.CacheControl";
  /**
   * If true, xDS proxies may not cache this resource.
   *
   * .. note::
   *   This does not apply to clients other than xDS proxies, which must cache resources
   *   for their own use, regardless of the value of this field.
   */
  do_not_cache?: boolean | undefined;
}

function createBaseResourceLocator(): ResourceLocator {
  return { $type: "envoy.service.discovery.v3.ResourceLocator" };
}

export const ResourceLocator: MessageFns<ResourceLocator, "envoy.service.discovery.v3.ResourceLocator"> = {
  $type: "envoy.service.discovery.v3.ResourceLocator" as const,

  encode(message: ResourceLocator, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    (message.dynamic_parameters || new Map()).forEach((value, key) => {
      ResourceLocator_DynamicParametersEntry.encode({
        $type: "envoy.service.discovery.v3.ResourceLocator.DynamicParametersEntry",
        key: key as any,
        value,
      }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceLocator {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceLocator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = ResourceLocator_DynamicParametersEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            if (message.dynamic_parameters === undefined) {
              message.dynamic_parameters = new Map();
            }
            message.dynamic_parameters!.set(entry2.key, entry2.value);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceLocator {
    return {
      $type: ResourceLocator.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      dynamic_parameters: isObject(object.dynamic_parameters)
        ? Object.entries(object.dynamic_parameters).reduce<Map<string, string>>((acc, [key, value]) => {
          acc.set(key, String(value));
          return acc;
        }, new Map())
        : undefined,
    };
  },

  toJSON(message: ResourceLocator): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.dynamic_parameters?.size) {
      obj.dynamic_parameters = {};
      message.dynamic_parameters.forEach((v, k) => {
        obj.dynamic_parameters[k] = v;
      });
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResourceLocator>, I>>(base?: I): ResourceLocator {
    return ResourceLocator.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResourceLocator>, I>>(object: I): ResourceLocator {
    const message = createBaseResourceLocator();
    message.name = object.name ?? undefined;
    message.dynamic_parameters = (object.dynamic_parameters === undefined || object.dynamic_parameters === null)
      ? undefined
      : (() => {
        const m = new Map();
        (object.dynamic_parameters as Map<string, string> ?? new Map()).forEach((value, key) => {
          if (value !== undefined) {
            m.set(key, globalThis.String(value));
          }
        });
        return m;
      })();
    return message;
  },
};

messageTypeRegistry.set(ResourceLocator.$type, ResourceLocator);

function createBaseResourceLocator_DynamicParametersEntry(): ResourceLocator_DynamicParametersEntry {
  return { $type: "envoy.service.discovery.v3.ResourceLocator.DynamicParametersEntry", key: "", value: "" };
}

export const ResourceLocator_DynamicParametersEntry: MessageFns<
  ResourceLocator_DynamicParametersEntry,
  "envoy.service.discovery.v3.ResourceLocator.DynamicParametersEntry"
> = {
  $type: "envoy.service.discovery.v3.ResourceLocator.DynamicParametersEntry" as const,

  encode(message: ResourceLocator_DynamicParametersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceLocator_DynamicParametersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceLocator_DynamicParametersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceLocator_DynamicParametersEntry {
    return {
      $type: ResourceLocator_DynamicParametersEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ResourceLocator_DynamicParametersEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResourceLocator_DynamicParametersEntry>, I>>(
    base?: I,
  ): ResourceLocator_DynamicParametersEntry {
    return ResourceLocator_DynamicParametersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResourceLocator_DynamicParametersEntry>, I>>(
    object: I,
  ): ResourceLocator_DynamicParametersEntry {
    const message = createBaseResourceLocator_DynamicParametersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

messageTypeRegistry.set(ResourceLocator_DynamicParametersEntry.$type, ResourceLocator_DynamicParametersEntry);

function createBaseResourceName(): ResourceName {
  return { $type: "envoy.service.discovery.v3.ResourceName" };
}

export const ResourceName: MessageFns<ResourceName, "envoy.service.discovery.v3.ResourceName"> = {
  $type: "envoy.service.discovery.v3.ResourceName" as const,

  encode(message: ResourceName, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.dynamic_parameter_constraints !== undefined) {
      DynamicParameterConstraints.encode(message.dynamic_parameter_constraints, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceName {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceName();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dynamic_parameter_constraints = DynamicParameterConstraints.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceName {
    return {
      $type: ResourceName.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      dynamic_parameter_constraints: isSet(object.dynamic_parameter_constraints)
        ? DynamicParameterConstraints.fromJSON(object.dynamic_parameter_constraints)
        : undefined,
    };
  },

  toJSON(message: ResourceName): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.dynamic_parameter_constraints !== undefined) {
      obj.dynamic_parameter_constraints = DynamicParameterConstraints.toJSON(message.dynamic_parameter_constraints);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResourceName>, I>>(base?: I): ResourceName {
    return ResourceName.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResourceName>, I>>(object: I): ResourceName {
    const message = createBaseResourceName();
    message.name = object.name ?? undefined;
    message.dynamic_parameter_constraints =
      (object.dynamic_parameter_constraints !== undefined && object.dynamic_parameter_constraints !== null)
        ? DynamicParameterConstraints.fromPartial(object.dynamic_parameter_constraints)
        : undefined;
    return message;
  },
};

messageTypeRegistry.set(ResourceName.$type, ResourceName);

function createBaseResourceError(): ResourceError {
  return { $type: "envoy.service.discovery.v3.ResourceError" };
}

export const ResourceError: MessageFns<ResourceError, "envoy.service.discovery.v3.ResourceError"> = {
  $type: "envoy.service.discovery.v3.ResourceError" as const,

  encode(message: ResourceError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resource_name !== undefined) {
      ResourceName.encode(message.resource_name, writer.uint32(10).fork()).join();
    }
    if (message.error_detail !== undefined) {
      Status.encode(message.error_detail, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.resource_name = ResourceName.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error_detail = Status.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceError {
    return {
      $type: ResourceError.$type,
      resource_name: isSet(object.resource_name) ? ResourceName.fromJSON(object.resource_name) : undefined,
      error_detail: isSet(object.error_detail) ? Status.fromJSON(object.error_detail) : undefined,
    };
  },

  toJSON(message: ResourceError): unknown {
    const obj: any = {};
    if (message.resource_name !== undefined) {
      obj.resource_name = ResourceName.toJSON(message.resource_name);
    }
    if (message.error_detail !== undefined) {
      obj.error_detail = Status.toJSON(message.error_detail);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResourceError>, I>>(base?: I): ResourceError {
    return ResourceError.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResourceError>, I>>(object: I): ResourceError {
    const message = createBaseResourceError();
    message.resource_name = (object.resource_name !== undefined && object.resource_name !== null)
      ? ResourceName.fromPartial(object.resource_name)
      : undefined;
    message.error_detail = (object.error_detail !== undefined && object.error_detail !== null)
      ? Status.fromPartial(object.error_detail)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(ResourceError.$type, ResourceError);

function createBaseDiscoveryRequest(): DiscoveryRequest {
  return { $type: "envoy.service.discovery.v3.DiscoveryRequest" };
}

export const DiscoveryRequest: MessageFns<DiscoveryRequest, "envoy.service.discovery.v3.DiscoveryRequest"> = {
  $type: "envoy.service.discovery.v3.DiscoveryRequest" as const,

  encode(message: DiscoveryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version_info !== undefined && message.version_info !== "") {
      writer.uint32(10).string(message.version_info);
    }
    if (message.node !== undefined) {
      Node.encode(message.node, writer.uint32(18).fork()).join();
    }
    if (message.resource_names !== undefined && message.resource_names.length !== 0) {
      for (const v of message.resource_names) {
        writer.uint32(26).string(v!);
      }
    }
    if (message.resource_locators !== undefined && message.resource_locators.length !== 0) {
      for (const v of message.resource_locators) {
        ResourceLocator.encode(v!, writer.uint32(58).fork()).join();
      }
    }
    if (message.type_url !== undefined && message.type_url !== "") {
      writer.uint32(34).string(message.type_url);
    }
    if (message.response_nonce !== undefined && message.response_nonce !== "") {
      writer.uint32(42).string(message.response_nonce);
    }
    if (message.error_detail !== undefined) {
      Status.encode(message.error_detail, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiscoveryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiscoveryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version_info = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.node = Node.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.resource_names === undefined) {
            message.resource_names = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.resource_names!.push(el);
          }
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          if (message.resource_locators === undefined) {
            message.resource_locators = [];
          }
          const el = ResourceLocator.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.resource_locators!.push(el);
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.type_url = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.response_nonce = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.error_detail = Status.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiscoveryRequest {
    return {
      $type: DiscoveryRequest.$type,
      version_info: isSet(object.version_info) ? globalThis.String(object.version_info) : undefined,
      node: isSet(object.node) ? Node.fromJSON(object.node) : undefined,
      resource_names: globalThis.Array.isArray(object?.resource_names)
        ? object.resource_names.map((e: any) => globalThis.String(e))
        : undefined,
      resource_locators: globalThis.Array.isArray(object?.resource_locators)
        ? object.resource_locators.map((e: any) => ResourceLocator.fromJSON(e))
        : undefined,
      type_url: isSet(object.type_url) ? globalThis.String(object.type_url) : undefined,
      response_nonce: isSet(object.response_nonce) ? globalThis.String(object.response_nonce) : undefined,
      error_detail: isSet(object.error_detail) ? Status.fromJSON(object.error_detail) : undefined,
    };
  },

  toJSON(message: DiscoveryRequest): unknown {
    const obj: any = {};
    if (message.version_info !== undefined) {
      obj.version_info = message.version_info;
    }
    if (message.node !== undefined) {
      obj.node = Node.toJSON(message.node);
    }
    if (message.resource_names?.length) {
      obj.resource_names = message.resource_names;
    }
    if (message.resource_locators?.length) {
      obj.resource_locators = message.resource_locators.map((e) => ResourceLocator.toJSON(e));
    }
    if (message.type_url !== undefined) {
      obj.type_url = message.type_url;
    }
    if (message.response_nonce !== undefined) {
      obj.response_nonce = message.response_nonce;
    }
    if (message.error_detail !== undefined) {
      obj.error_detail = Status.toJSON(message.error_detail);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DiscoveryRequest>, I>>(base?: I): DiscoveryRequest {
    return DiscoveryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DiscoveryRequest>, I>>(object: I): DiscoveryRequest {
    const message = createBaseDiscoveryRequest();
    message.version_info = object.version_info ?? undefined;
    message.node = (object.node !== undefined && object.node !== null) ? Node.fromPartial(object.node) : undefined;
    message.resource_names = object.resource_names?.map((e) => e) || undefined;
    message.resource_locators = object.resource_locators?.map((e) => ResourceLocator.fromPartial(e)) || undefined;
    message.type_url = object.type_url ?? undefined;
    message.response_nonce = object.response_nonce ?? undefined;
    message.error_detail = (object.error_detail !== undefined && object.error_detail !== null)
      ? Status.fromPartial(object.error_detail)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(DiscoveryRequest.$type, DiscoveryRequest);

function createBaseDiscoveryResponse(): DiscoveryResponse {
  return { $type: "envoy.service.discovery.v3.DiscoveryResponse" };
}

export const DiscoveryResponse: MessageFns<DiscoveryResponse, "envoy.service.discovery.v3.DiscoveryResponse"> = {
  $type: "envoy.service.discovery.v3.DiscoveryResponse" as const,

  encode(message: DiscoveryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version_info !== undefined && message.version_info !== "") {
      writer.uint32(10).string(message.version_info);
    }
    if (message.resources !== undefined && message.resources.length !== 0) {
      for (const v of message.resources) {
        Any.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.canary !== undefined && message.canary !== false) {
      writer.uint32(24).bool(message.canary);
    }
    if (message.type_url !== undefined && message.type_url !== "") {
      writer.uint32(34).string(message.type_url);
    }
    if (message.nonce !== undefined && message.nonce !== "") {
      writer.uint32(42).string(message.nonce);
    }
    if (message.control_plane !== undefined) {
      ControlPlane.encode(message.control_plane, writer.uint32(50).fork()).join();
    }
    if (message.resource_errors !== undefined && message.resource_errors.length !== 0) {
      for (const v of message.resource_errors) {
        ResourceError.encode(v!, writer.uint32(58).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiscoveryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiscoveryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version_info = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.resources === undefined) {
            message.resources = [];
          }
          const el = Any.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.resources!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.canary = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.type_url = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.nonce = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.control_plane = ControlPlane.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          if (message.resource_errors === undefined) {
            message.resource_errors = [];
          }
          const el = ResourceError.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.resource_errors!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiscoveryResponse {
    return {
      $type: DiscoveryResponse.$type,
      version_info: isSet(object.version_info) ? globalThis.String(object.version_info) : undefined,
      resources: globalThis.Array.isArray(object?.resources)
        ? object.resources.map((e: any) => Any.fromJSON(e))
        : undefined,
      canary: isSet(object.canary) ? globalThis.Boolean(object.canary) : undefined,
      type_url: isSet(object.type_url) ? globalThis.String(object.type_url) : undefined,
      nonce: isSet(object.nonce) ? globalThis.String(object.nonce) : undefined,
      control_plane: isSet(object.control_plane) ? ControlPlane.fromJSON(object.control_plane) : undefined,
      resource_errors: globalThis.Array.isArray(object?.resource_errors)
        ? object.resource_errors.map((e: any) => ResourceError.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: DiscoveryResponse): unknown {
    const obj: any = {};
    if (message.version_info !== undefined) {
      obj.version_info = message.version_info;
    }
    if (message.resources?.length) {
      obj.resources = message.resources.map((e) => Any.toJSON(e));
    }
    if (message.canary !== undefined) {
      obj.canary = message.canary;
    }
    if (message.type_url !== undefined) {
      obj.type_url = message.type_url;
    }
    if (message.nonce !== undefined) {
      obj.nonce = message.nonce;
    }
    if (message.control_plane !== undefined) {
      obj.control_plane = ControlPlane.toJSON(message.control_plane);
    }
    if (message.resource_errors?.length) {
      obj.resource_errors = message.resource_errors.map((e) => ResourceError.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DiscoveryResponse>, I>>(base?: I): DiscoveryResponse {
    return DiscoveryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DiscoveryResponse>, I>>(object: I): DiscoveryResponse {
    const message = createBaseDiscoveryResponse();
    message.version_info = object.version_info ?? undefined;
    message.resources = object.resources?.map((e) => Any.fromPartial(e)) || undefined;
    message.canary = object.canary ?? undefined;
    message.type_url = object.type_url ?? undefined;
    message.nonce = object.nonce ?? undefined;
    message.control_plane = (object.control_plane !== undefined && object.control_plane !== null)
      ? ControlPlane.fromPartial(object.control_plane)
      : undefined;
    message.resource_errors = object.resource_errors?.map((e) => ResourceError.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(DiscoveryResponse.$type, DiscoveryResponse);

function createBaseDeltaDiscoveryRequest(): DeltaDiscoveryRequest {
  return { $type: "envoy.service.discovery.v3.DeltaDiscoveryRequest" };
}

export const DeltaDiscoveryRequest: MessageFns<
  DeltaDiscoveryRequest,
  "envoy.service.discovery.v3.DeltaDiscoveryRequest"
> = {
  $type: "envoy.service.discovery.v3.DeltaDiscoveryRequest" as const,

  encode(message: DeltaDiscoveryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.node !== undefined) {
      Node.encode(message.node, writer.uint32(10).fork()).join();
    }
    if (message.type_url !== undefined && message.type_url !== "") {
      writer.uint32(18).string(message.type_url);
    }
    if (message.resource_names_subscribe !== undefined && message.resource_names_subscribe.length !== 0) {
      for (const v of message.resource_names_subscribe) {
        writer.uint32(26).string(v!);
      }
    }
    if (message.resource_names_unsubscribe !== undefined && message.resource_names_unsubscribe.length !== 0) {
      for (const v of message.resource_names_unsubscribe) {
        writer.uint32(34).string(v!);
      }
    }
    if (message.resource_locators_subscribe !== undefined && message.resource_locators_subscribe.length !== 0) {
      for (const v of message.resource_locators_subscribe) {
        ResourceLocator.encode(v!, writer.uint32(66).fork()).join();
      }
    }
    if (message.resource_locators_unsubscribe !== undefined && message.resource_locators_unsubscribe.length !== 0) {
      for (const v of message.resource_locators_unsubscribe) {
        ResourceLocator.encode(v!, writer.uint32(74).fork()).join();
      }
    }
    (message.initial_resource_versions || new Map()).forEach((value, key) => {
      DeltaDiscoveryRequest_InitialResourceVersionsEntry.encode({
        $type: "envoy.service.discovery.v3.DeltaDiscoveryRequest.InitialResourceVersionsEntry",
        key: key as any,
        value,
      }, writer.uint32(42).fork()).join();
    });
    if (message.response_nonce !== undefined && message.response_nonce !== "") {
      writer.uint32(50).string(message.response_nonce);
    }
    if (message.error_detail !== undefined) {
      Status.encode(message.error_detail, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeltaDiscoveryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeltaDiscoveryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.node = Node.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type_url = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.resource_names_subscribe === undefined) {
            message.resource_names_subscribe = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.resource_names_subscribe!.push(el);
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          if (message.resource_names_unsubscribe === undefined) {
            message.resource_names_unsubscribe = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.resource_names_unsubscribe!.push(el);
          }
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          if (message.resource_locators_subscribe === undefined) {
            message.resource_locators_subscribe = [];
          }
          const el = ResourceLocator.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.resource_locators_subscribe!.push(el);
          }
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          if (message.resource_locators_unsubscribe === undefined) {
            message.resource_locators_unsubscribe = [];
          }
          const el = ResourceLocator.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.resource_locators_unsubscribe!.push(el);
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = DeltaDiscoveryRequest_InitialResourceVersionsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            if (message.initial_resource_versions === undefined) {
              message.initial_resource_versions = new Map();
            }
            message.initial_resource_versions!.set(entry5.key, entry5.value);
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.response_nonce = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.error_detail = Status.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeltaDiscoveryRequest {
    return {
      $type: DeltaDiscoveryRequest.$type,
      node: isSet(object.node) ? Node.fromJSON(object.node) : undefined,
      type_url: isSet(object.type_url) ? globalThis.String(object.type_url) : undefined,
      resource_names_subscribe: globalThis.Array.isArray(object?.resource_names_subscribe)
        ? object.resource_names_subscribe.map((e: any) => globalThis.String(e))
        : undefined,
      resource_names_unsubscribe: globalThis.Array.isArray(object?.resource_names_unsubscribe)
        ? object.resource_names_unsubscribe.map((e: any) => globalThis.String(e))
        : undefined,
      resource_locators_subscribe: globalThis.Array.isArray(object?.resource_locators_subscribe)
        ? object.resource_locators_subscribe.map((e: any) => ResourceLocator.fromJSON(e))
        : undefined,
      resource_locators_unsubscribe: globalThis.Array.isArray(object?.resource_locators_unsubscribe)
        ? object.resource_locators_unsubscribe.map((e: any) => ResourceLocator.fromJSON(e))
        : undefined,
      initial_resource_versions: isObject(object.initial_resource_versions)
        ? Object.entries(object.initial_resource_versions).reduce<Map<string, string>>((acc, [key, value]) => {
          acc.set(key, String(value));
          return acc;
        }, new Map())
        : undefined,
      response_nonce: isSet(object.response_nonce) ? globalThis.String(object.response_nonce) : undefined,
      error_detail: isSet(object.error_detail) ? Status.fromJSON(object.error_detail) : undefined,
    };
  },

  toJSON(message: DeltaDiscoveryRequest): unknown {
    const obj: any = {};
    if (message.node !== undefined) {
      obj.node = Node.toJSON(message.node);
    }
    if (message.type_url !== undefined) {
      obj.type_url = message.type_url;
    }
    if (message.resource_names_subscribe?.length) {
      obj.resource_names_subscribe = message.resource_names_subscribe;
    }
    if (message.resource_names_unsubscribe?.length) {
      obj.resource_names_unsubscribe = message.resource_names_unsubscribe;
    }
    if (message.resource_locators_subscribe?.length) {
      obj.resource_locators_subscribe = message.resource_locators_subscribe.map((e) => ResourceLocator.toJSON(e));
    }
    if (message.resource_locators_unsubscribe?.length) {
      obj.resource_locators_unsubscribe = message.resource_locators_unsubscribe.map((e) => ResourceLocator.toJSON(e));
    }
    if (message.initial_resource_versions?.size) {
      obj.initial_resource_versions = {};
      message.initial_resource_versions.forEach((v, k) => {
        obj.initial_resource_versions[k] = v;
      });
    }
    if (message.response_nonce !== undefined) {
      obj.response_nonce = message.response_nonce;
    }
    if (message.error_detail !== undefined) {
      obj.error_detail = Status.toJSON(message.error_detail);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeltaDiscoveryRequest>, I>>(base?: I): DeltaDiscoveryRequest {
    return DeltaDiscoveryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeltaDiscoveryRequest>, I>>(object: I): DeltaDiscoveryRequest {
    const message = createBaseDeltaDiscoveryRequest();
    message.node = (object.node !== undefined && object.node !== null) ? Node.fromPartial(object.node) : undefined;
    message.type_url = object.type_url ?? undefined;
    message.resource_names_subscribe = object.resource_names_subscribe?.map((e) => e) || undefined;
    message.resource_names_unsubscribe = object.resource_names_unsubscribe?.map((e) => e) || undefined;
    message.resource_locators_subscribe =
      object.resource_locators_subscribe?.map((e) => ResourceLocator.fromPartial(e)) || undefined;
    message.resource_locators_unsubscribe =
      object.resource_locators_unsubscribe?.map((e) => ResourceLocator.fromPartial(e)) || undefined;
    message.initial_resource_versions =
      (object.initial_resource_versions === undefined || object.initial_resource_versions === null)
        ? undefined
        : (() => {
          const m = new Map();
          (object.initial_resource_versions as Map<string, string> ?? new Map()).forEach((value, key) => {
            if (value !== undefined) {
              m.set(key, globalThis.String(value));
            }
          });
          return m;
        })();
    message.response_nonce = object.response_nonce ?? undefined;
    message.error_detail = (object.error_detail !== undefined && object.error_detail !== null)
      ? Status.fromPartial(object.error_detail)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(DeltaDiscoveryRequest.$type, DeltaDiscoveryRequest);

function createBaseDeltaDiscoveryRequest_InitialResourceVersionsEntry(): DeltaDiscoveryRequest_InitialResourceVersionsEntry {
  return { $type: "envoy.service.discovery.v3.DeltaDiscoveryRequest.InitialResourceVersionsEntry", key: "", value: "" };
}

export const DeltaDiscoveryRequest_InitialResourceVersionsEntry: MessageFns<
  DeltaDiscoveryRequest_InitialResourceVersionsEntry,
  "envoy.service.discovery.v3.DeltaDiscoveryRequest.InitialResourceVersionsEntry"
> = {
  $type: "envoy.service.discovery.v3.DeltaDiscoveryRequest.InitialResourceVersionsEntry" as const,

  encode(
    message: DeltaDiscoveryRequest_InitialResourceVersionsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeltaDiscoveryRequest_InitialResourceVersionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeltaDiscoveryRequest_InitialResourceVersionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeltaDiscoveryRequest_InitialResourceVersionsEntry {
    return {
      $type: DeltaDiscoveryRequest_InitialResourceVersionsEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: DeltaDiscoveryRequest_InitialResourceVersionsEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeltaDiscoveryRequest_InitialResourceVersionsEntry>, I>>(
    base?: I,
  ): DeltaDiscoveryRequest_InitialResourceVersionsEntry {
    return DeltaDiscoveryRequest_InitialResourceVersionsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeltaDiscoveryRequest_InitialResourceVersionsEntry>, I>>(
    object: I,
  ): DeltaDiscoveryRequest_InitialResourceVersionsEntry {
    const message = createBaseDeltaDiscoveryRequest_InitialResourceVersionsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

messageTypeRegistry.set(
  DeltaDiscoveryRequest_InitialResourceVersionsEntry.$type,
  DeltaDiscoveryRequest_InitialResourceVersionsEntry,
);

function createBaseDeltaDiscoveryResponse(): DeltaDiscoveryResponse {
  return { $type: "envoy.service.discovery.v3.DeltaDiscoveryResponse" };
}

export const DeltaDiscoveryResponse: MessageFns<
  DeltaDiscoveryResponse,
  "envoy.service.discovery.v3.DeltaDiscoveryResponse"
> = {
  $type: "envoy.service.discovery.v3.DeltaDiscoveryResponse" as const,

  encode(message: DeltaDiscoveryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.system_version_info !== undefined && message.system_version_info !== "") {
      writer.uint32(10).string(message.system_version_info);
    }
    if (message.resources !== undefined && message.resources.length !== 0) {
      for (const v of message.resources) {
        Resource.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.type_url !== undefined && message.type_url !== "") {
      writer.uint32(34).string(message.type_url);
    }
    if (message.removed_resources !== undefined && message.removed_resources.length !== 0) {
      for (const v of message.removed_resources) {
        writer.uint32(50).string(v!);
      }
    }
    if (message.removed_resource_names !== undefined && message.removed_resource_names.length !== 0) {
      for (const v of message.removed_resource_names) {
        ResourceName.encode(v!, writer.uint32(66).fork()).join();
      }
    }
    if (message.nonce !== undefined && message.nonce !== "") {
      writer.uint32(42).string(message.nonce);
    }
    if (message.control_plane !== undefined) {
      ControlPlane.encode(message.control_plane, writer.uint32(58).fork()).join();
    }
    if (message.resource_errors !== undefined && message.resource_errors.length !== 0) {
      for (const v of message.resource_errors) {
        ResourceError.encode(v!, writer.uint32(74).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeltaDiscoveryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeltaDiscoveryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.system_version_info = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.resources === undefined) {
            message.resources = [];
          }
          const el = Resource.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.resources!.push(el);
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.type_url = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          if (message.removed_resources === undefined) {
            message.removed_resources = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.removed_resources!.push(el);
          }
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          if (message.removed_resource_names === undefined) {
            message.removed_resource_names = [];
          }
          const el = ResourceName.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.removed_resource_names!.push(el);
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.nonce = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.control_plane = ControlPlane.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          if (message.resource_errors === undefined) {
            message.resource_errors = [];
          }
          const el = ResourceError.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.resource_errors!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeltaDiscoveryResponse {
    return {
      $type: DeltaDiscoveryResponse.$type,
      system_version_info: isSet(object.system_version_info)
        ? globalThis.String(object.system_version_info)
        : undefined,
      resources: globalThis.Array.isArray(object?.resources)
        ? object.resources.map((e: any) => Resource.fromJSON(e))
        : undefined,
      type_url: isSet(object.type_url) ? globalThis.String(object.type_url) : undefined,
      removed_resources: globalThis.Array.isArray(object?.removed_resources)
        ? object.removed_resources.map((e: any) => globalThis.String(e))
        : undefined,
      removed_resource_names: globalThis.Array.isArray(object?.removed_resource_names)
        ? object.removed_resource_names.map((e: any) => ResourceName.fromJSON(e))
        : undefined,
      nonce: isSet(object.nonce) ? globalThis.String(object.nonce) : undefined,
      control_plane: isSet(object.control_plane) ? ControlPlane.fromJSON(object.control_plane) : undefined,
      resource_errors: globalThis.Array.isArray(object?.resource_errors)
        ? object.resource_errors.map((e: any) => ResourceError.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: DeltaDiscoveryResponse): unknown {
    const obj: any = {};
    if (message.system_version_info !== undefined) {
      obj.system_version_info = message.system_version_info;
    }
    if (message.resources?.length) {
      obj.resources = message.resources.map((e) => Resource.toJSON(e));
    }
    if (message.type_url !== undefined) {
      obj.type_url = message.type_url;
    }
    if (message.removed_resources?.length) {
      obj.removed_resources = message.removed_resources;
    }
    if (message.removed_resource_names?.length) {
      obj.removed_resource_names = message.removed_resource_names.map((e) => ResourceName.toJSON(e));
    }
    if (message.nonce !== undefined) {
      obj.nonce = message.nonce;
    }
    if (message.control_plane !== undefined) {
      obj.control_plane = ControlPlane.toJSON(message.control_plane);
    }
    if (message.resource_errors?.length) {
      obj.resource_errors = message.resource_errors.map((e) => ResourceError.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeltaDiscoveryResponse>, I>>(base?: I): DeltaDiscoveryResponse {
    return DeltaDiscoveryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeltaDiscoveryResponse>, I>>(object: I): DeltaDiscoveryResponse {
    const message = createBaseDeltaDiscoveryResponse();
    message.system_version_info = object.system_version_info ?? undefined;
    message.resources = object.resources?.map((e) => Resource.fromPartial(e)) || undefined;
    message.type_url = object.type_url ?? undefined;
    message.removed_resources = object.removed_resources?.map((e) => e) || undefined;
    message.removed_resource_names = object.removed_resource_names?.map((e) => ResourceName.fromPartial(e)) ||
      undefined;
    message.nonce = object.nonce ?? undefined;
    message.control_plane = (object.control_plane !== undefined && object.control_plane !== null)
      ? ControlPlane.fromPartial(object.control_plane)
      : undefined;
    message.resource_errors = object.resource_errors?.map((e) => ResourceError.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(DeltaDiscoveryResponse.$type, DeltaDiscoveryResponse);

function createBaseDynamicParameterConstraints(): DynamicParameterConstraints {
  return { $type: "envoy.service.discovery.v3.DynamicParameterConstraints", type: undefined };
}

export const DynamicParameterConstraints: MessageFns<
  DynamicParameterConstraints,
  "envoy.service.discovery.v3.DynamicParameterConstraints"
> = {
  $type: "envoy.service.discovery.v3.DynamicParameterConstraints" as const,

  encode(message: DynamicParameterConstraints, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.type?.$case) {
      case "constraint":
        DynamicParameterConstraints_SingleConstraint.encode(message.type.constraint, writer.uint32(10).fork()).join();
        break;
      case "or_constraints":
        DynamicParameterConstraints_ConstraintList.encode(message.type.or_constraints, writer.uint32(18).fork()).join();
        break;
      case "and_constraints":
        DynamicParameterConstraints_ConstraintList.encode(message.type.and_constraints, writer.uint32(26).fork())
          .join();
        break;
      case "not_constraints":
        DynamicParameterConstraints.encode(message.type.not_constraints, writer.uint32(34).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DynamicParameterConstraints {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDynamicParameterConstraints();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = {
            $case: "constraint",
            constraint: DynamicParameterConstraints_SingleConstraint.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type = {
            $case: "or_constraints",
            or_constraints: DynamicParameterConstraints_ConstraintList.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.type = {
            $case: "and_constraints",
            and_constraints: DynamicParameterConstraints_ConstraintList.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.type = {
            $case: "not_constraints",
            not_constraints: DynamicParameterConstraints.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DynamicParameterConstraints {
    return {
      $type: DynamicParameterConstraints.$type,
      type: isSet(object.constraint)
        ? { $case: "constraint", constraint: DynamicParameterConstraints_SingleConstraint.fromJSON(object.constraint) }
        : isSet(object.or_constraints)
        ? {
          $case: "or_constraints",
          or_constraints: DynamicParameterConstraints_ConstraintList.fromJSON(object.or_constraints),
        }
        : isSet(object.and_constraints)
        ? {
          $case: "and_constraints",
          and_constraints: DynamicParameterConstraints_ConstraintList.fromJSON(object.and_constraints),
        }
        : isSet(object.not_constraints)
        ? { $case: "not_constraints", not_constraints: DynamicParameterConstraints.fromJSON(object.not_constraints) }
        : undefined,
    };
  },

  toJSON(message: DynamicParameterConstraints): unknown {
    const obj: any = {};
    if (message.type?.$case === "constraint") {
      obj.constraint = DynamicParameterConstraints_SingleConstraint.toJSON(message.type.constraint);
    }
    if (message.type?.$case === "or_constraints") {
      obj.or_constraints = DynamicParameterConstraints_ConstraintList.toJSON(message.type.or_constraints);
    }
    if (message.type?.$case === "and_constraints") {
      obj.and_constraints = DynamicParameterConstraints_ConstraintList.toJSON(message.type.and_constraints);
    }
    if (message.type?.$case === "not_constraints") {
      obj.not_constraints = DynamicParameterConstraints.toJSON(message.type.not_constraints);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DynamicParameterConstraints>, I>>(base?: I): DynamicParameterConstraints {
    return DynamicParameterConstraints.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DynamicParameterConstraints>, I>>(object: I): DynamicParameterConstraints {
    const message = createBaseDynamicParameterConstraints();
    if (
      object.type?.$case === "constraint" && object.type?.constraint !== undefined && object.type?.constraint !== null
    ) {
      message.type = {
        $case: "constraint",
        constraint: DynamicParameterConstraints_SingleConstraint.fromPartial(object.type.constraint),
      };
    }
    if (
      object.type?.$case === "or_constraints" &&
      object.type?.or_constraints !== undefined &&
      object.type?.or_constraints !== null
    ) {
      message.type = {
        $case: "or_constraints",
        or_constraints: DynamicParameterConstraints_ConstraintList.fromPartial(object.type.or_constraints),
      };
    }
    if (
      object.type?.$case === "and_constraints" &&
      object.type?.and_constraints !== undefined &&
      object.type?.and_constraints !== null
    ) {
      message.type = {
        $case: "and_constraints",
        and_constraints: DynamicParameterConstraints_ConstraintList.fromPartial(object.type.and_constraints),
      };
    }
    if (
      object.type?.$case === "not_constraints" &&
      object.type?.not_constraints !== undefined &&
      object.type?.not_constraints !== null
    ) {
      message.type = {
        $case: "not_constraints",
        not_constraints: DynamicParameterConstraints.fromPartial(object.type.not_constraints),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(DynamicParameterConstraints.$type, DynamicParameterConstraints);

function createBaseDynamicParameterConstraints_SingleConstraint(): DynamicParameterConstraints_SingleConstraint {
  return {
    $type: "envoy.service.discovery.v3.DynamicParameterConstraints.SingleConstraint",
    constraint_type: undefined,
  };
}

export const DynamicParameterConstraints_SingleConstraint: MessageFns<
  DynamicParameterConstraints_SingleConstraint,
  "envoy.service.discovery.v3.DynamicParameterConstraints.SingleConstraint"
> = {
  $type: "envoy.service.discovery.v3.DynamicParameterConstraints.SingleConstraint" as const,

  encode(
    message: DynamicParameterConstraints_SingleConstraint,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== undefined && message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    switch (message.constraint_type?.$case) {
      case "value":
        writer.uint32(18).string(message.constraint_type.value);
        break;
      case "exists":
        DynamicParameterConstraints_SingleConstraint_Exists.encode(
          message.constraint_type.exists,
          writer.uint32(26).fork(),
        ).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DynamicParameterConstraints_SingleConstraint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDynamicParameterConstraints_SingleConstraint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.constraint_type = { $case: "value", value: reader.string() };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.constraint_type = {
            $case: "exists",
            exists: DynamicParameterConstraints_SingleConstraint_Exists.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DynamicParameterConstraints_SingleConstraint {
    return {
      $type: DynamicParameterConstraints_SingleConstraint.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : undefined,
      constraint_type: isSet(object.value)
        ? { $case: "value", value: globalThis.String(object.value) }
        : isSet(object.exists)
        ? { $case: "exists", exists: DynamicParameterConstraints_SingleConstraint_Exists.fromJSON(object.exists) }
        : undefined,
    };
  },

  toJSON(message: DynamicParameterConstraints_SingleConstraint): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.constraint_type?.$case === "value") {
      obj.value = message.constraint_type.value;
    }
    if (message.constraint_type?.$case === "exists") {
      obj.exists = DynamicParameterConstraints_SingleConstraint_Exists.toJSON(message.constraint_type.exists);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DynamicParameterConstraints_SingleConstraint>, I>>(
    base?: I,
  ): DynamicParameterConstraints_SingleConstraint {
    return DynamicParameterConstraints_SingleConstraint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DynamicParameterConstraints_SingleConstraint>, I>>(
    object: I,
  ): DynamicParameterConstraints_SingleConstraint {
    const message = createBaseDynamicParameterConstraints_SingleConstraint();
    message.key = object.key ?? undefined;
    if (
      object.constraint_type?.$case === "value" &&
      object.constraint_type?.value !== undefined &&
      object.constraint_type?.value !== null
    ) {
      message.constraint_type = { $case: "value", value: object.constraint_type.value };
    }
    if (
      object.constraint_type?.$case === "exists" &&
      object.constraint_type?.exists !== undefined &&
      object.constraint_type?.exists !== null
    ) {
      message.constraint_type = {
        $case: "exists",
        exists: DynamicParameterConstraints_SingleConstraint_Exists.fromPartial(object.constraint_type.exists),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(
  DynamicParameterConstraints_SingleConstraint.$type,
  DynamicParameterConstraints_SingleConstraint,
);

function createBaseDynamicParameterConstraints_SingleConstraint_Exists(): DynamicParameterConstraints_SingleConstraint_Exists {
  return { $type: "envoy.service.discovery.v3.DynamicParameterConstraints.SingleConstraint.Exists" };
}

export const DynamicParameterConstraints_SingleConstraint_Exists: MessageFns<
  DynamicParameterConstraints_SingleConstraint_Exists,
  "envoy.service.discovery.v3.DynamicParameterConstraints.SingleConstraint.Exists"
> = {
  $type: "envoy.service.discovery.v3.DynamicParameterConstraints.SingleConstraint.Exists" as const,

  encode(
    _: DynamicParameterConstraints_SingleConstraint_Exists,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DynamicParameterConstraints_SingleConstraint_Exists {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDynamicParameterConstraints_SingleConstraint_Exists();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DynamicParameterConstraints_SingleConstraint_Exists {
    return { $type: DynamicParameterConstraints_SingleConstraint_Exists.$type };
  },

  toJSON(_: DynamicParameterConstraints_SingleConstraint_Exists): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DynamicParameterConstraints_SingleConstraint_Exists>, I>>(
    base?: I,
  ): DynamicParameterConstraints_SingleConstraint_Exists {
    return DynamicParameterConstraints_SingleConstraint_Exists.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DynamicParameterConstraints_SingleConstraint_Exists>, I>>(
    _: I,
  ): DynamicParameterConstraints_SingleConstraint_Exists {
    const message = createBaseDynamicParameterConstraints_SingleConstraint_Exists();
    return message;
  },
};

messageTypeRegistry.set(
  DynamicParameterConstraints_SingleConstraint_Exists.$type,
  DynamicParameterConstraints_SingleConstraint_Exists,
);

function createBaseDynamicParameterConstraints_ConstraintList(): DynamicParameterConstraints_ConstraintList {
  return { $type: "envoy.service.discovery.v3.DynamicParameterConstraints.ConstraintList" };
}

export const DynamicParameterConstraints_ConstraintList: MessageFns<
  DynamicParameterConstraints_ConstraintList,
  "envoy.service.discovery.v3.DynamicParameterConstraints.ConstraintList"
> = {
  $type: "envoy.service.discovery.v3.DynamicParameterConstraints.ConstraintList" as const,

  encode(message: DynamicParameterConstraints_ConstraintList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.constraints !== undefined && message.constraints.length !== 0) {
      for (const v of message.constraints) {
        DynamicParameterConstraints.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DynamicParameterConstraints_ConstraintList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDynamicParameterConstraints_ConstraintList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.constraints === undefined) {
            message.constraints = [];
          }
          const el = DynamicParameterConstraints.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.constraints!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DynamicParameterConstraints_ConstraintList {
    return {
      $type: DynamicParameterConstraints_ConstraintList.$type,
      constraints: globalThis.Array.isArray(object?.constraints)
        ? object.constraints.map((e: any) => DynamicParameterConstraints.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: DynamicParameterConstraints_ConstraintList): unknown {
    const obj: any = {};
    if (message.constraints?.length) {
      obj.constraints = message.constraints.map((e) => DynamicParameterConstraints.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DynamicParameterConstraints_ConstraintList>, I>>(
    base?: I,
  ): DynamicParameterConstraints_ConstraintList {
    return DynamicParameterConstraints_ConstraintList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DynamicParameterConstraints_ConstraintList>, I>>(
    object: I,
  ): DynamicParameterConstraints_ConstraintList {
    const message = createBaseDynamicParameterConstraints_ConstraintList();
    message.constraints = object.constraints?.map((e) => DynamicParameterConstraints.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(DynamicParameterConstraints_ConstraintList.$type, DynamicParameterConstraints_ConstraintList);

function createBaseResource(): Resource {
  return { $type: "envoy.service.discovery.v3.Resource" };
}

export const Resource: MessageFns<Resource, "envoy.service.discovery.v3.Resource"> = {
  $type: "envoy.service.discovery.v3.Resource" as const,

  encode(message: Resource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.resource_name !== undefined) {
      ResourceName.encode(message.resource_name, writer.uint32(66).fork()).join();
    }
    if (message.aliases !== undefined && message.aliases.length !== 0) {
      for (const v of message.aliases) {
        writer.uint32(34).string(v!);
      }
    }
    if (message.version !== undefined && message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    if (message.resource !== undefined) {
      Any.encode(message.resource, writer.uint32(18).fork()).join();
    }
    if (message.ttl !== undefined) {
      Duration.encode(message.ttl, writer.uint32(50).fork()).join();
    }
    if (message.cache_control !== undefined) {
      Resource_CacheControl.encode(message.cache_control, writer.uint32(58).fork()).join();
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Resource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.resource_name = ResourceName.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          if (message.aliases === undefined) {
            message.aliases = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.aliases!.push(el);
          }
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.resource = Any.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.ttl = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.cache_control = Resource_CacheControl.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Resource {
    return {
      $type: Resource.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      resource_name: isSet(object.resource_name) ? ResourceName.fromJSON(object.resource_name) : undefined,
      aliases: globalThis.Array.isArray(object?.aliases)
        ? object.aliases.map((e: any) => globalThis.String(e))
        : undefined,
      version: isSet(object.version) ? globalThis.String(object.version) : undefined,
      resource: isSet(object.resource) ? Any.fromJSON(object.resource) : undefined,
      ttl: isSet(object.ttl) ? Duration.fromJSON(object.ttl) : undefined,
      cache_control: isSet(object.cache_control) ? Resource_CacheControl.fromJSON(object.cache_control) : undefined,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: Resource): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.resource_name !== undefined) {
      obj.resource_name = ResourceName.toJSON(message.resource_name);
    }
    if (message.aliases?.length) {
      obj.aliases = message.aliases;
    }
    if (message.version !== undefined) {
      obj.version = message.version;
    }
    if (message.resource !== undefined) {
      obj.resource = Any.toJSON(message.resource);
    }
    if (message.ttl !== undefined) {
      obj.ttl = Duration.toJSON(message.ttl);
    }
    if (message.cache_control !== undefined) {
      obj.cache_control = Resource_CacheControl.toJSON(message.cache_control);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Resource>, I>>(base?: I): Resource {
    return Resource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Resource>, I>>(object: I): Resource {
    const message = createBaseResource();
    message.name = object.name ?? undefined;
    message.resource_name = (object.resource_name !== undefined && object.resource_name !== null)
      ? ResourceName.fromPartial(object.resource_name)
      : undefined;
    message.aliases = object.aliases?.map((e) => e) || undefined;
    message.version = object.version ?? undefined;
    message.resource = (object.resource !== undefined && object.resource !== null)
      ? Any.fromPartial(object.resource)
      : undefined;
    message.ttl = (object.ttl !== undefined && object.ttl !== null) ? Duration.fromPartial(object.ttl) : undefined;
    message.cache_control = (object.cache_control !== undefined && object.cache_control !== null)
      ? Resource_CacheControl.fromPartial(object.cache_control)
      : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Resource.$type, Resource);

function createBaseResource_CacheControl(): Resource_CacheControl {
  return { $type: "envoy.service.discovery.v3.Resource.CacheControl" };
}

export const Resource_CacheControl: MessageFns<
  Resource_CacheControl,
  "envoy.service.discovery.v3.Resource.CacheControl"
> = {
  $type: "envoy.service.discovery.v3.Resource.CacheControl" as const,

  encode(message: Resource_CacheControl, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.do_not_cache !== undefined && message.do_not_cache !== false) {
      writer.uint32(8).bool(message.do_not_cache);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Resource_CacheControl {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResource_CacheControl();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.do_not_cache = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Resource_CacheControl {
    return {
      $type: Resource_CacheControl.$type,
      do_not_cache: isSet(object.do_not_cache) ? globalThis.Boolean(object.do_not_cache) : undefined,
    };
  },

  toJSON(message: Resource_CacheControl): unknown {
    const obj: any = {};
    if (message.do_not_cache !== undefined) {
      obj.do_not_cache = message.do_not_cache;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Resource_CacheControl>, I>>(base?: I): Resource_CacheControl {
    return Resource_CacheControl.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Resource_CacheControl>, I>>(object: I): Resource_CacheControl {
    const message = createBaseResource_CacheControl();
    message.do_not_cache = object.do_not_cache ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Resource_CacheControl.$type, Resource_CacheControl);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
