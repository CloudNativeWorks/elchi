// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/service/auth/v2/attribute_context.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "../../../../google/protobuf/timestamp";
import { messageTypeRegistry } from "../../../../typeRegistry";
import { Address } from "../../../api/v2/core/address";
import { Metadata } from "../../../api/v2/core/base";

export const protobufPackage = "envoy.service.auth.v2";

/**
 * An attribute is a piece of metadata that describes an activity on a network.
 * For example, the size of an HTTP request, or the status code of an HTTP response.
 *
 * Each attribute has a type and a name, which is logically defined as a proto message field
 * of the `AttributeContext`. The `AttributeContext` is a collection of individual attributes
 * supported by Envoy authorization system.
 * [#comment: The following items are left out of this proto
 * Request.Auth field for JWTs
 * Request.Api for api management
 * Origin peer that originated the request
 * Caching Protocol
 * request_context return values to inject back into the filter chain
 * peer.claims -- from X.509 extensions
 * Configuration
 * - field mask to send
 * - which return values from request_context are copied back
 * - which return values are copied into request_headers]
 * [#next-free-field: 12]
 */
export interface AttributeContext {
  $type: "envoy.service.auth.v2.AttributeContext";
  /**
   * The source of a network activity, such as starting a TCP connection.
   * In a multi hop network activity, the source represents the sender of the
   * last hop.
   */
  source?:
    | AttributeContext_Peer
    | undefined;
  /**
   * The destination of a network activity, such as accepting a TCP connection.
   * In a multi hop network activity, the destination represents the receiver of
   * the last hop.
   */
  destination?:
    | AttributeContext_Peer
    | undefined;
  /** Represents a network request, such as an HTTP request. */
  request?:
    | AttributeContext_Request
    | undefined;
  /**
   * This is analogous to http_request.headers, however these contents will not be sent to the
   * upstream server. Context_extensions provide an extension mechanism for sending additional
   * information to the auth server without modifying the proto definition. It maps to the
   * internal opaque context in the filter chain.
   */
  context_extensions?:
    | Map<string, string>
    | undefined;
  /** Dynamic metadata associated with the request. */
  metadata_context?: Metadata | undefined;
}

/**
 * This message defines attributes for a node that handles a network request.
 * The node can be either a service or an application that sends, forwards,
 * or receives the request. Service peers should fill in the `service`,
 * `principal`, and `labels` as appropriate.
 * [#next-free-field: 6]
 */
export interface AttributeContext_Peer {
  $type: "envoy.service.auth.v2.AttributeContext.Peer";
  /**
   * The address of the peer, this is typically the IP address.
   * It can also be UDS path, or others.
   */
  address?:
    | Address
    | undefined;
  /**
   * The canonical service name of the peer.
   * It should be set to :ref:`the HTTP x-envoy-downstream-service-cluster
   * <config_http_conn_man_headers_downstream-service-cluster>`
   * If a more trusted source of the service name is available through mTLS/secure naming, it
   * should be used.
   */
  service?:
    | string
    | undefined;
  /**
   * The labels associated with the peer.
   * These could be pod labels for Kubernetes or tags for VMs.
   * The source of the labels could be an X.509 certificate or other configuration.
   */
  labels?:
    | Map<string, string>
    | undefined;
  /**
   * The authenticated identity of this peer.
   * For example, the identity associated with the workload such as a service account.
   * If an X.509 certificate is used to assert the identity this field should be sourced from
   * `URI Subject Alternative Names`, `DNS Subject Alternate Names` or `Subject` in that order.
   * The primary identity should be the principal. The principal format is issuer specific.
   *
   * Example:
   * *    SPIFFE format is `spiffe://trust-domain/path`
   * *    Google account format is `https://accounts.google.com/{userid}`
   */
  principal?:
    | string
    | undefined;
  /**
   * The X.509 certificate used to authenticate the identify of this peer.
   * When present, the certificate contents are encoded in URL and PEM format.
   */
  certificate?: string | undefined;
}

export interface AttributeContext_Peer_LabelsEntry {
  $type: "envoy.service.auth.v2.AttributeContext.Peer.LabelsEntry";
  key: string;
  value: string;
}

/** Represents a network request, such as an HTTP request. */
export interface AttributeContext_Request {
  $type: "envoy.service.auth.v2.AttributeContext.Request";
  /** The timestamp when the proxy receives the first byte of the request. */
  time?:
    | Date
    | undefined;
  /** Represents an HTTP request or an HTTP-like request. */
  http?: AttributeContext_HttpRequest | undefined;
}

/**
 * This message defines attributes for an HTTP request.
 * HTTP/1.x, HTTP/2, gRPC are all considered as HTTP requests.
 * [#next-free-field: 12]
 */
export interface AttributeContext_HttpRequest {
  $type: "envoy.service.auth.v2.AttributeContext.HttpRequest";
  /**
   * The unique ID for a request, which can be propagated to downstream
   * systems. The ID should have low probability of collision
   * within a single day for a specific service.
   * For HTTP requests, it should be X-Request-ID or equivalent.
   */
  id?:
    | string
    | undefined;
  /** The HTTP request method, such as `GET`, `POST`. */
  method?:
    | string
    | undefined;
  /**
   * The HTTP request headers. If multiple headers share the same key, they
   * must be merged according to the HTTP spec. All header keys must be
   * lower-cased, because HTTP header keys are case-insensitive.
   */
  headers?:
    | Map<string, string>
    | undefined;
  /**
   * The request target, as it appears in the first line of the HTTP request. This includes
   * the URL path and query-string. No decoding is performed.
   */
  path?:
    | string
    | undefined;
  /** The HTTP request `Host` or 'Authority` header value. */
  host?:
    | string
    | undefined;
  /**
   * The HTTP URL scheme, such as `http` and `https`. This is set for HTTP/2
   * requests only. For HTTP/1.1, use "x-forwarded-for" header value to lookup
   * the scheme of the request.
   */
  scheme?:
    | string
    | undefined;
  /**
   * This field is always empty, and exists for compatibility reasons. The HTTP URL query is
   * included in `path` field.
   */
  query?:
    | string
    | undefined;
  /**
   * This field is always empty, and exists for compatibility reasons. The URL fragment is
   * not submitted as part of HTTP requests; it is unknowable.
   */
  fragment?:
    | string
    | undefined;
  /** The HTTP request size in bytes. If unknown, it must be -1. */
  size?:
    | number
    | undefined;
  /**
   * The network protocol used with the request, such as "HTTP/1.0", "HTTP/1.1", or "HTTP/2".
   *
   * See :repo:`headers.h:ProtocolStrings <source/common/http/headers.h>` for a list of all
   * possible values.
   */
  protocol?:
    | string
    | undefined;
  /** The HTTP request body. */
  body?: string | undefined;
}

export interface AttributeContext_HttpRequest_HeadersEntry {
  $type: "envoy.service.auth.v2.AttributeContext.HttpRequest.HeadersEntry";
  key: string;
  value: string;
}

export interface AttributeContext_ContextExtensionsEntry {
  $type: "envoy.service.auth.v2.AttributeContext.ContextExtensionsEntry";
  key: string;
  value: string;
}

function createBaseAttributeContext(): AttributeContext {
  return { $type: "envoy.service.auth.v2.AttributeContext" };
}

export const AttributeContext: MessageFns<AttributeContext, "envoy.service.auth.v2.AttributeContext"> = {
  $type: "envoy.service.auth.v2.AttributeContext" as const,

  encode(message: AttributeContext, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== undefined) {
      AttributeContext_Peer.encode(message.source, writer.uint32(10).fork()).join();
    }
    if (message.destination !== undefined) {
      AttributeContext_Peer.encode(message.destination, writer.uint32(18).fork()).join();
    }
    if (message.request !== undefined) {
      AttributeContext_Request.encode(message.request, writer.uint32(34).fork()).join();
    }
    (message.context_extensions || new Map()).forEach((value, key) => {
      AttributeContext_ContextExtensionsEntry.encode({
        $type: "envoy.service.auth.v2.AttributeContext.ContextExtensionsEntry",
        key: key as any,
        value,
      }, writer.uint32(82).fork()).join();
    });
    if (message.metadata_context !== undefined) {
      Metadata.encode(message.metadata_context, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttributeContext {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttributeContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.source = AttributeContext_Peer.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.destination = AttributeContext_Peer.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.request = AttributeContext_Request.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          const entry10 = AttributeContext_ContextExtensionsEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            if (message.context_extensions === undefined) {
              message.context_extensions = new Map();
            }
            message.context_extensions!.set(entry10.key, entry10.value);
          }
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.metadata_context = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttributeContext {
    return {
      $type: AttributeContext.$type,
      source: isSet(object.source) ? AttributeContext_Peer.fromJSON(object.source) : undefined,
      destination: isSet(object.destination) ? AttributeContext_Peer.fromJSON(object.destination) : undefined,
      request: isSet(object.request) ? AttributeContext_Request.fromJSON(object.request) : undefined,
      context_extensions: isObject(object.context_extensions)
        ? Object.entries(object.context_extensions).reduce<Map<string, string>>((acc, [key, value]) => {
          acc.set(key, String(value));
          return acc;
        }, new Map())
        : undefined,
      metadata_context: isSet(object.metadata_context) ? Metadata.fromJSON(object.metadata_context) : undefined,
    };
  },

  toJSON(message: AttributeContext): unknown {
    const obj: any = {};
    if (message.source !== undefined) {
      obj.source = AttributeContext_Peer.toJSON(message.source);
    }
    if (message.destination !== undefined) {
      obj.destination = AttributeContext_Peer.toJSON(message.destination);
    }
    if (message.request !== undefined) {
      obj.request = AttributeContext_Request.toJSON(message.request);
    }
    if (message.context_extensions?.size) {
      obj.context_extensions = {};
      message.context_extensions.forEach((v, k) => {
        obj.context_extensions[k] = v;
      });
    }
    if (message.metadata_context !== undefined) {
      obj.metadata_context = Metadata.toJSON(message.metadata_context);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AttributeContext>, I>>(base?: I): AttributeContext {
    return AttributeContext.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AttributeContext>, I>>(object: I): AttributeContext {
    const message = createBaseAttributeContext();
    message.source = (object.source !== undefined && object.source !== null)
      ? AttributeContext_Peer.fromPartial(object.source)
      : undefined;
    message.destination = (object.destination !== undefined && object.destination !== null)
      ? AttributeContext_Peer.fromPartial(object.destination)
      : undefined;
    message.request = (object.request !== undefined && object.request !== null)
      ? AttributeContext_Request.fromPartial(object.request)
      : undefined;
    message.context_extensions = (object.context_extensions === undefined || object.context_extensions === null)
      ? undefined
      : (() => {
        const m = new Map();
        (object.context_extensions as Map<string, string> ?? new Map()).forEach((value, key) => {
          if (value !== undefined) {
            m.set(key, globalThis.String(value));
          }
        });
        return m;
      })();
    message.metadata_context = (object.metadata_context !== undefined && object.metadata_context !== null)
      ? Metadata.fromPartial(object.metadata_context)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(AttributeContext.$type, AttributeContext);

function createBaseAttributeContext_Peer(): AttributeContext_Peer {
  return { $type: "envoy.service.auth.v2.AttributeContext.Peer" };
}

export const AttributeContext_Peer: MessageFns<AttributeContext_Peer, "envoy.service.auth.v2.AttributeContext.Peer"> = {
  $type: "envoy.service.auth.v2.AttributeContext.Peer" as const,

  encode(message: AttributeContext_Peer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== undefined) {
      Address.encode(message.address, writer.uint32(10).fork()).join();
    }
    if (message.service !== undefined && message.service !== "") {
      writer.uint32(18).string(message.service);
    }
    (message.labels || new Map()).forEach((value, key) => {
      AttributeContext_Peer_LabelsEntry.encode({
        $type: "envoy.service.auth.v2.AttributeContext.Peer.LabelsEntry",
        key: key as any,
        value,
      }, writer.uint32(26).fork()).join();
    });
    if (message.principal !== undefined && message.principal !== "") {
      writer.uint32(34).string(message.principal);
    }
    if (message.certificate !== undefined && message.certificate !== "") {
      writer.uint32(42).string(message.certificate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttributeContext_Peer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttributeContext_Peer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = Address.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.service = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = AttributeContext_Peer_LabelsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            if (message.labels === undefined) {
              message.labels = new Map();
            }
            message.labels!.set(entry3.key, entry3.value);
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.principal = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.certificate = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttributeContext_Peer {
    return {
      $type: AttributeContext_Peer.$type,
      address: isSet(object.address) ? Address.fromJSON(object.address) : undefined,
      service: isSet(object.service) ? globalThis.String(object.service) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<Map<string, string>>((acc, [key, value]) => {
          acc.set(key, String(value));
          return acc;
        }, new Map())
        : undefined,
      principal: isSet(object.principal) ? globalThis.String(object.principal) : undefined,
      certificate: isSet(object.certificate) ? globalThis.String(object.certificate) : undefined,
    };
  },

  toJSON(message: AttributeContext_Peer): unknown {
    const obj: any = {};
    if (message.address !== undefined) {
      obj.address = Address.toJSON(message.address);
    }
    if (message.service !== undefined) {
      obj.service = message.service;
    }
    if (message.labels?.size) {
      obj.labels = {};
      message.labels.forEach((v, k) => {
        obj.labels[k] = v;
      });
    }
    if (message.principal !== undefined) {
      obj.principal = message.principal;
    }
    if (message.certificate !== undefined) {
      obj.certificate = message.certificate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AttributeContext_Peer>, I>>(base?: I): AttributeContext_Peer {
    return AttributeContext_Peer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AttributeContext_Peer>, I>>(object: I): AttributeContext_Peer {
    const message = createBaseAttributeContext_Peer();
    message.address = (object.address !== undefined && object.address !== null)
      ? Address.fromPartial(object.address)
      : undefined;
    message.service = object.service ?? undefined;
    message.labels = (object.labels === undefined || object.labels === null) ? undefined : (() => {
      const m = new Map();
      (object.labels as Map<string, string> ?? new Map()).forEach((value, key) => {
        if (value !== undefined) {
          m.set(key, globalThis.String(value));
        }
      });
      return m;
    })();
    message.principal = object.principal ?? undefined;
    message.certificate = object.certificate ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(AttributeContext_Peer.$type, AttributeContext_Peer);

function createBaseAttributeContext_Peer_LabelsEntry(): AttributeContext_Peer_LabelsEntry {
  return { $type: "envoy.service.auth.v2.AttributeContext.Peer.LabelsEntry", key: "", value: "" };
}

export const AttributeContext_Peer_LabelsEntry: MessageFns<
  AttributeContext_Peer_LabelsEntry,
  "envoy.service.auth.v2.AttributeContext.Peer.LabelsEntry"
> = {
  $type: "envoy.service.auth.v2.AttributeContext.Peer.LabelsEntry" as const,

  encode(message: AttributeContext_Peer_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttributeContext_Peer_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttributeContext_Peer_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttributeContext_Peer_LabelsEntry {
    return {
      $type: AttributeContext_Peer_LabelsEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AttributeContext_Peer_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AttributeContext_Peer_LabelsEntry>, I>>(
    base?: I,
  ): AttributeContext_Peer_LabelsEntry {
    return AttributeContext_Peer_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AttributeContext_Peer_LabelsEntry>, I>>(
    object: I,
  ): AttributeContext_Peer_LabelsEntry {
    const message = createBaseAttributeContext_Peer_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

messageTypeRegistry.set(AttributeContext_Peer_LabelsEntry.$type, AttributeContext_Peer_LabelsEntry);

function createBaseAttributeContext_Request(): AttributeContext_Request {
  return { $type: "envoy.service.auth.v2.AttributeContext.Request" };
}

export const AttributeContext_Request: MessageFns<
  AttributeContext_Request,
  "envoy.service.auth.v2.AttributeContext.Request"
> = {
  $type: "envoy.service.auth.v2.AttributeContext.Request" as const,

  encode(message: AttributeContext_Request, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.time !== undefined) {
      Timestamp.encode(toTimestamp(message.time), writer.uint32(10).fork()).join();
    }
    if (message.http !== undefined) {
      AttributeContext_HttpRequest.encode(message.http, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttributeContext_Request {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttributeContext_Request();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.http = AttributeContext_HttpRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttributeContext_Request {
    return {
      $type: AttributeContext_Request.$type,
      time: isSet(object.time) ? fromJsonTimestamp(object.time) : undefined,
      http: isSet(object.http) ? AttributeContext_HttpRequest.fromJSON(object.http) : undefined,
    };
  },

  toJSON(message: AttributeContext_Request): unknown {
    const obj: any = {};
    if (message.time !== undefined) {
      obj.time = message.time.toISOString();
    }
    if (message.http !== undefined) {
      obj.http = AttributeContext_HttpRequest.toJSON(message.http);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AttributeContext_Request>, I>>(base?: I): AttributeContext_Request {
    return AttributeContext_Request.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AttributeContext_Request>, I>>(object: I): AttributeContext_Request {
    const message = createBaseAttributeContext_Request();
    message.time = object.time ?? undefined;
    message.http = (object.http !== undefined && object.http !== null)
      ? AttributeContext_HttpRequest.fromPartial(object.http)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(AttributeContext_Request.$type, AttributeContext_Request);

function createBaseAttributeContext_HttpRequest(): AttributeContext_HttpRequest {
  return { $type: "envoy.service.auth.v2.AttributeContext.HttpRequest" };
}

export const AttributeContext_HttpRequest: MessageFns<
  AttributeContext_HttpRequest,
  "envoy.service.auth.v2.AttributeContext.HttpRequest"
> = {
  $type: "envoy.service.auth.v2.AttributeContext.HttpRequest" as const,

  encode(message: AttributeContext_HttpRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined && message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.method !== undefined && message.method !== "") {
      writer.uint32(18).string(message.method);
    }
    (message.headers || new Map()).forEach((value, key) => {
      AttributeContext_HttpRequest_HeadersEntry.encode({
        $type: "envoy.service.auth.v2.AttributeContext.HttpRequest.HeadersEntry",
        key: key as any,
        value,
      }, writer.uint32(26).fork()).join();
    });
    if (message.path !== undefined && message.path !== "") {
      writer.uint32(34).string(message.path);
    }
    if (message.host !== undefined && message.host !== "") {
      writer.uint32(42).string(message.host);
    }
    if (message.scheme !== undefined && message.scheme !== "") {
      writer.uint32(50).string(message.scheme);
    }
    if (message.query !== undefined && message.query !== "") {
      writer.uint32(58).string(message.query);
    }
    if (message.fragment !== undefined && message.fragment !== "") {
      writer.uint32(66).string(message.fragment);
    }
    if (message.size !== undefined && message.size !== 0) {
      writer.uint32(72).int64(message.size);
    }
    if (message.protocol !== undefined && message.protocol !== "") {
      writer.uint32(82).string(message.protocol);
    }
    if (message.body !== undefined && message.body !== "") {
      writer.uint32(90).string(message.body);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttributeContext_HttpRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttributeContext_HttpRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.method = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = AttributeContext_HttpRequest_HeadersEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            if (message.headers === undefined) {
              message.headers = new Map();
            }
            message.headers!.set(entry3.key, entry3.value);
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.host = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.scheme = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.query = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.fragment = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.size = longToNumber(reader.int64());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.protocol = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.body = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttributeContext_HttpRequest {
    return {
      $type: AttributeContext_HttpRequest.$type,
      id: isSet(object.id) ? globalThis.String(object.id) : undefined,
      method: isSet(object.method) ? globalThis.String(object.method) : undefined,
      headers: isObject(object.headers)
        ? Object.entries(object.headers).reduce<Map<string, string>>((acc, [key, value]) => {
          acc.set(key, String(value));
          return acc;
        }, new Map())
        : undefined,
      path: isSet(object.path) ? globalThis.String(object.path) : undefined,
      host: isSet(object.host) ? globalThis.String(object.host) : undefined,
      scheme: isSet(object.scheme) ? globalThis.String(object.scheme) : undefined,
      query: isSet(object.query) ? globalThis.String(object.query) : undefined,
      fragment: isSet(object.fragment) ? globalThis.String(object.fragment) : undefined,
      size: isSet(object.size) ? globalThis.Number(object.size) : undefined,
      protocol: isSet(object.protocol) ? globalThis.String(object.protocol) : undefined,
      body: isSet(object.body) ? globalThis.String(object.body) : undefined,
    };
  },

  toJSON(message: AttributeContext_HttpRequest): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = message.id;
    }
    if (message.method !== undefined) {
      obj.method = message.method;
    }
    if (message.headers?.size) {
      obj.headers = {};
      message.headers.forEach((v, k) => {
        obj.headers[k] = v;
      });
    }
    if (message.path !== undefined) {
      obj.path = message.path;
    }
    if (message.host !== undefined) {
      obj.host = message.host;
    }
    if (message.scheme !== undefined) {
      obj.scheme = message.scheme;
    }
    if (message.query !== undefined) {
      obj.query = message.query;
    }
    if (message.fragment !== undefined) {
      obj.fragment = message.fragment;
    }
    if (message.size !== undefined) {
      obj.size = Math.round(message.size);
    }
    if (message.protocol !== undefined) {
      obj.protocol = message.protocol;
    }
    if (message.body !== undefined) {
      obj.body = message.body;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AttributeContext_HttpRequest>, I>>(base?: I): AttributeContext_HttpRequest {
    return AttributeContext_HttpRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AttributeContext_HttpRequest>, I>>(object: I): AttributeContext_HttpRequest {
    const message = createBaseAttributeContext_HttpRequest();
    message.id = object.id ?? undefined;
    message.method = object.method ?? undefined;
    message.headers = (object.headers === undefined || object.headers === null) ? undefined : (() => {
      const m = new Map();
      (object.headers as Map<string, string> ?? new Map()).forEach((value, key) => {
        if (value !== undefined) {
          m.set(key, globalThis.String(value));
        }
      });
      return m;
    })();
    message.path = object.path ?? undefined;
    message.host = object.host ?? undefined;
    message.scheme = object.scheme ?? undefined;
    message.query = object.query ?? undefined;
    message.fragment = object.fragment ?? undefined;
    message.size = object.size ?? undefined;
    message.protocol = object.protocol ?? undefined;
    message.body = object.body ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(AttributeContext_HttpRequest.$type, AttributeContext_HttpRequest);

function createBaseAttributeContext_HttpRequest_HeadersEntry(): AttributeContext_HttpRequest_HeadersEntry {
  return { $type: "envoy.service.auth.v2.AttributeContext.HttpRequest.HeadersEntry", key: "", value: "" };
}

export const AttributeContext_HttpRequest_HeadersEntry: MessageFns<
  AttributeContext_HttpRequest_HeadersEntry,
  "envoy.service.auth.v2.AttributeContext.HttpRequest.HeadersEntry"
> = {
  $type: "envoy.service.auth.v2.AttributeContext.HttpRequest.HeadersEntry" as const,

  encode(message: AttributeContext_HttpRequest_HeadersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttributeContext_HttpRequest_HeadersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttributeContext_HttpRequest_HeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttributeContext_HttpRequest_HeadersEntry {
    return {
      $type: AttributeContext_HttpRequest_HeadersEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AttributeContext_HttpRequest_HeadersEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AttributeContext_HttpRequest_HeadersEntry>, I>>(
    base?: I,
  ): AttributeContext_HttpRequest_HeadersEntry {
    return AttributeContext_HttpRequest_HeadersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AttributeContext_HttpRequest_HeadersEntry>, I>>(
    object: I,
  ): AttributeContext_HttpRequest_HeadersEntry {
    const message = createBaseAttributeContext_HttpRequest_HeadersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

messageTypeRegistry.set(AttributeContext_HttpRequest_HeadersEntry.$type, AttributeContext_HttpRequest_HeadersEntry);

function createBaseAttributeContext_ContextExtensionsEntry(): AttributeContext_ContextExtensionsEntry {
  return { $type: "envoy.service.auth.v2.AttributeContext.ContextExtensionsEntry", key: "", value: "" };
}

export const AttributeContext_ContextExtensionsEntry: MessageFns<
  AttributeContext_ContextExtensionsEntry,
  "envoy.service.auth.v2.AttributeContext.ContextExtensionsEntry"
> = {
  $type: "envoy.service.auth.v2.AttributeContext.ContextExtensionsEntry" as const,

  encode(message: AttributeContext_ContextExtensionsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttributeContext_ContextExtensionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttributeContext_ContextExtensionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttributeContext_ContextExtensionsEntry {
    return {
      $type: AttributeContext_ContextExtensionsEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AttributeContext_ContextExtensionsEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AttributeContext_ContextExtensionsEntry>, I>>(
    base?: I,
  ): AttributeContext_ContextExtensionsEntry {
    return AttributeContext_ContextExtensionsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AttributeContext_ContextExtensionsEntry>, I>>(
    object: I,
  ): AttributeContext_ContextExtensionsEntry {
    const message = createBaseAttributeContext_ContextExtensionsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

messageTypeRegistry.set(AttributeContext_ContextExtensionsEntry.$type, AttributeContext_ContextExtensionsEntry);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { $type: "google.protobuf.Timestamp", seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
