// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: xds/type/matcher/v3/matcher.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { messageTypeRegistry } from "../../../../typeRegistry";
import { TypedExtensionConfig } from "../../../core/v3/extension";
import { StringMatcher } from "./string";

export const protobufPackage = "xds.type.matcher.v3";

/**
 * A matcher, which may traverse a matching tree in order to result in a match action.
 * During matching, the tree will be traversed until a match is found, or if no match
 * is found the action specified by the most specific on_no_match will be evaluated.
 * As an on_no_match might result in another matching tree being evaluated, this process
 * might repeat several times until the final OnMatch (or no match) is decided.
 */
export interface Matcher {
  $type: "xds.type.matcher.v3.Matcher";
  matcher_type?:
    | //
    /** A linear list of matchers to evaluate. */
    { $case: "matcher_list"; matcher_list: Matcher_MatcherList }
    | //
    /** A match tree to evaluate. */
    { $case: "matcher_tree"; matcher_tree: Matcher_MatcherTree }
    | undefined;
  /**
   * Optional OnMatch to use if no matcher above matched (e.g., if there are no matchers specified
   * above, or if none of the matches specified above succeeded).
   * If no matcher above matched and this field is not populated, the match will be considered unsuccessful.
   */
  on_no_match?: Matcher_OnMatch | undefined;
}

/** What to do if a match is successful. */
export interface Matcher_OnMatch {
  $type: "xds.type.matcher.v3.Matcher.OnMatch";
  on_match?:
    | //
    /**
     * Nested matcher to evaluate.
     * If the nested matcher does not match and does not specify
     * on_no_match, then this matcher is considered not to have
     * matched, even if a predicate at this level or above returned
     * true.
     */
    { $case: "matcher"; matcher: Matcher }
    | //
    /** Protocol-specific action to take. */
    { $case: "action"; action: TypedExtensionConfig }
    | undefined;
}

/**
 * A linear list of field matchers.
 * The field matchers are evaluated in order, and the first match
 * wins.
 */
export interface Matcher_MatcherList {
  $type: "xds.type.matcher.v3.Matcher.MatcherList";
  /** A list of matchers. First match wins. */
  matchers?: Matcher_MatcherList_FieldMatcher[] | undefined;
}

/** Predicate to determine if a match is successful. */
export interface Matcher_MatcherList_Predicate {
  $type: "xds.type.matcher.v3.Matcher.MatcherList.Predicate";
  match_type?:
    | //
    /** A single predicate to evaluate. */
    { $case: "single_predicate"; single_predicate: Matcher_MatcherList_Predicate_SinglePredicate }
    | //
    /** A list of predicates to be OR-ed together. */
    { $case: "or_matcher"; or_matcher: Matcher_MatcherList_Predicate_PredicateList }
    | //
    /** A list of predicates to be AND-ed together. */
    { $case: "and_matcher"; and_matcher: Matcher_MatcherList_Predicate_PredicateList }
    | //
    /** The invert of a predicate */
    { $case: "not_matcher"; not_matcher: Matcher_MatcherList_Predicate }
    | undefined;
}

/** Predicate for a single input field. */
export interface Matcher_MatcherList_Predicate_SinglePredicate {
  $type: "xds.type.matcher.v3.Matcher.MatcherList.Predicate.SinglePredicate";
  /**
   * Protocol-specific specification of input field to match on.
   * [#extension-category: envoy.matching.common_inputs]
   */
  input?: TypedExtensionConfig | undefined;
  matcher?:
    | //
    /** Built-in string matcher. */
    { $case: "value_match"; value_match: StringMatcher }
    | //
    /**
     * Extension for custom matching logic.
     * [#extension-category: envoy.matching.input_matchers]
     */
    { $case: "custom_match"; custom_match: TypedExtensionConfig }
    | undefined;
}

/** A list of two or more matchers. Used to allow using a list within a oneof. */
export interface Matcher_MatcherList_Predicate_PredicateList {
  $type: "xds.type.matcher.v3.Matcher.MatcherList.Predicate.PredicateList";
  predicate?: Matcher_MatcherList_Predicate[] | undefined;
}

/** An individual matcher. */
export interface Matcher_MatcherList_FieldMatcher {
  $type: "xds.type.matcher.v3.Matcher.MatcherList.FieldMatcher";
  /** Determines if the match succeeds. */
  predicate?:
    | Matcher_MatcherList_Predicate
    | undefined;
  /** What to do if the match succeeds. */
  on_match?: Matcher_OnMatch | undefined;
}

export interface Matcher_MatcherTree {
  $type: "xds.type.matcher.v3.Matcher.MatcherTree";
  /** Protocol-specific specification of input field to match on. */
  input?:
    | TypedExtensionConfig
    | undefined;
  /**
   * Exact or prefix match maps in which to look up the input value.
   * If the lookup succeeds, the match is considered successful, and
   * the corresponding OnMatch is used.
   */
  tree_type?:
    | //
    { $case: "exact_match_map"; exact_match_map: Matcher_MatcherTree_MatchMap }
    | //
    /** Longest matching prefix wins. */
    { $case: "prefix_match_map"; prefix_match_map: Matcher_MatcherTree_MatchMap }
    | //
    /** Extension for custom matching logic. */
    { $case: "custom_match"; custom_match: TypedExtensionConfig }
    | undefined;
}

/** A map of configured matchers. Used to allow using a map within a oneof. */
export interface Matcher_MatcherTree_MatchMap {
  $type: "xds.type.matcher.v3.Matcher.MatcherTree.MatchMap";
  map?: Map<string, Matcher_OnMatch> | undefined;
}

export interface Matcher_MatcherTree_MatchMap_MapEntry {
  $type: "xds.type.matcher.v3.Matcher.MatcherTree.MatchMap.MapEntry";
  key: string;
  value?: Matcher_OnMatch | undefined;
}

function createBaseMatcher(): Matcher {
  return { $type: "xds.type.matcher.v3.Matcher", matcher_type: undefined };
}

export const Matcher: MessageFns<Matcher, "xds.type.matcher.v3.Matcher"> = {
  $type: "xds.type.matcher.v3.Matcher" as const,

  encode(message: Matcher, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.matcher_type?.$case) {
      case "matcher_list":
        Matcher_MatcherList.encode(message.matcher_type.matcher_list, writer.uint32(10).fork()).join();
        break;
      case "matcher_tree":
        Matcher_MatcherTree.encode(message.matcher_type.matcher_tree, writer.uint32(18).fork()).join();
        break;
    }
    if (message.on_no_match !== undefined) {
      Matcher_OnMatch.encode(message.on_no_match, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Matcher {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatcher();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.matcher_type = {
            $case: "matcher_list",
            matcher_list: Matcher_MatcherList.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.matcher_type = {
            $case: "matcher_tree",
            matcher_tree: Matcher_MatcherTree.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.on_no_match = Matcher_OnMatch.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Matcher {
    return {
      $type: Matcher.$type,
      matcher_type: isSet(object.matcher_list)
        ? { $case: "matcher_list", matcher_list: Matcher_MatcherList.fromJSON(object.matcher_list) }
        : isSet(object.matcher_tree)
        ? { $case: "matcher_tree", matcher_tree: Matcher_MatcherTree.fromJSON(object.matcher_tree) }
        : undefined,
      on_no_match: isSet(object.on_no_match) ? Matcher_OnMatch.fromJSON(object.on_no_match) : undefined,
    };
  },

  toJSON(message: Matcher): unknown {
    const obj: any = {};
    if (message.matcher_type?.$case === "matcher_list") {
      obj.matcher_list = Matcher_MatcherList.toJSON(message.matcher_type.matcher_list);
    }
    if (message.matcher_type?.$case === "matcher_tree") {
      obj.matcher_tree = Matcher_MatcherTree.toJSON(message.matcher_type.matcher_tree);
    }
    if (message.on_no_match !== undefined) {
      obj.on_no_match = Matcher_OnMatch.toJSON(message.on_no_match);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Matcher>, I>>(base?: I): Matcher {
    return Matcher.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Matcher>, I>>(object: I): Matcher {
    const message = createBaseMatcher();
    if (
      object.matcher_type?.$case === "matcher_list" &&
      object.matcher_type?.matcher_list !== undefined &&
      object.matcher_type?.matcher_list !== null
    ) {
      message.matcher_type = {
        $case: "matcher_list",
        matcher_list: Matcher_MatcherList.fromPartial(object.matcher_type.matcher_list),
      };
    }
    if (
      object.matcher_type?.$case === "matcher_tree" &&
      object.matcher_type?.matcher_tree !== undefined &&
      object.matcher_type?.matcher_tree !== null
    ) {
      message.matcher_type = {
        $case: "matcher_tree",
        matcher_tree: Matcher_MatcherTree.fromPartial(object.matcher_type.matcher_tree),
      };
    }
    message.on_no_match = (object.on_no_match !== undefined && object.on_no_match !== null)
      ? Matcher_OnMatch.fromPartial(object.on_no_match)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Matcher.$type, Matcher);

function createBaseMatcher_OnMatch(): Matcher_OnMatch {
  return { $type: "xds.type.matcher.v3.Matcher.OnMatch", on_match: undefined };
}

export const Matcher_OnMatch: MessageFns<Matcher_OnMatch, "xds.type.matcher.v3.Matcher.OnMatch"> = {
  $type: "xds.type.matcher.v3.Matcher.OnMatch" as const,

  encode(message: Matcher_OnMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.on_match?.$case) {
      case "matcher":
        Matcher.encode(message.on_match.matcher, writer.uint32(10).fork()).join();
        break;
      case "action":
        TypedExtensionConfig.encode(message.on_match.action, writer.uint32(18).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Matcher_OnMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatcher_OnMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.on_match = { $case: "matcher", matcher: Matcher.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.on_match = { $case: "action", action: TypedExtensionConfig.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Matcher_OnMatch {
    return {
      $type: Matcher_OnMatch.$type,
      on_match: isSet(object.matcher)
        ? { $case: "matcher", matcher: Matcher.fromJSON(object.matcher) }
        : isSet(object.action)
        ? { $case: "action", action: TypedExtensionConfig.fromJSON(object.action) }
        : undefined,
    };
  },

  toJSON(message: Matcher_OnMatch): unknown {
    const obj: any = {};
    if (message.on_match?.$case === "matcher") {
      obj.matcher = Matcher.toJSON(message.on_match.matcher);
    }
    if (message.on_match?.$case === "action") {
      obj.action = TypedExtensionConfig.toJSON(message.on_match.action);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Matcher_OnMatch>, I>>(base?: I): Matcher_OnMatch {
    return Matcher_OnMatch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Matcher_OnMatch>, I>>(object: I): Matcher_OnMatch {
    const message = createBaseMatcher_OnMatch();
    if (
      object.on_match?.$case === "matcher" &&
      object.on_match?.matcher !== undefined &&
      object.on_match?.matcher !== null
    ) {
      message.on_match = { $case: "matcher", matcher: Matcher.fromPartial(object.on_match.matcher) };
    }
    if (
      object.on_match?.$case === "action" && object.on_match?.action !== undefined && object.on_match?.action !== null
    ) {
      message.on_match = { $case: "action", action: TypedExtensionConfig.fromPartial(object.on_match.action) };
    }
    return message;
  },
};

messageTypeRegistry.set(Matcher_OnMatch.$type, Matcher_OnMatch);

function createBaseMatcher_MatcherList(): Matcher_MatcherList {
  return { $type: "xds.type.matcher.v3.Matcher.MatcherList" };
}

export const Matcher_MatcherList: MessageFns<Matcher_MatcherList, "xds.type.matcher.v3.Matcher.MatcherList"> = {
  $type: "xds.type.matcher.v3.Matcher.MatcherList" as const,

  encode(message: Matcher_MatcherList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.matchers !== undefined && message.matchers.length !== 0) {
      for (const v of message.matchers) {
        Matcher_MatcherList_FieldMatcher.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Matcher_MatcherList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatcher_MatcherList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.matchers === undefined) {
            message.matchers = [];
          }
          const el = Matcher_MatcherList_FieldMatcher.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.matchers!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Matcher_MatcherList {
    return {
      $type: Matcher_MatcherList.$type,
      matchers: globalThis.Array.isArray(object?.matchers)
        ? object.matchers.map((e: any) => Matcher_MatcherList_FieldMatcher.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: Matcher_MatcherList): unknown {
    const obj: any = {};
    if (message.matchers?.length) {
      obj.matchers = message.matchers.map((e) => Matcher_MatcherList_FieldMatcher.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Matcher_MatcherList>, I>>(base?: I): Matcher_MatcherList {
    return Matcher_MatcherList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Matcher_MatcherList>, I>>(object: I): Matcher_MatcherList {
    const message = createBaseMatcher_MatcherList();
    message.matchers = object.matchers?.map((e) => Matcher_MatcherList_FieldMatcher.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(Matcher_MatcherList.$type, Matcher_MatcherList);

function createBaseMatcher_MatcherList_Predicate(): Matcher_MatcherList_Predicate {
  return { $type: "xds.type.matcher.v3.Matcher.MatcherList.Predicate", match_type: undefined };
}

export const Matcher_MatcherList_Predicate: MessageFns<
  Matcher_MatcherList_Predicate,
  "xds.type.matcher.v3.Matcher.MatcherList.Predicate"
> = {
  $type: "xds.type.matcher.v3.Matcher.MatcherList.Predicate" as const,

  encode(message: Matcher_MatcherList_Predicate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.match_type?.$case) {
      case "single_predicate":
        Matcher_MatcherList_Predicate_SinglePredicate.encode(
          message.match_type.single_predicate,
          writer.uint32(10).fork(),
        ).join();
        break;
      case "or_matcher":
        Matcher_MatcherList_Predicate_PredicateList.encode(message.match_type.or_matcher, writer.uint32(18).fork())
          .join();
        break;
      case "and_matcher":
        Matcher_MatcherList_Predicate_PredicateList.encode(message.match_type.and_matcher, writer.uint32(26).fork())
          .join();
        break;
      case "not_matcher":
        Matcher_MatcherList_Predicate.encode(message.match_type.not_matcher, writer.uint32(34).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Matcher_MatcherList_Predicate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatcher_MatcherList_Predicate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.match_type = {
            $case: "single_predicate",
            single_predicate: Matcher_MatcherList_Predicate_SinglePredicate.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.match_type = {
            $case: "or_matcher",
            or_matcher: Matcher_MatcherList_Predicate_PredicateList.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.match_type = {
            $case: "and_matcher",
            and_matcher: Matcher_MatcherList_Predicate_PredicateList.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.match_type = {
            $case: "not_matcher",
            not_matcher: Matcher_MatcherList_Predicate.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Matcher_MatcherList_Predicate {
    return {
      $type: Matcher_MatcherList_Predicate.$type,
      match_type: isSet(object.single_predicate)
        ? {
          $case: "single_predicate",
          single_predicate: Matcher_MatcherList_Predicate_SinglePredicate.fromJSON(object.single_predicate),
        }
        : isSet(object.or_matcher)
        ? { $case: "or_matcher", or_matcher: Matcher_MatcherList_Predicate_PredicateList.fromJSON(object.or_matcher) }
        : isSet(object.and_matcher)
        ? {
          $case: "and_matcher",
          and_matcher: Matcher_MatcherList_Predicate_PredicateList.fromJSON(object.and_matcher),
        }
        : isSet(object.not_matcher)
        ? { $case: "not_matcher", not_matcher: Matcher_MatcherList_Predicate.fromJSON(object.not_matcher) }
        : undefined,
    };
  },

  toJSON(message: Matcher_MatcherList_Predicate): unknown {
    const obj: any = {};
    if (message.match_type?.$case === "single_predicate") {
      obj.single_predicate = Matcher_MatcherList_Predicate_SinglePredicate.toJSON(message.match_type.single_predicate);
    }
    if (message.match_type?.$case === "or_matcher") {
      obj.or_matcher = Matcher_MatcherList_Predicate_PredicateList.toJSON(message.match_type.or_matcher);
    }
    if (message.match_type?.$case === "and_matcher") {
      obj.and_matcher = Matcher_MatcherList_Predicate_PredicateList.toJSON(message.match_type.and_matcher);
    }
    if (message.match_type?.$case === "not_matcher") {
      obj.not_matcher = Matcher_MatcherList_Predicate.toJSON(message.match_type.not_matcher);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Matcher_MatcherList_Predicate>, I>>(base?: I): Matcher_MatcherList_Predicate {
    return Matcher_MatcherList_Predicate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Matcher_MatcherList_Predicate>, I>>(
    object: I,
  ): Matcher_MatcherList_Predicate {
    const message = createBaseMatcher_MatcherList_Predicate();
    if (
      object.match_type?.$case === "single_predicate" &&
      object.match_type?.single_predicate !== undefined &&
      object.match_type?.single_predicate !== null
    ) {
      message.match_type = {
        $case: "single_predicate",
        single_predicate: Matcher_MatcherList_Predicate_SinglePredicate.fromPartial(object.match_type.single_predicate),
      };
    }
    if (
      object.match_type?.$case === "or_matcher" &&
      object.match_type?.or_matcher !== undefined &&
      object.match_type?.or_matcher !== null
    ) {
      message.match_type = {
        $case: "or_matcher",
        or_matcher: Matcher_MatcherList_Predicate_PredicateList.fromPartial(object.match_type.or_matcher),
      };
    }
    if (
      object.match_type?.$case === "and_matcher" &&
      object.match_type?.and_matcher !== undefined &&
      object.match_type?.and_matcher !== null
    ) {
      message.match_type = {
        $case: "and_matcher",
        and_matcher: Matcher_MatcherList_Predicate_PredicateList.fromPartial(object.match_type.and_matcher),
      };
    }
    if (
      object.match_type?.$case === "not_matcher" &&
      object.match_type?.not_matcher !== undefined &&
      object.match_type?.not_matcher !== null
    ) {
      message.match_type = {
        $case: "not_matcher",
        not_matcher: Matcher_MatcherList_Predicate.fromPartial(object.match_type.not_matcher),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(Matcher_MatcherList_Predicate.$type, Matcher_MatcherList_Predicate);

function createBaseMatcher_MatcherList_Predicate_SinglePredicate(): Matcher_MatcherList_Predicate_SinglePredicate {
  return { $type: "xds.type.matcher.v3.Matcher.MatcherList.Predicate.SinglePredicate", matcher: undefined };
}

export const Matcher_MatcherList_Predicate_SinglePredicate: MessageFns<
  Matcher_MatcherList_Predicate_SinglePredicate,
  "xds.type.matcher.v3.Matcher.MatcherList.Predicate.SinglePredicate"
> = {
  $type: "xds.type.matcher.v3.Matcher.MatcherList.Predicate.SinglePredicate" as const,

  encode(
    message: Matcher_MatcherList_Predicate_SinglePredicate,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.input !== undefined) {
      TypedExtensionConfig.encode(message.input, writer.uint32(10).fork()).join();
    }
    switch (message.matcher?.$case) {
      case "value_match":
        StringMatcher.encode(message.matcher.value_match, writer.uint32(18).fork()).join();
        break;
      case "custom_match":
        TypedExtensionConfig.encode(message.matcher.custom_match, writer.uint32(26).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Matcher_MatcherList_Predicate_SinglePredicate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatcher_MatcherList_Predicate_SinglePredicate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.input = TypedExtensionConfig.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.matcher = { $case: "value_match", value_match: StringMatcher.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.matcher = {
            $case: "custom_match",
            custom_match: TypedExtensionConfig.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Matcher_MatcherList_Predicate_SinglePredicate {
    return {
      $type: Matcher_MatcherList_Predicate_SinglePredicate.$type,
      input: isSet(object.input) ? TypedExtensionConfig.fromJSON(object.input) : undefined,
      matcher: isSet(object.value_match)
        ? { $case: "value_match", value_match: StringMatcher.fromJSON(object.value_match) }
        : isSet(object.custom_match)
        ? { $case: "custom_match", custom_match: TypedExtensionConfig.fromJSON(object.custom_match) }
        : undefined,
    };
  },

  toJSON(message: Matcher_MatcherList_Predicate_SinglePredicate): unknown {
    const obj: any = {};
    if (message.input !== undefined) {
      obj.input = TypedExtensionConfig.toJSON(message.input);
    }
    if (message.matcher?.$case === "value_match") {
      obj.value_match = StringMatcher.toJSON(message.matcher.value_match);
    }
    if (message.matcher?.$case === "custom_match") {
      obj.custom_match = TypedExtensionConfig.toJSON(message.matcher.custom_match);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Matcher_MatcherList_Predicate_SinglePredicate>, I>>(
    base?: I,
  ): Matcher_MatcherList_Predicate_SinglePredicate {
    return Matcher_MatcherList_Predicate_SinglePredicate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Matcher_MatcherList_Predicate_SinglePredicate>, I>>(
    object: I,
  ): Matcher_MatcherList_Predicate_SinglePredicate {
    const message = createBaseMatcher_MatcherList_Predicate_SinglePredicate();
    message.input = (object.input !== undefined && object.input !== null)
      ? TypedExtensionConfig.fromPartial(object.input)
      : undefined;
    if (
      object.matcher?.$case === "value_match" &&
      object.matcher?.value_match !== undefined &&
      object.matcher?.value_match !== null
    ) {
      message.matcher = { $case: "value_match", value_match: StringMatcher.fromPartial(object.matcher.value_match) };
    }
    if (
      object.matcher?.$case === "custom_match" &&
      object.matcher?.custom_match !== undefined &&
      object.matcher?.custom_match !== null
    ) {
      message.matcher = {
        $case: "custom_match",
        custom_match: TypedExtensionConfig.fromPartial(object.matcher.custom_match),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(
  Matcher_MatcherList_Predicate_SinglePredicate.$type,
  Matcher_MatcherList_Predicate_SinglePredicate,
);

function createBaseMatcher_MatcherList_Predicate_PredicateList(): Matcher_MatcherList_Predicate_PredicateList {
  return { $type: "xds.type.matcher.v3.Matcher.MatcherList.Predicate.PredicateList" };
}

export const Matcher_MatcherList_Predicate_PredicateList: MessageFns<
  Matcher_MatcherList_Predicate_PredicateList,
  "xds.type.matcher.v3.Matcher.MatcherList.Predicate.PredicateList"
> = {
  $type: "xds.type.matcher.v3.Matcher.MatcherList.Predicate.PredicateList" as const,

  encode(
    message: Matcher_MatcherList_Predicate_PredicateList,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.predicate !== undefined && message.predicate.length !== 0) {
      for (const v of message.predicate) {
        Matcher_MatcherList_Predicate.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Matcher_MatcherList_Predicate_PredicateList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatcher_MatcherList_Predicate_PredicateList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.predicate === undefined) {
            message.predicate = [];
          }
          const el = Matcher_MatcherList_Predicate.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.predicate!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Matcher_MatcherList_Predicate_PredicateList {
    return {
      $type: Matcher_MatcherList_Predicate_PredicateList.$type,
      predicate: globalThis.Array.isArray(object?.predicate)
        ? object.predicate.map((e: any) => Matcher_MatcherList_Predicate.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: Matcher_MatcherList_Predicate_PredicateList): unknown {
    const obj: any = {};
    if (message.predicate?.length) {
      obj.predicate = message.predicate.map((e) => Matcher_MatcherList_Predicate.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Matcher_MatcherList_Predicate_PredicateList>, I>>(
    base?: I,
  ): Matcher_MatcherList_Predicate_PredicateList {
    return Matcher_MatcherList_Predicate_PredicateList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Matcher_MatcherList_Predicate_PredicateList>, I>>(
    object: I,
  ): Matcher_MatcherList_Predicate_PredicateList {
    const message = createBaseMatcher_MatcherList_Predicate_PredicateList();
    message.predicate = object.predicate?.map((e) => Matcher_MatcherList_Predicate.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(Matcher_MatcherList_Predicate_PredicateList.$type, Matcher_MatcherList_Predicate_PredicateList);

function createBaseMatcher_MatcherList_FieldMatcher(): Matcher_MatcherList_FieldMatcher {
  return { $type: "xds.type.matcher.v3.Matcher.MatcherList.FieldMatcher" };
}

export const Matcher_MatcherList_FieldMatcher: MessageFns<
  Matcher_MatcherList_FieldMatcher,
  "xds.type.matcher.v3.Matcher.MatcherList.FieldMatcher"
> = {
  $type: "xds.type.matcher.v3.Matcher.MatcherList.FieldMatcher" as const,

  encode(message: Matcher_MatcherList_FieldMatcher, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.predicate !== undefined) {
      Matcher_MatcherList_Predicate.encode(message.predicate, writer.uint32(10).fork()).join();
    }
    if (message.on_match !== undefined) {
      Matcher_OnMatch.encode(message.on_match, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Matcher_MatcherList_FieldMatcher {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatcher_MatcherList_FieldMatcher();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.predicate = Matcher_MatcherList_Predicate.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.on_match = Matcher_OnMatch.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Matcher_MatcherList_FieldMatcher {
    return {
      $type: Matcher_MatcherList_FieldMatcher.$type,
      predicate: isSet(object.predicate) ? Matcher_MatcherList_Predicate.fromJSON(object.predicate) : undefined,
      on_match: isSet(object.on_match) ? Matcher_OnMatch.fromJSON(object.on_match) : undefined,
    };
  },

  toJSON(message: Matcher_MatcherList_FieldMatcher): unknown {
    const obj: any = {};
    if (message.predicate !== undefined) {
      obj.predicate = Matcher_MatcherList_Predicate.toJSON(message.predicate);
    }
    if (message.on_match !== undefined) {
      obj.on_match = Matcher_OnMatch.toJSON(message.on_match);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Matcher_MatcherList_FieldMatcher>, I>>(
    base?: I,
  ): Matcher_MatcherList_FieldMatcher {
    return Matcher_MatcherList_FieldMatcher.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Matcher_MatcherList_FieldMatcher>, I>>(
    object: I,
  ): Matcher_MatcherList_FieldMatcher {
    const message = createBaseMatcher_MatcherList_FieldMatcher();
    message.predicate = (object.predicate !== undefined && object.predicate !== null)
      ? Matcher_MatcherList_Predicate.fromPartial(object.predicate)
      : undefined;
    message.on_match = (object.on_match !== undefined && object.on_match !== null)
      ? Matcher_OnMatch.fromPartial(object.on_match)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Matcher_MatcherList_FieldMatcher.$type, Matcher_MatcherList_FieldMatcher);

function createBaseMatcher_MatcherTree(): Matcher_MatcherTree {
  return { $type: "xds.type.matcher.v3.Matcher.MatcherTree", tree_type: undefined };
}

export const Matcher_MatcherTree: MessageFns<Matcher_MatcherTree, "xds.type.matcher.v3.Matcher.MatcherTree"> = {
  $type: "xds.type.matcher.v3.Matcher.MatcherTree" as const,

  encode(message: Matcher_MatcherTree, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.input !== undefined) {
      TypedExtensionConfig.encode(message.input, writer.uint32(10).fork()).join();
    }
    switch (message.tree_type?.$case) {
      case "exact_match_map":
        Matcher_MatcherTree_MatchMap.encode(message.tree_type.exact_match_map, writer.uint32(18).fork()).join();
        break;
      case "prefix_match_map":
        Matcher_MatcherTree_MatchMap.encode(message.tree_type.prefix_match_map, writer.uint32(26).fork()).join();
        break;
      case "custom_match":
        TypedExtensionConfig.encode(message.tree_type.custom_match, writer.uint32(34).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Matcher_MatcherTree {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatcher_MatcherTree();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.input = TypedExtensionConfig.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tree_type = {
            $case: "exact_match_map",
            exact_match_map: Matcher_MatcherTree_MatchMap.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tree_type = {
            $case: "prefix_match_map",
            prefix_match_map: Matcher_MatcherTree_MatchMap.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tree_type = {
            $case: "custom_match",
            custom_match: TypedExtensionConfig.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Matcher_MatcherTree {
    return {
      $type: Matcher_MatcherTree.$type,
      input: isSet(object.input) ? TypedExtensionConfig.fromJSON(object.input) : undefined,
      tree_type: isSet(object.exact_match_map)
        ? { $case: "exact_match_map", exact_match_map: Matcher_MatcherTree_MatchMap.fromJSON(object.exact_match_map) }
        : isSet(object.prefix_match_map)
        ? {
          $case: "prefix_match_map",
          prefix_match_map: Matcher_MatcherTree_MatchMap.fromJSON(object.prefix_match_map),
        }
        : isSet(object.custom_match)
        ? { $case: "custom_match", custom_match: TypedExtensionConfig.fromJSON(object.custom_match) }
        : undefined,
    };
  },

  toJSON(message: Matcher_MatcherTree): unknown {
    const obj: any = {};
    if (message.input !== undefined) {
      obj.input = TypedExtensionConfig.toJSON(message.input);
    }
    if (message.tree_type?.$case === "exact_match_map") {
      obj.exact_match_map = Matcher_MatcherTree_MatchMap.toJSON(message.tree_type.exact_match_map);
    }
    if (message.tree_type?.$case === "prefix_match_map") {
      obj.prefix_match_map = Matcher_MatcherTree_MatchMap.toJSON(message.tree_type.prefix_match_map);
    }
    if (message.tree_type?.$case === "custom_match") {
      obj.custom_match = TypedExtensionConfig.toJSON(message.tree_type.custom_match);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Matcher_MatcherTree>, I>>(base?: I): Matcher_MatcherTree {
    return Matcher_MatcherTree.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Matcher_MatcherTree>, I>>(object: I): Matcher_MatcherTree {
    const message = createBaseMatcher_MatcherTree();
    message.input = (object.input !== undefined && object.input !== null)
      ? TypedExtensionConfig.fromPartial(object.input)
      : undefined;
    if (
      object.tree_type?.$case === "exact_match_map" &&
      object.tree_type?.exact_match_map !== undefined &&
      object.tree_type?.exact_match_map !== null
    ) {
      message.tree_type = {
        $case: "exact_match_map",
        exact_match_map: Matcher_MatcherTree_MatchMap.fromPartial(object.tree_type.exact_match_map),
      };
    }
    if (
      object.tree_type?.$case === "prefix_match_map" &&
      object.tree_type?.prefix_match_map !== undefined &&
      object.tree_type?.prefix_match_map !== null
    ) {
      message.tree_type = {
        $case: "prefix_match_map",
        prefix_match_map: Matcher_MatcherTree_MatchMap.fromPartial(object.tree_type.prefix_match_map),
      };
    }
    if (
      object.tree_type?.$case === "custom_match" &&
      object.tree_type?.custom_match !== undefined &&
      object.tree_type?.custom_match !== null
    ) {
      message.tree_type = {
        $case: "custom_match",
        custom_match: TypedExtensionConfig.fromPartial(object.tree_type.custom_match),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(Matcher_MatcherTree.$type, Matcher_MatcherTree);

function createBaseMatcher_MatcherTree_MatchMap(): Matcher_MatcherTree_MatchMap {
  return { $type: "xds.type.matcher.v3.Matcher.MatcherTree.MatchMap" };
}

export const Matcher_MatcherTree_MatchMap: MessageFns<
  Matcher_MatcherTree_MatchMap,
  "xds.type.matcher.v3.Matcher.MatcherTree.MatchMap"
> = {
  $type: "xds.type.matcher.v3.Matcher.MatcherTree.MatchMap" as const,

  encode(message: Matcher_MatcherTree_MatchMap, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    (message.map || new Map()).forEach((value, key) => {
      Matcher_MatcherTree_MatchMap_MapEntry.encode({
        $type: "xds.type.matcher.v3.Matcher.MatcherTree.MatchMap.MapEntry",
        key: key as any,
        value,
      }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Matcher_MatcherTree_MatchMap {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatcher_MatcherTree_MatchMap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = Matcher_MatcherTree_MatchMap_MapEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            if (message.map === undefined) {
              message.map = new Map();
            }
            message.map!.set(entry1.key, entry1.value);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Matcher_MatcherTree_MatchMap {
    return {
      $type: Matcher_MatcherTree_MatchMap.$type,
      map: isObject(object.map)
        ? Object.entries(object.map).reduce<Map<string, Matcher_OnMatch>>((acc, [key, value]) => {
          acc.set(key, Matcher_OnMatch.fromJSON(value));
          return acc;
        }, new Map())
        : undefined,
    };
  },

  toJSON(message: Matcher_MatcherTree_MatchMap): unknown {
    const obj: any = {};
    if (message.map?.size) {
      obj.map = {};
      message.map.forEach((v, k) => {
        obj.map[k] = Matcher_OnMatch.toJSON(v);
      });
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Matcher_MatcherTree_MatchMap>, I>>(base?: I): Matcher_MatcherTree_MatchMap {
    return Matcher_MatcherTree_MatchMap.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Matcher_MatcherTree_MatchMap>, I>>(object: I): Matcher_MatcherTree_MatchMap {
    const message = createBaseMatcher_MatcherTree_MatchMap();
    message.map = (object.map === undefined || object.map === null) ? undefined : (() => {
      const m = new Map();
      (object.map as Map<string, Matcher_OnMatch> ?? new Map()).forEach((value, key) => {
        if (value !== undefined) {
          m.set(key, Matcher_OnMatch.fromPartial(value));
        }
      });
      return m;
    })();
    return message;
  },
};

messageTypeRegistry.set(Matcher_MatcherTree_MatchMap.$type, Matcher_MatcherTree_MatchMap);

function createBaseMatcher_MatcherTree_MatchMap_MapEntry(): Matcher_MatcherTree_MatchMap_MapEntry {
  return { $type: "xds.type.matcher.v3.Matcher.MatcherTree.MatchMap.MapEntry", key: "" };
}

export const Matcher_MatcherTree_MatchMap_MapEntry: MessageFns<
  Matcher_MatcherTree_MatchMap_MapEntry,
  "xds.type.matcher.v3.Matcher.MatcherTree.MatchMap.MapEntry"
> = {
  $type: "xds.type.matcher.v3.Matcher.MatcherTree.MatchMap.MapEntry" as const,

  encode(message: Matcher_MatcherTree_MatchMap_MapEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Matcher_OnMatch.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Matcher_MatcherTree_MatchMap_MapEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatcher_MatcherTree_MatchMap_MapEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Matcher_OnMatch.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Matcher_MatcherTree_MatchMap_MapEntry {
    return {
      $type: Matcher_MatcherTree_MatchMap_MapEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Matcher_OnMatch.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Matcher_MatcherTree_MatchMap_MapEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Matcher_OnMatch.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Matcher_MatcherTree_MatchMap_MapEntry>, I>>(
    base?: I,
  ): Matcher_MatcherTree_MatchMap_MapEntry {
    return Matcher_MatcherTree_MatchMap_MapEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Matcher_MatcherTree_MatchMap_MapEntry>, I>>(
    object: I,
  ): Matcher_MatcherTree_MatchMap_MapEntry {
    const message = createBaseMatcher_MatcherTree_MatchMap_MapEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Matcher_OnMatch.fromPartial(object.value)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Matcher_MatcherTree_MatchMap_MapEntry.$type, Matcher_MatcherTree_MatchMap_MapEntry);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
