// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/admin/v3/config_dump.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Any } from "../../../google/protobuf/any";
import { Timestamp } from "../../../google/protobuf/timestamp";
import { messageTypeRegistry } from "../../../typeRegistry";
import { Bootstrap } from "../../config/bootstrap/v3/bootstrap";
import {
  ClientResourceStatus,
  clientResourceStatusFromJSON,
  clientResourceStatusToJSON,
  clientResourceStatusToNumber,
  UpdateFailureState,
} from "./config_dump_shared";

export const protobufPackage = "envoy.admin.v3";

/**
 * The :ref:`/config_dump <operations_admin_interface_config_dump>` admin endpoint uses this wrapper
 * message to maintain and serve arbitrary configuration information from any component in Envoy.
 */
export interface ConfigDump {
  $type: "envoy.admin.v3.ConfigDump";
  /**
   * This list is serialized and dumped in its entirety at the
   * :ref:`/config_dump <operations_admin_interface_config_dump>` endpoint.
   *
   * The following configurations are currently supported and will be dumped in the order given
   * below:
   *
   * * ``bootstrap``: :ref:`BootstrapConfigDump <envoy_v3_api_msg_admin.v3.BootstrapConfigDump>`
   * * ``clusters``: :ref:`ClustersConfigDump <envoy_v3_api_msg_admin.v3.ClustersConfigDump>`
   * * ``ecds_filter_http``: :ref:`EcdsConfigDump <envoy_v3_api_msg_admin.v3.EcdsConfigDump>`
   * * ``ecds_filter_quic_listener``: :ref:`EcdsConfigDump <envoy_v3_api_msg_admin.v3.EcdsConfigDump>`
   * * ``ecds_filter_tcp_listener``: :ref:`EcdsConfigDump <envoy_v3_api_msg_admin.v3.EcdsConfigDump>`
   * * ``endpoints``:  :ref:`EndpointsConfigDump <envoy_v3_api_msg_admin.v3.EndpointsConfigDump>`
   * * ``listeners``: :ref:`ListenersConfigDump <envoy_v3_api_msg_admin.v3.ListenersConfigDump>`
   * * ``scoped_routes``: :ref:`ScopedRoutesConfigDump <envoy_v3_api_msg_admin.v3.ScopedRoutesConfigDump>`
   * * ``routes``:  :ref:`RoutesConfigDump <envoy_v3_api_msg_admin.v3.RoutesConfigDump>`
   * * ``secrets``:  :ref:`SecretsConfigDump <envoy_v3_api_msg_admin.v3.SecretsConfigDump>`
   *
   * EDS Configuration will only be dumped by using parameter ``?include_eds``
   *
   * Currently ECDS is supported in HTTP and listener filters. Note, ECDS configuration for
   * either HTTP or listener filter will only be dumped if it is actually configured.
   *
   * You can filter output with the resource and mask query parameters.
   * See :ref:`/config_dump?resource={} <operations_admin_interface_config_dump_by_resource>`,
   * :ref:`/config_dump?mask={} <operations_admin_interface_config_dump_by_mask>`,
   * or :ref:`/config_dump?resource={},mask={}
   * <operations_admin_interface_config_dump_by_resource_and_mask>` for more information.
   */
  configs?: Any[] | undefined;
}

/**
 * This message describes the bootstrap configuration that Envoy was started with. This includes
 * any CLI overrides that were merged. Bootstrap configuration information can be used to recreate
 * the static portions of an Envoy configuration by reusing the output as the bootstrap
 * configuration for another Envoy.
 */
export interface BootstrapConfigDump {
  $type: "envoy.admin.v3.BootstrapConfigDump";
  bootstrap?:
    | Bootstrap
    | undefined;
  /** The timestamp when the BootstrapConfig was last updated. */
  last_updated?: Date | undefined;
}

/** Envoys SDS implementation fills this message with all secrets fetched dynamically via SDS. */
export interface SecretsConfigDump {
  $type: "envoy.admin.v3.SecretsConfigDump";
  /** The statically loaded secrets. */
  static_secrets?:
    | SecretsConfigDump_StaticSecret[]
    | undefined;
  /**
   * The dynamically loaded active secrets. These are secrets that are available to service
   * clusters or listeners.
   */
  dynamic_active_secrets?:
    | SecretsConfigDump_DynamicSecret[]
    | undefined;
  /**
   * The dynamically loaded warming secrets. These are secrets that are currently undergoing
   * warming in preparation to service clusters or listeners.
   */
  dynamic_warming_secrets?: SecretsConfigDump_DynamicSecret[] | undefined;
}

/**
 * DynamicSecret contains secret information fetched via SDS.
 * [#next-free-field: 7]
 */
export interface SecretsConfigDump_DynamicSecret {
  $type: "envoy.admin.v3.SecretsConfigDump.DynamicSecret";
  /** The name assigned to the secret. */
  name?:
    | string
    | undefined;
  /** This is the per-resource version information. */
  version_info?:
    | string
    | undefined;
  /** The timestamp when the secret was last updated. */
  last_updated?:
    | Date
    | undefined;
  /**
   * The actual secret information.
   * Security sensitive information is redacted (replaced with "[redacted]") for
   * private keys and passwords in TLS certificates.
   */
  secret?:
    | Any
    | undefined;
  /**
   * Set if the last update failed, cleared after the next successful update.
   * The *error_state* field contains the rejected version of this particular
   * resource along with the reason and timestamp. For successfully updated or
   * acknowledged resource, this field should be empty.
   * [#not-implemented-hide:]
   */
  error_state?:
    | UpdateFailureState
    | undefined;
  /**
   * The client status of this resource.
   * [#not-implemented-hide:]
   */
  client_status?: ClientResourceStatus | undefined;
}

/** StaticSecret specifies statically loaded secret in bootstrap. */
export interface SecretsConfigDump_StaticSecret {
  $type: "envoy.admin.v3.SecretsConfigDump.StaticSecret";
  /** The name assigned to the secret. */
  name?:
    | string
    | undefined;
  /** The timestamp when the secret was last updated. */
  last_updated?:
    | Date
    | undefined;
  /**
   * The actual secret information.
   * Security sensitive information is redacted (replaced with "[redacted]") for
   * private keys and passwords in TLS certificates.
   */
  secret?: Any | undefined;
}

function createBaseConfigDump(): ConfigDump {
  return { $type: "envoy.admin.v3.ConfigDump" };
}

export const ConfigDump: MessageFns<ConfigDump, "envoy.admin.v3.ConfigDump"> = {
  $type: "envoy.admin.v3.ConfigDump" as const,

  encode(message: ConfigDump, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.configs !== undefined && message.configs.length !== 0) {
      for (const v of message.configs) {
        Any.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConfigDump {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfigDump();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.configs === undefined) {
            message.configs = [];
          }
          const el = Any.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.configs!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfigDump {
    return {
      $type: ConfigDump.$type,
      configs: globalThis.Array.isArray(object?.configs) ? object.configs.map((e: any) => Any.fromJSON(e)) : undefined,
    };
  },

  toJSON(message: ConfigDump): unknown {
    const obj: any = {};
    if (message.configs?.length) {
      obj.configs = message.configs.map((e) => Any.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConfigDump>, I>>(base?: I): ConfigDump {
    return ConfigDump.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConfigDump>, I>>(object: I): ConfigDump {
    const message = createBaseConfigDump();
    message.configs = object.configs?.map((e) => Any.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(ConfigDump.$type, ConfigDump);

function createBaseBootstrapConfigDump(): BootstrapConfigDump {
  return { $type: "envoy.admin.v3.BootstrapConfigDump" };
}

export const BootstrapConfigDump: MessageFns<BootstrapConfigDump, "envoy.admin.v3.BootstrapConfigDump"> = {
  $type: "envoy.admin.v3.BootstrapConfigDump" as const,

  encode(message: BootstrapConfigDump, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bootstrap !== undefined) {
      Bootstrap.encode(message.bootstrap, writer.uint32(10).fork()).join();
    }
    if (message.last_updated !== undefined) {
      Timestamp.encode(toTimestamp(message.last_updated), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BootstrapConfigDump {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBootstrapConfigDump();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bootstrap = Bootstrap.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.last_updated = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BootstrapConfigDump {
    return {
      $type: BootstrapConfigDump.$type,
      bootstrap: isSet(object.bootstrap) ? Bootstrap.fromJSON(object.bootstrap) : undefined,
      last_updated: isSet(object.last_updated) ? fromJsonTimestamp(object.last_updated) : undefined,
    };
  },

  toJSON(message: BootstrapConfigDump): unknown {
    const obj: any = {};
    if (message.bootstrap !== undefined) {
      obj.bootstrap = Bootstrap.toJSON(message.bootstrap);
    }
    if (message.last_updated !== undefined) {
      obj.last_updated = message.last_updated.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BootstrapConfigDump>, I>>(base?: I): BootstrapConfigDump {
    return BootstrapConfigDump.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BootstrapConfigDump>, I>>(object: I): BootstrapConfigDump {
    const message = createBaseBootstrapConfigDump();
    message.bootstrap = (object.bootstrap !== undefined && object.bootstrap !== null)
      ? Bootstrap.fromPartial(object.bootstrap)
      : undefined;
    message.last_updated = object.last_updated ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(BootstrapConfigDump.$type, BootstrapConfigDump);

function createBaseSecretsConfigDump(): SecretsConfigDump {
  return { $type: "envoy.admin.v3.SecretsConfigDump" };
}

export const SecretsConfigDump: MessageFns<SecretsConfigDump, "envoy.admin.v3.SecretsConfigDump"> = {
  $type: "envoy.admin.v3.SecretsConfigDump" as const,

  encode(message: SecretsConfigDump, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.static_secrets !== undefined && message.static_secrets.length !== 0) {
      for (const v of message.static_secrets) {
        SecretsConfigDump_StaticSecret.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    if (message.dynamic_active_secrets !== undefined && message.dynamic_active_secrets.length !== 0) {
      for (const v of message.dynamic_active_secrets) {
        SecretsConfigDump_DynamicSecret.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.dynamic_warming_secrets !== undefined && message.dynamic_warming_secrets.length !== 0) {
      for (const v of message.dynamic_warming_secrets) {
        SecretsConfigDump_DynamicSecret.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SecretsConfigDump {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecretsConfigDump();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.static_secrets === undefined) {
            message.static_secrets = [];
          }
          const el = SecretsConfigDump_StaticSecret.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.static_secrets!.push(el);
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.dynamic_active_secrets === undefined) {
            message.dynamic_active_secrets = [];
          }
          const el = SecretsConfigDump_DynamicSecret.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.dynamic_active_secrets!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.dynamic_warming_secrets === undefined) {
            message.dynamic_warming_secrets = [];
          }
          const el = SecretsConfigDump_DynamicSecret.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.dynamic_warming_secrets!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SecretsConfigDump {
    return {
      $type: SecretsConfigDump.$type,
      static_secrets: globalThis.Array.isArray(object?.static_secrets)
        ? object.static_secrets.map((e: any) => SecretsConfigDump_StaticSecret.fromJSON(e))
        : undefined,
      dynamic_active_secrets: globalThis.Array.isArray(object?.dynamic_active_secrets)
        ? object.dynamic_active_secrets.map((e: any) => SecretsConfigDump_DynamicSecret.fromJSON(e))
        : undefined,
      dynamic_warming_secrets: globalThis.Array.isArray(object?.dynamic_warming_secrets)
        ? object.dynamic_warming_secrets.map((e: any) => SecretsConfigDump_DynamicSecret.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: SecretsConfigDump): unknown {
    const obj: any = {};
    if (message.static_secrets?.length) {
      obj.static_secrets = message.static_secrets.map((e) => SecretsConfigDump_StaticSecret.toJSON(e));
    }
    if (message.dynamic_active_secrets?.length) {
      obj.dynamic_active_secrets = message.dynamic_active_secrets.map((e) => SecretsConfigDump_DynamicSecret.toJSON(e));
    }
    if (message.dynamic_warming_secrets?.length) {
      obj.dynamic_warming_secrets = message.dynamic_warming_secrets.map((e) =>
        SecretsConfigDump_DynamicSecret.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SecretsConfigDump>, I>>(base?: I): SecretsConfigDump {
    return SecretsConfigDump.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SecretsConfigDump>, I>>(object: I): SecretsConfigDump {
    const message = createBaseSecretsConfigDump();
    message.static_secrets = object.static_secrets?.map((e) => SecretsConfigDump_StaticSecret.fromPartial(e)) ||
      undefined;
    message.dynamic_active_secrets =
      object.dynamic_active_secrets?.map((e) => SecretsConfigDump_DynamicSecret.fromPartial(e)) || undefined;
    message.dynamic_warming_secrets =
      object.dynamic_warming_secrets?.map((e) => SecretsConfigDump_DynamicSecret.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(SecretsConfigDump.$type, SecretsConfigDump);

function createBaseSecretsConfigDump_DynamicSecret(): SecretsConfigDump_DynamicSecret {
  return { $type: "envoy.admin.v3.SecretsConfigDump.DynamicSecret" };
}

export const SecretsConfigDump_DynamicSecret: MessageFns<
  SecretsConfigDump_DynamicSecret,
  "envoy.admin.v3.SecretsConfigDump.DynamicSecret"
> = {
  $type: "envoy.admin.v3.SecretsConfigDump.DynamicSecret" as const,

  encode(message: SecretsConfigDump_DynamicSecret, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version_info !== undefined && message.version_info !== "") {
      writer.uint32(18).string(message.version_info);
    }
    if (message.last_updated !== undefined) {
      Timestamp.encode(toTimestamp(message.last_updated), writer.uint32(26).fork()).join();
    }
    if (message.secret !== undefined) {
      Any.encode(message.secret, writer.uint32(34).fork()).join();
    }
    if (message.error_state !== undefined) {
      UpdateFailureState.encode(message.error_state, writer.uint32(42).fork()).join();
    }
    if (message.client_status !== undefined && message.client_status !== ClientResourceStatus.UNKNOWN) {
      writer.uint32(48).int32(clientResourceStatusToNumber(message.client_status));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SecretsConfigDump_DynamicSecret {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecretsConfigDump_DynamicSecret();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.version_info = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.last_updated = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.secret = Any.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.error_state = UpdateFailureState.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.client_status = clientResourceStatusFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SecretsConfigDump_DynamicSecret {
    return {
      $type: SecretsConfigDump_DynamicSecret.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      version_info: isSet(object.version_info) ? globalThis.String(object.version_info) : undefined,
      last_updated: isSet(object.last_updated) ? fromJsonTimestamp(object.last_updated) : undefined,
      secret: isSet(object.secret) ? Any.fromJSON(object.secret) : undefined,
      error_state: isSet(object.error_state) ? UpdateFailureState.fromJSON(object.error_state) : undefined,
      client_status: isSet(object.client_status) ? clientResourceStatusFromJSON(object.client_status) : undefined,
    };
  },

  toJSON(message: SecretsConfigDump_DynamicSecret): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.version_info !== undefined) {
      obj.version_info = message.version_info;
    }
    if (message.last_updated !== undefined) {
      obj.last_updated = message.last_updated.toISOString();
    }
    if (message.secret !== undefined) {
      obj.secret = Any.toJSON(message.secret);
    }
    if (message.error_state !== undefined) {
      obj.error_state = UpdateFailureState.toJSON(message.error_state);
    }
    if (message.client_status !== undefined) {
      obj.client_status = clientResourceStatusToJSON(message.client_status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SecretsConfigDump_DynamicSecret>, I>>(base?: I): SecretsConfigDump_DynamicSecret {
    return SecretsConfigDump_DynamicSecret.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SecretsConfigDump_DynamicSecret>, I>>(
    object: I,
  ): SecretsConfigDump_DynamicSecret {
    const message = createBaseSecretsConfigDump_DynamicSecret();
    message.name = object.name ?? undefined;
    message.version_info = object.version_info ?? undefined;
    message.last_updated = object.last_updated ?? undefined;
    message.secret = (object.secret !== undefined && object.secret !== null)
      ? Any.fromPartial(object.secret)
      : undefined;
    message.error_state = (object.error_state !== undefined && object.error_state !== null)
      ? UpdateFailureState.fromPartial(object.error_state)
      : undefined;
    message.client_status = object.client_status ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(SecretsConfigDump_DynamicSecret.$type, SecretsConfigDump_DynamicSecret);

function createBaseSecretsConfigDump_StaticSecret(): SecretsConfigDump_StaticSecret {
  return { $type: "envoy.admin.v3.SecretsConfigDump.StaticSecret" };
}

export const SecretsConfigDump_StaticSecret: MessageFns<
  SecretsConfigDump_StaticSecret,
  "envoy.admin.v3.SecretsConfigDump.StaticSecret"
> = {
  $type: "envoy.admin.v3.SecretsConfigDump.StaticSecret" as const,

  encode(message: SecretsConfigDump_StaticSecret, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.last_updated !== undefined) {
      Timestamp.encode(toTimestamp(message.last_updated), writer.uint32(18).fork()).join();
    }
    if (message.secret !== undefined) {
      Any.encode(message.secret, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SecretsConfigDump_StaticSecret {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecretsConfigDump_StaticSecret();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.last_updated = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.secret = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SecretsConfigDump_StaticSecret {
    return {
      $type: SecretsConfigDump_StaticSecret.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      last_updated: isSet(object.last_updated) ? fromJsonTimestamp(object.last_updated) : undefined,
      secret: isSet(object.secret) ? Any.fromJSON(object.secret) : undefined,
    };
  },

  toJSON(message: SecretsConfigDump_StaticSecret): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.last_updated !== undefined) {
      obj.last_updated = message.last_updated.toISOString();
    }
    if (message.secret !== undefined) {
      obj.secret = Any.toJSON(message.secret);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SecretsConfigDump_StaticSecret>, I>>(base?: I): SecretsConfigDump_StaticSecret {
    return SecretsConfigDump_StaticSecret.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SecretsConfigDump_StaticSecret>, I>>(
    object: I,
  ): SecretsConfigDump_StaticSecret {
    const message = createBaseSecretsConfigDump_StaticSecret();
    message.name = object.name ?? undefined;
    message.last_updated = object.last_updated ?? undefined;
    message.secret = (object.secret !== undefined && object.secret !== null)
      ? Any.fromPartial(object.secret)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(SecretsConfigDump_StaticSecret.$type, SecretsConfigDump_StaticSecret);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { $type: "google.protobuf.Timestamp", seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
