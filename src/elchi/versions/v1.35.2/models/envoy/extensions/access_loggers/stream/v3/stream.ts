// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/access_loggers/stream/v3/stream.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { messageTypeRegistry } from "../../../../../typeRegistry";
import { SubstitutionFormatString } from "../../../../config/core/v3/substitution_format_string";

export const protobufPackage = "envoy.extensions.access_loggers.stream.v3";

/**
 * Custom configuration for an :ref:`AccessLog <envoy_v3_api_msg_config.accesslog.v3.AccessLog>`
 * that writes log entries directly to the operating system's standard output.
 * [#extension: envoy.access_loggers.stdout]
 */
export interface StdoutAccessLog {
  $type: "envoy.extensions.access_loggers.stream.v3.StdoutAccessLog";
  access_log_format?:
    | //
    /**
     * Configuration to form access log data and format.
     * If not specified, use :ref:`default format <config_access_log_default_format>`.
     */
    { $case: "log_format"; log_format: SubstitutionFormatString }
    | undefined;
}

/**
 * Custom configuration for an :ref:`AccessLog <envoy_v3_api_msg_config.accesslog.v3.AccessLog>`
 * that writes log entries directly to the operating system's standard error.
 * [#extension: envoy.access_loggers.stderr]
 */
export interface StderrAccessLog {
  $type: "envoy.extensions.access_loggers.stream.v3.StderrAccessLog";
  access_log_format?:
    | //
    /**
     * Configuration to form access log data and format.
     * If not specified, use :ref:`default format <config_access_log_default_format>`.
     */
    { $case: "log_format"; log_format: SubstitutionFormatString }
    | undefined;
}

function createBaseStdoutAccessLog(): StdoutAccessLog {
  return { $type: "envoy.extensions.access_loggers.stream.v3.StdoutAccessLog", access_log_format: undefined };
}

export const StdoutAccessLog: MessageFns<StdoutAccessLog, "envoy.extensions.access_loggers.stream.v3.StdoutAccessLog"> =
  {
    $type: "envoy.extensions.access_loggers.stream.v3.StdoutAccessLog" as const,

    encode(message: StdoutAccessLog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
      switch (message.access_log_format?.$case) {
        case "log_format":
          SubstitutionFormatString.encode(message.access_log_format.log_format, writer.uint32(10).fork()).join();
          break;
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): StdoutAccessLog {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseStdoutAccessLog();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.access_log_format = {
              $case: "log_format",
              log_format: SubstitutionFormatString.decode(reader, reader.uint32()),
            };
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): StdoutAccessLog {
      return {
        $type: StdoutAccessLog.$type,
        access_log_format: isSet(object.log_format)
          ? { $case: "log_format", log_format: SubstitutionFormatString.fromJSON(object.log_format) }
          : undefined,
      };
    },

    toJSON(message: StdoutAccessLog): unknown {
      const obj: any = {};
      if (message.access_log_format?.$case === "log_format") {
        obj.log_format = SubstitutionFormatString.toJSON(message.access_log_format.log_format);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<StdoutAccessLog>, I>>(base?: I): StdoutAccessLog {
      return StdoutAccessLog.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<StdoutAccessLog>, I>>(object: I): StdoutAccessLog {
      const message = createBaseStdoutAccessLog();
      if (
        object.access_log_format?.$case === "log_format" &&
        object.access_log_format?.log_format !== undefined &&
        object.access_log_format?.log_format !== null
      ) {
        message.access_log_format = {
          $case: "log_format",
          log_format: SubstitutionFormatString.fromPartial(object.access_log_format.log_format),
        };
      }
      return message;
    },
  };

messageTypeRegistry.set(StdoutAccessLog.$type, StdoutAccessLog);

function createBaseStderrAccessLog(): StderrAccessLog {
  return { $type: "envoy.extensions.access_loggers.stream.v3.StderrAccessLog", access_log_format: undefined };
}

export const StderrAccessLog: MessageFns<StderrAccessLog, "envoy.extensions.access_loggers.stream.v3.StderrAccessLog"> =
  {
    $type: "envoy.extensions.access_loggers.stream.v3.StderrAccessLog" as const,

    encode(message: StderrAccessLog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
      switch (message.access_log_format?.$case) {
        case "log_format":
          SubstitutionFormatString.encode(message.access_log_format.log_format, writer.uint32(10).fork()).join();
          break;
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): StderrAccessLog {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseStderrAccessLog();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.access_log_format = {
              $case: "log_format",
              log_format: SubstitutionFormatString.decode(reader, reader.uint32()),
            };
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): StderrAccessLog {
      return {
        $type: StderrAccessLog.$type,
        access_log_format: isSet(object.log_format)
          ? { $case: "log_format", log_format: SubstitutionFormatString.fromJSON(object.log_format) }
          : undefined,
      };
    },

    toJSON(message: StderrAccessLog): unknown {
      const obj: any = {};
      if (message.access_log_format?.$case === "log_format") {
        obj.log_format = SubstitutionFormatString.toJSON(message.access_log_format.log_format);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<StderrAccessLog>, I>>(base?: I): StderrAccessLog {
      return StderrAccessLog.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<StderrAccessLog>, I>>(object: I): StderrAccessLog {
      const message = createBaseStderrAccessLog();
      if (
        object.access_log_format?.$case === "log_format" &&
        object.access_log_format?.log_format !== undefined &&
        object.access_log_format?.log_format !== null
      ) {
        message.access_log_format = {
          $case: "log_format",
          log_format: SubstitutionFormatString.fromPartial(object.access_log_format.log_format),
        };
      }
      return message;
    },
  };

messageTypeRegistry.set(StderrAccessLog.$type, StderrAccessLog);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
