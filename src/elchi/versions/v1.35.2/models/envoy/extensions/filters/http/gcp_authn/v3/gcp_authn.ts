// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/filters/http/gcp_authn/v3/gcp_authn.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../../../../google/protobuf/duration";
import { UInt64Value } from "../../../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../../../typeRegistry";
import { RetryPolicy } from "../../../../../config/core/v3/base";
import { HttpUri } from "../../../../../config/core/v3/http_uri";

export const protobufPackage = "envoy.extensions.filters.http.gcp_authn.v3";

/**
 * Filter configuration.
 * [#next-free-field: 7]
 */
export interface GcpAuthnFilterConfig {
  $type: "envoy.extensions.filters.http.gcp_authn.v3.GcpAuthnFilterConfig";
  /**
   * The HTTP URI to fetch tokens from GCE Metadata Server(https://cloud.google.com/compute/docs/metadata/overview).
   * The URL format is "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/identity?audience=[AUDIENCE]"
   *
   * This field is deprecated because it does not match the API surface provided by the google auth libraries.
   * Control planes should not attempt to override the metadata server URI.
   * The cluster and timeout can be configured using the ``cluster`` and ``timeout`` fields instead.
   * For backward compatibility, the cluster and timeout configured in this field will be used
   * if the new ``cluster`` and ``timeout`` fields are not set.
   *
   * @deprecated
   */
  http_uri?:
    | HttpUri
    | undefined;
  /**
   * Retry policy for fetching tokens.
   * Not supported by all data planes.
   */
  retry_policy?:
    | RetryPolicy
    | undefined;
  /** Token cache configuration. This field is optional. */
  cache_config?:
    | TokenCacheConfig
    | undefined;
  /**
   * Request header location to extract the token. By default (i.e. if this field is not specified), the token
   * is extracted to the Authorization HTTP header, in the format "Authorization: Bearer <token>".
   * Not supported by all data planes.
   */
  token_header?:
    | TokenHeader
    | undefined;
  /**
   * Cluster to send traffic to the GCE metadata server. Not supported
   * by all data planes; a data plane may instead have its own mechanism
   * for contacting the metadata server.
   */
  cluster?:
    | string
    | undefined;
  /**
   * Timeout for fetching the tokens from the GCE metadata server.
   * Not supported by all data planes.
   */
  timeout?: Duration | undefined;
}

/**
 * Audience is the URL of the receiving service that performs token authentication.
 * It will be provided to the filter through cluster's typed_filter_metadata.
 */
export interface Audience {
  $type: "envoy.extensions.filters.http.gcp_authn.v3.Audience";
  url?: string | undefined;
}

/** Token Cache configuration. */
export interface TokenCacheConfig {
  $type: "envoy.extensions.filters.http.gcp_authn.v3.TokenCacheConfig";
  /**
   * The number of cache entries. The maximum number of entries is INT64_MAX as it is constrained by underlying cache implementation.
   * Default value 0 (i.e., proto3 defaults) disables the cache by default. Other default values will enable the cache.
   */
  cache_size?: number | undefined;
}

export interface TokenHeader {
  $type: "envoy.extensions.filters.http.gcp_authn.v3.TokenHeader";
  /** The HTTP header's name. */
  name?:
    | string
    | undefined;
  /**
   * The header's prefix. The format is "value_prefix<token>"
   * For example, for "Authorization: Bearer <token>", value_prefix="Bearer " with a space at the
   * end.
   */
  value_prefix?: string | undefined;
}

function createBaseGcpAuthnFilterConfig(): GcpAuthnFilterConfig {
  return { $type: "envoy.extensions.filters.http.gcp_authn.v3.GcpAuthnFilterConfig" };
}

export const GcpAuthnFilterConfig: MessageFns<
  GcpAuthnFilterConfig,
  "envoy.extensions.filters.http.gcp_authn.v3.GcpAuthnFilterConfig"
> = {
  $type: "envoy.extensions.filters.http.gcp_authn.v3.GcpAuthnFilterConfig" as const,

  encode(message: GcpAuthnFilterConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.http_uri !== undefined) {
      HttpUri.encode(message.http_uri, writer.uint32(10).fork()).join();
    }
    if (message.retry_policy !== undefined) {
      RetryPolicy.encode(message.retry_policy, writer.uint32(18).fork()).join();
    }
    if (message.cache_config !== undefined) {
      TokenCacheConfig.encode(message.cache_config, writer.uint32(26).fork()).join();
    }
    if (message.token_header !== undefined) {
      TokenHeader.encode(message.token_header, writer.uint32(34).fork()).join();
    }
    if (message.cluster !== undefined && message.cluster !== "") {
      writer.uint32(42).string(message.cluster);
    }
    if (message.timeout !== undefined) {
      Duration.encode(message.timeout, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GcpAuthnFilterConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGcpAuthnFilterConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.http_uri = HttpUri.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.retry_policy = RetryPolicy.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.cache_config = TokenCacheConfig.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.token_header = TokenHeader.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.cluster = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GcpAuthnFilterConfig {
    return {
      $type: GcpAuthnFilterConfig.$type,
      http_uri: isSet(object.http_uri) ? HttpUri.fromJSON(object.http_uri) : undefined,
      retry_policy: isSet(object.retry_policy) ? RetryPolicy.fromJSON(object.retry_policy) : undefined,
      cache_config: isSet(object.cache_config) ? TokenCacheConfig.fromJSON(object.cache_config) : undefined,
      token_header: isSet(object.token_header) ? TokenHeader.fromJSON(object.token_header) : undefined,
      cluster: isSet(object.cluster) ? globalThis.String(object.cluster) : undefined,
      timeout: isSet(object.timeout) ? Duration.fromJSON(object.timeout) : undefined,
    };
  },

  toJSON(message: GcpAuthnFilterConfig): unknown {
    const obj: any = {};
    if (message.http_uri !== undefined) {
      obj.http_uri = HttpUri.toJSON(message.http_uri);
    }
    if (message.retry_policy !== undefined) {
      obj.retry_policy = RetryPolicy.toJSON(message.retry_policy);
    }
    if (message.cache_config !== undefined) {
      obj.cache_config = TokenCacheConfig.toJSON(message.cache_config);
    }
    if (message.token_header !== undefined) {
      obj.token_header = TokenHeader.toJSON(message.token_header);
    }
    if (message.cluster !== undefined) {
      obj.cluster = message.cluster;
    }
    if (message.timeout !== undefined) {
      obj.timeout = Duration.toJSON(message.timeout);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GcpAuthnFilterConfig>, I>>(base?: I): GcpAuthnFilterConfig {
    return GcpAuthnFilterConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GcpAuthnFilterConfig>, I>>(object: I): GcpAuthnFilterConfig {
    const message = createBaseGcpAuthnFilterConfig();
    message.http_uri = (object.http_uri !== undefined && object.http_uri !== null)
      ? HttpUri.fromPartial(object.http_uri)
      : undefined;
    message.retry_policy = (object.retry_policy !== undefined && object.retry_policy !== null)
      ? RetryPolicy.fromPartial(object.retry_policy)
      : undefined;
    message.cache_config = (object.cache_config !== undefined && object.cache_config !== null)
      ? TokenCacheConfig.fromPartial(object.cache_config)
      : undefined;
    message.token_header = (object.token_header !== undefined && object.token_header !== null)
      ? TokenHeader.fromPartial(object.token_header)
      : undefined;
    message.cluster = object.cluster ?? undefined;
    message.timeout = (object.timeout !== undefined && object.timeout !== null)
      ? Duration.fromPartial(object.timeout)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(GcpAuthnFilterConfig.$type, GcpAuthnFilterConfig);

function createBaseAudience(): Audience {
  return { $type: "envoy.extensions.filters.http.gcp_authn.v3.Audience" };
}

export const Audience: MessageFns<Audience, "envoy.extensions.filters.http.gcp_authn.v3.Audience"> = {
  $type: "envoy.extensions.filters.http.gcp_authn.v3.Audience" as const,

  encode(message: Audience, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== undefined && message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Audience {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudience();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Audience {
    return { $type: Audience.$type, url: isSet(object.url) ? globalThis.String(object.url) : undefined };
  },

  toJSON(message: Audience): unknown {
    const obj: any = {};
    if (message.url !== undefined) {
      obj.url = message.url;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Audience>, I>>(base?: I): Audience {
    return Audience.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Audience>, I>>(object: I): Audience {
    const message = createBaseAudience();
    message.url = object.url ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Audience.$type, Audience);

function createBaseTokenCacheConfig(): TokenCacheConfig {
  return { $type: "envoy.extensions.filters.http.gcp_authn.v3.TokenCacheConfig" };
}

export const TokenCacheConfig: MessageFns<
  TokenCacheConfig,
  "envoy.extensions.filters.http.gcp_authn.v3.TokenCacheConfig"
> = {
  $type: "envoy.extensions.filters.http.gcp_authn.v3.TokenCacheConfig" as const,

  encode(message: TokenCacheConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cache_size !== undefined) {
      UInt64Value.encode({ $type: "google.protobuf.UInt64Value", value: message.cache_size! }, writer.uint32(10).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenCacheConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenCacheConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cache_size = UInt64Value.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenCacheConfig {
    return {
      $type: TokenCacheConfig.$type,
      cache_size: isSet(object.cache_size) ? Number(object.cache_size) : undefined,
    };
  },

  toJSON(message: TokenCacheConfig): unknown {
    const obj: any = {};
    if (message.cache_size !== undefined) {
      obj.cache_size = message.cache_size;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenCacheConfig>, I>>(base?: I): TokenCacheConfig {
    return TokenCacheConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenCacheConfig>, I>>(object: I): TokenCacheConfig {
    const message = createBaseTokenCacheConfig();
    message.cache_size = object.cache_size ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(TokenCacheConfig.$type, TokenCacheConfig);

function createBaseTokenHeader(): TokenHeader {
  return { $type: "envoy.extensions.filters.http.gcp_authn.v3.TokenHeader" };
}

export const TokenHeader: MessageFns<TokenHeader, "envoy.extensions.filters.http.gcp_authn.v3.TokenHeader"> = {
  $type: "envoy.extensions.filters.http.gcp_authn.v3.TokenHeader" as const,

  encode(message: TokenHeader, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value_prefix !== undefined && message.value_prefix !== "") {
      writer.uint32(18).string(message.value_prefix);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenHeader {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value_prefix = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenHeader {
    return {
      $type: TokenHeader.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      value_prefix: isSet(object.value_prefix) ? globalThis.String(object.value_prefix) : undefined,
    };
  },

  toJSON(message: TokenHeader): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.value_prefix !== undefined) {
      obj.value_prefix = message.value_prefix;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenHeader>, I>>(base?: I): TokenHeader {
    return TokenHeader.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenHeader>, I>>(object: I): TokenHeader {
    const message = createBaseTokenHeader();
    message.name = object.name ?? undefined;
    message.value_prefix = object.value_prefix ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(TokenHeader.$type, TokenHeader);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
