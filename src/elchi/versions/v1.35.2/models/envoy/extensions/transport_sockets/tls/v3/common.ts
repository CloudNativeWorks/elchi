// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/transport_sockets/tls/v3/common.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Any } from "../../../../../google/protobuf/any";
import { BoolValue, UInt32Value } from "../../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../../typeRegistry";
import { DataSource, WatchedDirectory } from "../../../../config/core/v3/base";
import { TypedExtensionConfig } from "../../../../config/core/v3/extension";
import { StringMatcher } from "../../../../type/matcher/v3/string";

export const protobufPackage = "envoy.extensions.transport_sockets.tls.v3";

/** [#next-free-field: 7] */
export interface TlsParameters {
  $type: "envoy.extensions.transport_sockets.tls.v3.TlsParameters";
  /**
   * Minimum TLS protocol version. By default, it's ``TLSv1_2`` for both clients and servers.
   *
   * TLS protocol versions below TLSv1_2 require setting compatible ciphers with the
   * ``cipher_suites`` setting as the default ciphers no longer include compatible ciphers.
   *
   * .. attention::
   *
   *   Using TLS protocol versions below TLSv1_2 has serious security considerations and risks.
   */
  tls_minimum_protocol_version?:
    | TlsParameters_TlsProtocol
    | undefined;
  /**
   * Maximum TLS protocol version. By default, it's ``TLSv1_2`` for clients and ``TLSv1_3`` for
   * servers.
   */
  tls_maximum_protocol_version?:
    | TlsParameters_TlsProtocol
    | undefined;
  /**
   * If specified, the TLS listener will only support the specified `cipher list
   * <https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration>`_
   * when negotiating TLS 1.0-1.2 (this setting has no effect when negotiating TLS 1.3).
   *
   * If not specified, a default list will be used. Defaults are different for server (downstream) and
   * client (upstream) TLS configurations.
   * Defaults will change over time in response to security considerations; If you care, configure
   * it instead of using the default.
   *
   * In non-FIPS builds, the default server cipher list is:
   *
   * .. code-block:: none
   *
   *   [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
   *   [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
   *   ECDHE-ECDSA-AES256-GCM-SHA384
   *   ECDHE-RSA-AES256-GCM-SHA384
   *
   * In builds using :ref:`BoringSSL FIPS <arch_overview_ssl_fips>`, the default server cipher list is:
   *
   * .. code-block:: none
   *
   *   ECDHE-ECDSA-AES128-GCM-SHA256
   *   ECDHE-RSA-AES128-GCM-SHA256
   *   ECDHE-ECDSA-AES256-GCM-SHA384
   *   ECDHE-RSA-AES256-GCM-SHA384
   *
   * In non-FIPS builds, the default client cipher list is:
   *
   * .. code-block:: none
   *
   *   [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
   *   [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
   *   ECDHE-ECDSA-AES256-GCM-SHA384
   *   ECDHE-RSA-AES256-GCM-SHA384
   *
   * In builds using :ref:`BoringSSL FIPS <arch_overview_ssl_fips>`, the default client cipher list is:
   *
   * .. code-block:: none
   *
   *   ECDHE-ECDSA-AES128-GCM-SHA256
   *   ECDHE-RSA-AES128-GCM-SHA256
   *   ECDHE-ECDSA-AES256-GCM-SHA384
   *   ECDHE-RSA-AES256-GCM-SHA384
   */
  cipher_suites?:
    | string[]
    | undefined;
  /**
   * If specified, the TLS connection will only support the specified ECDH
   * curves. If not specified, the default curves will be used.
   *
   * In non-FIPS builds, the default curves are:
   *
   * .. code-block:: none
   *
   *   X25519
   *   P-256
   *
   * In builds using :ref:`BoringSSL FIPS <arch_overview_ssl_fips>`, the default curve is:
   *
   * .. code-block:: none
   *
   *   P-256
   */
  ecdh_curves?:
    | string[]
    | undefined;
  /**
   * If specified, the TLS connection will only support the specified signature algorithms.
   * The list is ordered by preference.
   * If not specified, the default signature algorithms defined by BoringSSL will be used.
   *
   * Default signature algorithms selected by BoringSSL (may be out of date):
   *
   * .. code-block:: none
   *
   *   ecdsa_secp256r1_sha256
   *   rsa_pss_rsae_sha256
   *   rsa_pkcs1_sha256
   *   ecdsa_secp384r1_sha384
   *   rsa_pss_rsae_sha384
   *   rsa_pkcs1_sha384
   *   rsa_pss_rsae_sha512
   *   rsa_pkcs1_sha512
   *   rsa_pkcs1_sha1
   *
   * Signature algorithms supported by BoringSSL (may be out of date):
   *
   * .. code-block:: none
   *
   *   rsa_pkcs1_sha256
   *   rsa_pkcs1_sha384
   *   rsa_pkcs1_sha512
   *   ecdsa_secp256r1_sha256
   *   ecdsa_secp384r1_sha384
   *   ecdsa_secp521r1_sha512
   *   rsa_pss_rsae_sha256
   *   rsa_pss_rsae_sha384
   *   rsa_pss_rsae_sha512
   *   ed25519
   *   rsa_pkcs1_sha1
   *   ecdsa_sha1
   */
  signature_algorithms?:
    | string[]
    | undefined;
  /**
   * Compliance policies configure various aspects of the TLS based on the given policy.
   * The policies are applied last during configuration and may override the other TLS
   * parameters, or any previous policy.
   */
  compliance_policies?: TlsParameters_CompliancePolicy[] | undefined;
}

export enum TlsParameters_TlsProtocol {
  /** TLS_AUTO - Envoy will choose the optimal TLS version. */
  TLS_AUTO = "TLS_AUTO",
  /** TLSv1_0 - TLS 1.0 */
  TLSv1_0 = "TLSv1_0",
  /** TLSv1_1 - TLS 1.1 */
  TLSv1_1 = "TLSv1_1",
  /** TLSv1_2 - TLS 1.2 */
  TLSv1_2 = "TLSv1_2",
  /** TLSv1_3 - TLS 1.3 */
  TLSv1_3 = "TLSv1_3",
}

export function tlsParameters_TlsProtocolFromJSON(object: any): TlsParameters_TlsProtocol {
  switch (object) {
    case 0:
    case "TLS_AUTO":
      return TlsParameters_TlsProtocol.TLS_AUTO;
    case 1:
    case "TLSv1_0":
      return TlsParameters_TlsProtocol.TLSv1_0;
    case 2:
    case "TLSv1_1":
      return TlsParameters_TlsProtocol.TLSv1_1;
    case 3:
    case "TLSv1_2":
      return TlsParameters_TlsProtocol.TLSv1_2;
    case 4:
    case "TLSv1_3":
      return TlsParameters_TlsProtocol.TLSv1_3;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum TlsParameters_TlsProtocol");
  }
}

export function tlsParameters_TlsProtocolToJSON(object: TlsParameters_TlsProtocol): string {
  switch (object) {
    case TlsParameters_TlsProtocol.TLS_AUTO:
      return "TLS_AUTO";
    case TlsParameters_TlsProtocol.TLSv1_0:
      return "TLSv1_0";
    case TlsParameters_TlsProtocol.TLSv1_1:
      return "TLSv1_1";
    case TlsParameters_TlsProtocol.TLSv1_2:
      return "TLSv1_2";
    case TlsParameters_TlsProtocol.TLSv1_3:
      return "TLSv1_3";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum TlsParameters_TlsProtocol");
  }
}

export function tlsParameters_TlsProtocolToNumber(object: TlsParameters_TlsProtocol): number {
  switch (object) {
    case TlsParameters_TlsProtocol.TLS_AUTO:
      return 0;
    case TlsParameters_TlsProtocol.TLSv1_0:
      return 1;
    case TlsParameters_TlsProtocol.TLSv1_1:
      return 2;
    case TlsParameters_TlsProtocol.TLSv1_2:
      return 3;
    case TlsParameters_TlsProtocol.TLSv1_3:
      return 4;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum TlsParameters_TlsProtocol");
  }
}

export enum TlsParameters_CompliancePolicy {
  /**
   * FIPS_202205 - FIPS_202205 configures a TLS connection to use:
   *
   *   * TLS 1.2 or 1.3
   *   * For TLS 1.2, only ECDHE_[RSA|ECDSA]_WITH_AES_*_GCM_SHA*.
   *   * For TLS 1.3, only AES-GCM
   *   * P-256 or P-384 for key agreement.
   *   * For server signatures, only ``PKCS#1/PSS`` with ``SHA256/384/512``, or ECDSA
   *     with P-256 or P-384.
   *
   * .. attention::
   *
   *   Please refer to `BoringSSL policies <https://boringssl.googlesource.com/boringssl/+/refs/tags/0.20240913.0/include/openssl/ssl.h#5608>`_
   *   for details.
   */
  FIPS_202205 = "FIPS_202205",
}

export function tlsParameters_CompliancePolicyFromJSON(object: any): TlsParameters_CompliancePolicy {
  switch (object) {
    case 0:
    case "FIPS_202205":
      return TlsParameters_CompliancePolicy.FIPS_202205;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum TlsParameters_CompliancePolicy");
  }
}

export function tlsParameters_CompliancePolicyToJSON(object: TlsParameters_CompliancePolicy): string {
  switch (object) {
    case TlsParameters_CompliancePolicy.FIPS_202205:
      return "FIPS_202205";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum TlsParameters_CompliancePolicy");
  }
}

export function tlsParameters_CompliancePolicyToNumber(object: TlsParameters_CompliancePolicy): number {
  switch (object) {
    case TlsParameters_CompliancePolicy.FIPS_202205:
      return 0;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum TlsParameters_CompliancePolicy");
  }
}

/**
 * BoringSSL private key method configuration. The private key methods are used for external
 * (potentially asynchronous) signing and decryption operations. Some use cases for private key
 * methods would be TPM support and TLS acceleration.
 */
export interface PrivateKeyProvider {
  $type: "envoy.extensions.transport_sockets.tls.v3.PrivateKeyProvider";
  /**
   * Private key method provider name. The name must match a
   * supported private key method provider type.
   */
  provider_name?:
    | string
    | undefined;
  /** Private key method provider specific configuration. */
  config_type?:
    | //
    { $case: "typed_config"; typed_config: Any }
    | undefined;
  /**
   * If the private key provider isn't available (eg. the required hardware capability doesn't existed),
   * Envoy will fallback to the BoringSSL default implementation when the ``fallback`` is true.
   * The default value is ``false``.
   */
  fallback?: boolean | undefined;
}

/** [#next-free-field: 9] */
export interface TlsCertificate {
  $type: "envoy.extensions.transport_sockets.tls.v3.TlsCertificate";
  /**
   * The TLS certificate chain.
   *
   * If ``certificate_chain`` is a filesystem path, a watch will be added to the
   * parent directory for any file moves to support rotation. This currently
   * only applies to dynamic secrets, when the ``TlsCertificate`` is delivered via
   * SDS.
   */
  certificate_chain?:
    | DataSource
    | undefined;
  /**
   * The TLS private key.
   *
   * If ``private_key`` is a filesystem path, a watch will be added to the parent
   * directory for any file moves to support rotation. This currently only
   * applies to dynamic secrets, when the ``TlsCertificate`` is delivered via SDS.
   */
  private_key?:
    | DataSource
    | undefined;
  /**
   * ``Pkcs12`` data containing TLS certificate, chain, and private key.
   *
   * If ``pkcs12`` is a filesystem path, the file will be read, but no watch will
   * be added to the parent directory, since ``pkcs12`` isn't used by SDS.
   * This field is mutually exclusive with ``certificate_chain``, ``private_key`` and ``private_key_provider``.
   * This can't be marked as ``oneof`` due to API compatibility reasons. Setting
   * both :ref:`private_key <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.private_key>`,
   * :ref:`certificate_chain <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.certificate_chain>`,
   * or :ref:`private_key_provider <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.private_key_provider>`
   * and :ref:`pkcs12 <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.pkcs12>`
   * fields will result in an error. Use :ref:`password
   * <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.password>`
   * to specify the password to unprotect the ``PKCS12`` data, if necessary.
   */
  pkcs12?:
    | DataSource
    | undefined;
  /**
   * If specified, updates of file-based ``certificate_chain`` and ``private_key``
   * sources will be triggered by this watch. The certificate/key pair will be
   * read together and validated for atomic read consistency (i.e. no
   * intervening modification occurred between cert/key read, verified by file
   * hash comparisons). This allows explicit control over the path watched, by
   * default the parent directories of the filesystem paths in
   * ``certificate_chain`` and ``private_key`` are watched if this field is not
   * specified. This only applies when a ``TlsCertificate`` is delivered by SDS
   * with references to filesystem paths. See the :ref:`SDS key rotation
   * <sds_key_rotation>` documentation for further details.
   */
  watched_directory?:
    | WatchedDirectory
    | undefined;
  /**
   * BoringSSL private key method provider. This is an alternative to :ref:`private_key
   * <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.private_key>` field.
   * When both :ref:`private_key <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.private_key>` and
   * :ref:`private_key_provider <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.private_key_provider>` fields are set,
   * ``private_key_provider`` takes precedence.
   * If ``private_key_provider`` is unavailable and :ref:`fallback
   * <envoy_v3_api_field_extensions.transport_sockets.tls.v3.PrivateKeyProvider.fallback>`
   * is enabled, ``private_key`` will be used.
   */
  private_key_provider?:
    | PrivateKeyProvider
    | undefined;
  /**
   * The password to decrypt the TLS private key. If this field is not set, it is assumed that the
   * TLS private key is not password encrypted.
   */
  password?:
    | DataSource
    | undefined;
  /**
   * The OCSP response to be stapled with this certificate during the handshake.
   * The response must be DER-encoded and may only be  provided via ``filename`` or
   * ``inline_bytes``. The response may pertain to only one certificate.
   */
  ocsp_staple?:
    | DataSource
    | undefined;
  /** [#not-implemented-hide:] */
  signed_certificate_timestamp?: DataSource[] | undefined;
}

export interface TlsSessionTicketKeys {
  $type: "envoy.extensions.transport_sockets.tls.v3.TlsSessionTicketKeys";
  /**
   * Keys for encrypting and decrypting TLS session tickets. The
   * first key in the array contains the key to encrypt all new sessions created by this context.
   * All keys are candidates for decrypting received tickets. This allows for easy rotation of keys
   * by, for example, putting the new key first, and the previous key second.
   *
   * If :ref:`session_ticket_keys <envoy_v3_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.session_ticket_keys>`
   * is not specified, the TLS library will still support resuming sessions via tickets, but it will
   * use an internally-generated and managed key, so sessions cannot be resumed across hot restarts
   * or on different hosts.
   *
   * Each key must contain exactly 80 bytes of cryptographically-secure random data. For
   * example, the output of ``openssl rand 80``.
   *
   * .. attention::
   *
   *   Using this feature has serious security considerations and risks. Improper handling of keys
   *   may result in loss of secrecy in connections, even if ciphers supporting perfect forward
   *   secrecy are used. See https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some
   *   discussion. To minimize the risk, you must:
   *
   *   * Keep the session ticket keys at least as secure as your TLS certificate private keys
   *   * Rotate session ticket keys at least daily, and preferably hourly
   *   * Always generate keys using a cryptographically-secure random data source
   */
  keys?: DataSource[] | undefined;
}

/**
 * Indicates a certificate to be obtained from a named CertificateProvider plugin instance.
 * The plugin instances are defined in the client's bootstrap file.
 * The plugin allows certificates to be fetched/refreshed over the network asynchronously with
 * respect to the TLS handshake.
 * [#not-implemented-hide:]
 */
export interface CertificateProviderPluginInstance {
  $type: "envoy.extensions.transport_sockets.tls.v3.CertificateProviderPluginInstance";
  /**
   * Provider instance name.
   *
   * Instance names should generally be defined not in terms of the underlying provider
   * implementation (e.g., "file_watcher") but rather in terms of the function of the
   * certificates (e.g., "foo_deployment_identity").
   */
  instance_name?:
    | string
    | undefined;
  /**
   * Opaque name used to specify certificate instances or types. For example, "ROOTCA" to specify
   * a root-certificate (validation context) or "example.com" to specify a certificate for a
   * particular domain. Not all provider instances will actually use this field, so the value
   * defaults to the empty string.
   */
  certificate_name?: string | undefined;
}

/** Matcher for subject alternative names, to match both type and value of the SAN. */
export interface SubjectAltNameMatcher {
  $type: "envoy.extensions.transport_sockets.tls.v3.SubjectAltNameMatcher";
  /** Specification of type of SAN. Note that the default enum value is an invalid choice. */
  san_type?:
    | SubjectAltNameMatcher_SanType
    | undefined;
  /**
   * Matcher for SAN value.
   *
   * If the :ref:`san_type <envoy_v3_api_field_extensions.transport_sockets.tls.v3.SubjectAltNameMatcher.san_type>`
   * is :ref:`DNS <envoy_v3_api_enum_value_extensions.transport_sockets.tls.v3.SubjectAltNameMatcher.SanType.DNS>`
   * and the matcher type is :ref:`exact <envoy_v3_api_field_type.matcher.v3.StringMatcher.exact>`, DNS wildcards are evaluated
   * according to the rules in https://www.rfc-editor.org/rfc/rfc6125#section-6.4.3.
   * For example, ``*.example.com`` would match ``test.example.com`` but not ``example.com`` and not
   * ``a.b.example.com``.
   *
   * The string matching for OTHER_NAME SAN values depends on their ASN.1 type:
   *
   *          * OBJECT: Validated against its dotted numeric notation (e.g., "1.2.3.4")
   *          * BOOLEAN: Validated against strings "true" or "false"
   *          * INTEGER/ENUMERATED: Validated against a string containing the integer value
   *          * NULL: Validated against an empty string
   *          * Other types: Validated directly against the string value
   */
  matcher?:
    | StringMatcher
    | undefined;
  /**
   * OID Value which is required if OTHER_NAME SAN type is used.
   * For example, UPN OID is 1.3.6.1.4.1.311.20.2.3
   * (Reference: http://oid-info.com/get/1.3.6.1.4.1.311.20.2.3).
   *
   * If set for SAN types other than OTHER_NAME, it will be ignored.
   */
  oid?: string | undefined;
}

/**
 * Indicates the choice of GeneralName as defined in section 4.2.1.5 of RFC 5280 to match
 * against.
 */
export enum SubjectAltNameMatcher_SanType {
  SAN_TYPE_UNSPECIFIED = "SAN_TYPE_UNSPECIFIED",
  EMAIL = "EMAIL",
  DNS = "DNS",
  URI = "URI",
  IP_ADDRESS = "IP_ADDRESS",
  OTHER_NAME = "OTHER_NAME",
}

export function subjectAltNameMatcher_SanTypeFromJSON(object: any): SubjectAltNameMatcher_SanType {
  switch (object) {
    case 0:
    case "SAN_TYPE_UNSPECIFIED":
      return SubjectAltNameMatcher_SanType.SAN_TYPE_UNSPECIFIED;
    case 1:
    case "EMAIL":
      return SubjectAltNameMatcher_SanType.EMAIL;
    case 2:
    case "DNS":
      return SubjectAltNameMatcher_SanType.DNS;
    case 3:
    case "URI":
      return SubjectAltNameMatcher_SanType.URI;
    case 4:
    case "IP_ADDRESS":
      return SubjectAltNameMatcher_SanType.IP_ADDRESS;
    case 5:
    case "OTHER_NAME":
      return SubjectAltNameMatcher_SanType.OTHER_NAME;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum SubjectAltNameMatcher_SanType");
  }
}

export function subjectAltNameMatcher_SanTypeToJSON(object: SubjectAltNameMatcher_SanType): string {
  switch (object) {
    case SubjectAltNameMatcher_SanType.SAN_TYPE_UNSPECIFIED:
      return "SAN_TYPE_UNSPECIFIED";
    case SubjectAltNameMatcher_SanType.EMAIL:
      return "EMAIL";
    case SubjectAltNameMatcher_SanType.DNS:
      return "DNS";
    case SubjectAltNameMatcher_SanType.URI:
      return "URI";
    case SubjectAltNameMatcher_SanType.IP_ADDRESS:
      return "IP_ADDRESS";
    case SubjectAltNameMatcher_SanType.OTHER_NAME:
      return "OTHER_NAME";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum SubjectAltNameMatcher_SanType");
  }
}

export function subjectAltNameMatcher_SanTypeToNumber(object: SubjectAltNameMatcher_SanType): number {
  switch (object) {
    case SubjectAltNameMatcher_SanType.SAN_TYPE_UNSPECIFIED:
      return 0;
    case SubjectAltNameMatcher_SanType.EMAIL:
      return 1;
    case SubjectAltNameMatcher_SanType.DNS:
      return 2;
    case SubjectAltNameMatcher_SanType.URI:
      return 3;
    case SubjectAltNameMatcher_SanType.IP_ADDRESS:
      return 4;
    case SubjectAltNameMatcher_SanType.OTHER_NAME:
      return 5;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum SubjectAltNameMatcher_SanType");
  }
}

/** [#next-free-field: 18] */
export interface CertificateValidationContext {
  $type: "envoy.extensions.transport_sockets.tls.v3.CertificateValidationContext";
  /**
   * TLS certificate data containing certificate authority certificates to use in verifying
   * a presented peer certificate (e.g. server certificate for clusters or client certificate
   * for listeners). If not specified and a peer certificate is presented it will not be
   * verified. By default, a client certificate is optional, unless one of the additional
   * options (:ref:`require_client_certificate
   * <envoy_v3_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.require_client_certificate>`,
   * :ref:`verify_certificate_spki
   * <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_spki>`,
   * :ref:`verify_certificate_hash
   * <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_hash>`, or
   * :ref:`match_typed_subject_alt_names
   * <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.match_typed_subject_alt_names>`) is also
   * specified.
   *
   * It can optionally contain certificate revocation lists, in which case Envoy will verify
   * that the presented peer certificate has not been revoked by one of the included CRLs. Note
   * that if a CRL is provided for any certificate authority in a trust chain, a CRL must be
   * provided for all certificate authorities in that chain. Failure to do so will result in
   * verification failure for both revoked and unrevoked certificates from that chain.
   * The behavior of requiring all certificates to contain CRLs can be altered by
   * setting :ref:`only_verify_leaf_cert_crl <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.only_verify_leaf_cert_crl>`
   * true. If set to true, only the final certificate in the chain undergoes CRL verification.
   *
   * See :ref:`the TLS overview <arch_overview_ssl_enabling_verification>` for a list of common
   * system CA locations.
   *
   * If ``trusted_ca`` is a filesystem path, a watch will be added to the parent
   * directory for any file moves to support rotation. This currently only
   * applies to dynamic secrets, when the ``CertificateValidationContext`` is
   * delivered via SDS.
   *
   * X509_V_FLAG_PARTIAL_CHAIN is set by default, so non-root/intermediate ca certificate in ``trusted_ca``
   * can be treated as trust anchor as well. It allows verification with building valid partial chain instead
   * of a full chain.
   *
   * If ``ca_certificate_provider_instance`` is set, it takes precedence over ``trusted_ca``.
   */
  trusted_ca?:
    | DataSource
    | undefined;
  /**
   * Certificate provider instance for fetching TLS certificates.
   *
   * If set, takes precedence over ``trusted_ca``.
   * [#not-implemented-hide:]
   */
  ca_certificate_provider_instance?:
    | CertificateProviderPluginInstance
    | undefined;
  /**
   * Use system root certs for validation.
   * If present, system root certs are used only if neither of the ``trusted_ca``
   * or ``ca_certificate_provider_instance`` fields are set.
   * [#not-implemented-hide:]
   */
  system_root_certs?:
    | CertificateValidationContext_SystemRootCerts
    | undefined;
  /**
   * If specified, updates of a file-based ``trusted_ca`` source will be triggered
   * by this watch. This allows explicit control over the path watched, by
   * default the parent directory of the filesystem path in ``trusted_ca`` is
   * watched if this field is not specified. This only applies when a
   * ``CertificateValidationContext`` is delivered by SDS with references to
   * filesystem paths. See the :ref:`SDS key rotation <sds_key_rotation>`
   * documentation for further details.
   */
  watched_directory?:
    | WatchedDirectory
    | undefined;
  /**
   * An optional list of base64-encoded SHA-256 hashes. If specified, Envoy will verify that the
   * SHA-256 of the DER-encoded Subject Public Key Information (SPKI) of the presented certificate
   * matches one of the specified values.
   *
   * A base64-encoded SHA-256 of the Subject Public Key Information (SPKI) of the certificate
   * can be generated with the following command:
   *
   * .. code-block:: bash
   *
   *   $ openssl x509 -in path/to/client.crt -noout -pubkey
   *     | openssl pkey -pubin -outform DER
   *     | openssl dgst -sha256 -binary
   *     | openssl enc -base64
   *   NvqYIYSbgK2vCJpQhObf77vv+bQWtc5ek5RIOwPiC9A=
   *
   * This is the format used in HTTP Public Key Pinning.
   *
   * When both:
   * :ref:`verify_certificate_hash
   * <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_hash>` and
   * :ref:`verify_certificate_spki
   * <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_spki>` are specified,
   * a hash matching value from either of the lists will result in the certificate being accepted.
   *
   * .. attention::
   *
   *   This option is preferred over :ref:`verify_certificate_hash
   *   <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_hash>`,
   *   because SPKI is tied to a private key, so it doesn't change when the certificate
   *   is renewed using the same private key.
   */
  verify_certificate_spki?:
    | string[]
    | undefined;
  /**
   * An optional list of hex-encoded SHA-256 hashes. If specified, Envoy will verify that
   * the SHA-256 of the DER-encoded presented certificate matches one of the specified values.
   *
   * A hex-encoded SHA-256 of the certificate can be generated with the following command:
   *
   * .. code-block:: bash
   *
   *   $ openssl x509 -in path/to/client.crt -outform DER | openssl dgst -sha256 | cut -d" " -f2
   *   df6ff72fe9116521268f6f2dd4966f51df479883fe7037b39f75916ac3049d1a
   *
   * A long hex-encoded and colon-separated SHA-256 (a.k.a. "fingerprint") of the certificate
   * can be generated with the following command:
   *
   * .. code-block:: bash
   *
   *   $ openssl x509 -in path/to/client.crt -noout -fingerprint -sha256 | cut -d"=" -f2
   *   DF:6F:F7:2F:E9:11:65:21:26:8F:6F:2D:D4:96:6F:51:DF:47:98:83:FE:70:37:B3:9F:75:91:6A:C3:04:9D:1A
   *
   * Both of those formats are acceptable.
   *
   * When both:
   * :ref:`verify_certificate_hash
   * <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_hash>` and
   * :ref:`verify_certificate_spki
   * <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_spki>` are specified,
   * a hash matching value from either of the lists will result in the certificate being accepted.
   */
  verify_certificate_hash?:
    | string[]
    | undefined;
  /**
   * An optional list of Subject Alternative name matchers. If specified, Envoy will verify that the
   * Subject Alternative Name of the presented certificate matches one of the specified matchers.
   * The matching uses "any" semantics, that is to say, the SAN is verified if at least one matcher is
   * matched.
   *
   * When a certificate has wildcard DNS SAN entries, to match a specific client, it should be
   * configured with exact match type in the :ref:`string matcher <envoy_v3_api_msg_type.matcher.v3.StringMatcher>`.
   * For example if the certificate has "\*.example.com" as DNS SAN entry, to allow only "api.example.com",
   * it should be configured as shown below.
   *
   * .. code-block:: yaml
   *
   *  match_typed_subject_alt_names:
   *  - san_type: DNS
   *    matcher:
   *      exact: "api.example.com"
   *
   * .. attention::
   *
   *   Subject Alternative Names are easily spoofable and verifying only them is insecure,
   *   therefore this option must be used together with :ref:`trusted_ca
   *   <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.trusted_ca>`.
   */
  match_typed_subject_alt_names?:
    | SubjectAltNameMatcher[]
    | undefined;
  /**
   * This field is deprecated in favor of
   * :ref:`match_typed_subject_alt_names
   * <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.match_typed_subject_alt_names>`.
   * Note that if both this field and :ref:`match_typed_subject_alt_names
   * <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.match_typed_subject_alt_names>`
   * are specified, the former (deprecated field) is ignored.
   *
   * @deprecated
   */
  match_subject_alt_names?:
    | StringMatcher[]
    | undefined;
  /** [#not-implemented-hide:] Must present signed certificate time-stamp. */
  require_signed_certificate_timestamp?:
    | boolean
    | undefined;
  /**
   * An optional `certificate revocation list
   * <https://en.wikipedia.org/wiki/Certificate_revocation_list>`_
   * (in PEM format). If specified, Envoy will verify that the presented peer
   * certificate has not been revoked by this CRL. If this DataSource contains
   * multiple CRLs, all of them will be used. Note that if a CRL is provided
   * for any certificate authority in a trust chain, a CRL must be provided
   * for all certificate authorities in that chain. Failure to do so will
   * result in verification failure for both revoked and unrevoked certificates
   * from that chain. This default behavior can be altered by setting
   * :ref:`only_verify_leaf_cert_crl <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.only_verify_leaf_cert_crl>` to
   * true.
   *
   * If ``crl`` is a filesystem path, a watch will be added to the parent
   * directory for any file moves to support rotation. This currently only
   * applies to dynamic secrets, when the ``CertificateValidationContext`` is
   * delivered via SDS.
   */
  crl?:
    | DataSource
    | undefined;
  /** If specified, Envoy will not reject expired certificates. */
  allow_expired_certificate?:
    | boolean
    | undefined;
  /** Certificate trust chain verification mode. */
  trust_chain_verification?:
    | CertificateValidationContext_TrustChainVerification
    | undefined;
  /**
   * The configuration of an extension specific certificate validator.
   * If specified, all validation is done by the specified validator,
   * and the behavior of all other validation settings is defined by the specified validator (and may be entirely ignored, unused, and unvalidated).
   * Refer to the documentation for the specified validator. If you do not want a custom validation algorithm, do not set this field.
   * [#extension-category: envoy.tls.cert_validator]
   */
  custom_validator_config?:
    | TypedExtensionConfig
    | undefined;
  /**
   * If this option is set to true, only the certificate at the end of the
   * certificate chain will be subject to validation by :ref:`CRL <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.crl>`.
   */
  only_verify_leaf_cert_crl?:
    | boolean
    | undefined;
  /**
   * Defines maximum depth of a certificate chain accepted in verification, the default limit is 100, though this can be system-dependent.
   * This number does not include the leaf but includes the trust anchor, so a depth of 1 allows the leaf and one CA certificate. If a trusted issuer
   * appears in the chain, but in a depth larger than configured, the certificate validation will fail.
   * This matches the semantics of ``SSL_CTX_set_verify_depth`` in OpenSSL 1.0.x and older versions of BoringSSL. It differs from ``SSL_CTX_set_verify_depth``
   * in OpenSSL 1.1.x and newer versions of BoringSSL in that the trust anchor is included.
   * Trusted issues are specified by setting :ref:`trusted_ca <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.trusted_ca>`
   */
  max_verify_depth?: number | undefined;
}

/** Peer certificate verification mode. */
export enum CertificateValidationContext_TrustChainVerification {
  /** VERIFY_TRUST_CHAIN - Perform default certificate verification (e.g., against CA / verification lists) */
  VERIFY_TRUST_CHAIN = "VERIFY_TRUST_CHAIN",
  /**
   * ACCEPT_UNTRUSTED - Connections where the certificate fails verification will be permitted.
   * For HTTP connections, the result of certificate verification can be used in route matching. (
   * see :ref:`validated <envoy_v3_api_field_config.route.v3.RouteMatch.TlsContextMatchOptions.validated>` ).
   */
  ACCEPT_UNTRUSTED = "ACCEPT_UNTRUSTED",
}

export function certificateValidationContext_TrustChainVerificationFromJSON(
  object: any,
): CertificateValidationContext_TrustChainVerification {
  switch (object) {
    case 0:
    case "VERIFY_TRUST_CHAIN":
      return CertificateValidationContext_TrustChainVerification.VERIFY_TRUST_CHAIN;
    case 1:
    case "ACCEPT_UNTRUSTED":
      return CertificateValidationContext_TrustChainVerification.ACCEPT_UNTRUSTED;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CertificateValidationContext_TrustChainVerification",
      );
  }
}

export function certificateValidationContext_TrustChainVerificationToJSON(
  object: CertificateValidationContext_TrustChainVerification,
): string {
  switch (object) {
    case CertificateValidationContext_TrustChainVerification.VERIFY_TRUST_CHAIN:
      return "VERIFY_TRUST_CHAIN";
    case CertificateValidationContext_TrustChainVerification.ACCEPT_UNTRUSTED:
      return "ACCEPT_UNTRUSTED";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CertificateValidationContext_TrustChainVerification",
      );
  }
}

export function certificateValidationContext_TrustChainVerificationToNumber(
  object: CertificateValidationContext_TrustChainVerification,
): number {
  switch (object) {
    case CertificateValidationContext_TrustChainVerification.VERIFY_TRUST_CHAIN:
      return 0;
    case CertificateValidationContext_TrustChainVerification.ACCEPT_UNTRUSTED:
      return 1;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CertificateValidationContext_TrustChainVerification",
      );
  }
}

export interface CertificateValidationContext_SystemRootCerts {
  $type: "envoy.extensions.transport_sockets.tls.v3.CertificateValidationContext.SystemRootCerts";
}

function createBaseTlsParameters(): TlsParameters {
  return { $type: "envoy.extensions.transport_sockets.tls.v3.TlsParameters" };
}

export const TlsParameters: MessageFns<TlsParameters, "envoy.extensions.transport_sockets.tls.v3.TlsParameters"> = {
  $type: "envoy.extensions.transport_sockets.tls.v3.TlsParameters" as const,

  encode(message: TlsParameters, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (
      message.tls_minimum_protocol_version !== undefined &&
      message.tls_minimum_protocol_version !== TlsParameters_TlsProtocol.TLS_AUTO
    ) {
      writer.uint32(8).int32(tlsParameters_TlsProtocolToNumber(message.tls_minimum_protocol_version));
    }
    if (
      message.tls_maximum_protocol_version !== undefined &&
      message.tls_maximum_protocol_version !== TlsParameters_TlsProtocol.TLS_AUTO
    ) {
      writer.uint32(16).int32(tlsParameters_TlsProtocolToNumber(message.tls_maximum_protocol_version));
    }
    if (message.cipher_suites !== undefined && message.cipher_suites.length !== 0) {
      for (const v of message.cipher_suites) {
        writer.uint32(26).string(v!);
      }
    }
    if (message.ecdh_curves !== undefined && message.ecdh_curves.length !== 0) {
      for (const v of message.ecdh_curves) {
        writer.uint32(34).string(v!);
      }
    }
    if (message.signature_algorithms !== undefined && message.signature_algorithms.length !== 0) {
      for (const v of message.signature_algorithms) {
        writer.uint32(42).string(v!);
      }
    }
    if (message.compliance_policies !== undefined && message.compliance_policies.length !== 0) {
      writer.uint32(50).fork();
      for (const v of message.compliance_policies) {
        writer.int32(tlsParameters_CompliancePolicyToNumber(v));
      }
      writer.join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TlsParameters {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTlsParameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.tls_minimum_protocol_version = tlsParameters_TlsProtocolFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.tls_maximum_protocol_version = tlsParameters_TlsProtocolFromJSON(reader.int32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.cipher_suites === undefined) {
            message.cipher_suites = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.cipher_suites!.push(el);
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          if (message.ecdh_curves === undefined) {
            message.ecdh_curves = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.ecdh_curves!.push(el);
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          if (message.signature_algorithms === undefined) {
            message.signature_algorithms = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.signature_algorithms!.push(el);
          }
          continue;
        }
        case 6: {
          if (tag === 48) {
            if (message.compliance_policies === undefined) {
              message.compliance_policies = [];
            }
            message.compliance_policies!.push(tlsParameters_CompliancePolicyFromJSON(reader.int32()));

            continue;
          }

          if (tag === 50) {
            if (message.compliance_policies === undefined) {
              message.compliance_policies = [];
            }
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.compliance_policies!.push(tlsParameters_CompliancePolicyFromJSON(reader.int32()));
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TlsParameters {
    return {
      $type: TlsParameters.$type,
      tls_minimum_protocol_version: isSet(object.tls_minimum_protocol_version)
        ? tlsParameters_TlsProtocolFromJSON(object.tls_minimum_protocol_version)
        : undefined,
      tls_maximum_protocol_version: isSet(object.tls_maximum_protocol_version)
        ? tlsParameters_TlsProtocolFromJSON(object.tls_maximum_protocol_version)
        : undefined,
      cipher_suites: globalThis.Array.isArray(object?.cipher_suites)
        ? object.cipher_suites.map((e: any) => globalThis.String(e))
        : undefined,
      ecdh_curves: globalThis.Array.isArray(object?.ecdh_curves)
        ? object.ecdh_curves.map((e: any) => globalThis.String(e))
        : undefined,
      signature_algorithms: globalThis.Array.isArray(object?.signature_algorithms)
        ? object.signature_algorithms.map((e: any) => globalThis.String(e))
        : undefined,
      compliance_policies: globalThis.Array.isArray(object?.compliance_policies)
        ? object.compliance_policies.map((e: any) => tlsParameters_CompliancePolicyFromJSON(e))
        : undefined,
    };
  },

  toJSON(message: TlsParameters): unknown {
    const obj: any = {};
    if (message.tls_minimum_protocol_version !== undefined) {
      obj.tls_minimum_protocol_version = tlsParameters_TlsProtocolToJSON(message.tls_minimum_protocol_version);
    }
    if (message.tls_maximum_protocol_version !== undefined) {
      obj.tls_maximum_protocol_version = tlsParameters_TlsProtocolToJSON(message.tls_maximum_protocol_version);
    }
    if (message.cipher_suites?.length) {
      obj.cipher_suites = message.cipher_suites;
    }
    if (message.ecdh_curves?.length) {
      obj.ecdh_curves = message.ecdh_curves;
    }
    if (message.signature_algorithms?.length) {
      obj.signature_algorithms = message.signature_algorithms;
    }
    if (message.compliance_policies?.length) {
      obj.compliance_policies = message.compliance_policies.map((e) => tlsParameters_CompliancePolicyToJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TlsParameters>, I>>(base?: I): TlsParameters {
    return TlsParameters.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TlsParameters>, I>>(object: I): TlsParameters {
    const message = createBaseTlsParameters();
    message.tls_minimum_protocol_version = object.tls_minimum_protocol_version ?? undefined;
    message.tls_maximum_protocol_version = object.tls_maximum_protocol_version ?? undefined;
    message.cipher_suites = object.cipher_suites?.map((e) => e) || undefined;
    message.ecdh_curves = object.ecdh_curves?.map((e) => e) || undefined;
    message.signature_algorithms = object.signature_algorithms?.map((e) => e) || undefined;
    message.compliance_policies = object.compliance_policies?.map((e) => e) || undefined;
    return message;
  },
};

messageTypeRegistry.set(TlsParameters.$type, TlsParameters);

function createBasePrivateKeyProvider(): PrivateKeyProvider {
  return { $type: "envoy.extensions.transport_sockets.tls.v3.PrivateKeyProvider", config_type: undefined };
}

export const PrivateKeyProvider: MessageFns<
  PrivateKeyProvider,
  "envoy.extensions.transport_sockets.tls.v3.PrivateKeyProvider"
> = {
  $type: "envoy.extensions.transport_sockets.tls.v3.PrivateKeyProvider" as const,

  encode(message: PrivateKeyProvider, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provider_name !== undefined && message.provider_name !== "") {
      writer.uint32(10).string(message.provider_name);
    }
    switch (message.config_type?.$case) {
      case "typed_config":
        Any.encode(message.config_type.typed_config, writer.uint32(26).fork()).join();
        break;
    }
    if (message.fallback !== undefined && message.fallback !== false) {
      writer.uint32(32).bool(message.fallback);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrivateKeyProvider {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrivateKeyProvider();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.provider_name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.config_type = { $case: "typed_config", typed_config: Any.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.fallback = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrivateKeyProvider {
    return {
      $type: PrivateKeyProvider.$type,
      provider_name: isSet(object.provider_name) ? globalThis.String(object.provider_name) : undefined,
      config_type: isSet(object.typed_config)
        ? { $case: "typed_config", typed_config: Any.fromJSON(object.typed_config) }
        : undefined,
      fallback: isSet(object.fallback) ? globalThis.Boolean(object.fallback) : undefined,
    };
  },

  toJSON(message: PrivateKeyProvider): unknown {
    const obj: any = {};
    if (message.provider_name !== undefined) {
      obj.provider_name = message.provider_name;
    }
    if (message.config_type?.$case === "typed_config") {
      obj.typed_config = Any.toJSON(message.config_type.typed_config);
    }
    if (message.fallback !== undefined) {
      obj.fallback = message.fallback;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PrivateKeyProvider>, I>>(base?: I): PrivateKeyProvider {
    return PrivateKeyProvider.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PrivateKeyProvider>, I>>(object: I): PrivateKeyProvider {
    const message = createBasePrivateKeyProvider();
    message.provider_name = object.provider_name ?? undefined;
    if (
      object.config_type?.$case === "typed_config" &&
      object.config_type?.typed_config !== undefined &&
      object.config_type?.typed_config !== null
    ) {
      message.config_type = { $case: "typed_config", typed_config: Any.fromPartial(object.config_type.typed_config) };
    }
    message.fallback = object.fallback ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(PrivateKeyProvider.$type, PrivateKeyProvider);

function createBaseTlsCertificate(): TlsCertificate {
  return { $type: "envoy.extensions.transport_sockets.tls.v3.TlsCertificate" };
}

export const TlsCertificate: MessageFns<TlsCertificate, "envoy.extensions.transport_sockets.tls.v3.TlsCertificate"> = {
  $type: "envoy.extensions.transport_sockets.tls.v3.TlsCertificate" as const,

  encode(message: TlsCertificate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.certificate_chain !== undefined) {
      DataSource.encode(message.certificate_chain, writer.uint32(10).fork()).join();
    }
    if (message.private_key !== undefined) {
      DataSource.encode(message.private_key, writer.uint32(18).fork()).join();
    }
    if (message.pkcs12 !== undefined) {
      DataSource.encode(message.pkcs12, writer.uint32(66).fork()).join();
    }
    if (message.watched_directory !== undefined) {
      WatchedDirectory.encode(message.watched_directory, writer.uint32(58).fork()).join();
    }
    if (message.private_key_provider !== undefined) {
      PrivateKeyProvider.encode(message.private_key_provider, writer.uint32(50).fork()).join();
    }
    if (message.password !== undefined) {
      DataSource.encode(message.password, writer.uint32(26).fork()).join();
    }
    if (message.ocsp_staple !== undefined) {
      DataSource.encode(message.ocsp_staple, writer.uint32(34).fork()).join();
    }
    if (message.signed_certificate_timestamp !== undefined && message.signed_certificate_timestamp.length !== 0) {
      for (const v of message.signed_certificate_timestamp) {
        DataSource.encode(v!, writer.uint32(42).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TlsCertificate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTlsCertificate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.certificate_chain = DataSource.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.private_key = DataSource.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.pkcs12 = DataSource.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.watched_directory = WatchedDirectory.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.private_key_provider = PrivateKeyProvider.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.password = DataSource.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.ocsp_staple = DataSource.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          if (message.signed_certificate_timestamp === undefined) {
            message.signed_certificate_timestamp = [];
          }
          const el = DataSource.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.signed_certificate_timestamp!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TlsCertificate {
    return {
      $type: TlsCertificate.$type,
      certificate_chain: isSet(object.certificate_chain) ? DataSource.fromJSON(object.certificate_chain) : undefined,
      private_key: isSet(object.private_key) ? DataSource.fromJSON(object.private_key) : undefined,
      pkcs12: isSet(object.pkcs12) ? DataSource.fromJSON(object.pkcs12) : undefined,
      watched_directory: isSet(object.watched_directory)
        ? WatchedDirectory.fromJSON(object.watched_directory)
        : undefined,
      private_key_provider: isSet(object.private_key_provider)
        ? PrivateKeyProvider.fromJSON(object.private_key_provider)
        : undefined,
      password: isSet(object.password) ? DataSource.fromJSON(object.password) : undefined,
      ocsp_staple: isSet(object.ocsp_staple) ? DataSource.fromJSON(object.ocsp_staple) : undefined,
      signed_certificate_timestamp: globalThis.Array.isArray(object?.signed_certificate_timestamp)
        ? object.signed_certificate_timestamp.map((e: any) => DataSource.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: TlsCertificate): unknown {
    const obj: any = {};
    if (message.certificate_chain !== undefined) {
      obj.certificate_chain = DataSource.toJSON(message.certificate_chain);
    }
    if (message.private_key !== undefined) {
      obj.private_key = DataSource.toJSON(message.private_key);
    }
    if (message.pkcs12 !== undefined) {
      obj.pkcs12 = DataSource.toJSON(message.pkcs12);
    }
    if (message.watched_directory !== undefined) {
      obj.watched_directory = WatchedDirectory.toJSON(message.watched_directory);
    }
    if (message.private_key_provider !== undefined) {
      obj.private_key_provider = PrivateKeyProvider.toJSON(message.private_key_provider);
    }
    if (message.password !== undefined) {
      obj.password = DataSource.toJSON(message.password);
    }
    if (message.ocsp_staple !== undefined) {
      obj.ocsp_staple = DataSource.toJSON(message.ocsp_staple);
    }
    if (message.signed_certificate_timestamp?.length) {
      obj.signed_certificate_timestamp = message.signed_certificate_timestamp.map((e) => DataSource.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TlsCertificate>, I>>(base?: I): TlsCertificate {
    return TlsCertificate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TlsCertificate>, I>>(object: I): TlsCertificate {
    const message = createBaseTlsCertificate();
    message.certificate_chain = (object.certificate_chain !== undefined && object.certificate_chain !== null)
      ? DataSource.fromPartial(object.certificate_chain)
      : undefined;
    message.private_key = (object.private_key !== undefined && object.private_key !== null)
      ? DataSource.fromPartial(object.private_key)
      : undefined;
    message.pkcs12 = (object.pkcs12 !== undefined && object.pkcs12 !== null)
      ? DataSource.fromPartial(object.pkcs12)
      : undefined;
    message.watched_directory = (object.watched_directory !== undefined && object.watched_directory !== null)
      ? WatchedDirectory.fromPartial(object.watched_directory)
      : undefined;
    message.private_key_provider = (object.private_key_provider !== undefined && object.private_key_provider !== null)
      ? PrivateKeyProvider.fromPartial(object.private_key_provider)
      : undefined;
    message.password = (object.password !== undefined && object.password !== null)
      ? DataSource.fromPartial(object.password)
      : undefined;
    message.ocsp_staple = (object.ocsp_staple !== undefined && object.ocsp_staple !== null)
      ? DataSource.fromPartial(object.ocsp_staple)
      : undefined;
    message.signed_certificate_timestamp = object.signed_certificate_timestamp?.map((e) => DataSource.fromPartial(e)) ||
      undefined;
    return message;
  },
};

messageTypeRegistry.set(TlsCertificate.$type, TlsCertificate);

function createBaseTlsSessionTicketKeys(): TlsSessionTicketKeys {
  return { $type: "envoy.extensions.transport_sockets.tls.v3.TlsSessionTicketKeys" };
}

export const TlsSessionTicketKeys: MessageFns<
  TlsSessionTicketKeys,
  "envoy.extensions.transport_sockets.tls.v3.TlsSessionTicketKeys"
> = {
  $type: "envoy.extensions.transport_sockets.tls.v3.TlsSessionTicketKeys" as const,

  encode(message: TlsSessionTicketKeys, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keys !== undefined && message.keys.length !== 0) {
      for (const v of message.keys) {
        DataSource.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TlsSessionTicketKeys {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTlsSessionTicketKeys();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.keys === undefined) {
            message.keys = [];
          }
          const el = DataSource.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.keys!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TlsSessionTicketKeys {
    return {
      $type: TlsSessionTicketKeys.$type,
      keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e: any) => DataSource.fromJSON(e)) : undefined,
    };
  },

  toJSON(message: TlsSessionTicketKeys): unknown {
    const obj: any = {};
    if (message.keys?.length) {
      obj.keys = message.keys.map((e) => DataSource.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TlsSessionTicketKeys>, I>>(base?: I): TlsSessionTicketKeys {
    return TlsSessionTicketKeys.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TlsSessionTicketKeys>, I>>(object: I): TlsSessionTicketKeys {
    const message = createBaseTlsSessionTicketKeys();
    message.keys = object.keys?.map((e) => DataSource.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(TlsSessionTicketKeys.$type, TlsSessionTicketKeys);

function createBaseCertificateProviderPluginInstance(): CertificateProviderPluginInstance {
  return { $type: "envoy.extensions.transport_sockets.tls.v3.CertificateProviderPluginInstance" };
}

export const CertificateProviderPluginInstance: MessageFns<
  CertificateProviderPluginInstance,
  "envoy.extensions.transport_sockets.tls.v3.CertificateProviderPluginInstance"
> = {
  $type: "envoy.extensions.transport_sockets.tls.v3.CertificateProviderPluginInstance" as const,

  encode(message: CertificateProviderPluginInstance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instance_name !== undefined && message.instance_name !== "") {
      writer.uint32(10).string(message.instance_name);
    }
    if (message.certificate_name !== undefined && message.certificate_name !== "") {
      writer.uint32(18).string(message.certificate_name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateProviderPluginInstance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateProviderPluginInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.instance_name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.certificate_name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateProviderPluginInstance {
    return {
      $type: CertificateProviderPluginInstance.$type,
      instance_name: isSet(object.instance_name) ? globalThis.String(object.instance_name) : undefined,
      certificate_name: isSet(object.certificate_name) ? globalThis.String(object.certificate_name) : undefined,
    };
  },

  toJSON(message: CertificateProviderPluginInstance): unknown {
    const obj: any = {};
    if (message.instance_name !== undefined) {
      obj.instance_name = message.instance_name;
    }
    if (message.certificate_name !== undefined) {
      obj.certificate_name = message.certificate_name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CertificateProviderPluginInstance>, I>>(
    base?: I,
  ): CertificateProviderPluginInstance {
    return CertificateProviderPluginInstance.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CertificateProviderPluginInstance>, I>>(
    object: I,
  ): CertificateProviderPluginInstance {
    const message = createBaseCertificateProviderPluginInstance();
    message.instance_name = object.instance_name ?? undefined;
    message.certificate_name = object.certificate_name ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(CertificateProviderPluginInstance.$type, CertificateProviderPluginInstance);

function createBaseSubjectAltNameMatcher(): SubjectAltNameMatcher {
  return { $type: "envoy.extensions.transport_sockets.tls.v3.SubjectAltNameMatcher" };
}

export const SubjectAltNameMatcher: MessageFns<
  SubjectAltNameMatcher,
  "envoy.extensions.transport_sockets.tls.v3.SubjectAltNameMatcher"
> = {
  $type: "envoy.extensions.transport_sockets.tls.v3.SubjectAltNameMatcher" as const,

  encode(message: SubjectAltNameMatcher, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.san_type !== undefined && message.san_type !== SubjectAltNameMatcher_SanType.SAN_TYPE_UNSPECIFIED) {
      writer.uint32(8).int32(subjectAltNameMatcher_SanTypeToNumber(message.san_type));
    }
    if (message.matcher !== undefined) {
      StringMatcher.encode(message.matcher, writer.uint32(18).fork()).join();
    }
    if (message.oid !== undefined && message.oid !== "") {
      writer.uint32(26).string(message.oid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubjectAltNameMatcher {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubjectAltNameMatcher();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.san_type = subjectAltNameMatcher_SanTypeFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.matcher = StringMatcher.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.oid = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubjectAltNameMatcher {
    return {
      $type: SubjectAltNameMatcher.$type,
      san_type: isSet(object.san_type) ? subjectAltNameMatcher_SanTypeFromJSON(object.san_type) : undefined,
      matcher: isSet(object.matcher) ? StringMatcher.fromJSON(object.matcher) : undefined,
      oid: isSet(object.oid) ? globalThis.String(object.oid) : undefined,
    };
  },

  toJSON(message: SubjectAltNameMatcher): unknown {
    const obj: any = {};
    if (message.san_type !== undefined) {
      obj.san_type = subjectAltNameMatcher_SanTypeToJSON(message.san_type);
    }
    if (message.matcher !== undefined) {
      obj.matcher = StringMatcher.toJSON(message.matcher);
    }
    if (message.oid !== undefined) {
      obj.oid = message.oid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubjectAltNameMatcher>, I>>(base?: I): SubjectAltNameMatcher {
    return SubjectAltNameMatcher.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubjectAltNameMatcher>, I>>(object: I): SubjectAltNameMatcher {
    const message = createBaseSubjectAltNameMatcher();
    message.san_type = object.san_type ?? undefined;
    message.matcher = (object.matcher !== undefined && object.matcher !== null)
      ? StringMatcher.fromPartial(object.matcher)
      : undefined;
    message.oid = object.oid ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(SubjectAltNameMatcher.$type, SubjectAltNameMatcher);

function createBaseCertificateValidationContext(): CertificateValidationContext {
  return { $type: "envoy.extensions.transport_sockets.tls.v3.CertificateValidationContext" };
}

export const CertificateValidationContext: MessageFns<
  CertificateValidationContext,
  "envoy.extensions.transport_sockets.tls.v3.CertificateValidationContext"
> = {
  $type: "envoy.extensions.transport_sockets.tls.v3.CertificateValidationContext" as const,

  encode(message: CertificateValidationContext, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trusted_ca !== undefined) {
      DataSource.encode(message.trusted_ca, writer.uint32(10).fork()).join();
    }
    if (message.ca_certificate_provider_instance !== undefined) {
      CertificateProviderPluginInstance.encode(message.ca_certificate_provider_instance, writer.uint32(106).fork())
        .join();
    }
    if (message.system_root_certs !== undefined) {
      CertificateValidationContext_SystemRootCerts.encode(message.system_root_certs, writer.uint32(138).fork()).join();
    }
    if (message.watched_directory !== undefined) {
      WatchedDirectory.encode(message.watched_directory, writer.uint32(90).fork()).join();
    }
    if (message.verify_certificate_spki !== undefined && message.verify_certificate_spki.length !== 0) {
      for (const v of message.verify_certificate_spki) {
        writer.uint32(26).string(v!);
      }
    }
    if (message.verify_certificate_hash !== undefined && message.verify_certificate_hash.length !== 0) {
      for (const v of message.verify_certificate_hash) {
        writer.uint32(18).string(v!);
      }
    }
    if (message.match_typed_subject_alt_names !== undefined && message.match_typed_subject_alt_names.length !== 0) {
      for (const v of message.match_typed_subject_alt_names) {
        SubjectAltNameMatcher.encode(v!, writer.uint32(122).fork()).join();
      }
    }
    if (message.match_subject_alt_names !== undefined && message.match_subject_alt_names.length !== 0) {
      for (const v of message.match_subject_alt_names) {
        StringMatcher.encode(v!, writer.uint32(74).fork()).join();
      }
    }
    if (message.require_signed_certificate_timestamp !== undefined) {
      BoolValue.encode(
        { $type: "google.protobuf.BoolValue", value: message.require_signed_certificate_timestamp! },
        writer.uint32(50).fork(),
      ).join();
    }
    if (message.crl !== undefined) {
      DataSource.encode(message.crl, writer.uint32(58).fork()).join();
    }
    if (message.allow_expired_certificate !== undefined && message.allow_expired_certificate !== false) {
      writer.uint32(64).bool(message.allow_expired_certificate);
    }
    if (
      message.trust_chain_verification !== undefined &&
      message.trust_chain_verification !== CertificateValidationContext_TrustChainVerification.VERIFY_TRUST_CHAIN
    ) {
      writer.uint32(80).int32(
        certificateValidationContext_TrustChainVerificationToNumber(message.trust_chain_verification),
      );
    }
    if (message.custom_validator_config !== undefined) {
      TypedExtensionConfig.encode(message.custom_validator_config, writer.uint32(98).fork()).join();
    }
    if (message.only_verify_leaf_cert_crl !== undefined && message.only_verify_leaf_cert_crl !== false) {
      writer.uint32(112).bool(message.only_verify_leaf_cert_crl);
    }
    if (message.max_verify_depth !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.max_verify_depth! },
        writer.uint32(130).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateValidationContext {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateValidationContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trusted_ca = DataSource.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.ca_certificate_provider_instance = CertificateProviderPluginInstance.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.system_root_certs = CertificateValidationContext_SystemRootCerts.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.watched_directory = WatchedDirectory.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.verify_certificate_spki === undefined) {
            message.verify_certificate_spki = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.verify_certificate_spki!.push(el);
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.verify_certificate_hash === undefined) {
            message.verify_certificate_hash = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.verify_certificate_hash!.push(el);
          }
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          if (message.match_typed_subject_alt_names === undefined) {
            message.match_typed_subject_alt_names = [];
          }
          const el = SubjectAltNameMatcher.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.match_typed_subject_alt_names!.push(el);
          }
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          if (message.match_subject_alt_names === undefined) {
            message.match_subject_alt_names = [];
          }
          const el = StringMatcher.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.match_subject_alt_names!.push(el);
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.require_signed_certificate_timestamp = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.crl = DataSource.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.allow_expired_certificate = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.trust_chain_verification = certificateValidationContext_TrustChainVerificationFromJSON(
            reader.int32(),
          );
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.custom_validator_config = TypedExtensionConfig.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.only_verify_leaf_cert_crl = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.max_verify_depth = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateValidationContext {
    return {
      $type: CertificateValidationContext.$type,
      trusted_ca: isSet(object.trusted_ca) ? DataSource.fromJSON(object.trusted_ca) : undefined,
      ca_certificate_provider_instance: isSet(object.ca_certificate_provider_instance)
        ? CertificateProviderPluginInstance.fromJSON(object.ca_certificate_provider_instance)
        : undefined,
      system_root_certs: isSet(object.system_root_certs)
        ? CertificateValidationContext_SystemRootCerts.fromJSON(object.system_root_certs)
        : undefined,
      watched_directory: isSet(object.watched_directory)
        ? WatchedDirectory.fromJSON(object.watched_directory)
        : undefined,
      verify_certificate_spki: globalThis.Array.isArray(object?.verify_certificate_spki)
        ? object.verify_certificate_spki.map((e: any) => globalThis.String(e))
        : undefined,
      verify_certificate_hash: globalThis.Array.isArray(object?.verify_certificate_hash)
        ? object.verify_certificate_hash.map((e: any) => globalThis.String(e))
        : undefined,
      match_typed_subject_alt_names: globalThis.Array.isArray(object?.match_typed_subject_alt_names)
        ? object.match_typed_subject_alt_names.map((e: any) => SubjectAltNameMatcher.fromJSON(e))
        : undefined,
      match_subject_alt_names: globalThis.Array.isArray(object?.match_subject_alt_names)
        ? object.match_subject_alt_names.map((e: any) => StringMatcher.fromJSON(e))
        : undefined,
      require_signed_certificate_timestamp: isSet(object.require_signed_certificate_timestamp)
        ? Boolean(object.require_signed_certificate_timestamp)
        : undefined,
      crl: isSet(object.crl) ? DataSource.fromJSON(object.crl) : undefined,
      allow_expired_certificate: isSet(object.allow_expired_certificate)
        ? globalThis.Boolean(object.allow_expired_certificate)
        : undefined,
      trust_chain_verification: isSet(object.trust_chain_verification)
        ? certificateValidationContext_TrustChainVerificationFromJSON(object.trust_chain_verification)
        : undefined,
      custom_validator_config: isSet(object.custom_validator_config)
        ? TypedExtensionConfig.fromJSON(object.custom_validator_config)
        : undefined,
      only_verify_leaf_cert_crl: isSet(object.only_verify_leaf_cert_crl)
        ? globalThis.Boolean(object.only_verify_leaf_cert_crl)
        : undefined,
      max_verify_depth: isSet(object.max_verify_depth) ? Number(object.max_verify_depth) : undefined,
    };
  },

  toJSON(message: CertificateValidationContext): unknown {
    const obj: any = {};
    if (message.trusted_ca !== undefined) {
      obj.trusted_ca = DataSource.toJSON(message.trusted_ca);
    }
    if (message.ca_certificate_provider_instance !== undefined) {
      obj.ca_certificate_provider_instance = CertificateProviderPluginInstance.toJSON(
        message.ca_certificate_provider_instance,
      );
    }
    if (message.system_root_certs !== undefined) {
      obj.system_root_certs = CertificateValidationContext_SystemRootCerts.toJSON(message.system_root_certs);
    }
    if (message.watched_directory !== undefined) {
      obj.watched_directory = WatchedDirectory.toJSON(message.watched_directory);
    }
    if (message.verify_certificate_spki?.length) {
      obj.verify_certificate_spki = message.verify_certificate_spki;
    }
    if (message.verify_certificate_hash?.length) {
      obj.verify_certificate_hash = message.verify_certificate_hash;
    }
    if (message.match_typed_subject_alt_names?.length) {
      obj.match_typed_subject_alt_names = message.match_typed_subject_alt_names.map((e) =>
        SubjectAltNameMatcher.toJSON(e)
      );
    }
    if (message.match_subject_alt_names?.length) {
      obj.match_subject_alt_names = message.match_subject_alt_names.map((e) => StringMatcher.toJSON(e));
    }
    if (message.require_signed_certificate_timestamp !== undefined) {
      obj.require_signed_certificate_timestamp = message.require_signed_certificate_timestamp;
    }
    if (message.crl !== undefined) {
      obj.crl = DataSource.toJSON(message.crl);
    }
    if (message.allow_expired_certificate !== undefined) {
      obj.allow_expired_certificate = message.allow_expired_certificate;
    }
    if (message.trust_chain_verification !== undefined) {
      obj.trust_chain_verification = certificateValidationContext_TrustChainVerificationToJSON(
        message.trust_chain_verification,
      );
    }
    if (message.custom_validator_config !== undefined) {
      obj.custom_validator_config = TypedExtensionConfig.toJSON(message.custom_validator_config);
    }
    if (message.only_verify_leaf_cert_crl !== undefined) {
      obj.only_verify_leaf_cert_crl = message.only_verify_leaf_cert_crl;
    }
    if (message.max_verify_depth !== undefined) {
      obj.max_verify_depth = message.max_verify_depth;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CertificateValidationContext>, I>>(base?: I): CertificateValidationContext {
    return CertificateValidationContext.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CertificateValidationContext>, I>>(object: I): CertificateValidationContext {
    const message = createBaseCertificateValidationContext();
    message.trusted_ca = (object.trusted_ca !== undefined && object.trusted_ca !== null)
      ? DataSource.fromPartial(object.trusted_ca)
      : undefined;
    message.ca_certificate_provider_instance =
      (object.ca_certificate_provider_instance !== undefined && object.ca_certificate_provider_instance !== null)
        ? CertificateProviderPluginInstance.fromPartial(object.ca_certificate_provider_instance)
        : undefined;
    message.system_root_certs = (object.system_root_certs !== undefined && object.system_root_certs !== null)
      ? CertificateValidationContext_SystemRootCerts.fromPartial(object.system_root_certs)
      : undefined;
    message.watched_directory = (object.watched_directory !== undefined && object.watched_directory !== null)
      ? WatchedDirectory.fromPartial(object.watched_directory)
      : undefined;
    message.verify_certificate_spki = object.verify_certificate_spki?.map((e) => e) || undefined;
    message.verify_certificate_hash = object.verify_certificate_hash?.map((e) => e) || undefined;
    message.match_typed_subject_alt_names =
      object.match_typed_subject_alt_names?.map((e) => SubjectAltNameMatcher.fromPartial(e)) || undefined;
    message.match_subject_alt_names = object.match_subject_alt_names?.map((e) => StringMatcher.fromPartial(e)) ||
      undefined;
    message.require_signed_certificate_timestamp = object.require_signed_certificate_timestamp ?? undefined;
    message.crl = (object.crl !== undefined && object.crl !== null) ? DataSource.fromPartial(object.crl) : undefined;
    message.allow_expired_certificate = object.allow_expired_certificate ?? undefined;
    message.trust_chain_verification = object.trust_chain_verification ?? undefined;
    message.custom_validator_config =
      (object.custom_validator_config !== undefined && object.custom_validator_config !== null)
        ? TypedExtensionConfig.fromPartial(object.custom_validator_config)
        : undefined;
    message.only_verify_leaf_cert_crl = object.only_verify_leaf_cert_crl ?? undefined;
    message.max_verify_depth = object.max_verify_depth ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(CertificateValidationContext.$type, CertificateValidationContext);

function createBaseCertificateValidationContext_SystemRootCerts(): CertificateValidationContext_SystemRootCerts {
  return { $type: "envoy.extensions.transport_sockets.tls.v3.CertificateValidationContext.SystemRootCerts" };
}

export const CertificateValidationContext_SystemRootCerts: MessageFns<
  CertificateValidationContext_SystemRootCerts,
  "envoy.extensions.transport_sockets.tls.v3.CertificateValidationContext.SystemRootCerts"
> = {
  $type: "envoy.extensions.transport_sockets.tls.v3.CertificateValidationContext.SystemRootCerts" as const,

  encode(_: CertificateValidationContext_SystemRootCerts, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateValidationContext_SystemRootCerts {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateValidationContext_SystemRootCerts();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CertificateValidationContext_SystemRootCerts {
    return { $type: CertificateValidationContext_SystemRootCerts.$type };
  },

  toJSON(_: CertificateValidationContext_SystemRootCerts): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<CertificateValidationContext_SystemRootCerts>, I>>(
    base?: I,
  ): CertificateValidationContext_SystemRootCerts {
    return CertificateValidationContext_SystemRootCerts.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CertificateValidationContext_SystemRootCerts>, I>>(
    _: I,
  ): CertificateValidationContext_SystemRootCerts {
    const message = createBaseCertificateValidationContext_SystemRootCerts();
    return message;
  },
};

messageTypeRegistry.set(
  CertificateValidationContext_SystemRootCerts.$type,
  CertificateValidationContext_SystemRootCerts,
);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
