// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/service/discovery/v2/hds.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Observable } from "rxjs";
import { map } from "rxjs/operators";
import { Duration } from "../../../../google/protobuf/duration";
import { messageTypeRegistry } from "../../../../typeRegistry";
import { Locality, Node } from "../../../api/v2/core/base";
import {
  HealthCheck,
  HealthStatus,
  healthStatusFromJSON,
  healthStatusToJSON,
  healthStatusToNumber,
} from "../../../api/v2/core/health_check";
import { Endpoint } from "../../../api/v2/endpoint/endpoint_components";

export const protobufPackage = "envoy.service.discovery.v2";

/**
 * Defines supported protocols etc, so the management server can assign proper
 * endpoints to healthcheck.
 */
export interface Capability {
  $type: "envoy.service.discovery.v2.Capability";
  health_check_protocols?: Capability_Protocol[] | undefined;
}

/**
 * Different Envoy instances may have different capabilities (e.g. Redis)
 * and/or have ports enabled for different protocols.
 */
export enum Capability_Protocol {
  HTTP = "HTTP",
  TCP = "TCP",
  REDIS = "REDIS",
}

export function capability_ProtocolFromJSON(object: any): Capability_Protocol {
  switch (object) {
    case 0:
    case "HTTP":
      return Capability_Protocol.HTTP;
    case 1:
    case "TCP":
      return Capability_Protocol.TCP;
    case 2:
    case "REDIS":
      return Capability_Protocol.REDIS;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Capability_Protocol");
  }
}

export function capability_ProtocolToJSON(object: Capability_Protocol): string {
  switch (object) {
    case Capability_Protocol.HTTP:
      return "HTTP";
    case Capability_Protocol.TCP:
      return "TCP";
    case Capability_Protocol.REDIS:
      return "REDIS";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Capability_Protocol");
  }
}

export function capability_ProtocolToNumber(object: Capability_Protocol): number {
  switch (object) {
    case Capability_Protocol.HTTP:
      return 0;
    case Capability_Protocol.TCP:
      return 1;
    case Capability_Protocol.REDIS:
      return 2;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Capability_Protocol");
  }
}

export interface HealthCheckRequest {
  $type: "envoy.service.discovery.v2.HealthCheckRequest";
  node?: Node | undefined;
  capability?: Capability | undefined;
}

export interface EndpointHealth {
  $type: "envoy.service.discovery.v2.EndpointHealth";
  endpoint?: Endpoint | undefined;
  health_status?: HealthStatus | undefined;
}

export interface EndpointHealthResponse {
  $type: "envoy.service.discovery.v2.EndpointHealthResponse";
  endpoints_health?: EndpointHealth[] | undefined;
}

export interface HealthCheckRequestOrEndpointHealthResponse {
  $type: "envoy.service.discovery.v2.HealthCheckRequestOrEndpointHealthResponse";
  request_type?:
    | //
    { $case: "health_check_request"; health_check_request: HealthCheckRequest }
    | //
    { $case: "endpoint_health_response"; endpoint_health_response: EndpointHealthResponse }
    | undefined;
}

export interface LocalityEndpoints {
  $type: "envoy.service.discovery.v2.LocalityEndpoints";
  locality?: Locality | undefined;
  endpoints?: Endpoint[] | undefined;
}

/**
 * The cluster name and locality is provided to Envoy for the endpoints that it
 * health checks to support statistics reporting, logging and debugging by the
 * Envoy instance (outside of HDS). For maximum usefulness, it should match the
 * same cluster structure as that provided by EDS.
 */
export interface ClusterHealthCheck {
  $type: "envoy.service.discovery.v2.ClusterHealthCheck";
  cluster_name?: string | undefined;
  health_checks?: HealthCheck[] | undefined;
  locality_endpoints?: LocalityEndpoints[] | undefined;
}

export interface HealthCheckSpecifier {
  $type: "envoy.service.discovery.v2.HealthCheckSpecifier";
  cluster_health_checks?:
    | ClusterHealthCheck[]
    | undefined;
  /** The default is 1 second. */
  interval?: Duration | undefined;
}

function createBaseCapability(): Capability {
  return { $type: "envoy.service.discovery.v2.Capability" };
}

export const Capability: MessageFns<Capability, "envoy.service.discovery.v2.Capability"> = {
  $type: "envoy.service.discovery.v2.Capability" as const,

  encode(message: Capability, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.health_check_protocols !== undefined && message.health_check_protocols.length !== 0) {
      writer.uint32(10).fork();
      for (const v of message.health_check_protocols) {
        writer.int32(capability_ProtocolToNumber(v));
      }
      writer.join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Capability {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCapability();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            if (message.health_check_protocols === undefined) {
              message.health_check_protocols = [];
            }
            message.health_check_protocols!.push(capability_ProtocolFromJSON(reader.int32()));

            continue;
          }

          if (tag === 10) {
            if (message.health_check_protocols === undefined) {
              message.health_check_protocols = [];
            }
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.health_check_protocols!.push(capability_ProtocolFromJSON(reader.int32()));
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Capability {
    return {
      $type: Capability.$type,
      health_check_protocols: globalThis.Array.isArray(object?.health_check_protocols)
        ? object.health_check_protocols.map((e: any) => capability_ProtocolFromJSON(e))
        : undefined,
    };
  },

  toJSON(message: Capability): unknown {
    const obj: any = {};
    if (message.health_check_protocols?.length) {
      obj.health_check_protocols = message.health_check_protocols.map((e) => capability_ProtocolToJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Capability>, I>>(base?: I): Capability {
    return Capability.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Capability>, I>>(object: I): Capability {
    const message = createBaseCapability();
    message.health_check_protocols = object.health_check_protocols?.map((e) => e) || undefined;
    return message;
  },
};

messageTypeRegistry.set(Capability.$type, Capability);

function createBaseHealthCheckRequest(): HealthCheckRequest {
  return { $type: "envoy.service.discovery.v2.HealthCheckRequest" };
}

export const HealthCheckRequest: MessageFns<HealthCheckRequest, "envoy.service.discovery.v2.HealthCheckRequest"> = {
  $type: "envoy.service.discovery.v2.HealthCheckRequest" as const,

  encode(message: HealthCheckRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.node !== undefined) {
      Node.encode(message.node, writer.uint32(10).fork()).join();
    }
    if (message.capability !== undefined) {
      Capability.encode(message.capability, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.node = Node.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.capability = Capability.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheckRequest {
    return {
      $type: HealthCheckRequest.$type,
      node: isSet(object.node) ? Node.fromJSON(object.node) : undefined,
      capability: isSet(object.capability) ? Capability.fromJSON(object.capability) : undefined,
    };
  },

  toJSON(message: HealthCheckRequest): unknown {
    const obj: any = {};
    if (message.node !== undefined) {
      obj.node = Node.toJSON(message.node);
    }
    if (message.capability !== undefined) {
      obj.capability = Capability.toJSON(message.capability);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheckRequest>, I>>(base?: I): HealthCheckRequest {
    return HealthCheckRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheckRequest>, I>>(object: I): HealthCheckRequest {
    const message = createBaseHealthCheckRequest();
    message.node = (object.node !== undefined && object.node !== null) ? Node.fromPartial(object.node) : undefined;
    message.capability = (object.capability !== undefined && object.capability !== null)
      ? Capability.fromPartial(object.capability)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(HealthCheckRequest.$type, HealthCheckRequest);

function createBaseEndpointHealth(): EndpointHealth {
  return { $type: "envoy.service.discovery.v2.EndpointHealth" };
}

export const EndpointHealth: MessageFns<EndpointHealth, "envoy.service.discovery.v2.EndpointHealth"> = {
  $type: "envoy.service.discovery.v2.EndpointHealth" as const,

  encode(message: EndpointHealth, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.endpoint !== undefined) {
      Endpoint.encode(message.endpoint, writer.uint32(10).fork()).join();
    }
    if (message.health_status !== undefined && message.health_status !== HealthStatus.UNKNOWN) {
      writer.uint32(16).int32(healthStatusToNumber(message.health_status));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EndpointHealth {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndpointHealth();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.endpoint = Endpoint.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.health_status = healthStatusFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EndpointHealth {
    return {
      $type: EndpointHealth.$type,
      endpoint: isSet(object.endpoint) ? Endpoint.fromJSON(object.endpoint) : undefined,
      health_status: isSet(object.health_status) ? healthStatusFromJSON(object.health_status) : undefined,
    };
  },

  toJSON(message: EndpointHealth): unknown {
    const obj: any = {};
    if (message.endpoint !== undefined) {
      obj.endpoint = Endpoint.toJSON(message.endpoint);
    }
    if (message.health_status !== undefined) {
      obj.health_status = healthStatusToJSON(message.health_status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EndpointHealth>, I>>(base?: I): EndpointHealth {
    return EndpointHealth.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EndpointHealth>, I>>(object: I): EndpointHealth {
    const message = createBaseEndpointHealth();
    message.endpoint = (object.endpoint !== undefined && object.endpoint !== null)
      ? Endpoint.fromPartial(object.endpoint)
      : undefined;
    message.health_status = object.health_status ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(EndpointHealth.$type, EndpointHealth);

function createBaseEndpointHealthResponse(): EndpointHealthResponse {
  return { $type: "envoy.service.discovery.v2.EndpointHealthResponse" };
}

export const EndpointHealthResponse: MessageFns<
  EndpointHealthResponse,
  "envoy.service.discovery.v2.EndpointHealthResponse"
> = {
  $type: "envoy.service.discovery.v2.EndpointHealthResponse" as const,

  encode(message: EndpointHealthResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.endpoints_health !== undefined && message.endpoints_health.length !== 0) {
      for (const v of message.endpoints_health) {
        EndpointHealth.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EndpointHealthResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndpointHealthResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.endpoints_health === undefined) {
            message.endpoints_health = [];
          }
          const el = EndpointHealth.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.endpoints_health!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EndpointHealthResponse {
    return {
      $type: EndpointHealthResponse.$type,
      endpoints_health: globalThis.Array.isArray(object?.endpoints_health)
        ? object.endpoints_health.map((e: any) => EndpointHealth.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: EndpointHealthResponse): unknown {
    const obj: any = {};
    if (message.endpoints_health?.length) {
      obj.endpoints_health = message.endpoints_health.map((e) => EndpointHealth.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EndpointHealthResponse>, I>>(base?: I): EndpointHealthResponse {
    return EndpointHealthResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EndpointHealthResponse>, I>>(object: I): EndpointHealthResponse {
    const message = createBaseEndpointHealthResponse();
    message.endpoints_health = object.endpoints_health?.map((e) => EndpointHealth.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(EndpointHealthResponse.$type, EndpointHealthResponse);

function createBaseHealthCheckRequestOrEndpointHealthResponse(): HealthCheckRequestOrEndpointHealthResponse {
  return { $type: "envoy.service.discovery.v2.HealthCheckRequestOrEndpointHealthResponse", request_type: undefined };
}

export const HealthCheckRequestOrEndpointHealthResponse: MessageFns<
  HealthCheckRequestOrEndpointHealthResponse,
  "envoy.service.discovery.v2.HealthCheckRequestOrEndpointHealthResponse"
> = {
  $type: "envoy.service.discovery.v2.HealthCheckRequestOrEndpointHealthResponse" as const,

  encode(message: HealthCheckRequestOrEndpointHealthResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.request_type?.$case) {
      case "health_check_request":
        HealthCheckRequest.encode(message.request_type.health_check_request, writer.uint32(10).fork()).join();
        break;
      case "endpoint_health_response":
        EndpointHealthResponse.encode(message.request_type.endpoint_health_response, writer.uint32(18).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckRequestOrEndpointHealthResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckRequestOrEndpointHealthResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.request_type = {
            $case: "health_check_request",
            health_check_request: HealthCheckRequest.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.request_type = {
            $case: "endpoint_health_response",
            endpoint_health_response: EndpointHealthResponse.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheckRequestOrEndpointHealthResponse {
    return {
      $type: HealthCheckRequestOrEndpointHealthResponse.$type,
      request_type: isSet(object.health_check_request)
        ? {
          $case: "health_check_request",
          health_check_request: HealthCheckRequest.fromJSON(object.health_check_request),
        }
        : isSet(object.endpoint_health_response)
        ? {
          $case: "endpoint_health_response",
          endpoint_health_response: EndpointHealthResponse.fromJSON(object.endpoint_health_response),
        }
        : undefined,
    };
  },

  toJSON(message: HealthCheckRequestOrEndpointHealthResponse): unknown {
    const obj: any = {};
    if (message.request_type?.$case === "health_check_request") {
      obj.health_check_request = HealthCheckRequest.toJSON(message.request_type.health_check_request);
    }
    if (message.request_type?.$case === "endpoint_health_response") {
      obj.endpoint_health_response = EndpointHealthResponse.toJSON(message.request_type.endpoint_health_response);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheckRequestOrEndpointHealthResponse>, I>>(
    base?: I,
  ): HealthCheckRequestOrEndpointHealthResponse {
    return HealthCheckRequestOrEndpointHealthResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheckRequestOrEndpointHealthResponse>, I>>(
    object: I,
  ): HealthCheckRequestOrEndpointHealthResponse {
    const message = createBaseHealthCheckRequestOrEndpointHealthResponse();
    if (
      object.request_type?.$case === "health_check_request" &&
      object.request_type?.health_check_request !== undefined &&
      object.request_type?.health_check_request !== null
    ) {
      message.request_type = {
        $case: "health_check_request",
        health_check_request: HealthCheckRequest.fromPartial(object.request_type.health_check_request),
      };
    }
    if (
      object.request_type?.$case === "endpoint_health_response" &&
      object.request_type?.endpoint_health_response !== undefined &&
      object.request_type?.endpoint_health_response !== null
    ) {
      message.request_type = {
        $case: "endpoint_health_response",
        endpoint_health_response: EndpointHealthResponse.fromPartial(object.request_type.endpoint_health_response),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(HealthCheckRequestOrEndpointHealthResponse.$type, HealthCheckRequestOrEndpointHealthResponse);

function createBaseLocalityEndpoints(): LocalityEndpoints {
  return { $type: "envoy.service.discovery.v2.LocalityEndpoints" };
}

export const LocalityEndpoints: MessageFns<LocalityEndpoints, "envoy.service.discovery.v2.LocalityEndpoints"> = {
  $type: "envoy.service.discovery.v2.LocalityEndpoints" as const,

  encode(message: LocalityEndpoints, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.locality !== undefined) {
      Locality.encode(message.locality, writer.uint32(10).fork()).join();
    }
    if (message.endpoints !== undefined && message.endpoints.length !== 0) {
      for (const v of message.endpoints) {
        Endpoint.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocalityEndpoints {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocalityEndpoints();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.locality = Locality.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.endpoints === undefined) {
            message.endpoints = [];
          }
          const el = Endpoint.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.endpoints!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocalityEndpoints {
    return {
      $type: LocalityEndpoints.$type,
      locality: isSet(object.locality) ? Locality.fromJSON(object.locality) : undefined,
      endpoints: globalThis.Array.isArray(object?.endpoints)
        ? object.endpoints.map((e: any) => Endpoint.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: LocalityEndpoints): unknown {
    const obj: any = {};
    if (message.locality !== undefined) {
      obj.locality = Locality.toJSON(message.locality);
    }
    if (message.endpoints?.length) {
      obj.endpoints = message.endpoints.map((e) => Endpoint.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LocalityEndpoints>, I>>(base?: I): LocalityEndpoints {
    return LocalityEndpoints.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LocalityEndpoints>, I>>(object: I): LocalityEndpoints {
    const message = createBaseLocalityEndpoints();
    message.locality = (object.locality !== undefined && object.locality !== null)
      ? Locality.fromPartial(object.locality)
      : undefined;
    message.endpoints = object.endpoints?.map((e) => Endpoint.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(LocalityEndpoints.$type, LocalityEndpoints);

function createBaseClusterHealthCheck(): ClusterHealthCheck {
  return { $type: "envoy.service.discovery.v2.ClusterHealthCheck" };
}

export const ClusterHealthCheck: MessageFns<ClusterHealthCheck, "envoy.service.discovery.v2.ClusterHealthCheck"> = {
  $type: "envoy.service.discovery.v2.ClusterHealthCheck" as const,

  encode(message: ClusterHealthCheck, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cluster_name !== undefined && message.cluster_name !== "") {
      writer.uint32(10).string(message.cluster_name);
    }
    if (message.health_checks !== undefined && message.health_checks.length !== 0) {
      for (const v of message.health_checks) {
        HealthCheck.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.locality_endpoints !== undefined && message.locality_endpoints.length !== 0) {
      for (const v of message.locality_endpoints) {
        LocalityEndpoints.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClusterHealthCheck {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClusterHealthCheck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cluster_name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.health_checks === undefined) {
            message.health_checks = [];
          }
          const el = HealthCheck.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.health_checks!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.locality_endpoints === undefined) {
            message.locality_endpoints = [];
          }
          const el = LocalityEndpoints.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.locality_endpoints!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClusterHealthCheck {
    return {
      $type: ClusterHealthCheck.$type,
      cluster_name: isSet(object.cluster_name) ? globalThis.String(object.cluster_name) : undefined,
      health_checks: globalThis.Array.isArray(object?.health_checks)
        ? object.health_checks.map((e: any) => HealthCheck.fromJSON(e))
        : undefined,
      locality_endpoints: globalThis.Array.isArray(object?.locality_endpoints)
        ? object.locality_endpoints.map((e: any) => LocalityEndpoints.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: ClusterHealthCheck): unknown {
    const obj: any = {};
    if (message.cluster_name !== undefined) {
      obj.cluster_name = message.cluster_name;
    }
    if (message.health_checks?.length) {
      obj.health_checks = message.health_checks.map((e) => HealthCheck.toJSON(e));
    }
    if (message.locality_endpoints?.length) {
      obj.locality_endpoints = message.locality_endpoints.map((e) => LocalityEndpoints.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClusterHealthCheck>, I>>(base?: I): ClusterHealthCheck {
    return ClusterHealthCheck.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClusterHealthCheck>, I>>(object: I): ClusterHealthCheck {
    const message = createBaseClusterHealthCheck();
    message.cluster_name = object.cluster_name ?? undefined;
    message.health_checks = object.health_checks?.map((e) => HealthCheck.fromPartial(e)) || undefined;
    message.locality_endpoints = object.locality_endpoints?.map((e) => LocalityEndpoints.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(ClusterHealthCheck.$type, ClusterHealthCheck);

function createBaseHealthCheckSpecifier(): HealthCheckSpecifier {
  return { $type: "envoy.service.discovery.v2.HealthCheckSpecifier" };
}

export const HealthCheckSpecifier: MessageFns<HealthCheckSpecifier, "envoy.service.discovery.v2.HealthCheckSpecifier"> =
  {
    $type: "envoy.service.discovery.v2.HealthCheckSpecifier" as const,

    encode(message: HealthCheckSpecifier, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
      if (message.cluster_health_checks !== undefined && message.cluster_health_checks.length !== 0) {
        for (const v of message.cluster_health_checks) {
          ClusterHealthCheck.encode(v!, writer.uint32(10).fork()).join();
        }
      }
      if (message.interval !== undefined) {
        Duration.encode(message.interval, writer.uint32(18).fork()).join();
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckSpecifier {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseHealthCheckSpecifier();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            if (message.cluster_health_checks === undefined) {
              message.cluster_health_checks = [];
            }
            const el = ClusterHealthCheck.decode(reader, reader.uint32());
            if (el !== undefined) {
              message.cluster_health_checks!.push(el);
            }
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.interval = Duration.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): HealthCheckSpecifier {
      return {
        $type: HealthCheckSpecifier.$type,
        cluster_health_checks: globalThis.Array.isArray(object?.cluster_health_checks)
          ? object.cluster_health_checks.map((e: any) => ClusterHealthCheck.fromJSON(e))
          : undefined,
        interval: isSet(object.interval) ? Duration.fromJSON(object.interval) : undefined,
      };
    },

    toJSON(message: HealthCheckSpecifier): unknown {
      const obj: any = {};
      if (message.cluster_health_checks?.length) {
        obj.cluster_health_checks = message.cluster_health_checks.map((e) => ClusterHealthCheck.toJSON(e));
      }
      if (message.interval !== undefined) {
        obj.interval = Duration.toJSON(message.interval);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<HealthCheckSpecifier>, I>>(base?: I): HealthCheckSpecifier {
      return HealthCheckSpecifier.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<HealthCheckSpecifier>, I>>(object: I): HealthCheckSpecifier {
      const message = createBaseHealthCheckSpecifier();
      message.cluster_health_checks = object.cluster_health_checks?.map((e) => ClusterHealthCheck.fromPartial(e)) ||
        undefined;
      message.interval = (object.interval !== undefined && object.interval !== null)
        ? Duration.fromPartial(object.interval)
        : undefined;
      return message;
    },
  };

messageTypeRegistry.set(HealthCheckSpecifier.$type, HealthCheckSpecifier);

/**
 * HDS is Health Discovery Service. It compliments Envoy’s health checking
 * service by designating this Envoy to be a healthchecker for a subset of hosts
 * in the cluster. The status of these health checks will be reported to the
 * management server, where it can be aggregated etc and redistributed back to
 * Envoy through EDS.
 */
export interface HealthDiscoveryService {
  /**
   * 1. Envoy starts up and if its can_healthcheck option in the static
   *    bootstrap config is enabled, sends HealthCheckRequest to the management
   *    server. It supplies its capabilities (which protocol it can health check
   *    with, what zone it resides in, etc.).
   * 2. In response to (1), the management server designates this Envoy as a
   *    healthchecker to health check a subset of all upstream hosts for a given
   *    cluster (for example upstream Host 1 and Host 2). It streams
   *    HealthCheckSpecifier messages with cluster related configuration for all
   *    clusters this Envoy is designated to health check. Subsequent
   *    HealthCheckSpecifier message will be sent on changes to:
   *    a. Endpoints to health checks
   *    b. Per cluster configuration change
   * 3. Envoy creates a health probe based on the HealthCheck config and sends
   *    it to endpoint(ip:port) of Host 1 and 2. Based on the HealthCheck
   *    configuration Envoy waits upon the arrival of the probe response and
   *    looks at the content of the response to decide whether the endpoint is
   *    healthy or not. If a response hasn't been received within the timeout
   *    interval, the endpoint health status is considered TIMEOUT.
   * 4. Envoy reports results back in an EndpointHealthResponse message.
   *    Envoy streams responses as often as the interval configured by the
   *    management server in HealthCheckSpecifier.
   * 5. The management Server collects health statuses for all endpoints in the
   *    cluster (for all clusters) and uses this information to construct
   *    EndpointDiscoveryResponse messages.
   * 6. Once Envoy has a list of upstream endpoints to send traffic to, it load
   *    balances traffic to them without additional health checking. It may
   *    use inline healthcheck (i.e. consider endpoint UNHEALTHY if connection
   *    failed to a particular endpoint to account for health status propagation
   *    delay between HDS and EDS).
   * By default, can_healthcheck is true. If can_healthcheck is false, Cluster
   * configuration may not contain HealthCheck message.
   * TODO(htuch): How is can_healthcheck communicated to CDS to ensure the above
   * invariant?
   * TODO(htuch): Add @amb67's diagram.
   */
  StreamHealthCheck(request: Observable<HealthCheckRequestOrEndpointHealthResponse>): Observable<HealthCheckSpecifier>;
  /**
   * TODO(htuch): Unlike the gRPC version, there is no stream-based binding of
   * request/response. Should we add an identifier to the HealthCheckSpecifier
   * to bind with the response?
   */
  FetchHealthCheck(request: HealthCheckRequestOrEndpointHealthResponse): Promise<HealthCheckSpecifier>;
}

export const HealthDiscoveryServiceServiceName = "envoy.service.discovery.v2.HealthDiscoveryService";
export class HealthDiscoveryServiceClientImpl implements HealthDiscoveryService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || HealthDiscoveryServiceServiceName;
    this.rpc = rpc;
    this.StreamHealthCheck = this.StreamHealthCheck.bind(this);
    this.FetchHealthCheck = this.FetchHealthCheck.bind(this);
  }
  StreamHealthCheck(request: Observable<HealthCheckRequestOrEndpointHealthResponse>): Observable<HealthCheckSpecifier> {
    const data = request.pipe(map((request) => HealthCheckRequestOrEndpointHealthResponse.encode(request).finish()));
    const result = this.rpc.bidirectionalStreamingRequest(this.service, "StreamHealthCheck", data);
    return result.pipe(map((data) => HealthCheckSpecifier.decode(new BinaryReader(data))));
  }

  FetchHealthCheck(request: HealthCheckRequestOrEndpointHealthResponse): Promise<HealthCheckSpecifier> {
    const data = HealthCheckRequestOrEndpointHealthResponse.encode(request).finish();
    const promise = this.rpc.request(this.service, "FetchHealthCheck", data);
    return promise.then((data) => HealthCheckSpecifier.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
  clientStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Promise<Uint8Array>;
  serverStreamingRequest(service: string, method: string, data: Uint8Array): Observable<Uint8Array>;
  bidirectionalStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Observable<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
