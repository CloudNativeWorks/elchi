// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/api/v2/cluster.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Any } from "../../../google/protobuf/any";
import { Duration } from "../../../google/protobuf/duration";
import { Struct } from "../../../google/protobuf/struct";
import { UInt32Value, UInt64Value } from "../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../typeRegistry";
import { Percent } from "../../type/percent";
import { UpstreamTlsContext } from "./auth/tls";
import { CircuitBreakers } from "./cluster/circuit_breaker";
import { Filter } from "./cluster/filter";
import { OutlierDetection } from "./cluster/outlier_detection";
import { Address, BindConfig, TcpKeepalive } from "./core/address";
import { Metadata, TransportSocket } from "./core/base";
import { ConfigSource } from "./core/config_source";
import { HealthCheck } from "./core/health_check";
import {
  Http1ProtocolOptions,
  Http2ProtocolOptions,
  HttpProtocolOptions,
  UpstreamHttpProtocolOptions,
} from "./core/protocol";
import { ClusterLoadAssignment } from "./endpoint";

export const protobufPackage = "envoy.api.v2";

/**
 * Configuration for a single upstream cluster.
 * [#next-free-field: 48]
 */
export interface Cluster {
  $type: "envoy.api.v2.Cluster";
  /**
   * Configuration to use different transport sockets for different endpoints.
   * The entry of *envoy.transport_socket_match* in the
   * :ref:`LbEndpoint.Metadata <envoy_api_field_endpoint.LbEndpoint.metadata>`
   * is used to match against the transport sockets as they appear in the list. The first
   * :ref:`match <envoy_api_msg_Cluster.TransportSocketMatch>` is used.
   * For example, with the following match
   *
   * .. code-block:: yaml
   *
   *  transport_socket_matches:
   *  - name: "enableMTLS"
   *    match:
   *      acceptMTLS: true
   *    transport_socket:
   *      name: envoy.transport_sockets.tls
   *      config: { ... } # tls socket configuration
   *  - name: "defaultToPlaintext"
   *    match: {}
   *    transport_socket:
   *      name: envoy.transport_sockets.raw_buffer
   *
   * Connections to the endpoints whose metadata value under *envoy.transport_socket_match*
   * having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
   *
   * If a :ref:`socket match <envoy_api_msg_Cluster.TransportSocketMatch>` with empty match
   * criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
   * socket match in case above.
   *
   * If an endpoint metadata's value under *envoy.transport_socket_match* does not match any
   * *TransportSocketMatch*, socket configuration fallbacks to use the *tls_context* or
   * *transport_socket* specified in this cluster.
   *
   * This field allows gradual and flexible transport socket configuration changes.
   *
   * The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
   * an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
   * "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
   * has "acceptPlaintext": "true" metadata information.
   *
   * Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
   * traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
   * *TransportSocketMatch* in this field. Other client Envoys receive CDS without
   * *transport_socket_match* set, and still send plain text traffic to the same cluster.
   *
   * [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
   */
  transport_socket_matches?:
    | Cluster_TransportSocketMatch[]
    | undefined;
  /**
   * Supplies the name of the cluster which must be unique across all clusters.
   * The cluster name is used when emitting
   * :ref:`statistics <config_cluster_manager_cluster_stats>` if :ref:`alt_stat_name
   * <envoy_api_field_Cluster.alt_stat_name>` is not provided.
   * Any ``:`` in the cluster name will be converted to ``_`` when emitting statistics.
   */
  name?:
    | string
    | undefined;
  /**
   * An optional alternative to the cluster name to be used while emitting stats.
   * Any ``:`` in the name will be converted to ``_`` when emitting statistics. This should not be
   * confused with :ref:`Router Filter Header
   * <config_http_filters_router_x-envoy-upstream-alt-stat-name>`.
   */
  alt_stat_name?: string | undefined;
  cluster_discovery_type?:
    | //
    /**
     * The :ref:`service discovery type <arch_overview_service_discovery_types>`
     * to use for resolving the cluster.
     */
    { $case: "type"; type: Cluster_DiscoveryType }
    | //
    /** The custom cluster type. */
    { $case: "cluster_type"; cluster_type: Cluster_CustomClusterType }
    | undefined;
  /** Configuration to use for EDS updates for the Cluster. */
  eds_cluster_config?:
    | Cluster_EdsClusterConfig
    | undefined;
  /** The timeout for new network connections to hosts in the cluster. */
  connect_timeout?:
    | Duration
    | undefined;
  /**
   * Soft limit on size of the cluster’s connections read and write buffers. If
   * unspecified, an implementation defined default is applied (1MiB).
   */
  per_connection_buffer_limit_bytes?:
    | number
    | undefined;
  /**
   * The :ref:`load balancer type <arch_overview_load_balancing_types>` to use
   * when picking a host in the cluster.
   */
  lb_policy?:
    | Cluster_LbPolicy
    | undefined;
  /**
   * If the service discovery type is
   * :ref:`STATIC<envoy_api_enum_value_Cluster.DiscoveryType.STATIC>`,
   * :ref:`STRICT_DNS<envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`
   * or :ref:`LOGICAL_DNS<envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`,
   * then hosts is required.
   *
   * .. attention::
   *
   *   **This field is deprecated**. Set the
   *   :ref:`load_assignment<envoy_api_field_Cluster.load_assignment>` field instead.
   *
   * @deprecated
   */
  hosts?:
    | Address[]
    | undefined;
  /**
   * Setting this is required for specifying members of
   * :ref:`STATIC<envoy_api_enum_value_Cluster.DiscoveryType.STATIC>`,
   * :ref:`STRICT_DNS<envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`
   * or :ref:`LOGICAL_DNS<envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>` clusters.
   * This field supersedes the *hosts* field in the v2 API.
   *
   * .. attention::
   *
   *   Setting this allows non-EDS cluster types to contain embedded EDS equivalent
   *   :ref:`endpoint assignments<envoy_api_msg_ClusterLoadAssignment>`.
   */
  load_assignment?:
    | ClusterLoadAssignment
    | undefined;
  /**
   * Optional :ref:`active health checking <arch_overview_health_checking>`
   * configuration for the cluster. If no
   * configuration is specified no health checking will be done and all cluster
   * members will be considered healthy at all times.
   */
  health_checks?:
    | HealthCheck[]
    | undefined;
  /**
   * Optional maximum requests for a single upstream connection. This parameter
   * is respected by both the HTTP/1.1 and HTTP/2 connection pool
   * implementations. If not specified, there is no limit. Setting this
   * parameter to 1 will effectively disable keep alive.
   */
  max_requests_per_connection?:
    | number
    | undefined;
  /** Optional :ref:`circuit breaking <arch_overview_circuit_break>` for the cluster. */
  circuit_breakers?:
    | CircuitBreakers
    | undefined;
  /**
   * The TLS configuration for connections to the upstream cluster.
   *
   * .. attention::
   *
   *   **This field is deprecated**. Use `transport_socket` with name `tls` instead. If both are
   *   set, `transport_socket` takes priority.
   *
   * @deprecated
   */
  tls_context?:
    | UpstreamTlsContext
    | undefined;
  /**
   * HTTP protocol options that are applied only to upstream HTTP connections.
   * These options apply to all HTTP versions.
   */
  upstream_http_protocol_options?:
    | UpstreamHttpProtocolOptions
    | undefined;
  /**
   * Additional options when handling HTTP requests upstream. These options will be applicable to
   * both HTTP1 and HTTP2 requests.
   */
  common_http_protocol_options?:
    | HttpProtocolOptions
    | undefined;
  /** Additional options when handling HTTP1 requests. */
  http_protocol_options?:
    | Http1ProtocolOptions
    | undefined;
  /**
   * Even if default HTTP2 protocol options are desired, this field must be
   * set so that Envoy will assume that the upstream supports HTTP/2 when
   * making new HTTP connection pool connections. Currently, Envoy only
   * supports prior knowledge for upstream connections. Even if TLS is used
   * with ALPN, `http2_protocol_options` must be specified. As an aside this allows HTTP/2
   * connections to happen over plain text.
   */
  http2_protocol_options?:
    | Http2ProtocolOptions
    | undefined;
  /**
   * The extension_protocol_options field is used to provide extension-specific protocol options
   * for upstream connections. The key should match the extension filter name, such as
   * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
   * specific options.
   *
   * @deprecated
   */
  extension_protocol_options?:
    | Map<string, { [key: string]: any } | undefined>
    | undefined;
  /**
   * The extension_protocol_options field is used to provide extension-specific protocol options
   * for upstream connections. The key should match the extension filter name, such as
   * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
   * specific options.
   */
  typed_extension_protocol_options?:
    | Map<string, Any>
    | undefined;
  /**
   * If the DNS refresh rate is specified and the cluster type is either
   * :ref:`STRICT_DNS<envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`,
   * or :ref:`LOGICAL_DNS<envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`,
   * this value is used as the cluster’s DNS refresh
   * rate. The value configured must be at least 1ms. If this setting is not specified, the
   * value defaults to 5000ms. For cluster types other than
   * :ref:`STRICT_DNS<envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`
   * and :ref:`LOGICAL_DNS<envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`
   * this setting is ignored.
   */
  dns_refresh_rate?:
    | Duration
    | undefined;
  /**
   * If the DNS failure refresh rate is specified and the cluster type is either
   * :ref:`STRICT_DNS<envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`,
   * or :ref:`LOGICAL_DNS<envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`,
   * this is used as the cluster’s DNS refresh rate when requests are failing. If this setting is
   * not specified, the failure refresh rate defaults to the DNS refresh rate. For cluster types
   * other than :ref:`STRICT_DNS<envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>` and
   * :ref:`LOGICAL_DNS<envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>` this setting is
   * ignored.
   */
  dns_failure_refresh_rate?:
    | Cluster_RefreshRate
    | undefined;
  /**
   * Optional configuration for setting cluster's DNS refresh rate. If the value is set to true,
   * cluster's DNS refresh rate will be set to resource record's TTL which comes from DNS
   * resolution.
   */
  respect_dns_ttl?:
    | boolean
    | undefined;
  /**
   * The DNS IP address resolution policy. If this setting is not specified, the
   * value defaults to
   * :ref:`AUTO<envoy_api_enum_value_Cluster.DnsLookupFamily.AUTO>`.
   */
  dns_lookup_family?:
    | Cluster_DnsLookupFamily
    | undefined;
  /**
   * If DNS resolvers are specified and the cluster type is either
   * :ref:`STRICT_DNS<envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`,
   * or :ref:`LOGICAL_DNS<envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`,
   * this value is used to specify the cluster’s dns resolvers.
   * If this setting is not specified, the value defaults to the default
   * resolver, which uses /etc/resolv.conf for configuration. For cluster types
   * other than
   * :ref:`STRICT_DNS<envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`
   * and :ref:`LOGICAL_DNS<envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`
   * this setting is ignored.
   * Setting this value causes failure if the
   * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
   * server startup. Apple's API only allows overriding DNS resolvers via system settings.
   */
  dns_resolvers?:
    | Address[]
    | undefined;
  /**
   * [#next-major-version: Reconcile DNS options in a single message.]
   * Always use TCP queries instead of UDP queries for DNS lookups.
   * Setting this value causes failure if the
   * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
   * server startup. Apple' API only uses UDP for DNS resolution.
   */
  use_tcp_for_dns_lookups?:
    | boolean
    | undefined;
  /**
   * If specified, outlier detection will be enabled for this upstream cluster.
   * Each of the configuration values can be overridden via
   * :ref:`runtime values <config_cluster_manager_cluster_runtime_outlier_detection>`.
   */
  outlier_detection?:
    | OutlierDetection
    | undefined;
  /**
   * The interval for removing stale hosts from a cluster type
   * :ref:`ORIGINAL_DST<envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST>`.
   * Hosts are considered stale if they have not been used
   * as upstream destinations during this interval. New hosts are added
   * to original destination clusters on demand as new connections are
   * redirected to Envoy, causing the number of hosts in the cluster to
   * grow over time. Hosts that are not stale (they are actively used as
   * destinations) are kept in the cluster, which allows connections to
   * them remain open, saving the latency that would otherwise be spent
   * on opening new connections. If this setting is not specified, the
   * value defaults to 5000ms. For cluster types other than
   * :ref:`ORIGINAL_DST<envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST>`
   * this setting is ignored.
   */
  cleanup_interval?:
    | Duration
    | undefined;
  /**
   * Optional configuration used to bind newly established upstream connections.
   * This overrides any bind_config specified in the bootstrap proto.
   * If the address and port are empty, no bind will be performed.
   */
  upstream_bind_config?:
    | BindConfig
    | undefined;
  /** Configuration for load balancing subsetting. */
  lb_subset_config?:
    | Cluster_LbSubsetConfig
    | undefined;
  /**
   * Optional configuration for the load balancing algorithm selected by
   * LbPolicy. Currently only
   * :ref:`RING_HASH<envoy_api_enum_value_Cluster.LbPolicy.RING_HASH>` and
   * :ref:`LEAST_REQUEST<envoy_api_enum_value_Cluster.LbPolicy.LEAST_REQUEST>`
   * has additional configuration options.
   * Specifying ring_hash_lb_config or least_request_lb_config without setting the corresponding
   * LbPolicy will generate an error at runtime.
   */
  lb_config?:
    | //
    /** Optional configuration for the Ring Hash load balancing policy. */
    { $case: "ring_hash_lb_config"; ring_hash_lb_config: Cluster_RingHashLbConfig }
    | //
    /** Optional configuration for the Original Destination load balancing policy. */
    { $case: "original_dst_lb_config"; original_dst_lb_config: Cluster_OriginalDstLbConfig }
    | //
    /** Optional configuration for the LeastRequest load balancing policy. */
    { $case: "least_request_lb_config"; least_request_lb_config: Cluster_LeastRequestLbConfig }
    | undefined;
  /** Common configuration for all load balancer implementations. */
  common_lb_config?:
    | Cluster_CommonLbConfig
    | undefined;
  /**
   * Optional custom transport socket implementation to use for upstream connections.
   * To setup TLS, set a transport socket with name `tls` and
   * :ref:`UpstreamTlsContexts <envoy_api_msg_auth.UpstreamTlsContext>` in the `typed_config`.
   * If no transport socket configuration is specified, new connections
   * will be set up with plaintext.
   */
  transport_socket?:
    | TransportSocket
    | undefined;
  /**
   * The Metadata field can be used to provide additional information about the
   * cluster. It can be used for stats, logging, and varying filter behavior.
   * Fields should use reverse DNS notation to denote which entity within Envoy
   * will need the information. For instance, if the metadata is intended for
   * the Router filter, the filter name should be specified as *envoy.filters.http.router*.
   */
  metadata?:
    | Metadata
    | undefined;
  /** Determines how Envoy selects the protocol used to speak to upstream hosts. */
  protocol_selection?:
    | Cluster_ClusterProtocolSelection
    | undefined;
  /** Optional options for upstream connections. */
  upstream_connection_options?:
    | UpstreamConnectionOptions
    | undefined;
  /**
   * If an upstream host becomes unhealthy (as determined by the configured health checks
   * or outlier detection), immediately close all connections to the failed host.
   *
   * .. note::
   *
   *   This is currently only supported for connections created by tcp_proxy.
   *
   * .. note::
   *
   *   The current implementation of this feature closes all connections immediately when
   *   the unhealthy status is detected. If there are a large number of connections open
   *   to an upstream host that becomes unhealthy, Envoy may spend a substantial amount of
   *   time exclusively closing these connections, and not processing any other traffic.
   */
  close_connections_on_host_health_failure?:
    | boolean
    | undefined;
  /**
   * If set to true, Envoy will ignore the health value of a host when processing its removal
   * from service discovery. This means that if active health checking is used, Envoy will *not*
   * wait for the endpoint to go unhealthy before removing it.
   */
  drain_connections_on_host_removal?:
    | boolean
    | undefined;
  /**
   * An (optional) network filter chain, listed in the order the filters should be applied.
   * The chain will be applied to all outgoing connections that Envoy makes to the upstream
   * servers of this cluster.
   */
  filters?:
    | Filter[]
    | undefined;
  /**
   * [#not-implemented-hide:] New mechanism for LB policy configuration. Used only if the
   * :ref:`lb_policy<envoy_api_field_Cluster.lb_policy>` field has the value
   * :ref:`LOAD_BALANCING_POLICY_CONFIG<envoy_api_enum_value_Cluster.LbPolicy.LOAD_BALANCING_POLICY_CONFIG>`.
   */
  load_balancing_policy?:
    | LoadBalancingPolicy
    | undefined;
  /**
   * [#not-implemented-hide:]
   * If present, tells the client where to send load reports via LRS. If not present, the
   * client will fall back to a client-side default, which may be either (a) don't send any
   * load reports or (b) send load reports for all clusters to a single default server
   * (which may be configured in the bootstrap file).
   *
   * Note that if multiple clusters point to the same LRS server, the client may choose to
   * create a separate stream for each cluster or it may choose to coalesce the data for
   * multiple clusters onto a single stream. Either way, the client must make sure to send
   * the data for any given cluster on no more than one stream.
   *
   * [#next-major-version: In the v3 API, we should consider restructuring this somehow,
   * maybe by allowing LRS to go on the ADS stream, or maybe by moving some of the negotiation
   * from the LRS stream here.]
   */
  lrs_server?:
    | ConfigSource
    | undefined;
  /**
   * If track_timeout_budgets is true, the :ref:`timeout budget histograms
   * <config_cluster_manager_cluster_stats_timeout_budgets>` will be published for each
   * request. These show what percentage of a request's per try and global timeout was used. A value
   * of 0 would indicate that none of the timeout was used or that the timeout was infinite. A value
   * of 100 would indicate that the request took the entirety of the timeout given to it.
   */
  track_timeout_budgets?: boolean | undefined;
}

/**
 * Refer to :ref:`service discovery type <arch_overview_service_discovery_types>`
 * for an explanation on each type.
 */
export enum Cluster_DiscoveryType {
  /**
   * STATIC - Refer to the :ref:`static discovery type<arch_overview_service_discovery_types_static>`
   * for an explanation.
   */
  STATIC = "STATIC",
  /**
   * STRICT_DNS - Refer to the :ref:`strict DNS discovery
   * type<arch_overview_service_discovery_types_strict_dns>`
   * for an explanation.
   */
  STRICT_DNS = "STRICT_DNS",
  /**
   * LOGICAL_DNS - Refer to the :ref:`logical DNS discovery
   * type<arch_overview_service_discovery_types_logical_dns>`
   * for an explanation.
   */
  LOGICAL_DNS = "LOGICAL_DNS",
  /**
   * EDS - Refer to the :ref:`service discovery type<arch_overview_service_discovery_types_eds>`
   * for an explanation.
   */
  EDS = "EDS",
  /**
   * ORIGINAL_DST - Refer to the :ref:`original destination discovery
   * type<arch_overview_service_discovery_types_original_destination>`
   * for an explanation.
   */
  ORIGINAL_DST = "ORIGINAL_DST",
}

export function cluster_DiscoveryTypeFromJSON(object: any): Cluster_DiscoveryType {
  switch (object) {
    case 0:
    case "STATIC":
      return Cluster_DiscoveryType.STATIC;
    case 1:
    case "STRICT_DNS":
      return Cluster_DiscoveryType.STRICT_DNS;
    case 2:
    case "LOGICAL_DNS":
      return Cluster_DiscoveryType.LOGICAL_DNS;
    case 3:
    case "EDS":
      return Cluster_DiscoveryType.EDS;
    case 4:
    case "ORIGINAL_DST":
      return Cluster_DiscoveryType.ORIGINAL_DST;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Cluster_DiscoveryType");
  }
}

export function cluster_DiscoveryTypeToJSON(object: Cluster_DiscoveryType): string {
  switch (object) {
    case Cluster_DiscoveryType.STATIC:
      return "STATIC";
    case Cluster_DiscoveryType.STRICT_DNS:
      return "STRICT_DNS";
    case Cluster_DiscoveryType.LOGICAL_DNS:
      return "LOGICAL_DNS";
    case Cluster_DiscoveryType.EDS:
      return "EDS";
    case Cluster_DiscoveryType.ORIGINAL_DST:
      return "ORIGINAL_DST";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Cluster_DiscoveryType");
  }
}

export function cluster_DiscoveryTypeToNumber(object: Cluster_DiscoveryType): number {
  switch (object) {
    case Cluster_DiscoveryType.STATIC:
      return 0;
    case Cluster_DiscoveryType.STRICT_DNS:
      return 1;
    case Cluster_DiscoveryType.LOGICAL_DNS:
      return 2;
    case Cluster_DiscoveryType.EDS:
      return 3;
    case Cluster_DiscoveryType.ORIGINAL_DST:
      return 4;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Cluster_DiscoveryType");
  }
}

/**
 * Refer to :ref:`load balancer type <arch_overview_load_balancing_types>` architecture
 * overview section for information on each type.
 */
export enum Cluster_LbPolicy {
  /**
   * ROUND_ROBIN - Refer to the :ref:`round robin load balancing
   * policy<arch_overview_load_balancing_types_round_robin>`
   * for an explanation.
   */
  ROUND_ROBIN = "ROUND_ROBIN",
  /**
   * LEAST_REQUEST - Refer to the :ref:`least request load balancing
   * policy<arch_overview_load_balancing_types_least_request>`
   * for an explanation.
   */
  LEAST_REQUEST = "LEAST_REQUEST",
  /**
   * RING_HASH - Refer to the :ref:`ring hash load balancing
   * policy<arch_overview_load_balancing_types_ring_hash>`
   * for an explanation.
   */
  RING_HASH = "RING_HASH",
  /**
   * RANDOM - Refer to the :ref:`random load balancing
   * policy<arch_overview_load_balancing_types_random>`
   * for an explanation.
   */
  RANDOM = "RANDOM",
  /**
   * ORIGINAL_DST_LB - Refer to the :ref:`original destination load balancing
   * policy<arch_overview_load_balancing_types_original_destination>`
   * for an explanation.
   *
   * .. attention::
   *
   *   **This load balancing policy is deprecated**. Use CLUSTER_PROVIDED instead.
   *
   * @deprecated
   */
  ORIGINAL_DST_LB = "ORIGINAL_DST_LB",
  /**
   * MAGLEV - Refer to the :ref:`Maglev load balancing policy<arch_overview_load_balancing_types_maglev>`
   * for an explanation.
   */
  MAGLEV = "MAGLEV",
  /**
   * CLUSTER_PROVIDED - This load balancer type must be specified if the configured cluster provides a cluster
   * specific load balancer. Consult the configured cluster's documentation for whether to set
   * this option or not.
   */
  CLUSTER_PROVIDED = "CLUSTER_PROVIDED",
  /**
   * LOAD_BALANCING_POLICY_CONFIG - [#not-implemented-hide:] Use the new :ref:`load_balancing_policy
   * <envoy_api_field_Cluster.load_balancing_policy>` field to determine the LB policy.
   * [#next-major-version: In the v3 API, we should consider deprecating the lb_policy field
   * and instead using the new load_balancing_policy field as the one and only mechanism for
   * configuring this.]
   */
  LOAD_BALANCING_POLICY_CONFIG = "LOAD_BALANCING_POLICY_CONFIG",
}

export function cluster_LbPolicyFromJSON(object: any): Cluster_LbPolicy {
  switch (object) {
    case 0:
    case "ROUND_ROBIN":
      return Cluster_LbPolicy.ROUND_ROBIN;
    case 1:
    case "LEAST_REQUEST":
      return Cluster_LbPolicy.LEAST_REQUEST;
    case 2:
    case "RING_HASH":
      return Cluster_LbPolicy.RING_HASH;
    case 3:
    case "RANDOM":
      return Cluster_LbPolicy.RANDOM;
    case 4:
    case "ORIGINAL_DST_LB":
      return Cluster_LbPolicy.ORIGINAL_DST_LB;
    case 5:
    case "MAGLEV":
      return Cluster_LbPolicy.MAGLEV;
    case 6:
    case "CLUSTER_PROVIDED":
      return Cluster_LbPolicy.CLUSTER_PROVIDED;
    case 7:
    case "LOAD_BALANCING_POLICY_CONFIG":
      return Cluster_LbPolicy.LOAD_BALANCING_POLICY_CONFIG;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Cluster_LbPolicy");
  }
}

export function cluster_LbPolicyToJSON(object: Cluster_LbPolicy): string {
  switch (object) {
    case Cluster_LbPolicy.ROUND_ROBIN:
      return "ROUND_ROBIN";
    case Cluster_LbPolicy.LEAST_REQUEST:
      return "LEAST_REQUEST";
    case Cluster_LbPolicy.RING_HASH:
      return "RING_HASH";
    case Cluster_LbPolicy.RANDOM:
      return "RANDOM";
    case Cluster_LbPolicy.ORIGINAL_DST_LB:
      return "ORIGINAL_DST_LB";
    case Cluster_LbPolicy.MAGLEV:
      return "MAGLEV";
    case Cluster_LbPolicy.CLUSTER_PROVIDED:
      return "CLUSTER_PROVIDED";
    case Cluster_LbPolicy.LOAD_BALANCING_POLICY_CONFIG:
      return "LOAD_BALANCING_POLICY_CONFIG";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Cluster_LbPolicy");
  }
}

export function cluster_LbPolicyToNumber(object: Cluster_LbPolicy): number {
  switch (object) {
    case Cluster_LbPolicy.ROUND_ROBIN:
      return 0;
    case Cluster_LbPolicy.LEAST_REQUEST:
      return 1;
    case Cluster_LbPolicy.RING_HASH:
      return 2;
    case Cluster_LbPolicy.RANDOM:
      return 3;
    case Cluster_LbPolicy.ORIGINAL_DST_LB:
      return 4;
    case Cluster_LbPolicy.MAGLEV:
      return 5;
    case Cluster_LbPolicy.CLUSTER_PROVIDED:
      return 6;
    case Cluster_LbPolicy.LOAD_BALANCING_POLICY_CONFIG:
      return 7;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Cluster_LbPolicy");
  }
}

/**
 * When V4_ONLY is selected, the DNS resolver will only perform a lookup for
 * addresses in the IPv4 family. If V6_ONLY is selected, the DNS resolver will
 * only perform a lookup for addresses in the IPv6 family. If AUTO is
 * specified, the DNS resolver will first perform a lookup for addresses in
 * the IPv6 family and fallback to a lookup for addresses in the IPv4 family.
 * For cluster types other than
 * :ref:`STRICT_DNS<envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>` and
 * :ref:`LOGICAL_DNS<envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`,
 * this setting is
 * ignored.
 */
export enum Cluster_DnsLookupFamily {
  AUTO = "AUTO",
  V4_ONLY = "V4_ONLY",
  V6_ONLY = "V6_ONLY",
}

export function cluster_DnsLookupFamilyFromJSON(object: any): Cluster_DnsLookupFamily {
  switch (object) {
    case 0:
    case "AUTO":
      return Cluster_DnsLookupFamily.AUTO;
    case 1:
    case "V4_ONLY":
      return Cluster_DnsLookupFamily.V4_ONLY;
    case 2:
    case "V6_ONLY":
      return Cluster_DnsLookupFamily.V6_ONLY;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Cluster_DnsLookupFamily");
  }
}

export function cluster_DnsLookupFamilyToJSON(object: Cluster_DnsLookupFamily): string {
  switch (object) {
    case Cluster_DnsLookupFamily.AUTO:
      return "AUTO";
    case Cluster_DnsLookupFamily.V4_ONLY:
      return "V4_ONLY";
    case Cluster_DnsLookupFamily.V6_ONLY:
      return "V6_ONLY";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Cluster_DnsLookupFamily");
  }
}

export function cluster_DnsLookupFamilyToNumber(object: Cluster_DnsLookupFamily): number {
  switch (object) {
    case Cluster_DnsLookupFamily.AUTO:
      return 0;
    case Cluster_DnsLookupFamily.V4_ONLY:
      return 1;
    case Cluster_DnsLookupFamily.V6_ONLY:
      return 2;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Cluster_DnsLookupFamily");
  }
}

export enum Cluster_ClusterProtocolSelection {
  /**
   * USE_CONFIGURED_PROTOCOL - Cluster can only operate on one of the possible upstream protocols (HTTP1.1, HTTP2).
   * If :ref:`http2_protocol_options <envoy_api_field_Cluster.http2_protocol_options>` are
   * present, HTTP2 will be used, otherwise HTTP1.1 will be used.
   */
  USE_CONFIGURED_PROTOCOL = "USE_CONFIGURED_PROTOCOL",
  /** USE_DOWNSTREAM_PROTOCOL - Use HTTP1.1 or HTTP2, depending on which one is used on the downstream connection. */
  USE_DOWNSTREAM_PROTOCOL = "USE_DOWNSTREAM_PROTOCOL",
}

export function cluster_ClusterProtocolSelectionFromJSON(object: any): Cluster_ClusterProtocolSelection {
  switch (object) {
    case 0:
    case "USE_CONFIGURED_PROTOCOL":
      return Cluster_ClusterProtocolSelection.USE_CONFIGURED_PROTOCOL;
    case 1:
    case "USE_DOWNSTREAM_PROTOCOL":
      return Cluster_ClusterProtocolSelection.USE_DOWNSTREAM_PROTOCOL;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Cluster_ClusterProtocolSelection");
  }
}

export function cluster_ClusterProtocolSelectionToJSON(object: Cluster_ClusterProtocolSelection): string {
  switch (object) {
    case Cluster_ClusterProtocolSelection.USE_CONFIGURED_PROTOCOL:
      return "USE_CONFIGURED_PROTOCOL";
    case Cluster_ClusterProtocolSelection.USE_DOWNSTREAM_PROTOCOL:
      return "USE_DOWNSTREAM_PROTOCOL";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Cluster_ClusterProtocolSelection");
  }
}

export function cluster_ClusterProtocolSelectionToNumber(object: Cluster_ClusterProtocolSelection): number {
  switch (object) {
    case Cluster_ClusterProtocolSelection.USE_CONFIGURED_PROTOCOL:
      return 0;
    case Cluster_ClusterProtocolSelection.USE_DOWNSTREAM_PROTOCOL:
      return 1;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Cluster_ClusterProtocolSelection");
  }
}

/**
 * TransportSocketMatch specifies what transport socket config will be used
 * when the match conditions are satisfied.
 */
export interface Cluster_TransportSocketMatch {
  $type: "envoy.api.v2.Cluster.TransportSocketMatch";
  /** The name of the match, used in stats generation. */
  name?:
    | string
    | undefined;
  /**
   * Optional endpoint metadata match criteria.
   * The connection to the endpoint with metadata matching what is set in this field
   * will use the transport socket configuration specified here.
   * The endpoint's metadata entry in *envoy.transport_socket_match* is used to match
   * against the values specified in this field.
   */
  match?:
    | { [key: string]: any }
    | undefined;
  /** The configuration of the transport socket. */
  transport_socket?: TransportSocket | undefined;
}

/** Extended cluster type. */
export interface Cluster_CustomClusterType {
  $type: "envoy.api.v2.Cluster.CustomClusterType";
  /** The type of the cluster to instantiate. The name must match a supported cluster type. */
  name?:
    | string
    | undefined;
  /**
   * Cluster specific configuration which depends on the cluster being instantiated.
   * See the supported cluster for further documentation.
   */
  typed_config?: Any | undefined;
}

/** Only valid when discovery type is EDS. */
export interface Cluster_EdsClusterConfig {
  $type: "envoy.api.v2.Cluster.EdsClusterConfig";
  /** Configuration for the source of EDS updates for this Cluster. */
  eds_config?:
    | ConfigSource
    | undefined;
  /**
   * Optional alternative to cluster name to present to EDS. This does not
   * have the same restrictions as cluster name, i.e. it may be arbitrary
   * length.
   */
  service_name?: string | undefined;
}

/**
 * Optionally divide the endpoints in this cluster into subsets defined by
 * endpoint metadata and selected by route and weighted cluster metadata.
 * [#next-free-field: 8]
 */
export interface Cluster_LbSubsetConfig {
  $type: "envoy.api.v2.Cluster.LbSubsetConfig";
  /**
   * The behavior used when no endpoint subset matches the selected route's
   * metadata. The value defaults to
   * :ref:`NO_FALLBACK<envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK>`.
   */
  fallback_policy?:
    | Cluster_LbSubsetConfig_LbSubsetFallbackPolicy
    | undefined;
  /**
   * Specifies the default subset of endpoints used during fallback if
   * fallback_policy is
   * :ref:`DEFAULT_SUBSET<envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET>`.
   * Each field in default_subset is
   * compared to the matching LbEndpoint.Metadata under the *envoy.lb*
   * namespace. It is valid for no hosts to match, in which case the behavior
   * is the same as a fallback_policy of
   * :ref:`NO_FALLBACK<envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK>`.
   */
  default_subset?:
    | { [key: string]: any }
    | undefined;
  /**
   * For each entry, LbEndpoint.Metadata's
   * *envoy.lb* namespace is traversed and a subset is created for each unique
   * combination of key and value. For example:
   *
   * .. code-block:: json
   *
   *   { "subset_selectors": [
   *       { "keys": [ "version" ] },
   *       { "keys": [ "stage", "hardware_type" ] }
   *   ]}
   *
   * A subset is matched when the metadata from the selected route and
   * weighted cluster contains the same keys and values as the subset's
   * metadata. The same host may appear in multiple subsets.
   */
  subset_selectors?:
    | Cluster_LbSubsetConfig_LbSubsetSelector[]
    | undefined;
  /**
   * If true, routing to subsets will take into account the localities and locality weights of the
   * endpoints when making the routing decision.
   *
   * There are some potential pitfalls associated with enabling this feature, as the resulting
   * traffic split after applying both a subset match and locality weights might be undesirable.
   *
   * Consider for example a situation in which you have 50/50 split across two localities X/Y
   * which have 100 hosts each without subsetting. If the subset LB results in X having only 1
   * host selected but Y having 100, then a lot more load is being dumped on the single host in X
   * than originally anticipated in the load balancing assignment delivered via EDS.
   */
  locality_weight_aware?:
    | boolean
    | undefined;
  /**
   * When used with locality_weight_aware, scales the weight of each locality by the ratio
   * of hosts in the subset vs hosts in the original subset. This aims to even out the load
   * going to an individual locality if said locality is disproportionately affected by the
   * subset predicate.
   */
  scale_locality_weight?:
    | boolean
    | undefined;
  /**
   * If true, when a fallback policy is configured and its corresponding subset fails to find
   * a host this will cause any host to be selected instead.
   *
   * This is useful when using the default subset as the fallback policy, given the default
   * subset might become empty. With this option enabled, if that happens the LB will attempt
   * to select a host from the entire cluster.
   */
  panic_mode_any?:
    | boolean
    | undefined;
  /**
   * If true, metadata specified for a metadata key will be matched against the corresponding
   * endpoint metadata if the endpoint metadata matches the value exactly OR it is a list value
   * and any of the elements in the list matches the criteria.
   */
  list_as_any?: boolean | undefined;
}

/**
 * If NO_FALLBACK is selected, a result
 * equivalent to no healthy hosts is reported. If ANY_ENDPOINT is selected,
 * any cluster endpoint may be returned (subject to policy, health checks,
 * etc). If DEFAULT_SUBSET is selected, load balancing is performed over the
 * endpoints matching the values from the default_subset field.
 */
export enum Cluster_LbSubsetConfig_LbSubsetFallbackPolicy {
  NO_FALLBACK = "NO_FALLBACK",
  ANY_ENDPOINT = "ANY_ENDPOINT",
  DEFAULT_SUBSET = "DEFAULT_SUBSET",
}

export function cluster_LbSubsetConfig_LbSubsetFallbackPolicyFromJSON(
  object: any,
): Cluster_LbSubsetConfig_LbSubsetFallbackPolicy {
  switch (object) {
    case 0:
    case "NO_FALLBACK":
      return Cluster_LbSubsetConfig_LbSubsetFallbackPolicy.NO_FALLBACK;
    case 1:
    case "ANY_ENDPOINT":
      return Cluster_LbSubsetConfig_LbSubsetFallbackPolicy.ANY_ENDPOINT;
    case 2:
    case "DEFAULT_SUBSET":
      return Cluster_LbSubsetConfig_LbSubsetFallbackPolicy.DEFAULT_SUBSET;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum Cluster_LbSubsetConfig_LbSubsetFallbackPolicy",
      );
  }
}

export function cluster_LbSubsetConfig_LbSubsetFallbackPolicyToJSON(
  object: Cluster_LbSubsetConfig_LbSubsetFallbackPolicy,
): string {
  switch (object) {
    case Cluster_LbSubsetConfig_LbSubsetFallbackPolicy.NO_FALLBACK:
      return "NO_FALLBACK";
    case Cluster_LbSubsetConfig_LbSubsetFallbackPolicy.ANY_ENDPOINT:
      return "ANY_ENDPOINT";
    case Cluster_LbSubsetConfig_LbSubsetFallbackPolicy.DEFAULT_SUBSET:
      return "DEFAULT_SUBSET";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum Cluster_LbSubsetConfig_LbSubsetFallbackPolicy",
      );
  }
}

export function cluster_LbSubsetConfig_LbSubsetFallbackPolicyToNumber(
  object: Cluster_LbSubsetConfig_LbSubsetFallbackPolicy,
): number {
  switch (object) {
    case Cluster_LbSubsetConfig_LbSubsetFallbackPolicy.NO_FALLBACK:
      return 0;
    case Cluster_LbSubsetConfig_LbSubsetFallbackPolicy.ANY_ENDPOINT:
      return 1;
    case Cluster_LbSubsetConfig_LbSubsetFallbackPolicy.DEFAULT_SUBSET:
      return 2;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum Cluster_LbSubsetConfig_LbSubsetFallbackPolicy",
      );
  }
}

/** Specifications for subsets. */
export interface Cluster_LbSubsetConfig_LbSubsetSelector {
  $type: "envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector";
  /** List of keys to match with the weighted cluster metadata. */
  keys?:
    | string[]
    | undefined;
  /**
   * The behavior used when no endpoint subset matches the selected route's
   * metadata.
   */
  fallback_policy?:
    | Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy
    | undefined;
  /**
   * Subset of
   * :ref:`keys<envoy_api_field_Cluster.LbSubsetConfig.LbSubsetSelector.keys>` used by
   * :ref:`KEYS_SUBSET<envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.KEYS_SUBSET>`
   * fallback policy.
   * It has to be a non empty list if KEYS_SUBSET fallback policy is selected.
   * For any other fallback policy the parameter is not used and should not be set.
   * Only values also present in
   * :ref:`keys<envoy_api_field_Cluster.LbSubsetConfig.LbSubsetSelector.keys>` are allowed, but
   * `fallback_keys_subset` cannot be equal to `keys`.
   */
  fallback_keys_subset?: string[] | undefined;
}

/** Allows to override top level fallback policy per selector. */
export enum Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy {
  /** NOT_DEFINED - If NOT_DEFINED top level config fallback policy is used instead. */
  NOT_DEFINED = "NOT_DEFINED",
  /** NO_FALLBACK - If NO_FALLBACK is selected, a result equivalent to no healthy hosts is reported. */
  NO_FALLBACK = "NO_FALLBACK",
  /**
   * ANY_ENDPOINT - If ANY_ENDPOINT is selected, any cluster endpoint may be returned
   * (subject to policy, health checks, etc).
   */
  ANY_ENDPOINT = "ANY_ENDPOINT",
  /**
   * DEFAULT_SUBSET - If DEFAULT_SUBSET is selected, load balancing is performed over the
   * endpoints matching the values from the default_subset field.
   */
  DEFAULT_SUBSET = "DEFAULT_SUBSET",
  /**
   * KEYS_SUBSET - If KEYS_SUBSET is selected, subset selector matching is performed again with metadata
   * keys reduced to
   * :ref:`fallback_keys_subset<envoy_api_field_Cluster.LbSubsetConfig.LbSubsetSelector.fallback_keys_subset>`.
   * It allows for a fallback to a different, less specific selector if some of the keys of
   * the selector are considered optional.
   */
  KEYS_SUBSET = "KEYS_SUBSET",
}

export function cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicyFromJSON(
  object: any,
): Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy {
  switch (object) {
    case 0:
    case "NOT_DEFINED":
      return Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.NOT_DEFINED;
    case 1:
    case "NO_FALLBACK":
      return Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.NO_FALLBACK;
    case 2:
    case "ANY_ENDPOINT":
      return Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.ANY_ENDPOINT;
    case 3:
    case "DEFAULT_SUBSET":
      return Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.DEFAULT_SUBSET;
    case 4:
    case "KEYS_SUBSET":
      return Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.KEYS_SUBSET;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object +
          " for enum Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy",
      );
  }
}

export function cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicyToJSON(
  object: Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy,
): string {
  switch (object) {
    case Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.NOT_DEFINED:
      return "NOT_DEFINED";
    case Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.NO_FALLBACK:
      return "NO_FALLBACK";
    case Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.ANY_ENDPOINT:
      return "ANY_ENDPOINT";
    case Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.DEFAULT_SUBSET:
      return "DEFAULT_SUBSET";
    case Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.KEYS_SUBSET:
      return "KEYS_SUBSET";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object +
          " for enum Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy",
      );
  }
}

export function cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicyToNumber(
  object: Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy,
): number {
  switch (object) {
    case Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.NOT_DEFINED:
      return 0;
    case Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.NO_FALLBACK:
      return 1;
    case Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.ANY_ENDPOINT:
      return 2;
    case Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.DEFAULT_SUBSET:
      return 3;
    case Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.KEYS_SUBSET:
      return 4;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object +
          " for enum Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy",
      );
  }
}

/** Specific configuration for the LeastRequest load balancing policy. */
export interface Cluster_LeastRequestLbConfig {
  $type: "envoy.api.v2.Cluster.LeastRequestLbConfig";
  /**
   * The number of random healthy hosts from which the host with the fewest active requests will
   * be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
   */
  choice_count?: number | undefined;
}

/**
 * Specific configuration for the :ref:`RingHash<arch_overview_load_balancing_types_ring_hash>`
 * load balancing policy.
 */
export interface Cluster_RingHashLbConfig {
  $type: "envoy.api.v2.Cluster.RingHashLbConfig";
  /**
   * Minimum hash ring size. The larger the ring is (that is, the more hashes there are for each
   * provided host) the better the request distribution will reflect the desired weights. Defaults
   * to 1024 entries, and limited to 8M entries. See also
   * :ref:`maximum_ring_size<envoy_api_field_Cluster.RingHashLbConfig.maximum_ring_size>`.
   */
  minimum_ring_size?:
    | number
    | undefined;
  /**
   * The hash function used to hash hosts onto the ketama ring. The value defaults to
   * :ref:`XX_HASH<envoy_api_enum_value_Cluster.RingHashLbConfig.HashFunction.XX_HASH>`.
   */
  hash_function?:
    | Cluster_RingHashLbConfig_HashFunction
    | undefined;
  /**
   * Maximum hash ring size. Defaults to 8M entries, and limited to 8M entries, but can be lowered
   * to further constrain resource use. See also
   * :ref:`minimum_ring_size<envoy_api_field_Cluster.RingHashLbConfig.minimum_ring_size>`.
   */
  maximum_ring_size?: number | undefined;
}

/** The hash function used to hash hosts onto the ketama ring. */
export enum Cluster_RingHashLbConfig_HashFunction {
  /** XX_HASH - Use `xxHash <https://github.com/Cyan4973/xxHash>`_, this is the default hash function. */
  XX_HASH = "XX_HASH",
  /**
   * MURMUR_HASH_2 - Use `MurmurHash2 <https://sites.google.com/site/murmurhash/>`_, this is compatible with
   * std:hash<string> in GNU libstdc++ 3.4.20 or above. This is typically the case when compiled
   * on Linux and not macOS.
   */
  MURMUR_HASH_2 = "MURMUR_HASH_2",
}

export function cluster_RingHashLbConfig_HashFunctionFromJSON(object: any): Cluster_RingHashLbConfig_HashFunction {
  switch (object) {
    case 0:
    case "XX_HASH":
      return Cluster_RingHashLbConfig_HashFunction.XX_HASH;
    case 1:
    case "MURMUR_HASH_2":
      return Cluster_RingHashLbConfig_HashFunction.MURMUR_HASH_2;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum Cluster_RingHashLbConfig_HashFunction",
      );
  }
}

export function cluster_RingHashLbConfig_HashFunctionToJSON(object: Cluster_RingHashLbConfig_HashFunction): string {
  switch (object) {
    case Cluster_RingHashLbConfig_HashFunction.XX_HASH:
      return "XX_HASH";
    case Cluster_RingHashLbConfig_HashFunction.MURMUR_HASH_2:
      return "MURMUR_HASH_2";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum Cluster_RingHashLbConfig_HashFunction",
      );
  }
}

export function cluster_RingHashLbConfig_HashFunctionToNumber(object: Cluster_RingHashLbConfig_HashFunction): number {
  switch (object) {
    case Cluster_RingHashLbConfig_HashFunction.XX_HASH:
      return 0;
    case Cluster_RingHashLbConfig_HashFunction.MURMUR_HASH_2:
      return 1;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum Cluster_RingHashLbConfig_HashFunction",
      );
  }
}

/**
 * Specific configuration for the
 * :ref:`Original Destination <arch_overview_load_balancing_types_original_destination>`
 * load balancing policy.
 */
export interface Cluster_OriginalDstLbConfig {
  $type: "envoy.api.v2.Cluster.OriginalDstLbConfig";
  /**
   * When true, :ref:`x-envoy-original-dst-host
   * <config_http_conn_man_headers_x-envoy-original-dst-host>` can be used to override destination
   * address.
   *
   * .. attention::
   *
   *   This header isn't sanitized by default, so enabling this feature allows HTTP clients to
   *   route traffic to arbitrary hosts and/or ports, which may have serious security
   *   consequences.
   *
   * .. note::
   *
   *   If the header appears multiple times only the first value is used.
   */
  use_http_header?: boolean | undefined;
}

/**
 * Common configuration for all load balancer implementations.
 * [#next-free-field: 8]
 */
export interface Cluster_CommonLbConfig {
  $type: "envoy.api.v2.Cluster.CommonLbConfig";
  /**
   * Configures the :ref:`healthy panic threshold <arch_overview_load_balancing_panic_threshold>`.
   * If not specified, the default is 50%.
   * To disable panic mode, set to 0%.
   *
   * .. note::
   *   The specified percent will be truncated to the nearest 1%.
   */
  healthy_panic_threshold?: Percent | undefined;
  locality_config_specifier?:
    | //
    { $case: "zone_aware_lb_config"; zone_aware_lb_config: Cluster_CommonLbConfig_ZoneAwareLbConfig }
    | //
    {
      $case: "locality_weighted_lb_config";
      locality_weighted_lb_config: Cluster_CommonLbConfig_LocalityWeightedLbConfig;
    }
    | undefined;
  /**
   * If set, all health check/weight/metadata updates that happen within this duration will be
   * merged and delivered in one shot when the duration expires. The start of the duration is when
   * the first update happens. This is useful for big clusters, with potentially noisy deploys
   * that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
   * or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
   * cluster). Please always keep in mind that the use of sandbox technologies may change this
   * behavior.
   *
   * If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
   * window to 0.
   *
   * Note: merging does not apply to cluster membership changes (e.g.: adds/removes); this is
   * because merging those updates isn't currently safe. See
   * https://github.com/envoyproxy/envoy/pull/3941.
   */
  update_merge_window?:
    | Duration
    | undefined;
  /**
   * If set to true, Envoy will not consider new hosts when computing load balancing weights until
   * they have been health checked for the first time. This will have no effect unless
   * active health checking is also configured.
   *
   * Ignoring a host means that for any load balancing calculations that adjust weights based
   * on the ratio of eligible hosts and total hosts (priority spillover, locality weighting and
   * panic mode) Envoy will exclude these hosts in the denominator.
   *
   * For example, with hosts in two priorities P0 and P1, where P0 looks like
   * {healthy, unhealthy (new), unhealthy (new)}
   * and where P1 looks like
   * {healthy, healthy}
   * all traffic will still hit P0, as 1 / (3 - 2) = 1.
   *
   * Enabling this will allow scaling up the number of hosts for a given cluster without entering
   * panic mode or triggering priority spillover, assuming the hosts pass the first health check.
   *
   * If panic mode is triggered, new hosts are still eligible for traffic; they simply do not
   * contribute to the calculation when deciding whether panic mode is enabled or not.
   */
  ignore_new_hosts_until_first_hc?:
    | boolean
    | undefined;
  /**
   * If set to `true`, the cluster manager will drain all existing
   * connections to upstream hosts whenever hosts are added or removed from the cluster.
   */
  close_connections_on_host_set_change?:
    | boolean
    | undefined;
  /** Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.) */
  consistent_hashing_lb_config?: Cluster_CommonLbConfig_ConsistentHashingLbConfig | undefined;
}

/**
 * Configuration for :ref:`zone aware routing
 * <arch_overview_load_balancing_zone_aware_routing>`.
 */
export interface Cluster_CommonLbConfig_ZoneAwareLbConfig {
  $type: "envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig";
  /**
   * Configures percentage of requests that will be considered for zone aware routing
   * if zone aware routing is configured. If not specified, the default is 100%.
   * * :ref:`runtime values <config_cluster_manager_cluster_runtime_zone_routing>`.
   * * :ref:`Zone aware routing support <arch_overview_load_balancing_zone_aware_routing>`.
   */
  routing_enabled?:
    | Percent
    | undefined;
  /**
   * Configures minimum upstream cluster size required for zone aware routing
   * If upstream cluster size is less than specified, zone aware routing is not performed
   * even if zone aware routing is configured. If not specified, the default is 6.
   * * :ref:`runtime values <config_cluster_manager_cluster_runtime_zone_routing>`.
   * * :ref:`Zone aware routing support <arch_overview_load_balancing_zone_aware_routing>`.
   */
  min_cluster_size?:
    | number
    | undefined;
  /**
   * If set to true, Envoy will not consider any hosts when the cluster is in :ref:`panic
   * mode<arch_overview_load_balancing_panic_threshold>`. Instead, the cluster will fail all
   * requests as if all hosts are unhealthy. This can help avoid potentially overwhelming a
   * failing service.
   */
  fail_traffic_on_panic?: boolean | undefined;
}

/**
 * Configuration for :ref:`locality weighted load balancing
 * <arch_overview_load_balancing_locality_weighted_lb>`
 */
export interface Cluster_CommonLbConfig_LocalityWeightedLbConfig {
  $type: "envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig";
}

/** Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.) */
export interface Cluster_CommonLbConfig_ConsistentHashingLbConfig {
  $type: "envoy.api.v2.Cluster.CommonLbConfig.ConsistentHashingLbConfig";
  /**
   * If set to `true`, the cluster will use hostname instead of the resolved
   * address as the key to consistently hash to an upstream host. Only valid for StrictDNS clusters with hostnames which resolve to a single IP address.
   */
  use_hostname_for_hashing?: boolean | undefined;
}

export interface Cluster_RefreshRate {
  $type: "envoy.api.v2.Cluster.RefreshRate";
  /**
   * Specifies the base interval between refreshes. This parameter is required and must be greater
   * than zero and less than
   * :ref:`max_interval <envoy_api_field_Cluster.RefreshRate.max_interval>`.
   */
  base_interval?:
    | Duration
    | undefined;
  /**
   * Specifies the maximum interval between refreshes. This parameter is optional, but must be
   * greater than or equal to the
   * :ref:`base_interval <envoy_api_field_Cluster.RefreshRate.base_interval>`  if set. The default
   * is 10 times the :ref:`base_interval <envoy_api_field_Cluster.RefreshRate.base_interval>`.
   */
  max_interval?: Duration | undefined;
}

export interface Cluster_ExtensionProtocolOptionsEntry {
  $type: "envoy.api.v2.Cluster.ExtensionProtocolOptionsEntry";
  key: string;
  value?: { [key: string]: any } | undefined;
}

export interface Cluster_TypedExtensionProtocolOptionsEntry {
  $type: "envoy.api.v2.Cluster.TypedExtensionProtocolOptionsEntry";
  key: string;
  value?: Any | undefined;
}

/**
 * [#not-implemented-hide:] Extensible load balancing policy configuration.
 *
 * Every LB policy defined via this mechanism will be identified via a unique name using reverse
 * DNS notation. If the policy needs configuration parameters, it must define a message for its
 * own configuration, which will be stored in the config field. The name of the policy will tell
 * clients which type of message they should expect to see in the config field.
 *
 * Note that there are cases where it is useful to be able to independently select LB policies
 * for choosing a locality and for choosing an endpoint within that locality. For example, a
 * given deployment may always use the same policy to choose the locality, but for choosing the
 * endpoint within the locality, some clusters may use weighted-round-robin, while others may
 * use some sort of session-based balancing.
 *
 * This can be accomplished via hierarchical LB policies, where the parent LB policy creates a
 * child LB policy for each locality. For each request, the parent chooses the locality and then
 * delegates to the child policy for that locality to choose the endpoint within the locality.
 *
 * To facilitate this, the config message for the top-level LB policy may include a field of
 * type LoadBalancingPolicy that specifies the child policy.
 */
export interface LoadBalancingPolicy {
  $type: "envoy.api.v2.LoadBalancingPolicy";
  /**
   * Each client will iterate over the list in order and stop at the first policy that it
   * supports. This provides a mechanism for starting to use new LB policies that are not yet
   * supported by all clients.
   */
  policies?: LoadBalancingPolicy_Policy[] | undefined;
}

export interface LoadBalancingPolicy_Policy {
  $type: "envoy.api.v2.LoadBalancingPolicy.Policy";
  /** Required. The name of the LB policy. */
  name?:
    | string
    | undefined;
  /**
   * Optional config for the LB policy.
   * No more than one of these two fields may be populated.
   *
   * @deprecated
   */
  config?: { [key: string]: any } | undefined;
  typed_config?: Any | undefined;
}

/**
 * An extensible structure containing the address Envoy should bind to when
 * establishing upstream connections.
 */
export interface UpstreamBindConfig {
  $type: "envoy.api.v2.UpstreamBindConfig";
  /** The address Envoy should bind to when establishing upstream connections. */
  source_address?: Address | undefined;
}

export interface UpstreamConnectionOptions {
  $type: "envoy.api.v2.UpstreamConnectionOptions";
  /** If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives. */
  tcp_keepalive?: TcpKeepalive | undefined;
}

function createBaseCluster(): Cluster {
  return { $type: "envoy.api.v2.Cluster", cluster_discovery_type: undefined, lb_config: undefined };
}

export const Cluster: MessageFns<Cluster, "envoy.api.v2.Cluster"> = {
  $type: "envoy.api.v2.Cluster" as const,

  encode(message: Cluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transport_socket_matches !== undefined && message.transport_socket_matches.length !== 0) {
      for (const v of message.transport_socket_matches) {
        Cluster_TransportSocketMatch.encode(v!, writer.uint32(346).fork()).join();
      }
    }
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.alt_stat_name !== undefined && message.alt_stat_name !== "") {
      writer.uint32(226).string(message.alt_stat_name);
    }
    switch (message.cluster_discovery_type?.$case) {
      case "type":
        writer.uint32(16).int32(cluster_DiscoveryTypeToNumber(message.cluster_discovery_type.type));
        break;
      case "cluster_type":
        Cluster_CustomClusterType.encode(message.cluster_discovery_type.cluster_type, writer.uint32(306).fork()).join();
        break;
    }
    if (message.eds_cluster_config !== undefined) {
      Cluster_EdsClusterConfig.encode(message.eds_cluster_config, writer.uint32(26).fork()).join();
    }
    if (message.connect_timeout !== undefined) {
      Duration.encode(message.connect_timeout, writer.uint32(34).fork()).join();
    }
    if (message.per_connection_buffer_limit_bytes !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.per_connection_buffer_limit_bytes! },
        writer.uint32(42).fork(),
      ).join();
    }
    if (message.lb_policy !== undefined && message.lb_policy !== Cluster_LbPolicy.ROUND_ROBIN) {
      writer.uint32(48).int32(cluster_LbPolicyToNumber(message.lb_policy));
    }
    if (message.hosts !== undefined && message.hosts.length !== 0) {
      for (const v of message.hosts) {
        Address.encode(v!, writer.uint32(58).fork()).join();
      }
    }
    if (message.load_assignment !== undefined) {
      ClusterLoadAssignment.encode(message.load_assignment, writer.uint32(266).fork()).join();
    }
    if (message.health_checks !== undefined && message.health_checks.length !== 0) {
      for (const v of message.health_checks) {
        HealthCheck.encode(v!, writer.uint32(66).fork()).join();
      }
    }
    if (message.max_requests_per_connection !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.max_requests_per_connection! },
        writer.uint32(74).fork(),
      ).join();
    }
    if (message.circuit_breakers !== undefined) {
      CircuitBreakers.encode(message.circuit_breakers, writer.uint32(82).fork()).join();
    }
    if (message.tls_context !== undefined) {
      UpstreamTlsContext.encode(message.tls_context, writer.uint32(90).fork()).join();
    }
    if (message.upstream_http_protocol_options !== undefined) {
      UpstreamHttpProtocolOptions.encode(message.upstream_http_protocol_options, writer.uint32(370).fork()).join();
    }
    if (message.common_http_protocol_options !== undefined) {
      HttpProtocolOptions.encode(message.common_http_protocol_options, writer.uint32(234).fork()).join();
    }
    if (message.http_protocol_options !== undefined) {
      Http1ProtocolOptions.encode(message.http_protocol_options, writer.uint32(106).fork()).join();
    }
    if (message.http2_protocol_options !== undefined) {
      Http2ProtocolOptions.encode(message.http2_protocol_options, writer.uint32(114).fork()).join();
    }
    (message.extension_protocol_options || new Map()).forEach((value, key) => {
      if (value !== undefined) {
        Cluster_ExtensionProtocolOptionsEntry.encode({
          $type: "envoy.api.v2.Cluster.ExtensionProtocolOptionsEntry",
          key: key as any,
          value,
        }, writer.uint32(282).fork()).join();
      }
    });
    (message.typed_extension_protocol_options || new Map()).forEach((value, key) => {
      Cluster_TypedExtensionProtocolOptionsEntry.encode({
        $type: "envoy.api.v2.Cluster.TypedExtensionProtocolOptionsEntry",
        key: key as any,
        value,
      }, writer.uint32(290).fork()).join();
    });
    if (message.dns_refresh_rate !== undefined) {
      Duration.encode(message.dns_refresh_rate, writer.uint32(130).fork()).join();
    }
    if (message.dns_failure_refresh_rate !== undefined) {
      Cluster_RefreshRate.encode(message.dns_failure_refresh_rate, writer.uint32(354).fork()).join();
    }
    if (message.respect_dns_ttl !== undefined && message.respect_dns_ttl !== false) {
      writer.uint32(312).bool(message.respect_dns_ttl);
    }
    if (message.dns_lookup_family !== undefined && message.dns_lookup_family !== Cluster_DnsLookupFamily.AUTO) {
      writer.uint32(136).int32(cluster_DnsLookupFamilyToNumber(message.dns_lookup_family));
    }
    if (message.dns_resolvers !== undefined && message.dns_resolvers.length !== 0) {
      for (const v of message.dns_resolvers) {
        Address.encode(v!, writer.uint32(146).fork()).join();
      }
    }
    if (message.use_tcp_for_dns_lookups !== undefined && message.use_tcp_for_dns_lookups !== false) {
      writer.uint32(360).bool(message.use_tcp_for_dns_lookups);
    }
    if (message.outlier_detection !== undefined) {
      OutlierDetection.encode(message.outlier_detection, writer.uint32(154).fork()).join();
    }
    if (message.cleanup_interval !== undefined) {
      Duration.encode(message.cleanup_interval, writer.uint32(162).fork()).join();
    }
    if (message.upstream_bind_config !== undefined) {
      BindConfig.encode(message.upstream_bind_config, writer.uint32(170).fork()).join();
    }
    if (message.lb_subset_config !== undefined) {
      Cluster_LbSubsetConfig.encode(message.lb_subset_config, writer.uint32(178).fork()).join();
    }
    switch (message.lb_config?.$case) {
      case "ring_hash_lb_config":
        Cluster_RingHashLbConfig.encode(message.lb_config.ring_hash_lb_config, writer.uint32(186).fork()).join();
        break;
      case "original_dst_lb_config":
        Cluster_OriginalDstLbConfig.encode(message.lb_config.original_dst_lb_config, writer.uint32(274).fork()).join();
        break;
      case "least_request_lb_config":
        Cluster_LeastRequestLbConfig.encode(message.lb_config.least_request_lb_config, writer.uint32(298).fork())
          .join();
        break;
    }
    if (message.common_lb_config !== undefined) {
      Cluster_CommonLbConfig.encode(message.common_lb_config, writer.uint32(218).fork()).join();
    }
    if (message.transport_socket !== undefined) {
      TransportSocket.encode(message.transport_socket, writer.uint32(194).fork()).join();
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(202).fork()).join();
    }
    if (
      message.protocol_selection !== undefined &&
      message.protocol_selection !== Cluster_ClusterProtocolSelection.USE_CONFIGURED_PROTOCOL
    ) {
      writer.uint32(208).int32(cluster_ClusterProtocolSelectionToNumber(message.protocol_selection));
    }
    if (message.upstream_connection_options !== undefined) {
      UpstreamConnectionOptions.encode(message.upstream_connection_options, writer.uint32(242).fork()).join();
    }
    if (
      message.close_connections_on_host_health_failure !== undefined &&
      message.close_connections_on_host_health_failure !== false
    ) {
      writer.uint32(248).bool(message.close_connections_on_host_health_failure);
    }
    if (
      message.drain_connections_on_host_removal !== undefined && message.drain_connections_on_host_removal !== false
    ) {
      writer.uint32(256).bool(message.drain_connections_on_host_removal);
    }
    if (message.filters !== undefined && message.filters.length !== 0) {
      for (const v of message.filters) {
        Filter.encode(v!, writer.uint32(322).fork()).join();
      }
    }
    if (message.load_balancing_policy !== undefined) {
      LoadBalancingPolicy.encode(message.load_balancing_policy, writer.uint32(330).fork()).join();
    }
    if (message.lrs_server !== undefined) {
      ConfigSource.encode(message.lrs_server, writer.uint32(338).fork()).join();
    }
    if (message.track_timeout_budgets !== undefined && message.track_timeout_budgets !== false) {
      writer.uint32(376).bool(message.track_timeout_budgets);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 43: {
          if (tag !== 346) {
            break;
          }

          if (message.transport_socket_matches === undefined) {
            message.transport_socket_matches = [];
          }
          const el = Cluster_TransportSocketMatch.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.transport_socket_matches!.push(el);
          }
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.alt_stat_name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.cluster_discovery_type = { $case: "type", type: cluster_DiscoveryTypeFromJSON(reader.int32()) };
          continue;
        }
        case 38: {
          if (tag !== 306) {
            break;
          }

          message.cluster_discovery_type = {
            $case: "cluster_type",
            cluster_type: Cluster_CustomClusterType.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.eds_cluster_config = Cluster_EdsClusterConfig.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.connect_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.per_connection_buffer_limit_bytes = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.lb_policy = cluster_LbPolicyFromJSON(reader.int32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          if (message.hosts === undefined) {
            message.hosts = [];
          }
          const el = Address.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.hosts!.push(el);
          }
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }

          message.load_assignment = ClusterLoadAssignment.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          if (message.health_checks === undefined) {
            message.health_checks = [];
          }
          const el = HealthCheck.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.health_checks!.push(el);
          }
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.max_requests_per_connection = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.circuit_breakers = CircuitBreakers.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.tls_context = UpstreamTlsContext.decode(reader, reader.uint32());
          continue;
        }
        case 46: {
          if (tag !== 370) {
            break;
          }

          message.upstream_http_protocol_options = UpstreamHttpProtocolOptions.decode(reader, reader.uint32());
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.common_http_protocol_options = HttpProtocolOptions.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.http_protocol_options = Http1ProtocolOptions.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.http2_protocol_options = Http2ProtocolOptions.decode(reader, reader.uint32());
          continue;
        }
        case 35: {
          if (tag !== 282) {
            break;
          }

          const entry35 = Cluster_ExtensionProtocolOptionsEntry.decode(reader, reader.uint32());
          if (entry35.value !== undefined) {
            if (message.extension_protocol_options === undefined) {
              message.extension_protocol_options = new Map();
            }
            message.extension_protocol_options!.set(entry35.key, entry35.value);
          }
          continue;
        }
        case 36: {
          if (tag !== 290) {
            break;
          }

          const entry36 = Cluster_TypedExtensionProtocolOptionsEntry.decode(reader, reader.uint32());
          if (entry36.value !== undefined) {
            if (message.typed_extension_protocol_options === undefined) {
              message.typed_extension_protocol_options = new Map();
            }
            message.typed_extension_protocol_options!.set(entry36.key, entry36.value);
          }
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.dns_refresh_rate = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 44: {
          if (tag !== 354) {
            break;
          }

          message.dns_failure_refresh_rate = Cluster_RefreshRate.decode(reader, reader.uint32());
          continue;
        }
        case 39: {
          if (tag !== 312) {
            break;
          }

          message.respect_dns_ttl = reader.bool();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.dns_lookup_family = cluster_DnsLookupFamilyFromJSON(reader.int32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          if (message.dns_resolvers === undefined) {
            message.dns_resolvers = [];
          }
          const el = Address.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.dns_resolvers!.push(el);
          }
          continue;
        }
        case 45: {
          if (tag !== 360) {
            break;
          }

          message.use_tcp_for_dns_lookups = reader.bool();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.outlier_detection = OutlierDetection.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.cleanup_interval = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.upstream_bind_config = BindConfig.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.lb_subset_config = Cluster_LbSubsetConfig.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.lb_config = {
            $case: "ring_hash_lb_config",
            ring_hash_lb_config: Cluster_RingHashLbConfig.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          message.lb_config = {
            $case: "original_dst_lb_config",
            original_dst_lb_config: Cluster_OriginalDstLbConfig.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 37: {
          if (tag !== 298) {
            break;
          }

          message.lb_config = {
            $case: "least_request_lb_config",
            least_request_lb_config: Cluster_LeastRequestLbConfig.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.common_lb_config = Cluster_CommonLbConfig.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.transport_socket = TransportSocket.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.protocol_selection = cluster_ClusterProtocolSelectionFromJSON(reader.int32());
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.upstream_connection_options = UpstreamConnectionOptions.decode(reader, reader.uint32());
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.close_connections_on_host_health_failure = reader.bool();
          continue;
        }
        case 32: {
          if (tag !== 256) {
            break;
          }

          message.drain_connections_on_host_removal = reader.bool();
          continue;
        }
        case 40: {
          if (tag !== 322) {
            break;
          }

          if (message.filters === undefined) {
            message.filters = [];
          }
          const el = Filter.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.filters!.push(el);
          }
          continue;
        }
        case 41: {
          if (tag !== 330) {
            break;
          }

          message.load_balancing_policy = LoadBalancingPolicy.decode(reader, reader.uint32());
          continue;
        }
        case 42: {
          if (tag !== 338) {
            break;
          }

          message.lrs_server = ConfigSource.decode(reader, reader.uint32());
          continue;
        }
        case 47: {
          if (tag !== 376) {
            break;
          }

          message.track_timeout_budgets = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster {
    return {
      $type: Cluster.$type,
      transport_socket_matches: globalThis.Array.isArray(object?.transport_socket_matches)
        ? object.transport_socket_matches.map((e: any) => Cluster_TransportSocketMatch.fromJSON(e))
        : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      alt_stat_name: isSet(object.alt_stat_name) ? globalThis.String(object.alt_stat_name) : undefined,
      cluster_discovery_type: isSet(object.type)
        ? { $case: "type", type: cluster_DiscoveryTypeFromJSON(object.type) }
        : isSet(object.cluster_type)
        ? { $case: "cluster_type", cluster_type: Cluster_CustomClusterType.fromJSON(object.cluster_type) }
        : undefined,
      eds_cluster_config: isSet(object.eds_cluster_config)
        ? Cluster_EdsClusterConfig.fromJSON(object.eds_cluster_config)
        : undefined,
      connect_timeout: isSet(object.connect_timeout) ? Duration.fromJSON(object.connect_timeout) : undefined,
      per_connection_buffer_limit_bytes: isSet(object.per_connection_buffer_limit_bytes)
        ? Number(object.per_connection_buffer_limit_bytes)
        : undefined,
      lb_policy: isSet(object.lb_policy) ? cluster_LbPolicyFromJSON(object.lb_policy) : undefined,
      hosts: globalThis.Array.isArray(object?.hosts) ? object.hosts.map((e: any) => Address.fromJSON(e)) : undefined,
      load_assignment: isSet(object.load_assignment)
        ? ClusterLoadAssignment.fromJSON(object.load_assignment)
        : undefined,
      health_checks: globalThis.Array.isArray(object?.health_checks)
        ? object.health_checks.map((e: any) => HealthCheck.fromJSON(e))
        : undefined,
      max_requests_per_connection: isSet(object.max_requests_per_connection)
        ? Number(object.max_requests_per_connection)
        : undefined,
      circuit_breakers: isSet(object.circuit_breakers) ? CircuitBreakers.fromJSON(object.circuit_breakers) : undefined,
      tls_context: isSet(object.tls_context) ? UpstreamTlsContext.fromJSON(object.tls_context) : undefined,
      upstream_http_protocol_options: isSet(object.upstream_http_protocol_options)
        ? UpstreamHttpProtocolOptions.fromJSON(object.upstream_http_protocol_options)
        : undefined,
      common_http_protocol_options: isSet(object.common_http_protocol_options)
        ? HttpProtocolOptions.fromJSON(object.common_http_protocol_options)
        : undefined,
      http_protocol_options: isSet(object.http_protocol_options)
        ? Http1ProtocolOptions.fromJSON(object.http_protocol_options)
        : undefined,
      http2_protocol_options: isSet(object.http2_protocol_options)
        ? Http2ProtocolOptions.fromJSON(object.http2_protocol_options)
        : undefined,
      extension_protocol_options: isObject(object.extension_protocol_options)
        ? Object.entries(object.extension_protocol_options).reduce<Map<string, { [key: string]: any } | undefined>>(
          (acc, [key, value]) => {
            acc.set(key, value as { [key: string]: any } | undefined);
            return acc;
          },
          new Map(),
        )
        : undefined,
      typed_extension_protocol_options: isObject(object.typed_extension_protocol_options)
        ? Object.entries(object.typed_extension_protocol_options).reduce<Map<string, Any>>((acc, [key, value]) => {
          acc.set(key, Any.fromJSON(value));
          return acc;
        }, new Map())
        : undefined,
      dns_refresh_rate: isSet(object.dns_refresh_rate) ? Duration.fromJSON(object.dns_refresh_rate) : undefined,
      dns_failure_refresh_rate: isSet(object.dns_failure_refresh_rate)
        ? Cluster_RefreshRate.fromJSON(object.dns_failure_refresh_rate)
        : undefined,
      respect_dns_ttl: isSet(object.respect_dns_ttl) ? globalThis.Boolean(object.respect_dns_ttl) : undefined,
      dns_lookup_family: isSet(object.dns_lookup_family)
        ? cluster_DnsLookupFamilyFromJSON(object.dns_lookup_family)
        : undefined,
      dns_resolvers: globalThis.Array.isArray(object?.dns_resolvers)
        ? object.dns_resolvers.map((e: any) => Address.fromJSON(e))
        : undefined,
      use_tcp_for_dns_lookups: isSet(object.use_tcp_for_dns_lookups)
        ? globalThis.Boolean(object.use_tcp_for_dns_lookups)
        : undefined,
      outlier_detection: isSet(object.outlier_detection)
        ? OutlierDetection.fromJSON(object.outlier_detection)
        : undefined,
      cleanup_interval: isSet(object.cleanup_interval) ? Duration.fromJSON(object.cleanup_interval) : undefined,
      upstream_bind_config: isSet(object.upstream_bind_config)
        ? BindConfig.fromJSON(object.upstream_bind_config)
        : undefined,
      lb_subset_config: isSet(object.lb_subset_config)
        ? Cluster_LbSubsetConfig.fromJSON(object.lb_subset_config)
        : undefined,
      lb_config: isSet(object.ring_hash_lb_config)
        ? {
          $case: "ring_hash_lb_config",
          ring_hash_lb_config: Cluster_RingHashLbConfig.fromJSON(object.ring_hash_lb_config),
        }
        : isSet(object.original_dst_lb_config)
        ? {
          $case: "original_dst_lb_config",
          original_dst_lb_config: Cluster_OriginalDstLbConfig.fromJSON(object.original_dst_lb_config),
        }
        : isSet(object.least_request_lb_config)
        ? {
          $case: "least_request_lb_config",
          least_request_lb_config: Cluster_LeastRequestLbConfig.fromJSON(object.least_request_lb_config),
        }
        : undefined,
      common_lb_config: isSet(object.common_lb_config)
        ? Cluster_CommonLbConfig.fromJSON(object.common_lb_config)
        : undefined,
      transport_socket: isSet(object.transport_socket) ? TransportSocket.fromJSON(object.transport_socket) : undefined,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      protocol_selection: isSet(object.protocol_selection)
        ? cluster_ClusterProtocolSelectionFromJSON(object.protocol_selection)
        : undefined,
      upstream_connection_options: isSet(object.upstream_connection_options)
        ? UpstreamConnectionOptions.fromJSON(object.upstream_connection_options)
        : undefined,
      close_connections_on_host_health_failure: isSet(object.close_connections_on_host_health_failure)
        ? globalThis.Boolean(object.close_connections_on_host_health_failure)
        : undefined,
      drain_connections_on_host_removal: isSet(object.drain_connections_on_host_removal)
        ? globalThis.Boolean(object.drain_connections_on_host_removal)
        : undefined,
      filters: globalThis.Array.isArray(object?.filters)
        ? object.filters.map((e: any) => Filter.fromJSON(e))
        : undefined,
      load_balancing_policy: isSet(object.load_balancing_policy)
        ? LoadBalancingPolicy.fromJSON(object.load_balancing_policy)
        : undefined,
      lrs_server: isSet(object.lrs_server) ? ConfigSource.fromJSON(object.lrs_server) : undefined,
      track_timeout_budgets: isSet(object.track_timeout_budgets)
        ? globalThis.Boolean(object.track_timeout_budgets)
        : undefined,
    };
  },

  toJSON(message: Cluster): unknown {
    const obj: any = {};
    if (message.transport_socket_matches?.length) {
      obj.transport_socket_matches = message.transport_socket_matches.map((e) =>
        Cluster_TransportSocketMatch.toJSON(e)
      );
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.alt_stat_name !== undefined) {
      obj.alt_stat_name = message.alt_stat_name;
    }
    if (message.cluster_discovery_type?.$case === "type") {
      obj.type = cluster_DiscoveryTypeToJSON(message.cluster_discovery_type.type);
    }
    if (message.cluster_discovery_type?.$case === "cluster_type") {
      obj.cluster_type = Cluster_CustomClusterType.toJSON(message.cluster_discovery_type.cluster_type);
    }
    if (message.eds_cluster_config !== undefined) {
      obj.eds_cluster_config = Cluster_EdsClusterConfig.toJSON(message.eds_cluster_config);
    }
    if (message.connect_timeout !== undefined) {
      obj.connect_timeout = Duration.toJSON(message.connect_timeout);
    }
    if (message.per_connection_buffer_limit_bytes !== undefined) {
      obj.per_connection_buffer_limit_bytes = message.per_connection_buffer_limit_bytes;
    }
    if (message.lb_policy !== undefined) {
      obj.lb_policy = cluster_LbPolicyToJSON(message.lb_policy);
    }
    if (message.hosts?.length) {
      obj.hosts = message.hosts.map((e) => Address.toJSON(e));
    }
    if (message.load_assignment !== undefined) {
      obj.load_assignment = ClusterLoadAssignment.toJSON(message.load_assignment);
    }
    if (message.health_checks?.length) {
      obj.health_checks = message.health_checks.map((e) => HealthCheck.toJSON(e));
    }
    if (message.max_requests_per_connection !== undefined) {
      obj.max_requests_per_connection = message.max_requests_per_connection;
    }
    if (message.circuit_breakers !== undefined) {
      obj.circuit_breakers = CircuitBreakers.toJSON(message.circuit_breakers);
    }
    if (message.tls_context !== undefined) {
      obj.tls_context = UpstreamTlsContext.toJSON(message.tls_context);
    }
    if (message.upstream_http_protocol_options !== undefined) {
      obj.upstream_http_protocol_options = UpstreamHttpProtocolOptions.toJSON(message.upstream_http_protocol_options);
    }
    if (message.common_http_protocol_options !== undefined) {
      obj.common_http_protocol_options = HttpProtocolOptions.toJSON(message.common_http_protocol_options);
    }
    if (message.http_protocol_options !== undefined) {
      obj.http_protocol_options = Http1ProtocolOptions.toJSON(message.http_protocol_options);
    }
    if (message.http2_protocol_options !== undefined) {
      obj.http2_protocol_options = Http2ProtocolOptions.toJSON(message.http2_protocol_options);
    }
    if (message.extension_protocol_options?.size) {
      obj.extension_protocol_options = {};
      message.extension_protocol_options.forEach((v, k) => {
        obj.extension_protocol_options[k] = v;
      });
    }
    if (message.typed_extension_protocol_options?.size) {
      obj.typed_extension_protocol_options = {};
      message.typed_extension_protocol_options.forEach((v, k) => {
        obj.typed_extension_protocol_options[k] = Any.toJSON(v);
      });
    }
    if (message.dns_refresh_rate !== undefined) {
      obj.dns_refresh_rate = Duration.toJSON(message.dns_refresh_rate);
    }
    if (message.dns_failure_refresh_rate !== undefined) {
      obj.dns_failure_refresh_rate = Cluster_RefreshRate.toJSON(message.dns_failure_refresh_rate);
    }
    if (message.respect_dns_ttl !== undefined) {
      obj.respect_dns_ttl = message.respect_dns_ttl;
    }
    if (message.dns_lookup_family !== undefined) {
      obj.dns_lookup_family = cluster_DnsLookupFamilyToJSON(message.dns_lookup_family);
    }
    if (message.dns_resolvers?.length) {
      obj.dns_resolvers = message.dns_resolvers.map((e) => Address.toJSON(e));
    }
    if (message.use_tcp_for_dns_lookups !== undefined) {
      obj.use_tcp_for_dns_lookups = message.use_tcp_for_dns_lookups;
    }
    if (message.outlier_detection !== undefined) {
      obj.outlier_detection = OutlierDetection.toJSON(message.outlier_detection);
    }
    if (message.cleanup_interval !== undefined) {
      obj.cleanup_interval = Duration.toJSON(message.cleanup_interval);
    }
    if (message.upstream_bind_config !== undefined) {
      obj.upstream_bind_config = BindConfig.toJSON(message.upstream_bind_config);
    }
    if (message.lb_subset_config !== undefined) {
      obj.lb_subset_config = Cluster_LbSubsetConfig.toJSON(message.lb_subset_config);
    }
    if (message.lb_config?.$case === "ring_hash_lb_config") {
      obj.ring_hash_lb_config = Cluster_RingHashLbConfig.toJSON(message.lb_config.ring_hash_lb_config);
    }
    if (message.lb_config?.$case === "original_dst_lb_config") {
      obj.original_dst_lb_config = Cluster_OriginalDstLbConfig.toJSON(message.lb_config.original_dst_lb_config);
    }
    if (message.lb_config?.$case === "least_request_lb_config") {
      obj.least_request_lb_config = Cluster_LeastRequestLbConfig.toJSON(message.lb_config.least_request_lb_config);
    }
    if (message.common_lb_config !== undefined) {
      obj.common_lb_config = Cluster_CommonLbConfig.toJSON(message.common_lb_config);
    }
    if (message.transport_socket !== undefined) {
      obj.transport_socket = TransportSocket.toJSON(message.transport_socket);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.protocol_selection !== undefined) {
      obj.protocol_selection = cluster_ClusterProtocolSelectionToJSON(message.protocol_selection);
    }
    if (message.upstream_connection_options !== undefined) {
      obj.upstream_connection_options = UpstreamConnectionOptions.toJSON(message.upstream_connection_options);
    }
    if (message.close_connections_on_host_health_failure !== undefined) {
      obj.close_connections_on_host_health_failure = message.close_connections_on_host_health_failure;
    }
    if (message.drain_connections_on_host_removal !== undefined) {
      obj.drain_connections_on_host_removal = message.drain_connections_on_host_removal;
    }
    if (message.filters?.length) {
      obj.filters = message.filters.map((e) => Filter.toJSON(e));
    }
    if (message.load_balancing_policy !== undefined) {
      obj.load_balancing_policy = LoadBalancingPolicy.toJSON(message.load_balancing_policy);
    }
    if (message.lrs_server !== undefined) {
      obj.lrs_server = ConfigSource.toJSON(message.lrs_server);
    }
    if (message.track_timeout_budgets !== undefined) {
      obj.track_timeout_budgets = message.track_timeout_budgets;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Cluster>, I>>(base?: I): Cluster {
    return Cluster.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cluster>, I>>(object: I): Cluster {
    const message = createBaseCluster();
    message.transport_socket_matches =
      object.transport_socket_matches?.map((e) => Cluster_TransportSocketMatch.fromPartial(e)) || undefined;
    message.name = object.name ?? undefined;
    message.alt_stat_name = object.alt_stat_name ?? undefined;
    if (
      object.cluster_discovery_type?.$case === "type" &&
      object.cluster_discovery_type?.type !== undefined &&
      object.cluster_discovery_type?.type !== null
    ) {
      message.cluster_discovery_type = { $case: "type", type: object.cluster_discovery_type.type };
    }
    if (
      object.cluster_discovery_type?.$case === "cluster_type" &&
      object.cluster_discovery_type?.cluster_type !== undefined &&
      object.cluster_discovery_type?.cluster_type !== null
    ) {
      message.cluster_discovery_type = {
        $case: "cluster_type",
        cluster_type: Cluster_CustomClusterType.fromPartial(object.cluster_discovery_type.cluster_type),
      };
    }
    message.eds_cluster_config = (object.eds_cluster_config !== undefined && object.eds_cluster_config !== null)
      ? Cluster_EdsClusterConfig.fromPartial(object.eds_cluster_config)
      : undefined;
    message.connect_timeout = (object.connect_timeout !== undefined && object.connect_timeout !== null)
      ? Duration.fromPartial(object.connect_timeout)
      : undefined;
    message.per_connection_buffer_limit_bytes = object.per_connection_buffer_limit_bytes ?? undefined;
    message.lb_policy = object.lb_policy ?? undefined;
    message.hosts = object.hosts?.map((e) => Address.fromPartial(e)) || undefined;
    message.load_assignment = (object.load_assignment !== undefined && object.load_assignment !== null)
      ? ClusterLoadAssignment.fromPartial(object.load_assignment)
      : undefined;
    message.health_checks = object.health_checks?.map((e) => HealthCheck.fromPartial(e)) || undefined;
    message.max_requests_per_connection = object.max_requests_per_connection ?? undefined;
    message.circuit_breakers = (object.circuit_breakers !== undefined && object.circuit_breakers !== null)
      ? CircuitBreakers.fromPartial(object.circuit_breakers)
      : undefined;
    message.tls_context = (object.tls_context !== undefined && object.tls_context !== null)
      ? UpstreamTlsContext.fromPartial(object.tls_context)
      : undefined;
    message.upstream_http_protocol_options =
      (object.upstream_http_protocol_options !== undefined && object.upstream_http_protocol_options !== null)
        ? UpstreamHttpProtocolOptions.fromPartial(object.upstream_http_protocol_options)
        : undefined;
    message.common_http_protocol_options =
      (object.common_http_protocol_options !== undefined && object.common_http_protocol_options !== null)
        ? HttpProtocolOptions.fromPartial(object.common_http_protocol_options)
        : undefined;
    message.http_protocol_options =
      (object.http_protocol_options !== undefined && object.http_protocol_options !== null)
        ? Http1ProtocolOptions.fromPartial(object.http_protocol_options)
        : undefined;
    message.http2_protocol_options =
      (object.http2_protocol_options !== undefined && object.http2_protocol_options !== null)
        ? Http2ProtocolOptions.fromPartial(object.http2_protocol_options)
        : undefined;
    message.extension_protocol_options =
      (object.extension_protocol_options === undefined || object.extension_protocol_options === null)
        ? undefined
        : (() => {
          const m = new Map();
          (object.extension_protocol_options as Map<string, { [key: string]: any } | undefined> ?? new Map()).forEach(
            (value, key) => {
              if (value !== undefined) {
                m.set(key, value);
              }
            },
          );
          return m;
        })();
    message.typed_extension_protocol_options =
      (object.typed_extension_protocol_options === undefined || object.typed_extension_protocol_options === null)
        ? undefined
        : (() => {
          const m = new Map();
          (object.typed_extension_protocol_options as Map<string, Any> ?? new Map()).forEach((value, key) => {
            if (value !== undefined) {
              m.set(key, Any.fromPartial(value));
            }
          });
          return m;
        })();
    message.dns_refresh_rate = (object.dns_refresh_rate !== undefined && object.dns_refresh_rate !== null)
      ? Duration.fromPartial(object.dns_refresh_rate)
      : undefined;
    message.dns_failure_refresh_rate =
      (object.dns_failure_refresh_rate !== undefined && object.dns_failure_refresh_rate !== null)
        ? Cluster_RefreshRate.fromPartial(object.dns_failure_refresh_rate)
        : undefined;
    message.respect_dns_ttl = object.respect_dns_ttl ?? undefined;
    message.dns_lookup_family = object.dns_lookup_family ?? undefined;
    message.dns_resolvers = object.dns_resolvers?.map((e) => Address.fromPartial(e)) || undefined;
    message.use_tcp_for_dns_lookups = object.use_tcp_for_dns_lookups ?? undefined;
    message.outlier_detection = (object.outlier_detection !== undefined && object.outlier_detection !== null)
      ? OutlierDetection.fromPartial(object.outlier_detection)
      : undefined;
    message.cleanup_interval = (object.cleanup_interval !== undefined && object.cleanup_interval !== null)
      ? Duration.fromPartial(object.cleanup_interval)
      : undefined;
    message.upstream_bind_config = (object.upstream_bind_config !== undefined && object.upstream_bind_config !== null)
      ? BindConfig.fromPartial(object.upstream_bind_config)
      : undefined;
    message.lb_subset_config = (object.lb_subset_config !== undefined && object.lb_subset_config !== null)
      ? Cluster_LbSubsetConfig.fromPartial(object.lb_subset_config)
      : undefined;
    if (
      object.lb_config?.$case === "ring_hash_lb_config" &&
      object.lb_config?.ring_hash_lb_config !== undefined &&
      object.lb_config?.ring_hash_lb_config !== null
    ) {
      message.lb_config = {
        $case: "ring_hash_lb_config",
        ring_hash_lb_config: Cluster_RingHashLbConfig.fromPartial(object.lb_config.ring_hash_lb_config),
      };
    }
    if (
      object.lb_config?.$case === "original_dst_lb_config" &&
      object.lb_config?.original_dst_lb_config !== undefined &&
      object.lb_config?.original_dst_lb_config !== null
    ) {
      message.lb_config = {
        $case: "original_dst_lb_config",
        original_dst_lb_config: Cluster_OriginalDstLbConfig.fromPartial(object.lb_config.original_dst_lb_config),
      };
    }
    if (
      object.lb_config?.$case === "least_request_lb_config" &&
      object.lb_config?.least_request_lb_config !== undefined &&
      object.lb_config?.least_request_lb_config !== null
    ) {
      message.lb_config = {
        $case: "least_request_lb_config",
        least_request_lb_config: Cluster_LeastRequestLbConfig.fromPartial(object.lb_config.least_request_lb_config),
      };
    }
    message.common_lb_config = (object.common_lb_config !== undefined && object.common_lb_config !== null)
      ? Cluster_CommonLbConfig.fromPartial(object.common_lb_config)
      : undefined;
    message.transport_socket = (object.transport_socket !== undefined && object.transport_socket !== null)
      ? TransportSocket.fromPartial(object.transport_socket)
      : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.protocol_selection = object.protocol_selection ?? undefined;
    message.upstream_connection_options =
      (object.upstream_connection_options !== undefined && object.upstream_connection_options !== null)
        ? UpstreamConnectionOptions.fromPartial(object.upstream_connection_options)
        : undefined;
    message.close_connections_on_host_health_failure = object.close_connections_on_host_health_failure ?? undefined;
    message.drain_connections_on_host_removal = object.drain_connections_on_host_removal ?? undefined;
    message.filters = object.filters?.map((e) => Filter.fromPartial(e)) || undefined;
    message.load_balancing_policy =
      (object.load_balancing_policy !== undefined && object.load_balancing_policy !== null)
        ? LoadBalancingPolicy.fromPartial(object.load_balancing_policy)
        : undefined;
    message.lrs_server = (object.lrs_server !== undefined && object.lrs_server !== null)
      ? ConfigSource.fromPartial(object.lrs_server)
      : undefined;
    message.track_timeout_budgets = object.track_timeout_budgets ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Cluster.$type, Cluster);

function createBaseCluster_TransportSocketMatch(): Cluster_TransportSocketMatch {
  return { $type: "envoy.api.v2.Cluster.TransportSocketMatch" };
}

export const Cluster_TransportSocketMatch: MessageFns<
  Cluster_TransportSocketMatch,
  "envoy.api.v2.Cluster.TransportSocketMatch"
> = {
  $type: "envoy.api.v2.Cluster.TransportSocketMatch" as const,

  encode(message: Cluster_TransportSocketMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.match !== undefined) {
      Struct.encode(Struct.wrap(message.match), writer.uint32(18).fork()).join();
    }
    if (message.transport_socket !== undefined) {
      TransportSocket.encode(message.transport_socket, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_TransportSocketMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_TransportSocketMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.match = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.transport_socket = TransportSocket.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_TransportSocketMatch {
    return {
      $type: Cluster_TransportSocketMatch.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      match: isObject(object.match) ? object.match : undefined,
      transport_socket: isSet(object.transport_socket) ? TransportSocket.fromJSON(object.transport_socket) : undefined,
    };
  },

  toJSON(message: Cluster_TransportSocketMatch): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.match !== undefined) {
      obj.match = message.match;
    }
    if (message.transport_socket !== undefined) {
      obj.transport_socket = TransportSocket.toJSON(message.transport_socket);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Cluster_TransportSocketMatch>, I>>(base?: I): Cluster_TransportSocketMatch {
    return Cluster_TransportSocketMatch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cluster_TransportSocketMatch>, I>>(object: I): Cluster_TransportSocketMatch {
    const message = createBaseCluster_TransportSocketMatch();
    message.name = object.name ?? undefined;
    message.match = object.match ?? undefined;
    message.transport_socket = (object.transport_socket !== undefined && object.transport_socket !== null)
      ? TransportSocket.fromPartial(object.transport_socket)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Cluster_TransportSocketMatch.$type, Cluster_TransportSocketMatch);

function createBaseCluster_CustomClusterType(): Cluster_CustomClusterType {
  return { $type: "envoy.api.v2.Cluster.CustomClusterType" };
}

export const Cluster_CustomClusterType: MessageFns<
  Cluster_CustomClusterType,
  "envoy.api.v2.Cluster.CustomClusterType"
> = {
  $type: "envoy.api.v2.Cluster.CustomClusterType" as const,

  encode(message: Cluster_CustomClusterType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.typed_config !== undefined) {
      Any.encode(message.typed_config, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_CustomClusterType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_CustomClusterType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.typed_config = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_CustomClusterType {
    return {
      $type: Cluster_CustomClusterType.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      typed_config: isSet(object.typed_config) ? Any.fromJSON(object.typed_config) : undefined,
    };
  },

  toJSON(message: Cluster_CustomClusterType): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.typed_config !== undefined) {
      obj.typed_config = Any.toJSON(message.typed_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Cluster_CustomClusterType>, I>>(base?: I): Cluster_CustomClusterType {
    return Cluster_CustomClusterType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cluster_CustomClusterType>, I>>(object: I): Cluster_CustomClusterType {
    const message = createBaseCluster_CustomClusterType();
    message.name = object.name ?? undefined;
    message.typed_config = (object.typed_config !== undefined && object.typed_config !== null)
      ? Any.fromPartial(object.typed_config)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Cluster_CustomClusterType.$type, Cluster_CustomClusterType);

function createBaseCluster_EdsClusterConfig(): Cluster_EdsClusterConfig {
  return { $type: "envoy.api.v2.Cluster.EdsClusterConfig" };
}

export const Cluster_EdsClusterConfig: MessageFns<Cluster_EdsClusterConfig, "envoy.api.v2.Cluster.EdsClusterConfig"> = {
  $type: "envoy.api.v2.Cluster.EdsClusterConfig" as const,

  encode(message: Cluster_EdsClusterConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eds_config !== undefined) {
      ConfigSource.encode(message.eds_config, writer.uint32(10).fork()).join();
    }
    if (message.service_name !== undefined && message.service_name !== "") {
      writer.uint32(18).string(message.service_name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_EdsClusterConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_EdsClusterConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eds_config = ConfigSource.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.service_name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_EdsClusterConfig {
    return {
      $type: Cluster_EdsClusterConfig.$type,
      eds_config: isSet(object.eds_config) ? ConfigSource.fromJSON(object.eds_config) : undefined,
      service_name: isSet(object.service_name) ? globalThis.String(object.service_name) : undefined,
    };
  },

  toJSON(message: Cluster_EdsClusterConfig): unknown {
    const obj: any = {};
    if (message.eds_config !== undefined) {
      obj.eds_config = ConfigSource.toJSON(message.eds_config);
    }
    if (message.service_name !== undefined) {
      obj.service_name = message.service_name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Cluster_EdsClusterConfig>, I>>(base?: I): Cluster_EdsClusterConfig {
    return Cluster_EdsClusterConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cluster_EdsClusterConfig>, I>>(object: I): Cluster_EdsClusterConfig {
    const message = createBaseCluster_EdsClusterConfig();
    message.eds_config = (object.eds_config !== undefined && object.eds_config !== null)
      ? ConfigSource.fromPartial(object.eds_config)
      : undefined;
    message.service_name = object.service_name ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Cluster_EdsClusterConfig.$type, Cluster_EdsClusterConfig);

function createBaseCluster_LbSubsetConfig(): Cluster_LbSubsetConfig {
  return { $type: "envoy.api.v2.Cluster.LbSubsetConfig" };
}

export const Cluster_LbSubsetConfig: MessageFns<Cluster_LbSubsetConfig, "envoy.api.v2.Cluster.LbSubsetConfig"> = {
  $type: "envoy.api.v2.Cluster.LbSubsetConfig" as const,

  encode(message: Cluster_LbSubsetConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (
      message.fallback_policy !== undefined &&
      message.fallback_policy !== Cluster_LbSubsetConfig_LbSubsetFallbackPolicy.NO_FALLBACK
    ) {
      writer.uint32(8).int32(cluster_LbSubsetConfig_LbSubsetFallbackPolicyToNumber(message.fallback_policy));
    }
    if (message.default_subset !== undefined) {
      Struct.encode(Struct.wrap(message.default_subset), writer.uint32(18).fork()).join();
    }
    if (message.subset_selectors !== undefined && message.subset_selectors.length !== 0) {
      for (const v of message.subset_selectors) {
        Cluster_LbSubsetConfig_LbSubsetSelector.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    if (message.locality_weight_aware !== undefined && message.locality_weight_aware !== false) {
      writer.uint32(32).bool(message.locality_weight_aware);
    }
    if (message.scale_locality_weight !== undefined && message.scale_locality_weight !== false) {
      writer.uint32(40).bool(message.scale_locality_weight);
    }
    if (message.panic_mode_any !== undefined && message.panic_mode_any !== false) {
      writer.uint32(48).bool(message.panic_mode_any);
    }
    if (message.list_as_any !== undefined && message.list_as_any !== false) {
      writer.uint32(56).bool(message.list_as_any);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_LbSubsetConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_LbSubsetConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fallback_policy = cluster_LbSubsetConfig_LbSubsetFallbackPolicyFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.default_subset = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.subset_selectors === undefined) {
            message.subset_selectors = [];
          }
          const el = Cluster_LbSubsetConfig_LbSubsetSelector.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.subset_selectors!.push(el);
          }
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.locality_weight_aware = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.scale_locality_weight = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.panic_mode_any = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.list_as_any = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_LbSubsetConfig {
    return {
      $type: Cluster_LbSubsetConfig.$type,
      fallback_policy: isSet(object.fallback_policy)
        ? cluster_LbSubsetConfig_LbSubsetFallbackPolicyFromJSON(object.fallback_policy)
        : undefined,
      default_subset: isObject(object.default_subset) ? object.default_subset : undefined,
      subset_selectors: globalThis.Array.isArray(object?.subset_selectors)
        ? object.subset_selectors.map((e: any) => Cluster_LbSubsetConfig_LbSubsetSelector.fromJSON(e))
        : undefined,
      locality_weight_aware: isSet(object.locality_weight_aware)
        ? globalThis.Boolean(object.locality_weight_aware)
        : undefined,
      scale_locality_weight: isSet(object.scale_locality_weight)
        ? globalThis.Boolean(object.scale_locality_weight)
        : undefined,
      panic_mode_any: isSet(object.panic_mode_any) ? globalThis.Boolean(object.panic_mode_any) : undefined,
      list_as_any: isSet(object.list_as_any) ? globalThis.Boolean(object.list_as_any) : undefined,
    };
  },

  toJSON(message: Cluster_LbSubsetConfig): unknown {
    const obj: any = {};
    if (message.fallback_policy !== undefined) {
      obj.fallback_policy = cluster_LbSubsetConfig_LbSubsetFallbackPolicyToJSON(message.fallback_policy);
    }
    if (message.default_subset !== undefined) {
      obj.default_subset = message.default_subset;
    }
    if (message.subset_selectors?.length) {
      obj.subset_selectors = message.subset_selectors.map((e) => Cluster_LbSubsetConfig_LbSubsetSelector.toJSON(e));
    }
    if (message.locality_weight_aware !== undefined) {
      obj.locality_weight_aware = message.locality_weight_aware;
    }
    if (message.scale_locality_weight !== undefined) {
      obj.scale_locality_weight = message.scale_locality_weight;
    }
    if (message.panic_mode_any !== undefined) {
      obj.panic_mode_any = message.panic_mode_any;
    }
    if (message.list_as_any !== undefined) {
      obj.list_as_any = message.list_as_any;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Cluster_LbSubsetConfig>, I>>(base?: I): Cluster_LbSubsetConfig {
    return Cluster_LbSubsetConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cluster_LbSubsetConfig>, I>>(object: I): Cluster_LbSubsetConfig {
    const message = createBaseCluster_LbSubsetConfig();
    message.fallback_policy = object.fallback_policy ?? undefined;
    message.default_subset = object.default_subset ?? undefined;
    message.subset_selectors =
      object.subset_selectors?.map((e) => Cluster_LbSubsetConfig_LbSubsetSelector.fromPartial(e)) || undefined;
    message.locality_weight_aware = object.locality_weight_aware ?? undefined;
    message.scale_locality_weight = object.scale_locality_weight ?? undefined;
    message.panic_mode_any = object.panic_mode_any ?? undefined;
    message.list_as_any = object.list_as_any ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Cluster_LbSubsetConfig.$type, Cluster_LbSubsetConfig);

function createBaseCluster_LbSubsetConfig_LbSubsetSelector(): Cluster_LbSubsetConfig_LbSubsetSelector {
  return { $type: "envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector" };
}

export const Cluster_LbSubsetConfig_LbSubsetSelector: MessageFns<
  Cluster_LbSubsetConfig_LbSubsetSelector,
  "envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector"
> = {
  $type: "envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector" as const,

  encode(message: Cluster_LbSubsetConfig_LbSubsetSelector, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keys !== undefined && message.keys.length !== 0) {
      for (const v of message.keys) {
        writer.uint32(10).string(v!);
      }
    }
    if (
      message.fallback_policy !== undefined &&
      message.fallback_policy !== Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.NOT_DEFINED
    ) {
      writer.uint32(16).int32(
        cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicyToNumber(message.fallback_policy),
      );
    }
    if (message.fallback_keys_subset !== undefined && message.fallback_keys_subset.length !== 0) {
      for (const v of message.fallback_keys_subset) {
        writer.uint32(26).string(v!);
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_LbSubsetConfig_LbSubsetSelector {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_LbSubsetConfig_LbSubsetSelector();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.keys === undefined) {
            message.keys = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.keys!.push(el);
          }
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.fallback_policy = cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicyFromJSON(
            reader.int32(),
          );
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.fallback_keys_subset === undefined) {
            message.fallback_keys_subset = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.fallback_keys_subset!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_LbSubsetConfig_LbSubsetSelector {
    return {
      $type: Cluster_LbSubsetConfig_LbSubsetSelector.$type,
      keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e: any) => globalThis.String(e)) : undefined,
      fallback_policy: isSet(object.fallback_policy)
        ? cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicyFromJSON(object.fallback_policy)
        : undefined,
      fallback_keys_subset: globalThis.Array.isArray(object?.fallback_keys_subset)
        ? object.fallback_keys_subset.map((e: any) => globalThis.String(e))
        : undefined,
    };
  },

  toJSON(message: Cluster_LbSubsetConfig_LbSubsetSelector): unknown {
    const obj: any = {};
    if (message.keys?.length) {
      obj.keys = message.keys;
    }
    if (message.fallback_policy !== undefined) {
      obj.fallback_policy = cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicyToJSON(
        message.fallback_policy,
      );
    }
    if (message.fallback_keys_subset?.length) {
      obj.fallback_keys_subset = message.fallback_keys_subset;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Cluster_LbSubsetConfig_LbSubsetSelector>, I>>(
    base?: I,
  ): Cluster_LbSubsetConfig_LbSubsetSelector {
    return Cluster_LbSubsetConfig_LbSubsetSelector.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cluster_LbSubsetConfig_LbSubsetSelector>, I>>(
    object: I,
  ): Cluster_LbSubsetConfig_LbSubsetSelector {
    const message = createBaseCluster_LbSubsetConfig_LbSubsetSelector();
    message.keys = object.keys?.map((e) => e) || undefined;
    message.fallback_policy = object.fallback_policy ?? undefined;
    message.fallback_keys_subset = object.fallback_keys_subset?.map((e) => e) || undefined;
    return message;
  },
};

messageTypeRegistry.set(Cluster_LbSubsetConfig_LbSubsetSelector.$type, Cluster_LbSubsetConfig_LbSubsetSelector);

function createBaseCluster_LeastRequestLbConfig(): Cluster_LeastRequestLbConfig {
  return { $type: "envoy.api.v2.Cluster.LeastRequestLbConfig" };
}

export const Cluster_LeastRequestLbConfig: MessageFns<
  Cluster_LeastRequestLbConfig,
  "envoy.api.v2.Cluster.LeastRequestLbConfig"
> = {
  $type: "envoy.api.v2.Cluster.LeastRequestLbConfig" as const,

  encode(message: Cluster_LeastRequestLbConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.choice_count !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.choice_count! },
        writer.uint32(10).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_LeastRequestLbConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_LeastRequestLbConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.choice_count = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_LeastRequestLbConfig {
    return {
      $type: Cluster_LeastRequestLbConfig.$type,
      choice_count: isSet(object.choice_count) ? Number(object.choice_count) : undefined,
    };
  },

  toJSON(message: Cluster_LeastRequestLbConfig): unknown {
    const obj: any = {};
    if (message.choice_count !== undefined) {
      obj.choice_count = message.choice_count;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Cluster_LeastRequestLbConfig>, I>>(base?: I): Cluster_LeastRequestLbConfig {
    return Cluster_LeastRequestLbConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cluster_LeastRequestLbConfig>, I>>(object: I): Cluster_LeastRequestLbConfig {
    const message = createBaseCluster_LeastRequestLbConfig();
    message.choice_count = object.choice_count ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Cluster_LeastRequestLbConfig.$type, Cluster_LeastRequestLbConfig);

function createBaseCluster_RingHashLbConfig(): Cluster_RingHashLbConfig {
  return { $type: "envoy.api.v2.Cluster.RingHashLbConfig" };
}

export const Cluster_RingHashLbConfig: MessageFns<Cluster_RingHashLbConfig, "envoy.api.v2.Cluster.RingHashLbConfig"> = {
  $type: "envoy.api.v2.Cluster.RingHashLbConfig" as const,

  encode(message: Cluster_RingHashLbConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.minimum_ring_size !== undefined) {
      UInt64Value.encode(
        { $type: "google.protobuf.UInt64Value", value: message.minimum_ring_size! },
        writer.uint32(10).fork(),
      ).join();
    }
    if (
      message.hash_function !== undefined && message.hash_function !== Cluster_RingHashLbConfig_HashFunction.XX_HASH
    ) {
      writer.uint32(24).int32(cluster_RingHashLbConfig_HashFunctionToNumber(message.hash_function));
    }
    if (message.maximum_ring_size !== undefined) {
      UInt64Value.encode(
        { $type: "google.protobuf.UInt64Value", value: message.maximum_ring_size! },
        writer.uint32(34).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_RingHashLbConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_RingHashLbConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.minimum_ring_size = UInt64Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.hash_function = cluster_RingHashLbConfig_HashFunctionFromJSON(reader.int32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.maximum_ring_size = UInt64Value.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_RingHashLbConfig {
    return {
      $type: Cluster_RingHashLbConfig.$type,
      minimum_ring_size: isSet(object.minimum_ring_size) ? Number(object.minimum_ring_size) : undefined,
      hash_function: isSet(object.hash_function)
        ? cluster_RingHashLbConfig_HashFunctionFromJSON(object.hash_function)
        : undefined,
      maximum_ring_size: isSet(object.maximum_ring_size) ? Number(object.maximum_ring_size) : undefined,
    };
  },

  toJSON(message: Cluster_RingHashLbConfig): unknown {
    const obj: any = {};
    if (message.minimum_ring_size !== undefined) {
      obj.minimum_ring_size = message.minimum_ring_size;
    }
    if (message.hash_function !== undefined) {
      obj.hash_function = cluster_RingHashLbConfig_HashFunctionToJSON(message.hash_function);
    }
    if (message.maximum_ring_size !== undefined) {
      obj.maximum_ring_size = message.maximum_ring_size;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Cluster_RingHashLbConfig>, I>>(base?: I): Cluster_RingHashLbConfig {
    return Cluster_RingHashLbConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cluster_RingHashLbConfig>, I>>(object: I): Cluster_RingHashLbConfig {
    const message = createBaseCluster_RingHashLbConfig();
    message.minimum_ring_size = object.minimum_ring_size ?? undefined;
    message.hash_function = object.hash_function ?? undefined;
    message.maximum_ring_size = object.maximum_ring_size ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Cluster_RingHashLbConfig.$type, Cluster_RingHashLbConfig);

function createBaseCluster_OriginalDstLbConfig(): Cluster_OriginalDstLbConfig {
  return { $type: "envoy.api.v2.Cluster.OriginalDstLbConfig" };
}

export const Cluster_OriginalDstLbConfig: MessageFns<
  Cluster_OriginalDstLbConfig,
  "envoy.api.v2.Cluster.OriginalDstLbConfig"
> = {
  $type: "envoy.api.v2.Cluster.OriginalDstLbConfig" as const,

  encode(message: Cluster_OriginalDstLbConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.use_http_header !== undefined && message.use_http_header !== false) {
      writer.uint32(8).bool(message.use_http_header);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_OriginalDstLbConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_OriginalDstLbConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.use_http_header = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_OriginalDstLbConfig {
    return {
      $type: Cluster_OriginalDstLbConfig.$type,
      use_http_header: isSet(object.use_http_header) ? globalThis.Boolean(object.use_http_header) : undefined,
    };
  },

  toJSON(message: Cluster_OriginalDstLbConfig): unknown {
    const obj: any = {};
    if (message.use_http_header !== undefined) {
      obj.use_http_header = message.use_http_header;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Cluster_OriginalDstLbConfig>, I>>(base?: I): Cluster_OriginalDstLbConfig {
    return Cluster_OriginalDstLbConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cluster_OriginalDstLbConfig>, I>>(object: I): Cluster_OriginalDstLbConfig {
    const message = createBaseCluster_OriginalDstLbConfig();
    message.use_http_header = object.use_http_header ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Cluster_OriginalDstLbConfig.$type, Cluster_OriginalDstLbConfig);

function createBaseCluster_CommonLbConfig(): Cluster_CommonLbConfig {
  return { $type: "envoy.api.v2.Cluster.CommonLbConfig", locality_config_specifier: undefined };
}

export const Cluster_CommonLbConfig: MessageFns<Cluster_CommonLbConfig, "envoy.api.v2.Cluster.CommonLbConfig"> = {
  $type: "envoy.api.v2.Cluster.CommonLbConfig" as const,

  encode(message: Cluster_CommonLbConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.healthy_panic_threshold !== undefined) {
      Percent.encode(message.healthy_panic_threshold, writer.uint32(10).fork()).join();
    }
    switch (message.locality_config_specifier?.$case) {
      case "zone_aware_lb_config":
        Cluster_CommonLbConfig_ZoneAwareLbConfig.encode(
          message.locality_config_specifier.zone_aware_lb_config,
          writer.uint32(18).fork(),
        ).join();
        break;
      case "locality_weighted_lb_config":
        Cluster_CommonLbConfig_LocalityWeightedLbConfig.encode(
          message.locality_config_specifier.locality_weighted_lb_config,
          writer.uint32(26).fork(),
        ).join();
        break;
    }
    if (message.update_merge_window !== undefined) {
      Duration.encode(message.update_merge_window, writer.uint32(34).fork()).join();
    }
    if (message.ignore_new_hosts_until_first_hc !== undefined && message.ignore_new_hosts_until_first_hc !== false) {
      writer.uint32(40).bool(message.ignore_new_hosts_until_first_hc);
    }
    if (
      message.close_connections_on_host_set_change !== undefined &&
      message.close_connections_on_host_set_change !== false
    ) {
      writer.uint32(48).bool(message.close_connections_on_host_set_change);
    }
    if (message.consistent_hashing_lb_config !== undefined) {
      Cluster_CommonLbConfig_ConsistentHashingLbConfig.encode(
        message.consistent_hashing_lb_config,
        writer.uint32(58).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_CommonLbConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_CommonLbConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.healthy_panic_threshold = Percent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.locality_config_specifier = {
            $case: "zone_aware_lb_config",
            zone_aware_lb_config: Cluster_CommonLbConfig_ZoneAwareLbConfig.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.locality_config_specifier = {
            $case: "locality_weighted_lb_config",
            locality_weighted_lb_config: Cluster_CommonLbConfig_LocalityWeightedLbConfig.decode(
              reader,
              reader.uint32(),
            ),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.update_merge_window = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.ignore_new_hosts_until_first_hc = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.close_connections_on_host_set_change = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.consistent_hashing_lb_config = Cluster_CommonLbConfig_ConsistentHashingLbConfig.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_CommonLbConfig {
    return {
      $type: Cluster_CommonLbConfig.$type,
      healthy_panic_threshold: isSet(object.healthy_panic_threshold)
        ? Percent.fromJSON(object.healthy_panic_threshold)
        : undefined,
      locality_config_specifier: isSet(object.zone_aware_lb_config)
        ? {
          $case: "zone_aware_lb_config",
          zone_aware_lb_config: Cluster_CommonLbConfig_ZoneAwareLbConfig.fromJSON(object.zone_aware_lb_config),
        }
        : isSet(object.locality_weighted_lb_config)
        ? {
          $case: "locality_weighted_lb_config",
          locality_weighted_lb_config: Cluster_CommonLbConfig_LocalityWeightedLbConfig.fromJSON(
            object.locality_weighted_lb_config,
          ),
        }
        : undefined,
      update_merge_window: isSet(object.update_merge_window)
        ? Duration.fromJSON(object.update_merge_window)
        : undefined,
      ignore_new_hosts_until_first_hc: isSet(object.ignore_new_hosts_until_first_hc)
        ? globalThis.Boolean(object.ignore_new_hosts_until_first_hc)
        : undefined,
      close_connections_on_host_set_change: isSet(object.close_connections_on_host_set_change)
        ? globalThis.Boolean(object.close_connections_on_host_set_change)
        : undefined,
      consistent_hashing_lb_config: isSet(object.consistent_hashing_lb_config)
        ? Cluster_CommonLbConfig_ConsistentHashingLbConfig.fromJSON(object.consistent_hashing_lb_config)
        : undefined,
    };
  },

  toJSON(message: Cluster_CommonLbConfig): unknown {
    const obj: any = {};
    if (message.healthy_panic_threshold !== undefined) {
      obj.healthy_panic_threshold = Percent.toJSON(message.healthy_panic_threshold);
    }
    if (message.locality_config_specifier?.$case === "zone_aware_lb_config") {
      obj.zone_aware_lb_config = Cluster_CommonLbConfig_ZoneAwareLbConfig.toJSON(
        message.locality_config_specifier.zone_aware_lb_config,
      );
    }
    if (message.locality_config_specifier?.$case === "locality_weighted_lb_config") {
      obj.locality_weighted_lb_config = Cluster_CommonLbConfig_LocalityWeightedLbConfig.toJSON(
        message.locality_config_specifier.locality_weighted_lb_config,
      );
    }
    if (message.update_merge_window !== undefined) {
      obj.update_merge_window = Duration.toJSON(message.update_merge_window);
    }
    if (message.ignore_new_hosts_until_first_hc !== undefined) {
      obj.ignore_new_hosts_until_first_hc = message.ignore_new_hosts_until_first_hc;
    }
    if (message.close_connections_on_host_set_change !== undefined) {
      obj.close_connections_on_host_set_change = message.close_connections_on_host_set_change;
    }
    if (message.consistent_hashing_lb_config !== undefined) {
      obj.consistent_hashing_lb_config = Cluster_CommonLbConfig_ConsistentHashingLbConfig.toJSON(
        message.consistent_hashing_lb_config,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Cluster_CommonLbConfig>, I>>(base?: I): Cluster_CommonLbConfig {
    return Cluster_CommonLbConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cluster_CommonLbConfig>, I>>(object: I): Cluster_CommonLbConfig {
    const message = createBaseCluster_CommonLbConfig();
    message.healthy_panic_threshold =
      (object.healthy_panic_threshold !== undefined && object.healthy_panic_threshold !== null)
        ? Percent.fromPartial(object.healthy_panic_threshold)
        : undefined;
    if (
      object.locality_config_specifier?.$case === "zone_aware_lb_config" &&
      object.locality_config_specifier?.zone_aware_lb_config !== undefined &&
      object.locality_config_specifier?.zone_aware_lb_config !== null
    ) {
      message.locality_config_specifier = {
        $case: "zone_aware_lb_config",
        zone_aware_lb_config: Cluster_CommonLbConfig_ZoneAwareLbConfig.fromPartial(
          object.locality_config_specifier.zone_aware_lb_config,
        ),
      };
    }
    if (
      object.locality_config_specifier?.$case === "locality_weighted_lb_config" &&
      object.locality_config_specifier?.locality_weighted_lb_config !== undefined &&
      object.locality_config_specifier?.locality_weighted_lb_config !== null
    ) {
      message.locality_config_specifier = {
        $case: "locality_weighted_lb_config",
        locality_weighted_lb_config: Cluster_CommonLbConfig_LocalityWeightedLbConfig.fromPartial(
          object.locality_config_specifier.locality_weighted_lb_config,
        ),
      };
    }
    message.update_merge_window = (object.update_merge_window !== undefined && object.update_merge_window !== null)
      ? Duration.fromPartial(object.update_merge_window)
      : undefined;
    message.ignore_new_hosts_until_first_hc = object.ignore_new_hosts_until_first_hc ?? undefined;
    message.close_connections_on_host_set_change = object.close_connections_on_host_set_change ?? undefined;
    message.consistent_hashing_lb_config =
      (object.consistent_hashing_lb_config !== undefined && object.consistent_hashing_lb_config !== null)
        ? Cluster_CommonLbConfig_ConsistentHashingLbConfig.fromPartial(object.consistent_hashing_lb_config)
        : undefined;
    return message;
  },
};

messageTypeRegistry.set(Cluster_CommonLbConfig.$type, Cluster_CommonLbConfig);

function createBaseCluster_CommonLbConfig_ZoneAwareLbConfig(): Cluster_CommonLbConfig_ZoneAwareLbConfig {
  return { $type: "envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig" };
}

export const Cluster_CommonLbConfig_ZoneAwareLbConfig: MessageFns<
  Cluster_CommonLbConfig_ZoneAwareLbConfig,
  "envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig"
> = {
  $type: "envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig" as const,

  encode(message: Cluster_CommonLbConfig_ZoneAwareLbConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.routing_enabled !== undefined) {
      Percent.encode(message.routing_enabled, writer.uint32(10).fork()).join();
    }
    if (message.min_cluster_size !== undefined) {
      UInt64Value.encode(
        { $type: "google.protobuf.UInt64Value", value: message.min_cluster_size! },
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.fail_traffic_on_panic !== undefined && message.fail_traffic_on_panic !== false) {
      writer.uint32(24).bool(message.fail_traffic_on_panic);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_CommonLbConfig_ZoneAwareLbConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_CommonLbConfig_ZoneAwareLbConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.routing_enabled = Percent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.min_cluster_size = UInt64Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.fail_traffic_on_panic = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_CommonLbConfig_ZoneAwareLbConfig {
    return {
      $type: Cluster_CommonLbConfig_ZoneAwareLbConfig.$type,
      routing_enabled: isSet(object.routing_enabled) ? Percent.fromJSON(object.routing_enabled) : undefined,
      min_cluster_size: isSet(object.min_cluster_size) ? Number(object.min_cluster_size) : undefined,
      fail_traffic_on_panic: isSet(object.fail_traffic_on_panic)
        ? globalThis.Boolean(object.fail_traffic_on_panic)
        : undefined,
    };
  },

  toJSON(message: Cluster_CommonLbConfig_ZoneAwareLbConfig): unknown {
    const obj: any = {};
    if (message.routing_enabled !== undefined) {
      obj.routing_enabled = Percent.toJSON(message.routing_enabled);
    }
    if (message.min_cluster_size !== undefined) {
      obj.min_cluster_size = message.min_cluster_size;
    }
    if (message.fail_traffic_on_panic !== undefined) {
      obj.fail_traffic_on_panic = message.fail_traffic_on_panic;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Cluster_CommonLbConfig_ZoneAwareLbConfig>, I>>(
    base?: I,
  ): Cluster_CommonLbConfig_ZoneAwareLbConfig {
    return Cluster_CommonLbConfig_ZoneAwareLbConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cluster_CommonLbConfig_ZoneAwareLbConfig>, I>>(
    object: I,
  ): Cluster_CommonLbConfig_ZoneAwareLbConfig {
    const message = createBaseCluster_CommonLbConfig_ZoneAwareLbConfig();
    message.routing_enabled = (object.routing_enabled !== undefined && object.routing_enabled !== null)
      ? Percent.fromPartial(object.routing_enabled)
      : undefined;
    message.min_cluster_size = object.min_cluster_size ?? undefined;
    message.fail_traffic_on_panic = object.fail_traffic_on_panic ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Cluster_CommonLbConfig_ZoneAwareLbConfig.$type, Cluster_CommonLbConfig_ZoneAwareLbConfig);

function createBaseCluster_CommonLbConfig_LocalityWeightedLbConfig(): Cluster_CommonLbConfig_LocalityWeightedLbConfig {
  return { $type: "envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig" };
}

export const Cluster_CommonLbConfig_LocalityWeightedLbConfig: MessageFns<
  Cluster_CommonLbConfig_LocalityWeightedLbConfig,
  "envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig"
> = {
  $type: "envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig" as const,

  encode(_: Cluster_CommonLbConfig_LocalityWeightedLbConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_CommonLbConfig_LocalityWeightedLbConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_CommonLbConfig_LocalityWeightedLbConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Cluster_CommonLbConfig_LocalityWeightedLbConfig {
    return { $type: Cluster_CommonLbConfig_LocalityWeightedLbConfig.$type };
  },

  toJSON(_: Cluster_CommonLbConfig_LocalityWeightedLbConfig): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Cluster_CommonLbConfig_LocalityWeightedLbConfig>, I>>(
    base?: I,
  ): Cluster_CommonLbConfig_LocalityWeightedLbConfig {
    return Cluster_CommonLbConfig_LocalityWeightedLbConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cluster_CommonLbConfig_LocalityWeightedLbConfig>, I>>(
    _: I,
  ): Cluster_CommonLbConfig_LocalityWeightedLbConfig {
    const message = createBaseCluster_CommonLbConfig_LocalityWeightedLbConfig();
    return message;
  },
};

messageTypeRegistry.set(
  Cluster_CommonLbConfig_LocalityWeightedLbConfig.$type,
  Cluster_CommonLbConfig_LocalityWeightedLbConfig,
);

function createBaseCluster_CommonLbConfig_ConsistentHashingLbConfig(): Cluster_CommonLbConfig_ConsistentHashingLbConfig {
  return { $type: "envoy.api.v2.Cluster.CommonLbConfig.ConsistentHashingLbConfig" };
}

export const Cluster_CommonLbConfig_ConsistentHashingLbConfig: MessageFns<
  Cluster_CommonLbConfig_ConsistentHashingLbConfig,
  "envoy.api.v2.Cluster.CommonLbConfig.ConsistentHashingLbConfig"
> = {
  $type: "envoy.api.v2.Cluster.CommonLbConfig.ConsistentHashingLbConfig" as const,

  encode(
    message: Cluster_CommonLbConfig_ConsistentHashingLbConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.use_hostname_for_hashing !== undefined && message.use_hostname_for_hashing !== false) {
      writer.uint32(8).bool(message.use_hostname_for_hashing);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_CommonLbConfig_ConsistentHashingLbConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_CommonLbConfig_ConsistentHashingLbConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.use_hostname_for_hashing = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_CommonLbConfig_ConsistentHashingLbConfig {
    return {
      $type: Cluster_CommonLbConfig_ConsistentHashingLbConfig.$type,
      use_hostname_for_hashing: isSet(object.use_hostname_for_hashing)
        ? globalThis.Boolean(object.use_hostname_for_hashing)
        : undefined,
    };
  },

  toJSON(message: Cluster_CommonLbConfig_ConsistentHashingLbConfig): unknown {
    const obj: any = {};
    if (message.use_hostname_for_hashing !== undefined) {
      obj.use_hostname_for_hashing = message.use_hostname_for_hashing;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Cluster_CommonLbConfig_ConsistentHashingLbConfig>, I>>(
    base?: I,
  ): Cluster_CommonLbConfig_ConsistentHashingLbConfig {
    return Cluster_CommonLbConfig_ConsistentHashingLbConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cluster_CommonLbConfig_ConsistentHashingLbConfig>, I>>(
    object: I,
  ): Cluster_CommonLbConfig_ConsistentHashingLbConfig {
    const message = createBaseCluster_CommonLbConfig_ConsistentHashingLbConfig();
    message.use_hostname_for_hashing = object.use_hostname_for_hashing ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(
  Cluster_CommonLbConfig_ConsistentHashingLbConfig.$type,
  Cluster_CommonLbConfig_ConsistentHashingLbConfig,
);

function createBaseCluster_RefreshRate(): Cluster_RefreshRate {
  return { $type: "envoy.api.v2.Cluster.RefreshRate" };
}

export const Cluster_RefreshRate: MessageFns<Cluster_RefreshRate, "envoy.api.v2.Cluster.RefreshRate"> = {
  $type: "envoy.api.v2.Cluster.RefreshRate" as const,

  encode(message: Cluster_RefreshRate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.base_interval !== undefined) {
      Duration.encode(message.base_interval, writer.uint32(10).fork()).join();
    }
    if (message.max_interval !== undefined) {
      Duration.encode(message.max_interval, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_RefreshRate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_RefreshRate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.base_interval = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.max_interval = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_RefreshRate {
    return {
      $type: Cluster_RefreshRate.$type,
      base_interval: isSet(object.base_interval) ? Duration.fromJSON(object.base_interval) : undefined,
      max_interval: isSet(object.max_interval) ? Duration.fromJSON(object.max_interval) : undefined,
    };
  },

  toJSON(message: Cluster_RefreshRate): unknown {
    const obj: any = {};
    if (message.base_interval !== undefined) {
      obj.base_interval = Duration.toJSON(message.base_interval);
    }
    if (message.max_interval !== undefined) {
      obj.max_interval = Duration.toJSON(message.max_interval);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Cluster_RefreshRate>, I>>(base?: I): Cluster_RefreshRate {
    return Cluster_RefreshRate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cluster_RefreshRate>, I>>(object: I): Cluster_RefreshRate {
    const message = createBaseCluster_RefreshRate();
    message.base_interval = (object.base_interval !== undefined && object.base_interval !== null)
      ? Duration.fromPartial(object.base_interval)
      : undefined;
    message.max_interval = (object.max_interval !== undefined && object.max_interval !== null)
      ? Duration.fromPartial(object.max_interval)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Cluster_RefreshRate.$type, Cluster_RefreshRate);

function createBaseCluster_ExtensionProtocolOptionsEntry(): Cluster_ExtensionProtocolOptionsEntry {
  return { $type: "envoy.api.v2.Cluster.ExtensionProtocolOptionsEntry", key: "" };
}

export const Cluster_ExtensionProtocolOptionsEntry: MessageFns<
  Cluster_ExtensionProtocolOptionsEntry,
  "envoy.api.v2.Cluster.ExtensionProtocolOptionsEntry"
> = {
  $type: "envoy.api.v2.Cluster.ExtensionProtocolOptionsEntry" as const,

  encode(message: Cluster_ExtensionProtocolOptionsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Struct.encode(Struct.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_ExtensionProtocolOptionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_ExtensionProtocolOptionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_ExtensionProtocolOptionsEntry {
    return {
      $type: Cluster_ExtensionProtocolOptionsEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isObject(object.value) ? object.value : undefined,
    };
  },

  toJSON(message: Cluster_ExtensionProtocolOptionsEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Cluster_ExtensionProtocolOptionsEntry>, I>>(
    base?: I,
  ): Cluster_ExtensionProtocolOptionsEntry {
    return Cluster_ExtensionProtocolOptionsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cluster_ExtensionProtocolOptionsEntry>, I>>(
    object: I,
  ): Cluster_ExtensionProtocolOptionsEntry {
    const message = createBaseCluster_ExtensionProtocolOptionsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Cluster_ExtensionProtocolOptionsEntry.$type, Cluster_ExtensionProtocolOptionsEntry);

function createBaseCluster_TypedExtensionProtocolOptionsEntry(): Cluster_TypedExtensionProtocolOptionsEntry {
  return { $type: "envoy.api.v2.Cluster.TypedExtensionProtocolOptionsEntry", key: "" };
}

export const Cluster_TypedExtensionProtocolOptionsEntry: MessageFns<
  Cluster_TypedExtensionProtocolOptionsEntry,
  "envoy.api.v2.Cluster.TypedExtensionProtocolOptionsEntry"
> = {
  $type: "envoy.api.v2.Cluster.TypedExtensionProtocolOptionsEntry" as const,

  encode(message: Cluster_TypedExtensionProtocolOptionsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Any.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_TypedExtensionProtocolOptionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_TypedExtensionProtocolOptionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_TypedExtensionProtocolOptionsEntry {
    return {
      $type: Cluster_TypedExtensionProtocolOptionsEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Any.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Cluster_TypedExtensionProtocolOptionsEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Any.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Cluster_TypedExtensionProtocolOptionsEntry>, I>>(
    base?: I,
  ): Cluster_TypedExtensionProtocolOptionsEntry {
    return Cluster_TypedExtensionProtocolOptionsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cluster_TypedExtensionProtocolOptionsEntry>, I>>(
    object: I,
  ): Cluster_TypedExtensionProtocolOptionsEntry {
    const message = createBaseCluster_TypedExtensionProtocolOptionsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Any.fromPartial(object.value) : undefined;
    return message;
  },
};

messageTypeRegistry.set(Cluster_TypedExtensionProtocolOptionsEntry.$type, Cluster_TypedExtensionProtocolOptionsEntry);

function createBaseLoadBalancingPolicy(): LoadBalancingPolicy {
  return { $type: "envoy.api.v2.LoadBalancingPolicy" };
}

export const LoadBalancingPolicy: MessageFns<LoadBalancingPolicy, "envoy.api.v2.LoadBalancingPolicy"> = {
  $type: "envoy.api.v2.LoadBalancingPolicy" as const,

  encode(message: LoadBalancingPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.policies !== undefined && message.policies.length !== 0) {
      for (const v of message.policies) {
        LoadBalancingPolicy_Policy.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoadBalancingPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoadBalancingPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.policies === undefined) {
            message.policies = [];
          }
          const el = LoadBalancingPolicy_Policy.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.policies!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoadBalancingPolicy {
    return {
      $type: LoadBalancingPolicy.$type,
      policies: globalThis.Array.isArray(object?.policies)
        ? object.policies.map((e: any) => LoadBalancingPolicy_Policy.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: LoadBalancingPolicy): unknown {
    const obj: any = {};
    if (message.policies?.length) {
      obj.policies = message.policies.map((e) => LoadBalancingPolicy_Policy.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoadBalancingPolicy>, I>>(base?: I): LoadBalancingPolicy {
    return LoadBalancingPolicy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoadBalancingPolicy>, I>>(object: I): LoadBalancingPolicy {
    const message = createBaseLoadBalancingPolicy();
    message.policies = object.policies?.map((e) => LoadBalancingPolicy_Policy.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(LoadBalancingPolicy.$type, LoadBalancingPolicy);

function createBaseLoadBalancingPolicy_Policy(): LoadBalancingPolicy_Policy {
  return { $type: "envoy.api.v2.LoadBalancingPolicy.Policy" };
}

export const LoadBalancingPolicy_Policy: MessageFns<
  LoadBalancingPolicy_Policy,
  "envoy.api.v2.LoadBalancingPolicy.Policy"
> = {
  $type: "envoy.api.v2.LoadBalancingPolicy.Policy" as const,

  encode(message: LoadBalancingPolicy_Policy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.config !== undefined) {
      Struct.encode(Struct.wrap(message.config), writer.uint32(18).fork()).join();
    }
    if (message.typed_config !== undefined) {
      Any.encode(message.typed_config, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoadBalancingPolicy_Policy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoadBalancingPolicy_Policy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.config = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.typed_config = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoadBalancingPolicy_Policy {
    return {
      $type: LoadBalancingPolicy_Policy.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      config: isObject(object.config) ? object.config : undefined,
      typed_config: isSet(object.typed_config) ? Any.fromJSON(object.typed_config) : undefined,
    };
  },

  toJSON(message: LoadBalancingPolicy_Policy): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.config !== undefined) {
      obj.config = message.config;
    }
    if (message.typed_config !== undefined) {
      obj.typed_config = Any.toJSON(message.typed_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoadBalancingPolicy_Policy>, I>>(base?: I): LoadBalancingPolicy_Policy {
    return LoadBalancingPolicy_Policy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoadBalancingPolicy_Policy>, I>>(object: I): LoadBalancingPolicy_Policy {
    const message = createBaseLoadBalancingPolicy_Policy();
    message.name = object.name ?? undefined;
    message.config = object.config ?? undefined;
    message.typed_config = (object.typed_config !== undefined && object.typed_config !== null)
      ? Any.fromPartial(object.typed_config)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(LoadBalancingPolicy_Policy.$type, LoadBalancingPolicy_Policy);

function createBaseUpstreamBindConfig(): UpstreamBindConfig {
  return { $type: "envoy.api.v2.UpstreamBindConfig" };
}

export const UpstreamBindConfig: MessageFns<UpstreamBindConfig, "envoy.api.v2.UpstreamBindConfig"> = {
  $type: "envoy.api.v2.UpstreamBindConfig" as const,

  encode(message: UpstreamBindConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source_address !== undefined) {
      Address.encode(message.source_address, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpstreamBindConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpstreamBindConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.source_address = Address.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpstreamBindConfig {
    return {
      $type: UpstreamBindConfig.$type,
      source_address: isSet(object.source_address) ? Address.fromJSON(object.source_address) : undefined,
    };
  },

  toJSON(message: UpstreamBindConfig): unknown {
    const obj: any = {};
    if (message.source_address !== undefined) {
      obj.source_address = Address.toJSON(message.source_address);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpstreamBindConfig>, I>>(base?: I): UpstreamBindConfig {
    return UpstreamBindConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpstreamBindConfig>, I>>(object: I): UpstreamBindConfig {
    const message = createBaseUpstreamBindConfig();
    message.source_address = (object.source_address !== undefined && object.source_address !== null)
      ? Address.fromPartial(object.source_address)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(UpstreamBindConfig.$type, UpstreamBindConfig);

function createBaseUpstreamConnectionOptions(): UpstreamConnectionOptions {
  return { $type: "envoy.api.v2.UpstreamConnectionOptions" };
}

export const UpstreamConnectionOptions: MessageFns<
  UpstreamConnectionOptions,
  "envoy.api.v2.UpstreamConnectionOptions"
> = {
  $type: "envoy.api.v2.UpstreamConnectionOptions" as const,

  encode(message: UpstreamConnectionOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tcp_keepalive !== undefined) {
      TcpKeepalive.encode(message.tcp_keepalive, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpstreamConnectionOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpstreamConnectionOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tcp_keepalive = TcpKeepalive.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpstreamConnectionOptions {
    return {
      $type: UpstreamConnectionOptions.$type,
      tcp_keepalive: isSet(object.tcp_keepalive) ? TcpKeepalive.fromJSON(object.tcp_keepalive) : undefined,
    };
  },

  toJSON(message: UpstreamConnectionOptions): unknown {
    const obj: any = {};
    if (message.tcp_keepalive !== undefined) {
      obj.tcp_keepalive = TcpKeepalive.toJSON(message.tcp_keepalive);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpstreamConnectionOptions>, I>>(base?: I): UpstreamConnectionOptions {
    return UpstreamConnectionOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpstreamConnectionOptions>, I>>(object: I): UpstreamConnectionOptions {
    const message = createBaseUpstreamConnectionOptions();
    message.tcp_keepalive = (object.tcp_keepalive !== undefined && object.tcp_keepalive !== null)
      ? TcpKeepalive.fromPartial(object.tcp_keepalive)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(UpstreamConnectionOptions.$type, UpstreamConnectionOptions);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
