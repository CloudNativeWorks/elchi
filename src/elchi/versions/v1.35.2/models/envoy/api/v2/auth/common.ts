// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/api/v2/auth/common.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Any } from "../../../../google/protobuf/any";
import { Struct } from "../../../../google/protobuf/struct";
import { BoolValue } from "../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../typeRegistry";
import { StringMatcher } from "../../../type/matcher/string";
import { DataSource } from "../core/base";

export const protobufPackage = "envoy.api.v2.auth";

export interface TlsParameters {
  $type: "envoy.api.v2.auth.TlsParameters";
  /** Minimum TLS protocol version. By default, it's ``TLSv1_2`` for both clients and servers. */
  tls_minimum_protocol_version?:
    | TlsParameters_TlsProtocol
    | undefined;
  /**
   * Maximum TLS protocol version. By default, it's ``TLSv1_2`` for clients and ``TLSv1_3`` for
   * servers.
   */
  tls_maximum_protocol_version?:
    | TlsParameters_TlsProtocol
    | undefined;
  /**
   * If specified, the TLS listener will only support the specified `cipher list
   * <https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration>`_
   * when negotiating TLS 1.0-1.2 (this setting has no effect when negotiating TLS 1.3). If not
   * specified, the default list will be used.
   *
   * In non-FIPS builds, the default cipher list is:
   *
   * .. code-block:: none
   *
   *   [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
   *   [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
   *   ECDHE-ECDSA-AES128-SHA
   *   ECDHE-RSA-AES128-SHA
   *   AES128-GCM-SHA256
   *   AES128-SHA
   *   ECDHE-ECDSA-AES256-GCM-SHA384
   *   ECDHE-RSA-AES256-GCM-SHA384
   *   ECDHE-ECDSA-AES256-SHA
   *   ECDHE-RSA-AES256-SHA
   *   AES256-GCM-SHA384
   *   AES256-SHA
   *
   * In builds using :ref:`BoringSSL FIPS <arch_overview_ssl_fips>`, the default cipher list is:
   *
   * .. code-block:: none
   *
   *   ECDHE-ECDSA-AES128-GCM-SHA256
   *   ECDHE-RSA-AES128-GCM-SHA256
   *   ECDHE-ECDSA-AES128-SHA
   *   ECDHE-RSA-AES128-SHA
   *   AES128-GCM-SHA256
   *   AES128-SHA
   *   ECDHE-ECDSA-AES256-GCM-SHA384
   *   ECDHE-RSA-AES256-GCM-SHA384
   *   ECDHE-ECDSA-AES256-SHA
   *   ECDHE-RSA-AES256-SHA
   *   AES256-GCM-SHA384
   *   AES256-SHA
   */
  cipher_suites?:
    | string[]
    | undefined;
  /**
   * If specified, the TLS connection will only support the specified ECDH
   * curves. If not specified, the default curves will be used.
   *
   * In non-FIPS builds, the default curves are:
   *
   * .. code-block:: none
   *
   *   X25519
   *   P-256
   *
   * In builds using :ref:`BoringSSL FIPS <arch_overview_ssl_fips>`, the default curve is:
   *
   * .. code-block:: none
   *
   *   P-256
   */
  ecdh_curves?: string[] | undefined;
}

export enum TlsParameters_TlsProtocol {
  /** TLS_AUTO - Envoy will choose the optimal TLS version. */
  TLS_AUTO = "TLS_AUTO",
  /** TLSv1_0 - TLS 1.0 */
  TLSv1_0 = "TLSv1_0",
  /** TLSv1_1 - TLS 1.1 */
  TLSv1_1 = "TLSv1_1",
  /** TLSv1_2 - TLS 1.2 */
  TLSv1_2 = "TLSv1_2",
  /** TLSv1_3 - TLS 1.3 */
  TLSv1_3 = "TLSv1_3",
}

export function tlsParameters_TlsProtocolFromJSON(object: any): TlsParameters_TlsProtocol {
  switch (object) {
    case 0:
    case "TLS_AUTO":
      return TlsParameters_TlsProtocol.TLS_AUTO;
    case 1:
    case "TLSv1_0":
      return TlsParameters_TlsProtocol.TLSv1_0;
    case 2:
    case "TLSv1_1":
      return TlsParameters_TlsProtocol.TLSv1_1;
    case 3:
    case "TLSv1_2":
      return TlsParameters_TlsProtocol.TLSv1_2;
    case 4:
    case "TLSv1_3":
      return TlsParameters_TlsProtocol.TLSv1_3;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum TlsParameters_TlsProtocol");
  }
}

export function tlsParameters_TlsProtocolToJSON(object: TlsParameters_TlsProtocol): string {
  switch (object) {
    case TlsParameters_TlsProtocol.TLS_AUTO:
      return "TLS_AUTO";
    case TlsParameters_TlsProtocol.TLSv1_0:
      return "TLSv1_0";
    case TlsParameters_TlsProtocol.TLSv1_1:
      return "TLSv1_1";
    case TlsParameters_TlsProtocol.TLSv1_2:
      return "TLSv1_2";
    case TlsParameters_TlsProtocol.TLSv1_3:
      return "TLSv1_3";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum TlsParameters_TlsProtocol");
  }
}

export function tlsParameters_TlsProtocolToNumber(object: TlsParameters_TlsProtocol): number {
  switch (object) {
    case TlsParameters_TlsProtocol.TLS_AUTO:
      return 0;
    case TlsParameters_TlsProtocol.TLSv1_0:
      return 1;
    case TlsParameters_TlsProtocol.TLSv1_1:
      return 2;
    case TlsParameters_TlsProtocol.TLSv1_2:
      return 3;
    case TlsParameters_TlsProtocol.TLSv1_3:
      return 4;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum TlsParameters_TlsProtocol");
  }
}

/**
 * BoringSSL private key method configuration. The private key methods are used for external
 * (potentially asynchronous) signing and decryption operations. Some use cases for private key
 * methods would be TPM support and TLS acceleration.
 */
export interface PrivateKeyProvider {
  $type: "envoy.api.v2.auth.PrivateKeyProvider";
  /**
   * Private key method provider name. The name must match a
   * supported private key method provider type.
   */
  provider_name?:
    | string
    | undefined;
  /** Private key method provider specific configuration. */
  config_type?:
    | //
    { $case: "config"; config: { [key: string]: any } | undefined }
    | //
    { $case: "typed_config"; typed_config: Any }
    | undefined;
}

/** [#next-free-field: 7] */
export interface TlsCertificate {
  $type: "envoy.api.v2.auth.TlsCertificate";
  /** The TLS certificate chain. */
  certificate_chain?:
    | DataSource
    | undefined;
  /** The TLS private key. */
  private_key?:
    | DataSource
    | undefined;
  /**
   * BoringSSL private key method provider. This is an alternative to :ref:`private_key
   * <envoy_api_field_auth.TlsCertificate.private_key>` field. This can't be
   * marked as ``oneof`` due to API compatibility reasons. Setting both :ref:`private_key
   * <envoy_api_field_auth.TlsCertificate.private_key>` and
   * :ref:`private_key_provider
   * <envoy_api_field_auth.TlsCertificate.private_key_provider>` fields will result in an
   * error.
   */
  private_key_provider?:
    | PrivateKeyProvider
    | undefined;
  /**
   * The password to decrypt the TLS private key. If this field is not set, it is assumed that the
   * TLS private key is not password encrypted.
   */
  password?:
    | DataSource
    | undefined;
  /** [#not-implemented-hide:] */
  ocsp_staple?:
    | DataSource
    | undefined;
  /** [#not-implemented-hide:] */
  signed_certificate_timestamp?: DataSource[] | undefined;
}

export interface TlsSessionTicketKeys {
  $type: "envoy.api.v2.auth.TlsSessionTicketKeys";
  /**
   * Keys for encrypting and decrypting TLS session tickets. The
   * first key in the array contains the key to encrypt all new sessions created by this context.
   * All keys are candidates for decrypting received tickets. This allows for easy rotation of keys
   * by, for example, putting the new key first, and the previous key second.
   *
   * If :ref:`session_ticket_keys <envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys>`
   * is not specified, the TLS library will still support resuming sessions via tickets, but it will
   * use an internally-generated and managed key, so sessions cannot be resumed across hot restarts
   * or on different hosts.
   *
   * Each key must contain exactly 80 bytes of cryptographically-secure random data. For
   * example, the output of ``openssl rand 80``.
   *
   * .. attention::
   *
   *   Using this feature has serious security considerations and risks. Improper handling of keys
   *   may result in loss of secrecy in connections, even if ciphers supporting perfect forward
   *   secrecy are used. See https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some
   *   discussion. To minimize the risk, you must:
   *
   *   * Keep the session ticket keys at least as secure as your TLS certificate private keys
   *   * Rotate session ticket keys at least daily, and preferably hourly
   *   * Always generate keys using a cryptographically-secure random data source
   */
  keys?: DataSource[] | undefined;
}

/** [#next-free-field: 11] */
export interface CertificateValidationContext {
  $type: "envoy.api.v2.auth.CertificateValidationContext";
  /**
   * TLS certificate data containing certificate authority certificates to use in verifying
   * a presented peer certificate (e.g. server certificate for clusters or client certificate
   * for listeners). If not specified and a peer certificate is presented it will not be
   * verified. By default, a client certificate is optional, unless one of the additional
   * options (:ref:`require_client_certificate
   * <envoy_api_field_auth.DownstreamTlsContext.require_client_certificate>`,
   * :ref:`verify_certificate_spki
   * <envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki>`,
   * :ref:`verify_certificate_hash
   * <envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash>`, or
   * :ref:`match_subject_alt_names
   * <envoy_api_field_auth.CertificateValidationContext.match_subject_alt_names>`) is also
   * specified.
   *
   * It can optionally contain certificate revocation lists, in which case Envoy will verify
   * that the presented peer certificate has not been revoked by one of the included CRLs.
   *
   * See :ref:`the TLS overview <arch_overview_ssl_enabling_verification>` for a list of common
   * system CA locations.
   */
  trusted_ca?:
    | DataSource
    | undefined;
  /**
   * An optional list of base64-encoded SHA-256 hashes. If specified, Envoy will verify that the
   * SHA-256 of the DER-encoded Subject Public Key Information (SPKI) of the presented certificate
   * matches one of the specified values.
   *
   * A base64-encoded SHA-256 of the Subject Public Key Information (SPKI) of the certificate
   * can be generated with the following command:
   *
   * .. code-block:: bash
   *
   *   $ openssl x509 -in path/to/client.crt -noout -pubkey
   *     | openssl pkey -pubin -outform DER
   *     | openssl dgst -sha256 -binary
   *     | openssl enc -base64
   *   NvqYIYSbgK2vCJpQhObf77vv+bQWtc5ek5RIOwPiC9A=
   *
   * This is the format used in HTTP Public Key Pinning.
   *
   * When both:
   * :ref:`verify_certificate_hash
   * <envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash>` and
   * :ref:`verify_certificate_spki
   * <envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki>` are specified,
   * a hash matching value from either of the lists will result in the certificate being accepted.
   *
   * .. attention::
   *
   *   This option is preferred over :ref:`verify_certificate_hash
   *   <envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash>`,
   *   because SPKI is tied to a private key, so it doesn't change when the certificate
   *   is renewed using the same private key.
   */
  verify_certificate_spki?:
    | string[]
    | undefined;
  /**
   * An optional list of hex-encoded SHA-256 hashes. If specified, Envoy will verify that
   * the SHA-256 of the DER-encoded presented certificate matches one of the specified values.
   *
   * A hex-encoded SHA-256 of the certificate can be generated with the following command:
   *
   * .. code-block:: bash
   *
   *   $ openssl x509 -in path/to/client.crt -outform DER | openssl dgst -sha256 | cut -d" " -f2
   *   df6ff72fe9116521268f6f2dd4966f51df479883fe7037b39f75916ac3049d1a
   *
   * A long hex-encoded and colon-separated SHA-256 (a.k.a. "fingerprint") of the certificate
   * can be generated with the following command:
   *
   * .. code-block:: bash
   *
   *   $ openssl x509 -in path/to/client.crt -noout -fingerprint -sha256 | cut -d"=" -f2
   *   DF:6F:F7:2F:E9:11:65:21:26:8F:6F:2D:D4:96:6F:51:DF:47:98:83:FE:70:37:B3:9F:75:91:6A:C3:04:9D:1A
   *
   * Both of those formats are acceptable.
   *
   * When both:
   * :ref:`verify_certificate_hash
   * <envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash>` and
   * :ref:`verify_certificate_spki
   * <envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki>` are specified,
   * a hash matching value from either of the lists will result in the certificate being accepted.
   */
  verify_certificate_hash?:
    | string[]
    | undefined;
  /**
   * An optional list of Subject Alternative Names. If specified, Envoy will verify that the
   * Subject Alternative Name of the presented certificate matches one of the specified values.
   *
   * .. attention::
   *
   *   Subject Alternative Names are easily spoofable and verifying only them is insecure,
   *   therefore this option must be used together with :ref:`trusted_ca
   *   <envoy_api_field_auth.CertificateValidationContext.trusted_ca>`.
   *
   * @deprecated
   */
  verify_subject_alt_name?:
    | string[]
    | undefined;
  /**
   * An optional list of Subject Alternative name matchers. Envoy will verify that the
   * Subject Alternative Name of the presented certificate matches one of the specified matches.
   *
   * When a certificate has wildcard DNS SAN entries, to match a specific client, it should be
   * configured with exact match type in the :ref:`string matcher <envoy_api_msg_type.matcher.StringMatcher>`.
   * For example if the certificate has "\*.example.com" as DNS SAN entry, to allow only "api.example.com",
   * it should be configured as shown below.
   *
   * .. code-block:: yaml
   *
   *  match_subject_alt_names:
   *    exact: "api.example.com"
   *
   * .. attention::
   *
   *   Subject Alternative Names are easily spoofable and verifying only them is insecure,
   *   therefore this option must be used together with :ref:`trusted_ca
   *   <envoy_api_field_auth.CertificateValidationContext.trusted_ca>`.
   */
  match_subject_alt_names?:
    | StringMatcher[]
    | undefined;
  /** [#not-implemented-hide:] Must present a signed time-stamped OCSP response. */
  require_ocsp_staple?:
    | boolean
    | undefined;
  /** [#not-implemented-hide:] Must present signed certificate time-stamp. */
  require_signed_certificate_timestamp?:
    | boolean
    | undefined;
  /**
   * An optional `certificate revocation list
   * <https://en.wikipedia.org/wiki/Certificate_revocation_list>`_
   * (in PEM format). If specified, Envoy will verify that the presented peer
   * certificate has not been revoked by this CRL. If this DataSource contains
   * multiple CRLs, all of them will be used.
   */
  crl?:
    | DataSource
    | undefined;
  /** If specified, Envoy will not reject expired certificates. */
  allow_expired_certificate?:
    | boolean
    | undefined;
  /** Certificate trust chain verification mode. */
  trust_chain_verification?: CertificateValidationContext_TrustChainVerification | undefined;
}

/** Peer certificate verification mode. */
export enum CertificateValidationContext_TrustChainVerification {
  /** VERIFY_TRUST_CHAIN - Perform default certificate verification (e.g., against CA / verification lists) */
  VERIFY_TRUST_CHAIN = "VERIFY_TRUST_CHAIN",
  /**
   * ACCEPT_UNTRUSTED - Connections where the certificate fails verification will be permitted.
   * For HTTP connections, the result of certificate verification can be used in route matching. (
   * see :ref:`validated <envoy_api_field_route.RouteMatch.TlsContextMatchOptions.validated>` ).
   */
  ACCEPT_UNTRUSTED = "ACCEPT_UNTRUSTED",
}

export function certificateValidationContext_TrustChainVerificationFromJSON(
  object: any,
): CertificateValidationContext_TrustChainVerification {
  switch (object) {
    case 0:
    case "VERIFY_TRUST_CHAIN":
      return CertificateValidationContext_TrustChainVerification.VERIFY_TRUST_CHAIN;
    case 1:
    case "ACCEPT_UNTRUSTED":
      return CertificateValidationContext_TrustChainVerification.ACCEPT_UNTRUSTED;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CertificateValidationContext_TrustChainVerification",
      );
  }
}

export function certificateValidationContext_TrustChainVerificationToJSON(
  object: CertificateValidationContext_TrustChainVerification,
): string {
  switch (object) {
    case CertificateValidationContext_TrustChainVerification.VERIFY_TRUST_CHAIN:
      return "VERIFY_TRUST_CHAIN";
    case CertificateValidationContext_TrustChainVerification.ACCEPT_UNTRUSTED:
      return "ACCEPT_UNTRUSTED";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CertificateValidationContext_TrustChainVerification",
      );
  }
}

export function certificateValidationContext_TrustChainVerificationToNumber(
  object: CertificateValidationContext_TrustChainVerification,
): number {
  switch (object) {
    case CertificateValidationContext_TrustChainVerification.VERIFY_TRUST_CHAIN:
      return 0;
    case CertificateValidationContext_TrustChainVerification.ACCEPT_UNTRUSTED:
      return 1;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CertificateValidationContext_TrustChainVerification",
      );
  }
}

function createBaseTlsParameters(): TlsParameters {
  return { $type: "envoy.api.v2.auth.TlsParameters" };
}

export const TlsParameters: MessageFns<TlsParameters, "envoy.api.v2.auth.TlsParameters"> = {
  $type: "envoy.api.v2.auth.TlsParameters" as const,

  encode(message: TlsParameters, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (
      message.tls_minimum_protocol_version !== undefined &&
      message.tls_minimum_protocol_version !== TlsParameters_TlsProtocol.TLS_AUTO
    ) {
      writer.uint32(8).int32(tlsParameters_TlsProtocolToNumber(message.tls_minimum_protocol_version));
    }
    if (
      message.tls_maximum_protocol_version !== undefined &&
      message.tls_maximum_protocol_version !== TlsParameters_TlsProtocol.TLS_AUTO
    ) {
      writer.uint32(16).int32(tlsParameters_TlsProtocolToNumber(message.tls_maximum_protocol_version));
    }
    if (message.cipher_suites !== undefined && message.cipher_suites.length !== 0) {
      for (const v of message.cipher_suites) {
        writer.uint32(26).string(v!);
      }
    }
    if (message.ecdh_curves !== undefined && message.ecdh_curves.length !== 0) {
      for (const v of message.ecdh_curves) {
        writer.uint32(34).string(v!);
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TlsParameters {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTlsParameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.tls_minimum_protocol_version = tlsParameters_TlsProtocolFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.tls_maximum_protocol_version = tlsParameters_TlsProtocolFromJSON(reader.int32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.cipher_suites === undefined) {
            message.cipher_suites = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.cipher_suites!.push(el);
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          if (message.ecdh_curves === undefined) {
            message.ecdh_curves = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.ecdh_curves!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TlsParameters {
    return {
      $type: TlsParameters.$type,
      tls_minimum_protocol_version: isSet(object.tls_minimum_protocol_version)
        ? tlsParameters_TlsProtocolFromJSON(object.tls_minimum_protocol_version)
        : undefined,
      tls_maximum_protocol_version: isSet(object.tls_maximum_protocol_version)
        ? tlsParameters_TlsProtocolFromJSON(object.tls_maximum_protocol_version)
        : undefined,
      cipher_suites: globalThis.Array.isArray(object?.cipher_suites)
        ? object.cipher_suites.map((e: any) => globalThis.String(e))
        : undefined,
      ecdh_curves: globalThis.Array.isArray(object?.ecdh_curves)
        ? object.ecdh_curves.map((e: any) => globalThis.String(e))
        : undefined,
    };
  },

  toJSON(message: TlsParameters): unknown {
    const obj: any = {};
    if (message.tls_minimum_protocol_version !== undefined) {
      obj.tls_minimum_protocol_version = tlsParameters_TlsProtocolToJSON(message.tls_minimum_protocol_version);
    }
    if (message.tls_maximum_protocol_version !== undefined) {
      obj.tls_maximum_protocol_version = tlsParameters_TlsProtocolToJSON(message.tls_maximum_protocol_version);
    }
    if (message.cipher_suites?.length) {
      obj.cipher_suites = message.cipher_suites;
    }
    if (message.ecdh_curves?.length) {
      obj.ecdh_curves = message.ecdh_curves;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TlsParameters>, I>>(base?: I): TlsParameters {
    return TlsParameters.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TlsParameters>, I>>(object: I): TlsParameters {
    const message = createBaseTlsParameters();
    message.tls_minimum_protocol_version = object.tls_minimum_protocol_version ?? undefined;
    message.tls_maximum_protocol_version = object.tls_maximum_protocol_version ?? undefined;
    message.cipher_suites = object.cipher_suites?.map((e) => e) || undefined;
    message.ecdh_curves = object.ecdh_curves?.map((e) => e) || undefined;
    return message;
  },
};

messageTypeRegistry.set(TlsParameters.$type, TlsParameters);

function createBasePrivateKeyProvider(): PrivateKeyProvider {
  return { $type: "envoy.api.v2.auth.PrivateKeyProvider", config_type: undefined };
}

export const PrivateKeyProvider: MessageFns<PrivateKeyProvider, "envoy.api.v2.auth.PrivateKeyProvider"> = {
  $type: "envoy.api.v2.auth.PrivateKeyProvider" as const,

  encode(message: PrivateKeyProvider, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provider_name !== undefined && message.provider_name !== "") {
      writer.uint32(10).string(message.provider_name);
    }
    switch (message.config_type?.$case) {
      case "config":
        Struct.encode(Struct.wrap(message.config_type.config), writer.uint32(18).fork()).join();
        break;
      case "typed_config":
        Any.encode(message.config_type.typed_config, writer.uint32(26).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrivateKeyProvider {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrivateKeyProvider();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.provider_name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.config_type = { $case: "config", config: Struct.unwrap(Struct.decode(reader, reader.uint32())) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.config_type = { $case: "typed_config", typed_config: Any.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrivateKeyProvider {
    return {
      $type: PrivateKeyProvider.$type,
      provider_name: isSet(object.provider_name) ? globalThis.String(object.provider_name) : undefined,
      config_type: isSet(object.config)
        ? { $case: "config", config: object.config }
        : isSet(object.typed_config)
        ? { $case: "typed_config", typed_config: Any.fromJSON(object.typed_config) }
        : undefined,
    };
  },

  toJSON(message: PrivateKeyProvider): unknown {
    const obj: any = {};
    if (message.provider_name !== undefined) {
      obj.provider_name = message.provider_name;
    }
    if (message.config_type?.$case === "config") {
      obj.config = message.config_type.config;
    }
    if (message.config_type?.$case === "typed_config") {
      obj.typed_config = Any.toJSON(message.config_type.typed_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PrivateKeyProvider>, I>>(base?: I): PrivateKeyProvider {
    return PrivateKeyProvider.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PrivateKeyProvider>, I>>(object: I): PrivateKeyProvider {
    const message = createBasePrivateKeyProvider();
    message.provider_name = object.provider_name ?? undefined;
    if (
      object.config_type?.$case === "config" &&
      object.config_type?.config !== undefined &&
      object.config_type?.config !== null
    ) {
      message.config_type = { $case: "config", config: object.config_type.config };
    }
    if (
      object.config_type?.$case === "typed_config" &&
      object.config_type?.typed_config !== undefined &&
      object.config_type?.typed_config !== null
    ) {
      message.config_type = { $case: "typed_config", typed_config: Any.fromPartial(object.config_type.typed_config) };
    }
    return message;
  },
};

messageTypeRegistry.set(PrivateKeyProvider.$type, PrivateKeyProvider);

function createBaseTlsCertificate(): TlsCertificate {
  return { $type: "envoy.api.v2.auth.TlsCertificate" };
}

export const TlsCertificate: MessageFns<TlsCertificate, "envoy.api.v2.auth.TlsCertificate"> = {
  $type: "envoy.api.v2.auth.TlsCertificate" as const,

  encode(message: TlsCertificate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.certificate_chain !== undefined) {
      DataSource.encode(message.certificate_chain, writer.uint32(10).fork()).join();
    }
    if (message.private_key !== undefined) {
      DataSource.encode(message.private_key, writer.uint32(18).fork()).join();
    }
    if (message.private_key_provider !== undefined) {
      PrivateKeyProvider.encode(message.private_key_provider, writer.uint32(50).fork()).join();
    }
    if (message.password !== undefined) {
      DataSource.encode(message.password, writer.uint32(26).fork()).join();
    }
    if (message.ocsp_staple !== undefined) {
      DataSource.encode(message.ocsp_staple, writer.uint32(34).fork()).join();
    }
    if (message.signed_certificate_timestamp !== undefined && message.signed_certificate_timestamp.length !== 0) {
      for (const v of message.signed_certificate_timestamp) {
        DataSource.encode(v!, writer.uint32(42).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TlsCertificate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTlsCertificate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.certificate_chain = DataSource.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.private_key = DataSource.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.private_key_provider = PrivateKeyProvider.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.password = DataSource.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.ocsp_staple = DataSource.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          if (message.signed_certificate_timestamp === undefined) {
            message.signed_certificate_timestamp = [];
          }
          const el = DataSource.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.signed_certificate_timestamp!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TlsCertificate {
    return {
      $type: TlsCertificate.$type,
      certificate_chain: isSet(object.certificate_chain) ? DataSource.fromJSON(object.certificate_chain) : undefined,
      private_key: isSet(object.private_key) ? DataSource.fromJSON(object.private_key) : undefined,
      private_key_provider: isSet(object.private_key_provider)
        ? PrivateKeyProvider.fromJSON(object.private_key_provider)
        : undefined,
      password: isSet(object.password) ? DataSource.fromJSON(object.password) : undefined,
      ocsp_staple: isSet(object.ocsp_staple) ? DataSource.fromJSON(object.ocsp_staple) : undefined,
      signed_certificate_timestamp: globalThis.Array.isArray(object?.signed_certificate_timestamp)
        ? object.signed_certificate_timestamp.map((e: any) => DataSource.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: TlsCertificate): unknown {
    const obj: any = {};
    if (message.certificate_chain !== undefined) {
      obj.certificate_chain = DataSource.toJSON(message.certificate_chain);
    }
    if (message.private_key !== undefined) {
      obj.private_key = DataSource.toJSON(message.private_key);
    }
    if (message.private_key_provider !== undefined) {
      obj.private_key_provider = PrivateKeyProvider.toJSON(message.private_key_provider);
    }
    if (message.password !== undefined) {
      obj.password = DataSource.toJSON(message.password);
    }
    if (message.ocsp_staple !== undefined) {
      obj.ocsp_staple = DataSource.toJSON(message.ocsp_staple);
    }
    if (message.signed_certificate_timestamp?.length) {
      obj.signed_certificate_timestamp = message.signed_certificate_timestamp.map((e) => DataSource.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TlsCertificate>, I>>(base?: I): TlsCertificate {
    return TlsCertificate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TlsCertificate>, I>>(object: I): TlsCertificate {
    const message = createBaseTlsCertificate();
    message.certificate_chain = (object.certificate_chain !== undefined && object.certificate_chain !== null)
      ? DataSource.fromPartial(object.certificate_chain)
      : undefined;
    message.private_key = (object.private_key !== undefined && object.private_key !== null)
      ? DataSource.fromPartial(object.private_key)
      : undefined;
    message.private_key_provider = (object.private_key_provider !== undefined && object.private_key_provider !== null)
      ? PrivateKeyProvider.fromPartial(object.private_key_provider)
      : undefined;
    message.password = (object.password !== undefined && object.password !== null)
      ? DataSource.fromPartial(object.password)
      : undefined;
    message.ocsp_staple = (object.ocsp_staple !== undefined && object.ocsp_staple !== null)
      ? DataSource.fromPartial(object.ocsp_staple)
      : undefined;
    message.signed_certificate_timestamp = object.signed_certificate_timestamp?.map((e) => DataSource.fromPartial(e)) ||
      undefined;
    return message;
  },
};

messageTypeRegistry.set(TlsCertificate.$type, TlsCertificate);

function createBaseTlsSessionTicketKeys(): TlsSessionTicketKeys {
  return { $type: "envoy.api.v2.auth.TlsSessionTicketKeys" };
}

export const TlsSessionTicketKeys: MessageFns<TlsSessionTicketKeys, "envoy.api.v2.auth.TlsSessionTicketKeys"> = {
  $type: "envoy.api.v2.auth.TlsSessionTicketKeys" as const,

  encode(message: TlsSessionTicketKeys, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keys !== undefined && message.keys.length !== 0) {
      for (const v of message.keys) {
        DataSource.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TlsSessionTicketKeys {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTlsSessionTicketKeys();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.keys === undefined) {
            message.keys = [];
          }
          const el = DataSource.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.keys!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TlsSessionTicketKeys {
    return {
      $type: TlsSessionTicketKeys.$type,
      keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e: any) => DataSource.fromJSON(e)) : undefined,
    };
  },

  toJSON(message: TlsSessionTicketKeys): unknown {
    const obj: any = {};
    if (message.keys?.length) {
      obj.keys = message.keys.map((e) => DataSource.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TlsSessionTicketKeys>, I>>(base?: I): TlsSessionTicketKeys {
    return TlsSessionTicketKeys.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TlsSessionTicketKeys>, I>>(object: I): TlsSessionTicketKeys {
    const message = createBaseTlsSessionTicketKeys();
    message.keys = object.keys?.map((e) => DataSource.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(TlsSessionTicketKeys.$type, TlsSessionTicketKeys);

function createBaseCertificateValidationContext(): CertificateValidationContext {
  return { $type: "envoy.api.v2.auth.CertificateValidationContext" };
}

export const CertificateValidationContext: MessageFns<
  CertificateValidationContext,
  "envoy.api.v2.auth.CertificateValidationContext"
> = {
  $type: "envoy.api.v2.auth.CertificateValidationContext" as const,

  encode(message: CertificateValidationContext, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trusted_ca !== undefined) {
      DataSource.encode(message.trusted_ca, writer.uint32(10).fork()).join();
    }
    if (message.verify_certificate_spki !== undefined && message.verify_certificate_spki.length !== 0) {
      for (const v of message.verify_certificate_spki) {
        writer.uint32(26).string(v!);
      }
    }
    if (message.verify_certificate_hash !== undefined && message.verify_certificate_hash.length !== 0) {
      for (const v of message.verify_certificate_hash) {
        writer.uint32(18).string(v!);
      }
    }
    if (message.verify_subject_alt_name !== undefined && message.verify_subject_alt_name.length !== 0) {
      for (const v of message.verify_subject_alt_name) {
        writer.uint32(34).string(v!);
      }
    }
    if (message.match_subject_alt_names !== undefined && message.match_subject_alt_names.length !== 0) {
      for (const v of message.match_subject_alt_names) {
        StringMatcher.encode(v!, writer.uint32(74).fork()).join();
      }
    }
    if (message.require_ocsp_staple !== undefined) {
      BoolValue.encode(
        { $type: "google.protobuf.BoolValue", value: message.require_ocsp_staple! },
        writer.uint32(42).fork(),
      ).join();
    }
    if (message.require_signed_certificate_timestamp !== undefined) {
      BoolValue.encode(
        { $type: "google.protobuf.BoolValue", value: message.require_signed_certificate_timestamp! },
        writer.uint32(50).fork(),
      ).join();
    }
    if (message.crl !== undefined) {
      DataSource.encode(message.crl, writer.uint32(58).fork()).join();
    }
    if (message.allow_expired_certificate !== undefined && message.allow_expired_certificate !== false) {
      writer.uint32(64).bool(message.allow_expired_certificate);
    }
    if (
      message.trust_chain_verification !== undefined &&
      message.trust_chain_verification !== CertificateValidationContext_TrustChainVerification.VERIFY_TRUST_CHAIN
    ) {
      writer.uint32(80).int32(
        certificateValidationContext_TrustChainVerificationToNumber(message.trust_chain_verification),
      );
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateValidationContext {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateValidationContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trusted_ca = DataSource.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.verify_certificate_spki === undefined) {
            message.verify_certificate_spki = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.verify_certificate_spki!.push(el);
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.verify_certificate_hash === undefined) {
            message.verify_certificate_hash = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.verify_certificate_hash!.push(el);
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          if (message.verify_subject_alt_name === undefined) {
            message.verify_subject_alt_name = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.verify_subject_alt_name!.push(el);
          }
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          if (message.match_subject_alt_names === undefined) {
            message.match_subject_alt_names = [];
          }
          const el = StringMatcher.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.match_subject_alt_names!.push(el);
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.require_ocsp_staple = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.require_signed_certificate_timestamp = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.crl = DataSource.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.allow_expired_certificate = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.trust_chain_verification = certificateValidationContext_TrustChainVerificationFromJSON(
            reader.int32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateValidationContext {
    return {
      $type: CertificateValidationContext.$type,
      trusted_ca: isSet(object.trusted_ca) ? DataSource.fromJSON(object.trusted_ca) : undefined,
      verify_certificate_spki: globalThis.Array.isArray(object?.verify_certificate_spki)
        ? object.verify_certificate_spki.map((e: any) => globalThis.String(e))
        : undefined,
      verify_certificate_hash: globalThis.Array.isArray(object?.verify_certificate_hash)
        ? object.verify_certificate_hash.map((e: any) => globalThis.String(e))
        : undefined,
      verify_subject_alt_name: globalThis.Array.isArray(object?.verify_subject_alt_name)
        ? object.verify_subject_alt_name.map((e: any) => globalThis.String(e))
        : undefined,
      match_subject_alt_names: globalThis.Array.isArray(object?.match_subject_alt_names)
        ? object.match_subject_alt_names.map((e: any) => StringMatcher.fromJSON(e))
        : undefined,
      require_ocsp_staple: isSet(object.require_ocsp_staple) ? Boolean(object.require_ocsp_staple) : undefined,
      require_signed_certificate_timestamp: isSet(object.require_signed_certificate_timestamp)
        ? Boolean(object.require_signed_certificate_timestamp)
        : undefined,
      crl: isSet(object.crl) ? DataSource.fromJSON(object.crl) : undefined,
      allow_expired_certificate: isSet(object.allow_expired_certificate)
        ? globalThis.Boolean(object.allow_expired_certificate)
        : undefined,
      trust_chain_verification: isSet(object.trust_chain_verification)
        ? certificateValidationContext_TrustChainVerificationFromJSON(object.trust_chain_verification)
        : undefined,
    };
  },

  toJSON(message: CertificateValidationContext): unknown {
    const obj: any = {};
    if (message.trusted_ca !== undefined) {
      obj.trusted_ca = DataSource.toJSON(message.trusted_ca);
    }
    if (message.verify_certificate_spki?.length) {
      obj.verify_certificate_spki = message.verify_certificate_spki;
    }
    if (message.verify_certificate_hash?.length) {
      obj.verify_certificate_hash = message.verify_certificate_hash;
    }
    if (message.verify_subject_alt_name?.length) {
      obj.verify_subject_alt_name = message.verify_subject_alt_name;
    }
    if (message.match_subject_alt_names?.length) {
      obj.match_subject_alt_names = message.match_subject_alt_names.map((e) => StringMatcher.toJSON(e));
    }
    if (message.require_ocsp_staple !== undefined) {
      obj.require_ocsp_staple = message.require_ocsp_staple;
    }
    if (message.require_signed_certificate_timestamp !== undefined) {
      obj.require_signed_certificate_timestamp = message.require_signed_certificate_timestamp;
    }
    if (message.crl !== undefined) {
      obj.crl = DataSource.toJSON(message.crl);
    }
    if (message.allow_expired_certificate !== undefined) {
      obj.allow_expired_certificate = message.allow_expired_certificate;
    }
    if (message.trust_chain_verification !== undefined) {
      obj.trust_chain_verification = certificateValidationContext_TrustChainVerificationToJSON(
        message.trust_chain_verification,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CertificateValidationContext>, I>>(base?: I): CertificateValidationContext {
    return CertificateValidationContext.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CertificateValidationContext>, I>>(object: I): CertificateValidationContext {
    const message = createBaseCertificateValidationContext();
    message.trusted_ca = (object.trusted_ca !== undefined && object.trusted_ca !== null)
      ? DataSource.fromPartial(object.trusted_ca)
      : undefined;
    message.verify_certificate_spki = object.verify_certificate_spki?.map((e) => e) || undefined;
    message.verify_certificate_hash = object.verify_certificate_hash?.map((e) => e) || undefined;
    message.verify_subject_alt_name = object.verify_subject_alt_name?.map((e) => e) || undefined;
    message.match_subject_alt_names = object.match_subject_alt_names?.map((e) => StringMatcher.fromPartial(e)) ||
      undefined;
    message.require_ocsp_staple = object.require_ocsp_staple ?? undefined;
    message.require_signed_certificate_timestamp = object.require_signed_certificate_timestamp ?? undefined;
    message.crl = (object.crl !== undefined && object.crl !== null) ? DataSource.fromPartial(object.crl) : undefined;
    message.allow_expired_certificate = object.allow_expired_certificate ?? undefined;
    message.trust_chain_verification = object.trust_chain_verification ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(CertificateValidationContext.$type, CertificateValidationContext);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
