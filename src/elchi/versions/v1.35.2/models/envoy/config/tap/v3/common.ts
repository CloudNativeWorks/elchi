// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/config/tap/v3/common.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../../google/protobuf/duration";
import { UInt32Value } from "../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../typeRegistry";
import { MatchPredicate as MatchPredicate1 } from "../../common/matcher/v3/matcher";
import { RuntimeFractionalPercent } from "../../core/v3/base";
import { TypedExtensionConfig } from "../../core/v3/extension";
import { GrpcService } from "../../core/v3/grpc_service";
import { HeaderMatcher } from "../../route/v3/route_components";

export const protobufPackage = "envoy.config.tap.v3";

/** Tap configuration. */
export interface TapConfig {
  $type: "envoy.config.tap.v3.TapConfig";
  /**
   * The match configuration. If the configuration matches the data source being tapped, a tap will
   * occur, with the result written to the configured output.
   * Exactly one of :ref:`match <envoy_v3_api_field_config.tap.v3.TapConfig.match>` and
   * :ref:`match_config <envoy_v3_api_field_config.tap.v3.TapConfig.match_config>` must be set. If both
   * are set, the :ref:`match <envoy_v3_api_field_config.tap.v3.TapConfig.match>` will be used.
   *
   * @deprecated
   */
  match_config?:
    | MatchPredicate
    | undefined;
  /**
   * The match configuration. If the configuration matches the data source being tapped, a tap will
   * occur, with the result written to the configured output.
   * Exactly one of :ref:`match <envoy_v3_api_field_config.tap.v3.TapConfig.match>` and
   * :ref:`match_config <envoy_v3_api_field_config.tap.v3.TapConfig.match_config>` must be set. If both
   * are set, the :ref:`match <envoy_v3_api_field_config.tap.v3.TapConfig.match>` will be used.
   */
  match?:
    | MatchPredicate1
    | undefined;
  /**
   * The tap output configuration. If a match configuration matches a data source being tapped,
   * a tap will occur and the data will be written to the configured output.
   */
  output_config?:
    | OutputConfig
    | undefined;
  /**
   * [#not-implemented-hide:] Specify if Tap matching is enabled. The % of requests\connections for
   * which the tap matching is enabled. When not enabled, the request\connection will not be
   * recorded.
   *
   * .. note::
   *
   *   This field defaults to 100/:ref:`HUNDRED
   *   <envoy_v3_api_enum_type.v3.FractionalPercent.DenominatorType>`.
   */
  tap_enabled?: RuntimeFractionalPercent | undefined;
}

/**
 * Tap match configuration. This is a recursive structure which allows complex nested match
 * configurations to be built using various logical operators.
 * [#next-free-field: 11]
 */
export interface MatchPredicate {
  $type: "envoy.config.tap.v3.MatchPredicate";
  rule?:
    | //
    /**
     * A set that describes a logical OR. If any member of the set matches, the match configuration
     * matches.
     */
    { $case: "or_match"; or_match: MatchPredicate_MatchSet }
    | //
    /**
     * A set that describes a logical AND. If all members of the set match, the match configuration
     * matches.
     */
    { $case: "and_match"; and_match: MatchPredicate_MatchSet }
    | //
    /** A negation match. The match configuration will match if the negated match condition matches. */
    { $case: "not_match"; not_match: MatchPredicate }
    | //
    /** The match configuration will always match. */
    { $case: "any_match"; any_match: boolean }
    | //
    /** HTTP request headers match configuration. */
    { $case: "http_request_headers_match"; http_request_headers_match: HttpHeadersMatch }
    | //
    /** HTTP request trailers match configuration. */
    { $case: "http_request_trailers_match"; http_request_trailers_match: HttpHeadersMatch }
    | //
    /** HTTP response headers match configuration. */
    { $case: "http_response_headers_match"; http_response_headers_match: HttpHeadersMatch }
    | //
    /** HTTP response trailers match configuration. */
    { $case: "http_response_trailers_match"; http_response_trailers_match: HttpHeadersMatch }
    | //
    /** HTTP request generic body match configuration. */
    { $case: "http_request_generic_body_match"; http_request_generic_body_match: HttpGenericBodyMatch }
    | //
    /** HTTP response generic body match configuration. */
    { $case: "http_response_generic_body_match"; http_response_generic_body_match: HttpGenericBodyMatch }
    | undefined;
}

/** A set of match configurations used for logical operations. */
export interface MatchPredicate_MatchSet {
  $type: "envoy.config.tap.v3.MatchPredicate.MatchSet";
  /** The list of rules that make up the set. */
  rules?: MatchPredicate[] | undefined;
}

/** HTTP headers match configuration. */
export interface HttpHeadersMatch {
  $type: "envoy.config.tap.v3.HttpHeadersMatch";
  /** HTTP headers to match. */
  headers?: HeaderMatcher[] | undefined;
}

/**
 * HTTP generic body match configuration.
 * List of text strings and hex strings to be located in HTTP body.
 * All specified strings must be found in the HTTP body for positive match.
 * The search may be limited to specified number of bytes from the body start.
 *
 * .. attention::
 *
 *   Searching for patterns in HTTP body is potentially cpu intensive. For each specified pattern, http body is scanned byte by byte to find a match.
 *   If multiple patterns are specified, the process is repeated for each pattern. If location of a pattern is known, ``bytes_limit`` should be specified
 *   to scan only part of the http body.
 */
export interface HttpGenericBodyMatch {
  $type: "envoy.config.tap.v3.HttpGenericBodyMatch";
  /** Limits search to specified number of bytes - default zero (no limit - match entire captured buffer). */
  bytes_limit?:
    | number
    | undefined;
  /** List of patterns to match. */
  patterns?: HttpGenericBodyMatch_GenericTextMatch[] | undefined;
}

export interface HttpGenericBodyMatch_GenericTextMatch {
  $type: "envoy.config.tap.v3.HttpGenericBodyMatch.GenericTextMatch";
  rule?:
    | //
    /** Text string to be located in HTTP body. */
    { $case: "string_match"; string_match: string }
    | //
    /** Sequence of bytes to be located in HTTP body. */
    { $case: "binary_match"; binary_match: Uint8Array }
    | undefined;
}

/**
 * Tap output configuration.
 * [#next-free-field: 6]
 */
export interface OutputConfig {
  $type: "envoy.config.tap.v3.OutputConfig";
  /**
   * Output sinks for tap data. Currently a single sink is allowed in the list. Once multiple
   * sink types are supported this constraint will be relaxed.
   */
  sinks?:
    | OutputSink[]
    | undefined;
  /**
   * For buffered tapping, the maximum amount of received body that will be buffered prior to
   * truncation. If truncation occurs, the :ref:`truncated
   * <envoy_v3_api_field_data.tap.v3.Body.truncated>` field will be set. If not specified, the
   * default is 1KiB.
   */
  max_buffered_rx_bytes?:
    | number
    | undefined;
  /**
   * For buffered tapping, the maximum amount of transmitted body that will be buffered prior to
   * truncation. If truncation occurs, the :ref:`truncated
   * <envoy_v3_api_field_data.tap.v3.Body.truncated>` field will be set. If not specified, the
   * default is 1KiB.
   */
  max_buffered_tx_bytes?:
    | number
    | undefined;
  /**
   * Indicates whether taps produce a single buffered message per tap, or multiple streamed
   * messages per tap in the emitted :ref:`TraceWrapper
   * <envoy_v3_api_msg_data.tap.v3.TraceWrapper>` messages. Note that streamed tapping does not
   * mean that no buffering takes place. Buffering may be required if data is processed before a
   * match can be determined. See the HTTP tap filter :ref:`streaming
   * <config_http_filters_tap_streaming>` documentation for more information.
   */
  streaming?:
    | boolean
    | undefined;
  /**
   * Tapped messages will be sent on each read/write event for streamed tapping by default.
   * But this behavior could be controlled by setting this field.
   * If set then the tapped messages will be send once the threshold is reached.
   * This could be used to avoid high frequent sending.
   */
  min_streamed_sent_bytes?: number | undefined;
}

/**
 * Tap output sink configuration.
 * [#next-free-field: 7]
 */
export interface OutputSink {
  $type: "envoy.config.tap.v3.OutputSink";
  /** Sink output format. */
  format?: OutputSink_Format | undefined;
  output_sink_type?:
    | //
    /**
     * Tap output will be streamed out the :http:post:`/tap` admin endpoint.
     *
     * .. attention::
     *
     *   It is only allowed to specify the streaming admin output sink if the tap is being
     *   configured from the :http:post:`/tap` admin endpoint. Thus, if an extension has
     *   been configured to receive tap configuration from some other source (e.g., static
     *   file, XDS, etc.) configuring the streaming admin output type will fail.
     */
    { $case: "streaming_admin"; streaming_admin: StreamingAdminSink }
    | //
    /** Tap output will be written to a file per tap sink. */
    { $case: "file_per_tap"; file_per_tap: FilePerTapSink }
    | //
    /**
     * [#not-implemented-hide:]
     * GrpcService to stream data to. The format argument must be PROTO_BINARY.
     * [#comment: TODO(samflattery): remove cleanup in uber_per_filter.cc once implemented]
     */
    { $case: "streaming_grpc"; streaming_grpc: StreamingGrpcSink }
    | //
    /**
     * Tap output will be buffered in a single block before flushing to the :http:post:`/tap` admin endpoint
     *
     * .. attention::
     *
     *   It is only allowed to specify the buffered admin output sink if the tap is being
     *   configured from the :http:post:`/tap` admin endpoint. Thus, if an extension has
     *   been configured to receive tap configuration from some other source (e.g., static
     *   file, XDS, etc.) configuring the buffered admin output type will fail.
     */
    { $case: "buffered_admin"; buffered_admin: BufferedAdminSink }
    | //
    /** Tap output filter will be defined by an extension type */
    { $case: "custom_sink"; custom_sink: TypedExtensionConfig }
    | undefined;
}

/**
 * Output format. All output is in the form of one or more :ref:`TraceWrapper
 * <envoy_v3_api_msg_data.tap.v3.TraceWrapper>` messages. This enumeration indicates
 * how those messages are written. Note that not all sinks support all output formats. See
 * individual sink documentation for more information.
 */
export enum OutputSink_Format {
  /**
   * JSON_BODY_AS_BYTES - Each message will be written as JSON. Any :ref:`body <envoy_v3_api_msg_data.tap.v3.Body>`
   * data will be present in the :ref:`as_bytes
   * <envoy_v3_api_field_data.tap.v3.Body.as_bytes>` field. This means that body data will be
   * base64 encoded as per the `proto3 JSON mappings
   * <https://developers.google.com/protocol-buffers/docs/proto3#json>`_.
   */
  JSON_BODY_AS_BYTES = "JSON_BODY_AS_BYTES",
  /**
   * JSON_BODY_AS_STRING - Each message will be written as JSON. Any :ref:`body <envoy_v3_api_msg_data.tap.v3.Body>`
   * data will be present in the :ref:`as_string
   * <envoy_v3_api_field_data.tap.v3.Body.as_string>` field. This means that body data will be
   * string encoded as per the `proto3 JSON mappings
   * <https://developers.google.com/protocol-buffers/docs/proto3#json>`_. This format type is
   * useful when it is known that that body is human readable (e.g., JSON over HTTP) and the
   * user wishes to view it directly without being forced to base64 decode the body.
   */
  JSON_BODY_AS_STRING = "JSON_BODY_AS_STRING",
  /**
   * PROTO_BINARY - Binary proto format. Note that binary proto is not self-delimiting. If a sink writes
   * multiple binary messages without any length information the data stream will not be
   * useful. However, for certain sinks that are self-delimiting (e.g., one message per file)
   * this output format makes consumption simpler.
   */
  PROTO_BINARY = "PROTO_BINARY",
  /**
   * PROTO_BINARY_LENGTH_DELIMITED - Messages are written as a sequence tuples, where each tuple is the message length encoded
   * as a `protobuf 32-bit varint
   * <https://developers.google.com/protocol-buffers/docs/reference/cpp/google.protobuf.io.coded_stream>`_
   * followed by the binary message. The messages can be read back using the language specific
   * protobuf coded stream implementation to obtain the message length and the message.
   */
  PROTO_BINARY_LENGTH_DELIMITED = "PROTO_BINARY_LENGTH_DELIMITED",
  /** PROTO_TEXT - Text proto format. */
  PROTO_TEXT = "PROTO_TEXT",
}

export function outputSink_FormatFromJSON(object: any): OutputSink_Format {
  switch (object) {
    case 0:
    case "JSON_BODY_AS_BYTES":
      return OutputSink_Format.JSON_BODY_AS_BYTES;
    case 1:
    case "JSON_BODY_AS_STRING":
      return OutputSink_Format.JSON_BODY_AS_STRING;
    case 2:
    case "PROTO_BINARY":
      return OutputSink_Format.PROTO_BINARY;
    case 3:
    case "PROTO_BINARY_LENGTH_DELIMITED":
      return OutputSink_Format.PROTO_BINARY_LENGTH_DELIMITED;
    case 4:
    case "PROTO_TEXT":
      return OutputSink_Format.PROTO_TEXT;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum OutputSink_Format");
  }
}

export function outputSink_FormatToJSON(object: OutputSink_Format): string {
  switch (object) {
    case OutputSink_Format.JSON_BODY_AS_BYTES:
      return "JSON_BODY_AS_BYTES";
    case OutputSink_Format.JSON_BODY_AS_STRING:
      return "JSON_BODY_AS_STRING";
    case OutputSink_Format.PROTO_BINARY:
      return "PROTO_BINARY";
    case OutputSink_Format.PROTO_BINARY_LENGTH_DELIMITED:
      return "PROTO_BINARY_LENGTH_DELIMITED";
    case OutputSink_Format.PROTO_TEXT:
      return "PROTO_TEXT";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum OutputSink_Format");
  }
}

export function outputSink_FormatToNumber(object: OutputSink_Format): number {
  switch (object) {
    case OutputSink_Format.JSON_BODY_AS_BYTES:
      return 0;
    case OutputSink_Format.JSON_BODY_AS_STRING:
      return 1;
    case OutputSink_Format.PROTO_BINARY:
      return 2;
    case OutputSink_Format.PROTO_BINARY_LENGTH_DELIMITED:
      return 3;
    case OutputSink_Format.PROTO_TEXT:
      return 4;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum OutputSink_Format");
  }
}

/** Streaming admin sink configuration. */
export interface StreamingAdminSink {
  $type: "envoy.config.tap.v3.StreamingAdminSink";
}

/**
 * BufferedAdminSink configures a tap output to collect traces without returning them until
 * one of multiple criteria are satisfied.
 * Similar to StreamingAdminSink, it is only allowed to specify the buffered admin output
 * sink if the tap is being configured from the ``/tap`` admin endpoint.
 */
export interface BufferedAdminSink {
  $type: "envoy.config.tap.v3.BufferedAdminSink";
  /**
   * Stop collecting traces when the specified number are collected.
   * If other criteria for ending collection are reached first, this value will not be used.
   */
  max_traces?:
    | number
    | undefined;
  /**
   * Acts as a fallback to prevent the client from waiting for long periods of time.
   * After timeout has occurred, a buffer flush will be triggered, returning the traces buffered so far.
   * This may result in returning fewer traces than were requested, and in the case that no traces are
   * buffered during this time, no traces will be returned.
   * Specifying 0 for the timeout value (or not specifying a value at all) indicates an infinite timeout.
   */
  timeout?: Duration | undefined;
}

/** The file per tap sink outputs a discrete file for every tapped stream. */
export interface FilePerTapSink {
  $type: "envoy.config.tap.v3.FilePerTapSink";
  /**
   * Path prefix. The output file will be of the form <path_prefix>_<id>.pb, where <id> is an
   * identifier distinguishing the recorded trace for stream instances (the Envoy
   * connection ID, HTTP stream ID, etc.).
   */
  path_prefix?: string | undefined;
}

/**
 * [#not-implemented-hide:] Streaming gRPC sink configuration sends the taps to an external gRPC
 * server.
 */
export interface StreamingGrpcSink {
  $type: "envoy.config.tap.v3.StreamingGrpcSink";
  /** Opaque identifier, that will be sent back to the streaming grpc server. */
  tap_id?:
    | string
    | undefined;
  /** The gRPC server that hosts the Tap Sink Service. */
  grpc_service?: GrpcService | undefined;
}

function createBaseTapConfig(): TapConfig {
  return { $type: "envoy.config.tap.v3.TapConfig" };
}

export const TapConfig: MessageFns<TapConfig, "envoy.config.tap.v3.TapConfig"> = {
  $type: "envoy.config.tap.v3.TapConfig" as const,

  encode(message: TapConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.match_config !== undefined) {
      MatchPredicate.encode(message.match_config, writer.uint32(10).fork()).join();
    }
    if (message.match !== undefined) {
      MatchPredicate1.encode(message.match, writer.uint32(34).fork()).join();
    }
    if (message.output_config !== undefined) {
      OutputConfig.encode(message.output_config, writer.uint32(18).fork()).join();
    }
    if (message.tap_enabled !== undefined) {
      RuntimeFractionalPercent.encode(message.tap_enabled, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TapConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTapConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.match_config = MatchPredicate.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.match = MatchPredicate1.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.output_config = OutputConfig.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tap_enabled = RuntimeFractionalPercent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TapConfig {
    return {
      $type: TapConfig.$type,
      match_config: isSet(object.match_config) ? MatchPredicate.fromJSON(object.match_config) : undefined,
      match: isSet(object.match) ? MatchPredicate1.fromJSON(object.match) : undefined,
      output_config: isSet(object.output_config) ? OutputConfig.fromJSON(object.output_config) : undefined,
      tap_enabled: isSet(object.tap_enabled) ? RuntimeFractionalPercent.fromJSON(object.tap_enabled) : undefined,
    };
  },

  toJSON(message: TapConfig): unknown {
    const obj: any = {};
    if (message.match_config !== undefined) {
      obj.match_config = MatchPredicate.toJSON(message.match_config);
    }
    if (message.match !== undefined) {
      obj.match = MatchPredicate1.toJSON(message.match);
    }
    if (message.output_config !== undefined) {
      obj.output_config = OutputConfig.toJSON(message.output_config);
    }
    if (message.tap_enabled !== undefined) {
      obj.tap_enabled = RuntimeFractionalPercent.toJSON(message.tap_enabled);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TapConfig>, I>>(base?: I): TapConfig {
    return TapConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TapConfig>, I>>(object: I): TapConfig {
    const message = createBaseTapConfig();
    message.match_config = (object.match_config !== undefined && object.match_config !== null)
      ? MatchPredicate.fromPartial(object.match_config)
      : undefined;
    message.match = (object.match !== undefined && object.match !== null)
      ? MatchPredicate1.fromPartial(object.match)
      : undefined;
    message.output_config = (object.output_config !== undefined && object.output_config !== null)
      ? OutputConfig.fromPartial(object.output_config)
      : undefined;
    message.tap_enabled = (object.tap_enabled !== undefined && object.tap_enabled !== null)
      ? RuntimeFractionalPercent.fromPartial(object.tap_enabled)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(TapConfig.$type, TapConfig);

function createBaseMatchPredicate(): MatchPredicate {
  return { $type: "envoy.config.tap.v3.MatchPredicate", rule: undefined };
}

export const MatchPredicate: MessageFns<MatchPredicate, "envoy.config.tap.v3.MatchPredicate"> = {
  $type: "envoy.config.tap.v3.MatchPredicate" as const,

  encode(message: MatchPredicate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.rule?.$case) {
      case "or_match":
        MatchPredicate_MatchSet.encode(message.rule.or_match, writer.uint32(10).fork()).join();
        break;
      case "and_match":
        MatchPredicate_MatchSet.encode(message.rule.and_match, writer.uint32(18).fork()).join();
        break;
      case "not_match":
        MatchPredicate.encode(message.rule.not_match, writer.uint32(26).fork()).join();
        break;
      case "any_match":
        writer.uint32(32).bool(message.rule.any_match);
        break;
      case "http_request_headers_match":
        HttpHeadersMatch.encode(message.rule.http_request_headers_match, writer.uint32(42).fork()).join();
        break;
      case "http_request_trailers_match":
        HttpHeadersMatch.encode(message.rule.http_request_trailers_match, writer.uint32(50).fork()).join();
        break;
      case "http_response_headers_match":
        HttpHeadersMatch.encode(message.rule.http_response_headers_match, writer.uint32(58).fork()).join();
        break;
      case "http_response_trailers_match":
        HttpHeadersMatch.encode(message.rule.http_response_trailers_match, writer.uint32(66).fork()).join();
        break;
      case "http_request_generic_body_match":
        HttpGenericBodyMatch.encode(message.rule.http_request_generic_body_match, writer.uint32(74).fork()).join();
        break;
      case "http_response_generic_body_match":
        HttpGenericBodyMatch.encode(message.rule.http_response_generic_body_match, writer.uint32(82).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MatchPredicate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatchPredicate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rule = { $case: "or_match", or_match: MatchPredicate_MatchSet.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rule = { $case: "and_match", and_match: MatchPredicate_MatchSet.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rule = { $case: "not_match", not_match: MatchPredicate.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.rule = { $case: "any_match", any_match: reader.bool() };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.rule = {
            $case: "http_request_headers_match",
            http_request_headers_match: HttpHeadersMatch.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.rule = {
            $case: "http_request_trailers_match",
            http_request_trailers_match: HttpHeadersMatch.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.rule = {
            $case: "http_response_headers_match",
            http_response_headers_match: HttpHeadersMatch.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.rule = {
            $case: "http_response_trailers_match",
            http_response_trailers_match: HttpHeadersMatch.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.rule = {
            $case: "http_request_generic_body_match",
            http_request_generic_body_match: HttpGenericBodyMatch.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.rule = {
            $case: "http_response_generic_body_match",
            http_response_generic_body_match: HttpGenericBodyMatch.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MatchPredicate {
    return {
      $type: MatchPredicate.$type,
      rule: isSet(object.or_match)
        ? { $case: "or_match", or_match: MatchPredicate_MatchSet.fromJSON(object.or_match) }
        : isSet(object.and_match)
        ? { $case: "and_match", and_match: MatchPredicate_MatchSet.fromJSON(object.and_match) }
        : isSet(object.not_match)
        ? { $case: "not_match", not_match: MatchPredicate.fromJSON(object.not_match) }
        : isSet(object.any_match)
        ? { $case: "any_match", any_match: globalThis.Boolean(object.any_match) }
        : isSet(object.http_request_headers_match)
        ? {
          $case: "http_request_headers_match",
          http_request_headers_match: HttpHeadersMatch.fromJSON(object.http_request_headers_match),
        }
        : isSet(object.http_request_trailers_match)
        ? {
          $case: "http_request_trailers_match",
          http_request_trailers_match: HttpHeadersMatch.fromJSON(object.http_request_trailers_match),
        }
        : isSet(object.http_response_headers_match)
        ? {
          $case: "http_response_headers_match",
          http_response_headers_match: HttpHeadersMatch.fromJSON(object.http_response_headers_match),
        }
        : isSet(object.http_response_trailers_match)
        ? {
          $case: "http_response_trailers_match",
          http_response_trailers_match: HttpHeadersMatch.fromJSON(object.http_response_trailers_match),
        }
        : isSet(object.http_request_generic_body_match)
        ? {
          $case: "http_request_generic_body_match",
          http_request_generic_body_match: HttpGenericBodyMatch.fromJSON(object.http_request_generic_body_match),
        }
        : isSet(object.http_response_generic_body_match)
        ? {
          $case: "http_response_generic_body_match",
          http_response_generic_body_match: HttpGenericBodyMatch.fromJSON(object.http_response_generic_body_match),
        }
        : undefined,
    };
  },

  toJSON(message: MatchPredicate): unknown {
    const obj: any = {};
    if (message.rule?.$case === "or_match") {
      obj.or_match = MatchPredicate_MatchSet.toJSON(message.rule.or_match);
    }
    if (message.rule?.$case === "and_match") {
      obj.and_match = MatchPredicate_MatchSet.toJSON(message.rule.and_match);
    }
    if (message.rule?.$case === "not_match") {
      obj.not_match = MatchPredicate.toJSON(message.rule.not_match);
    }
    if (message.rule?.$case === "any_match") {
      obj.any_match = message.rule.any_match;
    }
    if (message.rule?.$case === "http_request_headers_match") {
      obj.http_request_headers_match = HttpHeadersMatch.toJSON(message.rule.http_request_headers_match);
    }
    if (message.rule?.$case === "http_request_trailers_match") {
      obj.http_request_trailers_match = HttpHeadersMatch.toJSON(message.rule.http_request_trailers_match);
    }
    if (message.rule?.$case === "http_response_headers_match") {
      obj.http_response_headers_match = HttpHeadersMatch.toJSON(message.rule.http_response_headers_match);
    }
    if (message.rule?.$case === "http_response_trailers_match") {
      obj.http_response_trailers_match = HttpHeadersMatch.toJSON(message.rule.http_response_trailers_match);
    }
    if (message.rule?.$case === "http_request_generic_body_match") {
      obj.http_request_generic_body_match = HttpGenericBodyMatch.toJSON(message.rule.http_request_generic_body_match);
    }
    if (message.rule?.$case === "http_response_generic_body_match") {
      obj.http_response_generic_body_match = HttpGenericBodyMatch.toJSON(message.rule.http_response_generic_body_match);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MatchPredicate>, I>>(base?: I): MatchPredicate {
    return MatchPredicate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MatchPredicate>, I>>(object: I): MatchPredicate {
    const message = createBaseMatchPredicate();
    if (object.rule?.$case === "or_match" && object.rule?.or_match !== undefined && object.rule?.or_match !== null) {
      message.rule = { $case: "or_match", or_match: MatchPredicate_MatchSet.fromPartial(object.rule.or_match) };
    }
    if (object.rule?.$case === "and_match" && object.rule?.and_match !== undefined && object.rule?.and_match !== null) {
      message.rule = { $case: "and_match", and_match: MatchPredicate_MatchSet.fromPartial(object.rule.and_match) };
    }
    if (object.rule?.$case === "not_match" && object.rule?.not_match !== undefined && object.rule?.not_match !== null) {
      message.rule = { $case: "not_match", not_match: MatchPredicate.fromPartial(object.rule.not_match) };
    }
    if (object.rule?.$case === "any_match" && object.rule?.any_match !== undefined && object.rule?.any_match !== null) {
      message.rule = { $case: "any_match", any_match: object.rule.any_match };
    }
    if (
      object.rule?.$case === "http_request_headers_match" &&
      object.rule?.http_request_headers_match !== undefined &&
      object.rule?.http_request_headers_match !== null
    ) {
      message.rule = {
        $case: "http_request_headers_match",
        http_request_headers_match: HttpHeadersMatch.fromPartial(object.rule.http_request_headers_match),
      };
    }
    if (
      object.rule?.$case === "http_request_trailers_match" &&
      object.rule?.http_request_trailers_match !== undefined &&
      object.rule?.http_request_trailers_match !== null
    ) {
      message.rule = {
        $case: "http_request_trailers_match",
        http_request_trailers_match: HttpHeadersMatch.fromPartial(object.rule.http_request_trailers_match),
      };
    }
    if (
      object.rule?.$case === "http_response_headers_match" &&
      object.rule?.http_response_headers_match !== undefined &&
      object.rule?.http_response_headers_match !== null
    ) {
      message.rule = {
        $case: "http_response_headers_match",
        http_response_headers_match: HttpHeadersMatch.fromPartial(object.rule.http_response_headers_match),
      };
    }
    if (
      object.rule?.$case === "http_response_trailers_match" &&
      object.rule?.http_response_trailers_match !== undefined &&
      object.rule?.http_response_trailers_match !== null
    ) {
      message.rule = {
        $case: "http_response_trailers_match",
        http_response_trailers_match: HttpHeadersMatch.fromPartial(object.rule.http_response_trailers_match),
      };
    }
    if (
      object.rule?.$case === "http_request_generic_body_match" &&
      object.rule?.http_request_generic_body_match !== undefined &&
      object.rule?.http_request_generic_body_match !== null
    ) {
      message.rule = {
        $case: "http_request_generic_body_match",
        http_request_generic_body_match: HttpGenericBodyMatch.fromPartial(object.rule.http_request_generic_body_match),
      };
    }
    if (
      object.rule?.$case === "http_response_generic_body_match" &&
      object.rule?.http_response_generic_body_match !== undefined &&
      object.rule?.http_response_generic_body_match !== null
    ) {
      message.rule = {
        $case: "http_response_generic_body_match",
        http_response_generic_body_match: HttpGenericBodyMatch.fromPartial(
          object.rule.http_response_generic_body_match,
        ),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(MatchPredicate.$type, MatchPredicate);

function createBaseMatchPredicate_MatchSet(): MatchPredicate_MatchSet {
  return { $type: "envoy.config.tap.v3.MatchPredicate.MatchSet" };
}

export const MatchPredicate_MatchSet: MessageFns<
  MatchPredicate_MatchSet,
  "envoy.config.tap.v3.MatchPredicate.MatchSet"
> = {
  $type: "envoy.config.tap.v3.MatchPredicate.MatchSet" as const,

  encode(message: MatchPredicate_MatchSet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rules !== undefined && message.rules.length !== 0) {
      for (const v of message.rules) {
        MatchPredicate.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MatchPredicate_MatchSet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatchPredicate_MatchSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.rules === undefined) {
            message.rules = [];
          }
          const el = MatchPredicate.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.rules!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MatchPredicate_MatchSet {
    return {
      $type: MatchPredicate_MatchSet.$type,
      rules: globalThis.Array.isArray(object?.rules)
        ? object.rules.map((e: any) => MatchPredicate.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: MatchPredicate_MatchSet): unknown {
    const obj: any = {};
    if (message.rules?.length) {
      obj.rules = message.rules.map((e) => MatchPredicate.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MatchPredicate_MatchSet>, I>>(base?: I): MatchPredicate_MatchSet {
    return MatchPredicate_MatchSet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MatchPredicate_MatchSet>, I>>(object: I): MatchPredicate_MatchSet {
    const message = createBaseMatchPredicate_MatchSet();
    message.rules = object.rules?.map((e) => MatchPredicate.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(MatchPredicate_MatchSet.$type, MatchPredicate_MatchSet);

function createBaseHttpHeadersMatch(): HttpHeadersMatch {
  return { $type: "envoy.config.tap.v3.HttpHeadersMatch" };
}

export const HttpHeadersMatch: MessageFns<HttpHeadersMatch, "envoy.config.tap.v3.HttpHeadersMatch"> = {
  $type: "envoy.config.tap.v3.HttpHeadersMatch" as const,

  encode(message: HttpHeadersMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.headers !== undefined && message.headers.length !== 0) {
      for (const v of message.headers) {
        HeaderMatcher.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpHeadersMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpHeadersMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.headers === undefined) {
            message.headers = [];
          }
          const el = HeaderMatcher.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.headers!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpHeadersMatch {
    return {
      $type: HttpHeadersMatch.$type,
      headers: globalThis.Array.isArray(object?.headers)
        ? object.headers.map((e: any) => HeaderMatcher.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: HttpHeadersMatch): unknown {
    const obj: any = {};
    if (message.headers?.length) {
      obj.headers = message.headers.map((e) => HeaderMatcher.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpHeadersMatch>, I>>(base?: I): HttpHeadersMatch {
    return HttpHeadersMatch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpHeadersMatch>, I>>(object: I): HttpHeadersMatch {
    const message = createBaseHttpHeadersMatch();
    message.headers = object.headers?.map((e) => HeaderMatcher.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(HttpHeadersMatch.$type, HttpHeadersMatch);

function createBaseHttpGenericBodyMatch(): HttpGenericBodyMatch {
  return { $type: "envoy.config.tap.v3.HttpGenericBodyMatch" };
}

export const HttpGenericBodyMatch: MessageFns<HttpGenericBodyMatch, "envoy.config.tap.v3.HttpGenericBodyMatch"> = {
  $type: "envoy.config.tap.v3.HttpGenericBodyMatch" as const,

  encode(message: HttpGenericBodyMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bytes_limit !== undefined && message.bytes_limit !== 0) {
      writer.uint32(8).uint32(message.bytes_limit);
    }
    if (message.patterns !== undefined && message.patterns.length !== 0) {
      for (const v of message.patterns) {
        HttpGenericBodyMatch_GenericTextMatch.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpGenericBodyMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpGenericBodyMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.bytes_limit = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.patterns === undefined) {
            message.patterns = [];
          }
          const el = HttpGenericBodyMatch_GenericTextMatch.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.patterns!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpGenericBodyMatch {
    return {
      $type: HttpGenericBodyMatch.$type,
      bytes_limit: isSet(object.bytes_limit) ? globalThis.Number(object.bytes_limit) : undefined,
      patterns: globalThis.Array.isArray(object?.patterns)
        ? object.patterns.map((e: any) => HttpGenericBodyMatch_GenericTextMatch.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: HttpGenericBodyMatch): unknown {
    const obj: any = {};
    if (message.bytes_limit !== undefined) {
      obj.bytes_limit = Math.round(message.bytes_limit);
    }
    if (message.patterns?.length) {
      obj.patterns = message.patterns.map((e) => HttpGenericBodyMatch_GenericTextMatch.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpGenericBodyMatch>, I>>(base?: I): HttpGenericBodyMatch {
    return HttpGenericBodyMatch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpGenericBodyMatch>, I>>(object: I): HttpGenericBodyMatch {
    const message = createBaseHttpGenericBodyMatch();
    message.bytes_limit = object.bytes_limit ?? undefined;
    message.patterns = object.patterns?.map((e) => HttpGenericBodyMatch_GenericTextMatch.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(HttpGenericBodyMatch.$type, HttpGenericBodyMatch);

function createBaseHttpGenericBodyMatch_GenericTextMatch(): HttpGenericBodyMatch_GenericTextMatch {
  return { $type: "envoy.config.tap.v3.HttpGenericBodyMatch.GenericTextMatch", rule: undefined };
}

export const HttpGenericBodyMatch_GenericTextMatch: MessageFns<
  HttpGenericBodyMatch_GenericTextMatch,
  "envoy.config.tap.v3.HttpGenericBodyMatch.GenericTextMatch"
> = {
  $type: "envoy.config.tap.v3.HttpGenericBodyMatch.GenericTextMatch" as const,

  encode(message: HttpGenericBodyMatch_GenericTextMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.rule?.$case) {
      case "string_match":
        writer.uint32(10).string(message.rule.string_match);
        break;
      case "binary_match":
        writer.uint32(18).bytes(message.rule.binary_match);
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpGenericBodyMatch_GenericTextMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpGenericBodyMatch_GenericTextMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rule = { $case: "string_match", string_match: reader.string() };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rule = { $case: "binary_match", binary_match: reader.bytes() };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpGenericBodyMatch_GenericTextMatch {
    return {
      $type: HttpGenericBodyMatch_GenericTextMatch.$type,
      rule: isSet(object.string_match)
        ? { $case: "string_match", string_match: globalThis.String(object.string_match) }
        : isSet(object.binary_match)
        ? { $case: "binary_match", binary_match: bytesFromBase64(object.binary_match) }
        : undefined,
    };
  },

  toJSON(message: HttpGenericBodyMatch_GenericTextMatch): unknown {
    const obj: any = {};
    if (message.rule?.$case === "string_match") {
      obj.string_match = message.rule.string_match;
    }
    if (message.rule?.$case === "binary_match") {
      obj.binary_match = base64FromBytes(message.rule.binary_match);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpGenericBodyMatch_GenericTextMatch>, I>>(
    base?: I,
  ): HttpGenericBodyMatch_GenericTextMatch {
    return HttpGenericBodyMatch_GenericTextMatch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpGenericBodyMatch_GenericTextMatch>, I>>(
    object: I,
  ): HttpGenericBodyMatch_GenericTextMatch {
    const message = createBaseHttpGenericBodyMatch_GenericTextMatch();
    if (
      object.rule?.$case === "string_match" &&
      object.rule?.string_match !== undefined &&
      object.rule?.string_match !== null
    ) {
      message.rule = { $case: "string_match", string_match: object.rule.string_match };
    }
    if (
      object.rule?.$case === "binary_match" &&
      object.rule?.binary_match !== undefined &&
      object.rule?.binary_match !== null
    ) {
      message.rule = { $case: "binary_match", binary_match: object.rule.binary_match };
    }
    return message;
  },
};

messageTypeRegistry.set(HttpGenericBodyMatch_GenericTextMatch.$type, HttpGenericBodyMatch_GenericTextMatch);

function createBaseOutputConfig(): OutputConfig {
  return { $type: "envoy.config.tap.v3.OutputConfig" };
}

export const OutputConfig: MessageFns<OutputConfig, "envoy.config.tap.v3.OutputConfig"> = {
  $type: "envoy.config.tap.v3.OutputConfig" as const,

  encode(message: OutputConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sinks !== undefined && message.sinks.length !== 0) {
      for (const v of message.sinks) {
        OutputSink.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    if (message.max_buffered_rx_bytes !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.max_buffered_rx_bytes! },
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.max_buffered_tx_bytes !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.max_buffered_tx_bytes! },
        writer.uint32(26).fork(),
      ).join();
    }
    if (message.streaming !== undefined && message.streaming !== false) {
      writer.uint32(32).bool(message.streaming);
    }
    if (message.min_streamed_sent_bytes !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.min_streamed_sent_bytes! },
        writer.uint32(42).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutputConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutputConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.sinks === undefined) {
            message.sinks = [];
          }
          const el = OutputSink.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.sinks!.push(el);
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.max_buffered_rx_bytes = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.max_buffered_tx_bytes = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.streaming = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.min_streamed_sent_bytes = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutputConfig {
    return {
      $type: OutputConfig.$type,
      sinks: globalThis.Array.isArray(object?.sinks) ? object.sinks.map((e: any) => OutputSink.fromJSON(e)) : undefined,
      max_buffered_rx_bytes: isSet(object.max_buffered_rx_bytes) ? Number(object.max_buffered_rx_bytes) : undefined,
      max_buffered_tx_bytes: isSet(object.max_buffered_tx_bytes) ? Number(object.max_buffered_tx_bytes) : undefined,
      streaming: isSet(object.streaming) ? globalThis.Boolean(object.streaming) : undefined,
      min_streamed_sent_bytes: isSet(object.min_streamed_sent_bytes)
        ? Number(object.min_streamed_sent_bytes)
        : undefined,
    };
  },

  toJSON(message: OutputConfig): unknown {
    const obj: any = {};
    if (message.sinks?.length) {
      obj.sinks = message.sinks.map((e) => OutputSink.toJSON(e));
    }
    if (message.max_buffered_rx_bytes !== undefined) {
      obj.max_buffered_rx_bytes = message.max_buffered_rx_bytes;
    }
    if (message.max_buffered_tx_bytes !== undefined) {
      obj.max_buffered_tx_bytes = message.max_buffered_tx_bytes;
    }
    if (message.streaming !== undefined) {
      obj.streaming = message.streaming;
    }
    if (message.min_streamed_sent_bytes !== undefined) {
      obj.min_streamed_sent_bytes = message.min_streamed_sent_bytes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OutputConfig>, I>>(base?: I): OutputConfig {
    return OutputConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OutputConfig>, I>>(object: I): OutputConfig {
    const message = createBaseOutputConfig();
    message.sinks = object.sinks?.map((e) => OutputSink.fromPartial(e)) || undefined;
    message.max_buffered_rx_bytes = object.max_buffered_rx_bytes ?? undefined;
    message.max_buffered_tx_bytes = object.max_buffered_tx_bytes ?? undefined;
    message.streaming = object.streaming ?? undefined;
    message.min_streamed_sent_bytes = object.min_streamed_sent_bytes ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(OutputConfig.$type, OutputConfig);

function createBaseOutputSink(): OutputSink {
  return { $type: "envoy.config.tap.v3.OutputSink", output_sink_type: undefined };
}

export const OutputSink: MessageFns<OutputSink, "envoy.config.tap.v3.OutputSink"> = {
  $type: "envoy.config.tap.v3.OutputSink" as const,

  encode(message: OutputSink, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.format !== undefined && message.format !== OutputSink_Format.JSON_BODY_AS_BYTES) {
      writer.uint32(8).int32(outputSink_FormatToNumber(message.format));
    }
    switch (message.output_sink_type?.$case) {
      case "streaming_admin":
        StreamingAdminSink.encode(message.output_sink_type.streaming_admin, writer.uint32(18).fork()).join();
        break;
      case "file_per_tap":
        FilePerTapSink.encode(message.output_sink_type.file_per_tap, writer.uint32(26).fork()).join();
        break;
      case "streaming_grpc":
        StreamingGrpcSink.encode(message.output_sink_type.streaming_grpc, writer.uint32(34).fork()).join();
        break;
      case "buffered_admin":
        BufferedAdminSink.encode(message.output_sink_type.buffered_admin, writer.uint32(42).fork()).join();
        break;
      case "custom_sink":
        TypedExtensionConfig.encode(message.output_sink_type.custom_sink, writer.uint32(50).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutputSink {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutputSink();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.format = outputSink_FormatFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.output_sink_type = {
            $case: "streaming_admin",
            streaming_admin: StreamingAdminSink.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.output_sink_type = {
            $case: "file_per_tap",
            file_per_tap: FilePerTapSink.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.output_sink_type = {
            $case: "streaming_grpc",
            streaming_grpc: StreamingGrpcSink.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.output_sink_type = {
            $case: "buffered_admin",
            buffered_admin: BufferedAdminSink.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.output_sink_type = {
            $case: "custom_sink",
            custom_sink: TypedExtensionConfig.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutputSink {
    return {
      $type: OutputSink.$type,
      format: isSet(object.format) ? outputSink_FormatFromJSON(object.format) : undefined,
      output_sink_type: isSet(object.streaming_admin)
        ? { $case: "streaming_admin", streaming_admin: StreamingAdminSink.fromJSON(object.streaming_admin) }
        : isSet(object.file_per_tap)
        ? { $case: "file_per_tap", file_per_tap: FilePerTapSink.fromJSON(object.file_per_tap) }
        : isSet(object.streaming_grpc)
        ? { $case: "streaming_grpc", streaming_grpc: StreamingGrpcSink.fromJSON(object.streaming_grpc) }
        : isSet(object.buffered_admin)
        ? { $case: "buffered_admin", buffered_admin: BufferedAdminSink.fromJSON(object.buffered_admin) }
        : isSet(object.custom_sink)
        ? { $case: "custom_sink", custom_sink: TypedExtensionConfig.fromJSON(object.custom_sink) }
        : undefined,
    };
  },

  toJSON(message: OutputSink): unknown {
    const obj: any = {};
    if (message.format !== undefined) {
      obj.format = outputSink_FormatToJSON(message.format);
    }
    if (message.output_sink_type?.$case === "streaming_admin") {
      obj.streaming_admin = StreamingAdminSink.toJSON(message.output_sink_type.streaming_admin);
    }
    if (message.output_sink_type?.$case === "file_per_tap") {
      obj.file_per_tap = FilePerTapSink.toJSON(message.output_sink_type.file_per_tap);
    }
    if (message.output_sink_type?.$case === "streaming_grpc") {
      obj.streaming_grpc = StreamingGrpcSink.toJSON(message.output_sink_type.streaming_grpc);
    }
    if (message.output_sink_type?.$case === "buffered_admin") {
      obj.buffered_admin = BufferedAdminSink.toJSON(message.output_sink_type.buffered_admin);
    }
    if (message.output_sink_type?.$case === "custom_sink") {
      obj.custom_sink = TypedExtensionConfig.toJSON(message.output_sink_type.custom_sink);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OutputSink>, I>>(base?: I): OutputSink {
    return OutputSink.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OutputSink>, I>>(object: I): OutputSink {
    const message = createBaseOutputSink();
    message.format = object.format ?? undefined;
    if (
      object.output_sink_type?.$case === "streaming_admin" &&
      object.output_sink_type?.streaming_admin !== undefined &&
      object.output_sink_type?.streaming_admin !== null
    ) {
      message.output_sink_type = {
        $case: "streaming_admin",
        streaming_admin: StreamingAdminSink.fromPartial(object.output_sink_type.streaming_admin),
      };
    }
    if (
      object.output_sink_type?.$case === "file_per_tap" &&
      object.output_sink_type?.file_per_tap !== undefined &&
      object.output_sink_type?.file_per_tap !== null
    ) {
      message.output_sink_type = {
        $case: "file_per_tap",
        file_per_tap: FilePerTapSink.fromPartial(object.output_sink_type.file_per_tap),
      };
    }
    if (
      object.output_sink_type?.$case === "streaming_grpc" &&
      object.output_sink_type?.streaming_grpc !== undefined &&
      object.output_sink_type?.streaming_grpc !== null
    ) {
      message.output_sink_type = {
        $case: "streaming_grpc",
        streaming_grpc: StreamingGrpcSink.fromPartial(object.output_sink_type.streaming_grpc),
      };
    }
    if (
      object.output_sink_type?.$case === "buffered_admin" &&
      object.output_sink_type?.buffered_admin !== undefined &&
      object.output_sink_type?.buffered_admin !== null
    ) {
      message.output_sink_type = {
        $case: "buffered_admin",
        buffered_admin: BufferedAdminSink.fromPartial(object.output_sink_type.buffered_admin),
      };
    }
    if (
      object.output_sink_type?.$case === "custom_sink" &&
      object.output_sink_type?.custom_sink !== undefined &&
      object.output_sink_type?.custom_sink !== null
    ) {
      message.output_sink_type = {
        $case: "custom_sink",
        custom_sink: TypedExtensionConfig.fromPartial(object.output_sink_type.custom_sink),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(OutputSink.$type, OutputSink);

function createBaseStreamingAdminSink(): StreamingAdminSink {
  return { $type: "envoy.config.tap.v3.StreamingAdminSink" };
}

export const StreamingAdminSink: MessageFns<StreamingAdminSink, "envoy.config.tap.v3.StreamingAdminSink"> = {
  $type: "envoy.config.tap.v3.StreamingAdminSink" as const,

  encode(_: StreamingAdminSink, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamingAdminSink {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamingAdminSink();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): StreamingAdminSink {
    return { $type: StreamingAdminSink.$type };
  },

  toJSON(_: StreamingAdminSink): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamingAdminSink>, I>>(base?: I): StreamingAdminSink {
    return StreamingAdminSink.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamingAdminSink>, I>>(_: I): StreamingAdminSink {
    const message = createBaseStreamingAdminSink();
    return message;
  },
};

messageTypeRegistry.set(StreamingAdminSink.$type, StreamingAdminSink);

function createBaseBufferedAdminSink(): BufferedAdminSink {
  return { $type: "envoy.config.tap.v3.BufferedAdminSink" };
}

export const BufferedAdminSink: MessageFns<BufferedAdminSink, "envoy.config.tap.v3.BufferedAdminSink"> = {
  $type: "envoy.config.tap.v3.BufferedAdminSink" as const,

  encode(message: BufferedAdminSink, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.max_traces !== undefined && message.max_traces !== 0) {
      writer.uint32(8).uint64(message.max_traces);
    }
    if (message.timeout !== undefined) {
      Duration.encode(message.timeout, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BufferedAdminSink {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBufferedAdminSink();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.max_traces = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BufferedAdminSink {
    return {
      $type: BufferedAdminSink.$type,
      max_traces: isSet(object.max_traces) ? globalThis.Number(object.max_traces) : undefined,
      timeout: isSet(object.timeout) ? Duration.fromJSON(object.timeout) : undefined,
    };
  },

  toJSON(message: BufferedAdminSink): unknown {
    const obj: any = {};
    if (message.max_traces !== undefined) {
      obj.max_traces = Math.round(message.max_traces);
    }
    if (message.timeout !== undefined) {
      obj.timeout = Duration.toJSON(message.timeout);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BufferedAdminSink>, I>>(base?: I): BufferedAdminSink {
    return BufferedAdminSink.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BufferedAdminSink>, I>>(object: I): BufferedAdminSink {
    const message = createBaseBufferedAdminSink();
    message.max_traces = object.max_traces ?? undefined;
    message.timeout = (object.timeout !== undefined && object.timeout !== null)
      ? Duration.fromPartial(object.timeout)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(BufferedAdminSink.$type, BufferedAdminSink);

function createBaseFilePerTapSink(): FilePerTapSink {
  return { $type: "envoy.config.tap.v3.FilePerTapSink" };
}

export const FilePerTapSink: MessageFns<FilePerTapSink, "envoy.config.tap.v3.FilePerTapSink"> = {
  $type: "envoy.config.tap.v3.FilePerTapSink" as const,

  encode(message: FilePerTapSink, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path_prefix !== undefined && message.path_prefix !== "") {
      writer.uint32(10).string(message.path_prefix);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FilePerTapSink {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilePerTapSink();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path_prefix = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FilePerTapSink {
    return {
      $type: FilePerTapSink.$type,
      path_prefix: isSet(object.path_prefix) ? globalThis.String(object.path_prefix) : undefined,
    };
  },

  toJSON(message: FilePerTapSink): unknown {
    const obj: any = {};
    if (message.path_prefix !== undefined) {
      obj.path_prefix = message.path_prefix;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FilePerTapSink>, I>>(base?: I): FilePerTapSink {
    return FilePerTapSink.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FilePerTapSink>, I>>(object: I): FilePerTapSink {
    const message = createBaseFilePerTapSink();
    message.path_prefix = object.path_prefix ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(FilePerTapSink.$type, FilePerTapSink);

function createBaseStreamingGrpcSink(): StreamingGrpcSink {
  return { $type: "envoy.config.tap.v3.StreamingGrpcSink" };
}

export const StreamingGrpcSink: MessageFns<StreamingGrpcSink, "envoy.config.tap.v3.StreamingGrpcSink"> = {
  $type: "envoy.config.tap.v3.StreamingGrpcSink" as const,

  encode(message: StreamingGrpcSink, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tap_id !== undefined && message.tap_id !== "") {
      writer.uint32(10).string(message.tap_id);
    }
    if (message.grpc_service !== undefined) {
      GrpcService.encode(message.grpc_service, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamingGrpcSink {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamingGrpcSink();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tap_id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.grpc_service = GrpcService.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamingGrpcSink {
    return {
      $type: StreamingGrpcSink.$type,
      tap_id: isSet(object.tap_id) ? globalThis.String(object.tap_id) : undefined,
      grpc_service: isSet(object.grpc_service) ? GrpcService.fromJSON(object.grpc_service) : undefined,
    };
  },

  toJSON(message: StreamingGrpcSink): unknown {
    const obj: any = {};
    if (message.tap_id !== undefined) {
      obj.tap_id = message.tap_id;
    }
    if (message.grpc_service !== undefined) {
      obj.grpc_service = GrpcService.toJSON(message.grpc_service);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamingGrpcSink>, I>>(base?: I): StreamingGrpcSink {
    return StreamingGrpcSink.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamingGrpcSink>, I>>(object: I): StreamingGrpcSink {
    const message = createBaseStreamingGrpcSink();
    message.tap_id = object.tap_id ?? undefined;
    message.grpc_service = (object.grpc_service !== undefined && object.grpc_service !== null)
      ? GrpcService.fromPartial(object.grpc_service)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(StreamingGrpcSink.$type, StreamingGrpcSink);

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
