// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/config/listener/v3/listener_components.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Any } from "../../../../google/protobuf/any";
import { Duration } from "../../../../google/protobuf/duration";
import { BoolValue, UInt32Value } from "../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../typeRegistry";
import { Int32Range } from "../../../type/v3/range";
import { CidrRange } from "../../core/v3/address";
import { Metadata, TransportSocket } from "../../core/v3/base";
import { ExtensionConfigSource } from "../../core/v3/config_source";

export const protobufPackage = "envoy.config.listener.v3";

/** [#next-free-field: 6] */
export interface Filter {
  $type: "envoy.config.listener.v3.Filter";
  /** The name of the filter configuration. */
  name?: string | undefined;
  config_type?:
    | //
    /**
     * Filter specific configuration which depends on the filter being
     * instantiated. See the supported filters for further documentation.
     * [#extension-category: envoy.filters.network]
     */
    { $case: "typed_config"; typed_config: Any }
    | //
    /**
     * Configuration source specifier for an extension configuration discovery
     * service. In case of a failure and without the default configuration, the
     * listener closes the connections.
     */
    { $case: "config_discovery"; config_discovery: ExtensionConfigSource }
    | undefined;
}

/**
 * Specifies the match criteria for selecting a specific filter chain for a
 * listener.
 *
 * In order for a filter chain to be selected, *ALL* of its criteria must be
 * fulfilled by the incoming connection, properties of which are set by the
 * networking stack and/or listener filters.
 *
 * The following order applies:
 *
 * 1. Destination port.
 * 2. Destination IP address.
 * 3. Server name (e.g. SNI for TLS protocol),
 * 4. Transport protocol.
 * 5. Application protocols (e.g. ALPN for TLS protocol).
 * 6. Directly connected source IP address (this will only be different from the source IP address
 *    when using a listener filter that overrides the source address, such as the :ref:`Proxy Protocol
 *    listener filter <config_listener_filters_proxy_protocol>`).
 * 7. Source type (e.g. any, local or external network).
 * 8. Source IP address.
 * 9. Source port.
 *
 * For criteria that allow ranges or wildcards, the most specific value in any
 * of the configured filter chains that matches the incoming connection is going
 * to be used (e.g. for SNI ``www.example.com`` the most specific match would be
 * ``www.example.com``, then ``*.example.com``, then ``*.com``, then any filter
 * chain without ``server_names`` requirements).
 *
 * A different way to reason about the filter chain matches:
 * Suppose there exists N filter chains. Prune the filter chain set using the above 8 steps.
 * In each step, filter chains which most specifically matches the attributes continue to the next step.
 * The listener guarantees at most 1 filter chain is left after all of the steps.
 *
 * Example:
 *
 * For destination port, filter chains specifying the destination port of incoming traffic are the
 * most specific match. If none of the filter chains specifies the exact destination port, the filter
 * chains which do not specify ports are the most specific match. Filter chains specifying the
 * wrong port can never be the most specific match.
 *
 * [#comment: Implemented rules are kept in the preference order, with deprecated fields
 * listed at the end, because that's how we want to list them in the docs.
 *
 * [#comment:TODO(PiotrSikora): Add support for configurable precedence of the rules]
 * [#next-free-field: 14]
 */
export interface FilterChainMatch {
  $type: "envoy.config.listener.v3.FilterChainMatch";
  /**
   * Optional destination port to consider when use_original_dst is set on the
   * listener in determining a filter chain match.
   */
  destination_port?:
    | number
    | undefined;
  /**
   * If non-empty, an IP address and prefix length to match addresses when the
   * listener is bound to 0.0.0.0/:: or when use_original_dst is specified.
   */
  prefix_ranges?:
    | CidrRange[]
    | undefined;
  /**
   * If non-empty, an IP address and suffix length to match addresses when the
   * listener is bound to 0.0.0.0/:: or when use_original_dst is specified.
   * [#not-implemented-hide:]
   */
  address_suffix?:
    | string
    | undefined;
  /** [#not-implemented-hide:] */
  suffix_len?:
    | number
    | undefined;
  /**
   * The criteria is satisfied if the directly connected source IP address of the downstream
   * connection is contained in at least one of the specified subnets. If the parameter is not
   * specified or the list is empty, the directly connected source IP address is ignored.
   */
  direct_source_prefix_ranges?:
    | CidrRange[]
    | undefined;
  /** Specifies the connection source IP match type. Can be any, local or external network. */
  source_type?:
    | FilterChainMatch_ConnectionSourceType
    | undefined;
  /**
   * The criteria is satisfied if the source IP address of the downstream
   * connection is contained in at least one of the specified subnets. If the
   * parameter is not specified or the list is empty, the source IP address is
   * ignored.
   */
  source_prefix_ranges?:
    | CidrRange[]
    | undefined;
  /**
   * The criteria is satisfied if the source port of the downstream connection
   * is contained in at least one of the specified ports. If the parameter is
   * not specified, the source port is ignored.
   */
  source_ports?:
    | number[]
    | undefined;
  /**
   * If non-empty, a list of server names (e.g. SNI for TLS protocol) to consider when determining
   * a filter chain match. Those values will be compared against the server names of a new
   * connection, when detected by one of the listener filters.
   *
   * The server name will be matched against all wildcard domains, i.e. ``www.example.com``
   * will be first matched against ``www.example.com``, then ``*.example.com``, then ``*.com``.
   *
   * Note that partial wildcards are not supported, and values like ``*w.example.com`` are invalid.
   * The value ``*`` is also not supported, and ``server_names`` should be omitted instead.
   *
   * .. attention::
   *
   *   See the :ref:`FAQ entry <faq_how_to_setup_sni>` on how to configure SNI for more
   *   information.
   */
  server_names?:
    | string[]
    | undefined;
  /**
   * If non-empty, a transport protocol to consider when determining a filter chain match.
   * This value will be compared against the transport protocol of a new connection, when
   * it's detected by one of the listener filters.
   *
   * Suggested values include:
   *
   * * ``raw_buffer`` - default, used when no transport protocol is detected,
   * * ``tls`` - set by :ref:`envoy.filters.listener.tls_inspector <config_listener_filters_tls_inspector>`
   *   when TLS protocol is detected.
   */
  transport_protocol?:
    | string
    | undefined;
  /**
   * If non-empty, a list of application protocols (e.g. ALPN for TLS protocol) to consider when
   * determining a filter chain match. Those values will be compared against the application
   * protocols of a new connection, when detected by one of the listener filters.
   *
   * Suggested values include:
   *
   * * ``http/1.1`` - set by :ref:`envoy.filters.listener.tls_inspector
   *   <config_listener_filters_tls_inspector>`,
   * * ``h2`` - set by :ref:`envoy.filters.listener.tls_inspector <config_listener_filters_tls_inspector>`
   *
   * .. attention::
   *
   *   Currently, only :ref:`TLS Inspector <config_listener_filters_tls_inspector>` provides
   *   application protocol detection based on the requested
   *   `ALPN <https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation>`_ values.
   *
   *   However, the use of ALPN is pretty much limited to the HTTP/2 traffic on the Internet,
   *   and matching on values other than ``h2`` is going to lead to a lot of false negatives,
   *   unless all connecting clients are known to use ALPN.
   */
  application_protocols?: string[] | undefined;
}

export enum FilterChainMatch_ConnectionSourceType {
  /** ANY - Any connection source matches. */
  ANY = "ANY",
  /** SAME_IP_OR_LOOPBACK - Match a connection originating from the same host. */
  SAME_IP_OR_LOOPBACK = "SAME_IP_OR_LOOPBACK",
  /** EXTERNAL - Match a connection originating from a different host. */
  EXTERNAL = "EXTERNAL",
}

export function filterChainMatch_ConnectionSourceTypeFromJSON(object: any): FilterChainMatch_ConnectionSourceType {
  switch (object) {
    case 0:
    case "ANY":
      return FilterChainMatch_ConnectionSourceType.ANY;
    case 1:
    case "SAME_IP_OR_LOOPBACK":
      return FilterChainMatch_ConnectionSourceType.SAME_IP_OR_LOOPBACK;
    case 2:
    case "EXTERNAL":
      return FilterChainMatch_ConnectionSourceType.EXTERNAL;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum FilterChainMatch_ConnectionSourceType",
      );
  }
}

export function filterChainMatch_ConnectionSourceTypeToJSON(object: FilterChainMatch_ConnectionSourceType): string {
  switch (object) {
    case FilterChainMatch_ConnectionSourceType.ANY:
      return "ANY";
    case FilterChainMatch_ConnectionSourceType.SAME_IP_OR_LOOPBACK:
      return "SAME_IP_OR_LOOPBACK";
    case FilterChainMatch_ConnectionSourceType.EXTERNAL:
      return "EXTERNAL";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum FilterChainMatch_ConnectionSourceType",
      );
  }
}

export function filterChainMatch_ConnectionSourceTypeToNumber(object: FilterChainMatch_ConnectionSourceType): number {
  switch (object) {
    case FilterChainMatch_ConnectionSourceType.ANY:
      return 0;
    case FilterChainMatch_ConnectionSourceType.SAME_IP_OR_LOOPBACK:
      return 1;
    case FilterChainMatch_ConnectionSourceType.EXTERNAL:
      return 2;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum FilterChainMatch_ConnectionSourceType",
      );
  }
}

/**
 * A filter chain wraps a set of match criteria, an option TLS context, a set of filters, and
 * various other parameters.
 * [#next-free-field: 10]
 */
export interface FilterChain {
  $type: "envoy.config.listener.v3.FilterChain";
  /** The criteria to use when matching a connection to this filter chain. */
  filter_chain_match?:
    | FilterChainMatch
    | undefined;
  /**
   * A list of individual network filters that make up the filter chain for
   * connections established with the listener. Order matters as the filters are
   * processed sequentially as connection events happen. Note: If the filter
   * list is empty, the connection will close by default.
   *
   * For QUIC listeners, network filters other than HTTP Connection Manager (HCM)
   * can be created, but due to differences in the connection implementation compared
   * to TCP, the onData() method will never be called. Therefore, network filters
   * for QUIC listeners should only expect to do work at the start of a new connection
   * (i.e. in onNewConnection()). HCM must be the last (or only) filter in the chain.
   */
  filters?:
    | Filter[]
    | undefined;
  /**
   * Whether the listener should expect a PROXY protocol V1 header on new
   * connections. If this option is enabled, the listener will assume that that
   * remote address of the connection is the one specified in the header. Some
   * load balancers including the AWS ELB support this option. If the option is
   * absent or set to false, Envoy will use the physical peer address of the
   * connection as the remote address.
   *
   * This field is deprecated. Add a
   * :ref:`PROXY protocol listener filter <config_listener_filters_proxy_protocol>`
   * explicitly instead.
   *
   * @deprecated
   */
  use_proxy_proto?:
    | boolean
    | undefined;
  /** [#not-implemented-hide:] filter chain metadata. */
  metadata?:
    | Metadata
    | undefined;
  /**
   * Optional custom transport socket implementation to use for downstream connections.
   * To setup TLS, set a transport socket with name ``envoy.transport_sockets.tls`` and
   * :ref:`DownstreamTlsContext <envoy_v3_api_msg_extensions.transport_sockets.tls.v3.DownstreamTlsContext>` in the ``typed_config``.
   * If no transport socket configuration is specified, new connections
   * will be set up with plaintext.
   * [#extension-category: envoy.transport_sockets.downstream]
   */
  transport_socket?:
    | TransportSocket
    | undefined;
  /**
   * If present and nonzero, the amount of time to allow incoming connections to complete any
   * transport socket negotiations. If this expires before the transport reports connection
   * establishment, the connection is summarily closed.
   */
  transport_socket_connect_timeout?:
    | Duration
    | undefined;
  /**
   * The unique name (or empty) by which this filter chain is known.
   * Note: :ref:`filter_chain_matcher
   * <envoy_v3_api_field_config.listener.v3.Listener.filter_chain_matcher>`
   * requires that filter chains are uniquely named within a listener.
   */
  name?: string | undefined;
}

/**
 * Listener filter chain match configuration. This is a recursive structure which allows complex
 * nested match configurations to be built using various logical operators.
 *
 * Examples:
 *
 * * Matches if the destination port is 3306.
 *
 * .. code-block:: yaml
 *
 *  destination_port_range:
 *   start: 3306
 *   end: 3307
 *
 * * Matches if the destination port is 3306 or 15000.
 *
 * .. code-block:: yaml
 *
 *  or_match:
 *    rules:
 *      - destination_port_range:
 *          start: 3306
 *          end: 3307
 *      - destination_port_range:
 *          start: 15000
 *          end: 15001
 *
 * [#next-free-field: 6]
 */
export interface ListenerFilterChainMatchPredicate {
  $type: "envoy.config.listener.v3.ListenerFilterChainMatchPredicate";
  rule?:
    | //
    /**
     * A set that describes a logical OR. If any member of the set matches, the match configuration
     * matches.
     */
    { $case: "or_match"; or_match: ListenerFilterChainMatchPredicate_MatchSet }
    | //
    /**
     * A set that describes a logical AND. If all members of the set match, the match configuration
     * matches.
     */
    { $case: "and_match"; and_match: ListenerFilterChainMatchPredicate_MatchSet }
    | //
    /** A negation match. The match configuration will match if the negated match condition matches. */
    { $case: "not_match"; not_match: ListenerFilterChainMatchPredicate }
    | //
    /** The match configuration will always match. */
    { $case: "any_match"; any_match: boolean }
    | //
    /**
     * Match destination port. Particularly, the match evaluation must use the recovered local port if
     * the owning listener filter is after :ref:`an original_dst listener filter <config_listener_filters_original_dst>`.
     */
    { $case: "destination_port_range"; destination_port_range: Int32Range }
    | undefined;
}

/** A set of match configurations used for logical operations. */
export interface ListenerFilterChainMatchPredicate_MatchSet {
  $type: "envoy.config.listener.v3.ListenerFilterChainMatchPredicate.MatchSet";
  /** The list of rules that make up the set. */
  rules?: ListenerFilterChainMatchPredicate[] | undefined;
}

/** [#next-free-field: 6] */
export interface ListenerFilter {
  $type: "envoy.config.listener.v3.ListenerFilter";
  /** The name of the filter configuration. */
  name?: string | undefined;
  config_type?:
    | //
    /**
     * Filter specific configuration which depends on the filter being
     * instantiated. See the supported filters for further documentation.
     * [#extension-category: envoy.filters.listener,envoy.filters.udp_listener]
     */
    { $case: "typed_config"; typed_config: Any }
    | //
    /**
     * Configuration source specifier for an extension configuration discovery
     * service. In case of a failure and without the default configuration, the
     * listener closes the connections.
     */
    { $case: "config_discovery"; config_discovery: ExtensionConfigSource }
    | undefined;
  /**
   * Optional match predicate used to disable the filter. The filter is enabled when this field is empty.
   * See :ref:`ListenerFilterChainMatchPredicate <envoy_v3_api_msg_config.listener.v3.ListenerFilterChainMatchPredicate>`
   * for further examples.
   */
  filter_disabled?: ListenerFilterChainMatchPredicate | undefined;
}

function createBaseFilter(): Filter {
  return { $type: "envoy.config.listener.v3.Filter", config_type: undefined };
}

export const Filter: MessageFns<Filter, "envoy.config.listener.v3.Filter"> = {
  $type: "envoy.config.listener.v3.Filter" as const,

  encode(message: Filter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    switch (message.config_type?.$case) {
      case "typed_config":
        Any.encode(message.config_type.typed_config, writer.uint32(34).fork()).join();
        break;
      case "config_discovery":
        ExtensionConfigSource.encode(message.config_type.config_discovery, writer.uint32(42).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Filter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.config_type = { $case: "typed_config", typed_config: Any.decode(reader, reader.uint32()) };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.config_type = {
            $case: "config_discovery",
            config_discovery: ExtensionConfigSource.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Filter {
    return {
      $type: Filter.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      config_type: isSet(object.typed_config)
        ? { $case: "typed_config", typed_config: Any.fromJSON(object.typed_config) }
        : isSet(object.config_discovery)
        ? { $case: "config_discovery", config_discovery: ExtensionConfigSource.fromJSON(object.config_discovery) }
        : undefined,
    };
  },

  toJSON(message: Filter): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.config_type?.$case === "typed_config") {
      obj.typed_config = Any.toJSON(message.config_type.typed_config);
    }
    if (message.config_type?.$case === "config_discovery") {
      obj.config_discovery = ExtensionConfigSource.toJSON(message.config_type.config_discovery);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Filter>, I>>(base?: I): Filter {
    return Filter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Filter>, I>>(object: I): Filter {
    const message = createBaseFilter();
    message.name = object.name ?? undefined;
    if (
      object.config_type?.$case === "typed_config" &&
      object.config_type?.typed_config !== undefined &&
      object.config_type?.typed_config !== null
    ) {
      message.config_type = { $case: "typed_config", typed_config: Any.fromPartial(object.config_type.typed_config) };
    }
    if (
      object.config_type?.$case === "config_discovery" &&
      object.config_type?.config_discovery !== undefined &&
      object.config_type?.config_discovery !== null
    ) {
      message.config_type = {
        $case: "config_discovery",
        config_discovery: ExtensionConfigSource.fromPartial(object.config_type.config_discovery),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(Filter.$type, Filter);

function createBaseFilterChainMatch(): FilterChainMatch {
  return { $type: "envoy.config.listener.v3.FilterChainMatch" };
}

export const FilterChainMatch: MessageFns<FilterChainMatch, "envoy.config.listener.v3.FilterChainMatch"> = {
  $type: "envoy.config.listener.v3.FilterChainMatch" as const,

  encode(message: FilterChainMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.destination_port !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.destination_port! },
        writer.uint32(66).fork(),
      ).join();
    }
    if (message.prefix_ranges !== undefined && message.prefix_ranges.length !== 0) {
      for (const v of message.prefix_ranges) {
        CidrRange.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    if (message.address_suffix !== undefined && message.address_suffix !== "") {
      writer.uint32(34).string(message.address_suffix);
    }
    if (message.suffix_len !== undefined) {
      UInt32Value.encode({ $type: "google.protobuf.UInt32Value", value: message.suffix_len! }, writer.uint32(42).fork())
        .join();
    }
    if (message.direct_source_prefix_ranges !== undefined && message.direct_source_prefix_ranges.length !== 0) {
      for (const v of message.direct_source_prefix_ranges) {
        CidrRange.encode(v!, writer.uint32(106).fork()).join();
      }
    }
    if (message.source_type !== undefined && message.source_type !== FilterChainMatch_ConnectionSourceType.ANY) {
      writer.uint32(96).int32(filterChainMatch_ConnectionSourceTypeToNumber(message.source_type));
    }
    if (message.source_prefix_ranges !== undefined && message.source_prefix_ranges.length !== 0) {
      for (const v of message.source_prefix_ranges) {
        CidrRange.encode(v!, writer.uint32(50).fork()).join();
      }
    }
    if (message.source_ports !== undefined && message.source_ports.length !== 0) {
      writer.uint32(58).fork();
      for (const v of message.source_ports) {
        writer.uint32(v);
      }
      writer.join();
    }
    if (message.server_names !== undefined && message.server_names.length !== 0) {
      for (const v of message.server_names) {
        writer.uint32(90).string(v!);
      }
    }
    if (message.transport_protocol !== undefined && message.transport_protocol !== "") {
      writer.uint32(74).string(message.transport_protocol);
    }
    if (message.application_protocols !== undefined && message.application_protocols.length !== 0) {
      for (const v of message.application_protocols) {
        writer.uint32(82).string(v!);
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FilterChainMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilterChainMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.destination_port = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.prefix_ranges === undefined) {
            message.prefix_ranges = [];
          }
          const el = CidrRange.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.prefix_ranges!.push(el);
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.address_suffix = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.suffix_len = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          if (message.direct_source_prefix_ranges === undefined) {
            message.direct_source_prefix_ranges = [];
          }
          const el = CidrRange.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.direct_source_prefix_ranges!.push(el);
          }
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.source_type = filterChainMatch_ConnectionSourceTypeFromJSON(reader.int32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          if (message.source_prefix_ranges === undefined) {
            message.source_prefix_ranges = [];
          }
          const el = CidrRange.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.source_prefix_ranges!.push(el);
          }
          continue;
        }
        case 7: {
          if (tag === 56) {
            if (message.source_ports === undefined) {
              message.source_ports = [];
            }
            message.source_ports!.push(reader.uint32());

            continue;
          }

          if (tag === 58) {
            if (message.source_ports === undefined) {
              message.source_ports = [];
            }
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.source_ports!.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          if (message.server_names === undefined) {
            message.server_names = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.server_names!.push(el);
          }
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.transport_protocol = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          if (message.application_protocols === undefined) {
            message.application_protocols = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.application_protocols!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FilterChainMatch {
    return {
      $type: FilterChainMatch.$type,
      destination_port: isSet(object.destination_port) ? Number(object.destination_port) : undefined,
      prefix_ranges: globalThis.Array.isArray(object?.prefix_ranges)
        ? object.prefix_ranges.map((e: any) => CidrRange.fromJSON(e))
        : undefined,
      address_suffix: isSet(object.address_suffix) ? globalThis.String(object.address_suffix) : undefined,
      suffix_len: isSet(object.suffix_len) ? Number(object.suffix_len) : undefined,
      direct_source_prefix_ranges: globalThis.Array.isArray(object?.direct_source_prefix_ranges)
        ? object.direct_source_prefix_ranges.map((e: any) => CidrRange.fromJSON(e))
        : undefined,
      source_type: isSet(object.source_type)
        ? filterChainMatch_ConnectionSourceTypeFromJSON(object.source_type)
        : undefined,
      source_prefix_ranges: globalThis.Array.isArray(object?.source_prefix_ranges)
        ? object.source_prefix_ranges.map((e: any) => CidrRange.fromJSON(e))
        : undefined,
      source_ports: globalThis.Array.isArray(object?.source_ports)
        ? object.source_ports.map((e: any) => globalThis.Number(e))
        : undefined,
      server_names: globalThis.Array.isArray(object?.server_names)
        ? object.server_names.map((e: any) => globalThis.String(e))
        : undefined,
      transport_protocol: isSet(object.transport_protocol) ? globalThis.String(object.transport_protocol) : undefined,
      application_protocols: globalThis.Array.isArray(object?.application_protocols)
        ? object.application_protocols.map((e: any) => globalThis.String(e))
        : undefined,
    };
  },

  toJSON(message: FilterChainMatch): unknown {
    const obj: any = {};
    if (message.destination_port !== undefined) {
      obj.destination_port = message.destination_port;
    }
    if (message.prefix_ranges?.length) {
      obj.prefix_ranges = message.prefix_ranges.map((e) => CidrRange.toJSON(e));
    }
    if (message.address_suffix !== undefined) {
      obj.address_suffix = message.address_suffix;
    }
    if (message.suffix_len !== undefined) {
      obj.suffix_len = message.suffix_len;
    }
    if (message.direct_source_prefix_ranges?.length) {
      obj.direct_source_prefix_ranges = message.direct_source_prefix_ranges.map((e) => CidrRange.toJSON(e));
    }
    if (message.source_type !== undefined) {
      obj.source_type = filterChainMatch_ConnectionSourceTypeToJSON(message.source_type);
    }
    if (message.source_prefix_ranges?.length) {
      obj.source_prefix_ranges = message.source_prefix_ranges.map((e) => CidrRange.toJSON(e));
    }
    if (message.source_ports?.length) {
      obj.source_ports = message.source_ports.map((e) => Math.round(e));
    }
    if (message.server_names?.length) {
      obj.server_names = message.server_names;
    }
    if (message.transport_protocol !== undefined) {
      obj.transport_protocol = message.transport_protocol;
    }
    if (message.application_protocols?.length) {
      obj.application_protocols = message.application_protocols;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FilterChainMatch>, I>>(base?: I): FilterChainMatch {
    return FilterChainMatch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FilterChainMatch>, I>>(object: I): FilterChainMatch {
    const message = createBaseFilterChainMatch();
    message.destination_port = object.destination_port ?? undefined;
    message.prefix_ranges = object.prefix_ranges?.map((e) => CidrRange.fromPartial(e)) || undefined;
    message.address_suffix = object.address_suffix ?? undefined;
    message.suffix_len = object.suffix_len ?? undefined;
    message.direct_source_prefix_ranges = object.direct_source_prefix_ranges?.map((e) => CidrRange.fromPartial(e)) ||
      undefined;
    message.source_type = object.source_type ?? undefined;
    message.source_prefix_ranges = object.source_prefix_ranges?.map((e) => CidrRange.fromPartial(e)) || undefined;
    message.source_ports = object.source_ports?.map((e) => e) || undefined;
    message.server_names = object.server_names?.map((e) => e) || undefined;
    message.transport_protocol = object.transport_protocol ?? undefined;
    message.application_protocols = object.application_protocols?.map((e) => e) || undefined;
    return message;
  },
};

messageTypeRegistry.set(FilterChainMatch.$type, FilterChainMatch);

function createBaseFilterChain(): FilterChain {
  return { $type: "envoy.config.listener.v3.FilterChain" };
}

export const FilterChain: MessageFns<FilterChain, "envoy.config.listener.v3.FilterChain"> = {
  $type: "envoy.config.listener.v3.FilterChain" as const,

  encode(message: FilterChain, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filter_chain_match !== undefined) {
      FilterChainMatch.encode(message.filter_chain_match, writer.uint32(10).fork()).join();
    }
    if (message.filters !== undefined && message.filters.length !== 0) {
      for (const v of message.filters) {
        Filter.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    if (message.use_proxy_proto !== undefined) {
      BoolValue.encode(
        { $type: "google.protobuf.BoolValue", value: message.use_proxy_proto! },
        writer.uint32(34).fork(),
      ).join();
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(42).fork()).join();
    }
    if (message.transport_socket !== undefined) {
      TransportSocket.encode(message.transport_socket, writer.uint32(50).fork()).join();
    }
    if (message.transport_socket_connect_timeout !== undefined) {
      Duration.encode(message.transport_socket_connect_timeout, writer.uint32(74).fork()).join();
    }
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(58).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FilterChain {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilterChain();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filter_chain_match = FilterChainMatch.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.filters === undefined) {
            message.filters = [];
          }
          const el = Filter.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.filters!.push(el);
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.use_proxy_proto = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.transport_socket = TransportSocket.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.transport_socket_connect_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FilterChain {
    return {
      $type: FilterChain.$type,
      filter_chain_match: isSet(object.filter_chain_match)
        ? FilterChainMatch.fromJSON(object.filter_chain_match)
        : undefined,
      filters: globalThis.Array.isArray(object?.filters)
        ? object.filters.map((e: any) => Filter.fromJSON(e))
        : undefined,
      use_proxy_proto: isSet(object.use_proxy_proto) ? Boolean(object.use_proxy_proto) : undefined,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      transport_socket: isSet(object.transport_socket) ? TransportSocket.fromJSON(object.transport_socket) : undefined,
      transport_socket_connect_timeout: isSet(object.transport_socket_connect_timeout)
        ? Duration.fromJSON(object.transport_socket_connect_timeout)
        : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
    };
  },

  toJSON(message: FilterChain): unknown {
    const obj: any = {};
    if (message.filter_chain_match !== undefined) {
      obj.filter_chain_match = FilterChainMatch.toJSON(message.filter_chain_match);
    }
    if (message.filters?.length) {
      obj.filters = message.filters.map((e) => Filter.toJSON(e));
    }
    if (message.use_proxy_proto !== undefined) {
      obj.use_proxy_proto = message.use_proxy_proto;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.transport_socket !== undefined) {
      obj.transport_socket = TransportSocket.toJSON(message.transport_socket);
    }
    if (message.transport_socket_connect_timeout !== undefined) {
      obj.transport_socket_connect_timeout = Duration.toJSON(message.transport_socket_connect_timeout);
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FilterChain>, I>>(base?: I): FilterChain {
    return FilterChain.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FilterChain>, I>>(object: I): FilterChain {
    const message = createBaseFilterChain();
    message.filter_chain_match = (object.filter_chain_match !== undefined && object.filter_chain_match !== null)
      ? FilterChainMatch.fromPartial(object.filter_chain_match)
      : undefined;
    message.filters = object.filters?.map((e) => Filter.fromPartial(e)) || undefined;
    message.use_proxy_proto = object.use_proxy_proto ?? undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.transport_socket = (object.transport_socket !== undefined && object.transport_socket !== null)
      ? TransportSocket.fromPartial(object.transport_socket)
      : undefined;
    message.transport_socket_connect_timeout =
      (object.transport_socket_connect_timeout !== undefined && object.transport_socket_connect_timeout !== null)
        ? Duration.fromPartial(object.transport_socket_connect_timeout)
        : undefined;
    message.name = object.name ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(FilterChain.$type, FilterChain);

function createBaseListenerFilterChainMatchPredicate(): ListenerFilterChainMatchPredicate {
  return { $type: "envoy.config.listener.v3.ListenerFilterChainMatchPredicate", rule: undefined };
}

export const ListenerFilterChainMatchPredicate: MessageFns<
  ListenerFilterChainMatchPredicate,
  "envoy.config.listener.v3.ListenerFilterChainMatchPredicate"
> = {
  $type: "envoy.config.listener.v3.ListenerFilterChainMatchPredicate" as const,

  encode(message: ListenerFilterChainMatchPredicate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.rule?.$case) {
      case "or_match":
        ListenerFilterChainMatchPredicate_MatchSet.encode(message.rule.or_match, writer.uint32(10).fork()).join();
        break;
      case "and_match":
        ListenerFilterChainMatchPredicate_MatchSet.encode(message.rule.and_match, writer.uint32(18).fork()).join();
        break;
      case "not_match":
        ListenerFilterChainMatchPredicate.encode(message.rule.not_match, writer.uint32(26).fork()).join();
        break;
      case "any_match":
        writer.uint32(32).bool(message.rule.any_match);
        break;
      case "destination_port_range":
        Int32Range.encode(message.rule.destination_port_range, writer.uint32(42).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListenerFilterChainMatchPredicate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListenerFilterChainMatchPredicate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rule = {
            $case: "or_match",
            or_match: ListenerFilterChainMatchPredicate_MatchSet.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rule = {
            $case: "and_match",
            and_match: ListenerFilterChainMatchPredicate_MatchSet.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rule = {
            $case: "not_match",
            not_match: ListenerFilterChainMatchPredicate.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.rule = { $case: "any_match", any_match: reader.bool() };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.rule = {
            $case: "destination_port_range",
            destination_port_range: Int32Range.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListenerFilterChainMatchPredicate {
    return {
      $type: ListenerFilterChainMatchPredicate.$type,
      rule: isSet(object.or_match)
        ? { $case: "or_match", or_match: ListenerFilterChainMatchPredicate_MatchSet.fromJSON(object.or_match) }
        : isSet(object.and_match)
        ? { $case: "and_match", and_match: ListenerFilterChainMatchPredicate_MatchSet.fromJSON(object.and_match) }
        : isSet(object.not_match)
        ? { $case: "not_match", not_match: ListenerFilterChainMatchPredicate.fromJSON(object.not_match) }
        : isSet(object.any_match)
        ? { $case: "any_match", any_match: globalThis.Boolean(object.any_match) }
        : isSet(object.destination_port_range)
        ? {
          $case: "destination_port_range",
          destination_port_range: Int32Range.fromJSON(object.destination_port_range),
        }
        : undefined,
    };
  },

  toJSON(message: ListenerFilterChainMatchPredicate): unknown {
    const obj: any = {};
    if (message.rule?.$case === "or_match") {
      obj.or_match = ListenerFilterChainMatchPredicate_MatchSet.toJSON(message.rule.or_match);
    }
    if (message.rule?.$case === "and_match") {
      obj.and_match = ListenerFilterChainMatchPredicate_MatchSet.toJSON(message.rule.and_match);
    }
    if (message.rule?.$case === "not_match") {
      obj.not_match = ListenerFilterChainMatchPredicate.toJSON(message.rule.not_match);
    }
    if (message.rule?.$case === "any_match") {
      obj.any_match = message.rule.any_match;
    }
    if (message.rule?.$case === "destination_port_range") {
      obj.destination_port_range = Int32Range.toJSON(message.rule.destination_port_range);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListenerFilterChainMatchPredicate>, I>>(
    base?: I,
  ): ListenerFilterChainMatchPredicate {
    return ListenerFilterChainMatchPredicate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListenerFilterChainMatchPredicate>, I>>(
    object: I,
  ): ListenerFilterChainMatchPredicate {
    const message = createBaseListenerFilterChainMatchPredicate();
    if (object.rule?.$case === "or_match" && object.rule?.or_match !== undefined && object.rule?.or_match !== null) {
      message.rule = {
        $case: "or_match",
        or_match: ListenerFilterChainMatchPredicate_MatchSet.fromPartial(object.rule.or_match),
      };
    }
    if (object.rule?.$case === "and_match" && object.rule?.and_match !== undefined && object.rule?.and_match !== null) {
      message.rule = {
        $case: "and_match",
        and_match: ListenerFilterChainMatchPredicate_MatchSet.fromPartial(object.rule.and_match),
      };
    }
    if (object.rule?.$case === "not_match" && object.rule?.not_match !== undefined && object.rule?.not_match !== null) {
      message.rule = {
        $case: "not_match",
        not_match: ListenerFilterChainMatchPredicate.fromPartial(object.rule.not_match),
      };
    }
    if (object.rule?.$case === "any_match" && object.rule?.any_match !== undefined && object.rule?.any_match !== null) {
      message.rule = { $case: "any_match", any_match: object.rule.any_match };
    }
    if (
      object.rule?.$case === "destination_port_range" &&
      object.rule?.destination_port_range !== undefined &&
      object.rule?.destination_port_range !== null
    ) {
      message.rule = {
        $case: "destination_port_range",
        destination_port_range: Int32Range.fromPartial(object.rule.destination_port_range),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(ListenerFilterChainMatchPredicate.$type, ListenerFilterChainMatchPredicate);

function createBaseListenerFilterChainMatchPredicate_MatchSet(): ListenerFilterChainMatchPredicate_MatchSet {
  return { $type: "envoy.config.listener.v3.ListenerFilterChainMatchPredicate.MatchSet" };
}

export const ListenerFilterChainMatchPredicate_MatchSet: MessageFns<
  ListenerFilterChainMatchPredicate_MatchSet,
  "envoy.config.listener.v3.ListenerFilterChainMatchPredicate.MatchSet"
> = {
  $type: "envoy.config.listener.v3.ListenerFilterChainMatchPredicate.MatchSet" as const,

  encode(message: ListenerFilterChainMatchPredicate_MatchSet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rules !== undefined && message.rules.length !== 0) {
      for (const v of message.rules) {
        ListenerFilterChainMatchPredicate.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListenerFilterChainMatchPredicate_MatchSet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListenerFilterChainMatchPredicate_MatchSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.rules === undefined) {
            message.rules = [];
          }
          const el = ListenerFilterChainMatchPredicate.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.rules!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListenerFilterChainMatchPredicate_MatchSet {
    return {
      $type: ListenerFilterChainMatchPredicate_MatchSet.$type,
      rules: globalThis.Array.isArray(object?.rules)
        ? object.rules.map((e: any) => ListenerFilterChainMatchPredicate.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: ListenerFilterChainMatchPredicate_MatchSet): unknown {
    const obj: any = {};
    if (message.rules?.length) {
      obj.rules = message.rules.map((e) => ListenerFilterChainMatchPredicate.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListenerFilterChainMatchPredicate_MatchSet>, I>>(
    base?: I,
  ): ListenerFilterChainMatchPredicate_MatchSet {
    return ListenerFilterChainMatchPredicate_MatchSet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListenerFilterChainMatchPredicate_MatchSet>, I>>(
    object: I,
  ): ListenerFilterChainMatchPredicate_MatchSet {
    const message = createBaseListenerFilterChainMatchPredicate_MatchSet();
    message.rules = object.rules?.map((e) => ListenerFilterChainMatchPredicate.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(ListenerFilterChainMatchPredicate_MatchSet.$type, ListenerFilterChainMatchPredicate_MatchSet);

function createBaseListenerFilter(): ListenerFilter {
  return { $type: "envoy.config.listener.v3.ListenerFilter", config_type: undefined };
}

export const ListenerFilter: MessageFns<ListenerFilter, "envoy.config.listener.v3.ListenerFilter"> = {
  $type: "envoy.config.listener.v3.ListenerFilter" as const,

  encode(message: ListenerFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    switch (message.config_type?.$case) {
      case "typed_config":
        Any.encode(message.config_type.typed_config, writer.uint32(26).fork()).join();
        break;
      case "config_discovery":
        ExtensionConfigSource.encode(message.config_type.config_discovery, writer.uint32(42).fork()).join();
        break;
    }
    if (message.filter_disabled !== undefined) {
      ListenerFilterChainMatchPredicate.encode(message.filter_disabled, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListenerFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListenerFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.config_type = { $case: "typed_config", typed_config: Any.decode(reader, reader.uint32()) };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.config_type = {
            $case: "config_discovery",
            config_discovery: ExtensionConfigSource.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.filter_disabled = ListenerFilterChainMatchPredicate.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListenerFilter {
    return {
      $type: ListenerFilter.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      config_type: isSet(object.typed_config)
        ? { $case: "typed_config", typed_config: Any.fromJSON(object.typed_config) }
        : isSet(object.config_discovery)
        ? { $case: "config_discovery", config_discovery: ExtensionConfigSource.fromJSON(object.config_discovery) }
        : undefined,
      filter_disabled: isSet(object.filter_disabled)
        ? ListenerFilterChainMatchPredicate.fromJSON(object.filter_disabled)
        : undefined,
    };
  },

  toJSON(message: ListenerFilter): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.config_type?.$case === "typed_config") {
      obj.typed_config = Any.toJSON(message.config_type.typed_config);
    }
    if (message.config_type?.$case === "config_discovery") {
      obj.config_discovery = ExtensionConfigSource.toJSON(message.config_type.config_discovery);
    }
    if (message.filter_disabled !== undefined) {
      obj.filter_disabled = ListenerFilterChainMatchPredicate.toJSON(message.filter_disabled);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListenerFilter>, I>>(base?: I): ListenerFilter {
    return ListenerFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListenerFilter>, I>>(object: I): ListenerFilter {
    const message = createBaseListenerFilter();
    message.name = object.name ?? undefined;
    if (
      object.config_type?.$case === "typed_config" &&
      object.config_type?.typed_config !== undefined &&
      object.config_type?.typed_config !== null
    ) {
      message.config_type = { $case: "typed_config", typed_config: Any.fromPartial(object.config_type.typed_config) };
    }
    if (
      object.config_type?.$case === "config_discovery" &&
      object.config_type?.config_discovery !== undefined &&
      object.config_type?.config_discovery !== null
    ) {
      message.config_type = {
        $case: "config_discovery",
        config_discovery: ExtensionConfigSource.fromPartial(object.config_type.config_discovery),
      };
    }
    message.filter_disabled = (object.filter_disabled !== undefined && object.filter_disabled !== null)
      ? ListenerFilterChainMatchPredicate.fromPartial(object.filter_disabled)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(ListenerFilter.$type, ListenerFilter);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
