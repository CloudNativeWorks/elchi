// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/data/cluster/v3/outlier_detection_event.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "../../../../google/protobuf/timestamp";
import { UInt64Value } from "../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../typeRegistry";

export const protobufPackage = "envoy.data.cluster.v3";

/** Type of ejection that took place */
export enum OutlierEjectionType {
  /**
   * CONSECUTIVE_5XX - In case upstream host returns certain number of consecutive 5xx.
   * If
   * :ref:`outlier_detection.split_external_local_origin_errors<envoy_v3_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
   * is ``false``, all type of errors are treated as HTTP 5xx errors.
   * See :ref:`Cluster outlier detection <arch_overview_outlier_detection>` documentation for
   * details.
   */
  CONSECUTIVE_5XX = "CONSECUTIVE_5XX",
  /** CONSECUTIVE_GATEWAY_FAILURE - In case upstream host returns certain number of consecutive gateway errors */
  CONSECUTIVE_GATEWAY_FAILURE = "CONSECUTIVE_GATEWAY_FAILURE",
  /**
   * SUCCESS_RATE - Runs over aggregated success rate statistics from every host in cluster
   * and selects hosts for which ratio of successful replies deviates from other hosts
   * in the cluster.
   * If
   * :ref:`outlier_detection.split_external_local_origin_errors<envoy_v3_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
   * is ``false``, all errors (externally and locally generated) are used to calculate success rate
   * statistics. See :ref:`Cluster outlier detection <arch_overview_outlier_detection>`
   * documentation for details.
   */
  SUCCESS_RATE = "SUCCESS_RATE",
  /**
   * CONSECUTIVE_LOCAL_ORIGIN_FAILURE - Consecutive local origin failures: Connection failures, resets, timeouts, etc
   * This type of ejection happens only when
   * :ref:`outlier_detection.split_external_local_origin_errors<envoy_v3_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
   * is set to ``true``.
   * See :ref:`Cluster outlier detection <arch_overview_outlier_detection>` documentation for
   */
  CONSECUTIVE_LOCAL_ORIGIN_FAILURE = "CONSECUTIVE_LOCAL_ORIGIN_FAILURE",
  /**
   * SUCCESS_RATE_LOCAL_ORIGIN - Runs over aggregated success rate statistics for local origin failures
   * for all hosts in the cluster and selects hosts for which success rate deviates from other
   * hosts in the cluster. This type of ejection happens only when
   * :ref:`outlier_detection.split_external_local_origin_errors<envoy_v3_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
   * is set to ``true``.
   * See :ref:`Cluster outlier detection <arch_overview_outlier_detection>` documentation for
   */
  SUCCESS_RATE_LOCAL_ORIGIN = "SUCCESS_RATE_LOCAL_ORIGIN",
  /**
   * FAILURE_PERCENTAGE - Runs over aggregated success rate statistics from every host in cluster and selects hosts for
   * which ratio of failed replies is above configured value.
   */
  FAILURE_PERCENTAGE = "FAILURE_PERCENTAGE",
  /**
   * FAILURE_PERCENTAGE_LOCAL_ORIGIN - Runs over aggregated success rate statistics for local origin failures from every host in
   * cluster and selects hosts for which ratio of failed replies is above configured value.
   */
  FAILURE_PERCENTAGE_LOCAL_ORIGIN = "FAILURE_PERCENTAGE_LOCAL_ORIGIN",
}

export function outlierEjectionTypeFromJSON(object: any): OutlierEjectionType {
  switch (object) {
    case 0:
    case "CONSECUTIVE_5XX":
      return OutlierEjectionType.CONSECUTIVE_5XX;
    case 1:
    case "CONSECUTIVE_GATEWAY_FAILURE":
      return OutlierEjectionType.CONSECUTIVE_GATEWAY_FAILURE;
    case 2:
    case "SUCCESS_RATE":
      return OutlierEjectionType.SUCCESS_RATE;
    case 3:
    case "CONSECUTIVE_LOCAL_ORIGIN_FAILURE":
      return OutlierEjectionType.CONSECUTIVE_LOCAL_ORIGIN_FAILURE;
    case 4:
    case "SUCCESS_RATE_LOCAL_ORIGIN":
      return OutlierEjectionType.SUCCESS_RATE_LOCAL_ORIGIN;
    case 5:
    case "FAILURE_PERCENTAGE":
      return OutlierEjectionType.FAILURE_PERCENTAGE;
    case 6:
    case "FAILURE_PERCENTAGE_LOCAL_ORIGIN":
      return OutlierEjectionType.FAILURE_PERCENTAGE_LOCAL_ORIGIN;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum OutlierEjectionType");
  }
}

export function outlierEjectionTypeToJSON(object: OutlierEjectionType): string {
  switch (object) {
    case OutlierEjectionType.CONSECUTIVE_5XX:
      return "CONSECUTIVE_5XX";
    case OutlierEjectionType.CONSECUTIVE_GATEWAY_FAILURE:
      return "CONSECUTIVE_GATEWAY_FAILURE";
    case OutlierEjectionType.SUCCESS_RATE:
      return "SUCCESS_RATE";
    case OutlierEjectionType.CONSECUTIVE_LOCAL_ORIGIN_FAILURE:
      return "CONSECUTIVE_LOCAL_ORIGIN_FAILURE";
    case OutlierEjectionType.SUCCESS_RATE_LOCAL_ORIGIN:
      return "SUCCESS_RATE_LOCAL_ORIGIN";
    case OutlierEjectionType.FAILURE_PERCENTAGE:
      return "FAILURE_PERCENTAGE";
    case OutlierEjectionType.FAILURE_PERCENTAGE_LOCAL_ORIGIN:
      return "FAILURE_PERCENTAGE_LOCAL_ORIGIN";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum OutlierEjectionType");
  }
}

export function outlierEjectionTypeToNumber(object: OutlierEjectionType): number {
  switch (object) {
    case OutlierEjectionType.CONSECUTIVE_5XX:
      return 0;
    case OutlierEjectionType.CONSECUTIVE_GATEWAY_FAILURE:
      return 1;
    case OutlierEjectionType.SUCCESS_RATE:
      return 2;
    case OutlierEjectionType.CONSECUTIVE_LOCAL_ORIGIN_FAILURE:
      return 3;
    case OutlierEjectionType.SUCCESS_RATE_LOCAL_ORIGIN:
      return 4;
    case OutlierEjectionType.FAILURE_PERCENTAGE:
      return 5;
    case OutlierEjectionType.FAILURE_PERCENTAGE_LOCAL_ORIGIN:
      return 6;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum OutlierEjectionType");
  }
}

/** Represents possible action applied to upstream host */
export enum Action {
  /** EJECT - In case host was excluded from service */
  EJECT = "EJECT",
  /** UNEJECT - In case host was brought back into service */
  UNEJECT = "UNEJECT",
}

export function actionFromJSON(object: any): Action {
  switch (object) {
    case 0:
    case "EJECT":
      return Action.EJECT;
    case 1:
    case "UNEJECT":
      return Action.UNEJECT;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Action");
  }
}

export function actionToJSON(object: Action): string {
  switch (object) {
    case Action.EJECT:
      return "EJECT";
    case Action.UNEJECT:
      return "UNEJECT";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Action");
  }
}

export function actionToNumber(object: Action): number {
  switch (object) {
    case Action.EJECT:
      return 0;
    case Action.UNEJECT:
      return 1;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Action");
  }
}

/** [#next-free-field: 12] */
export interface OutlierDetectionEvent {
  $type: "envoy.data.cluster.v3.OutlierDetectionEvent";
  /** In case of eject represents type of ejection that took place. */
  type?:
    | OutlierEjectionType
    | undefined;
  /** Timestamp for event. */
  timestamp?:
    | Date
    | undefined;
  /** The time in seconds since the last action (either an ejection or unejection) took place. */
  secs_since_last_action?:
    | number
    | undefined;
  /** The :ref:`cluster <envoy_v3_api_msg_config.cluster.v3.Cluster>` that owns the ejected host. */
  cluster_name?:
    | string
    | undefined;
  /** The URL of the ejected host. E.g., ``tcp://1.2.3.4:80``. */
  upstream_url?:
    | string
    | undefined;
  /** The action that took place. */
  action?:
    | Action
    | undefined;
  /**
   * If ``action`` is ``eject``, specifies the number of times the host has been ejected (local to
   * that Envoy and gets reset if the host gets removed from the upstream cluster for any reason and
   * then re-added).
   */
  num_ejections?:
    | number
    | undefined;
  /**
   * If ``action`` is ``eject``, specifies if the ejection was enforced. ``true`` means the host was
   * ejected. ``false`` means the event was logged but the host was not actually ejected.
   */
  enforced?: boolean | undefined;
  event?:
    | //
    { $case: "eject_success_rate_event"; eject_success_rate_event: OutlierEjectSuccessRate }
    | //
    { $case: "eject_consecutive_event"; eject_consecutive_event: OutlierEjectConsecutive }
    | //
    { $case: "eject_failure_percentage_event"; eject_failure_percentage_event: OutlierEjectFailurePercentage }
    | undefined;
}

export interface OutlierEjectSuccessRate {
  $type: "envoy.data.cluster.v3.OutlierEjectSuccessRate";
  /** Hostâ€™s success rate at the time of the ejection event on a 0-100 range. */
  host_success_rate?:
    | number
    | undefined;
  /**
   * Average success rate of the hosts in the cluster at the time of the ejection event on a 0-100
   * range.
   */
  cluster_average_success_rate?:
    | number
    | undefined;
  /** Success rate ejection threshold at the time of the ejection event. */
  cluster_success_rate_ejection_threshold?: number | undefined;
}

export interface OutlierEjectConsecutive {
  $type: "envoy.data.cluster.v3.OutlierEjectConsecutive";
}

export interface OutlierEjectFailurePercentage {
  $type: "envoy.data.cluster.v3.OutlierEjectFailurePercentage";
  /** Host's success rate at the time of the ejection event on a 0-100 range. */
  host_success_rate?: number | undefined;
}

function createBaseOutlierDetectionEvent(): OutlierDetectionEvent {
  return { $type: "envoy.data.cluster.v3.OutlierDetectionEvent", event: undefined };
}

export const OutlierDetectionEvent: MessageFns<OutlierDetectionEvent, "envoy.data.cluster.v3.OutlierDetectionEvent"> = {
  $type: "envoy.data.cluster.v3.OutlierDetectionEvent" as const,

  encode(message: OutlierDetectionEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== undefined && message.type !== OutlierEjectionType.CONSECUTIVE_5XX) {
      writer.uint32(8).int32(outlierEjectionTypeToNumber(message.type));
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(18).fork()).join();
    }
    if (message.secs_since_last_action !== undefined) {
      UInt64Value.encode(
        { $type: "google.protobuf.UInt64Value", value: message.secs_since_last_action! },
        writer.uint32(26).fork(),
      ).join();
    }
    if (message.cluster_name !== undefined && message.cluster_name !== "") {
      writer.uint32(34).string(message.cluster_name);
    }
    if (message.upstream_url !== undefined && message.upstream_url !== "") {
      writer.uint32(42).string(message.upstream_url);
    }
    if (message.action !== undefined && message.action !== Action.EJECT) {
      writer.uint32(48).int32(actionToNumber(message.action));
    }
    if (message.num_ejections !== undefined && message.num_ejections !== 0) {
      writer.uint32(56).uint32(message.num_ejections);
    }
    if (message.enforced !== undefined && message.enforced !== false) {
      writer.uint32(64).bool(message.enforced);
    }
    switch (message.event?.$case) {
      case "eject_success_rate_event":
        OutlierEjectSuccessRate.encode(message.event.eject_success_rate_event, writer.uint32(74).fork()).join();
        break;
      case "eject_consecutive_event":
        OutlierEjectConsecutive.encode(message.event.eject_consecutive_event, writer.uint32(82).fork()).join();
        break;
      case "eject_failure_percentage_event":
        OutlierEjectFailurePercentage.encode(message.event.eject_failure_percentage_event, writer.uint32(90).fork())
          .join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutlierDetectionEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutlierDetectionEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = outlierEjectionTypeFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.secs_since_last_action = UInt64Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.cluster_name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.upstream_url = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.action = actionFromJSON(reader.int32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.num_ejections = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.enforced = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.event = {
            $case: "eject_success_rate_event",
            eject_success_rate_event: OutlierEjectSuccessRate.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.event = {
            $case: "eject_consecutive_event",
            eject_consecutive_event: OutlierEjectConsecutive.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.event = {
            $case: "eject_failure_percentage_event",
            eject_failure_percentage_event: OutlierEjectFailurePercentage.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutlierDetectionEvent {
    return {
      $type: OutlierDetectionEvent.$type,
      type: isSet(object.type) ? outlierEjectionTypeFromJSON(object.type) : undefined,
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      secs_since_last_action: isSet(object.secs_since_last_action) ? Number(object.secs_since_last_action) : undefined,
      cluster_name: isSet(object.cluster_name) ? globalThis.String(object.cluster_name) : undefined,
      upstream_url: isSet(object.upstream_url) ? globalThis.String(object.upstream_url) : undefined,
      action: isSet(object.action) ? actionFromJSON(object.action) : undefined,
      num_ejections: isSet(object.num_ejections) ? globalThis.Number(object.num_ejections) : undefined,
      enforced: isSet(object.enforced) ? globalThis.Boolean(object.enforced) : undefined,
      event: isSet(object.eject_success_rate_event)
        ? {
          $case: "eject_success_rate_event",
          eject_success_rate_event: OutlierEjectSuccessRate.fromJSON(object.eject_success_rate_event),
        }
        : isSet(object.eject_consecutive_event)
        ? {
          $case: "eject_consecutive_event",
          eject_consecutive_event: OutlierEjectConsecutive.fromJSON(object.eject_consecutive_event),
        }
        : isSet(object.eject_failure_percentage_event)
        ? {
          $case: "eject_failure_percentage_event",
          eject_failure_percentage_event: OutlierEjectFailurePercentage.fromJSON(object.eject_failure_percentage_event),
        }
        : undefined,
    };
  },

  toJSON(message: OutlierDetectionEvent): unknown {
    const obj: any = {};
    if (message.type !== undefined) {
      obj.type = outlierEjectionTypeToJSON(message.type);
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.secs_since_last_action !== undefined) {
      obj.secs_since_last_action = message.secs_since_last_action;
    }
    if (message.cluster_name !== undefined) {
      obj.cluster_name = message.cluster_name;
    }
    if (message.upstream_url !== undefined) {
      obj.upstream_url = message.upstream_url;
    }
    if (message.action !== undefined) {
      obj.action = actionToJSON(message.action);
    }
    if (message.num_ejections !== undefined) {
      obj.num_ejections = Math.round(message.num_ejections);
    }
    if (message.enforced !== undefined) {
      obj.enforced = message.enforced;
    }
    if (message.event?.$case === "eject_success_rate_event") {
      obj.eject_success_rate_event = OutlierEjectSuccessRate.toJSON(message.event.eject_success_rate_event);
    }
    if (message.event?.$case === "eject_consecutive_event") {
      obj.eject_consecutive_event = OutlierEjectConsecutive.toJSON(message.event.eject_consecutive_event);
    }
    if (message.event?.$case === "eject_failure_percentage_event") {
      obj.eject_failure_percentage_event = OutlierEjectFailurePercentage.toJSON(
        message.event.eject_failure_percentage_event,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OutlierDetectionEvent>, I>>(base?: I): OutlierDetectionEvent {
    return OutlierDetectionEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OutlierDetectionEvent>, I>>(object: I): OutlierDetectionEvent {
    const message = createBaseOutlierDetectionEvent();
    message.type = object.type ?? undefined;
    message.timestamp = object.timestamp ?? undefined;
    message.secs_since_last_action = object.secs_since_last_action ?? undefined;
    message.cluster_name = object.cluster_name ?? undefined;
    message.upstream_url = object.upstream_url ?? undefined;
    message.action = object.action ?? undefined;
    message.num_ejections = object.num_ejections ?? undefined;
    message.enforced = object.enforced ?? undefined;
    if (
      object.event?.$case === "eject_success_rate_event" &&
      object.event?.eject_success_rate_event !== undefined &&
      object.event?.eject_success_rate_event !== null
    ) {
      message.event = {
        $case: "eject_success_rate_event",
        eject_success_rate_event: OutlierEjectSuccessRate.fromPartial(object.event.eject_success_rate_event),
      };
    }
    if (
      object.event?.$case === "eject_consecutive_event" &&
      object.event?.eject_consecutive_event !== undefined &&
      object.event?.eject_consecutive_event !== null
    ) {
      message.event = {
        $case: "eject_consecutive_event",
        eject_consecutive_event: OutlierEjectConsecutive.fromPartial(object.event.eject_consecutive_event),
      };
    }
    if (
      object.event?.$case === "eject_failure_percentage_event" &&
      object.event?.eject_failure_percentage_event !== undefined &&
      object.event?.eject_failure_percentage_event !== null
    ) {
      message.event = {
        $case: "eject_failure_percentage_event",
        eject_failure_percentage_event: OutlierEjectFailurePercentage.fromPartial(
          object.event.eject_failure_percentage_event,
        ),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(OutlierDetectionEvent.$type, OutlierDetectionEvent);

function createBaseOutlierEjectSuccessRate(): OutlierEjectSuccessRate {
  return { $type: "envoy.data.cluster.v3.OutlierEjectSuccessRate" };
}

export const OutlierEjectSuccessRate: MessageFns<
  OutlierEjectSuccessRate,
  "envoy.data.cluster.v3.OutlierEjectSuccessRate"
> = {
  $type: "envoy.data.cluster.v3.OutlierEjectSuccessRate" as const,

  encode(message: OutlierEjectSuccessRate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.host_success_rate !== undefined && message.host_success_rate !== 0) {
      writer.uint32(8).uint32(message.host_success_rate);
    }
    if (message.cluster_average_success_rate !== undefined && message.cluster_average_success_rate !== 0) {
      writer.uint32(16).uint32(message.cluster_average_success_rate);
    }
    if (
      message.cluster_success_rate_ejection_threshold !== undefined &&
      message.cluster_success_rate_ejection_threshold !== 0
    ) {
      writer.uint32(24).uint32(message.cluster_success_rate_ejection_threshold);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutlierEjectSuccessRate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutlierEjectSuccessRate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.host_success_rate = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.cluster_average_success_rate = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.cluster_success_rate_ejection_threshold = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutlierEjectSuccessRate {
    return {
      $type: OutlierEjectSuccessRate.$type,
      host_success_rate: isSet(object.host_success_rate) ? globalThis.Number(object.host_success_rate) : undefined,
      cluster_average_success_rate: isSet(object.cluster_average_success_rate)
        ? globalThis.Number(object.cluster_average_success_rate)
        : undefined,
      cluster_success_rate_ejection_threshold: isSet(object.cluster_success_rate_ejection_threshold)
        ? globalThis.Number(object.cluster_success_rate_ejection_threshold)
        : undefined,
    };
  },

  toJSON(message: OutlierEjectSuccessRate): unknown {
    const obj: any = {};
    if (message.host_success_rate !== undefined) {
      obj.host_success_rate = Math.round(message.host_success_rate);
    }
    if (message.cluster_average_success_rate !== undefined) {
      obj.cluster_average_success_rate = Math.round(message.cluster_average_success_rate);
    }
    if (message.cluster_success_rate_ejection_threshold !== undefined) {
      obj.cluster_success_rate_ejection_threshold = Math.round(message.cluster_success_rate_ejection_threshold);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OutlierEjectSuccessRate>, I>>(base?: I): OutlierEjectSuccessRate {
    return OutlierEjectSuccessRate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OutlierEjectSuccessRate>, I>>(object: I): OutlierEjectSuccessRate {
    const message = createBaseOutlierEjectSuccessRate();
    message.host_success_rate = object.host_success_rate ?? undefined;
    message.cluster_average_success_rate = object.cluster_average_success_rate ?? undefined;
    message.cluster_success_rate_ejection_threshold = object.cluster_success_rate_ejection_threshold ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(OutlierEjectSuccessRate.$type, OutlierEjectSuccessRate);

function createBaseOutlierEjectConsecutive(): OutlierEjectConsecutive {
  return { $type: "envoy.data.cluster.v3.OutlierEjectConsecutive" };
}

export const OutlierEjectConsecutive: MessageFns<
  OutlierEjectConsecutive,
  "envoy.data.cluster.v3.OutlierEjectConsecutive"
> = {
  $type: "envoy.data.cluster.v3.OutlierEjectConsecutive" as const,

  encode(_: OutlierEjectConsecutive, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutlierEjectConsecutive {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutlierEjectConsecutive();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): OutlierEjectConsecutive {
    return { $type: OutlierEjectConsecutive.$type };
  },

  toJSON(_: OutlierEjectConsecutive): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<OutlierEjectConsecutive>, I>>(base?: I): OutlierEjectConsecutive {
    return OutlierEjectConsecutive.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OutlierEjectConsecutive>, I>>(_: I): OutlierEjectConsecutive {
    const message = createBaseOutlierEjectConsecutive();
    return message;
  },
};

messageTypeRegistry.set(OutlierEjectConsecutive.$type, OutlierEjectConsecutive);

function createBaseOutlierEjectFailurePercentage(): OutlierEjectFailurePercentage {
  return { $type: "envoy.data.cluster.v3.OutlierEjectFailurePercentage" };
}

export const OutlierEjectFailurePercentage: MessageFns<
  OutlierEjectFailurePercentage,
  "envoy.data.cluster.v3.OutlierEjectFailurePercentage"
> = {
  $type: "envoy.data.cluster.v3.OutlierEjectFailurePercentage" as const,

  encode(message: OutlierEjectFailurePercentage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.host_success_rate !== undefined && message.host_success_rate !== 0) {
      writer.uint32(8).uint32(message.host_success_rate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutlierEjectFailurePercentage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutlierEjectFailurePercentage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.host_success_rate = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutlierEjectFailurePercentage {
    return {
      $type: OutlierEjectFailurePercentage.$type,
      host_success_rate: isSet(object.host_success_rate) ? globalThis.Number(object.host_success_rate) : undefined,
    };
  },

  toJSON(message: OutlierEjectFailurePercentage): unknown {
    const obj: any = {};
    if (message.host_success_rate !== undefined) {
      obj.host_success_rate = Math.round(message.host_success_rate);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OutlierEjectFailurePercentage>, I>>(base?: I): OutlierEjectFailurePercentage {
    return OutlierEjectFailurePercentage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OutlierEjectFailurePercentage>, I>>(
    object: I,
  ): OutlierEjectFailurePercentage {
    const message = createBaseOutlierEjectFailurePercentage();
    message.host_success_rate = object.host_success_rate ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(OutlierEjectFailurePercentage.$type, OutlierEjectFailurePercentage);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { $type: "google.protobuf.Timestamp", seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
