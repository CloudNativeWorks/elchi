// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/config/filter/http/jwt_authn/v2alpha/config.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../../../../google/protobuf/duration";
import { Empty } from "../../../../../../google/protobuf/empty";
import { messageTypeRegistry } from "../../../../../../typeRegistry";
import { DataSource } from "../../../../../api/v2/core/base";
import { HttpUri } from "../../../../../api/v2/core/http_uri";
import { RouteMatch } from "../../../../../api/v2/route/route_components";

export const protobufPackage = "envoy.config.filter.http.jwt_authn.v2alpha";

/**
 * Please see following for JWT authentication flow:
 *
 * * `JSON Web Token (JWT) <https://tools.ietf.org/html/rfc7519>`_
 * * `The OAuth 2.0 Authorization Framework <https://tools.ietf.org/html/rfc6749>`_
 * * `OpenID Connect <http://openid.net/connect>`_
 *
 * A JwtProvider message specifies how a JSON Web Token (JWT) can be verified. It specifies:
 *
 * * issuer: the principal that issues the JWT. It has to match the one from the token.
 * * allowed audiences: the ones in the token have to be listed here.
 * * how to fetch public key JWKS to verify the token signature.
 * * how to extract the JWT in the request.
 * * how to pass successfully verified token payload.
 *
 * Example:
 *
 * .. code-block:: yaml
 *
 *     issuer: https://example.com
 *     audiences:
 *     - bookstore_android.apps.googleusercontent.com
 *     - bookstore_web.apps.googleusercontent.com
 *     remote_jwks:
 *       http_uri:
 *         uri: https://example.com/.well-known/jwks.json
 *         cluster: example_jwks_cluster
 *       cache_duration:
 *         seconds: 300
 *
 * [#next-free-field: 10]
 */
export interface JwtProvider {
  $type: "envoy.config.filter.http.jwt_authn.v2alpha.JwtProvider";
  /**
   * Specify the `principal <https://tools.ietf.org/html/rfc7519#section-4.1.1>`_ that issued
   * the JWT, usually a URL or an email address.
   *
   * Example: https://securetoken.google.com
   * Example: 1234567-compute@developer.gserviceaccount.com
   */
  issuer?:
    | string
    | undefined;
  /**
   * The list of JWT `audiences <https://tools.ietf.org/html/rfc7519#section-4.1.3>`_ are
   * allowed to access. A JWT containing any of these audiences will be accepted. If not specified,
   * will not check audiences in the token.
   *
   * Example:
   *
   * .. code-block:: yaml
   *
   *     audiences:
   *     - bookstore_android.apps.googleusercontent.com
   *     - bookstore_web.apps.googleusercontent.com
   */
  audiences?:
    | string[]
    | undefined;
  /**
   * `JSON Web Key Set (JWKS) <https://tools.ietf.org/html/rfc7517#appendix-A>`_ is needed to
   * validate signature of a JWT. This field specifies where to fetch JWKS.
   */
  jwks_source_specifier?:
    | //
    /**
     * JWKS can be fetched from remote server via HTTP/HTTPS. This field specifies the remote HTTP
     * URI and how the fetched JWKS should be cached.
     *
     * Example:
     *
     * .. code-block:: yaml
     *
     *    remote_jwks:
     *      http_uri:
     *        uri: https://www.googleapis.com/oauth2/v1/certs
     *        cluster: jwt.www.googleapis.com|443
     *      cache_duration:
     *        seconds: 300
     */
    { $case: "remote_jwks"; remote_jwks: RemoteJwks }
    | //
    /**
     * JWKS is in local data source. It could be either in a local file or embedded in the
     * inline_string.
     *
     * Example: local file
     *
     * .. code-block:: yaml
     *
     *    local_jwks:
     *      filename: /etc/envoy/jwks/jwks1.txt
     *
     * Example: inline_string
     *
     * .. code-block:: yaml
     *
     *    local_jwks:
     *      inline_string: ACADADADADA
     */
    { $case: "local_jwks"; local_jwks: DataSource }
    | undefined;
  /**
   * If false, the JWT is removed in the request after a success verification. If true, the JWT is
   * not removed in the request. Default value is false.
   */
  forward?:
    | boolean
    | undefined;
  /**
   * Two fields below define where to extract the JWT from an HTTP request.
   *
   * If no explicit location is specified, the following default locations are tried in order:
   *
   * 1. The Authorization header using the `Bearer schema
   * <https://tools.ietf.org/html/rfc6750#section-2.1>`_. Example::
   *
   *    Authorization: Bearer <token>.
   *
   * 2. `access_token <https://tools.ietf.org/html/rfc6750#section-2.3>`_ query parameter.
   *
   * Multiple JWTs can be verified for a request. Each JWT has to be extracted from the locations
   * its provider specified or from the default locations.
   *
   * Specify the HTTP headers to extract the JWT. For examples, following config:
   *
   * .. code-block:: yaml
   *
   *   from_headers:
   *   - name: x-goog-iap-jwt-assertion
   *
   * can be used to extract token from header::
   *
   *   ``x-goog-iap-jwt-assertion: <JWT>``.
   */
  from_headers?:
    | JwtHeader[]
    | undefined;
  /**
   * JWT is sent in a query parameter. `jwt_params` represents the query parameter names.
   *
   * For example, if config is:
   *
   * .. code-block:: yaml
   *
   *   from_params:
   *   - jwt_token
   *
   * The JWT format in query parameter is::
   *
   *    /path?jwt_token=<JWT>
   */
  from_params?:
    | string[]
    | undefined;
  /**
   * This field specifies the header name to forward a successfully verified JWT payload to the
   * backend. The forwarded data is::
   *
   *    base64url_encoded(jwt_payload_in_JSON)
   *
   * If it is not specified, the payload will not be forwarded.
   */
  forward_payload_header?:
    | string
    | undefined;
  /**
   * If non empty, successfully verified JWT payloads will be written to StreamInfo DynamicMetadata
   * in the format as: *namespace* is the jwt_authn filter name as **envoy.filters.http.jwt_authn**
   * The value is the *protobuf::Struct*. The value of this field will be the key for its *fields*
   * and the value is the *protobuf::Struct* converted from JWT JSON payload.
   *
   * For example, if payload_in_metadata is *my_payload*:
   *
   * .. code-block:: yaml
   *
   *   envoy.filters.http.jwt_authn:
   *     my_payload:
   *       iss: https://example.com
   *       sub: test@example.com
   *       aud: https://example.com
   *       exp: 1501281058
   */
  payload_in_metadata?: string | undefined;
}

/** This message specifies how to fetch JWKS from remote and how to cache it. */
export interface RemoteJwks {
  $type: "envoy.config.filter.http.jwt_authn.v2alpha.RemoteJwks";
  /**
   * The HTTP URI to fetch the JWKS. For example:
   *
   * .. code-block:: yaml
   *
   *    http_uri:
   *      uri: https://www.googleapis.com/oauth2/v1/certs
   *      cluster: jwt.www.googleapis.com|443
   */
  http_uri?:
    | HttpUri
    | undefined;
  /**
   * Duration after which the cached JWKS should be expired. If not specified, default cache
   * duration is 5 minutes.
   */
  cache_duration?: Duration | undefined;
}

/** This message specifies a header location to extract JWT. */
export interface JwtHeader {
  $type: "envoy.config.filter.http.jwt_authn.v2alpha.JwtHeader";
  /** The HTTP header name. */
  name?:
    | string
    | undefined;
  /**
   * The value prefix. The value format is "value_prefix<token>"
   * For example, for "Authorization: Bearer <token>", value_prefix="Bearer " with a space at the
   * end.
   */
  value_prefix?: string | undefined;
}

/** Specify a required provider with audiences. */
export interface ProviderWithAudiences {
  $type: "envoy.config.filter.http.jwt_authn.v2alpha.ProviderWithAudiences";
  /** Specify a required provider name. */
  provider_name?:
    | string
    | undefined;
  /** This field overrides the one specified in the JwtProvider. */
  audiences?: string[] | undefined;
}

/**
 * This message specifies a Jwt requirement. An empty message means JWT verification is not
 * required. Here are some config examples:
 *
 * .. code-block:: yaml
 *
 *  # Example 1: not required with an empty message
 *
 *  # Example 2: require A
 *  provider_name: provider-A
 *
 *  # Example 3: require A or B
 *  requires_any:
 *    requirements:
 *      - provider_name: provider-A
 *      - provider_name: provider-B
 *
 *  # Example 4: require A and B
 *  requires_all:
 *    requirements:
 *      - provider_name: provider-A
 *      - provider_name: provider-B
 *
 *  # Example 5: require A and (B or C)
 *  requires_all:
 *    requirements:
 *      - provider_name: provider-A
 *      - requires_any:
 *        requirements:
 *          - provider_name: provider-B
 *          - provider_name: provider-C
 *
 *  # Example 6: require A or (B and C)
 *  requires_any:
 *    requirements:
 *      - provider_name: provider-A
 *      - requires_all:
 *        requirements:
 *          - provider_name: provider-B
 *          - provider_name: provider-C
 *
 *  # Example 7: A is optional (if token from A is provided, it must be valid, but also allows
 *  missing token.)
 *  requires_any:
 *    requirements:
 *    - provider_name: provider-A
 *    - allow_missing: {}
 *
 *  # Example 8: A is optional and B is required.
 *  requires_all:
 *    requirements:
 *    - requires_any:
 *        requirements:
 *        - provider_name: provider-A
 *        - allow_missing: {}
 *    - provider_name: provider-B
 *
 * [#next-free-field: 7]
 */
export interface JwtRequirement {
  $type: "envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirement";
  requires_type?:
    | //
    /** Specify a required provider name. */
    { $case: "provider_name"; provider_name: string }
    | //
    /** Specify a required provider with audiences. */
    { $case: "provider_and_audiences"; provider_and_audiences: ProviderWithAudiences }
    | //
    /**
     * Specify list of JwtRequirement. Their results are OR-ed.
     * If any one of them passes, the result is passed.
     */
    { $case: "requires_any"; requires_any: JwtRequirementOrList }
    | //
    /**
     * Specify list of JwtRequirement. Their results are AND-ed.
     * All of them must pass, if one of them fails or missing, it fails.
     */
    { $case: "requires_all"; requires_all: JwtRequirementAndList }
    | //
    /**
     * The requirement is always satisfied even if JWT is missing or the JWT
     * verification fails. A typical usage is: this filter is used to only verify
     * JWTs and pass the verified JWT payloads to another filter, the other filter
     * will make decision. In this mode, all JWTs will be verified.
     */
    { $case: "allow_missing_or_failed"; allow_missing_or_failed: Empty }
    | //
    /**
     * The requirement is satisfied if JWT is missing, but failed if JWT is
     * presented but invalid. Similar to allow_missing_or_failed, this is used
     * to only verify JWTs and pass the verified payload to another filter. The
     * different is this mode will reject requests with invalid tokens.
     */
    { $case: "allow_missing"; allow_missing: Empty }
    | undefined;
}

/**
 * This message specifies a list of RequiredProvider.
 * Their results are OR-ed; if any one of them passes, the result is passed
 */
export interface JwtRequirementOrList {
  $type: "envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirementOrList";
  /** Specify a list of JwtRequirement. */
  requirements?: JwtRequirement[] | undefined;
}

/**
 * This message specifies a list of RequiredProvider.
 * Their results are AND-ed; all of them must pass, if one of them fails or missing, it fails.
 */
export interface JwtRequirementAndList {
  $type: "envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirementAndList";
  /** Specify a list of JwtRequirement. */
  requirements?: JwtRequirement[] | undefined;
}

/**
 * This message specifies a Jwt requirement for a specific Route condition.
 * Example 1:
 *
 * .. code-block:: yaml
 *
 *    - match:
 *        prefix: /healthz
 *
 * In above example, "requires" field is empty for /healthz prefix match,
 * it means that requests matching the path prefix don't require JWT authentication.
 *
 * Example 2:
 *
 * .. code-block:: yaml
 *
 *    - match:
 *        prefix: /
 *      requires: { provider_name: provider-A }
 *
 * In above example, all requests matched the path prefix require jwt authentication
 * from "provider-A".
 */
export interface RequirementRule {
  $type: "envoy.config.filter.http.jwt_authn.v2alpha.RequirementRule";
  /**
   * The route matching parameter. Only when the match is satisfied, the "requires" field will
   * apply.
   *
   * For example: following match will match all requests.
   *
   * .. code-block:: yaml
   *
   *    match:
   *      prefix: /
   */
  match?:
    | RouteMatch
    | undefined;
  /** Specify a Jwt Requirement. Please detail comment in message JwtRequirement. */
  requires?: JwtRequirement | undefined;
}

/**
 * This message specifies Jwt requirements based on stream_info.filterState.
 * This FilterState should use `Router::StringAccessor` object to set a string value.
 * Other HTTP filters can use it to specify Jwt requirements dynamically.
 *
 * Example:
 *
 * .. code-block:: yaml
 *
 *    name: jwt_selector
 *    requires:
 *      issuer_1:
 *        provider_name: issuer1
 *      issuer_2:
 *        provider_name: issuer2
 *
 * If a filter set "jwt_selector" with "issuer_1" to FilterState for a request,
 * jwt_authn filter will use JwtRequirement{"provider_name": "issuer1"} to verify.
 */
export interface FilterStateRule {
  $type: "envoy.config.filter.http.jwt_authn.v2alpha.FilterStateRule";
  /** The filter state name to retrieve the `Router::StringAccessor` object. */
  name?:
    | string
    | undefined;
  /**
   * A map of string keys to requirements. The string key is the string value
   * in the FilterState with the name specified in the *name* field above.
   */
  requires?: Map<string, JwtRequirement> | undefined;
}

export interface FilterStateRule_RequiresEntry {
  $type: "envoy.config.filter.http.jwt_authn.v2alpha.FilterStateRule.RequiresEntry";
  key: string;
  value?: JwtRequirement | undefined;
}

/**
 * This is the Envoy HTTP filter config for JWT authentication.
 *
 * For example:
 *
 * .. code-block:: yaml
 *
 *   providers:
 *      provider1:
 *        issuer: issuer1
 *        audiences:
 *        - audience1
 *        - audience2
 *        remote_jwks:
 *          http_uri:
 *            uri: https://example.com/.well-known/jwks.json
 *            cluster: example_jwks_cluster
 *      provider2:
 *        issuer: issuer2
 *        local_jwks:
 *          inline_string: jwks_string
 *
 *   rules:
 *      # Not jwt verification is required for /health path
 *      - match:
 *          prefix: /health
 *
 *      # Jwt verification for provider1 is required for path prefixed with "prefix"
 *      - match:
 *          prefix: /prefix
 *        requires:
 *          provider_name: provider1
 *
 *      # Jwt verification for either provider1 or provider2 is required for all other requests.
 *      - match:
 *          prefix: /
 *        requires:
 *          requires_any:
 *            requirements:
 *              - provider_name: provider1
 *              - provider_name: provider2
 */
export interface JwtAuthentication {
  $type: "envoy.config.filter.http.jwt_authn.v2alpha.JwtAuthentication";
  /**
   * Map of provider names to JwtProviders.
   *
   * .. code-block:: yaml
   *
   *   providers:
   *     provider1:
   *        issuer: issuer1
   *        audiences:
   *        - audience1
   *        - audience2
   *        remote_jwks:
   *          http_uri:
   *            uri: https://example.com/.well-known/jwks.json
   *            cluster: example_jwks_cluster
   *      provider2:
   *        issuer: provider2
   *        local_jwks:
   *          inline_string: jwks_string
   */
  providers?:
    | Map<string, JwtProvider>
    | undefined;
  /**
   * Specifies requirements based on the route matches. The first matched requirement will be
   * applied. If there are overlapped match conditions, please put the most specific match first.
   *
   * Examples
   *
   * .. code-block:: yaml
   *
   *   rules:
   *     - match:
   *         prefix: /healthz
   *     - match:
   *         prefix: /baz
   *       requires:
   *         provider_name: provider1
   *     - match:
   *         prefix: /foo
   *       requires:
   *         requires_any:
   *           requirements:
   *             - provider_name: provider1
   *             - provider_name: provider2
   *     - match:
   *         prefix: /bar
   *       requires:
   *         requires_all:
   *           requirements:
   *             - provider_name: provider1
   *             - provider_name: provider2
   */
  rules?:
    | RequirementRule[]
    | undefined;
  /**
   * This message specifies Jwt requirements based on stream_info.filterState.
   * Other HTTP filters can use it to specify Jwt requirements dynamically.
   * The *rules* field above is checked first, if it could not find any matches,
   * check this one.
   */
  filter_state_rules?:
    | FilterStateRule
    | undefined;
  /**
   * When set to true, bypass the `CORS preflight request
   * <http://www.w3.org/TR/cors/#cross-origin-request-with-preflight>`_ regardless of JWT
   * requirements specified in the rules.
   */
  bypass_cors_preflight?: boolean | undefined;
}

export interface JwtAuthentication_ProvidersEntry {
  $type: "envoy.config.filter.http.jwt_authn.v2alpha.JwtAuthentication.ProvidersEntry";
  key: string;
  value?: JwtProvider | undefined;
}

function createBaseJwtProvider(): JwtProvider {
  return { $type: "envoy.config.filter.http.jwt_authn.v2alpha.JwtProvider", jwks_source_specifier: undefined };
}

export const JwtProvider: MessageFns<JwtProvider, "envoy.config.filter.http.jwt_authn.v2alpha.JwtProvider"> = {
  $type: "envoy.config.filter.http.jwt_authn.v2alpha.JwtProvider" as const,

  encode(message: JwtProvider, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.issuer !== undefined && message.issuer !== "") {
      writer.uint32(10).string(message.issuer);
    }
    if (message.audiences !== undefined && message.audiences.length !== 0) {
      for (const v of message.audiences) {
        writer.uint32(18).string(v!);
      }
    }
    switch (message.jwks_source_specifier?.$case) {
      case "remote_jwks":
        RemoteJwks.encode(message.jwks_source_specifier.remote_jwks, writer.uint32(26).fork()).join();
        break;
      case "local_jwks":
        DataSource.encode(message.jwks_source_specifier.local_jwks, writer.uint32(34).fork()).join();
        break;
    }
    if (message.forward !== undefined && message.forward !== false) {
      writer.uint32(40).bool(message.forward);
    }
    if (message.from_headers !== undefined && message.from_headers.length !== 0) {
      for (const v of message.from_headers) {
        JwtHeader.encode(v!, writer.uint32(50).fork()).join();
      }
    }
    if (message.from_params !== undefined && message.from_params.length !== 0) {
      for (const v of message.from_params) {
        writer.uint32(58).string(v!);
      }
    }
    if (message.forward_payload_header !== undefined && message.forward_payload_header !== "") {
      writer.uint32(66).string(message.forward_payload_header);
    }
    if (message.payload_in_metadata !== undefined && message.payload_in_metadata !== "") {
      writer.uint32(74).string(message.payload_in_metadata);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JwtProvider {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJwtProvider();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.issuer = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.audiences === undefined) {
            message.audiences = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.audiences!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.jwks_source_specifier = {
            $case: "remote_jwks",
            remote_jwks: RemoteJwks.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.jwks_source_specifier = {
            $case: "local_jwks",
            local_jwks: DataSource.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.forward = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          if (message.from_headers === undefined) {
            message.from_headers = [];
          }
          const el = JwtHeader.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.from_headers!.push(el);
          }
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          if (message.from_params === undefined) {
            message.from_params = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.from_params!.push(el);
          }
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.forward_payload_header = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.payload_in_metadata = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JwtProvider {
    return {
      $type: JwtProvider.$type,
      issuer: isSet(object.issuer) ? globalThis.String(object.issuer) : undefined,
      audiences: globalThis.Array.isArray(object?.audiences)
        ? object.audiences.map((e: any) => globalThis.String(e))
        : undefined,
      jwks_source_specifier: isSet(object.remote_jwks)
        ? { $case: "remote_jwks", remote_jwks: RemoteJwks.fromJSON(object.remote_jwks) }
        : isSet(object.local_jwks)
        ? { $case: "local_jwks", local_jwks: DataSource.fromJSON(object.local_jwks) }
        : undefined,
      forward: isSet(object.forward) ? globalThis.Boolean(object.forward) : undefined,
      from_headers: globalThis.Array.isArray(object?.from_headers)
        ? object.from_headers.map((e: any) => JwtHeader.fromJSON(e))
        : undefined,
      from_params: globalThis.Array.isArray(object?.from_params)
        ? object.from_params.map((e: any) => globalThis.String(e))
        : undefined,
      forward_payload_header: isSet(object.forward_payload_header)
        ? globalThis.String(object.forward_payload_header)
        : undefined,
      payload_in_metadata: isSet(object.payload_in_metadata)
        ? globalThis.String(object.payload_in_metadata)
        : undefined,
    };
  },

  toJSON(message: JwtProvider): unknown {
    const obj: any = {};
    if (message.issuer !== undefined) {
      obj.issuer = message.issuer;
    }
    if (message.audiences?.length) {
      obj.audiences = message.audiences;
    }
    if (message.jwks_source_specifier?.$case === "remote_jwks") {
      obj.remote_jwks = RemoteJwks.toJSON(message.jwks_source_specifier.remote_jwks);
    }
    if (message.jwks_source_specifier?.$case === "local_jwks") {
      obj.local_jwks = DataSource.toJSON(message.jwks_source_specifier.local_jwks);
    }
    if (message.forward !== undefined) {
      obj.forward = message.forward;
    }
    if (message.from_headers?.length) {
      obj.from_headers = message.from_headers.map((e) => JwtHeader.toJSON(e));
    }
    if (message.from_params?.length) {
      obj.from_params = message.from_params;
    }
    if (message.forward_payload_header !== undefined) {
      obj.forward_payload_header = message.forward_payload_header;
    }
    if (message.payload_in_metadata !== undefined) {
      obj.payload_in_metadata = message.payload_in_metadata;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JwtProvider>, I>>(base?: I): JwtProvider {
    return JwtProvider.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JwtProvider>, I>>(object: I): JwtProvider {
    const message = createBaseJwtProvider();
    message.issuer = object.issuer ?? undefined;
    message.audiences = object.audiences?.map((e) => e) || undefined;
    if (
      object.jwks_source_specifier?.$case === "remote_jwks" &&
      object.jwks_source_specifier?.remote_jwks !== undefined &&
      object.jwks_source_specifier?.remote_jwks !== null
    ) {
      message.jwks_source_specifier = {
        $case: "remote_jwks",
        remote_jwks: RemoteJwks.fromPartial(object.jwks_source_specifier.remote_jwks),
      };
    }
    if (
      object.jwks_source_specifier?.$case === "local_jwks" &&
      object.jwks_source_specifier?.local_jwks !== undefined &&
      object.jwks_source_specifier?.local_jwks !== null
    ) {
      message.jwks_source_specifier = {
        $case: "local_jwks",
        local_jwks: DataSource.fromPartial(object.jwks_source_specifier.local_jwks),
      };
    }
    message.forward = object.forward ?? undefined;
    message.from_headers = object.from_headers?.map((e) => JwtHeader.fromPartial(e)) || undefined;
    message.from_params = object.from_params?.map((e) => e) || undefined;
    message.forward_payload_header = object.forward_payload_header ?? undefined;
    message.payload_in_metadata = object.payload_in_metadata ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(JwtProvider.$type, JwtProvider);

function createBaseRemoteJwks(): RemoteJwks {
  return { $type: "envoy.config.filter.http.jwt_authn.v2alpha.RemoteJwks" };
}

export const RemoteJwks: MessageFns<RemoteJwks, "envoy.config.filter.http.jwt_authn.v2alpha.RemoteJwks"> = {
  $type: "envoy.config.filter.http.jwt_authn.v2alpha.RemoteJwks" as const,

  encode(message: RemoteJwks, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.http_uri !== undefined) {
      HttpUri.encode(message.http_uri, writer.uint32(10).fork()).join();
    }
    if (message.cache_duration !== undefined) {
      Duration.encode(message.cache_duration, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoteJwks {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoteJwks();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.http_uri = HttpUri.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cache_duration = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoteJwks {
    return {
      $type: RemoteJwks.$type,
      http_uri: isSet(object.http_uri) ? HttpUri.fromJSON(object.http_uri) : undefined,
      cache_duration: isSet(object.cache_duration) ? Duration.fromJSON(object.cache_duration) : undefined,
    };
  },

  toJSON(message: RemoteJwks): unknown {
    const obj: any = {};
    if (message.http_uri !== undefined) {
      obj.http_uri = HttpUri.toJSON(message.http_uri);
    }
    if (message.cache_duration !== undefined) {
      obj.cache_duration = Duration.toJSON(message.cache_duration);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoteJwks>, I>>(base?: I): RemoteJwks {
    return RemoteJwks.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoteJwks>, I>>(object: I): RemoteJwks {
    const message = createBaseRemoteJwks();
    message.http_uri = (object.http_uri !== undefined && object.http_uri !== null)
      ? HttpUri.fromPartial(object.http_uri)
      : undefined;
    message.cache_duration = (object.cache_duration !== undefined && object.cache_duration !== null)
      ? Duration.fromPartial(object.cache_duration)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(RemoteJwks.$type, RemoteJwks);

function createBaseJwtHeader(): JwtHeader {
  return { $type: "envoy.config.filter.http.jwt_authn.v2alpha.JwtHeader" };
}

export const JwtHeader: MessageFns<JwtHeader, "envoy.config.filter.http.jwt_authn.v2alpha.JwtHeader"> = {
  $type: "envoy.config.filter.http.jwt_authn.v2alpha.JwtHeader" as const,

  encode(message: JwtHeader, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value_prefix !== undefined && message.value_prefix !== "") {
      writer.uint32(18).string(message.value_prefix);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JwtHeader {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJwtHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value_prefix = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JwtHeader {
    return {
      $type: JwtHeader.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      value_prefix: isSet(object.value_prefix) ? globalThis.String(object.value_prefix) : undefined,
    };
  },

  toJSON(message: JwtHeader): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.value_prefix !== undefined) {
      obj.value_prefix = message.value_prefix;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JwtHeader>, I>>(base?: I): JwtHeader {
    return JwtHeader.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JwtHeader>, I>>(object: I): JwtHeader {
    const message = createBaseJwtHeader();
    message.name = object.name ?? undefined;
    message.value_prefix = object.value_prefix ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(JwtHeader.$type, JwtHeader);

function createBaseProviderWithAudiences(): ProviderWithAudiences {
  return { $type: "envoy.config.filter.http.jwt_authn.v2alpha.ProviderWithAudiences" };
}

export const ProviderWithAudiences: MessageFns<
  ProviderWithAudiences,
  "envoy.config.filter.http.jwt_authn.v2alpha.ProviderWithAudiences"
> = {
  $type: "envoy.config.filter.http.jwt_authn.v2alpha.ProviderWithAudiences" as const,

  encode(message: ProviderWithAudiences, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provider_name !== undefined && message.provider_name !== "") {
      writer.uint32(10).string(message.provider_name);
    }
    if (message.audiences !== undefined && message.audiences.length !== 0) {
      for (const v of message.audiences) {
        writer.uint32(18).string(v!);
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProviderWithAudiences {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProviderWithAudiences();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.provider_name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.audiences === undefined) {
            message.audiences = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.audiences!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProviderWithAudiences {
    return {
      $type: ProviderWithAudiences.$type,
      provider_name: isSet(object.provider_name) ? globalThis.String(object.provider_name) : undefined,
      audiences: globalThis.Array.isArray(object?.audiences)
        ? object.audiences.map((e: any) => globalThis.String(e))
        : undefined,
    };
  },

  toJSON(message: ProviderWithAudiences): unknown {
    const obj: any = {};
    if (message.provider_name !== undefined) {
      obj.provider_name = message.provider_name;
    }
    if (message.audiences?.length) {
      obj.audiences = message.audiences;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProviderWithAudiences>, I>>(base?: I): ProviderWithAudiences {
    return ProviderWithAudiences.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProviderWithAudiences>, I>>(object: I): ProviderWithAudiences {
    const message = createBaseProviderWithAudiences();
    message.provider_name = object.provider_name ?? undefined;
    message.audiences = object.audiences?.map((e) => e) || undefined;
    return message;
  },
};

messageTypeRegistry.set(ProviderWithAudiences.$type, ProviderWithAudiences);

function createBaseJwtRequirement(): JwtRequirement {
  return { $type: "envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirement", requires_type: undefined };
}

export const JwtRequirement: MessageFns<JwtRequirement, "envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirement"> = {
  $type: "envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirement" as const,

  encode(message: JwtRequirement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.requires_type?.$case) {
      case "provider_name":
        writer.uint32(10).string(message.requires_type.provider_name);
        break;
      case "provider_and_audiences":
        ProviderWithAudiences.encode(message.requires_type.provider_and_audiences, writer.uint32(18).fork()).join();
        break;
      case "requires_any":
        JwtRequirementOrList.encode(message.requires_type.requires_any, writer.uint32(26).fork()).join();
        break;
      case "requires_all":
        JwtRequirementAndList.encode(message.requires_type.requires_all, writer.uint32(34).fork()).join();
        break;
      case "allow_missing_or_failed":
        Empty.encode(message.requires_type.allow_missing_or_failed, writer.uint32(42).fork()).join();
        break;
      case "allow_missing":
        Empty.encode(message.requires_type.allow_missing, writer.uint32(50).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JwtRequirement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJwtRequirement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requires_type = { $case: "provider_name", provider_name: reader.string() };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.requires_type = {
            $case: "provider_and_audiences",
            provider_and_audiences: ProviderWithAudiences.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.requires_type = {
            $case: "requires_any",
            requires_any: JwtRequirementOrList.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.requires_type = {
            $case: "requires_all",
            requires_all: JwtRequirementAndList.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.requires_type = {
            $case: "allow_missing_or_failed",
            allow_missing_or_failed: Empty.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.requires_type = { $case: "allow_missing", allow_missing: Empty.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JwtRequirement {
    return {
      $type: JwtRequirement.$type,
      requires_type: isSet(object.provider_name)
        ? { $case: "provider_name", provider_name: globalThis.String(object.provider_name) }
        : isSet(object.provider_and_audiences)
        ? {
          $case: "provider_and_audiences",
          provider_and_audiences: ProviderWithAudiences.fromJSON(object.provider_and_audiences),
        }
        : isSet(object.requires_any)
        ? { $case: "requires_any", requires_any: JwtRequirementOrList.fromJSON(object.requires_any) }
        : isSet(object.requires_all)
        ? { $case: "requires_all", requires_all: JwtRequirementAndList.fromJSON(object.requires_all) }
        : isSet(object.allow_missing_or_failed)
        ? { $case: "allow_missing_or_failed", allow_missing_or_failed: Empty.fromJSON(object.allow_missing_or_failed) }
        : isSet(object.allow_missing)
        ? { $case: "allow_missing", allow_missing: Empty.fromJSON(object.allow_missing) }
        : undefined,
    };
  },

  toJSON(message: JwtRequirement): unknown {
    const obj: any = {};
    if (message.requires_type?.$case === "provider_name") {
      obj.provider_name = message.requires_type.provider_name;
    }
    if (message.requires_type?.$case === "provider_and_audiences") {
      obj.provider_and_audiences = ProviderWithAudiences.toJSON(message.requires_type.provider_and_audiences);
    }
    if (message.requires_type?.$case === "requires_any") {
      obj.requires_any = JwtRequirementOrList.toJSON(message.requires_type.requires_any);
    }
    if (message.requires_type?.$case === "requires_all") {
      obj.requires_all = JwtRequirementAndList.toJSON(message.requires_type.requires_all);
    }
    if (message.requires_type?.$case === "allow_missing_or_failed") {
      obj.allow_missing_or_failed = Empty.toJSON(message.requires_type.allow_missing_or_failed);
    }
    if (message.requires_type?.$case === "allow_missing") {
      obj.allow_missing = Empty.toJSON(message.requires_type.allow_missing);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JwtRequirement>, I>>(base?: I): JwtRequirement {
    return JwtRequirement.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JwtRequirement>, I>>(object: I): JwtRequirement {
    const message = createBaseJwtRequirement();
    if (
      object.requires_type?.$case === "provider_name" &&
      object.requires_type?.provider_name !== undefined &&
      object.requires_type?.provider_name !== null
    ) {
      message.requires_type = { $case: "provider_name", provider_name: object.requires_type.provider_name };
    }
    if (
      object.requires_type?.$case === "provider_and_audiences" &&
      object.requires_type?.provider_and_audiences !== undefined &&
      object.requires_type?.provider_and_audiences !== null
    ) {
      message.requires_type = {
        $case: "provider_and_audiences",
        provider_and_audiences: ProviderWithAudiences.fromPartial(object.requires_type.provider_and_audiences),
      };
    }
    if (
      object.requires_type?.$case === "requires_any" &&
      object.requires_type?.requires_any !== undefined &&
      object.requires_type?.requires_any !== null
    ) {
      message.requires_type = {
        $case: "requires_any",
        requires_any: JwtRequirementOrList.fromPartial(object.requires_type.requires_any),
      };
    }
    if (
      object.requires_type?.$case === "requires_all" &&
      object.requires_type?.requires_all !== undefined &&
      object.requires_type?.requires_all !== null
    ) {
      message.requires_type = {
        $case: "requires_all",
        requires_all: JwtRequirementAndList.fromPartial(object.requires_type.requires_all),
      };
    }
    if (
      object.requires_type?.$case === "allow_missing_or_failed" &&
      object.requires_type?.allow_missing_or_failed !== undefined &&
      object.requires_type?.allow_missing_or_failed !== null
    ) {
      message.requires_type = {
        $case: "allow_missing_or_failed",
        allow_missing_or_failed: Empty.fromPartial(object.requires_type.allow_missing_or_failed),
      };
    }
    if (
      object.requires_type?.$case === "allow_missing" &&
      object.requires_type?.allow_missing !== undefined &&
      object.requires_type?.allow_missing !== null
    ) {
      message.requires_type = {
        $case: "allow_missing",
        allow_missing: Empty.fromPartial(object.requires_type.allow_missing),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(JwtRequirement.$type, JwtRequirement);

function createBaseJwtRequirementOrList(): JwtRequirementOrList {
  return { $type: "envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirementOrList" };
}

export const JwtRequirementOrList: MessageFns<
  JwtRequirementOrList,
  "envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirementOrList"
> = {
  $type: "envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirementOrList" as const,

  encode(message: JwtRequirementOrList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requirements !== undefined && message.requirements.length !== 0) {
      for (const v of message.requirements) {
        JwtRequirement.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JwtRequirementOrList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJwtRequirementOrList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.requirements === undefined) {
            message.requirements = [];
          }
          const el = JwtRequirement.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.requirements!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JwtRequirementOrList {
    return {
      $type: JwtRequirementOrList.$type,
      requirements: globalThis.Array.isArray(object?.requirements)
        ? object.requirements.map((e: any) => JwtRequirement.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: JwtRequirementOrList): unknown {
    const obj: any = {};
    if (message.requirements?.length) {
      obj.requirements = message.requirements.map((e) => JwtRequirement.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JwtRequirementOrList>, I>>(base?: I): JwtRequirementOrList {
    return JwtRequirementOrList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JwtRequirementOrList>, I>>(object: I): JwtRequirementOrList {
    const message = createBaseJwtRequirementOrList();
    message.requirements = object.requirements?.map((e) => JwtRequirement.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(JwtRequirementOrList.$type, JwtRequirementOrList);

function createBaseJwtRequirementAndList(): JwtRequirementAndList {
  return { $type: "envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirementAndList" };
}

export const JwtRequirementAndList: MessageFns<
  JwtRequirementAndList,
  "envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirementAndList"
> = {
  $type: "envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirementAndList" as const,

  encode(message: JwtRequirementAndList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requirements !== undefined && message.requirements.length !== 0) {
      for (const v of message.requirements) {
        JwtRequirement.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JwtRequirementAndList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJwtRequirementAndList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.requirements === undefined) {
            message.requirements = [];
          }
          const el = JwtRequirement.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.requirements!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JwtRequirementAndList {
    return {
      $type: JwtRequirementAndList.$type,
      requirements: globalThis.Array.isArray(object?.requirements)
        ? object.requirements.map((e: any) => JwtRequirement.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: JwtRequirementAndList): unknown {
    const obj: any = {};
    if (message.requirements?.length) {
      obj.requirements = message.requirements.map((e) => JwtRequirement.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JwtRequirementAndList>, I>>(base?: I): JwtRequirementAndList {
    return JwtRequirementAndList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JwtRequirementAndList>, I>>(object: I): JwtRequirementAndList {
    const message = createBaseJwtRequirementAndList();
    message.requirements = object.requirements?.map((e) => JwtRequirement.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(JwtRequirementAndList.$type, JwtRequirementAndList);

function createBaseRequirementRule(): RequirementRule {
  return { $type: "envoy.config.filter.http.jwt_authn.v2alpha.RequirementRule" };
}

export const RequirementRule: MessageFns<
  RequirementRule,
  "envoy.config.filter.http.jwt_authn.v2alpha.RequirementRule"
> = {
  $type: "envoy.config.filter.http.jwt_authn.v2alpha.RequirementRule" as const,

  encode(message: RequirementRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.match !== undefined) {
      RouteMatch.encode(message.match, writer.uint32(10).fork()).join();
    }
    if (message.requires !== undefined) {
      JwtRequirement.encode(message.requires, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequirementRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequirementRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.match = RouteMatch.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.requires = JwtRequirement.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequirementRule {
    return {
      $type: RequirementRule.$type,
      match: isSet(object.match) ? RouteMatch.fromJSON(object.match) : undefined,
      requires: isSet(object.requires) ? JwtRequirement.fromJSON(object.requires) : undefined,
    };
  },

  toJSON(message: RequirementRule): unknown {
    const obj: any = {};
    if (message.match !== undefined) {
      obj.match = RouteMatch.toJSON(message.match);
    }
    if (message.requires !== undefined) {
      obj.requires = JwtRequirement.toJSON(message.requires);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequirementRule>, I>>(base?: I): RequirementRule {
    return RequirementRule.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequirementRule>, I>>(object: I): RequirementRule {
    const message = createBaseRequirementRule();
    message.match = (object.match !== undefined && object.match !== null)
      ? RouteMatch.fromPartial(object.match)
      : undefined;
    message.requires = (object.requires !== undefined && object.requires !== null)
      ? JwtRequirement.fromPartial(object.requires)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(RequirementRule.$type, RequirementRule);

function createBaseFilterStateRule(): FilterStateRule {
  return { $type: "envoy.config.filter.http.jwt_authn.v2alpha.FilterStateRule" };
}

export const FilterStateRule: MessageFns<
  FilterStateRule,
  "envoy.config.filter.http.jwt_authn.v2alpha.FilterStateRule"
> = {
  $type: "envoy.config.filter.http.jwt_authn.v2alpha.FilterStateRule" as const,

  encode(message: FilterStateRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    (message.requires || new Map()).forEach((value, key) => {
      FilterStateRule_RequiresEntry.encode({
        $type: "envoy.config.filter.http.jwt_authn.v2alpha.FilterStateRule.RequiresEntry",
        key: key as any,
        value,
      }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FilterStateRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilterStateRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = FilterStateRule_RequiresEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            if (message.requires === undefined) {
              message.requires = new Map();
            }
            message.requires!.set(entry3.key, entry3.value);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FilterStateRule {
    return {
      $type: FilterStateRule.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      requires: isObject(object.requires)
        ? Object.entries(object.requires).reduce<Map<string, JwtRequirement>>((acc, [key, value]) => {
          acc.set(key, JwtRequirement.fromJSON(value));
          return acc;
        }, new Map())
        : undefined,
    };
  },

  toJSON(message: FilterStateRule): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.requires?.size) {
      obj.requires = {};
      message.requires.forEach((v, k) => {
        obj.requires[k] = JwtRequirement.toJSON(v);
      });
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FilterStateRule>, I>>(base?: I): FilterStateRule {
    return FilterStateRule.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FilterStateRule>, I>>(object: I): FilterStateRule {
    const message = createBaseFilterStateRule();
    message.name = object.name ?? undefined;
    message.requires = (object.requires === undefined || object.requires === null) ? undefined : (() => {
      const m = new Map();
      (object.requires as Map<string, JwtRequirement> ?? new Map()).forEach((value, key) => {
        if (value !== undefined) {
          m.set(key, JwtRequirement.fromPartial(value));
        }
      });
      return m;
    })();
    return message;
  },
};

messageTypeRegistry.set(FilterStateRule.$type, FilterStateRule);

function createBaseFilterStateRule_RequiresEntry(): FilterStateRule_RequiresEntry {
  return { $type: "envoy.config.filter.http.jwt_authn.v2alpha.FilterStateRule.RequiresEntry", key: "" };
}

export const FilterStateRule_RequiresEntry: MessageFns<
  FilterStateRule_RequiresEntry,
  "envoy.config.filter.http.jwt_authn.v2alpha.FilterStateRule.RequiresEntry"
> = {
  $type: "envoy.config.filter.http.jwt_authn.v2alpha.FilterStateRule.RequiresEntry" as const,

  encode(message: FilterStateRule_RequiresEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      JwtRequirement.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FilterStateRule_RequiresEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilterStateRule_RequiresEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = JwtRequirement.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FilterStateRule_RequiresEntry {
    return {
      $type: FilterStateRule_RequiresEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? JwtRequirement.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: FilterStateRule_RequiresEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = JwtRequirement.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FilterStateRule_RequiresEntry>, I>>(base?: I): FilterStateRule_RequiresEntry {
    return FilterStateRule_RequiresEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FilterStateRule_RequiresEntry>, I>>(
    object: I,
  ): FilterStateRule_RequiresEntry {
    const message = createBaseFilterStateRule_RequiresEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? JwtRequirement.fromPartial(object.value)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(FilterStateRule_RequiresEntry.$type, FilterStateRule_RequiresEntry);

function createBaseJwtAuthentication(): JwtAuthentication {
  return { $type: "envoy.config.filter.http.jwt_authn.v2alpha.JwtAuthentication" };
}

export const JwtAuthentication: MessageFns<
  JwtAuthentication,
  "envoy.config.filter.http.jwt_authn.v2alpha.JwtAuthentication"
> = {
  $type: "envoy.config.filter.http.jwt_authn.v2alpha.JwtAuthentication" as const,

  encode(message: JwtAuthentication, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    (message.providers || new Map()).forEach((value, key) => {
      JwtAuthentication_ProvidersEntry.encode({
        $type: "envoy.config.filter.http.jwt_authn.v2alpha.JwtAuthentication.ProvidersEntry",
        key: key as any,
        value,
      }, writer.uint32(10).fork()).join();
    });
    if (message.rules !== undefined && message.rules.length !== 0) {
      for (const v of message.rules) {
        RequirementRule.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.filter_state_rules !== undefined) {
      FilterStateRule.encode(message.filter_state_rules, writer.uint32(26).fork()).join();
    }
    if (message.bypass_cors_preflight !== undefined && message.bypass_cors_preflight !== false) {
      writer.uint32(32).bool(message.bypass_cors_preflight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JwtAuthentication {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJwtAuthentication();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = JwtAuthentication_ProvidersEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            if (message.providers === undefined) {
              message.providers = new Map();
            }
            message.providers!.set(entry1.key, entry1.value);
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.rules === undefined) {
            message.rules = [];
          }
          const el = RequirementRule.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.rules!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.filter_state_rules = FilterStateRule.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.bypass_cors_preflight = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JwtAuthentication {
    return {
      $type: JwtAuthentication.$type,
      providers: isObject(object.providers)
        ? Object.entries(object.providers).reduce<Map<string, JwtProvider>>((acc, [key, value]) => {
          acc.set(key, JwtProvider.fromJSON(value));
          return acc;
        }, new Map())
        : undefined,
      rules: globalThis.Array.isArray(object?.rules)
        ? object.rules.map((e: any) => RequirementRule.fromJSON(e))
        : undefined,
      filter_state_rules: isSet(object.filter_state_rules)
        ? FilterStateRule.fromJSON(object.filter_state_rules)
        : undefined,
      bypass_cors_preflight: isSet(object.bypass_cors_preflight)
        ? globalThis.Boolean(object.bypass_cors_preflight)
        : undefined,
    };
  },

  toJSON(message: JwtAuthentication): unknown {
    const obj: any = {};
    if (message.providers?.size) {
      obj.providers = {};
      message.providers.forEach((v, k) => {
        obj.providers[k] = JwtProvider.toJSON(v);
      });
    }
    if (message.rules?.length) {
      obj.rules = message.rules.map((e) => RequirementRule.toJSON(e));
    }
    if (message.filter_state_rules !== undefined) {
      obj.filter_state_rules = FilterStateRule.toJSON(message.filter_state_rules);
    }
    if (message.bypass_cors_preflight !== undefined) {
      obj.bypass_cors_preflight = message.bypass_cors_preflight;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JwtAuthentication>, I>>(base?: I): JwtAuthentication {
    return JwtAuthentication.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JwtAuthentication>, I>>(object: I): JwtAuthentication {
    const message = createBaseJwtAuthentication();
    message.providers = (object.providers === undefined || object.providers === null) ? undefined : (() => {
      const m = new Map();
      (object.providers as Map<string, JwtProvider> ?? new Map()).forEach((value, key) => {
        if (value !== undefined) {
          m.set(key, JwtProvider.fromPartial(value));
        }
      });
      return m;
    })();
    message.rules = object.rules?.map((e) => RequirementRule.fromPartial(e)) || undefined;
    message.filter_state_rules = (object.filter_state_rules !== undefined && object.filter_state_rules !== null)
      ? FilterStateRule.fromPartial(object.filter_state_rules)
      : undefined;
    message.bypass_cors_preflight = object.bypass_cors_preflight ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(JwtAuthentication.$type, JwtAuthentication);

function createBaseJwtAuthentication_ProvidersEntry(): JwtAuthentication_ProvidersEntry {
  return { $type: "envoy.config.filter.http.jwt_authn.v2alpha.JwtAuthentication.ProvidersEntry", key: "" };
}

export const JwtAuthentication_ProvidersEntry: MessageFns<
  JwtAuthentication_ProvidersEntry,
  "envoy.config.filter.http.jwt_authn.v2alpha.JwtAuthentication.ProvidersEntry"
> = {
  $type: "envoy.config.filter.http.jwt_authn.v2alpha.JwtAuthentication.ProvidersEntry" as const,

  encode(message: JwtAuthentication_ProvidersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      JwtProvider.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JwtAuthentication_ProvidersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJwtAuthentication_ProvidersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = JwtProvider.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JwtAuthentication_ProvidersEntry {
    return {
      $type: JwtAuthentication_ProvidersEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? JwtProvider.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: JwtAuthentication_ProvidersEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = JwtProvider.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JwtAuthentication_ProvidersEntry>, I>>(
    base?: I,
  ): JwtAuthentication_ProvidersEntry {
    return JwtAuthentication_ProvidersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JwtAuthentication_ProvidersEntry>, I>>(
    object: I,
  ): JwtAuthentication_ProvidersEntry {
    const message = createBaseJwtAuthentication_ProvidersEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? JwtProvider.fromPartial(object.value)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(JwtAuthentication_ProvidersEntry.$type, JwtAuthentication_ProvidersEntry);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
