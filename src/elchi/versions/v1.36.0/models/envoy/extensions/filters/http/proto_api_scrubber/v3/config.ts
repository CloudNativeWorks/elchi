// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/filters/http/proto_api_scrubber/v3/config.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { messageTypeRegistry } from "../../../../../../typeRegistry";
import { Matcher } from "../../../../../../xds/type/matcher/v3/matcher";
import { DataSource } from "../../../../../config/core/v3/base";

export const protobufPackage = "envoy.extensions.filters.http.proto_api_scrubber.v3";

export interface ProtoApiScrubberConfig {
  $type: "envoy.extensions.filters.http.proto_api_scrubber.v3.ProtoApiScrubberConfig";
  /** The proto descriptor set for the proto services. */
  descriptor_set?:
    | DescriptorSet
    | undefined;
  /** Contains the restrictions for the supported proto elements. */
  restrictions?:
    | Restrictions
    | undefined;
  /** Specifies the filtering mode of this filter. */
  filtering_mode?: ProtoApiScrubberConfig_FilteringMode | undefined;
}

/** An enum enlisting all the filtering modes supported by this filter. */
export enum ProtoApiScrubberConfig_FilteringMode {
  /**
   * OVERRIDE - Override the original request/response body with the filtered
   * request/response body.
   */
  OVERRIDE = "OVERRIDE",
}

export function protoApiScrubberConfig_FilteringModeFromJSON(object: any): ProtoApiScrubberConfig_FilteringMode {
  switch (object) {
    case 0:
    case "OVERRIDE":
      return ProtoApiScrubberConfig_FilteringMode.OVERRIDE;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum ProtoApiScrubberConfig_FilteringMode",
      );
  }
}

export function protoApiScrubberConfig_FilteringModeToJSON(object: ProtoApiScrubberConfig_FilteringMode): string {
  switch (object) {
    case ProtoApiScrubberConfig_FilteringMode.OVERRIDE:
      return "OVERRIDE";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum ProtoApiScrubberConfig_FilteringMode",
      );
  }
}

export function protoApiScrubberConfig_FilteringModeToNumber(object: ProtoApiScrubberConfig_FilteringMode): number {
  switch (object) {
    case ProtoApiScrubberConfig_FilteringMode.OVERRIDE:
      return 0;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum ProtoApiScrubberConfig_FilteringMode",
      );
  }
}

/** Specifies the descriptor set for proto services. */
export interface DescriptorSet {
  $type: "envoy.extensions.filters.http.proto_api_scrubber.v3.DescriptorSet";
  /**
   * It could be passed by a local file through ``Datasource.filename`` or
   * embedded in the ``Datasource.inline_bytes``.
   */
  data_source?: DataSource | undefined;
}

/** Contains the restrictions for the methods. */
export interface Restrictions {
  $type: "envoy.extensions.filters.http.proto_api_scrubber.v3.Restrictions";
  /**
   * Specifies the method restrictions.
   * Key - Fully qualified method name e.g., ``endpoints.examples.bookstore.BookStore/GetShelf``.
   * Value - Method restrictions.
   */
  method_restrictions?: Map<string, MethodRestrictions> | undefined;
}

export interface Restrictions_MethodRestrictionsEntry {
  $type: "envoy.extensions.filters.http.proto_api_scrubber.v3.Restrictions.MethodRestrictionsEntry";
  key: string;
  value?: MethodRestrictions | undefined;
}

/**
 * Contains the method restrictions which include the field level restrictions
 * for the request and response fields.
 */
export interface MethodRestrictions {
  $type: "envoy.extensions.filters.http.proto_api_scrubber.v3.MethodRestrictions";
  /**
   * Restrictions that apply to request fields of the method.
   * Key - field mask like path of the field eg, foo.bar.baz
   * Value - Restrictions map containing the mapping from restriction name to
   * the restriction values.
   */
  request_field_restrictions?:
    | Map<string, RestrictionConfig>
    | undefined;
  /**
   * Restrictions that apply to response fields of the method.
   * Key - field mask like path of the field eg, foo.bar.baz
   * Value - Restrictions map containing the mapping from restriction name to
   * the restriction values.
   */
  response_field_restrictions?: Map<string, RestrictionConfig> | undefined;
}

export interface MethodRestrictions_RequestFieldRestrictionsEntry {
  $type: "envoy.extensions.filters.http.proto_api_scrubber.v3.MethodRestrictions.RequestFieldRestrictionsEntry";
  key: string;
  value?: RestrictionConfig | undefined;
}

export interface MethodRestrictions_ResponseFieldRestrictionsEntry {
  $type: "envoy.extensions.filters.http.proto_api_scrubber.v3.MethodRestrictions.ResponseFieldRestrictionsEntry";
  key: string;
  value?: RestrictionConfig | undefined;
}

/** The restriction configuration. */
export interface RestrictionConfig {
  $type: "envoy.extensions.filters.http.proto_api_scrubber.v3.RestrictionConfig";
  /**
   * Matcher tree for matching requests and responses with the configured restrictions.
   * NOTE: Currently, only CEL expressions are supported for matching. Support for more
   * matchers will be added incrementally overtime.
   */
  matcher?: Matcher | undefined;
}

function createBaseProtoApiScrubberConfig(): ProtoApiScrubberConfig {
  return { $type: "envoy.extensions.filters.http.proto_api_scrubber.v3.ProtoApiScrubberConfig" };
}

export const ProtoApiScrubberConfig: MessageFns<
  ProtoApiScrubberConfig,
  "envoy.extensions.filters.http.proto_api_scrubber.v3.ProtoApiScrubberConfig"
> = {
  $type: "envoy.extensions.filters.http.proto_api_scrubber.v3.ProtoApiScrubberConfig" as const,

  encode(message: ProtoApiScrubberConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.descriptor_set !== undefined) {
      DescriptorSet.encode(message.descriptor_set, writer.uint32(10).fork()).join();
    }
    if (message.restrictions !== undefined) {
      Restrictions.encode(message.restrictions, writer.uint32(18).fork()).join();
    }
    if (
      message.filtering_mode !== undefined && message.filtering_mode !== ProtoApiScrubberConfig_FilteringMode.OVERRIDE
    ) {
      writer.uint32(24).int32(protoApiScrubberConfig_FilteringModeToNumber(message.filtering_mode));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoApiScrubberConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoApiScrubberConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.descriptor_set = DescriptorSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.restrictions = Restrictions.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.filtering_mode = protoApiScrubberConfig_FilteringModeFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoApiScrubberConfig {
    return {
      $type: ProtoApiScrubberConfig.$type,
      descriptor_set: isSet(object.descriptor_set) ? DescriptorSet.fromJSON(object.descriptor_set) : undefined,
      restrictions: isSet(object.restrictions) ? Restrictions.fromJSON(object.restrictions) : undefined,
      filtering_mode: isSet(object.filtering_mode)
        ? protoApiScrubberConfig_FilteringModeFromJSON(object.filtering_mode)
        : undefined,
    };
  },

  toJSON(message: ProtoApiScrubberConfig): unknown {
    const obj: any = {};
    if (message.descriptor_set !== undefined) {
      obj.descriptor_set = DescriptorSet.toJSON(message.descriptor_set);
    }
    if (message.restrictions !== undefined) {
      obj.restrictions = Restrictions.toJSON(message.restrictions);
    }
    if (message.filtering_mode !== undefined) {
      obj.filtering_mode = protoApiScrubberConfig_FilteringModeToJSON(message.filtering_mode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoApiScrubberConfig>, I>>(base?: I): ProtoApiScrubberConfig {
    return ProtoApiScrubberConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoApiScrubberConfig>, I>>(object: I): ProtoApiScrubberConfig {
    const message = createBaseProtoApiScrubberConfig();
    message.descriptor_set = (object.descriptor_set !== undefined && object.descriptor_set !== null)
      ? DescriptorSet.fromPartial(object.descriptor_set)
      : undefined;
    message.restrictions = (object.restrictions !== undefined && object.restrictions !== null)
      ? Restrictions.fromPartial(object.restrictions)
      : undefined;
    message.filtering_mode = object.filtering_mode ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ProtoApiScrubberConfig.$type, ProtoApiScrubberConfig);

function createBaseDescriptorSet(): DescriptorSet {
  return { $type: "envoy.extensions.filters.http.proto_api_scrubber.v3.DescriptorSet" };
}

export const DescriptorSet: MessageFns<
  DescriptorSet,
  "envoy.extensions.filters.http.proto_api_scrubber.v3.DescriptorSet"
> = {
  $type: "envoy.extensions.filters.http.proto_api_scrubber.v3.DescriptorSet" as const,

  encode(message: DescriptorSet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data_source !== undefined) {
      DataSource.encode(message.data_source, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DescriptorSet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDescriptorSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data_source = DataSource.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DescriptorSet {
    return {
      $type: DescriptorSet.$type,
      data_source: isSet(object.data_source) ? DataSource.fromJSON(object.data_source) : undefined,
    };
  },

  toJSON(message: DescriptorSet): unknown {
    const obj: any = {};
    if (message.data_source !== undefined) {
      obj.data_source = DataSource.toJSON(message.data_source);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DescriptorSet>, I>>(base?: I): DescriptorSet {
    return DescriptorSet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DescriptorSet>, I>>(object: I): DescriptorSet {
    const message = createBaseDescriptorSet();
    message.data_source = (object.data_source !== undefined && object.data_source !== null)
      ? DataSource.fromPartial(object.data_source)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(DescriptorSet.$type, DescriptorSet);

function createBaseRestrictions(): Restrictions {
  return { $type: "envoy.extensions.filters.http.proto_api_scrubber.v3.Restrictions" };
}

export const Restrictions: MessageFns<
  Restrictions,
  "envoy.extensions.filters.http.proto_api_scrubber.v3.Restrictions"
> = {
  $type: "envoy.extensions.filters.http.proto_api_scrubber.v3.Restrictions" as const,

  encode(message: Restrictions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    (message.method_restrictions || new Map()).forEach((value, key) => {
      Restrictions_MethodRestrictionsEntry.encode({
        $type: "envoy.extensions.filters.http.proto_api_scrubber.v3.Restrictions.MethodRestrictionsEntry",
        key: key as any,
        value,
      }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Restrictions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRestrictions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = Restrictions_MethodRestrictionsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            if (message.method_restrictions === undefined) {
              message.method_restrictions = new Map();
            }
            message.method_restrictions!.set(entry1.key, entry1.value);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Restrictions {
    return {
      $type: Restrictions.$type,
      method_restrictions: isObject(object.method_restrictions)
        ? Object.entries(object.method_restrictions).reduce<Map<string, MethodRestrictions>>((acc, [key, value]) => {
          acc.set(key, MethodRestrictions.fromJSON(value));
          return acc;
        }, new Map())
        : undefined,
    };
  },

  toJSON(message: Restrictions): unknown {
    const obj: any = {};
    if (message.method_restrictions?.size) {
      obj.method_restrictions = {};
      message.method_restrictions.forEach((v, k) => {
        obj.method_restrictions[k] = MethodRestrictions.toJSON(v);
      });
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Restrictions>, I>>(base?: I): Restrictions {
    return Restrictions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Restrictions>, I>>(object: I): Restrictions {
    const message = createBaseRestrictions();
    message.method_restrictions = (object.method_restrictions === undefined || object.method_restrictions === null)
      ? undefined
      : (() => {
        const m = new Map();
        (object.method_restrictions as Map<string, MethodRestrictions> ?? new Map()).forEach((value, key) => {
          if (value !== undefined) {
            m.set(key, MethodRestrictions.fromPartial(value));
          }
        });
        return m;
      })();
    return message;
  },
};

messageTypeRegistry.set(Restrictions.$type, Restrictions);

function createBaseRestrictions_MethodRestrictionsEntry(): Restrictions_MethodRestrictionsEntry {
  return { $type: "envoy.extensions.filters.http.proto_api_scrubber.v3.Restrictions.MethodRestrictionsEntry", key: "" };
}

export const Restrictions_MethodRestrictionsEntry: MessageFns<
  Restrictions_MethodRestrictionsEntry,
  "envoy.extensions.filters.http.proto_api_scrubber.v3.Restrictions.MethodRestrictionsEntry"
> = {
  $type: "envoy.extensions.filters.http.proto_api_scrubber.v3.Restrictions.MethodRestrictionsEntry" as const,

  encode(message: Restrictions_MethodRestrictionsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      MethodRestrictions.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Restrictions_MethodRestrictionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRestrictions_MethodRestrictionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = MethodRestrictions.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Restrictions_MethodRestrictionsEntry {
    return {
      $type: Restrictions_MethodRestrictionsEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? MethodRestrictions.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Restrictions_MethodRestrictionsEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = MethodRestrictions.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Restrictions_MethodRestrictionsEntry>, I>>(
    base?: I,
  ): Restrictions_MethodRestrictionsEntry {
    return Restrictions_MethodRestrictionsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Restrictions_MethodRestrictionsEntry>, I>>(
    object: I,
  ): Restrictions_MethodRestrictionsEntry {
    const message = createBaseRestrictions_MethodRestrictionsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? MethodRestrictions.fromPartial(object.value)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Restrictions_MethodRestrictionsEntry.$type, Restrictions_MethodRestrictionsEntry);

function createBaseMethodRestrictions(): MethodRestrictions {
  return { $type: "envoy.extensions.filters.http.proto_api_scrubber.v3.MethodRestrictions" };
}

export const MethodRestrictions: MessageFns<
  MethodRestrictions,
  "envoy.extensions.filters.http.proto_api_scrubber.v3.MethodRestrictions"
> = {
  $type: "envoy.extensions.filters.http.proto_api_scrubber.v3.MethodRestrictions" as const,

  encode(message: MethodRestrictions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    (message.request_field_restrictions || new Map()).forEach((value, key) => {
      MethodRestrictions_RequestFieldRestrictionsEntry.encode({
        $type: "envoy.extensions.filters.http.proto_api_scrubber.v3.MethodRestrictions.RequestFieldRestrictionsEntry",
        key: key as any,
        value,
      }, writer.uint32(10).fork()).join();
    });
    (message.response_field_restrictions || new Map()).forEach((value, key) => {
      MethodRestrictions_ResponseFieldRestrictionsEntry.encode({
        $type: "envoy.extensions.filters.http.proto_api_scrubber.v3.MethodRestrictions.ResponseFieldRestrictionsEntry",
        key: key as any,
        value,
      }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MethodRestrictions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMethodRestrictions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = MethodRestrictions_RequestFieldRestrictionsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            if (message.request_field_restrictions === undefined) {
              message.request_field_restrictions = new Map();
            }
            message.request_field_restrictions!.set(entry1.key, entry1.value);
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = MethodRestrictions_ResponseFieldRestrictionsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            if (message.response_field_restrictions === undefined) {
              message.response_field_restrictions = new Map();
            }
            message.response_field_restrictions!.set(entry2.key, entry2.value);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MethodRestrictions {
    return {
      $type: MethodRestrictions.$type,
      request_field_restrictions: isObject(object.request_field_restrictions)
        ? Object.entries(object.request_field_restrictions).reduce<Map<string, RestrictionConfig>>(
          (acc, [key, value]) => {
            acc.set(key, RestrictionConfig.fromJSON(value));
            return acc;
          },
          new Map(),
        )
        : undefined,
      response_field_restrictions: isObject(object.response_field_restrictions)
        ? Object.entries(object.response_field_restrictions).reduce<Map<string, RestrictionConfig>>(
          (acc, [key, value]) => {
            acc.set(key, RestrictionConfig.fromJSON(value));
            return acc;
          },
          new Map(),
        )
        : undefined,
    };
  },

  toJSON(message: MethodRestrictions): unknown {
    const obj: any = {};
    if (message.request_field_restrictions?.size) {
      obj.request_field_restrictions = {};
      message.request_field_restrictions.forEach((v, k) => {
        obj.request_field_restrictions[k] = RestrictionConfig.toJSON(v);
      });
    }
    if (message.response_field_restrictions?.size) {
      obj.response_field_restrictions = {};
      message.response_field_restrictions.forEach((v, k) => {
        obj.response_field_restrictions[k] = RestrictionConfig.toJSON(v);
      });
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MethodRestrictions>, I>>(base?: I): MethodRestrictions {
    return MethodRestrictions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MethodRestrictions>, I>>(object: I): MethodRestrictions {
    const message = createBaseMethodRestrictions();
    message.request_field_restrictions =
      (object.request_field_restrictions === undefined || object.request_field_restrictions === null)
        ? undefined
        : (() => {
          const m = new Map();
          (object.request_field_restrictions as Map<string, RestrictionConfig> ?? new Map()).forEach((value, key) => {
            if (value !== undefined) {
              m.set(key, RestrictionConfig.fromPartial(value));
            }
          });
          return m;
        })();
    message.response_field_restrictions =
      (object.response_field_restrictions === undefined || object.response_field_restrictions === null)
        ? undefined
        : (() => {
          const m = new Map();
          (object.response_field_restrictions as Map<string, RestrictionConfig> ?? new Map()).forEach((value, key) => {
            if (value !== undefined) {
              m.set(key, RestrictionConfig.fromPartial(value));
            }
          });
          return m;
        })();
    return message;
  },
};

messageTypeRegistry.set(MethodRestrictions.$type, MethodRestrictions);

function createBaseMethodRestrictions_RequestFieldRestrictionsEntry(): MethodRestrictions_RequestFieldRestrictionsEntry {
  return {
    $type: "envoy.extensions.filters.http.proto_api_scrubber.v3.MethodRestrictions.RequestFieldRestrictionsEntry",
    key: "",
  };
}

export const MethodRestrictions_RequestFieldRestrictionsEntry: MessageFns<
  MethodRestrictions_RequestFieldRestrictionsEntry,
  "envoy.extensions.filters.http.proto_api_scrubber.v3.MethodRestrictions.RequestFieldRestrictionsEntry"
> = {
  $type:
    "envoy.extensions.filters.http.proto_api_scrubber.v3.MethodRestrictions.RequestFieldRestrictionsEntry" as const,

  encode(
    message: MethodRestrictions_RequestFieldRestrictionsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      RestrictionConfig.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MethodRestrictions_RequestFieldRestrictionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMethodRestrictions_RequestFieldRestrictionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = RestrictionConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MethodRestrictions_RequestFieldRestrictionsEntry {
    return {
      $type: MethodRestrictions_RequestFieldRestrictionsEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? RestrictionConfig.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: MethodRestrictions_RequestFieldRestrictionsEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = RestrictionConfig.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MethodRestrictions_RequestFieldRestrictionsEntry>, I>>(
    base?: I,
  ): MethodRestrictions_RequestFieldRestrictionsEntry {
    return MethodRestrictions_RequestFieldRestrictionsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MethodRestrictions_RequestFieldRestrictionsEntry>, I>>(
    object: I,
  ): MethodRestrictions_RequestFieldRestrictionsEntry {
    const message = createBaseMethodRestrictions_RequestFieldRestrictionsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? RestrictionConfig.fromPartial(object.value)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(
  MethodRestrictions_RequestFieldRestrictionsEntry.$type,
  MethodRestrictions_RequestFieldRestrictionsEntry,
);

function createBaseMethodRestrictions_ResponseFieldRestrictionsEntry(): MethodRestrictions_ResponseFieldRestrictionsEntry {
  return {
    $type: "envoy.extensions.filters.http.proto_api_scrubber.v3.MethodRestrictions.ResponseFieldRestrictionsEntry",
    key: "",
  };
}

export const MethodRestrictions_ResponseFieldRestrictionsEntry: MessageFns<
  MethodRestrictions_ResponseFieldRestrictionsEntry,
  "envoy.extensions.filters.http.proto_api_scrubber.v3.MethodRestrictions.ResponseFieldRestrictionsEntry"
> = {
  $type:
    "envoy.extensions.filters.http.proto_api_scrubber.v3.MethodRestrictions.ResponseFieldRestrictionsEntry" as const,

  encode(
    message: MethodRestrictions_ResponseFieldRestrictionsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      RestrictionConfig.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MethodRestrictions_ResponseFieldRestrictionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMethodRestrictions_ResponseFieldRestrictionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = RestrictionConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MethodRestrictions_ResponseFieldRestrictionsEntry {
    return {
      $type: MethodRestrictions_ResponseFieldRestrictionsEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? RestrictionConfig.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: MethodRestrictions_ResponseFieldRestrictionsEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = RestrictionConfig.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MethodRestrictions_ResponseFieldRestrictionsEntry>, I>>(
    base?: I,
  ): MethodRestrictions_ResponseFieldRestrictionsEntry {
    return MethodRestrictions_ResponseFieldRestrictionsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MethodRestrictions_ResponseFieldRestrictionsEntry>, I>>(
    object: I,
  ): MethodRestrictions_ResponseFieldRestrictionsEntry {
    const message = createBaseMethodRestrictions_ResponseFieldRestrictionsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? RestrictionConfig.fromPartial(object.value)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(
  MethodRestrictions_ResponseFieldRestrictionsEntry.$type,
  MethodRestrictions_ResponseFieldRestrictionsEntry,
);

function createBaseRestrictionConfig(): RestrictionConfig {
  return { $type: "envoy.extensions.filters.http.proto_api_scrubber.v3.RestrictionConfig" };
}

export const RestrictionConfig: MessageFns<
  RestrictionConfig,
  "envoy.extensions.filters.http.proto_api_scrubber.v3.RestrictionConfig"
> = {
  $type: "envoy.extensions.filters.http.proto_api_scrubber.v3.RestrictionConfig" as const,

  encode(message: RestrictionConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.matcher !== undefined) {
      Matcher.encode(message.matcher, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RestrictionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRestrictionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.matcher = Matcher.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RestrictionConfig {
    return {
      $type: RestrictionConfig.$type,
      matcher: isSet(object.matcher) ? Matcher.fromJSON(object.matcher) : undefined,
    };
  },

  toJSON(message: RestrictionConfig): unknown {
    const obj: any = {};
    if (message.matcher !== undefined) {
      obj.matcher = Matcher.toJSON(message.matcher);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RestrictionConfig>, I>>(base?: I): RestrictionConfig {
    return RestrictionConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RestrictionConfig>, I>>(object: I): RestrictionConfig {
    const message = createBaseRestrictionConfig();
    message.matcher = (object.matcher !== undefined && object.matcher !== null)
      ? Matcher.fromPartial(object.matcher)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(RestrictionConfig.$type, RestrictionConfig);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
