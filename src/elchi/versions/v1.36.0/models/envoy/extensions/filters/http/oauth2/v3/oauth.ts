// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/filters/http/oauth2/v3/oauth.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../../../../google/protobuf/duration";
import { BoolValue } from "../../../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../../../typeRegistry";
import { RetryPolicy } from "../../../../../config/core/v3/base";
import { HttpUri } from "../../../../../config/core/v3/http_uri";
import { HeaderMatcher } from "../../../../../config/route/v3/route_components";
import { PathMatcher } from "../../../../../type/matcher/v3/path";
import { SdsSecretConfig } from "../../../../transport_sockets/tls/v3/secret";

export const protobufPackage = "envoy.extensions.filters.http.oauth2.v3";

/** OAuth cookie configuration attributes. */
export interface CookieConfig {
  $type: "envoy.extensions.filters.http.oauth2.v3.CookieConfig";
  /** The value used for the SameSite cookie attribute. */
  same_site?: CookieConfig_SameSite | undefined;
}

export enum CookieConfig_SameSite {
  DISABLED = "DISABLED",
  STRICT = "STRICT",
  LAX = "LAX",
  NONE = "NONE",
}

export function cookieConfig_SameSiteFromJSON(object: any): CookieConfig_SameSite {
  switch (object) {
    case 0:
    case "DISABLED":
      return CookieConfig_SameSite.DISABLED;
    case 1:
    case "STRICT":
      return CookieConfig_SameSite.STRICT;
    case 2:
    case "LAX":
      return CookieConfig_SameSite.LAX;
    case 3:
    case "NONE":
      return CookieConfig_SameSite.NONE;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CookieConfig_SameSite");
  }
}

export function cookieConfig_SameSiteToJSON(object: CookieConfig_SameSite): string {
  switch (object) {
    case CookieConfig_SameSite.DISABLED:
      return "DISABLED";
    case CookieConfig_SameSite.STRICT:
      return "STRICT";
    case CookieConfig_SameSite.LAX:
      return "LAX";
    case CookieConfig_SameSite.NONE:
      return "NONE";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CookieConfig_SameSite");
  }
}

export function cookieConfig_SameSiteToNumber(object: CookieConfig_SameSite): number {
  switch (object) {
    case CookieConfig_SameSite.DISABLED:
      return 0;
    case CookieConfig_SameSite.STRICT:
      return 1;
    case CookieConfig_SameSite.LAX:
      return 2;
    case CookieConfig_SameSite.NONE:
      return 3;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CookieConfig_SameSite");
  }
}

/** [#next-free-field: 8] */
export interface CookieConfigs {
  $type: "envoy.extensions.filters.http.oauth2.v3.CookieConfigs";
  /** Configuration for the bearer token cookie. */
  bearer_token_cookie_config?:
    | CookieConfig
    | undefined;
  /** Configuration for the OAuth HMAC cookie. */
  oauth_hmac_cookie_config?:
    | CookieConfig
    | undefined;
  /** Configuration for the OAuth expires cookie. */
  oauth_expires_cookie_config?:
    | CookieConfig
    | undefined;
  /** Configuration for the ID token cookie. */
  id_token_cookie_config?:
    | CookieConfig
    | undefined;
  /** Configuration for the refresh token cookie. */
  refresh_token_cookie_config?:
    | CookieConfig
    | undefined;
  /** Configuration for the OAuth nonce cookie. */
  oauth_nonce_cookie_config?:
    | CookieConfig
    | undefined;
  /** Configuration for the code verifier cookie. */
  code_verifier_cookie_config?: CookieConfig | undefined;
}

/** [#next-free-field: 6] */
export interface OAuth2Credentials {
  $type: "envoy.extensions.filters.http.oauth2.v3.OAuth2Credentials";
  /** The client_id to be used in the authorize calls. This value will be URL encoded when sent to the OAuth server. */
  client_id?:
    | string
    | undefined;
  /** The secret used to retrieve the access token. This value will be URL encoded when sent to the OAuth server. */
  token_secret?:
    | SdsSecretConfig
    | undefined;
  /** Configures how the secret token should be created. */
  token_formation?:
    | //
    /** If present, the secret token will be a HMAC using the provided secret. */
    { $case: "hmac_secret"; hmac_secret: SdsSecretConfig }
    | undefined;
  /** The cookie names used in OAuth filters flow. */
  cookie_names?:
    | OAuth2Credentials_CookieNames
    | undefined;
  /**
   * The domain to set the cookie on. If not set, the cookie will default to the host of the request, not including the subdomains.
   * This is useful when token cookies need to be shared across multiple subdomains.
   */
  cookie_domain?: string | undefined;
}

/** [#next-free-field: 8] */
export interface OAuth2Credentials_CookieNames {
  $type: "envoy.extensions.filters.http.oauth2.v3.OAuth2Credentials.CookieNames";
  /**
   * Cookie name to hold OAuth bearer token value. When the authentication server validates the
   * client and returns an authorization token back to the OAuth filter, no matter what format
   * that token is, if :ref:`forward_bearer_token <envoy_v3_api_field_extensions.filters.http.oauth2.v3.OAuth2Config.forward_bearer_token>`
   * is set to true the filter will send over the bearer token as a cookie with this name to the
   * upstream. Defaults to ``BearerToken``.
   */
  bearer_token?:
    | string
    | undefined;
  /** Cookie name to hold OAuth HMAC value. Defaults to ``OauthHMAC``. */
  oauth_hmac?:
    | string
    | undefined;
  /** Cookie name to hold OAuth expiry value. Defaults to ``OauthExpires``. */
  oauth_expires?:
    | string
    | undefined;
  /** Cookie name to hold the id token. Defaults to ``IdToken``. */
  id_token?:
    | string
    | undefined;
  /** Cookie name to hold the refresh token. Defaults to ``RefreshToken``. */
  refresh_token?:
    | string
    | undefined;
  /** Cookie name to hold the nonce value. Defaults to ``OauthNonce``. */
  oauth_nonce?:
    | string
    | undefined;
  /** Cookie name to hold the PKCE code verifier. Defaults to ``OauthCodeVerifier``. */
  code_verifier?: string | undefined;
}

/**
 * OAuth config
 *
 * [#next-free-field: 27]
 */
export interface OAuth2Config {
  $type: "envoy.extensions.filters.http.oauth2.v3.OAuth2Config";
  /** Endpoint on the authorization server to retrieve the access token from. */
  token_endpoint?:
    | HttpUri
    | undefined;
  /** Specifies the retry policy for requests to the OAuth server. If not specified, then no retries will be performed. */
  retry_policy?:
    | RetryPolicy
    | undefined;
  /** The endpoint redirect to for authorization in response to unauthorized requests. */
  authorization_endpoint?:
    | string
    | undefined;
  /**
   * The endpoint at the authorization server to request the user be logged out of the Authorization server.
   * This field is optional and should be set only if openid is in the auth_scopes and the authorization server
   * supports the OpenID Connect RP-Initiated Logout specification.
   * For more information, see https://openid.net/specs/openid-connect-rpinitiated-1_0.html
   *
   * If configured, the OAuth2 filter will redirect users to this endpoint when they access the signout_path.
   */
  end_session_endpoint?:
    | string
    | undefined;
  /** Credentials used for OAuth. */
  credentials?:
    | OAuth2Credentials
    | undefined;
  /**
   * The redirect URI passed to the authorization endpoint. Supports header formatting
   * tokens. For more information, including details on header value syntax, see the
   * documentation on :ref:`custom request headers <config_http_conn_man_headers_custom_request_headers>`.
   *
   * This URI should not contain any query parameters.
   */
  redirect_uri?:
    | string
    | undefined;
  /** Matching criteria used to determine whether a path appears to be the result of a redirect from the authorization server. */
  redirect_path_matcher?:
    | PathMatcher
    | undefined;
  /** The path to sign a user out, clearing their credential cookies. */
  signout_path?:
    | PathMatcher
    | undefined;
  /** Forward the OAuth token as a Bearer to upstream web service. */
  forward_bearer_token?:
    | boolean
    | undefined;
  /**
   * If set to true, preserve the existing authorization header.
   * By default the client strips the existing authorization header before forwarding upstream.
   * Can not be set to true if forward_bearer_token is already set to true.
   * Default value is false.
   */
  preserve_authorization_header?:
    | boolean
    | undefined;
  /** Any request that matches any of the provided matchers will be passed through without OAuth validation. */
  pass_through_matcher?:
    | HeaderMatcher[]
    | undefined;
  /**
   * Optional list of OAuth scopes to be claimed in the authorization request. If not specified,
   * defaults to "user" scope.
   * OAuth RFC https://tools.ietf.org/html/rfc6749#section-3.3
   */
  auth_scopes?:
    | string[]
    | undefined;
  /**
   * Optional resource parameter for authorization request
   * RFC: https://tools.ietf.org/html/rfc8707
   */
  resources?:
    | string[]
    | undefined;
  /**
   * Defines how ``client_id`` and ``client_secret`` are sent in OAuth client to OAuth server requests.
   * RFC https://datatracker.ietf.org/doc/html/rfc6749#section-2.3.1
   */
  auth_type?:
    | OAuth2Config_AuthType
    | undefined;
  /**
   * If set to true, allows automatic access token refresh using the associated refresh token (see
   * `RFC 6749 section 6 <https://datatracker.ietf.org/doc/html/rfc6749#section-6>`_), provided that the OAuth server supports that.
   * Default value is true.
   */
  use_refresh_token?:
    | boolean
    | undefined;
  /**
   * The default lifetime in seconds of the access token, if omitted by the authorization server.
   *
   * If this value is not set, it will default to ``0s``. In this case, the expiry must be set by
   * the authorization server or the OAuth flow will fail.
   */
  default_expires_in?:
    | Duration
    | undefined;
  /**
   * Any request that matches any of the provided matchers won't be redirected to OAuth server when tokens are not valid.
   * Automatic access token refresh will be performed for these requests, if enabled.
   * This behavior can be useful for AJAX requests.
   */
  deny_redirect_matcher?:
    | HeaderMatcher[]
    | undefined;
  /**
   * The default lifetime in seconds of the refresh token, if the exp (expiration time) claim is omitted in the refresh token or the refresh token is not JWT.
   *
   * If this value is not set, it will default to ``604800s``. In this case, the cookie with the refresh token will be expired
   * in a week.
   * This setting is only considered if ``use_refresh_token`` is set to true, otherwise the authorization server expiration or ``default_expires_in`` is used.
   */
  default_refresh_token_expires_in?:
    | Duration
    | undefined;
  /**
   * If set to true, the client will not set a cookie for ID Token even if one is received from the Identity Provider. This may be useful in cases where the ID
   * Token is too large for HTTP cookies (longer than 4096 characters). Enabling this option will only disable setting the cookie response header, the filter
   * will still process incoming ID Tokens as part of the HMAC if they are there. This is to ensure compatibility while switching this setting on. Future
   * sessions would not set the IdToken cookie header.
   */
  disable_id_token_set_cookie?:
    | boolean
    | undefined;
  /**
   * If set to true, the client will not set a cookie for Access Token even if one is received from the Identity Provider.
   * Enabling this option will only disable setting the cookie response header, the filter
   * will still process incoming Access Tokens as part of the HMAC if they are there. This is to ensure compatibility while switching this setting on. Future
   * sessions would not set the Access Token cookie header.
   */
  disable_access_token_set_cookie?:
    | boolean
    | undefined;
  /**
   * If set to true, the client will not set a cookie for Refresh Token even if one is received from the Identity Provider.
   * Enabling this option will only disable setting the cookie response header, the filter
   * will still process incoming Refresh Tokens as part of the HMAC if they are there. This is to ensure compatibility while switching this setting on. Future
   * sessions would not set the Refresh Token cookie header.
   */
  disable_refresh_token_set_cookie?:
    | boolean
    | undefined;
  /** Controls for attributes that can be set on the cookies. */
  cookie_configs?:
    | CookieConfigs
    | undefined;
  /** Optional additional prefix to use when emitting statistics. */
  stat_prefix?:
    | string
    | undefined;
  /**
   * Optional expiration time for the CSRF protection token cookie.
   * The CSRF token prevents cross-site request forgery attacks during the OAuth2 flow.
   * If not specified, defaults to ``600s`` (10 minutes), which should provide sufficient time
   * for users to complete the OAuth2 authorization flow.
   */
  csrf_token_expires_in?:
    | Duration
    | undefined;
  /**
   * Optional expiration time for the code verifier cookie.
   * The code verifier is stored in a secure, HTTP-only cookie during the OAuth2 authorization process.
   * If not specified, defaults to ``600s`` (10 minutes), which should provide sufficient time
   * for users to complete the OAuth2 authorization flow.
   */
  code_verifier_token_expires_in?:
    | Duration
    | undefined;
  /**
   * Disable token encryption. When set to true, both the access token and the ID token will be stored in plain text.
   * This option should only be used in secure environments where token encryption is not required.
   * Default is false (tokens are encrypted).
   */
  disable_token_encryption?: boolean | undefined;
}

export enum OAuth2Config_AuthType {
  /**
   * URL_ENCODED_BODY - The ``client_id`` and ``client_secret`` will be sent in the URL encoded request body.
   * This type should only be used when Auth server does not support Basic authentication.
   */
  URL_ENCODED_BODY = "URL_ENCODED_BODY",
  /** BASIC_AUTH - The ``client_id`` and ``client_secret`` will be sent using HTTP Basic authentication scheme. */
  BASIC_AUTH = "BASIC_AUTH",
}

export function oAuth2Config_AuthTypeFromJSON(object: any): OAuth2Config_AuthType {
  switch (object) {
    case 0:
    case "URL_ENCODED_BODY":
      return OAuth2Config_AuthType.URL_ENCODED_BODY;
    case 1:
    case "BASIC_AUTH":
      return OAuth2Config_AuthType.BASIC_AUTH;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum OAuth2Config_AuthType");
  }
}

export function oAuth2Config_AuthTypeToJSON(object: OAuth2Config_AuthType): string {
  switch (object) {
    case OAuth2Config_AuthType.URL_ENCODED_BODY:
      return "URL_ENCODED_BODY";
    case OAuth2Config_AuthType.BASIC_AUTH:
      return "BASIC_AUTH";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum OAuth2Config_AuthType");
  }
}

export function oAuth2Config_AuthTypeToNumber(object: OAuth2Config_AuthType): number {
  switch (object) {
    case OAuth2Config_AuthType.URL_ENCODED_BODY:
      return 0;
    case OAuth2Config_AuthType.BASIC_AUTH:
      return 1;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum OAuth2Config_AuthType");
  }
}

/** Filter config. */
export interface OAuth2 {
  $type: "envoy.extensions.filters.http.oauth2.v3.OAuth2";
  /** Leave this empty to disable OAuth2 for a specific route, using per filter config. */
  config?: OAuth2Config | undefined;
}

function createBaseCookieConfig(): CookieConfig {
  return { $type: "envoy.extensions.filters.http.oauth2.v3.CookieConfig" };
}

export const CookieConfig: MessageFns<CookieConfig, "envoy.extensions.filters.http.oauth2.v3.CookieConfig"> = {
  $type: "envoy.extensions.filters.http.oauth2.v3.CookieConfig" as const,

  encode(message: CookieConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.same_site !== undefined && message.same_site !== CookieConfig_SameSite.DISABLED) {
      writer.uint32(8).int32(cookieConfig_SameSiteToNumber(message.same_site));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CookieConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCookieConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.same_site = cookieConfig_SameSiteFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CookieConfig {
    return {
      $type: CookieConfig.$type,
      same_site: isSet(object.same_site) ? cookieConfig_SameSiteFromJSON(object.same_site) : undefined,
    };
  },

  toJSON(message: CookieConfig): unknown {
    const obj: any = {};
    if (message.same_site !== undefined) {
      obj.same_site = cookieConfig_SameSiteToJSON(message.same_site);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CookieConfig>, I>>(base?: I): CookieConfig {
    return CookieConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CookieConfig>, I>>(object: I): CookieConfig {
    const message = createBaseCookieConfig();
    message.same_site = object.same_site ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(CookieConfig.$type, CookieConfig);

function createBaseCookieConfigs(): CookieConfigs {
  return { $type: "envoy.extensions.filters.http.oauth2.v3.CookieConfigs" };
}

export const CookieConfigs: MessageFns<CookieConfigs, "envoy.extensions.filters.http.oauth2.v3.CookieConfigs"> = {
  $type: "envoy.extensions.filters.http.oauth2.v3.CookieConfigs" as const,

  encode(message: CookieConfigs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bearer_token_cookie_config !== undefined) {
      CookieConfig.encode(message.bearer_token_cookie_config, writer.uint32(10).fork()).join();
    }
    if (message.oauth_hmac_cookie_config !== undefined) {
      CookieConfig.encode(message.oauth_hmac_cookie_config, writer.uint32(18).fork()).join();
    }
    if (message.oauth_expires_cookie_config !== undefined) {
      CookieConfig.encode(message.oauth_expires_cookie_config, writer.uint32(26).fork()).join();
    }
    if (message.id_token_cookie_config !== undefined) {
      CookieConfig.encode(message.id_token_cookie_config, writer.uint32(34).fork()).join();
    }
    if (message.refresh_token_cookie_config !== undefined) {
      CookieConfig.encode(message.refresh_token_cookie_config, writer.uint32(42).fork()).join();
    }
    if (message.oauth_nonce_cookie_config !== undefined) {
      CookieConfig.encode(message.oauth_nonce_cookie_config, writer.uint32(50).fork()).join();
    }
    if (message.code_verifier_cookie_config !== undefined) {
      CookieConfig.encode(message.code_verifier_cookie_config, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CookieConfigs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCookieConfigs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bearer_token_cookie_config = CookieConfig.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.oauth_hmac_cookie_config = CookieConfig.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.oauth_expires_cookie_config = CookieConfig.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.id_token_cookie_config = CookieConfig.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.refresh_token_cookie_config = CookieConfig.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.oauth_nonce_cookie_config = CookieConfig.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.code_verifier_cookie_config = CookieConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CookieConfigs {
    return {
      $type: CookieConfigs.$type,
      bearer_token_cookie_config: isSet(object.bearer_token_cookie_config)
        ? CookieConfig.fromJSON(object.bearer_token_cookie_config)
        : undefined,
      oauth_hmac_cookie_config: isSet(object.oauth_hmac_cookie_config)
        ? CookieConfig.fromJSON(object.oauth_hmac_cookie_config)
        : undefined,
      oauth_expires_cookie_config: isSet(object.oauth_expires_cookie_config)
        ? CookieConfig.fromJSON(object.oauth_expires_cookie_config)
        : undefined,
      id_token_cookie_config: isSet(object.id_token_cookie_config)
        ? CookieConfig.fromJSON(object.id_token_cookie_config)
        : undefined,
      refresh_token_cookie_config: isSet(object.refresh_token_cookie_config)
        ? CookieConfig.fromJSON(object.refresh_token_cookie_config)
        : undefined,
      oauth_nonce_cookie_config: isSet(object.oauth_nonce_cookie_config)
        ? CookieConfig.fromJSON(object.oauth_nonce_cookie_config)
        : undefined,
      code_verifier_cookie_config: isSet(object.code_verifier_cookie_config)
        ? CookieConfig.fromJSON(object.code_verifier_cookie_config)
        : undefined,
    };
  },

  toJSON(message: CookieConfigs): unknown {
    const obj: any = {};
    if (message.bearer_token_cookie_config !== undefined) {
      obj.bearer_token_cookie_config = CookieConfig.toJSON(message.bearer_token_cookie_config);
    }
    if (message.oauth_hmac_cookie_config !== undefined) {
      obj.oauth_hmac_cookie_config = CookieConfig.toJSON(message.oauth_hmac_cookie_config);
    }
    if (message.oauth_expires_cookie_config !== undefined) {
      obj.oauth_expires_cookie_config = CookieConfig.toJSON(message.oauth_expires_cookie_config);
    }
    if (message.id_token_cookie_config !== undefined) {
      obj.id_token_cookie_config = CookieConfig.toJSON(message.id_token_cookie_config);
    }
    if (message.refresh_token_cookie_config !== undefined) {
      obj.refresh_token_cookie_config = CookieConfig.toJSON(message.refresh_token_cookie_config);
    }
    if (message.oauth_nonce_cookie_config !== undefined) {
      obj.oauth_nonce_cookie_config = CookieConfig.toJSON(message.oauth_nonce_cookie_config);
    }
    if (message.code_verifier_cookie_config !== undefined) {
      obj.code_verifier_cookie_config = CookieConfig.toJSON(message.code_verifier_cookie_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CookieConfigs>, I>>(base?: I): CookieConfigs {
    return CookieConfigs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CookieConfigs>, I>>(object: I): CookieConfigs {
    const message = createBaseCookieConfigs();
    message.bearer_token_cookie_config =
      (object.bearer_token_cookie_config !== undefined && object.bearer_token_cookie_config !== null)
        ? CookieConfig.fromPartial(object.bearer_token_cookie_config)
        : undefined;
    message.oauth_hmac_cookie_config =
      (object.oauth_hmac_cookie_config !== undefined && object.oauth_hmac_cookie_config !== null)
        ? CookieConfig.fromPartial(object.oauth_hmac_cookie_config)
        : undefined;
    message.oauth_expires_cookie_config =
      (object.oauth_expires_cookie_config !== undefined && object.oauth_expires_cookie_config !== null)
        ? CookieConfig.fromPartial(object.oauth_expires_cookie_config)
        : undefined;
    message.id_token_cookie_config =
      (object.id_token_cookie_config !== undefined && object.id_token_cookie_config !== null)
        ? CookieConfig.fromPartial(object.id_token_cookie_config)
        : undefined;
    message.refresh_token_cookie_config =
      (object.refresh_token_cookie_config !== undefined && object.refresh_token_cookie_config !== null)
        ? CookieConfig.fromPartial(object.refresh_token_cookie_config)
        : undefined;
    message.oauth_nonce_cookie_config =
      (object.oauth_nonce_cookie_config !== undefined && object.oauth_nonce_cookie_config !== null)
        ? CookieConfig.fromPartial(object.oauth_nonce_cookie_config)
        : undefined;
    message.code_verifier_cookie_config =
      (object.code_verifier_cookie_config !== undefined && object.code_verifier_cookie_config !== null)
        ? CookieConfig.fromPartial(object.code_verifier_cookie_config)
        : undefined;
    return message;
  },
};

messageTypeRegistry.set(CookieConfigs.$type, CookieConfigs);

function createBaseOAuth2Credentials(): OAuth2Credentials {
  return { $type: "envoy.extensions.filters.http.oauth2.v3.OAuth2Credentials", token_formation: undefined };
}

export const OAuth2Credentials: MessageFns<
  OAuth2Credentials,
  "envoy.extensions.filters.http.oauth2.v3.OAuth2Credentials"
> = {
  $type: "envoy.extensions.filters.http.oauth2.v3.OAuth2Credentials" as const,

  encode(message: OAuth2Credentials, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.client_id !== undefined && message.client_id !== "") {
      writer.uint32(10).string(message.client_id);
    }
    if (message.token_secret !== undefined) {
      SdsSecretConfig.encode(message.token_secret, writer.uint32(18).fork()).join();
    }
    switch (message.token_formation?.$case) {
      case "hmac_secret":
        SdsSecretConfig.encode(message.token_formation.hmac_secret, writer.uint32(26).fork()).join();
        break;
    }
    if (message.cookie_names !== undefined) {
      OAuth2Credentials_CookieNames.encode(message.cookie_names, writer.uint32(34).fork()).join();
    }
    if (message.cookie_domain !== undefined && message.cookie_domain !== "") {
      writer.uint32(42).string(message.cookie_domain);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OAuth2Credentials {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOAuth2Credentials();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.client_id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.token_secret = SdsSecretConfig.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.token_formation = {
            $case: "hmac_secret",
            hmac_secret: SdsSecretConfig.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.cookie_names = OAuth2Credentials_CookieNames.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.cookie_domain = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OAuth2Credentials {
    return {
      $type: OAuth2Credentials.$type,
      client_id: isSet(object.client_id) ? globalThis.String(object.client_id) : undefined,
      token_secret: isSet(object.token_secret) ? SdsSecretConfig.fromJSON(object.token_secret) : undefined,
      token_formation: isSet(object.hmac_secret)
        ? { $case: "hmac_secret", hmac_secret: SdsSecretConfig.fromJSON(object.hmac_secret) }
        : undefined,
      cookie_names: isSet(object.cookie_names)
        ? OAuth2Credentials_CookieNames.fromJSON(object.cookie_names)
        : undefined,
      cookie_domain: isSet(object.cookie_domain) ? globalThis.String(object.cookie_domain) : undefined,
    };
  },

  toJSON(message: OAuth2Credentials): unknown {
    const obj: any = {};
    if (message.client_id !== undefined) {
      obj.client_id = message.client_id;
    }
    if (message.token_secret !== undefined) {
      obj.token_secret = SdsSecretConfig.toJSON(message.token_secret);
    }
    if (message.token_formation?.$case === "hmac_secret") {
      obj.hmac_secret = SdsSecretConfig.toJSON(message.token_formation.hmac_secret);
    }
    if (message.cookie_names !== undefined) {
      obj.cookie_names = OAuth2Credentials_CookieNames.toJSON(message.cookie_names);
    }
    if (message.cookie_domain !== undefined) {
      obj.cookie_domain = message.cookie_domain;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OAuth2Credentials>, I>>(base?: I): OAuth2Credentials {
    return OAuth2Credentials.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OAuth2Credentials>, I>>(object: I): OAuth2Credentials {
    const message = createBaseOAuth2Credentials();
    message.client_id = object.client_id ?? undefined;
    message.token_secret = (object.token_secret !== undefined && object.token_secret !== null)
      ? SdsSecretConfig.fromPartial(object.token_secret)
      : undefined;
    if (
      object.token_formation?.$case === "hmac_secret" &&
      object.token_formation?.hmac_secret !== undefined &&
      object.token_formation?.hmac_secret !== null
    ) {
      message.token_formation = {
        $case: "hmac_secret",
        hmac_secret: SdsSecretConfig.fromPartial(object.token_formation.hmac_secret),
      };
    }
    message.cookie_names = (object.cookie_names !== undefined && object.cookie_names !== null)
      ? OAuth2Credentials_CookieNames.fromPartial(object.cookie_names)
      : undefined;
    message.cookie_domain = object.cookie_domain ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(OAuth2Credentials.$type, OAuth2Credentials);

function createBaseOAuth2Credentials_CookieNames(): OAuth2Credentials_CookieNames {
  return { $type: "envoy.extensions.filters.http.oauth2.v3.OAuth2Credentials.CookieNames" };
}

export const OAuth2Credentials_CookieNames: MessageFns<
  OAuth2Credentials_CookieNames,
  "envoy.extensions.filters.http.oauth2.v3.OAuth2Credentials.CookieNames"
> = {
  $type: "envoy.extensions.filters.http.oauth2.v3.OAuth2Credentials.CookieNames" as const,

  encode(message: OAuth2Credentials_CookieNames, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bearer_token !== undefined && message.bearer_token !== "") {
      writer.uint32(10).string(message.bearer_token);
    }
    if (message.oauth_hmac !== undefined && message.oauth_hmac !== "") {
      writer.uint32(18).string(message.oauth_hmac);
    }
    if (message.oauth_expires !== undefined && message.oauth_expires !== "") {
      writer.uint32(26).string(message.oauth_expires);
    }
    if (message.id_token !== undefined && message.id_token !== "") {
      writer.uint32(34).string(message.id_token);
    }
    if (message.refresh_token !== undefined && message.refresh_token !== "") {
      writer.uint32(42).string(message.refresh_token);
    }
    if (message.oauth_nonce !== undefined && message.oauth_nonce !== "") {
      writer.uint32(50).string(message.oauth_nonce);
    }
    if (message.code_verifier !== undefined && message.code_verifier !== "") {
      writer.uint32(58).string(message.code_verifier);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OAuth2Credentials_CookieNames {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOAuth2Credentials_CookieNames();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bearer_token = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.oauth_hmac = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.oauth_expires = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.id_token = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.refresh_token = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.oauth_nonce = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.code_verifier = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OAuth2Credentials_CookieNames {
    return {
      $type: OAuth2Credentials_CookieNames.$type,
      bearer_token: isSet(object.bearer_token) ? globalThis.String(object.bearer_token) : undefined,
      oauth_hmac: isSet(object.oauth_hmac) ? globalThis.String(object.oauth_hmac) : undefined,
      oauth_expires: isSet(object.oauth_expires) ? globalThis.String(object.oauth_expires) : undefined,
      id_token: isSet(object.id_token) ? globalThis.String(object.id_token) : undefined,
      refresh_token: isSet(object.refresh_token) ? globalThis.String(object.refresh_token) : undefined,
      oauth_nonce: isSet(object.oauth_nonce) ? globalThis.String(object.oauth_nonce) : undefined,
      code_verifier: isSet(object.code_verifier) ? globalThis.String(object.code_verifier) : undefined,
    };
  },

  toJSON(message: OAuth2Credentials_CookieNames): unknown {
    const obj: any = {};
    if (message.bearer_token !== undefined) {
      obj.bearer_token = message.bearer_token;
    }
    if (message.oauth_hmac !== undefined) {
      obj.oauth_hmac = message.oauth_hmac;
    }
    if (message.oauth_expires !== undefined) {
      obj.oauth_expires = message.oauth_expires;
    }
    if (message.id_token !== undefined) {
      obj.id_token = message.id_token;
    }
    if (message.refresh_token !== undefined) {
      obj.refresh_token = message.refresh_token;
    }
    if (message.oauth_nonce !== undefined) {
      obj.oauth_nonce = message.oauth_nonce;
    }
    if (message.code_verifier !== undefined) {
      obj.code_verifier = message.code_verifier;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OAuth2Credentials_CookieNames>, I>>(base?: I): OAuth2Credentials_CookieNames {
    return OAuth2Credentials_CookieNames.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OAuth2Credentials_CookieNames>, I>>(
    object: I,
  ): OAuth2Credentials_CookieNames {
    const message = createBaseOAuth2Credentials_CookieNames();
    message.bearer_token = object.bearer_token ?? undefined;
    message.oauth_hmac = object.oauth_hmac ?? undefined;
    message.oauth_expires = object.oauth_expires ?? undefined;
    message.id_token = object.id_token ?? undefined;
    message.refresh_token = object.refresh_token ?? undefined;
    message.oauth_nonce = object.oauth_nonce ?? undefined;
    message.code_verifier = object.code_verifier ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(OAuth2Credentials_CookieNames.$type, OAuth2Credentials_CookieNames);

function createBaseOAuth2Config(): OAuth2Config {
  return { $type: "envoy.extensions.filters.http.oauth2.v3.OAuth2Config" };
}

export const OAuth2Config: MessageFns<OAuth2Config, "envoy.extensions.filters.http.oauth2.v3.OAuth2Config"> = {
  $type: "envoy.extensions.filters.http.oauth2.v3.OAuth2Config" as const,

  encode(message: OAuth2Config, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token_endpoint !== undefined) {
      HttpUri.encode(message.token_endpoint, writer.uint32(10).fork()).join();
    }
    if (message.retry_policy !== undefined) {
      RetryPolicy.encode(message.retry_policy, writer.uint32(146).fork()).join();
    }
    if (message.authorization_endpoint !== undefined && message.authorization_endpoint !== "") {
      writer.uint32(18).string(message.authorization_endpoint);
    }
    if (message.end_session_endpoint !== undefined && message.end_session_endpoint !== "") {
      writer.uint32(186).string(message.end_session_endpoint);
    }
    if (message.credentials !== undefined) {
      OAuth2Credentials.encode(message.credentials, writer.uint32(26).fork()).join();
    }
    if (message.redirect_uri !== undefined && message.redirect_uri !== "") {
      writer.uint32(34).string(message.redirect_uri);
    }
    if (message.redirect_path_matcher !== undefined) {
      PathMatcher.encode(message.redirect_path_matcher, writer.uint32(42).fork()).join();
    }
    if (message.signout_path !== undefined) {
      PathMatcher.encode(message.signout_path, writer.uint32(50).fork()).join();
    }
    if (message.forward_bearer_token !== undefined && message.forward_bearer_token !== false) {
      writer.uint32(56).bool(message.forward_bearer_token);
    }
    if (message.preserve_authorization_header !== undefined && message.preserve_authorization_header !== false) {
      writer.uint32(128).bool(message.preserve_authorization_header);
    }
    if (message.pass_through_matcher !== undefined && message.pass_through_matcher.length !== 0) {
      for (const v of message.pass_through_matcher) {
        HeaderMatcher.encode(v!, writer.uint32(66).fork()).join();
      }
    }
    if (message.auth_scopes !== undefined && message.auth_scopes.length !== 0) {
      for (const v of message.auth_scopes) {
        writer.uint32(74).string(v!);
      }
    }
    if (message.resources !== undefined && message.resources.length !== 0) {
      for (const v of message.resources) {
        writer.uint32(82).string(v!);
      }
    }
    if (message.auth_type !== undefined && message.auth_type !== OAuth2Config_AuthType.URL_ENCODED_BODY) {
      writer.uint32(88).int32(oAuth2Config_AuthTypeToNumber(message.auth_type));
    }
    if (message.use_refresh_token !== undefined) {
      BoolValue.encode(
        { $type: "google.protobuf.BoolValue", value: message.use_refresh_token! },
        writer.uint32(98).fork(),
      ).join();
    }
    if (message.default_expires_in !== undefined) {
      Duration.encode(message.default_expires_in, writer.uint32(106).fork()).join();
    }
    if (message.deny_redirect_matcher !== undefined && message.deny_redirect_matcher.length !== 0) {
      for (const v of message.deny_redirect_matcher) {
        HeaderMatcher.encode(v!, writer.uint32(114).fork()).join();
      }
    }
    if (message.default_refresh_token_expires_in !== undefined) {
      Duration.encode(message.default_refresh_token_expires_in, writer.uint32(122).fork()).join();
    }
    if (message.disable_id_token_set_cookie !== undefined && message.disable_id_token_set_cookie !== false) {
      writer.uint32(136).bool(message.disable_id_token_set_cookie);
    }
    if (message.disable_access_token_set_cookie !== undefined && message.disable_access_token_set_cookie !== false) {
      writer.uint32(152).bool(message.disable_access_token_set_cookie);
    }
    if (message.disable_refresh_token_set_cookie !== undefined && message.disable_refresh_token_set_cookie !== false) {
      writer.uint32(160).bool(message.disable_refresh_token_set_cookie);
    }
    if (message.cookie_configs !== undefined) {
      CookieConfigs.encode(message.cookie_configs, writer.uint32(170).fork()).join();
    }
    if (message.stat_prefix !== undefined && message.stat_prefix !== "") {
      writer.uint32(178).string(message.stat_prefix);
    }
    if (message.csrf_token_expires_in !== undefined) {
      Duration.encode(message.csrf_token_expires_in, writer.uint32(194).fork()).join();
    }
    if (message.code_verifier_token_expires_in !== undefined) {
      Duration.encode(message.code_verifier_token_expires_in, writer.uint32(202).fork()).join();
    }
    if (message.disable_token_encryption !== undefined && message.disable_token_encryption !== false) {
      writer.uint32(208).bool(message.disable_token_encryption);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OAuth2Config {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOAuth2Config();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token_endpoint = HttpUri.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.retry_policy = RetryPolicy.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.authorization_endpoint = reader.string();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.end_session_endpoint = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.credentials = OAuth2Credentials.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.redirect_uri = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.redirect_path_matcher = PathMatcher.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.signout_path = PathMatcher.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.forward_bearer_token = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.preserve_authorization_header = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          if (message.pass_through_matcher === undefined) {
            message.pass_through_matcher = [];
          }
          const el = HeaderMatcher.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.pass_through_matcher!.push(el);
          }
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          if (message.auth_scopes === undefined) {
            message.auth_scopes = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.auth_scopes!.push(el);
          }
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          if (message.resources === undefined) {
            message.resources = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.resources!.push(el);
          }
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.auth_type = oAuth2Config_AuthTypeFromJSON(reader.int32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.use_refresh_token = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.default_expires_in = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          if (message.deny_redirect_matcher === undefined) {
            message.deny_redirect_matcher = [];
          }
          const el = HeaderMatcher.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.deny_redirect_matcher!.push(el);
          }
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.default_refresh_token_expires_in = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.disable_id_token_set_cookie = reader.bool();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.disable_access_token_set_cookie = reader.bool();
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.disable_refresh_token_set_cookie = reader.bool();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.cookie_configs = CookieConfigs.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.stat_prefix = reader.string();
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.csrf_token_expires_in = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.code_verifier_token_expires_in = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.disable_token_encryption = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OAuth2Config {
    return {
      $type: OAuth2Config.$type,
      token_endpoint: isSet(object.token_endpoint) ? HttpUri.fromJSON(object.token_endpoint) : undefined,
      retry_policy: isSet(object.retry_policy) ? RetryPolicy.fromJSON(object.retry_policy) : undefined,
      authorization_endpoint: isSet(object.authorization_endpoint)
        ? globalThis.String(object.authorization_endpoint)
        : undefined,
      end_session_endpoint: isSet(object.end_session_endpoint)
        ? globalThis.String(object.end_session_endpoint)
        : undefined,
      credentials: isSet(object.credentials) ? OAuth2Credentials.fromJSON(object.credentials) : undefined,
      redirect_uri: isSet(object.redirect_uri) ? globalThis.String(object.redirect_uri) : undefined,
      redirect_path_matcher: isSet(object.redirect_path_matcher)
        ? PathMatcher.fromJSON(object.redirect_path_matcher)
        : undefined,
      signout_path: isSet(object.signout_path) ? PathMatcher.fromJSON(object.signout_path) : undefined,
      forward_bearer_token: isSet(object.forward_bearer_token)
        ? globalThis.Boolean(object.forward_bearer_token)
        : undefined,
      preserve_authorization_header: isSet(object.preserve_authorization_header)
        ? globalThis.Boolean(object.preserve_authorization_header)
        : undefined,
      pass_through_matcher: globalThis.Array.isArray(object?.pass_through_matcher)
        ? object.pass_through_matcher.map((e: any) => HeaderMatcher.fromJSON(e))
        : undefined,
      auth_scopes: globalThis.Array.isArray(object?.auth_scopes)
        ? object.auth_scopes.map((e: any) => globalThis.String(e))
        : undefined,
      resources: globalThis.Array.isArray(object?.resources)
        ? object.resources.map((e: any) => globalThis.String(e))
        : undefined,
      auth_type: isSet(object.auth_type) ? oAuth2Config_AuthTypeFromJSON(object.auth_type) : undefined,
      use_refresh_token: isSet(object.use_refresh_token) ? Boolean(object.use_refresh_token) : undefined,
      default_expires_in: isSet(object.default_expires_in) ? Duration.fromJSON(object.default_expires_in) : undefined,
      deny_redirect_matcher: globalThis.Array.isArray(object?.deny_redirect_matcher)
        ? object.deny_redirect_matcher.map((e: any) => HeaderMatcher.fromJSON(e))
        : undefined,
      default_refresh_token_expires_in: isSet(object.default_refresh_token_expires_in)
        ? Duration.fromJSON(object.default_refresh_token_expires_in)
        : undefined,
      disable_id_token_set_cookie: isSet(object.disable_id_token_set_cookie)
        ? globalThis.Boolean(object.disable_id_token_set_cookie)
        : undefined,
      disable_access_token_set_cookie: isSet(object.disable_access_token_set_cookie)
        ? globalThis.Boolean(object.disable_access_token_set_cookie)
        : undefined,
      disable_refresh_token_set_cookie: isSet(object.disable_refresh_token_set_cookie)
        ? globalThis.Boolean(object.disable_refresh_token_set_cookie)
        : undefined,
      cookie_configs: isSet(object.cookie_configs) ? CookieConfigs.fromJSON(object.cookie_configs) : undefined,
      stat_prefix: isSet(object.stat_prefix) ? globalThis.String(object.stat_prefix) : undefined,
      csrf_token_expires_in: isSet(object.csrf_token_expires_in)
        ? Duration.fromJSON(object.csrf_token_expires_in)
        : undefined,
      code_verifier_token_expires_in: isSet(object.code_verifier_token_expires_in)
        ? Duration.fromJSON(object.code_verifier_token_expires_in)
        : undefined,
      disable_token_encryption: isSet(object.disable_token_encryption)
        ? globalThis.Boolean(object.disable_token_encryption)
        : undefined,
    };
  },

  toJSON(message: OAuth2Config): unknown {
    const obj: any = {};
    if (message.token_endpoint !== undefined) {
      obj.token_endpoint = HttpUri.toJSON(message.token_endpoint);
    }
    if (message.retry_policy !== undefined) {
      obj.retry_policy = RetryPolicy.toJSON(message.retry_policy);
    }
    if (message.authorization_endpoint !== undefined) {
      obj.authorization_endpoint = message.authorization_endpoint;
    }
    if (message.end_session_endpoint !== undefined) {
      obj.end_session_endpoint = message.end_session_endpoint;
    }
    if (message.credentials !== undefined) {
      obj.credentials = OAuth2Credentials.toJSON(message.credentials);
    }
    if (message.redirect_uri !== undefined) {
      obj.redirect_uri = message.redirect_uri;
    }
    if (message.redirect_path_matcher !== undefined) {
      obj.redirect_path_matcher = PathMatcher.toJSON(message.redirect_path_matcher);
    }
    if (message.signout_path !== undefined) {
      obj.signout_path = PathMatcher.toJSON(message.signout_path);
    }
    if (message.forward_bearer_token !== undefined) {
      obj.forward_bearer_token = message.forward_bearer_token;
    }
    if (message.preserve_authorization_header !== undefined) {
      obj.preserve_authorization_header = message.preserve_authorization_header;
    }
    if (message.pass_through_matcher?.length) {
      obj.pass_through_matcher = message.pass_through_matcher.map((e) => HeaderMatcher.toJSON(e));
    }
    if (message.auth_scopes?.length) {
      obj.auth_scopes = message.auth_scopes;
    }
    if (message.resources?.length) {
      obj.resources = message.resources;
    }
    if (message.auth_type !== undefined) {
      obj.auth_type = oAuth2Config_AuthTypeToJSON(message.auth_type);
    }
    if (message.use_refresh_token !== undefined) {
      obj.use_refresh_token = message.use_refresh_token;
    }
    if (message.default_expires_in !== undefined) {
      obj.default_expires_in = Duration.toJSON(message.default_expires_in);
    }
    if (message.deny_redirect_matcher?.length) {
      obj.deny_redirect_matcher = message.deny_redirect_matcher.map((e) => HeaderMatcher.toJSON(e));
    }
    if (message.default_refresh_token_expires_in !== undefined) {
      obj.default_refresh_token_expires_in = Duration.toJSON(message.default_refresh_token_expires_in);
    }
    if (message.disable_id_token_set_cookie !== undefined) {
      obj.disable_id_token_set_cookie = message.disable_id_token_set_cookie;
    }
    if (message.disable_access_token_set_cookie !== undefined) {
      obj.disable_access_token_set_cookie = message.disable_access_token_set_cookie;
    }
    if (message.disable_refresh_token_set_cookie !== undefined) {
      obj.disable_refresh_token_set_cookie = message.disable_refresh_token_set_cookie;
    }
    if (message.cookie_configs !== undefined) {
      obj.cookie_configs = CookieConfigs.toJSON(message.cookie_configs);
    }
    if (message.stat_prefix !== undefined) {
      obj.stat_prefix = message.stat_prefix;
    }
    if (message.csrf_token_expires_in !== undefined) {
      obj.csrf_token_expires_in = Duration.toJSON(message.csrf_token_expires_in);
    }
    if (message.code_verifier_token_expires_in !== undefined) {
      obj.code_verifier_token_expires_in = Duration.toJSON(message.code_verifier_token_expires_in);
    }
    if (message.disable_token_encryption !== undefined) {
      obj.disable_token_encryption = message.disable_token_encryption;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OAuth2Config>, I>>(base?: I): OAuth2Config {
    return OAuth2Config.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OAuth2Config>, I>>(object: I): OAuth2Config {
    const message = createBaseOAuth2Config();
    message.token_endpoint = (object.token_endpoint !== undefined && object.token_endpoint !== null)
      ? HttpUri.fromPartial(object.token_endpoint)
      : undefined;
    message.retry_policy = (object.retry_policy !== undefined && object.retry_policy !== null)
      ? RetryPolicy.fromPartial(object.retry_policy)
      : undefined;
    message.authorization_endpoint = object.authorization_endpoint ?? undefined;
    message.end_session_endpoint = object.end_session_endpoint ?? undefined;
    message.credentials = (object.credentials !== undefined && object.credentials !== null)
      ? OAuth2Credentials.fromPartial(object.credentials)
      : undefined;
    message.redirect_uri = object.redirect_uri ?? undefined;
    message.redirect_path_matcher =
      (object.redirect_path_matcher !== undefined && object.redirect_path_matcher !== null)
        ? PathMatcher.fromPartial(object.redirect_path_matcher)
        : undefined;
    message.signout_path = (object.signout_path !== undefined && object.signout_path !== null)
      ? PathMatcher.fromPartial(object.signout_path)
      : undefined;
    message.forward_bearer_token = object.forward_bearer_token ?? undefined;
    message.preserve_authorization_header = object.preserve_authorization_header ?? undefined;
    message.pass_through_matcher = object.pass_through_matcher?.map((e) => HeaderMatcher.fromPartial(e)) || undefined;
    message.auth_scopes = object.auth_scopes?.map((e) => e) || undefined;
    message.resources = object.resources?.map((e) => e) || undefined;
    message.auth_type = object.auth_type ?? undefined;
    message.use_refresh_token = object.use_refresh_token ?? undefined;
    message.default_expires_in = (object.default_expires_in !== undefined && object.default_expires_in !== null)
      ? Duration.fromPartial(object.default_expires_in)
      : undefined;
    message.deny_redirect_matcher = object.deny_redirect_matcher?.map((e) => HeaderMatcher.fromPartial(e)) || undefined;
    message.default_refresh_token_expires_in =
      (object.default_refresh_token_expires_in !== undefined && object.default_refresh_token_expires_in !== null)
        ? Duration.fromPartial(object.default_refresh_token_expires_in)
        : undefined;
    message.disable_id_token_set_cookie = object.disable_id_token_set_cookie ?? undefined;
    message.disable_access_token_set_cookie = object.disable_access_token_set_cookie ?? undefined;
    message.disable_refresh_token_set_cookie = object.disable_refresh_token_set_cookie ?? undefined;
    message.cookie_configs = (object.cookie_configs !== undefined && object.cookie_configs !== null)
      ? CookieConfigs.fromPartial(object.cookie_configs)
      : undefined;
    message.stat_prefix = object.stat_prefix ?? undefined;
    message.csrf_token_expires_in =
      (object.csrf_token_expires_in !== undefined && object.csrf_token_expires_in !== null)
        ? Duration.fromPartial(object.csrf_token_expires_in)
        : undefined;
    message.code_verifier_token_expires_in =
      (object.code_verifier_token_expires_in !== undefined && object.code_verifier_token_expires_in !== null)
        ? Duration.fromPartial(object.code_verifier_token_expires_in)
        : undefined;
    message.disable_token_encryption = object.disable_token_encryption ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(OAuth2Config.$type, OAuth2Config);

function createBaseOAuth2(): OAuth2 {
  return { $type: "envoy.extensions.filters.http.oauth2.v3.OAuth2" };
}

export const OAuth2: MessageFns<OAuth2, "envoy.extensions.filters.http.oauth2.v3.OAuth2"> = {
  $type: "envoy.extensions.filters.http.oauth2.v3.OAuth2" as const,

  encode(message: OAuth2, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.config !== undefined) {
      OAuth2Config.encode(message.config, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OAuth2 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOAuth2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.config = OAuth2Config.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OAuth2 {
    return { $type: OAuth2.$type, config: isSet(object.config) ? OAuth2Config.fromJSON(object.config) : undefined };
  },

  toJSON(message: OAuth2): unknown {
    const obj: any = {};
    if (message.config !== undefined) {
      obj.config = OAuth2Config.toJSON(message.config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OAuth2>, I>>(base?: I): OAuth2 {
    return OAuth2.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OAuth2>, I>>(object: I): OAuth2 {
    const message = createBaseOAuth2();
    message.config = (object.config !== undefined && object.config !== null)
      ? OAuth2Config.fromPartial(object.config)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(OAuth2.$type, OAuth2);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
