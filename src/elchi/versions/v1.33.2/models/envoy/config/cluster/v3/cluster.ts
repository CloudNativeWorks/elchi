// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/config/cluster/v3/cluster.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Any } from "../../../../google/protobuf/any";
import { Duration } from "../../../../google/protobuf/duration";
import { Struct } from "../../../../google/protobuf/struct";
import { BoolValue, DoubleValue, UInt32Value, UInt64Value } from "../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../typeRegistry";
import { CollectionEntry } from "../../../../xds/core/v3/collection_entry";
import { MetadataKey } from "../../../type/metadata/v3/metadata";
import { Percent } from "../../../type/v3/percent";
import { Address, BindConfig, TcpKeepalive } from "../../core/v3/address";
import { Metadata, RuntimeDouble, TransportSocket } from "../../core/v3/base";
import { ConfigSource } from "../../core/v3/config_source";
import { TypedExtensionConfig } from "../../core/v3/extension";
import { HealthCheck, HealthStatusSet } from "../../core/v3/health_check";
import {
  Http1ProtocolOptions,
  Http2ProtocolOptions,
  HttpProtocolOptions,
  UpstreamHttpProtocolOptions,
} from "../../core/v3/protocol";
import { DnsResolutionConfig } from "../../core/v3/resolver";
import { ClusterLoadAssignment } from "../../endpoint/v3/endpoint";
import { CircuitBreakers } from "./circuit_breaker";
import { Filter } from "./filter";
import { OutlierDetection } from "./outlier_detection";

export const protobufPackage = "envoy.config.cluster.v3";

/**
 * Cluster list collections. Entries are ``Cluster`` resources or references.
 * [#not-implemented-hide:]
 */
export interface ClusterCollection {
  $type: "envoy.config.cluster.v3.ClusterCollection";
  entries?: CollectionEntry | undefined;
}

/**
 * Configuration for a single upstream cluster.
 * [#next-free-field: 59]
 */
export interface Cluster {
  $type: "envoy.config.cluster.v3.Cluster";
  /**
   * Configuration to use different transport sockets for different endpoints. The entry of
   * ``envoy.transport_socket_match`` in the :ref:`LbEndpoint.Metadata
   * <envoy_v3_api_field_config.endpoint.v3.LbEndpoint.metadata>` is used to match against the
   * transport sockets as they appear in the list. If a match is not found, the search continues in
   * :ref:`LocalityLbEndpoints.Metadata
   * <envoy_v3_api_field_config.endpoint.v3.LocalityLbEndpoints.metadata>`. The first :ref:`match
   * <envoy_v3_api_msg_config.cluster.v3.Cluster.TransportSocketMatch>` is used. For example, with
   * the following match
   *
   * .. code-block:: yaml
   *
   *  transport_socket_matches:
   *  - name: "enableMTLS"
   *    match:
   *      acceptMTLS: true
   *    transport_socket:
   *      name: envoy.transport_sockets.tls
   *      config: { ... } # tls socket configuration
   *  - name: "defaultToPlaintext"
   *    match: {}
   *    transport_socket:
   *      name: envoy.transport_sockets.raw_buffer
   *
   * Connections to the endpoints whose metadata value under ``envoy.transport_socket_match``
   * having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
   *
   * If a :ref:`socket match <envoy_v3_api_msg_config.cluster.v3.Cluster.TransportSocketMatch>` with empty match
   * criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
   * socket match in case above.
   *
   * If an endpoint metadata's value under ``envoy.transport_socket_match`` does not match any
   * ``TransportSocketMatch``, the locality metadata is then checked for a match. Barring any
   * matches in the endpoint or locality metadata, the socket configuration fallbacks to use the
   * ``tls_context`` or ``transport_socket`` specified in this cluster.
   *
   * This field allows gradual and flexible transport socket configuration changes.
   *
   * The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
   * an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
   * "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
   * has "acceptPlaintext": "true" metadata information.
   *
   * Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
   * traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
   * ``TransportSocketMatch`` in this field. Other client Envoys receive CDS without
   * ``transport_socket_match`` set, and still send plain text traffic to the same cluster.
   *
   * This field can be used to specify custom transport socket configurations for health
   * checks by adding matching key/value pairs in a health check's
   * :ref:`transport socket match criteria <envoy_v3_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria>` field.
   *
   * [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
   */
  transport_socket_matches?:
    | Cluster_TransportSocketMatch[]
    | undefined;
  /**
   * Supplies the name of the cluster which must be unique across all clusters.
   * The cluster name is used when emitting
   * :ref:`statistics <config_cluster_manager_cluster_stats>` if :ref:`alt_stat_name
   * <envoy_v3_api_field_config.cluster.v3.Cluster.alt_stat_name>` is not provided.
   * Any ``:`` in the cluster name will be converted to ``_`` when emitting statistics.
   */
  name?:
    | string
    | undefined;
  /**
   * An optional alternative to the cluster name to be used for observability. This name is used
   * emitting stats for the cluster and access logging the cluster name. This will appear as
   * additional information in configuration dumps of a cluster's current status as
   * :ref:`observability_name <envoy_v3_api_field_admin.v3.ClusterStatus.observability_name>`
   * and as an additional tag "upstream_cluster.name" while tracing. Note: Any ``:`` in the name
   * will be converted to ``_`` when emitting statistics. This should not be confused with
   * :ref:`Router Filter Header <config_http_filters_router_x-envoy-upstream-alt-stat-name>`.
   */
  alt_stat_name?: string | undefined;
  cluster_discovery_type?:
    | //
    /**
     * The :ref:`service discovery type <arch_overview_service_discovery_types>`
     * to use for resolving the cluster.
     */
    { $case: "type"; type: Cluster_DiscoveryType }
    | //
    /** The custom cluster type. */
    { $case: "cluster_type"; cluster_type: Cluster_CustomClusterType }
    | undefined;
  /** Configuration to use for EDS updates for the Cluster. */
  eds_cluster_config?:
    | Cluster_EdsClusterConfig
    | undefined;
  /**
   * The timeout for new network connections to hosts in the cluster.
   * If not set, a default value of 5s will be used.
   */
  connect_timeout?:
    | Duration
    | undefined;
  /**
   * Soft limit on size of the clusterâ€™s connections read and write buffers. If
   * unspecified, an implementation defined default is applied (1MiB).
   */
  per_connection_buffer_limit_bytes?:
    | number
    | undefined;
  /**
   * The :ref:`load balancer type <arch_overview_load_balancing_types>` to use
   * when picking a host in the cluster.
   */
  lb_policy?:
    | Cluster_LbPolicy
    | undefined;
  /**
   * Setting this is required for specifying members of
   * :ref:`STATIC<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STATIC>`,
   * :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`
   * or :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>` clusters.
   * This field supersedes the ``hosts`` field in the v2 API.
   *
   * .. attention::
   *
   *   Setting this allows non-EDS cluster types to contain embedded EDS equivalent
   *   :ref:`endpoint assignments<envoy_v3_api_msg_config.endpoint.v3.ClusterLoadAssignment>`.
   */
  load_assignment?:
    | ClusterLoadAssignment
    | undefined;
  /**
   * Optional :ref:`active health checking <arch_overview_health_checking>`
   * configuration for the cluster. If no
   * configuration is specified no health checking will be done and all cluster
   * members will be considered healthy at all times.
   */
  health_checks?:
    | HealthCheck[]
    | undefined;
  /**
   * Optional maximum requests for a single upstream connection. This parameter
   * is respected by both the HTTP/1.1 and HTTP/2 connection pool
   * implementations. If not specified, there is no limit. Setting this
   * parameter to 1 will effectively disable keep alive.
   *
   * .. attention::
   *   This field has been deprecated in favor of the :ref:`max_requests_per_connection <envoy_v3_api_field_config.core.v3.HttpProtocolOptions.max_requests_per_connection>` field.
   *
   * @deprecated
   */
  max_requests_per_connection?:
    | number
    | undefined;
  /** Optional :ref:`circuit breaking <arch_overview_circuit_break>` for the cluster. */
  circuit_breakers?:
    | CircuitBreakers
    | undefined;
  /**
   * HTTP protocol options that are applied only to upstream HTTP connections.
   * These options apply to all HTTP versions.
   * This has been deprecated in favor of
   * :ref:`upstream_http_protocol_options <envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options>`
   * in the :ref:`http_protocol_options <envoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions>` message.
   * upstream_http_protocol_options can be set via the cluster's
   * :ref:`extension_protocol_options<envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`.
   * See :ref:`upstream_http_protocol_options
   * <envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options>`
   * for example usage.
   *
   * @deprecated
   */
  upstream_http_protocol_options?:
    | UpstreamHttpProtocolOptions
    | undefined;
  /**
   * Additional options when handling HTTP requests upstream. These options will be applicable to
   * both HTTP1 and HTTP2 requests.
   * This has been deprecated in favor of
   * :ref:`common_http_protocol_options <envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.common_http_protocol_options>`
   * in the :ref:`http_protocol_options <envoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions>` message.
   * common_http_protocol_options can be set via the cluster's
   * :ref:`extension_protocol_options<envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`.
   * See :ref:`upstream_http_protocol_options
   * <envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options>`
   * for example usage.
   *
   * @deprecated
   */
  common_http_protocol_options?:
    | HttpProtocolOptions
    | undefined;
  /**
   * Additional options when handling HTTP1 requests.
   * This has been deprecated in favor of http_protocol_options fields in the
   * :ref:`http_protocol_options <envoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions>` message.
   * http_protocol_options can be set via the cluster's
   * :ref:`extension_protocol_options<envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`.
   * See :ref:`upstream_http_protocol_options
   * <envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options>`
   * for example usage.
   *
   * @deprecated
   */
  http_protocol_options?:
    | Http1ProtocolOptions
    | undefined;
  /**
   * Even if default HTTP2 protocol options are desired, this field must be
   * set so that Envoy will assume that the upstream supports HTTP/2 when
   * making new HTTP connection pool connections. Currently, Envoy only
   * supports prior knowledge for upstream connections. Even if TLS is used
   * with ALPN, ``http2_protocol_options`` must be specified. As an aside this allows HTTP/2
   * connections to happen over plain text.
   * This has been deprecated in favor of http2_protocol_options fields in the
   * :ref:`http_protocol_options <envoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions>`
   * message. http2_protocol_options can be set via the cluster's
   * :ref:`extension_protocol_options<envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`.
   * See :ref:`upstream_http_protocol_options
   * <envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options>`
   * for example usage.
   *
   * @deprecated
   */
  http2_protocol_options?:
    | Http2ProtocolOptions
    | undefined;
  /**
   * The extension_protocol_options field is used to provide extension-specific protocol options
   * for upstream connections. The key should match the extension filter name, such as
   * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
   * specific options.
   * [#next-major-version: make this a list of typed extensions.]
   */
  typed_extension_protocol_options?:
    | Map<string, Any>
    | undefined;
  /**
   * If the DNS refresh rate is specified and the cluster type is either
   * :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`,
   * or :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
   * this value is used as the clusterâ€™s DNS refresh
   * rate. The value configured must be at least 1ms. If this setting is not specified, the
   * value defaults to 5000ms. For cluster types other than
   * :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`
   * and :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`
   * this setting is ignored.
   * This field is deprecated in favor of using the :ref:`cluster_type<envoy_v3_api_field_config.cluster.v3.Cluster.cluster_type>`
   * extension point and configuring it with :ref:`DnsCluster<envoy_v3_api_msg_extensions.clusters.dns.v3.DnsCluster>`.
   * If :ref:`cluster_type<envoy_v3_api_field_config.cluster.v3.Cluster.cluster_type>` is configured with
   * :ref:`DnsCluster<envoy_v3_api_msg_extensions.clusters.dns.v3.DnsCluster>`, this field will be ignored.
   *
   * @deprecated
   */
  dns_refresh_rate?:
    | Duration
    | undefined;
  /**
   * DNS jitter can be optionally specified if the cluster type is either
   * :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`,
   * or :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`.
   * DNS jitter causes the cluster to refresh DNS entries later by a random amount of time to avoid a
   * stampede of DNS requests. This value sets the upper bound (exclusive) for the random amount.
   * There will be no jitter if this value is omitted. For cluster types other than
   * :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`
   * and :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`
   * this setting is ignored.
   * This field is deprecated in favor of using the :ref:`cluster_type<envoy_v3_api_field_config.cluster.v3.Cluster.cluster_type>`
   * extension point and configuring it with :ref:`DnsCluster<envoy_v3_api_msg_extensions.clusters.dns.v3.DnsCluster>`.
   * If :ref:`cluster_type<envoy_v3_api_field_config.cluster.v3.Cluster.cluster_type>` is configured with
   * :ref:`DnsCluster<envoy_v3_api_msg_extensions.clusters.dns.v3.DnsCluster>`, this field will be ignored.
   *
   * @deprecated
   */
  dns_jitter?:
    | Duration
    | undefined;
  /**
   * If the DNS failure refresh rate is specified and the cluster type is either
   * :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`,
   * or :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
   * this is used as the clusterâ€™s DNS refresh rate when requests are failing. If this setting is
   * not specified, the failure refresh rate defaults to the DNS refresh rate. For cluster types
   * other than :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>` and
   * :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>` this setting is
   * ignored.
   * This field is deprecated in favor of using the :ref:`cluster_type<envoy_v3_api_field_config.cluster.v3.Cluster.cluster_type>`
   * extension point and configuring it with :ref:`DnsCluster<envoy_v3_api_msg_extensions.clusters.dns.v3.DnsCluster>`.
   * If :ref:`cluster_type<envoy_v3_api_field_config.cluster.v3.Cluster.cluster_type>` is configured with
   * :ref:`DnsCluster<envoy_v3_api_msg_extensions.clusters.dns.v3.DnsCluster>`, this field will be ignored.
   *
   * @deprecated
   */
  dns_failure_refresh_rate?:
    | Cluster_RefreshRate
    | undefined;
  /**
   * Optional configuration for setting cluster's DNS refresh rate. If the value is set to true,
   * cluster's DNS refresh rate will be set to resource record's TTL which comes from DNS
   * resolution.
   * This field is deprecated in favor of using the :ref:`cluster_type<envoy_v3_api_field_config.cluster.v3.Cluster.cluster_type>`
   * extension point and configuring it with :ref:`DnsCluster<envoy_v3_api_msg_extensions.clusters.dns.v3.DnsCluster>`.
   * If :ref:`cluster_type<envoy_v3_api_field_config.cluster.v3.Cluster.cluster_type>` is configured with
   * :ref:`DnsCluster<envoy_v3_api_msg_extensions.clusters.dns.v3.DnsCluster>`, this field will be ignored.
   *
   * @deprecated
   */
  respect_dns_ttl?:
    | boolean
    | undefined;
  /**
   * The DNS IP address resolution policy. If this setting is not specified, the
   * value defaults to
   * :ref:`AUTO<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DnsLookupFamily.AUTO>`.
   * For logical and strict dns cluster, this field is deprecated in favor of using the
   * :ref:`cluster_type<envoy_v3_api_field_config.cluster.v3.Cluster.cluster_type>`
   * extension point and configuring it with :ref:`DnsCluster<envoy_v3_api_msg_extensions.clusters.dns.v3.DnsCluster>`.
   * If :ref:`cluster_type<envoy_v3_api_field_config.cluster.v3.Cluster.cluster_type>` is configured with
   * :ref:`DnsCluster<envoy_v3_api_msg_extensions.clusters.dns.v3.DnsCluster>`, this field will be ignored.
   */
  dns_lookup_family?:
    | Cluster_DnsLookupFamily
    | undefined;
  /**
   * If DNS resolvers are specified and the cluster type is either
   * :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`,
   * or :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
   * this value is used to specify the clusterâ€™s dns resolvers.
   * If this setting is not specified, the value defaults to the default
   * resolver, which uses /etc/resolv.conf for configuration. For cluster types
   * other than
   * :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`
   * and :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`
   * this setting is ignored.
   * This field is deprecated in favor of ``dns_resolution_config``
   * which aggregates all of the DNS resolver configuration in a single message.
   *
   * @deprecated
   */
  dns_resolvers?:
    | Address[]
    | undefined;
  /**
   * Always use TCP queries instead of UDP queries for DNS lookups.
   * This field is deprecated in favor of ``dns_resolution_config``
   * which aggregates all of the DNS resolver configuration in a single message.
   *
   * @deprecated
   */
  use_tcp_for_dns_lookups?:
    | boolean
    | undefined;
  /**
   * DNS resolution configuration which includes the underlying dns resolver addresses and options.
   * This field is deprecated in favor of
   * :ref:`typed_dns_resolver_config <envoy_v3_api_field_config.cluster.v3.Cluster.typed_dns_resolver_config>`.
   *
   * @deprecated
   */
  dns_resolution_config?:
    | DnsResolutionConfig
    | undefined;
  /**
   * DNS resolver type configuration extension. This extension can be used to configure c-ares, apple,
   * or any other DNS resolver types and the related parameters.
   * For example, an object of
   * :ref:`CaresDnsResolverConfig <envoy_v3_api_msg_extensions.network.dns_resolver.cares.v3.CaresDnsResolverConfig>`
   * can be packed into this ``typed_dns_resolver_config``. This configuration replaces the
   * :ref:`dns_resolution_config <envoy_v3_api_field_config.cluster.v3.Cluster.dns_resolution_config>`
   * configuration.
   * During the transition period when both ``dns_resolution_config`` and ``typed_dns_resolver_config`` exists,
   * when ``typed_dns_resolver_config`` is in place, Envoy will use it and ignore ``dns_resolution_config``.
   * When ``typed_dns_resolver_config`` is missing, the default behavior is in place.
   * Also note that this field is deprecated for logical dns and strict dns clusters and will be ignored when
   * :ref:`cluster_type<envoy_v3_api_field_config.cluster.v3.Cluster.cluster_type>` is configured with
   * :ref:`DnsCluster<envoy_v3_api_msg_extensions.clusters.dns.v3.DnsCluster>`.
   * [#extension-category: envoy.network.dns_resolver]
   */
  typed_dns_resolver_config?:
    | TypedExtensionConfig
    | undefined;
  /**
   * Optional configuration for having cluster readiness block on warm-up. Currently, only applicable for
   * :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`,
   * or :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
   * or :ref:`Redis Cluster<arch_overview_redis>`.
   * If true, cluster readiness blocks on warm-up. If false, the cluster will complete
   * initialization whether or not warm-up has completed. Defaults to true.
   */
  wait_for_warm_on_init?:
    | boolean
    | undefined;
  /**
   * If specified, outlier detection will be enabled for this upstream cluster.
   * Each of the configuration values can be overridden via
   * :ref:`runtime values <config_cluster_manager_cluster_runtime_outlier_detection>`.
   */
  outlier_detection?:
    | OutlierDetection
    | undefined;
  /**
   * The interval for removing stale hosts from a cluster type
   * :ref:`ORIGINAL_DST<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST>`.
   * Hosts are considered stale if they have not been used
   * as upstream destinations during this interval. New hosts are added
   * to original destination clusters on demand as new connections are
   * redirected to Envoy, causing the number of hosts in the cluster to
   * grow over time. Hosts that are not stale (they are actively used as
   * destinations) are kept in the cluster, which allows connections to
   * them remain open, saving the latency that would otherwise be spent
   * on opening new connections. If this setting is not specified, the
   * value defaults to 5000ms. For cluster types other than
   * :ref:`ORIGINAL_DST<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST>`
   * this setting is ignored.
   */
  cleanup_interval?:
    | Duration
    | undefined;
  /**
   * Optional configuration used to bind newly established upstream connections.
   * This overrides any bind_config specified in the bootstrap proto.
   * If the address and port are empty, no bind will be performed.
   */
  upstream_bind_config?:
    | BindConfig
    | undefined;
  /** Configuration for load balancing subsetting. */
  lb_subset_config?:
    | Cluster_LbSubsetConfig
    | undefined;
  /**
   * Optional configuration for the load balancing algorithm selected by
   * LbPolicy. Currently only
   * :ref:`RING_HASH<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbPolicy.RING_HASH>`,
   * :ref:`MAGLEV<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbPolicy.MAGLEV>` and
   * :ref:`LEAST_REQUEST<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbPolicy.LEAST_REQUEST>`
   * has additional configuration options.
   * Specifying ring_hash_lb_config or maglev_lb_config or least_request_lb_config without setting the corresponding
   * LbPolicy will generate an error at runtime.
   */
  lb_config?:
    | //
    /** Optional configuration for the Ring Hash load balancing policy. */
    { $case: "ring_hash_lb_config"; ring_hash_lb_config: Cluster_RingHashLbConfig }
    | //
    /** Optional configuration for the Maglev load balancing policy. */
    { $case: "maglev_lb_config"; maglev_lb_config: Cluster_MaglevLbConfig }
    | //
    /** Optional configuration for the Original Destination load balancing policy. */
    { $case: "original_dst_lb_config"; original_dst_lb_config: Cluster_OriginalDstLbConfig }
    | //
    /** Optional configuration for the LeastRequest load balancing policy. */
    { $case: "least_request_lb_config"; least_request_lb_config: Cluster_LeastRequestLbConfig }
    | //
    /** Optional configuration for the RoundRobin load balancing policy. */
    { $case: "round_robin_lb_config"; round_robin_lb_config: Cluster_RoundRobinLbConfig }
    | undefined;
  /** Common configuration for all load balancer implementations. */
  common_lb_config?:
    | Cluster_CommonLbConfig
    | undefined;
  /**
   * Optional custom transport socket implementation to use for upstream connections.
   * To setup TLS, set a transport socket with name ``envoy.transport_sockets.tls`` and
   * :ref:`UpstreamTlsContexts <envoy_v3_api_msg_extensions.transport_sockets.tls.v3.UpstreamTlsContext>` in the ``typed_config``.
   * If no transport socket configuration is specified, new connections
   * will be set up with plaintext.
   */
  transport_socket?:
    | TransportSocket
    | undefined;
  /**
   * The Metadata field can be used to provide additional information about the
   * cluster. It can be used for stats, logging, and varying filter behavior.
   * Fields should use reverse DNS notation to denote which entity within Envoy
   * will need the information. For instance, if the metadata is intended for
   * the Router filter, the filter name should be specified as ``envoy.filters.http.router``.
   */
  metadata?:
    | Metadata
    | undefined;
  /**
   * Determines how Envoy selects the protocol used to speak to upstream hosts.
   * This has been deprecated in favor of setting explicit protocol selection
   * in the :ref:`http_protocol_options
   * <envoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions>` message.
   * http_protocol_options can be set via the cluster's
   * :ref:`extension_protocol_options<envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`.
   *
   * @deprecated
   */
  protocol_selection?:
    | Cluster_ClusterProtocolSelection
    | undefined;
  /** Optional options for upstream connections. */
  upstream_connection_options?:
    | UpstreamConnectionOptions
    | undefined;
  /**
   * If an upstream host becomes unhealthy (as determined by the configured health checks
   * or outlier detection), immediately close all connections to the failed host.
   *
   * .. note::
   *
   *   This is currently only supported for connections created by tcp_proxy.
   *
   * .. note::
   *
   *   The current implementation of this feature closes all connections immediately when
   *   the unhealthy status is detected. If there are a large number of connections open
   *   to an upstream host that becomes unhealthy, Envoy may spend a substantial amount of
   *   time exclusively closing these connections, and not processing any other traffic.
   */
  close_connections_on_host_health_failure?:
    | boolean
    | undefined;
  /**
   * If set to true, Envoy will ignore the health value of a host when processing its removal
   * from service discovery. This means that if active health checking is used, Envoy will *not*
   * wait for the endpoint to go unhealthy before removing it.
   */
  ignore_health_on_host_removal?:
    | boolean
    | undefined;
  /**
   * An (optional) network filter chain, listed in the order the filters should be applied.
   * The chain will be applied to all outgoing connections that Envoy makes to the upstream
   * servers of this cluster.
   */
  filters?:
    | Filter[]
    | undefined;
  /**
   * If this field is set and is supported by the client, it will supersede the value of
   * :ref:`lb_policy<envoy_v3_api_field_config.cluster.v3.Cluster.lb_policy>`.
   */
  load_balancing_policy?:
    | LoadBalancingPolicy
    | undefined;
  /**
   * [#not-implemented-hide:]
   * If present, tells the client where to send load reports via LRS. If not present, the
   * client will fall back to a client-side default, which may be either (a) don't send any
   * load reports or (b) send load reports for all clusters to a single default server
   * (which may be configured in the bootstrap file).
   *
   * Note that if multiple clusters point to the same LRS server, the client may choose to
   * create a separate stream for each cluster or it may choose to coalesce the data for
   * multiple clusters onto a single stream. Either way, the client must make sure to send
   * the data for any given cluster on no more than one stream.
   *
   * [#next-major-version: In the v3 API, we should consider restructuring this somehow,
   * maybe by allowing LRS to go on the ADS stream, or maybe by moving some of the negotiation
   * from the LRS stream here.]
   */
  lrs_server?:
    | ConfigSource
    | undefined;
  /**
   * A list of metric names from :ref:`ORCA load reports <envoy_v3_api_msg_.xds.data.orca.v3.OrcaLoadReport>` to propagate to LRS.
   *
   * If not specified, then ORCA load reports will not be propagated to LRS.
   *
   * For map fields in the ORCA proto, the string will be of the form ``<map_field_name>.<map_key>``.
   * For example, the string ``named_metrics.foo`` will mean to look for the key ``foo`` in the ORCA
   * :ref:`named_metrics <envoy_v3_api_field_.xds.data.orca.v3.OrcaLoadReport.named_metrics>` field.
   *
   * The special map key ``*`` means to report all entries in the map (e.g., ``named_metrics.*`` means to
   * report all entries in the ORCA named_metrics field). Note that this should be used only with trusted
   * backends.
   *
   * The metric names in LRS will follow the same semantics as this field. In other words, if this field
   * contains ``named_metrics.foo``, then the LRS load report will include the data with that same string
   * as the key.
   */
  lrs_report_endpoint_metrics?:
    | string[]
    | undefined;
  /**
   * If track_timeout_budgets is true, the :ref:`timeout budget histograms
   * <config_cluster_manager_cluster_stats_timeout_budgets>` will be published for each
   * request. These show what percentage of a request's per try and global timeout was used. A value
   * of 0 would indicate that none of the timeout was used or that the timeout was infinite. A value
   * of 100 would indicate that the request took the entirety of the timeout given to it.
   *
   * .. attention::
   *
   *   This field has been deprecated in favor of ``timeout_budgets``, part of
   *   :ref:`track_cluster_stats <envoy_v3_api_field_config.cluster.v3.Cluster.track_cluster_stats>`.
   *
   * @deprecated
   */
  track_timeout_budgets?:
    | boolean
    | undefined;
  /**
   * Optional customization and configuration of upstream connection pool, and upstream type.
   *
   * Currently this field only applies for HTTP traffic but is designed for eventual use for custom
   * TCP upstreams.
   *
   * For HTTP traffic, Envoy will generally take downstream HTTP and send it upstream as upstream
   * HTTP, using the http connection pool and the codec from ``http2_protocol_options``
   *
   * For routes where CONNECT termination is configured, Envoy will take downstream CONNECT
   * requests and forward the CONNECT payload upstream over raw TCP using the tcp connection pool.
   *
   * The default pool used is the generic connection pool which creates the HTTP upstream for most
   * HTTP requests, and the TCP upstream if CONNECT termination is configured.
   *
   * If users desire custom connection pool or upstream behavior, for example terminating
   * CONNECT only if a custom filter indicates it is appropriate, the custom factories
   * can be registered and configured here.
   * [#extension-category: envoy.upstreams]
   */
  upstream_config?:
    | TypedExtensionConfig
    | undefined;
  /** Configuration to track optional cluster stats. */
  track_cluster_stats?:
    | TrackClusterStats
    | undefined;
  /** Preconnect configuration for this cluster. */
  preconnect_policy?:
    | Cluster_PreconnectPolicy
    | undefined;
  /**
   * If ``connection_pool_per_downstream_connection`` is true, the cluster will use a separate
   * connection pool for every downstream connection
   */
  connection_pool_per_downstream_connection?: boolean | undefined;
}

/**
 * Refer to :ref:`service discovery type <arch_overview_service_discovery_types>`
 * for an explanation on each type.
 */
export enum Cluster_DiscoveryType {
  /**
   * STATIC - Refer to the :ref:`static discovery type<arch_overview_service_discovery_types_static>`
   * for an explanation.
   */
  STATIC = "STATIC",
  /**
   * STRICT_DNS - Refer to the :ref:`strict DNS discovery
   * type<arch_overview_service_discovery_types_strict_dns>`
   * for an explanation.
   */
  STRICT_DNS = "STRICT_DNS",
  /**
   * LOGICAL_DNS - Refer to the :ref:`logical DNS discovery
   * type<arch_overview_service_discovery_types_logical_dns>`
   * for an explanation.
   */
  LOGICAL_DNS = "LOGICAL_DNS",
  /**
   * EDS - Refer to the :ref:`service discovery type<arch_overview_service_discovery_types_eds>`
   * for an explanation.
   */
  EDS = "EDS",
  /**
   * ORIGINAL_DST - Refer to the :ref:`original destination discovery
   * type<arch_overview_service_discovery_types_original_destination>`
   * for an explanation.
   */
  ORIGINAL_DST = "ORIGINAL_DST",
}

export function cluster_DiscoveryTypeFromJSON(object: any): Cluster_DiscoveryType {
  switch (object) {
    case 0:
    case "STATIC":
      return Cluster_DiscoveryType.STATIC;
    case 1:
    case "STRICT_DNS":
      return Cluster_DiscoveryType.STRICT_DNS;
    case 2:
    case "LOGICAL_DNS":
      return Cluster_DiscoveryType.LOGICAL_DNS;
    case 3:
    case "EDS":
      return Cluster_DiscoveryType.EDS;
    case 4:
    case "ORIGINAL_DST":
      return Cluster_DiscoveryType.ORIGINAL_DST;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Cluster_DiscoveryType");
  }
}

export function cluster_DiscoveryTypeToJSON(object: Cluster_DiscoveryType): string {
  switch (object) {
    case Cluster_DiscoveryType.STATIC:
      return "STATIC";
    case Cluster_DiscoveryType.STRICT_DNS:
      return "STRICT_DNS";
    case Cluster_DiscoveryType.LOGICAL_DNS:
      return "LOGICAL_DNS";
    case Cluster_DiscoveryType.EDS:
      return "EDS";
    case Cluster_DiscoveryType.ORIGINAL_DST:
      return "ORIGINAL_DST";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Cluster_DiscoveryType");
  }
}

export function cluster_DiscoveryTypeToNumber(object: Cluster_DiscoveryType): number {
  switch (object) {
    case Cluster_DiscoveryType.STATIC:
      return 0;
    case Cluster_DiscoveryType.STRICT_DNS:
      return 1;
    case Cluster_DiscoveryType.LOGICAL_DNS:
      return 2;
    case Cluster_DiscoveryType.EDS:
      return 3;
    case Cluster_DiscoveryType.ORIGINAL_DST:
      return 4;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Cluster_DiscoveryType");
  }
}

/**
 * Refer to :ref:`load balancer type <arch_overview_load_balancing_types>` architecture
 * overview section for information on each type.
 */
export enum Cluster_LbPolicy {
  /**
   * ROUND_ROBIN - Refer to the :ref:`round robin load balancing
   * policy<arch_overview_load_balancing_types_round_robin>`
   * for an explanation.
   */
  ROUND_ROBIN = "ROUND_ROBIN",
  /**
   * LEAST_REQUEST - Refer to the :ref:`least request load balancing
   * policy<arch_overview_load_balancing_types_least_request>`
   * for an explanation.
   */
  LEAST_REQUEST = "LEAST_REQUEST",
  /**
   * RING_HASH - Refer to the :ref:`ring hash load balancing
   * policy<arch_overview_load_balancing_types_ring_hash>`
   * for an explanation.
   */
  RING_HASH = "RING_HASH",
  /**
   * RANDOM - Refer to the :ref:`random load balancing
   * policy<arch_overview_load_balancing_types_random>`
   * for an explanation.
   */
  RANDOM = "RANDOM",
  /**
   * MAGLEV - Refer to the :ref:`Maglev load balancing policy<arch_overview_load_balancing_types_maglev>`
   * for an explanation.
   */
  MAGLEV = "MAGLEV",
  /**
   * CLUSTER_PROVIDED - This load balancer type must be specified if the configured cluster provides a cluster
   * specific load balancer. Consult the configured cluster's documentation for whether to set
   * this option or not.
   */
  CLUSTER_PROVIDED = "CLUSTER_PROVIDED",
  /**
   * LOAD_BALANCING_POLICY_CONFIG - Use the new :ref:`load_balancing_policy
   * <envoy_v3_api_field_config.cluster.v3.Cluster.load_balancing_policy>` field to determine the LB policy.
   * This has been deprecated in favor of using the :ref:`load_balancing_policy
   * <envoy_v3_api_field_config.cluster.v3.Cluster.load_balancing_policy>` field without
   * setting any value in :ref:`lb_policy<envoy_v3_api_field_config.cluster.v3.Cluster.lb_policy>`.
   */
  LOAD_BALANCING_POLICY_CONFIG = "LOAD_BALANCING_POLICY_CONFIG",
}

export function cluster_LbPolicyFromJSON(object: any): Cluster_LbPolicy {
  switch (object) {
    case 0:
    case "ROUND_ROBIN":
      return Cluster_LbPolicy.ROUND_ROBIN;
    case 1:
    case "LEAST_REQUEST":
      return Cluster_LbPolicy.LEAST_REQUEST;
    case 2:
    case "RING_HASH":
      return Cluster_LbPolicy.RING_HASH;
    case 3:
    case "RANDOM":
      return Cluster_LbPolicy.RANDOM;
    case 5:
    case "MAGLEV":
      return Cluster_LbPolicy.MAGLEV;
    case 6:
    case "CLUSTER_PROVIDED":
      return Cluster_LbPolicy.CLUSTER_PROVIDED;
    case 7:
    case "LOAD_BALANCING_POLICY_CONFIG":
      return Cluster_LbPolicy.LOAD_BALANCING_POLICY_CONFIG;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Cluster_LbPolicy");
  }
}

export function cluster_LbPolicyToJSON(object: Cluster_LbPolicy): string {
  switch (object) {
    case Cluster_LbPolicy.ROUND_ROBIN:
      return "ROUND_ROBIN";
    case Cluster_LbPolicy.LEAST_REQUEST:
      return "LEAST_REQUEST";
    case Cluster_LbPolicy.RING_HASH:
      return "RING_HASH";
    case Cluster_LbPolicy.RANDOM:
      return "RANDOM";
    case Cluster_LbPolicy.MAGLEV:
      return "MAGLEV";
    case Cluster_LbPolicy.CLUSTER_PROVIDED:
      return "CLUSTER_PROVIDED";
    case Cluster_LbPolicy.LOAD_BALANCING_POLICY_CONFIG:
      return "LOAD_BALANCING_POLICY_CONFIG";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Cluster_LbPolicy");
  }
}

export function cluster_LbPolicyToNumber(object: Cluster_LbPolicy): number {
  switch (object) {
    case Cluster_LbPolicy.ROUND_ROBIN:
      return 0;
    case Cluster_LbPolicy.LEAST_REQUEST:
      return 1;
    case Cluster_LbPolicy.RING_HASH:
      return 2;
    case Cluster_LbPolicy.RANDOM:
      return 3;
    case Cluster_LbPolicy.MAGLEV:
      return 5;
    case Cluster_LbPolicy.CLUSTER_PROVIDED:
      return 6;
    case Cluster_LbPolicy.LOAD_BALANCING_POLICY_CONFIG:
      return 7;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Cluster_LbPolicy");
  }
}

/**
 * When V4_ONLY is selected, the DNS resolver will only perform a lookup for
 * addresses in the IPv4 family. If V6_ONLY is selected, the DNS resolver will
 * only perform a lookup for addresses in the IPv6 family. If AUTO is
 * specified, the DNS resolver will first perform a lookup for addresses in
 * the IPv6 family and fallback to a lookup for addresses in the IPv4 family.
 * This is semantically equivalent to a non-existent V6_PREFERRED option.
 * AUTO is a legacy name that is more opaque than
 * necessary and will be deprecated in favor of V6_PREFERRED in a future major version of the API.
 * If V4_PREFERRED is specified, the DNS resolver will first perform a lookup for addresses in the
 * IPv4 family and fallback to a lookup for addresses in the IPv6 family. i.e., the callback
 * target will only get v6 addresses if there were NO v4 addresses to return.
 * If ALL is specified, the DNS resolver will perform a lookup for both IPv4 and IPv6 families,
 * and return all resolved addresses. When this is used, Happy Eyeballs will be enabled for
 * upstream connections. Refer to :ref:`Happy Eyeballs Support <arch_overview_happy_eyeballs>`
 * for more information.
 * For cluster types other than
 * :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>` and
 * :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
 * this setting is
 * ignored.
 * [#next-major-version: deprecate AUTO in favor of a V6_PREFERRED option.]
 */
export enum Cluster_DnsLookupFamily {
  AUTO = "AUTO",
  V4_ONLY = "V4_ONLY",
  V6_ONLY = "V6_ONLY",
  V4_PREFERRED = "V4_PREFERRED",
  ALL = "ALL",
}

export function cluster_DnsLookupFamilyFromJSON(object: any): Cluster_DnsLookupFamily {
  switch (object) {
    case 0:
    case "AUTO":
      return Cluster_DnsLookupFamily.AUTO;
    case 1:
    case "V4_ONLY":
      return Cluster_DnsLookupFamily.V4_ONLY;
    case 2:
    case "V6_ONLY":
      return Cluster_DnsLookupFamily.V6_ONLY;
    case 3:
    case "V4_PREFERRED":
      return Cluster_DnsLookupFamily.V4_PREFERRED;
    case 4:
    case "ALL":
      return Cluster_DnsLookupFamily.ALL;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Cluster_DnsLookupFamily");
  }
}

export function cluster_DnsLookupFamilyToJSON(object: Cluster_DnsLookupFamily): string {
  switch (object) {
    case Cluster_DnsLookupFamily.AUTO:
      return "AUTO";
    case Cluster_DnsLookupFamily.V4_ONLY:
      return "V4_ONLY";
    case Cluster_DnsLookupFamily.V6_ONLY:
      return "V6_ONLY";
    case Cluster_DnsLookupFamily.V4_PREFERRED:
      return "V4_PREFERRED";
    case Cluster_DnsLookupFamily.ALL:
      return "ALL";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Cluster_DnsLookupFamily");
  }
}

export function cluster_DnsLookupFamilyToNumber(object: Cluster_DnsLookupFamily): number {
  switch (object) {
    case Cluster_DnsLookupFamily.AUTO:
      return 0;
    case Cluster_DnsLookupFamily.V4_ONLY:
      return 1;
    case Cluster_DnsLookupFamily.V6_ONLY:
      return 2;
    case Cluster_DnsLookupFamily.V4_PREFERRED:
      return 3;
    case Cluster_DnsLookupFamily.ALL:
      return 4;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Cluster_DnsLookupFamily");
  }
}

export enum Cluster_ClusterProtocolSelection {
  /**
   * USE_CONFIGURED_PROTOCOL - Cluster can only operate on one of the possible upstream protocols (HTTP1.1, HTTP2).
   * If :ref:`http2_protocol_options <envoy_v3_api_field_config.cluster.v3.Cluster.http2_protocol_options>` are
   * present, HTTP2 will be used, otherwise HTTP1.1 will be used.
   */
  USE_CONFIGURED_PROTOCOL = "USE_CONFIGURED_PROTOCOL",
  /** USE_DOWNSTREAM_PROTOCOL - Use HTTP1.1 or HTTP2, depending on which one is used on the downstream connection. */
  USE_DOWNSTREAM_PROTOCOL = "USE_DOWNSTREAM_PROTOCOL",
}

export function cluster_ClusterProtocolSelectionFromJSON(object: any): Cluster_ClusterProtocolSelection {
  switch (object) {
    case 0:
    case "USE_CONFIGURED_PROTOCOL":
      return Cluster_ClusterProtocolSelection.USE_CONFIGURED_PROTOCOL;
    case 1:
    case "USE_DOWNSTREAM_PROTOCOL":
      return Cluster_ClusterProtocolSelection.USE_DOWNSTREAM_PROTOCOL;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Cluster_ClusterProtocolSelection");
  }
}

export function cluster_ClusterProtocolSelectionToJSON(object: Cluster_ClusterProtocolSelection): string {
  switch (object) {
    case Cluster_ClusterProtocolSelection.USE_CONFIGURED_PROTOCOL:
      return "USE_CONFIGURED_PROTOCOL";
    case Cluster_ClusterProtocolSelection.USE_DOWNSTREAM_PROTOCOL:
      return "USE_DOWNSTREAM_PROTOCOL";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Cluster_ClusterProtocolSelection");
  }
}

export function cluster_ClusterProtocolSelectionToNumber(object: Cluster_ClusterProtocolSelection): number {
  switch (object) {
    case Cluster_ClusterProtocolSelection.USE_CONFIGURED_PROTOCOL:
      return 0;
    case Cluster_ClusterProtocolSelection.USE_DOWNSTREAM_PROTOCOL:
      return 1;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Cluster_ClusterProtocolSelection");
  }
}

/**
 * TransportSocketMatch specifies what transport socket config will be used
 * when the match conditions are satisfied.
 */
export interface Cluster_TransportSocketMatch {
  $type: "envoy.config.cluster.v3.Cluster.TransportSocketMatch";
  /** The name of the match, used in stats generation. */
  name?:
    | string
    | undefined;
  /**
   * Optional metadata match criteria.
   * The connection to the endpoint with metadata matching what is set in this field
   * will use the transport socket configuration specified here.
   * The endpoint's metadata entry in ``envoy.transport_socket_match`` is used to match
   * against the values specified in this field.
   */
  match?:
    | { [key: string]: any }
    | undefined;
  /**
   * The configuration of the transport socket.
   * [#extension-category: envoy.transport_sockets.upstream]
   */
  transport_socket?: TransportSocket | undefined;
}

/** Extended cluster type. */
export interface Cluster_CustomClusterType {
  $type: "envoy.config.cluster.v3.Cluster.CustomClusterType";
  /** The type of the cluster to instantiate. The name must match a supported cluster type. */
  name?:
    | string
    | undefined;
  /**
   * Cluster specific configuration which depends on the cluster being instantiated.
   * See the supported cluster for further documentation.
   * [#extension-category: envoy.clusters]
   */
  typed_config?: Any | undefined;
}

/** Only valid when discovery type is EDS. */
export interface Cluster_EdsClusterConfig {
  $type: "envoy.config.cluster.v3.Cluster.EdsClusterConfig";
  /** Configuration for the source of EDS updates for this Cluster. */
  eds_config?:
    | ConfigSource
    | undefined;
  /**
   * Optional alternative to cluster name to present to EDS. This does not
   * have the same restrictions as cluster name, i.e. it may be arbitrary
   * length. This may be a xdstp:// URL.
   */
  service_name?: string | undefined;
}

/**
 * Optionally divide the endpoints in this cluster into subsets defined by
 * endpoint metadata and selected by route and weighted cluster metadata.
 * [#next-free-field: 9]
 */
export interface Cluster_LbSubsetConfig {
  $type: "envoy.config.cluster.v3.Cluster.LbSubsetConfig";
  /**
   * The behavior used when no endpoint subset matches the selected route's
   * metadata. The value defaults to
   * :ref:`NO_FALLBACK<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK>`.
   */
  fallback_policy?:
    | Cluster_LbSubsetConfig_LbSubsetFallbackPolicy
    | undefined;
  /**
   * Specifies the default subset of endpoints used during fallback if
   * fallback_policy is
   * :ref:`DEFAULT_SUBSET<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET>`.
   * Each field in default_subset is
   * compared to the matching LbEndpoint.Metadata under the ``envoy.lb``
   * namespace. It is valid for no hosts to match, in which case the behavior
   * is the same as a fallback_policy of
   * :ref:`NO_FALLBACK<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK>`.
   */
  default_subset?:
    | { [key: string]: any }
    | undefined;
  /**
   * For each entry, LbEndpoint.Metadata's
   * ``envoy.lb`` namespace is traversed and a subset is created for each unique
   * combination of key and value. For example:
   *
   * .. code-block:: json
   *
   *   { "subset_selectors": [
   *       { "keys": [ "version" ] },
   *       { "keys": [ "stage", "hardware_type" ] }
   *   ]}
   *
   * A subset is matched when the metadata from the selected route and
   * weighted cluster contains the same keys and values as the subset's
   * metadata. The same host may appear in multiple subsets.
   */
  subset_selectors?:
    | Cluster_LbSubsetConfig_LbSubsetSelector[]
    | undefined;
  /**
   * If true, routing to subsets will take into account the localities and locality weights of the
   * endpoints when making the routing decision.
   *
   * There are some potential pitfalls associated with enabling this feature, as the resulting
   * traffic split after applying both a subset match and locality weights might be undesirable.
   *
   * Consider for example a situation in which you have 50/50 split across two localities X/Y
   * which have 100 hosts each without subsetting. If the subset LB results in X having only 1
   * host selected but Y having 100, then a lot more load is being dumped on the single host in X
   * than originally anticipated in the load balancing assignment delivered via EDS.
   */
  locality_weight_aware?:
    | boolean
    | undefined;
  /**
   * When used with locality_weight_aware, scales the weight of each locality by the ratio
   * of hosts in the subset vs hosts in the original subset. This aims to even out the load
   * going to an individual locality if said locality is disproportionately affected by the
   * subset predicate.
   */
  scale_locality_weight?:
    | boolean
    | undefined;
  /**
   * If true, when a fallback policy is configured and its corresponding subset fails to find
   * a host this will cause any host to be selected instead.
   *
   * This is useful when using the default subset as the fallback policy, given the default
   * subset might become empty. With this option enabled, if that happens the LB will attempt
   * to select a host from the entire cluster.
   */
  panic_mode_any?:
    | boolean
    | undefined;
  /**
   * If true, metadata specified for a metadata key will be matched against the corresponding
   * endpoint metadata if the endpoint metadata matches the value exactly OR it is a list value
   * and any of the elements in the list matches the criteria.
   */
  list_as_any?:
    | boolean
    | undefined;
  /**
   * Fallback mechanism that allows to try different route metadata until a host is found.
   * If load balancing process, including all its mechanisms (like
   * :ref:`fallback_policy<envoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.fallback_policy>`)
   * fails to select a host, this policy decides if and how the process is repeated using another metadata.
   *
   * The value defaults to
   * :ref:`METADATA_NO_FALLBACK<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetMetadataFallbackPolicy.METADATA_NO_FALLBACK>`.
   */
  metadata_fallback_policy?: Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy | undefined;
}

/**
 * If NO_FALLBACK is selected, a result
 * equivalent to no healthy hosts is reported. If ANY_ENDPOINT is selected,
 * any cluster endpoint may be returned (subject to policy, health checks,
 * etc). If DEFAULT_SUBSET is selected, load balancing is performed over the
 * endpoints matching the values from the default_subset field.
 */
export enum Cluster_LbSubsetConfig_LbSubsetFallbackPolicy {
  NO_FALLBACK = "NO_FALLBACK",
  ANY_ENDPOINT = "ANY_ENDPOINT",
  DEFAULT_SUBSET = "DEFAULT_SUBSET",
}

export function cluster_LbSubsetConfig_LbSubsetFallbackPolicyFromJSON(
  object: any,
): Cluster_LbSubsetConfig_LbSubsetFallbackPolicy {
  switch (object) {
    case 0:
    case "NO_FALLBACK":
      return Cluster_LbSubsetConfig_LbSubsetFallbackPolicy.NO_FALLBACK;
    case 1:
    case "ANY_ENDPOINT":
      return Cluster_LbSubsetConfig_LbSubsetFallbackPolicy.ANY_ENDPOINT;
    case 2:
    case "DEFAULT_SUBSET":
      return Cluster_LbSubsetConfig_LbSubsetFallbackPolicy.DEFAULT_SUBSET;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum Cluster_LbSubsetConfig_LbSubsetFallbackPolicy",
      );
  }
}

export function cluster_LbSubsetConfig_LbSubsetFallbackPolicyToJSON(
  object: Cluster_LbSubsetConfig_LbSubsetFallbackPolicy,
): string {
  switch (object) {
    case Cluster_LbSubsetConfig_LbSubsetFallbackPolicy.NO_FALLBACK:
      return "NO_FALLBACK";
    case Cluster_LbSubsetConfig_LbSubsetFallbackPolicy.ANY_ENDPOINT:
      return "ANY_ENDPOINT";
    case Cluster_LbSubsetConfig_LbSubsetFallbackPolicy.DEFAULT_SUBSET:
      return "DEFAULT_SUBSET";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum Cluster_LbSubsetConfig_LbSubsetFallbackPolicy",
      );
  }
}

export function cluster_LbSubsetConfig_LbSubsetFallbackPolicyToNumber(
  object: Cluster_LbSubsetConfig_LbSubsetFallbackPolicy,
): number {
  switch (object) {
    case Cluster_LbSubsetConfig_LbSubsetFallbackPolicy.NO_FALLBACK:
      return 0;
    case Cluster_LbSubsetConfig_LbSubsetFallbackPolicy.ANY_ENDPOINT:
      return 1;
    case Cluster_LbSubsetConfig_LbSubsetFallbackPolicy.DEFAULT_SUBSET:
      return 2;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum Cluster_LbSubsetConfig_LbSubsetFallbackPolicy",
      );
  }
}

export enum Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy {
  /** METADATA_NO_FALLBACK - No fallback. Route metadata will be used as-is. */
  METADATA_NO_FALLBACK = "METADATA_NO_FALLBACK",
  /**
   * FALLBACK_LIST - A special metadata key ``fallback_list`` will be used to provide variants of metadata to try.
   * Value of ``fallback_list`` key has to be a list. Every list element has to be a struct - it will
   * be merged with route metadata, overriding keys that appear in both places.
   * ``fallback_list`` entries will be used in order until a host is found.
   *
   * ``fallback_list`` key itself is removed from metadata before subset load balancing is performed.
   *
   * Example:
   *
   * for metadata:
   *
   * .. code-block:: yaml
   *
   *   version: 1.0
   *   fallback_list:
   *     - version: 2.0
   *       hardware: c64
   *     - hardware: c32
   *     - version: 3.0
   *
   * at first, metadata:
   *
   * .. code-block:: json
   *
   *   {"version": "2.0", "hardware": "c64"}
   *
   * will be used for load balancing. If no host is found, metadata:
   *
   * .. code-block:: json
   *
   *   {"version": "1.0", "hardware": "c32"}
   *
   * is next to try. If it still results in no host, finally metadata:
   *
   * .. code-block:: json
   *
   *   {"version": "3.0"}
   *
   * is used.
   */
  FALLBACK_LIST = "FALLBACK_LIST",
}

export function cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicyFromJSON(
  object: any,
): Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy {
  switch (object) {
    case 0:
    case "METADATA_NO_FALLBACK":
      return Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy.METADATA_NO_FALLBACK;
    case 1:
    case "FALLBACK_LIST":
      return Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy.FALLBACK_LIST;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy",
      );
  }
}

export function cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicyToJSON(
  object: Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy,
): string {
  switch (object) {
    case Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy.METADATA_NO_FALLBACK:
      return "METADATA_NO_FALLBACK";
    case Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy.FALLBACK_LIST:
      return "FALLBACK_LIST";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy",
      );
  }
}

export function cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicyToNumber(
  object: Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy,
): number {
  switch (object) {
    case Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy.METADATA_NO_FALLBACK:
      return 0;
    case Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy.FALLBACK_LIST:
      return 1;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy",
      );
  }
}

/** Specifications for subsets. */
export interface Cluster_LbSubsetConfig_LbSubsetSelector {
  $type: "envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector";
  /** List of keys to match with the weighted cluster metadata. */
  keys?:
    | string[]
    | undefined;
  /**
   * Selects a mode of operation in which each subset has only one host. This mode uses the same rules for
   * choosing a host, but updating hosts is faster, especially for large numbers of hosts.
   *
   * If a match is found to a host, that host will be used regardless of priority levels.
   *
   * When this mode is enabled, configurations that contain more than one host with the same metadata value for the single key in ``keys``
   * will use only one of the hosts with the given key; no requests will be routed to the others. The cluster gauge
   * :ref:`lb_subsets_single_host_per_subset_duplicate<config_cluster_manager_cluster_stats_subset_lb>` indicates how many duplicates are
   * present in the current configuration.
   */
  single_host_per_subset?:
    | boolean
    | undefined;
  /**
   * The behavior used when no endpoint subset matches the selected route's
   * metadata.
   */
  fallback_policy?:
    | Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy
    | undefined;
  /**
   * Subset of
   * :ref:`keys<envoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys>` used by
   * :ref:`KEYS_SUBSET<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.KEYS_SUBSET>`
   * fallback policy.
   * It has to be a non empty list if KEYS_SUBSET fallback policy is selected.
   * For any other fallback policy the parameter is not used and should not be set.
   * Only values also present in
   * :ref:`keys<envoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys>` are allowed, but
   * ``fallback_keys_subset`` cannot be equal to ``keys``.
   */
  fallback_keys_subset?: string[] | undefined;
}

/** Allows to override top level fallback policy per selector. */
export enum Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy {
  /** NOT_DEFINED - If NOT_DEFINED top level config fallback policy is used instead. */
  NOT_DEFINED = "NOT_DEFINED",
  /** NO_FALLBACK - If NO_FALLBACK is selected, a result equivalent to no healthy hosts is reported. */
  NO_FALLBACK = "NO_FALLBACK",
  /**
   * ANY_ENDPOINT - If ANY_ENDPOINT is selected, any cluster endpoint may be returned
   * (subject to policy, health checks, etc).
   */
  ANY_ENDPOINT = "ANY_ENDPOINT",
  /**
   * DEFAULT_SUBSET - If DEFAULT_SUBSET is selected, load balancing is performed over the
   * endpoints matching the values from the default_subset field.
   */
  DEFAULT_SUBSET = "DEFAULT_SUBSET",
  /**
   * KEYS_SUBSET - If KEYS_SUBSET is selected, subset selector matching is performed again with metadata
   * keys reduced to
   * :ref:`fallback_keys_subset<envoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.fallback_keys_subset>`.
   * It allows for a fallback to a different, less specific selector if some of the keys of
   * the selector are considered optional.
   */
  KEYS_SUBSET = "KEYS_SUBSET",
}

export function cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicyFromJSON(
  object: any,
): Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy {
  switch (object) {
    case 0:
    case "NOT_DEFINED":
      return Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.NOT_DEFINED;
    case 1:
    case "NO_FALLBACK":
      return Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.NO_FALLBACK;
    case 2:
    case "ANY_ENDPOINT":
      return Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.ANY_ENDPOINT;
    case 3:
    case "DEFAULT_SUBSET":
      return Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.DEFAULT_SUBSET;
    case 4:
    case "KEYS_SUBSET":
      return Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.KEYS_SUBSET;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object +
          " for enum Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy",
      );
  }
}

export function cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicyToJSON(
  object: Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy,
): string {
  switch (object) {
    case Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.NOT_DEFINED:
      return "NOT_DEFINED";
    case Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.NO_FALLBACK:
      return "NO_FALLBACK";
    case Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.ANY_ENDPOINT:
      return "ANY_ENDPOINT";
    case Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.DEFAULT_SUBSET:
      return "DEFAULT_SUBSET";
    case Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.KEYS_SUBSET:
      return "KEYS_SUBSET";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object +
          " for enum Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy",
      );
  }
}

export function cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicyToNumber(
  object: Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy,
): number {
  switch (object) {
    case Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.NOT_DEFINED:
      return 0;
    case Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.NO_FALLBACK:
      return 1;
    case Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.ANY_ENDPOINT:
      return 2;
    case Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.DEFAULT_SUBSET:
      return 3;
    case Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.KEYS_SUBSET:
      return 4;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object +
          " for enum Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy",
      );
  }
}

/** Configuration for :ref:`slow start mode <arch_overview_load_balancing_slow_start>`. */
export interface Cluster_SlowStartConfig {
  $type: "envoy.config.cluster.v3.Cluster.SlowStartConfig";
  /**
   * Represents the size of slow start window.
   * If set, the newly created host remains in slow start mode starting from its creation time
   * for the duration of slow start window.
   */
  slow_start_window?:
    | Duration
    | undefined;
  /**
   * This parameter controls the speed of traffic increase over the slow start window. Defaults to 1.0,
   * so that endpoint would get linearly increasing amount of traffic.
   * When increasing the value for this parameter, the speed of traffic ramp-up increases non-linearly.
   * The value of aggression parameter should be greater than 0.0.
   * By tuning the parameter, is possible to achieve polynomial or exponential shape of ramp-up curve.
   *
   * During slow start window, effective weight of an endpoint would be scaled with time factor and aggression:
   * ``new_weight = weight * max(min_weight_percent, time_factor ^ (1 / aggression))``,
   * where ``time_factor=(time_since_start_seconds / slow_start_time_seconds)``.
   *
   * As time progresses, more and more traffic would be sent to endpoint, which is in slow start window.
   * Once host exits slow start, time_factor and aggression no longer affect its weight.
   */
  aggression?:
    | RuntimeDouble
    | undefined;
  /**
   * Configures the minimum percentage of origin weight that avoids too small new weight,
   * which may cause endpoints in slow start mode receive no traffic in slow start window.
   * If not specified, the default is 10%.
   */
  min_weight_percent?: Percent | undefined;
}

/** Specific configuration for the RoundRobin load balancing policy. */
export interface Cluster_RoundRobinLbConfig {
  $type: "envoy.config.cluster.v3.Cluster.RoundRobinLbConfig";
  /**
   * Configuration for slow start mode.
   * If this configuration is not set, slow start will not be not enabled.
   */
  slow_start_config?: Cluster_SlowStartConfig | undefined;
}

/** Specific configuration for the LeastRequest load balancing policy. */
export interface Cluster_LeastRequestLbConfig {
  $type: "envoy.config.cluster.v3.Cluster.LeastRequestLbConfig";
  /**
   * The number of random healthy hosts from which the host with the fewest active requests will
   * be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
   */
  choice_count?:
    | number
    | undefined;
  /**
   * The following formula is used to calculate the dynamic weights when hosts have different load
   * balancing weights:
   *
   * ``weight = load_balancing_weight / (active_requests + 1)^active_request_bias``
   *
   * The larger the active request bias is, the more aggressively active requests will lower the
   * effective weight when all host weights are not equal.
   *
   * ``active_request_bias`` must be greater than or equal to 0.0.
   *
   * When ``active_request_bias == 0.0`` the Least Request Load Balancer doesn't consider the number
   * of active requests at the time it picks a host and behaves like the Round Robin Load
   * Balancer.
   *
   * When ``active_request_bias > 0.0`` the Least Request Load Balancer scales the load balancing
   * weight by the number of active requests at the time it does a pick.
   *
   * The value is cached for performance reasons and refreshed whenever one of the Load Balancer's
   * host sets changes, e.g., whenever there is a host membership update or a host load balancing
   * weight change.
   *
   * .. note::
   *   This setting only takes effect if all host weights are not equal.
   */
  active_request_bias?:
    | RuntimeDouble
    | undefined;
  /**
   * Configuration for slow start mode.
   * If this configuration is not set, slow start will not be not enabled.
   */
  slow_start_config?: Cluster_SlowStartConfig | undefined;
}

/**
 * Specific configuration for the :ref:`RingHash<arch_overview_load_balancing_types_ring_hash>`
 * load balancing policy.
 */
export interface Cluster_RingHashLbConfig {
  $type: "envoy.config.cluster.v3.Cluster.RingHashLbConfig";
  /**
   * Minimum hash ring size. The larger the ring is (that is, the more hashes there are for each
   * provided host) the better the request distribution will reflect the desired weights. Defaults
   * to 1024 entries, and limited to 8M entries. See also
   * :ref:`maximum_ring_size<envoy_v3_api_field_config.cluster.v3.Cluster.RingHashLbConfig.maximum_ring_size>`.
   */
  minimum_ring_size?:
    | number
    | undefined;
  /**
   * The hash function used to hash hosts onto the ketama ring. The value defaults to
   * :ref:`XX_HASH<envoy_v3_api_enum_value_config.cluster.v3.Cluster.RingHashLbConfig.HashFunction.XX_HASH>`.
   */
  hash_function?:
    | Cluster_RingHashLbConfig_HashFunction
    | undefined;
  /**
   * Maximum hash ring size. Defaults to 8M entries, and limited to 8M entries, but can be lowered
   * to further constrain resource use. See also
   * :ref:`minimum_ring_size<envoy_v3_api_field_config.cluster.v3.Cluster.RingHashLbConfig.minimum_ring_size>`.
   */
  maximum_ring_size?: number | undefined;
}

/** The hash function used to hash hosts onto the ketama ring. */
export enum Cluster_RingHashLbConfig_HashFunction {
  /** XX_HASH - Use `xxHash <https://github.com/Cyan4973/xxHash>`_, this is the default hash function. */
  XX_HASH = "XX_HASH",
  /**
   * MURMUR_HASH_2 - Use `MurmurHash2 <https://sites.google.com/site/murmurhash/>`_, this is compatible with
   * std:hash<string> in GNU libstdc++ 3.4.20 or above. This is typically the case when compiled
   * on Linux and not macOS.
   */
  MURMUR_HASH_2 = "MURMUR_HASH_2",
}

export function cluster_RingHashLbConfig_HashFunctionFromJSON(object: any): Cluster_RingHashLbConfig_HashFunction {
  switch (object) {
    case 0:
    case "XX_HASH":
      return Cluster_RingHashLbConfig_HashFunction.XX_HASH;
    case 1:
    case "MURMUR_HASH_2":
      return Cluster_RingHashLbConfig_HashFunction.MURMUR_HASH_2;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum Cluster_RingHashLbConfig_HashFunction",
      );
  }
}

export function cluster_RingHashLbConfig_HashFunctionToJSON(object: Cluster_RingHashLbConfig_HashFunction): string {
  switch (object) {
    case Cluster_RingHashLbConfig_HashFunction.XX_HASH:
      return "XX_HASH";
    case Cluster_RingHashLbConfig_HashFunction.MURMUR_HASH_2:
      return "MURMUR_HASH_2";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum Cluster_RingHashLbConfig_HashFunction",
      );
  }
}

export function cluster_RingHashLbConfig_HashFunctionToNumber(object: Cluster_RingHashLbConfig_HashFunction): number {
  switch (object) {
    case Cluster_RingHashLbConfig_HashFunction.XX_HASH:
      return 0;
    case Cluster_RingHashLbConfig_HashFunction.MURMUR_HASH_2:
      return 1;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum Cluster_RingHashLbConfig_HashFunction",
      );
  }
}

/**
 * Specific configuration for the :ref:`Maglev<arch_overview_load_balancing_types_maglev>`
 * load balancing policy.
 */
export interface Cluster_MaglevLbConfig {
  $type: "envoy.config.cluster.v3.Cluster.MaglevLbConfig";
  /**
   * The table size for Maglev hashing. Maglev aims for "minimal disruption" rather than an absolute guarantee.
   * Minimal disruption means that when the set of upstream hosts change, a connection will likely be sent to the same
   * upstream as it was before. Increasing the table size reduces the amount of disruption.
   * The table size must be prime number limited to 5000011. If it is not specified, the default is 65537.
   */
  table_size?: number | undefined;
}

/**
 * Specific configuration for the
 * :ref:`Original Destination <arch_overview_load_balancing_types_original_destination>`
 * load balancing policy.
 * [#extension: envoy.clusters.original_dst]
 */
export interface Cluster_OriginalDstLbConfig {
  $type: "envoy.config.cluster.v3.Cluster.OriginalDstLbConfig";
  /**
   * When true, a HTTP header can be used to override the original dst address. The default header is
   * :ref:`x-envoy-original-dst-host <config_http_conn_man_headers_x-envoy-original-dst-host>`.
   *
   * .. attention::
   *
   *   This header isn't sanitized by default, so enabling this feature allows HTTP clients to
   *   route traffic to arbitrary hosts and/or ports, which may have serious security
   *   consequences.
   *
   * .. note::
   *
   *   If the header appears multiple times only the first value is used.
   */
  use_http_header?:
    | boolean
    | undefined;
  /**
   * The http header to override destination address if :ref:`use_http_header <envoy_v3_api_field_config.cluster.v3.Cluster.OriginalDstLbConfig.use_http_header>`.
   * is set to true. If the value is empty, :ref:`x-envoy-original-dst-host <config_http_conn_man_headers_x-envoy-original-dst-host>` will be used.
   */
  http_header_name?:
    | string
    | undefined;
  /**
   * The port to override for the original dst address. This port
   * will take precedence over filter state and header override ports
   */
  upstream_port_override?:
    | number
    | undefined;
  /**
   * The dynamic metadata key to override destination address.
   * First the request metadata is considered, then the connection one.
   */
  metadata_key?: MetadataKey | undefined;
}

/**
 * Common configuration for all load balancer implementations.
 * [#next-free-field: 9]
 */
export interface Cluster_CommonLbConfig {
  $type: "envoy.config.cluster.v3.Cluster.CommonLbConfig";
  /**
   * Configures the :ref:`healthy panic threshold <arch_overview_load_balancing_panic_threshold>`.
   * If not specified, the default is 50%.
   * To disable panic mode, set to 0%.
   *
   * .. note::
   *   The specified percent will be truncated to the nearest 1%.
   */
  healthy_panic_threshold?: Percent | undefined;
  locality_config_specifier?:
    | //
    { $case: "zone_aware_lb_config"; zone_aware_lb_config: Cluster_CommonLbConfig_ZoneAwareLbConfig }
    | //
    {
      $case: "locality_weighted_lb_config";
      locality_weighted_lb_config: Cluster_CommonLbConfig_LocalityWeightedLbConfig;
    }
    | undefined;
  /**
   * If set, all health check/weight/metadata updates that happen within this duration will be
   * merged and delivered in one shot when the duration expires. The start of the duration is when
   * the first update happens. This is useful for big clusters, with potentially noisy deploys
   * that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
   * or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
   * cluster). Please always keep in mind that the use of sandbox technologies may change this
   * behavior.
   *
   * If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
   * window to 0.
   *
   * Note: merging does not apply to cluster membership changes (e.g.: adds/removes); this is
   * because merging those updates isn't currently safe. See
   * https://github.com/envoyproxy/envoy/pull/3941.
   */
  update_merge_window?:
    | Duration
    | undefined;
  /**
   * If set to true, Envoy will :ref:`exclude <arch_overview_load_balancing_excluded>` new hosts
   * when computing load balancing weights until they have been health checked for the first time.
   * This will have no effect unless active health checking is also configured.
   */
  ignore_new_hosts_until_first_hc?:
    | boolean
    | undefined;
  /**
   * If set to ``true``, the cluster manager will drain all existing
   * connections to upstream hosts whenever hosts are added or removed from the cluster.
   */
  close_connections_on_host_set_change?:
    | boolean
    | undefined;
  /** Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.) */
  consistent_hashing_lb_config?:
    | Cluster_CommonLbConfig_ConsistentHashingLbConfig
    | undefined;
  /**
   * This controls what hosts are considered valid when using
   * :ref:`host overrides <arch_overview_load_balancing_override_host>`, which is used by some
   * filters to modify the load balancing decision.
   *
   * If this is unset then [UNKNOWN, HEALTHY, DEGRADED] will be applied by default. If this is
   * set with an empty set of statuses then host overrides will be ignored by the load balancing.
   */
  override_host_status?: HealthStatusSet | undefined;
}

/**
 * Configuration for :ref:`zone aware routing
 * <arch_overview_load_balancing_zone_aware_routing>`.
 */
export interface Cluster_CommonLbConfig_ZoneAwareLbConfig {
  $type: "envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig";
  /**
   * Configures percentage of requests that will be considered for zone aware routing
   * if zone aware routing is configured. If not specified, the default is 100%.
   * * :ref:`runtime values <config_cluster_manager_cluster_runtime_zone_routing>`.
   * * :ref:`Zone aware routing support <arch_overview_load_balancing_zone_aware_routing>`.
   */
  routing_enabled?:
    | Percent
    | undefined;
  /**
   * Configures minimum upstream cluster size required for zone aware routing
   * If upstream cluster size is less than specified, zone aware routing is not performed
   * even if zone aware routing is configured. If not specified, the default is 6.
   * * :ref:`runtime values <config_cluster_manager_cluster_runtime_zone_routing>`.
   * * :ref:`Zone aware routing support <arch_overview_load_balancing_zone_aware_routing>`.
   */
  min_cluster_size?:
    | number
    | undefined;
  /**
   * If set to true, Envoy will not consider any hosts when the cluster is in :ref:`panic
   * mode<arch_overview_load_balancing_panic_threshold>`. Instead, the cluster will fail all
   * requests as if all hosts are unhealthy. This can help avoid potentially overwhelming a
   * failing service.
   */
  fail_traffic_on_panic?: boolean | undefined;
}

/**
 * Configuration for :ref:`locality weighted load balancing
 * <arch_overview_load_balancing_locality_weighted_lb>`
 */
export interface Cluster_CommonLbConfig_LocalityWeightedLbConfig {
  $type: "envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig";
}

/** Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.) */
export interface Cluster_CommonLbConfig_ConsistentHashingLbConfig {
  $type: "envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig";
  /**
   * If set to ``true``, the cluster will use hostname instead of the resolved
   * address as the key to consistently hash to an upstream host. Only valid for StrictDNS clusters with hostnames which resolve to a single IP address.
   */
  use_hostname_for_hashing?:
    | boolean
    | undefined;
  /**
   * Configures percentage of average cluster load to bound per upstream host. For example, with a value of 150
   * no upstream host will get a load more than 1.5 times the average load of all the hosts in the cluster.
   * If not specified, the load is not bounded for any upstream host. Typical value for this parameter is between 120 and 200.
   * Minimum is 100.
   *
   * Applies to both Ring Hash and Maglev load balancers.
   *
   * This is implemented based on the method described in the paper https://arxiv.org/abs/1608.01350. For the specified
   * ``hash_balance_factor``, requests to any upstream host are capped at ``hash_balance_factor/100`` times the average number of requests
   * across the cluster. When a request arrives for an upstream host that is currently serving at its max capacity, linear probing
   * is used to identify an eligible host. Further, the linear probe is implemented using a random jump in hosts ring/table to identify
   * the eligible host (this technique is as described in the paper https://arxiv.org/abs/1908.08762 - the random jump avoids the
   * cascading overflow effect when choosing the next host in the ring/table).
   *
   * If weights are specified on the hosts, they are respected.
   *
   * This is an O(N) algorithm, unlike other load balancers. Using a lower ``hash_balance_factor`` results in more hosts
   * being probed, so use a higher value if you require better performance.
   */
  hash_balance_factor?: number | undefined;
}

export interface Cluster_RefreshRate {
  $type: "envoy.config.cluster.v3.Cluster.RefreshRate";
  /**
   * Specifies the base interval between refreshes. This parameter is required and must be greater
   * than zero and less than
   * :ref:`max_interval <envoy_v3_api_field_config.cluster.v3.Cluster.RefreshRate.max_interval>`.
   */
  base_interval?:
    | Duration
    | undefined;
  /**
   * Specifies the maximum interval between refreshes. This parameter is optional, but must be
   * greater than or equal to the
   * :ref:`base_interval <envoy_v3_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval>`  if set. The default
   * is 10 times the :ref:`base_interval <envoy_v3_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval>`.
   */
  max_interval?: Duration | undefined;
}

export interface Cluster_PreconnectPolicy {
  $type: "envoy.config.cluster.v3.Cluster.PreconnectPolicy";
  /**
   * Indicates how many streams (rounded up) can be anticipated per-upstream for each
   * incoming stream. This is useful for high-QPS or latency-sensitive services. Preconnecting
   * will only be done if the upstream is healthy and the cluster has traffic.
   *
   * For example if this is 2, for an incoming HTTP/1.1 stream, 2 connections will be
   * established, one for the new incoming stream, and one for a presumed follow-up stream. For
   * HTTP/2, only one connection would be established by default as one connection can
   * serve both the original and presumed follow-up stream.
   *
   * In steady state for non-multiplexed connections a value of 1.5 would mean if there were 100
   * active streams, there would be 100 connections in use, and 50 connections preconnected.
   * This might be a useful value for something like short lived single-use connections,
   * for example proxying HTTP/1.1 if keep-alive were false and each stream resulted in connection
   * termination. It would likely be overkill for long lived connections, such as TCP proxying SMTP
   * or regular HTTP/1.1 with keep-alive. For long lived traffic, a value of 1.05 would be more
   * reasonable, where for every 100 connections, 5 preconnected connections would be in the queue
   * in case of unexpected disconnects where the connection could not be reused.
   *
   * If this value is not set, or set explicitly to one, Envoy will fetch as many connections
   * as needed to serve streams in flight. This means in steady state if a connection is torn down,
   * a subsequent streams will pay an upstream-rtt latency penalty waiting for a new connection.
   *
   * This is limited somewhat arbitrarily to 3 because preconnecting too aggressively can
   * harm latency more than the preconnecting helps.
   */
  per_upstream_preconnect_ratio?:
    | number
    | undefined;
  /**
   * Indicates how many streams (rounded up) can be anticipated across a cluster for each
   * stream, useful for low QPS services. This is currently supported for a subset of
   * deterministic non-hash-based load-balancing algorithms (weighted round robin, random).
   * Unlike ``per_upstream_preconnect_ratio`` this preconnects across the upstream instances in a
   * cluster, doing best effort predictions of what upstream would be picked next and
   * pre-establishing a connection.
   *
   * Preconnecting will be limited to one preconnect per configured upstream in the cluster and will
   * only be done if there are healthy upstreams and the cluster has traffic.
   *
   * For example if preconnecting is set to 2 for a round robin HTTP/2 cluster, on the first
   * incoming stream, 2 connections will be preconnected - one to the first upstream for this
   * cluster, one to the second on the assumption there will be a follow-up stream.
   *
   * If this value is not set, or set explicitly to one, Envoy will fetch as many connections
   * as needed to serve streams in flight, so during warm up and in steady state if a connection
   * is closed (and per_upstream_preconnect_ratio is not set), there will be a latency hit for
   * connection establishment.
   *
   * If both this and preconnect_ratio are set, Envoy will make sure both predicted needs are met,
   * basically preconnecting max(predictive-preconnect, per-upstream-preconnect), for each
   * upstream.
   */
  predictive_preconnect_ratio?: number | undefined;
}

export interface Cluster_TypedExtensionProtocolOptionsEntry {
  $type: "envoy.config.cluster.v3.Cluster.TypedExtensionProtocolOptionsEntry";
  key: string;
  value?: Any | undefined;
}

/**
 * Extensible load balancing policy configuration.
 *
 * Every LB policy defined via this mechanism will be identified via a unique name using reverse
 * DNS notation. If the policy needs configuration parameters, it must define a message for its
 * own configuration, which will be stored in the config field. The name of the policy will tell
 * clients which type of message they should expect to see in the config field.
 *
 * Note that there are cases where it is useful to be able to independently select LB policies
 * for choosing a locality and for choosing an endpoint within that locality. For example, a
 * given deployment may always use the same policy to choose the locality, but for choosing the
 * endpoint within the locality, some clusters may use weighted-round-robin, while others may
 * use some sort of session-based balancing.
 *
 * This can be accomplished via hierarchical LB policies, where the parent LB policy creates a
 * child LB policy for each locality. For each request, the parent chooses the locality and then
 * delegates to the child policy for that locality to choose the endpoint within the locality.
 *
 * To facilitate this, the config message for the top-level LB policy may include a field of
 * type LoadBalancingPolicy that specifies the child policy.
 */
export interface LoadBalancingPolicy {
  $type: "envoy.config.cluster.v3.LoadBalancingPolicy";
  /**
   * Each client will iterate over the list in order and stop at the first policy that it
   * supports. This provides a mechanism for starting to use new LB policies that are not yet
   * supported by all clients.
   */
  policies?: LoadBalancingPolicy_Policy[] | undefined;
}

export interface LoadBalancingPolicy_Policy {
  $type: "envoy.config.cluster.v3.LoadBalancingPolicy.Policy";
  /** [#extension-category: envoy.load_balancing_policies] */
  typed_extension_config?: TypedExtensionConfig | undefined;
}

export interface UpstreamConnectionOptions {
  $type: "envoy.config.cluster.v3.UpstreamConnectionOptions";
  /** If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives. */
  tcp_keepalive?:
    | TcpKeepalive
    | undefined;
  /**
   * If enabled, associates the interface name of the local address with the upstream connection.
   * This can be used by extensions during processing of requests. The association mechanism is
   * implementation specific. Defaults to false due to performance concerns.
   */
  set_local_interface_name_on_upstream_connections?:
    | boolean
    | undefined;
  /**
   * Configurations for happy eyeballs algorithm.
   * Add configs for first_address_family_version and first_address_family_count
   * when sorting destination ip addresses.
   */
  happy_eyeballs_config?: UpstreamConnectionOptions_HappyEyeballsConfig | undefined;
}

export enum UpstreamConnectionOptions_FirstAddressFamilyVersion {
  /**
   * DEFAULT - respect the native ranking of destination ip addresses returned from dns
   * resolution
   */
  DEFAULT = "DEFAULT",
  V4 = "V4",
  V6 = "V6",
}

export function upstreamConnectionOptions_FirstAddressFamilyVersionFromJSON(
  object: any,
): UpstreamConnectionOptions_FirstAddressFamilyVersion {
  switch (object) {
    case 0:
    case "DEFAULT":
      return UpstreamConnectionOptions_FirstAddressFamilyVersion.DEFAULT;
    case 1:
    case "V4":
      return UpstreamConnectionOptions_FirstAddressFamilyVersion.V4;
    case 2:
    case "V6":
      return UpstreamConnectionOptions_FirstAddressFamilyVersion.V6;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum UpstreamConnectionOptions_FirstAddressFamilyVersion",
      );
  }
}

export function upstreamConnectionOptions_FirstAddressFamilyVersionToJSON(
  object: UpstreamConnectionOptions_FirstAddressFamilyVersion,
): string {
  switch (object) {
    case UpstreamConnectionOptions_FirstAddressFamilyVersion.DEFAULT:
      return "DEFAULT";
    case UpstreamConnectionOptions_FirstAddressFamilyVersion.V4:
      return "V4";
    case UpstreamConnectionOptions_FirstAddressFamilyVersion.V6:
      return "V6";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum UpstreamConnectionOptions_FirstAddressFamilyVersion",
      );
  }
}

export function upstreamConnectionOptions_FirstAddressFamilyVersionToNumber(
  object: UpstreamConnectionOptions_FirstAddressFamilyVersion,
): number {
  switch (object) {
    case UpstreamConnectionOptions_FirstAddressFamilyVersion.DEFAULT:
      return 0;
    case UpstreamConnectionOptions_FirstAddressFamilyVersion.V4:
      return 1;
    case UpstreamConnectionOptions_FirstAddressFamilyVersion.V6:
      return 2;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum UpstreamConnectionOptions_FirstAddressFamilyVersion",
      );
  }
}

export interface UpstreamConnectionOptions_HappyEyeballsConfig {
  $type: "envoy.config.cluster.v3.UpstreamConnectionOptions.HappyEyeballsConfig";
  /**
   * Specify the IP address family to attempt connection first in happy
   * eyeballs algorithm according to RFC8305#section-4.
   */
  first_address_family_version?:
    | UpstreamConnectionOptions_FirstAddressFamilyVersion
    | undefined;
  /**
   * Specify the number of addresses of the first_address_family_version being
   * attempted for connection before the other address family.
   */
  first_address_family_count?: number | undefined;
}

export interface TrackClusterStats {
  $type: "envoy.config.cluster.v3.TrackClusterStats";
  /**
   * If timeout_budgets is true, the :ref:`timeout budget histograms
   * <config_cluster_manager_cluster_stats_timeout_budgets>` will be published for each
   * request. These show what percentage of a request's per try and global timeout was used. A value
   * of 0 would indicate that none of the timeout was used or that the timeout was infinite. A value
   * of 100 would indicate that the request took the entirety of the timeout given to it.
   */
  timeout_budgets?:
    | boolean
    | undefined;
  /**
   * If request_response_sizes is true, then the :ref:`histograms
   * <config_cluster_manager_cluster_stats_request_response_sizes>`  tracking header and body sizes
   * of requests and responses will be published.
   */
  request_response_sizes?:
    | boolean
    | undefined;
  /**
   * If true, some stats will be emitted per-endpoint, similar to the stats in admin ``/clusters``
   * output.
   *
   * This does not currently output correct stats during a hot-restart.
   *
   * This is not currently implemented by all stat sinks.
   *
   * These stats do not honor filtering or tag extraction rules in :ref:`StatsConfig
   * <envoy_v3_api_msg_config.metrics.v3.StatsConfig>` (but fixed-value tags are supported). Admin
   * endpoint filtering is supported.
   *
   * This may not be used at the same time as
   * :ref:`load_stats_config <envoy_v3_api_field_config.bootstrap.v3.ClusterManager.load_stats_config>`.
   */
  per_endpoint_stats?: boolean | undefined;
}

function createBaseClusterCollection(): ClusterCollection {
  return { $type: "envoy.config.cluster.v3.ClusterCollection" };
}

export const ClusterCollection: MessageFns<ClusterCollection, "envoy.config.cluster.v3.ClusterCollection"> = {
  $type: "envoy.config.cluster.v3.ClusterCollection" as const,

  encode(message: ClusterCollection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entries !== undefined) {
      CollectionEntry.encode(message.entries, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClusterCollection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClusterCollection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entries = CollectionEntry.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClusterCollection {
    return {
      $type: ClusterCollection.$type,
      entries: isSet(object.entries) ? CollectionEntry.fromJSON(object.entries) : undefined,
    };
  },

  toJSON(message: ClusterCollection): unknown {
    const obj: any = {};
    if (message.entries !== undefined) {
      obj.entries = CollectionEntry.toJSON(message.entries);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClusterCollection>, I>>(base?: I): ClusterCollection {
    return ClusterCollection.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClusterCollection>, I>>(object: I): ClusterCollection {
    const message = createBaseClusterCollection();
    message.entries = (object.entries !== undefined && object.entries !== null)
      ? CollectionEntry.fromPartial(object.entries)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(ClusterCollection.$type, ClusterCollection);

function createBaseCluster(): Cluster {
  return { $type: "envoy.config.cluster.v3.Cluster", cluster_discovery_type: undefined, lb_config: undefined };
}

export const Cluster: MessageFns<Cluster, "envoy.config.cluster.v3.Cluster"> = {
  $type: "envoy.config.cluster.v3.Cluster" as const,

  encode(message: Cluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transport_socket_matches !== undefined && message.transport_socket_matches.length !== 0) {
      for (const v of message.transport_socket_matches) {
        Cluster_TransportSocketMatch.encode(v!, writer.uint32(346).fork()).join();
      }
    }
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.alt_stat_name !== undefined && message.alt_stat_name !== "") {
      writer.uint32(226).string(message.alt_stat_name);
    }
    switch (message.cluster_discovery_type?.$case) {
      case "type":
        writer.uint32(16).int32(cluster_DiscoveryTypeToNumber(message.cluster_discovery_type.type));
        break;
      case "cluster_type":
        Cluster_CustomClusterType.encode(message.cluster_discovery_type.cluster_type, writer.uint32(306).fork()).join();
        break;
    }
    if (message.eds_cluster_config !== undefined) {
      Cluster_EdsClusterConfig.encode(message.eds_cluster_config, writer.uint32(26).fork()).join();
    }
    if (message.connect_timeout !== undefined) {
      Duration.encode(message.connect_timeout, writer.uint32(34).fork()).join();
    }
    if (message.per_connection_buffer_limit_bytes !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.per_connection_buffer_limit_bytes! },
        writer.uint32(42).fork(),
      ).join();
    }
    if (message.lb_policy !== undefined && message.lb_policy !== Cluster_LbPolicy.ROUND_ROBIN) {
      writer.uint32(48).int32(cluster_LbPolicyToNumber(message.lb_policy));
    }
    if (message.load_assignment !== undefined) {
      ClusterLoadAssignment.encode(message.load_assignment, writer.uint32(266).fork()).join();
    }
    if (message.health_checks !== undefined && message.health_checks.length !== 0) {
      for (const v of message.health_checks) {
        HealthCheck.encode(v!, writer.uint32(66).fork()).join();
      }
    }
    if (message.max_requests_per_connection !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.max_requests_per_connection! },
        writer.uint32(74).fork(),
      ).join();
    }
    if (message.circuit_breakers !== undefined) {
      CircuitBreakers.encode(message.circuit_breakers, writer.uint32(82).fork()).join();
    }
    if (message.upstream_http_protocol_options !== undefined) {
      UpstreamHttpProtocolOptions.encode(message.upstream_http_protocol_options, writer.uint32(370).fork()).join();
    }
    if (message.common_http_protocol_options !== undefined) {
      HttpProtocolOptions.encode(message.common_http_protocol_options, writer.uint32(234).fork()).join();
    }
    if (message.http_protocol_options !== undefined) {
      Http1ProtocolOptions.encode(message.http_protocol_options, writer.uint32(106).fork()).join();
    }
    if (message.http2_protocol_options !== undefined) {
      Http2ProtocolOptions.encode(message.http2_protocol_options, writer.uint32(114).fork()).join();
    }
    (message.typed_extension_protocol_options || new Map()).forEach((value, key) => {
      Cluster_TypedExtensionProtocolOptionsEntry.encode({
        $type: "envoy.config.cluster.v3.Cluster.TypedExtensionProtocolOptionsEntry",
        key: key as any,
        value,
      }, writer.uint32(290).fork()).join();
    });
    if (message.dns_refresh_rate !== undefined) {
      Duration.encode(message.dns_refresh_rate, writer.uint32(130).fork()).join();
    }
    if (message.dns_jitter !== undefined) {
      Duration.encode(message.dns_jitter, writer.uint32(466).fork()).join();
    }
    if (message.dns_failure_refresh_rate !== undefined) {
      Cluster_RefreshRate.encode(message.dns_failure_refresh_rate, writer.uint32(354).fork()).join();
    }
    if (message.respect_dns_ttl !== undefined && message.respect_dns_ttl !== false) {
      writer.uint32(312).bool(message.respect_dns_ttl);
    }
    if (message.dns_lookup_family !== undefined && message.dns_lookup_family !== Cluster_DnsLookupFamily.AUTO) {
      writer.uint32(136).int32(cluster_DnsLookupFamilyToNumber(message.dns_lookup_family));
    }
    if (message.dns_resolvers !== undefined && message.dns_resolvers.length !== 0) {
      for (const v of message.dns_resolvers) {
        Address.encode(v!, writer.uint32(146).fork()).join();
      }
    }
    if (message.use_tcp_for_dns_lookups !== undefined && message.use_tcp_for_dns_lookups !== false) {
      writer.uint32(360).bool(message.use_tcp_for_dns_lookups);
    }
    if (message.dns_resolution_config !== undefined) {
      DnsResolutionConfig.encode(message.dns_resolution_config, writer.uint32(426).fork()).join();
    }
    if (message.typed_dns_resolver_config !== undefined) {
      TypedExtensionConfig.encode(message.typed_dns_resolver_config, writer.uint32(442).fork()).join();
    }
    if (message.wait_for_warm_on_init !== undefined) {
      BoolValue.encode(
        { $type: "google.protobuf.BoolValue", value: message.wait_for_warm_on_init! },
        writer.uint32(434).fork(),
      ).join();
    }
    if (message.outlier_detection !== undefined) {
      OutlierDetection.encode(message.outlier_detection, writer.uint32(154).fork()).join();
    }
    if (message.cleanup_interval !== undefined) {
      Duration.encode(message.cleanup_interval, writer.uint32(162).fork()).join();
    }
    if (message.upstream_bind_config !== undefined) {
      BindConfig.encode(message.upstream_bind_config, writer.uint32(170).fork()).join();
    }
    if (message.lb_subset_config !== undefined) {
      Cluster_LbSubsetConfig.encode(message.lb_subset_config, writer.uint32(178).fork()).join();
    }
    switch (message.lb_config?.$case) {
      case "ring_hash_lb_config":
        Cluster_RingHashLbConfig.encode(message.lb_config.ring_hash_lb_config, writer.uint32(186).fork()).join();
        break;
      case "maglev_lb_config":
        Cluster_MaglevLbConfig.encode(message.lb_config.maglev_lb_config, writer.uint32(418).fork()).join();
        break;
      case "original_dst_lb_config":
        Cluster_OriginalDstLbConfig.encode(message.lb_config.original_dst_lb_config, writer.uint32(274).fork()).join();
        break;
      case "least_request_lb_config":
        Cluster_LeastRequestLbConfig.encode(message.lb_config.least_request_lb_config, writer.uint32(298).fork())
          .join();
        break;
      case "round_robin_lb_config":
        Cluster_RoundRobinLbConfig.encode(message.lb_config.round_robin_lb_config, writer.uint32(450).fork()).join();
        break;
    }
    if (message.common_lb_config !== undefined) {
      Cluster_CommonLbConfig.encode(message.common_lb_config, writer.uint32(218).fork()).join();
    }
    if (message.transport_socket !== undefined) {
      TransportSocket.encode(message.transport_socket, writer.uint32(194).fork()).join();
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(202).fork()).join();
    }
    if (
      message.protocol_selection !== undefined &&
      message.protocol_selection !== Cluster_ClusterProtocolSelection.USE_CONFIGURED_PROTOCOL
    ) {
      writer.uint32(208).int32(cluster_ClusterProtocolSelectionToNumber(message.protocol_selection));
    }
    if (message.upstream_connection_options !== undefined) {
      UpstreamConnectionOptions.encode(message.upstream_connection_options, writer.uint32(242).fork()).join();
    }
    if (
      message.close_connections_on_host_health_failure !== undefined &&
      message.close_connections_on_host_health_failure !== false
    ) {
      writer.uint32(248).bool(message.close_connections_on_host_health_failure);
    }
    if (message.ignore_health_on_host_removal !== undefined && message.ignore_health_on_host_removal !== false) {
      writer.uint32(256).bool(message.ignore_health_on_host_removal);
    }
    if (message.filters !== undefined && message.filters.length !== 0) {
      for (const v of message.filters) {
        Filter.encode(v!, writer.uint32(322).fork()).join();
      }
    }
    if (message.load_balancing_policy !== undefined) {
      LoadBalancingPolicy.encode(message.load_balancing_policy, writer.uint32(330).fork()).join();
    }
    if (message.lrs_server !== undefined) {
      ConfigSource.encode(message.lrs_server, writer.uint32(338).fork()).join();
    }
    if (message.lrs_report_endpoint_metrics !== undefined && message.lrs_report_endpoint_metrics.length !== 0) {
      for (const v of message.lrs_report_endpoint_metrics) {
        writer.uint32(458).string(v!);
      }
    }
    if (message.track_timeout_budgets !== undefined && message.track_timeout_budgets !== false) {
      writer.uint32(376).bool(message.track_timeout_budgets);
    }
    if (message.upstream_config !== undefined) {
      TypedExtensionConfig.encode(message.upstream_config, writer.uint32(386).fork()).join();
    }
    if (message.track_cluster_stats !== undefined) {
      TrackClusterStats.encode(message.track_cluster_stats, writer.uint32(394).fork()).join();
    }
    if (message.preconnect_policy !== undefined) {
      Cluster_PreconnectPolicy.encode(message.preconnect_policy, writer.uint32(402).fork()).join();
    }
    if (
      message.connection_pool_per_downstream_connection !== undefined &&
      message.connection_pool_per_downstream_connection !== false
    ) {
      writer.uint32(408).bool(message.connection_pool_per_downstream_connection);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 43: {
          if (tag !== 346) {
            break;
          }

          if (message.transport_socket_matches === undefined) {
            message.transport_socket_matches = [];
          }
          const el = Cluster_TransportSocketMatch.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.transport_socket_matches!.push(el);
          }
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.alt_stat_name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.cluster_discovery_type = { $case: "type", type: cluster_DiscoveryTypeFromJSON(reader.int32()) };
          continue;
        }
        case 38: {
          if (tag !== 306) {
            break;
          }

          message.cluster_discovery_type = {
            $case: "cluster_type",
            cluster_type: Cluster_CustomClusterType.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.eds_cluster_config = Cluster_EdsClusterConfig.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.connect_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.per_connection_buffer_limit_bytes = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.lb_policy = cluster_LbPolicyFromJSON(reader.int32());
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }

          message.load_assignment = ClusterLoadAssignment.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          if (message.health_checks === undefined) {
            message.health_checks = [];
          }
          const el = HealthCheck.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.health_checks!.push(el);
          }
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.max_requests_per_connection = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.circuit_breakers = CircuitBreakers.decode(reader, reader.uint32());
          continue;
        }
        case 46: {
          if (tag !== 370) {
            break;
          }

          message.upstream_http_protocol_options = UpstreamHttpProtocolOptions.decode(reader, reader.uint32());
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.common_http_protocol_options = HttpProtocolOptions.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.http_protocol_options = Http1ProtocolOptions.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.http2_protocol_options = Http2ProtocolOptions.decode(reader, reader.uint32());
          continue;
        }
        case 36: {
          if (tag !== 290) {
            break;
          }

          const entry36 = Cluster_TypedExtensionProtocolOptionsEntry.decode(reader, reader.uint32());
          if (entry36.value !== undefined) {
            if (message.typed_extension_protocol_options === undefined) {
              message.typed_extension_protocol_options = new Map();
            }
            message.typed_extension_protocol_options!.set(entry36.key, entry36.value);
          }
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.dns_refresh_rate = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 58: {
          if (tag !== 466) {
            break;
          }

          message.dns_jitter = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 44: {
          if (tag !== 354) {
            break;
          }

          message.dns_failure_refresh_rate = Cluster_RefreshRate.decode(reader, reader.uint32());
          continue;
        }
        case 39: {
          if (tag !== 312) {
            break;
          }

          message.respect_dns_ttl = reader.bool();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.dns_lookup_family = cluster_DnsLookupFamilyFromJSON(reader.int32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          if (message.dns_resolvers === undefined) {
            message.dns_resolvers = [];
          }
          const el = Address.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.dns_resolvers!.push(el);
          }
          continue;
        }
        case 45: {
          if (tag !== 360) {
            break;
          }

          message.use_tcp_for_dns_lookups = reader.bool();
          continue;
        }
        case 53: {
          if (tag !== 426) {
            break;
          }

          message.dns_resolution_config = DnsResolutionConfig.decode(reader, reader.uint32());
          continue;
        }
        case 55: {
          if (tag !== 442) {
            break;
          }

          message.typed_dns_resolver_config = TypedExtensionConfig.decode(reader, reader.uint32());
          continue;
        }
        case 54: {
          if (tag !== 434) {
            break;
          }

          message.wait_for_warm_on_init = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.outlier_detection = OutlierDetection.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.cleanup_interval = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.upstream_bind_config = BindConfig.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.lb_subset_config = Cluster_LbSubsetConfig.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.lb_config = {
            $case: "ring_hash_lb_config",
            ring_hash_lb_config: Cluster_RingHashLbConfig.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 52: {
          if (tag !== 418) {
            break;
          }

          message.lb_config = {
            $case: "maglev_lb_config",
            maglev_lb_config: Cluster_MaglevLbConfig.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          message.lb_config = {
            $case: "original_dst_lb_config",
            original_dst_lb_config: Cluster_OriginalDstLbConfig.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 37: {
          if (tag !== 298) {
            break;
          }

          message.lb_config = {
            $case: "least_request_lb_config",
            least_request_lb_config: Cluster_LeastRequestLbConfig.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 56: {
          if (tag !== 450) {
            break;
          }

          message.lb_config = {
            $case: "round_robin_lb_config",
            round_robin_lb_config: Cluster_RoundRobinLbConfig.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.common_lb_config = Cluster_CommonLbConfig.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.transport_socket = TransportSocket.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.protocol_selection = cluster_ClusterProtocolSelectionFromJSON(reader.int32());
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.upstream_connection_options = UpstreamConnectionOptions.decode(reader, reader.uint32());
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.close_connections_on_host_health_failure = reader.bool();
          continue;
        }
        case 32: {
          if (tag !== 256) {
            break;
          }

          message.ignore_health_on_host_removal = reader.bool();
          continue;
        }
        case 40: {
          if (tag !== 322) {
            break;
          }

          if (message.filters === undefined) {
            message.filters = [];
          }
          const el = Filter.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.filters!.push(el);
          }
          continue;
        }
        case 41: {
          if (tag !== 330) {
            break;
          }

          message.load_balancing_policy = LoadBalancingPolicy.decode(reader, reader.uint32());
          continue;
        }
        case 42: {
          if (tag !== 338) {
            break;
          }

          message.lrs_server = ConfigSource.decode(reader, reader.uint32());
          continue;
        }
        case 57: {
          if (tag !== 458) {
            break;
          }

          if (message.lrs_report_endpoint_metrics === undefined) {
            message.lrs_report_endpoint_metrics = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.lrs_report_endpoint_metrics!.push(el);
          }
          continue;
        }
        case 47: {
          if (tag !== 376) {
            break;
          }

          message.track_timeout_budgets = reader.bool();
          continue;
        }
        case 48: {
          if (tag !== 386) {
            break;
          }

          message.upstream_config = TypedExtensionConfig.decode(reader, reader.uint32());
          continue;
        }
        case 49: {
          if (tag !== 394) {
            break;
          }

          message.track_cluster_stats = TrackClusterStats.decode(reader, reader.uint32());
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.preconnect_policy = Cluster_PreconnectPolicy.decode(reader, reader.uint32());
          continue;
        }
        case 51: {
          if (tag !== 408) {
            break;
          }

          message.connection_pool_per_downstream_connection = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster {
    return {
      $type: Cluster.$type,
      transport_socket_matches: globalThis.Array.isArray(object?.transport_socket_matches)
        ? object.transport_socket_matches.map((e: any) => Cluster_TransportSocketMatch.fromJSON(e))
        : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      alt_stat_name: isSet(object.alt_stat_name) ? globalThis.String(object.alt_stat_name) : undefined,
      cluster_discovery_type: isSet(object.type)
        ? { $case: "type", type: cluster_DiscoveryTypeFromJSON(object.type) }
        : isSet(object.cluster_type)
        ? { $case: "cluster_type", cluster_type: Cluster_CustomClusterType.fromJSON(object.cluster_type) }
        : undefined,
      eds_cluster_config: isSet(object.eds_cluster_config)
        ? Cluster_EdsClusterConfig.fromJSON(object.eds_cluster_config)
        : undefined,
      connect_timeout: isSet(object.connect_timeout) ? Duration.fromJSON(object.connect_timeout) : undefined,
      per_connection_buffer_limit_bytes: isSet(object.per_connection_buffer_limit_bytes)
        ? Number(object.per_connection_buffer_limit_bytes)
        : undefined,
      lb_policy: isSet(object.lb_policy) ? cluster_LbPolicyFromJSON(object.lb_policy) : undefined,
      load_assignment: isSet(object.load_assignment)
        ? ClusterLoadAssignment.fromJSON(object.load_assignment)
        : undefined,
      health_checks: globalThis.Array.isArray(object?.health_checks)
        ? object.health_checks.map((e: any) => HealthCheck.fromJSON(e))
        : undefined,
      max_requests_per_connection: isSet(object.max_requests_per_connection)
        ? Number(object.max_requests_per_connection)
        : undefined,
      circuit_breakers: isSet(object.circuit_breakers) ? CircuitBreakers.fromJSON(object.circuit_breakers) : undefined,
      upstream_http_protocol_options: isSet(object.upstream_http_protocol_options)
        ? UpstreamHttpProtocolOptions.fromJSON(object.upstream_http_protocol_options)
        : undefined,
      common_http_protocol_options: isSet(object.common_http_protocol_options)
        ? HttpProtocolOptions.fromJSON(object.common_http_protocol_options)
        : undefined,
      http_protocol_options: isSet(object.http_protocol_options)
        ? Http1ProtocolOptions.fromJSON(object.http_protocol_options)
        : undefined,
      http2_protocol_options: isSet(object.http2_protocol_options)
        ? Http2ProtocolOptions.fromJSON(object.http2_protocol_options)
        : undefined,
      typed_extension_protocol_options: isObject(object.typed_extension_protocol_options)
        ? Object.entries(object.typed_extension_protocol_options).reduce<Map<string, Any>>((acc, [key, value]) => {
          acc.set(key, Any.fromJSON(value));
          return acc;
        }, new Map())
        : undefined,
      dns_refresh_rate: isSet(object.dns_refresh_rate) ? Duration.fromJSON(object.dns_refresh_rate) : undefined,
      dns_jitter: isSet(object.dns_jitter) ? Duration.fromJSON(object.dns_jitter) : undefined,
      dns_failure_refresh_rate: isSet(object.dns_failure_refresh_rate)
        ? Cluster_RefreshRate.fromJSON(object.dns_failure_refresh_rate)
        : undefined,
      respect_dns_ttl: isSet(object.respect_dns_ttl) ? globalThis.Boolean(object.respect_dns_ttl) : undefined,
      dns_lookup_family: isSet(object.dns_lookup_family)
        ? cluster_DnsLookupFamilyFromJSON(object.dns_lookup_family)
        : undefined,
      dns_resolvers: globalThis.Array.isArray(object?.dns_resolvers)
        ? object.dns_resolvers.map((e: any) => Address.fromJSON(e))
        : undefined,
      use_tcp_for_dns_lookups: isSet(object.use_tcp_for_dns_lookups)
        ? globalThis.Boolean(object.use_tcp_for_dns_lookups)
        : undefined,
      dns_resolution_config: isSet(object.dns_resolution_config)
        ? DnsResolutionConfig.fromJSON(object.dns_resolution_config)
        : undefined,
      typed_dns_resolver_config: isSet(object.typed_dns_resolver_config)
        ? TypedExtensionConfig.fromJSON(object.typed_dns_resolver_config)
        : undefined,
      wait_for_warm_on_init: isSet(object.wait_for_warm_on_init) ? Boolean(object.wait_for_warm_on_init) : undefined,
      outlier_detection: isSet(object.outlier_detection)
        ? OutlierDetection.fromJSON(object.outlier_detection)
        : undefined,
      cleanup_interval: isSet(object.cleanup_interval) ? Duration.fromJSON(object.cleanup_interval) : undefined,
      upstream_bind_config: isSet(object.upstream_bind_config)
        ? BindConfig.fromJSON(object.upstream_bind_config)
        : undefined,
      lb_subset_config: isSet(object.lb_subset_config)
        ? Cluster_LbSubsetConfig.fromJSON(object.lb_subset_config)
        : undefined,
      lb_config: isSet(object.ring_hash_lb_config)
        ? {
          $case: "ring_hash_lb_config",
          ring_hash_lb_config: Cluster_RingHashLbConfig.fromJSON(object.ring_hash_lb_config),
        }
        : isSet(object.maglev_lb_config)
        ? { $case: "maglev_lb_config", maglev_lb_config: Cluster_MaglevLbConfig.fromJSON(object.maglev_lb_config) }
        : isSet(object.original_dst_lb_config)
        ? {
          $case: "original_dst_lb_config",
          original_dst_lb_config: Cluster_OriginalDstLbConfig.fromJSON(object.original_dst_lb_config),
        }
        : isSet(object.least_request_lb_config)
        ? {
          $case: "least_request_lb_config",
          least_request_lb_config: Cluster_LeastRequestLbConfig.fromJSON(object.least_request_lb_config),
        }
        : isSet(object.round_robin_lb_config)
        ? {
          $case: "round_robin_lb_config",
          round_robin_lb_config: Cluster_RoundRobinLbConfig.fromJSON(object.round_robin_lb_config),
        }
        : undefined,
      common_lb_config: isSet(object.common_lb_config)
        ? Cluster_CommonLbConfig.fromJSON(object.common_lb_config)
        : undefined,
      transport_socket: isSet(object.transport_socket) ? TransportSocket.fromJSON(object.transport_socket) : undefined,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      protocol_selection: isSet(object.protocol_selection)
        ? cluster_ClusterProtocolSelectionFromJSON(object.protocol_selection)
        : undefined,
      upstream_connection_options: isSet(object.upstream_connection_options)
        ? UpstreamConnectionOptions.fromJSON(object.upstream_connection_options)
        : undefined,
      close_connections_on_host_health_failure: isSet(object.close_connections_on_host_health_failure)
        ? globalThis.Boolean(object.close_connections_on_host_health_failure)
        : undefined,
      ignore_health_on_host_removal: isSet(object.ignore_health_on_host_removal)
        ? globalThis.Boolean(object.ignore_health_on_host_removal)
        : undefined,
      filters: globalThis.Array.isArray(object?.filters)
        ? object.filters.map((e: any) => Filter.fromJSON(e))
        : undefined,
      load_balancing_policy: isSet(object.load_balancing_policy)
        ? LoadBalancingPolicy.fromJSON(object.load_balancing_policy)
        : undefined,
      lrs_server: isSet(object.lrs_server) ? ConfigSource.fromJSON(object.lrs_server) : undefined,
      lrs_report_endpoint_metrics: globalThis.Array.isArray(object?.lrs_report_endpoint_metrics)
        ? object.lrs_report_endpoint_metrics.map((e: any) => globalThis.String(e))
        : undefined,
      track_timeout_budgets: isSet(object.track_timeout_budgets)
        ? globalThis.Boolean(object.track_timeout_budgets)
        : undefined,
      upstream_config: isSet(object.upstream_config)
        ? TypedExtensionConfig.fromJSON(object.upstream_config)
        : undefined,
      track_cluster_stats: isSet(object.track_cluster_stats)
        ? TrackClusterStats.fromJSON(object.track_cluster_stats)
        : undefined,
      preconnect_policy: isSet(object.preconnect_policy)
        ? Cluster_PreconnectPolicy.fromJSON(object.preconnect_policy)
        : undefined,
      connection_pool_per_downstream_connection: isSet(object.connection_pool_per_downstream_connection)
        ? globalThis.Boolean(object.connection_pool_per_downstream_connection)
        : undefined,
    };
  },

  toJSON(message: Cluster): unknown {
    const obj: any = {};
    if (message.transport_socket_matches?.length) {
      obj.transport_socket_matches = message.transport_socket_matches.map((e) =>
        Cluster_TransportSocketMatch.toJSON(e)
      );
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.alt_stat_name !== undefined) {
      obj.alt_stat_name = message.alt_stat_name;
    }
    if (message.cluster_discovery_type?.$case === "type") {
      obj.type = cluster_DiscoveryTypeToJSON(message.cluster_discovery_type.type);
    }
    if (message.cluster_discovery_type?.$case === "cluster_type") {
      obj.cluster_type = Cluster_CustomClusterType.toJSON(message.cluster_discovery_type.cluster_type);
    }
    if (message.eds_cluster_config !== undefined) {
      obj.eds_cluster_config = Cluster_EdsClusterConfig.toJSON(message.eds_cluster_config);
    }
    if (message.connect_timeout !== undefined) {
      obj.connect_timeout = Duration.toJSON(message.connect_timeout);
    }
    if (message.per_connection_buffer_limit_bytes !== undefined) {
      obj.per_connection_buffer_limit_bytes = message.per_connection_buffer_limit_bytes;
    }
    if (message.lb_policy !== undefined) {
      obj.lb_policy = cluster_LbPolicyToJSON(message.lb_policy);
    }
    if (message.load_assignment !== undefined) {
      obj.load_assignment = ClusterLoadAssignment.toJSON(message.load_assignment);
    }
    if (message.health_checks?.length) {
      obj.health_checks = message.health_checks.map((e) => HealthCheck.toJSON(e));
    }
    if (message.max_requests_per_connection !== undefined) {
      obj.max_requests_per_connection = message.max_requests_per_connection;
    }
    if (message.circuit_breakers !== undefined) {
      obj.circuit_breakers = CircuitBreakers.toJSON(message.circuit_breakers);
    }
    if (message.upstream_http_protocol_options !== undefined) {
      obj.upstream_http_protocol_options = UpstreamHttpProtocolOptions.toJSON(message.upstream_http_protocol_options);
    }
    if (message.common_http_protocol_options !== undefined) {
      obj.common_http_protocol_options = HttpProtocolOptions.toJSON(message.common_http_protocol_options);
    }
    if (message.http_protocol_options !== undefined) {
      obj.http_protocol_options = Http1ProtocolOptions.toJSON(message.http_protocol_options);
    }
    if (message.http2_protocol_options !== undefined) {
      obj.http2_protocol_options = Http2ProtocolOptions.toJSON(message.http2_protocol_options);
    }
    if (message.typed_extension_protocol_options?.size) {
      obj.typed_extension_protocol_options = {};
      message.typed_extension_protocol_options.forEach((v, k) => {
        obj.typed_extension_protocol_options[k] = Any.toJSON(v);
      });
    }
    if (message.dns_refresh_rate !== undefined) {
      obj.dns_refresh_rate = Duration.toJSON(message.dns_refresh_rate);
    }
    if (message.dns_jitter !== undefined) {
      obj.dns_jitter = Duration.toJSON(message.dns_jitter);
    }
    if (message.dns_failure_refresh_rate !== undefined) {
      obj.dns_failure_refresh_rate = Cluster_RefreshRate.toJSON(message.dns_failure_refresh_rate);
    }
    if (message.respect_dns_ttl !== undefined) {
      obj.respect_dns_ttl = message.respect_dns_ttl;
    }
    if (message.dns_lookup_family !== undefined) {
      obj.dns_lookup_family = cluster_DnsLookupFamilyToJSON(message.dns_lookup_family);
    }
    if (message.dns_resolvers?.length) {
      obj.dns_resolvers = message.dns_resolvers.map((e) => Address.toJSON(e));
    }
    if (message.use_tcp_for_dns_lookups !== undefined) {
      obj.use_tcp_for_dns_lookups = message.use_tcp_for_dns_lookups;
    }
    if (message.dns_resolution_config !== undefined) {
      obj.dns_resolution_config = DnsResolutionConfig.toJSON(message.dns_resolution_config);
    }
    if (message.typed_dns_resolver_config !== undefined) {
      obj.typed_dns_resolver_config = TypedExtensionConfig.toJSON(message.typed_dns_resolver_config);
    }
    if (message.wait_for_warm_on_init !== undefined) {
      obj.wait_for_warm_on_init = message.wait_for_warm_on_init;
    }
    if (message.outlier_detection !== undefined) {
      obj.outlier_detection = OutlierDetection.toJSON(message.outlier_detection);
    }
    if (message.cleanup_interval !== undefined) {
      obj.cleanup_interval = Duration.toJSON(message.cleanup_interval);
    }
    if (message.upstream_bind_config !== undefined) {
      obj.upstream_bind_config = BindConfig.toJSON(message.upstream_bind_config);
    }
    if (message.lb_subset_config !== undefined) {
      obj.lb_subset_config = Cluster_LbSubsetConfig.toJSON(message.lb_subset_config);
    }
    if (message.lb_config?.$case === "ring_hash_lb_config") {
      obj.ring_hash_lb_config = Cluster_RingHashLbConfig.toJSON(message.lb_config.ring_hash_lb_config);
    }
    if (message.lb_config?.$case === "maglev_lb_config") {
      obj.maglev_lb_config = Cluster_MaglevLbConfig.toJSON(message.lb_config.maglev_lb_config);
    }
    if (message.lb_config?.$case === "original_dst_lb_config") {
      obj.original_dst_lb_config = Cluster_OriginalDstLbConfig.toJSON(message.lb_config.original_dst_lb_config);
    }
    if (message.lb_config?.$case === "least_request_lb_config") {
      obj.least_request_lb_config = Cluster_LeastRequestLbConfig.toJSON(message.lb_config.least_request_lb_config);
    }
    if (message.lb_config?.$case === "round_robin_lb_config") {
      obj.round_robin_lb_config = Cluster_RoundRobinLbConfig.toJSON(message.lb_config.round_robin_lb_config);
    }
    if (message.common_lb_config !== undefined) {
      obj.common_lb_config = Cluster_CommonLbConfig.toJSON(message.common_lb_config);
    }
    if (message.transport_socket !== undefined) {
      obj.transport_socket = TransportSocket.toJSON(message.transport_socket);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.protocol_selection !== undefined) {
      obj.protocol_selection = cluster_ClusterProtocolSelectionToJSON(message.protocol_selection);
    }
    if (message.upstream_connection_options !== undefined) {
      obj.upstream_connection_options = UpstreamConnectionOptions.toJSON(message.upstream_connection_options);
    }
    if (message.close_connections_on_host_health_failure !== undefined) {
      obj.close_connections_on_host_health_failure = message.close_connections_on_host_health_failure;
    }
    if (message.ignore_health_on_host_removal !== undefined) {
      obj.ignore_health_on_host_removal = message.ignore_health_on_host_removal;
    }
    if (message.filters?.length) {
      obj.filters = message.filters.map((e) => Filter.toJSON(e));
    }
    if (message.load_balancing_policy !== undefined) {
      obj.load_balancing_policy = LoadBalancingPolicy.toJSON(message.load_balancing_policy);
    }
    if (message.lrs_server !== undefined) {
      obj.lrs_server = ConfigSource.toJSON(message.lrs_server);
    }
    if (message.lrs_report_endpoint_metrics?.length) {
      obj.lrs_report_endpoint_metrics = message.lrs_report_endpoint_metrics;
    }
    if (message.track_timeout_budgets !== undefined) {
      obj.track_timeout_budgets = message.track_timeout_budgets;
    }
    if (message.upstream_config !== undefined) {
      obj.upstream_config = TypedExtensionConfig.toJSON(message.upstream_config);
    }
    if (message.track_cluster_stats !== undefined) {
      obj.track_cluster_stats = TrackClusterStats.toJSON(message.track_cluster_stats);
    }
    if (message.preconnect_policy !== undefined) {
      obj.preconnect_policy = Cluster_PreconnectPolicy.toJSON(message.preconnect_policy);
    }
    if (message.connection_pool_per_downstream_connection !== undefined) {
      obj.connection_pool_per_downstream_connection = message.connection_pool_per_downstream_connection;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Cluster>, I>>(base?: I): Cluster {
    return Cluster.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cluster>, I>>(object: I): Cluster {
    const message = createBaseCluster();
    message.transport_socket_matches =
      object.transport_socket_matches?.map((e) => Cluster_TransportSocketMatch.fromPartial(e)) || undefined;
    message.name = object.name ?? undefined;
    message.alt_stat_name = object.alt_stat_name ?? undefined;
    if (
      object.cluster_discovery_type?.$case === "type" &&
      object.cluster_discovery_type?.type !== undefined &&
      object.cluster_discovery_type?.type !== null
    ) {
      message.cluster_discovery_type = { $case: "type", type: object.cluster_discovery_type.type };
    }
    if (
      object.cluster_discovery_type?.$case === "cluster_type" &&
      object.cluster_discovery_type?.cluster_type !== undefined &&
      object.cluster_discovery_type?.cluster_type !== null
    ) {
      message.cluster_discovery_type = {
        $case: "cluster_type",
        cluster_type: Cluster_CustomClusterType.fromPartial(object.cluster_discovery_type.cluster_type),
      };
    }
    message.eds_cluster_config = (object.eds_cluster_config !== undefined && object.eds_cluster_config !== null)
      ? Cluster_EdsClusterConfig.fromPartial(object.eds_cluster_config)
      : undefined;
    message.connect_timeout = (object.connect_timeout !== undefined && object.connect_timeout !== null)
      ? Duration.fromPartial(object.connect_timeout)
      : undefined;
    message.per_connection_buffer_limit_bytes = object.per_connection_buffer_limit_bytes ?? undefined;
    message.lb_policy = object.lb_policy ?? undefined;
    message.load_assignment = (object.load_assignment !== undefined && object.load_assignment !== null)
      ? ClusterLoadAssignment.fromPartial(object.load_assignment)
      : undefined;
    message.health_checks = object.health_checks?.map((e) => HealthCheck.fromPartial(e)) || undefined;
    message.max_requests_per_connection = object.max_requests_per_connection ?? undefined;
    message.circuit_breakers = (object.circuit_breakers !== undefined && object.circuit_breakers !== null)
      ? CircuitBreakers.fromPartial(object.circuit_breakers)
      : undefined;
    message.upstream_http_protocol_options =
      (object.upstream_http_protocol_options !== undefined && object.upstream_http_protocol_options !== null)
        ? UpstreamHttpProtocolOptions.fromPartial(object.upstream_http_protocol_options)
        : undefined;
    message.common_http_protocol_options =
      (object.common_http_protocol_options !== undefined && object.common_http_protocol_options !== null)
        ? HttpProtocolOptions.fromPartial(object.common_http_protocol_options)
        : undefined;
    message.http_protocol_options =
      (object.http_protocol_options !== undefined && object.http_protocol_options !== null)
        ? Http1ProtocolOptions.fromPartial(object.http_protocol_options)
        : undefined;
    message.http2_protocol_options =
      (object.http2_protocol_options !== undefined && object.http2_protocol_options !== null)
        ? Http2ProtocolOptions.fromPartial(object.http2_protocol_options)
        : undefined;
    message.typed_extension_protocol_options =
      (object.typed_extension_protocol_options === undefined || object.typed_extension_protocol_options === null)
        ? undefined
        : (() => {
          const m = new Map();
          (object.typed_extension_protocol_options as Map<string, Any> ?? new Map()).forEach((value, key) => {
            if (value !== undefined) {
              m.set(key, Any.fromPartial(value));
            }
          });
          return m;
        })();
    message.dns_refresh_rate = (object.dns_refresh_rate !== undefined && object.dns_refresh_rate !== null)
      ? Duration.fromPartial(object.dns_refresh_rate)
      : undefined;
    message.dns_jitter = (object.dns_jitter !== undefined && object.dns_jitter !== null)
      ? Duration.fromPartial(object.dns_jitter)
      : undefined;
    message.dns_failure_refresh_rate =
      (object.dns_failure_refresh_rate !== undefined && object.dns_failure_refresh_rate !== null)
        ? Cluster_RefreshRate.fromPartial(object.dns_failure_refresh_rate)
        : undefined;
    message.respect_dns_ttl = object.respect_dns_ttl ?? undefined;
    message.dns_lookup_family = object.dns_lookup_family ?? undefined;
    message.dns_resolvers = object.dns_resolvers?.map((e) => Address.fromPartial(e)) || undefined;
    message.use_tcp_for_dns_lookups = object.use_tcp_for_dns_lookups ?? undefined;
    message.dns_resolution_config =
      (object.dns_resolution_config !== undefined && object.dns_resolution_config !== null)
        ? DnsResolutionConfig.fromPartial(object.dns_resolution_config)
        : undefined;
    message.typed_dns_resolver_config =
      (object.typed_dns_resolver_config !== undefined && object.typed_dns_resolver_config !== null)
        ? TypedExtensionConfig.fromPartial(object.typed_dns_resolver_config)
        : undefined;
    message.wait_for_warm_on_init = object.wait_for_warm_on_init ?? undefined;
    message.outlier_detection = (object.outlier_detection !== undefined && object.outlier_detection !== null)
      ? OutlierDetection.fromPartial(object.outlier_detection)
      : undefined;
    message.cleanup_interval = (object.cleanup_interval !== undefined && object.cleanup_interval !== null)
      ? Duration.fromPartial(object.cleanup_interval)
      : undefined;
    message.upstream_bind_config = (object.upstream_bind_config !== undefined && object.upstream_bind_config !== null)
      ? BindConfig.fromPartial(object.upstream_bind_config)
      : undefined;
    message.lb_subset_config = (object.lb_subset_config !== undefined && object.lb_subset_config !== null)
      ? Cluster_LbSubsetConfig.fromPartial(object.lb_subset_config)
      : undefined;
    if (
      object.lb_config?.$case === "ring_hash_lb_config" &&
      object.lb_config?.ring_hash_lb_config !== undefined &&
      object.lb_config?.ring_hash_lb_config !== null
    ) {
      message.lb_config = {
        $case: "ring_hash_lb_config",
        ring_hash_lb_config: Cluster_RingHashLbConfig.fromPartial(object.lb_config.ring_hash_lb_config),
      };
    }
    if (
      object.lb_config?.$case === "maglev_lb_config" &&
      object.lb_config?.maglev_lb_config !== undefined &&
      object.lb_config?.maglev_lb_config !== null
    ) {
      message.lb_config = {
        $case: "maglev_lb_config",
        maglev_lb_config: Cluster_MaglevLbConfig.fromPartial(object.lb_config.maglev_lb_config),
      };
    }
    if (
      object.lb_config?.$case === "original_dst_lb_config" &&
      object.lb_config?.original_dst_lb_config !== undefined &&
      object.lb_config?.original_dst_lb_config !== null
    ) {
      message.lb_config = {
        $case: "original_dst_lb_config",
        original_dst_lb_config: Cluster_OriginalDstLbConfig.fromPartial(object.lb_config.original_dst_lb_config),
      };
    }
    if (
      object.lb_config?.$case === "least_request_lb_config" &&
      object.lb_config?.least_request_lb_config !== undefined &&
      object.lb_config?.least_request_lb_config !== null
    ) {
      message.lb_config = {
        $case: "least_request_lb_config",
        least_request_lb_config: Cluster_LeastRequestLbConfig.fromPartial(object.lb_config.least_request_lb_config),
      };
    }
    if (
      object.lb_config?.$case === "round_robin_lb_config" &&
      object.lb_config?.round_robin_lb_config !== undefined &&
      object.lb_config?.round_robin_lb_config !== null
    ) {
      message.lb_config = {
        $case: "round_robin_lb_config",
        round_robin_lb_config: Cluster_RoundRobinLbConfig.fromPartial(object.lb_config.round_robin_lb_config),
      };
    }
    message.common_lb_config = (object.common_lb_config !== undefined && object.common_lb_config !== null)
      ? Cluster_CommonLbConfig.fromPartial(object.common_lb_config)
      : undefined;
    message.transport_socket = (object.transport_socket !== undefined && object.transport_socket !== null)
      ? TransportSocket.fromPartial(object.transport_socket)
      : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.protocol_selection = object.protocol_selection ?? undefined;
    message.upstream_connection_options =
      (object.upstream_connection_options !== undefined && object.upstream_connection_options !== null)
        ? UpstreamConnectionOptions.fromPartial(object.upstream_connection_options)
        : undefined;
    message.close_connections_on_host_health_failure = object.close_connections_on_host_health_failure ?? undefined;
    message.ignore_health_on_host_removal = object.ignore_health_on_host_removal ?? undefined;
    message.filters = object.filters?.map((e) => Filter.fromPartial(e)) || undefined;
    message.load_balancing_policy =
      (object.load_balancing_policy !== undefined && object.load_balancing_policy !== null)
        ? LoadBalancingPolicy.fromPartial(object.load_balancing_policy)
        : undefined;
    message.lrs_server = (object.lrs_server !== undefined && object.lrs_server !== null)
      ? ConfigSource.fromPartial(object.lrs_server)
      : undefined;
    message.lrs_report_endpoint_metrics = object.lrs_report_endpoint_metrics?.map((e) => e) || undefined;
    message.track_timeout_budgets = object.track_timeout_budgets ?? undefined;
    message.upstream_config = (object.upstream_config !== undefined && object.upstream_config !== null)
      ? TypedExtensionConfig.fromPartial(object.upstream_config)
      : undefined;
    message.track_cluster_stats = (object.track_cluster_stats !== undefined && object.track_cluster_stats !== null)
      ? TrackClusterStats.fromPartial(object.track_cluster_stats)
      : undefined;
    message.preconnect_policy = (object.preconnect_policy !== undefined && object.preconnect_policy !== null)
      ? Cluster_PreconnectPolicy.fromPartial(object.preconnect_policy)
      : undefined;
    message.connection_pool_per_downstream_connection = object.connection_pool_per_downstream_connection ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Cluster.$type, Cluster);

function createBaseCluster_TransportSocketMatch(): Cluster_TransportSocketMatch {
  return { $type: "envoy.config.cluster.v3.Cluster.TransportSocketMatch" };
}

export const Cluster_TransportSocketMatch: MessageFns<
  Cluster_TransportSocketMatch,
  "envoy.config.cluster.v3.Cluster.TransportSocketMatch"
> = {
  $type: "envoy.config.cluster.v3.Cluster.TransportSocketMatch" as const,

  encode(message: Cluster_TransportSocketMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.match !== undefined) {
      Struct.encode(Struct.wrap(message.match), writer.uint32(18).fork()).join();
    }
    if (message.transport_socket !== undefined) {
      TransportSocket.encode(message.transport_socket, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_TransportSocketMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_TransportSocketMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.match = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.transport_socket = TransportSocket.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_TransportSocketMatch {
    return {
      $type: Cluster_TransportSocketMatch.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      match: isObject(object.match) ? object.match : undefined,
      transport_socket: isSet(object.transport_socket) ? TransportSocket.fromJSON(object.transport_socket) : undefined,
    };
  },

  toJSON(message: Cluster_TransportSocketMatch): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.match !== undefined) {
      obj.match = message.match;
    }
    if (message.transport_socket !== undefined) {
      obj.transport_socket = TransportSocket.toJSON(message.transport_socket);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Cluster_TransportSocketMatch>, I>>(base?: I): Cluster_TransportSocketMatch {
    return Cluster_TransportSocketMatch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cluster_TransportSocketMatch>, I>>(object: I): Cluster_TransportSocketMatch {
    const message = createBaseCluster_TransportSocketMatch();
    message.name = object.name ?? undefined;
    message.match = object.match ?? undefined;
    message.transport_socket = (object.transport_socket !== undefined && object.transport_socket !== null)
      ? TransportSocket.fromPartial(object.transport_socket)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Cluster_TransportSocketMatch.$type, Cluster_TransportSocketMatch);

function createBaseCluster_CustomClusterType(): Cluster_CustomClusterType {
  return { $type: "envoy.config.cluster.v3.Cluster.CustomClusterType" };
}

export const Cluster_CustomClusterType: MessageFns<
  Cluster_CustomClusterType,
  "envoy.config.cluster.v3.Cluster.CustomClusterType"
> = {
  $type: "envoy.config.cluster.v3.Cluster.CustomClusterType" as const,

  encode(message: Cluster_CustomClusterType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.typed_config !== undefined) {
      Any.encode(message.typed_config, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_CustomClusterType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_CustomClusterType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.typed_config = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_CustomClusterType {
    return {
      $type: Cluster_CustomClusterType.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      typed_config: isSet(object.typed_config) ? Any.fromJSON(object.typed_config) : undefined,
    };
  },

  toJSON(message: Cluster_CustomClusterType): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.typed_config !== undefined) {
      obj.typed_config = Any.toJSON(message.typed_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Cluster_CustomClusterType>, I>>(base?: I): Cluster_CustomClusterType {
    return Cluster_CustomClusterType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cluster_CustomClusterType>, I>>(object: I): Cluster_CustomClusterType {
    const message = createBaseCluster_CustomClusterType();
    message.name = object.name ?? undefined;
    message.typed_config = (object.typed_config !== undefined && object.typed_config !== null)
      ? Any.fromPartial(object.typed_config)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Cluster_CustomClusterType.$type, Cluster_CustomClusterType);

function createBaseCluster_EdsClusterConfig(): Cluster_EdsClusterConfig {
  return { $type: "envoy.config.cluster.v3.Cluster.EdsClusterConfig" };
}

export const Cluster_EdsClusterConfig: MessageFns<
  Cluster_EdsClusterConfig,
  "envoy.config.cluster.v3.Cluster.EdsClusterConfig"
> = {
  $type: "envoy.config.cluster.v3.Cluster.EdsClusterConfig" as const,

  encode(message: Cluster_EdsClusterConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eds_config !== undefined) {
      ConfigSource.encode(message.eds_config, writer.uint32(10).fork()).join();
    }
    if (message.service_name !== undefined && message.service_name !== "") {
      writer.uint32(18).string(message.service_name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_EdsClusterConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_EdsClusterConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eds_config = ConfigSource.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.service_name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_EdsClusterConfig {
    return {
      $type: Cluster_EdsClusterConfig.$type,
      eds_config: isSet(object.eds_config) ? ConfigSource.fromJSON(object.eds_config) : undefined,
      service_name: isSet(object.service_name) ? globalThis.String(object.service_name) : undefined,
    };
  },

  toJSON(message: Cluster_EdsClusterConfig): unknown {
    const obj: any = {};
    if (message.eds_config !== undefined) {
      obj.eds_config = ConfigSource.toJSON(message.eds_config);
    }
    if (message.service_name !== undefined) {
      obj.service_name = message.service_name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Cluster_EdsClusterConfig>, I>>(base?: I): Cluster_EdsClusterConfig {
    return Cluster_EdsClusterConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cluster_EdsClusterConfig>, I>>(object: I): Cluster_EdsClusterConfig {
    const message = createBaseCluster_EdsClusterConfig();
    message.eds_config = (object.eds_config !== undefined && object.eds_config !== null)
      ? ConfigSource.fromPartial(object.eds_config)
      : undefined;
    message.service_name = object.service_name ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Cluster_EdsClusterConfig.$type, Cluster_EdsClusterConfig);

function createBaseCluster_LbSubsetConfig(): Cluster_LbSubsetConfig {
  return { $type: "envoy.config.cluster.v3.Cluster.LbSubsetConfig" };
}

export const Cluster_LbSubsetConfig: MessageFns<
  Cluster_LbSubsetConfig,
  "envoy.config.cluster.v3.Cluster.LbSubsetConfig"
> = {
  $type: "envoy.config.cluster.v3.Cluster.LbSubsetConfig" as const,

  encode(message: Cluster_LbSubsetConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (
      message.fallback_policy !== undefined &&
      message.fallback_policy !== Cluster_LbSubsetConfig_LbSubsetFallbackPolicy.NO_FALLBACK
    ) {
      writer.uint32(8).int32(cluster_LbSubsetConfig_LbSubsetFallbackPolicyToNumber(message.fallback_policy));
    }
    if (message.default_subset !== undefined) {
      Struct.encode(Struct.wrap(message.default_subset), writer.uint32(18).fork()).join();
    }
    if (message.subset_selectors !== undefined && message.subset_selectors.length !== 0) {
      for (const v of message.subset_selectors) {
        Cluster_LbSubsetConfig_LbSubsetSelector.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    if (message.locality_weight_aware !== undefined && message.locality_weight_aware !== false) {
      writer.uint32(32).bool(message.locality_weight_aware);
    }
    if (message.scale_locality_weight !== undefined && message.scale_locality_weight !== false) {
      writer.uint32(40).bool(message.scale_locality_weight);
    }
    if (message.panic_mode_any !== undefined && message.panic_mode_any !== false) {
      writer.uint32(48).bool(message.panic_mode_any);
    }
    if (message.list_as_any !== undefined && message.list_as_any !== false) {
      writer.uint32(56).bool(message.list_as_any);
    }
    if (
      message.metadata_fallback_policy !== undefined &&
      message.metadata_fallback_policy !== Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy.METADATA_NO_FALLBACK
    ) {
      writer.uint32(64).int32(
        cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicyToNumber(message.metadata_fallback_policy),
      );
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_LbSubsetConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_LbSubsetConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fallback_policy = cluster_LbSubsetConfig_LbSubsetFallbackPolicyFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.default_subset = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.subset_selectors === undefined) {
            message.subset_selectors = [];
          }
          const el = Cluster_LbSubsetConfig_LbSubsetSelector.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.subset_selectors!.push(el);
          }
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.locality_weight_aware = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.scale_locality_weight = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.panic_mode_any = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.list_as_any = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.metadata_fallback_policy = cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicyFromJSON(
            reader.int32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_LbSubsetConfig {
    return {
      $type: Cluster_LbSubsetConfig.$type,
      fallback_policy: isSet(object.fallback_policy)
        ? cluster_LbSubsetConfig_LbSubsetFallbackPolicyFromJSON(object.fallback_policy)
        : undefined,
      default_subset: isObject(object.default_subset) ? object.default_subset : undefined,
      subset_selectors: globalThis.Array.isArray(object?.subset_selectors)
        ? object.subset_selectors.map((e: any) => Cluster_LbSubsetConfig_LbSubsetSelector.fromJSON(e))
        : undefined,
      locality_weight_aware: isSet(object.locality_weight_aware)
        ? globalThis.Boolean(object.locality_weight_aware)
        : undefined,
      scale_locality_weight: isSet(object.scale_locality_weight)
        ? globalThis.Boolean(object.scale_locality_weight)
        : undefined,
      panic_mode_any: isSet(object.panic_mode_any) ? globalThis.Boolean(object.panic_mode_any) : undefined,
      list_as_any: isSet(object.list_as_any) ? globalThis.Boolean(object.list_as_any) : undefined,
      metadata_fallback_policy: isSet(object.metadata_fallback_policy)
        ? cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicyFromJSON(object.metadata_fallback_policy)
        : undefined,
    };
  },

  toJSON(message: Cluster_LbSubsetConfig): unknown {
    const obj: any = {};
    if (message.fallback_policy !== undefined) {
      obj.fallback_policy = cluster_LbSubsetConfig_LbSubsetFallbackPolicyToJSON(message.fallback_policy);
    }
    if (message.default_subset !== undefined) {
      obj.default_subset = message.default_subset;
    }
    if (message.subset_selectors?.length) {
      obj.subset_selectors = message.subset_selectors.map((e) => Cluster_LbSubsetConfig_LbSubsetSelector.toJSON(e));
    }
    if (message.locality_weight_aware !== undefined) {
      obj.locality_weight_aware = message.locality_weight_aware;
    }
    if (message.scale_locality_weight !== undefined) {
      obj.scale_locality_weight = message.scale_locality_weight;
    }
    if (message.panic_mode_any !== undefined) {
      obj.panic_mode_any = message.panic_mode_any;
    }
    if (message.list_as_any !== undefined) {
      obj.list_as_any = message.list_as_any;
    }
    if (message.metadata_fallback_policy !== undefined) {
      obj.metadata_fallback_policy = cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicyToJSON(
        message.metadata_fallback_policy,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Cluster_LbSubsetConfig>, I>>(base?: I): Cluster_LbSubsetConfig {
    return Cluster_LbSubsetConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cluster_LbSubsetConfig>, I>>(object: I): Cluster_LbSubsetConfig {
    const message = createBaseCluster_LbSubsetConfig();
    message.fallback_policy = object.fallback_policy ?? undefined;
    message.default_subset = object.default_subset ?? undefined;
    message.subset_selectors =
      object.subset_selectors?.map((e) => Cluster_LbSubsetConfig_LbSubsetSelector.fromPartial(e)) || undefined;
    message.locality_weight_aware = object.locality_weight_aware ?? undefined;
    message.scale_locality_weight = object.scale_locality_weight ?? undefined;
    message.panic_mode_any = object.panic_mode_any ?? undefined;
    message.list_as_any = object.list_as_any ?? undefined;
    message.metadata_fallback_policy = object.metadata_fallback_policy ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Cluster_LbSubsetConfig.$type, Cluster_LbSubsetConfig);

function createBaseCluster_LbSubsetConfig_LbSubsetSelector(): Cluster_LbSubsetConfig_LbSubsetSelector {
  return { $type: "envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector" };
}

export const Cluster_LbSubsetConfig_LbSubsetSelector: MessageFns<
  Cluster_LbSubsetConfig_LbSubsetSelector,
  "envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector"
> = {
  $type: "envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector" as const,

  encode(message: Cluster_LbSubsetConfig_LbSubsetSelector, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keys !== undefined && message.keys.length !== 0) {
      for (const v of message.keys) {
        writer.uint32(10).string(v!);
      }
    }
    if (message.single_host_per_subset !== undefined && message.single_host_per_subset !== false) {
      writer.uint32(32).bool(message.single_host_per_subset);
    }
    if (
      message.fallback_policy !== undefined &&
      message.fallback_policy !== Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.NOT_DEFINED
    ) {
      writer.uint32(16).int32(
        cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicyToNumber(message.fallback_policy),
      );
    }
    if (message.fallback_keys_subset !== undefined && message.fallback_keys_subset.length !== 0) {
      for (const v of message.fallback_keys_subset) {
        writer.uint32(26).string(v!);
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_LbSubsetConfig_LbSubsetSelector {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_LbSubsetConfig_LbSubsetSelector();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.keys === undefined) {
            message.keys = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.keys!.push(el);
          }
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.single_host_per_subset = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.fallback_policy = cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicyFromJSON(
            reader.int32(),
          );
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.fallback_keys_subset === undefined) {
            message.fallback_keys_subset = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.fallback_keys_subset!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_LbSubsetConfig_LbSubsetSelector {
    return {
      $type: Cluster_LbSubsetConfig_LbSubsetSelector.$type,
      keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e: any) => globalThis.String(e)) : undefined,
      single_host_per_subset: isSet(object.single_host_per_subset)
        ? globalThis.Boolean(object.single_host_per_subset)
        : undefined,
      fallback_policy: isSet(object.fallback_policy)
        ? cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicyFromJSON(object.fallback_policy)
        : undefined,
      fallback_keys_subset: globalThis.Array.isArray(object?.fallback_keys_subset)
        ? object.fallback_keys_subset.map((e: any) => globalThis.String(e))
        : undefined,
    };
  },

  toJSON(message: Cluster_LbSubsetConfig_LbSubsetSelector): unknown {
    const obj: any = {};
    if (message.keys?.length) {
      obj.keys = message.keys;
    }
    if (message.single_host_per_subset !== undefined) {
      obj.single_host_per_subset = message.single_host_per_subset;
    }
    if (message.fallback_policy !== undefined) {
      obj.fallback_policy = cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicyToJSON(
        message.fallback_policy,
      );
    }
    if (message.fallback_keys_subset?.length) {
      obj.fallback_keys_subset = message.fallback_keys_subset;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Cluster_LbSubsetConfig_LbSubsetSelector>, I>>(
    base?: I,
  ): Cluster_LbSubsetConfig_LbSubsetSelector {
    return Cluster_LbSubsetConfig_LbSubsetSelector.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cluster_LbSubsetConfig_LbSubsetSelector>, I>>(
    object: I,
  ): Cluster_LbSubsetConfig_LbSubsetSelector {
    const message = createBaseCluster_LbSubsetConfig_LbSubsetSelector();
    message.keys = object.keys?.map((e) => e) || undefined;
    message.single_host_per_subset = object.single_host_per_subset ?? undefined;
    message.fallback_policy = object.fallback_policy ?? undefined;
    message.fallback_keys_subset = object.fallback_keys_subset?.map((e) => e) || undefined;
    return message;
  },
};

messageTypeRegistry.set(Cluster_LbSubsetConfig_LbSubsetSelector.$type, Cluster_LbSubsetConfig_LbSubsetSelector);

function createBaseCluster_SlowStartConfig(): Cluster_SlowStartConfig {
  return { $type: "envoy.config.cluster.v3.Cluster.SlowStartConfig" };
}

export const Cluster_SlowStartConfig: MessageFns<
  Cluster_SlowStartConfig,
  "envoy.config.cluster.v3.Cluster.SlowStartConfig"
> = {
  $type: "envoy.config.cluster.v3.Cluster.SlowStartConfig" as const,

  encode(message: Cluster_SlowStartConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.slow_start_window !== undefined) {
      Duration.encode(message.slow_start_window, writer.uint32(10).fork()).join();
    }
    if (message.aggression !== undefined) {
      RuntimeDouble.encode(message.aggression, writer.uint32(18).fork()).join();
    }
    if (message.min_weight_percent !== undefined) {
      Percent.encode(message.min_weight_percent, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_SlowStartConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_SlowStartConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.slow_start_window = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.aggression = RuntimeDouble.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.min_weight_percent = Percent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_SlowStartConfig {
    return {
      $type: Cluster_SlowStartConfig.$type,
      slow_start_window: isSet(object.slow_start_window) ? Duration.fromJSON(object.slow_start_window) : undefined,
      aggression: isSet(object.aggression) ? RuntimeDouble.fromJSON(object.aggression) : undefined,
      min_weight_percent: isSet(object.min_weight_percent) ? Percent.fromJSON(object.min_weight_percent) : undefined,
    };
  },

  toJSON(message: Cluster_SlowStartConfig): unknown {
    const obj: any = {};
    if (message.slow_start_window !== undefined) {
      obj.slow_start_window = Duration.toJSON(message.slow_start_window);
    }
    if (message.aggression !== undefined) {
      obj.aggression = RuntimeDouble.toJSON(message.aggression);
    }
    if (message.min_weight_percent !== undefined) {
      obj.min_weight_percent = Percent.toJSON(message.min_weight_percent);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Cluster_SlowStartConfig>, I>>(base?: I): Cluster_SlowStartConfig {
    return Cluster_SlowStartConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cluster_SlowStartConfig>, I>>(object: I): Cluster_SlowStartConfig {
    const message = createBaseCluster_SlowStartConfig();
    message.slow_start_window = (object.slow_start_window !== undefined && object.slow_start_window !== null)
      ? Duration.fromPartial(object.slow_start_window)
      : undefined;
    message.aggression = (object.aggression !== undefined && object.aggression !== null)
      ? RuntimeDouble.fromPartial(object.aggression)
      : undefined;
    message.min_weight_percent = (object.min_weight_percent !== undefined && object.min_weight_percent !== null)
      ? Percent.fromPartial(object.min_weight_percent)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Cluster_SlowStartConfig.$type, Cluster_SlowStartConfig);

function createBaseCluster_RoundRobinLbConfig(): Cluster_RoundRobinLbConfig {
  return { $type: "envoy.config.cluster.v3.Cluster.RoundRobinLbConfig" };
}

export const Cluster_RoundRobinLbConfig: MessageFns<
  Cluster_RoundRobinLbConfig,
  "envoy.config.cluster.v3.Cluster.RoundRobinLbConfig"
> = {
  $type: "envoy.config.cluster.v3.Cluster.RoundRobinLbConfig" as const,

  encode(message: Cluster_RoundRobinLbConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.slow_start_config !== undefined) {
      Cluster_SlowStartConfig.encode(message.slow_start_config, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_RoundRobinLbConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_RoundRobinLbConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.slow_start_config = Cluster_SlowStartConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_RoundRobinLbConfig {
    return {
      $type: Cluster_RoundRobinLbConfig.$type,
      slow_start_config: isSet(object.slow_start_config)
        ? Cluster_SlowStartConfig.fromJSON(object.slow_start_config)
        : undefined,
    };
  },

  toJSON(message: Cluster_RoundRobinLbConfig): unknown {
    const obj: any = {};
    if (message.slow_start_config !== undefined) {
      obj.slow_start_config = Cluster_SlowStartConfig.toJSON(message.slow_start_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Cluster_RoundRobinLbConfig>, I>>(base?: I): Cluster_RoundRobinLbConfig {
    return Cluster_RoundRobinLbConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cluster_RoundRobinLbConfig>, I>>(object: I): Cluster_RoundRobinLbConfig {
    const message = createBaseCluster_RoundRobinLbConfig();
    message.slow_start_config = (object.slow_start_config !== undefined && object.slow_start_config !== null)
      ? Cluster_SlowStartConfig.fromPartial(object.slow_start_config)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Cluster_RoundRobinLbConfig.$type, Cluster_RoundRobinLbConfig);

function createBaseCluster_LeastRequestLbConfig(): Cluster_LeastRequestLbConfig {
  return { $type: "envoy.config.cluster.v3.Cluster.LeastRequestLbConfig" };
}

export const Cluster_LeastRequestLbConfig: MessageFns<
  Cluster_LeastRequestLbConfig,
  "envoy.config.cluster.v3.Cluster.LeastRequestLbConfig"
> = {
  $type: "envoy.config.cluster.v3.Cluster.LeastRequestLbConfig" as const,

  encode(message: Cluster_LeastRequestLbConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.choice_count !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.choice_count! },
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.active_request_bias !== undefined) {
      RuntimeDouble.encode(message.active_request_bias, writer.uint32(18).fork()).join();
    }
    if (message.slow_start_config !== undefined) {
      Cluster_SlowStartConfig.encode(message.slow_start_config, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_LeastRequestLbConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_LeastRequestLbConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.choice_count = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.active_request_bias = RuntimeDouble.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.slow_start_config = Cluster_SlowStartConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_LeastRequestLbConfig {
    return {
      $type: Cluster_LeastRequestLbConfig.$type,
      choice_count: isSet(object.choice_count) ? Number(object.choice_count) : undefined,
      active_request_bias: isSet(object.active_request_bias)
        ? RuntimeDouble.fromJSON(object.active_request_bias)
        : undefined,
      slow_start_config: isSet(object.slow_start_config)
        ? Cluster_SlowStartConfig.fromJSON(object.slow_start_config)
        : undefined,
    };
  },

  toJSON(message: Cluster_LeastRequestLbConfig): unknown {
    const obj: any = {};
    if (message.choice_count !== undefined) {
      obj.choice_count = message.choice_count;
    }
    if (message.active_request_bias !== undefined) {
      obj.active_request_bias = RuntimeDouble.toJSON(message.active_request_bias);
    }
    if (message.slow_start_config !== undefined) {
      obj.slow_start_config = Cluster_SlowStartConfig.toJSON(message.slow_start_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Cluster_LeastRequestLbConfig>, I>>(base?: I): Cluster_LeastRequestLbConfig {
    return Cluster_LeastRequestLbConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cluster_LeastRequestLbConfig>, I>>(object: I): Cluster_LeastRequestLbConfig {
    const message = createBaseCluster_LeastRequestLbConfig();
    message.choice_count = object.choice_count ?? undefined;
    message.active_request_bias = (object.active_request_bias !== undefined && object.active_request_bias !== null)
      ? RuntimeDouble.fromPartial(object.active_request_bias)
      : undefined;
    message.slow_start_config = (object.slow_start_config !== undefined && object.slow_start_config !== null)
      ? Cluster_SlowStartConfig.fromPartial(object.slow_start_config)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Cluster_LeastRequestLbConfig.$type, Cluster_LeastRequestLbConfig);

function createBaseCluster_RingHashLbConfig(): Cluster_RingHashLbConfig {
  return { $type: "envoy.config.cluster.v3.Cluster.RingHashLbConfig" };
}

export const Cluster_RingHashLbConfig: MessageFns<
  Cluster_RingHashLbConfig,
  "envoy.config.cluster.v3.Cluster.RingHashLbConfig"
> = {
  $type: "envoy.config.cluster.v3.Cluster.RingHashLbConfig" as const,

  encode(message: Cluster_RingHashLbConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.minimum_ring_size !== undefined) {
      UInt64Value.encode(
        { $type: "google.protobuf.UInt64Value", value: message.minimum_ring_size! },
        writer.uint32(10).fork(),
      ).join();
    }
    if (
      message.hash_function !== undefined && message.hash_function !== Cluster_RingHashLbConfig_HashFunction.XX_HASH
    ) {
      writer.uint32(24).int32(cluster_RingHashLbConfig_HashFunctionToNumber(message.hash_function));
    }
    if (message.maximum_ring_size !== undefined) {
      UInt64Value.encode(
        { $type: "google.protobuf.UInt64Value", value: message.maximum_ring_size! },
        writer.uint32(34).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_RingHashLbConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_RingHashLbConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.minimum_ring_size = UInt64Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.hash_function = cluster_RingHashLbConfig_HashFunctionFromJSON(reader.int32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.maximum_ring_size = UInt64Value.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_RingHashLbConfig {
    return {
      $type: Cluster_RingHashLbConfig.$type,
      minimum_ring_size: isSet(object.minimum_ring_size) ? Number(object.minimum_ring_size) : undefined,
      hash_function: isSet(object.hash_function)
        ? cluster_RingHashLbConfig_HashFunctionFromJSON(object.hash_function)
        : undefined,
      maximum_ring_size: isSet(object.maximum_ring_size) ? Number(object.maximum_ring_size) : undefined,
    };
  },

  toJSON(message: Cluster_RingHashLbConfig): unknown {
    const obj: any = {};
    if (message.minimum_ring_size !== undefined) {
      obj.minimum_ring_size = message.minimum_ring_size;
    }
    if (message.hash_function !== undefined) {
      obj.hash_function = cluster_RingHashLbConfig_HashFunctionToJSON(message.hash_function);
    }
    if (message.maximum_ring_size !== undefined) {
      obj.maximum_ring_size = message.maximum_ring_size;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Cluster_RingHashLbConfig>, I>>(base?: I): Cluster_RingHashLbConfig {
    return Cluster_RingHashLbConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cluster_RingHashLbConfig>, I>>(object: I): Cluster_RingHashLbConfig {
    const message = createBaseCluster_RingHashLbConfig();
    message.minimum_ring_size = object.minimum_ring_size ?? undefined;
    message.hash_function = object.hash_function ?? undefined;
    message.maximum_ring_size = object.maximum_ring_size ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Cluster_RingHashLbConfig.$type, Cluster_RingHashLbConfig);

function createBaseCluster_MaglevLbConfig(): Cluster_MaglevLbConfig {
  return { $type: "envoy.config.cluster.v3.Cluster.MaglevLbConfig" };
}

export const Cluster_MaglevLbConfig: MessageFns<
  Cluster_MaglevLbConfig,
  "envoy.config.cluster.v3.Cluster.MaglevLbConfig"
> = {
  $type: "envoy.config.cluster.v3.Cluster.MaglevLbConfig" as const,

  encode(message: Cluster_MaglevLbConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.table_size !== undefined) {
      UInt64Value.encode({ $type: "google.protobuf.UInt64Value", value: message.table_size! }, writer.uint32(10).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_MaglevLbConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_MaglevLbConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.table_size = UInt64Value.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_MaglevLbConfig {
    return {
      $type: Cluster_MaglevLbConfig.$type,
      table_size: isSet(object.table_size) ? Number(object.table_size) : undefined,
    };
  },

  toJSON(message: Cluster_MaglevLbConfig): unknown {
    const obj: any = {};
    if (message.table_size !== undefined) {
      obj.table_size = message.table_size;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Cluster_MaglevLbConfig>, I>>(base?: I): Cluster_MaglevLbConfig {
    return Cluster_MaglevLbConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cluster_MaglevLbConfig>, I>>(object: I): Cluster_MaglevLbConfig {
    const message = createBaseCluster_MaglevLbConfig();
    message.table_size = object.table_size ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Cluster_MaglevLbConfig.$type, Cluster_MaglevLbConfig);

function createBaseCluster_OriginalDstLbConfig(): Cluster_OriginalDstLbConfig {
  return { $type: "envoy.config.cluster.v3.Cluster.OriginalDstLbConfig" };
}

export const Cluster_OriginalDstLbConfig: MessageFns<
  Cluster_OriginalDstLbConfig,
  "envoy.config.cluster.v3.Cluster.OriginalDstLbConfig"
> = {
  $type: "envoy.config.cluster.v3.Cluster.OriginalDstLbConfig" as const,

  encode(message: Cluster_OriginalDstLbConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.use_http_header !== undefined && message.use_http_header !== false) {
      writer.uint32(8).bool(message.use_http_header);
    }
    if (message.http_header_name !== undefined && message.http_header_name !== "") {
      writer.uint32(18).string(message.http_header_name);
    }
    if (message.upstream_port_override !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.upstream_port_override! },
        writer.uint32(26).fork(),
      ).join();
    }
    if (message.metadata_key !== undefined) {
      MetadataKey.encode(message.metadata_key, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_OriginalDstLbConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_OriginalDstLbConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.use_http_header = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.http_header_name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.upstream_port_override = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata_key = MetadataKey.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_OriginalDstLbConfig {
    return {
      $type: Cluster_OriginalDstLbConfig.$type,
      use_http_header: isSet(object.use_http_header) ? globalThis.Boolean(object.use_http_header) : undefined,
      http_header_name: isSet(object.http_header_name) ? globalThis.String(object.http_header_name) : undefined,
      upstream_port_override: isSet(object.upstream_port_override) ? Number(object.upstream_port_override) : undefined,
      metadata_key: isSet(object.metadata_key) ? MetadataKey.fromJSON(object.metadata_key) : undefined,
    };
  },

  toJSON(message: Cluster_OriginalDstLbConfig): unknown {
    const obj: any = {};
    if (message.use_http_header !== undefined) {
      obj.use_http_header = message.use_http_header;
    }
    if (message.http_header_name !== undefined) {
      obj.http_header_name = message.http_header_name;
    }
    if (message.upstream_port_override !== undefined) {
      obj.upstream_port_override = message.upstream_port_override;
    }
    if (message.metadata_key !== undefined) {
      obj.metadata_key = MetadataKey.toJSON(message.metadata_key);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Cluster_OriginalDstLbConfig>, I>>(base?: I): Cluster_OriginalDstLbConfig {
    return Cluster_OriginalDstLbConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cluster_OriginalDstLbConfig>, I>>(object: I): Cluster_OriginalDstLbConfig {
    const message = createBaseCluster_OriginalDstLbConfig();
    message.use_http_header = object.use_http_header ?? undefined;
    message.http_header_name = object.http_header_name ?? undefined;
    message.upstream_port_override = object.upstream_port_override ?? undefined;
    message.metadata_key = (object.metadata_key !== undefined && object.metadata_key !== null)
      ? MetadataKey.fromPartial(object.metadata_key)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Cluster_OriginalDstLbConfig.$type, Cluster_OriginalDstLbConfig);

function createBaseCluster_CommonLbConfig(): Cluster_CommonLbConfig {
  return { $type: "envoy.config.cluster.v3.Cluster.CommonLbConfig", locality_config_specifier: undefined };
}

export const Cluster_CommonLbConfig: MessageFns<
  Cluster_CommonLbConfig,
  "envoy.config.cluster.v3.Cluster.CommonLbConfig"
> = {
  $type: "envoy.config.cluster.v3.Cluster.CommonLbConfig" as const,

  encode(message: Cluster_CommonLbConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.healthy_panic_threshold !== undefined) {
      Percent.encode(message.healthy_panic_threshold, writer.uint32(10).fork()).join();
    }
    switch (message.locality_config_specifier?.$case) {
      case "zone_aware_lb_config":
        Cluster_CommonLbConfig_ZoneAwareLbConfig.encode(
          message.locality_config_specifier.zone_aware_lb_config,
          writer.uint32(18).fork(),
        ).join();
        break;
      case "locality_weighted_lb_config":
        Cluster_CommonLbConfig_LocalityWeightedLbConfig.encode(
          message.locality_config_specifier.locality_weighted_lb_config,
          writer.uint32(26).fork(),
        ).join();
        break;
    }
    if (message.update_merge_window !== undefined) {
      Duration.encode(message.update_merge_window, writer.uint32(34).fork()).join();
    }
    if (message.ignore_new_hosts_until_first_hc !== undefined && message.ignore_new_hosts_until_first_hc !== false) {
      writer.uint32(40).bool(message.ignore_new_hosts_until_first_hc);
    }
    if (
      message.close_connections_on_host_set_change !== undefined &&
      message.close_connections_on_host_set_change !== false
    ) {
      writer.uint32(48).bool(message.close_connections_on_host_set_change);
    }
    if (message.consistent_hashing_lb_config !== undefined) {
      Cluster_CommonLbConfig_ConsistentHashingLbConfig.encode(
        message.consistent_hashing_lb_config,
        writer.uint32(58).fork(),
      ).join();
    }
    if (message.override_host_status !== undefined) {
      HealthStatusSet.encode(message.override_host_status, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_CommonLbConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_CommonLbConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.healthy_panic_threshold = Percent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.locality_config_specifier = {
            $case: "zone_aware_lb_config",
            zone_aware_lb_config: Cluster_CommonLbConfig_ZoneAwareLbConfig.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.locality_config_specifier = {
            $case: "locality_weighted_lb_config",
            locality_weighted_lb_config: Cluster_CommonLbConfig_LocalityWeightedLbConfig.decode(
              reader,
              reader.uint32(),
            ),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.update_merge_window = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.ignore_new_hosts_until_first_hc = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.close_connections_on_host_set_change = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.consistent_hashing_lb_config = Cluster_CommonLbConfig_ConsistentHashingLbConfig.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.override_host_status = HealthStatusSet.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_CommonLbConfig {
    return {
      $type: Cluster_CommonLbConfig.$type,
      healthy_panic_threshold: isSet(object.healthy_panic_threshold)
        ? Percent.fromJSON(object.healthy_panic_threshold)
        : undefined,
      locality_config_specifier: isSet(object.zone_aware_lb_config)
        ? {
          $case: "zone_aware_lb_config",
          zone_aware_lb_config: Cluster_CommonLbConfig_ZoneAwareLbConfig.fromJSON(object.zone_aware_lb_config),
        }
        : isSet(object.locality_weighted_lb_config)
        ? {
          $case: "locality_weighted_lb_config",
          locality_weighted_lb_config: Cluster_CommonLbConfig_LocalityWeightedLbConfig.fromJSON(
            object.locality_weighted_lb_config,
          ),
        }
        : undefined,
      update_merge_window: isSet(object.update_merge_window)
        ? Duration.fromJSON(object.update_merge_window)
        : undefined,
      ignore_new_hosts_until_first_hc: isSet(object.ignore_new_hosts_until_first_hc)
        ? globalThis.Boolean(object.ignore_new_hosts_until_first_hc)
        : undefined,
      close_connections_on_host_set_change: isSet(object.close_connections_on_host_set_change)
        ? globalThis.Boolean(object.close_connections_on_host_set_change)
        : undefined,
      consistent_hashing_lb_config: isSet(object.consistent_hashing_lb_config)
        ? Cluster_CommonLbConfig_ConsistentHashingLbConfig.fromJSON(object.consistent_hashing_lb_config)
        : undefined,
      override_host_status: isSet(object.override_host_status)
        ? HealthStatusSet.fromJSON(object.override_host_status)
        : undefined,
    };
  },

  toJSON(message: Cluster_CommonLbConfig): unknown {
    const obj: any = {};
    if (message.healthy_panic_threshold !== undefined) {
      obj.healthy_panic_threshold = Percent.toJSON(message.healthy_panic_threshold);
    }
    if (message.locality_config_specifier?.$case === "zone_aware_lb_config") {
      obj.zone_aware_lb_config = Cluster_CommonLbConfig_ZoneAwareLbConfig.toJSON(
        message.locality_config_specifier.zone_aware_lb_config,
      );
    }
    if (message.locality_config_specifier?.$case === "locality_weighted_lb_config") {
      obj.locality_weighted_lb_config = Cluster_CommonLbConfig_LocalityWeightedLbConfig.toJSON(
        message.locality_config_specifier.locality_weighted_lb_config,
      );
    }
    if (message.update_merge_window !== undefined) {
      obj.update_merge_window = Duration.toJSON(message.update_merge_window);
    }
    if (message.ignore_new_hosts_until_first_hc !== undefined) {
      obj.ignore_new_hosts_until_first_hc = message.ignore_new_hosts_until_first_hc;
    }
    if (message.close_connections_on_host_set_change !== undefined) {
      obj.close_connections_on_host_set_change = message.close_connections_on_host_set_change;
    }
    if (message.consistent_hashing_lb_config !== undefined) {
      obj.consistent_hashing_lb_config = Cluster_CommonLbConfig_ConsistentHashingLbConfig.toJSON(
        message.consistent_hashing_lb_config,
      );
    }
    if (message.override_host_status !== undefined) {
      obj.override_host_status = HealthStatusSet.toJSON(message.override_host_status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Cluster_CommonLbConfig>, I>>(base?: I): Cluster_CommonLbConfig {
    return Cluster_CommonLbConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cluster_CommonLbConfig>, I>>(object: I): Cluster_CommonLbConfig {
    const message = createBaseCluster_CommonLbConfig();
    message.healthy_panic_threshold =
      (object.healthy_panic_threshold !== undefined && object.healthy_panic_threshold !== null)
        ? Percent.fromPartial(object.healthy_panic_threshold)
        : undefined;
    if (
      object.locality_config_specifier?.$case === "zone_aware_lb_config" &&
      object.locality_config_specifier?.zone_aware_lb_config !== undefined &&
      object.locality_config_specifier?.zone_aware_lb_config !== null
    ) {
      message.locality_config_specifier = {
        $case: "zone_aware_lb_config",
        zone_aware_lb_config: Cluster_CommonLbConfig_ZoneAwareLbConfig.fromPartial(
          object.locality_config_specifier.zone_aware_lb_config,
        ),
      };
    }
    if (
      object.locality_config_specifier?.$case === "locality_weighted_lb_config" &&
      object.locality_config_specifier?.locality_weighted_lb_config !== undefined &&
      object.locality_config_specifier?.locality_weighted_lb_config !== null
    ) {
      message.locality_config_specifier = {
        $case: "locality_weighted_lb_config",
        locality_weighted_lb_config: Cluster_CommonLbConfig_LocalityWeightedLbConfig.fromPartial(
          object.locality_config_specifier.locality_weighted_lb_config,
        ),
      };
    }
    message.update_merge_window = (object.update_merge_window !== undefined && object.update_merge_window !== null)
      ? Duration.fromPartial(object.update_merge_window)
      : undefined;
    message.ignore_new_hosts_until_first_hc = object.ignore_new_hosts_until_first_hc ?? undefined;
    message.close_connections_on_host_set_change = object.close_connections_on_host_set_change ?? undefined;
    message.consistent_hashing_lb_config =
      (object.consistent_hashing_lb_config !== undefined && object.consistent_hashing_lb_config !== null)
        ? Cluster_CommonLbConfig_ConsistentHashingLbConfig.fromPartial(object.consistent_hashing_lb_config)
        : undefined;
    message.override_host_status = (object.override_host_status !== undefined && object.override_host_status !== null)
      ? HealthStatusSet.fromPartial(object.override_host_status)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Cluster_CommonLbConfig.$type, Cluster_CommonLbConfig);

function createBaseCluster_CommonLbConfig_ZoneAwareLbConfig(): Cluster_CommonLbConfig_ZoneAwareLbConfig {
  return { $type: "envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig" };
}

export const Cluster_CommonLbConfig_ZoneAwareLbConfig: MessageFns<
  Cluster_CommonLbConfig_ZoneAwareLbConfig,
  "envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig"
> = {
  $type: "envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig" as const,

  encode(message: Cluster_CommonLbConfig_ZoneAwareLbConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.routing_enabled !== undefined) {
      Percent.encode(message.routing_enabled, writer.uint32(10).fork()).join();
    }
    if (message.min_cluster_size !== undefined) {
      UInt64Value.encode(
        { $type: "google.protobuf.UInt64Value", value: message.min_cluster_size! },
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.fail_traffic_on_panic !== undefined && message.fail_traffic_on_panic !== false) {
      writer.uint32(24).bool(message.fail_traffic_on_panic);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_CommonLbConfig_ZoneAwareLbConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_CommonLbConfig_ZoneAwareLbConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.routing_enabled = Percent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.min_cluster_size = UInt64Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.fail_traffic_on_panic = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_CommonLbConfig_ZoneAwareLbConfig {
    return {
      $type: Cluster_CommonLbConfig_ZoneAwareLbConfig.$type,
      routing_enabled: isSet(object.routing_enabled) ? Percent.fromJSON(object.routing_enabled) : undefined,
      min_cluster_size: isSet(object.min_cluster_size) ? Number(object.min_cluster_size) : undefined,
      fail_traffic_on_panic: isSet(object.fail_traffic_on_panic)
        ? globalThis.Boolean(object.fail_traffic_on_panic)
        : undefined,
    };
  },

  toJSON(message: Cluster_CommonLbConfig_ZoneAwareLbConfig): unknown {
    const obj: any = {};
    if (message.routing_enabled !== undefined) {
      obj.routing_enabled = Percent.toJSON(message.routing_enabled);
    }
    if (message.min_cluster_size !== undefined) {
      obj.min_cluster_size = message.min_cluster_size;
    }
    if (message.fail_traffic_on_panic !== undefined) {
      obj.fail_traffic_on_panic = message.fail_traffic_on_panic;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Cluster_CommonLbConfig_ZoneAwareLbConfig>, I>>(
    base?: I,
  ): Cluster_CommonLbConfig_ZoneAwareLbConfig {
    return Cluster_CommonLbConfig_ZoneAwareLbConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cluster_CommonLbConfig_ZoneAwareLbConfig>, I>>(
    object: I,
  ): Cluster_CommonLbConfig_ZoneAwareLbConfig {
    const message = createBaseCluster_CommonLbConfig_ZoneAwareLbConfig();
    message.routing_enabled = (object.routing_enabled !== undefined && object.routing_enabled !== null)
      ? Percent.fromPartial(object.routing_enabled)
      : undefined;
    message.min_cluster_size = object.min_cluster_size ?? undefined;
    message.fail_traffic_on_panic = object.fail_traffic_on_panic ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Cluster_CommonLbConfig_ZoneAwareLbConfig.$type, Cluster_CommonLbConfig_ZoneAwareLbConfig);

function createBaseCluster_CommonLbConfig_LocalityWeightedLbConfig(): Cluster_CommonLbConfig_LocalityWeightedLbConfig {
  return { $type: "envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig" };
}

export const Cluster_CommonLbConfig_LocalityWeightedLbConfig: MessageFns<
  Cluster_CommonLbConfig_LocalityWeightedLbConfig,
  "envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig"
> = {
  $type: "envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig" as const,

  encode(_: Cluster_CommonLbConfig_LocalityWeightedLbConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_CommonLbConfig_LocalityWeightedLbConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_CommonLbConfig_LocalityWeightedLbConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Cluster_CommonLbConfig_LocalityWeightedLbConfig {
    return { $type: Cluster_CommonLbConfig_LocalityWeightedLbConfig.$type };
  },

  toJSON(_: Cluster_CommonLbConfig_LocalityWeightedLbConfig): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Cluster_CommonLbConfig_LocalityWeightedLbConfig>, I>>(
    base?: I,
  ): Cluster_CommonLbConfig_LocalityWeightedLbConfig {
    return Cluster_CommonLbConfig_LocalityWeightedLbConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cluster_CommonLbConfig_LocalityWeightedLbConfig>, I>>(
    _: I,
  ): Cluster_CommonLbConfig_LocalityWeightedLbConfig {
    const message = createBaseCluster_CommonLbConfig_LocalityWeightedLbConfig();
    return message;
  },
};

messageTypeRegistry.set(
  Cluster_CommonLbConfig_LocalityWeightedLbConfig.$type,
  Cluster_CommonLbConfig_LocalityWeightedLbConfig,
);

function createBaseCluster_CommonLbConfig_ConsistentHashingLbConfig(): Cluster_CommonLbConfig_ConsistentHashingLbConfig {
  return { $type: "envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig" };
}

export const Cluster_CommonLbConfig_ConsistentHashingLbConfig: MessageFns<
  Cluster_CommonLbConfig_ConsistentHashingLbConfig,
  "envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig"
> = {
  $type: "envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig" as const,

  encode(
    message: Cluster_CommonLbConfig_ConsistentHashingLbConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.use_hostname_for_hashing !== undefined && message.use_hostname_for_hashing !== false) {
      writer.uint32(8).bool(message.use_hostname_for_hashing);
    }
    if (message.hash_balance_factor !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.hash_balance_factor! },
        writer.uint32(18).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_CommonLbConfig_ConsistentHashingLbConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_CommonLbConfig_ConsistentHashingLbConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.use_hostname_for_hashing = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.hash_balance_factor = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_CommonLbConfig_ConsistentHashingLbConfig {
    return {
      $type: Cluster_CommonLbConfig_ConsistentHashingLbConfig.$type,
      use_hostname_for_hashing: isSet(object.use_hostname_for_hashing)
        ? globalThis.Boolean(object.use_hostname_for_hashing)
        : undefined,
      hash_balance_factor: isSet(object.hash_balance_factor) ? Number(object.hash_balance_factor) : undefined,
    };
  },

  toJSON(message: Cluster_CommonLbConfig_ConsistentHashingLbConfig): unknown {
    const obj: any = {};
    if (message.use_hostname_for_hashing !== undefined) {
      obj.use_hostname_for_hashing = message.use_hostname_for_hashing;
    }
    if (message.hash_balance_factor !== undefined) {
      obj.hash_balance_factor = message.hash_balance_factor;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Cluster_CommonLbConfig_ConsistentHashingLbConfig>, I>>(
    base?: I,
  ): Cluster_CommonLbConfig_ConsistentHashingLbConfig {
    return Cluster_CommonLbConfig_ConsistentHashingLbConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cluster_CommonLbConfig_ConsistentHashingLbConfig>, I>>(
    object: I,
  ): Cluster_CommonLbConfig_ConsistentHashingLbConfig {
    const message = createBaseCluster_CommonLbConfig_ConsistentHashingLbConfig();
    message.use_hostname_for_hashing = object.use_hostname_for_hashing ?? undefined;
    message.hash_balance_factor = object.hash_balance_factor ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(
  Cluster_CommonLbConfig_ConsistentHashingLbConfig.$type,
  Cluster_CommonLbConfig_ConsistentHashingLbConfig,
);

function createBaseCluster_RefreshRate(): Cluster_RefreshRate {
  return { $type: "envoy.config.cluster.v3.Cluster.RefreshRate" };
}

export const Cluster_RefreshRate: MessageFns<Cluster_RefreshRate, "envoy.config.cluster.v3.Cluster.RefreshRate"> = {
  $type: "envoy.config.cluster.v3.Cluster.RefreshRate" as const,

  encode(message: Cluster_RefreshRate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.base_interval !== undefined) {
      Duration.encode(message.base_interval, writer.uint32(10).fork()).join();
    }
    if (message.max_interval !== undefined) {
      Duration.encode(message.max_interval, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_RefreshRate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_RefreshRate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.base_interval = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.max_interval = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_RefreshRate {
    return {
      $type: Cluster_RefreshRate.$type,
      base_interval: isSet(object.base_interval) ? Duration.fromJSON(object.base_interval) : undefined,
      max_interval: isSet(object.max_interval) ? Duration.fromJSON(object.max_interval) : undefined,
    };
  },

  toJSON(message: Cluster_RefreshRate): unknown {
    const obj: any = {};
    if (message.base_interval !== undefined) {
      obj.base_interval = Duration.toJSON(message.base_interval);
    }
    if (message.max_interval !== undefined) {
      obj.max_interval = Duration.toJSON(message.max_interval);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Cluster_RefreshRate>, I>>(base?: I): Cluster_RefreshRate {
    return Cluster_RefreshRate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cluster_RefreshRate>, I>>(object: I): Cluster_RefreshRate {
    const message = createBaseCluster_RefreshRate();
    message.base_interval = (object.base_interval !== undefined && object.base_interval !== null)
      ? Duration.fromPartial(object.base_interval)
      : undefined;
    message.max_interval = (object.max_interval !== undefined && object.max_interval !== null)
      ? Duration.fromPartial(object.max_interval)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Cluster_RefreshRate.$type, Cluster_RefreshRate);

function createBaseCluster_PreconnectPolicy(): Cluster_PreconnectPolicy {
  return { $type: "envoy.config.cluster.v3.Cluster.PreconnectPolicy" };
}

export const Cluster_PreconnectPolicy: MessageFns<
  Cluster_PreconnectPolicy,
  "envoy.config.cluster.v3.Cluster.PreconnectPolicy"
> = {
  $type: "envoy.config.cluster.v3.Cluster.PreconnectPolicy" as const,

  encode(message: Cluster_PreconnectPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.per_upstream_preconnect_ratio !== undefined) {
      DoubleValue.encode(
        { $type: "google.protobuf.DoubleValue", value: message.per_upstream_preconnect_ratio! },
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.predictive_preconnect_ratio !== undefined) {
      DoubleValue.encode(
        { $type: "google.protobuf.DoubleValue", value: message.predictive_preconnect_ratio! },
        writer.uint32(18).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_PreconnectPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_PreconnectPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.per_upstream_preconnect_ratio = DoubleValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.predictive_preconnect_ratio = DoubleValue.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_PreconnectPolicy {
    return {
      $type: Cluster_PreconnectPolicy.$type,
      per_upstream_preconnect_ratio: isSet(object.per_upstream_preconnect_ratio)
        ? Number(object.per_upstream_preconnect_ratio)
        : undefined,
      predictive_preconnect_ratio: isSet(object.predictive_preconnect_ratio)
        ? Number(object.predictive_preconnect_ratio)
        : undefined,
    };
  },

  toJSON(message: Cluster_PreconnectPolicy): unknown {
    const obj: any = {};
    if (message.per_upstream_preconnect_ratio !== undefined) {
      obj.per_upstream_preconnect_ratio = message.per_upstream_preconnect_ratio;
    }
    if (message.predictive_preconnect_ratio !== undefined) {
      obj.predictive_preconnect_ratio = message.predictive_preconnect_ratio;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Cluster_PreconnectPolicy>, I>>(base?: I): Cluster_PreconnectPolicy {
    return Cluster_PreconnectPolicy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cluster_PreconnectPolicy>, I>>(object: I): Cluster_PreconnectPolicy {
    const message = createBaseCluster_PreconnectPolicy();
    message.per_upstream_preconnect_ratio = object.per_upstream_preconnect_ratio ?? undefined;
    message.predictive_preconnect_ratio = object.predictive_preconnect_ratio ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Cluster_PreconnectPolicy.$type, Cluster_PreconnectPolicy);

function createBaseCluster_TypedExtensionProtocolOptionsEntry(): Cluster_TypedExtensionProtocolOptionsEntry {
  return { $type: "envoy.config.cluster.v3.Cluster.TypedExtensionProtocolOptionsEntry", key: "" };
}

export const Cluster_TypedExtensionProtocolOptionsEntry: MessageFns<
  Cluster_TypedExtensionProtocolOptionsEntry,
  "envoy.config.cluster.v3.Cluster.TypedExtensionProtocolOptionsEntry"
> = {
  $type: "envoy.config.cluster.v3.Cluster.TypedExtensionProtocolOptionsEntry" as const,

  encode(message: Cluster_TypedExtensionProtocolOptionsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Any.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_TypedExtensionProtocolOptionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_TypedExtensionProtocolOptionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_TypedExtensionProtocolOptionsEntry {
    return {
      $type: Cluster_TypedExtensionProtocolOptionsEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Any.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Cluster_TypedExtensionProtocolOptionsEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Any.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Cluster_TypedExtensionProtocolOptionsEntry>, I>>(
    base?: I,
  ): Cluster_TypedExtensionProtocolOptionsEntry {
    return Cluster_TypedExtensionProtocolOptionsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cluster_TypedExtensionProtocolOptionsEntry>, I>>(
    object: I,
  ): Cluster_TypedExtensionProtocolOptionsEntry {
    const message = createBaseCluster_TypedExtensionProtocolOptionsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Any.fromPartial(object.value) : undefined;
    return message;
  },
};

messageTypeRegistry.set(Cluster_TypedExtensionProtocolOptionsEntry.$type, Cluster_TypedExtensionProtocolOptionsEntry);

function createBaseLoadBalancingPolicy(): LoadBalancingPolicy {
  return { $type: "envoy.config.cluster.v3.LoadBalancingPolicy" };
}

export const LoadBalancingPolicy: MessageFns<LoadBalancingPolicy, "envoy.config.cluster.v3.LoadBalancingPolicy"> = {
  $type: "envoy.config.cluster.v3.LoadBalancingPolicy" as const,

  encode(message: LoadBalancingPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.policies !== undefined && message.policies.length !== 0) {
      for (const v of message.policies) {
        LoadBalancingPolicy_Policy.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoadBalancingPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoadBalancingPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.policies === undefined) {
            message.policies = [];
          }
          const el = LoadBalancingPolicy_Policy.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.policies!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoadBalancingPolicy {
    return {
      $type: LoadBalancingPolicy.$type,
      policies: globalThis.Array.isArray(object?.policies)
        ? object.policies.map((e: any) => LoadBalancingPolicy_Policy.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: LoadBalancingPolicy): unknown {
    const obj: any = {};
    if (message.policies?.length) {
      obj.policies = message.policies.map((e) => LoadBalancingPolicy_Policy.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoadBalancingPolicy>, I>>(base?: I): LoadBalancingPolicy {
    return LoadBalancingPolicy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoadBalancingPolicy>, I>>(object: I): LoadBalancingPolicy {
    const message = createBaseLoadBalancingPolicy();
    message.policies = object.policies?.map((e) => LoadBalancingPolicy_Policy.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(LoadBalancingPolicy.$type, LoadBalancingPolicy);

function createBaseLoadBalancingPolicy_Policy(): LoadBalancingPolicy_Policy {
  return { $type: "envoy.config.cluster.v3.LoadBalancingPolicy.Policy" };
}

export const LoadBalancingPolicy_Policy: MessageFns<
  LoadBalancingPolicy_Policy,
  "envoy.config.cluster.v3.LoadBalancingPolicy.Policy"
> = {
  $type: "envoy.config.cluster.v3.LoadBalancingPolicy.Policy" as const,

  encode(message: LoadBalancingPolicy_Policy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.typed_extension_config !== undefined) {
      TypedExtensionConfig.encode(message.typed_extension_config, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoadBalancingPolicy_Policy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoadBalancingPolicy_Policy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.typed_extension_config = TypedExtensionConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoadBalancingPolicy_Policy {
    return {
      $type: LoadBalancingPolicy_Policy.$type,
      typed_extension_config: isSet(object.typed_extension_config)
        ? TypedExtensionConfig.fromJSON(object.typed_extension_config)
        : undefined,
    };
  },

  toJSON(message: LoadBalancingPolicy_Policy): unknown {
    const obj: any = {};
    if (message.typed_extension_config !== undefined) {
      obj.typed_extension_config = TypedExtensionConfig.toJSON(message.typed_extension_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoadBalancingPolicy_Policy>, I>>(base?: I): LoadBalancingPolicy_Policy {
    return LoadBalancingPolicy_Policy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoadBalancingPolicy_Policy>, I>>(object: I): LoadBalancingPolicy_Policy {
    const message = createBaseLoadBalancingPolicy_Policy();
    message.typed_extension_config =
      (object.typed_extension_config !== undefined && object.typed_extension_config !== null)
        ? TypedExtensionConfig.fromPartial(object.typed_extension_config)
        : undefined;
    return message;
  },
};

messageTypeRegistry.set(LoadBalancingPolicy_Policy.$type, LoadBalancingPolicy_Policy);

function createBaseUpstreamConnectionOptions(): UpstreamConnectionOptions {
  return { $type: "envoy.config.cluster.v3.UpstreamConnectionOptions" };
}

export const UpstreamConnectionOptions: MessageFns<
  UpstreamConnectionOptions,
  "envoy.config.cluster.v3.UpstreamConnectionOptions"
> = {
  $type: "envoy.config.cluster.v3.UpstreamConnectionOptions" as const,

  encode(message: UpstreamConnectionOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tcp_keepalive !== undefined) {
      TcpKeepalive.encode(message.tcp_keepalive, writer.uint32(10).fork()).join();
    }
    if (
      message.set_local_interface_name_on_upstream_connections !== undefined &&
      message.set_local_interface_name_on_upstream_connections !== false
    ) {
      writer.uint32(16).bool(message.set_local_interface_name_on_upstream_connections);
    }
    if (message.happy_eyeballs_config !== undefined) {
      UpstreamConnectionOptions_HappyEyeballsConfig.encode(message.happy_eyeballs_config, writer.uint32(26).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpstreamConnectionOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpstreamConnectionOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tcp_keepalive = TcpKeepalive.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.set_local_interface_name_on_upstream_connections = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.happy_eyeballs_config = UpstreamConnectionOptions_HappyEyeballsConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpstreamConnectionOptions {
    return {
      $type: UpstreamConnectionOptions.$type,
      tcp_keepalive: isSet(object.tcp_keepalive) ? TcpKeepalive.fromJSON(object.tcp_keepalive) : undefined,
      set_local_interface_name_on_upstream_connections: isSet(object.set_local_interface_name_on_upstream_connections)
        ? globalThis.Boolean(object.set_local_interface_name_on_upstream_connections)
        : undefined,
      happy_eyeballs_config: isSet(object.happy_eyeballs_config)
        ? UpstreamConnectionOptions_HappyEyeballsConfig.fromJSON(object.happy_eyeballs_config)
        : undefined,
    };
  },

  toJSON(message: UpstreamConnectionOptions): unknown {
    const obj: any = {};
    if (message.tcp_keepalive !== undefined) {
      obj.tcp_keepalive = TcpKeepalive.toJSON(message.tcp_keepalive);
    }
    if (message.set_local_interface_name_on_upstream_connections !== undefined) {
      obj.set_local_interface_name_on_upstream_connections = message.set_local_interface_name_on_upstream_connections;
    }
    if (message.happy_eyeballs_config !== undefined) {
      obj.happy_eyeballs_config = UpstreamConnectionOptions_HappyEyeballsConfig.toJSON(message.happy_eyeballs_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpstreamConnectionOptions>, I>>(base?: I): UpstreamConnectionOptions {
    return UpstreamConnectionOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpstreamConnectionOptions>, I>>(object: I): UpstreamConnectionOptions {
    const message = createBaseUpstreamConnectionOptions();
    message.tcp_keepalive = (object.tcp_keepalive !== undefined && object.tcp_keepalive !== null)
      ? TcpKeepalive.fromPartial(object.tcp_keepalive)
      : undefined;
    message.set_local_interface_name_on_upstream_connections =
      object.set_local_interface_name_on_upstream_connections ?? undefined;
    message.happy_eyeballs_config =
      (object.happy_eyeballs_config !== undefined && object.happy_eyeballs_config !== null)
        ? UpstreamConnectionOptions_HappyEyeballsConfig.fromPartial(object.happy_eyeballs_config)
        : undefined;
    return message;
  },
};

messageTypeRegistry.set(UpstreamConnectionOptions.$type, UpstreamConnectionOptions);

function createBaseUpstreamConnectionOptions_HappyEyeballsConfig(): UpstreamConnectionOptions_HappyEyeballsConfig {
  return { $type: "envoy.config.cluster.v3.UpstreamConnectionOptions.HappyEyeballsConfig" };
}

export const UpstreamConnectionOptions_HappyEyeballsConfig: MessageFns<
  UpstreamConnectionOptions_HappyEyeballsConfig,
  "envoy.config.cluster.v3.UpstreamConnectionOptions.HappyEyeballsConfig"
> = {
  $type: "envoy.config.cluster.v3.UpstreamConnectionOptions.HappyEyeballsConfig" as const,

  encode(
    message: UpstreamConnectionOptions_HappyEyeballsConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (
      message.first_address_family_version !== undefined &&
      message.first_address_family_version !== UpstreamConnectionOptions_FirstAddressFamilyVersion.DEFAULT
    ) {
      writer.uint32(8).int32(
        upstreamConnectionOptions_FirstAddressFamilyVersionToNumber(message.first_address_family_version),
      );
    }
    if (message.first_address_family_count !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.first_address_family_count! },
        writer.uint32(18).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpstreamConnectionOptions_HappyEyeballsConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpstreamConnectionOptions_HappyEyeballsConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.first_address_family_version = upstreamConnectionOptions_FirstAddressFamilyVersionFromJSON(
            reader.int32(),
          );
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.first_address_family_count = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpstreamConnectionOptions_HappyEyeballsConfig {
    return {
      $type: UpstreamConnectionOptions_HappyEyeballsConfig.$type,
      first_address_family_version: isSet(object.first_address_family_version)
        ? upstreamConnectionOptions_FirstAddressFamilyVersionFromJSON(object.first_address_family_version)
        : undefined,
      first_address_family_count: isSet(object.first_address_family_count)
        ? Number(object.first_address_family_count)
        : undefined,
    };
  },

  toJSON(message: UpstreamConnectionOptions_HappyEyeballsConfig): unknown {
    const obj: any = {};
    if (message.first_address_family_version !== undefined) {
      obj.first_address_family_version = upstreamConnectionOptions_FirstAddressFamilyVersionToJSON(
        message.first_address_family_version,
      );
    }
    if (message.first_address_family_count !== undefined) {
      obj.first_address_family_count = message.first_address_family_count;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpstreamConnectionOptions_HappyEyeballsConfig>, I>>(
    base?: I,
  ): UpstreamConnectionOptions_HappyEyeballsConfig {
    return UpstreamConnectionOptions_HappyEyeballsConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpstreamConnectionOptions_HappyEyeballsConfig>, I>>(
    object: I,
  ): UpstreamConnectionOptions_HappyEyeballsConfig {
    const message = createBaseUpstreamConnectionOptions_HappyEyeballsConfig();
    message.first_address_family_version = object.first_address_family_version ?? undefined;
    message.first_address_family_count = object.first_address_family_count ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(
  UpstreamConnectionOptions_HappyEyeballsConfig.$type,
  UpstreamConnectionOptions_HappyEyeballsConfig,
);

function createBaseTrackClusterStats(): TrackClusterStats {
  return { $type: "envoy.config.cluster.v3.TrackClusterStats" };
}

export const TrackClusterStats: MessageFns<TrackClusterStats, "envoy.config.cluster.v3.TrackClusterStats"> = {
  $type: "envoy.config.cluster.v3.TrackClusterStats" as const,

  encode(message: TrackClusterStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timeout_budgets !== undefined && message.timeout_budgets !== false) {
      writer.uint32(8).bool(message.timeout_budgets);
    }
    if (message.request_response_sizes !== undefined && message.request_response_sizes !== false) {
      writer.uint32(16).bool(message.request_response_sizes);
    }
    if (message.per_endpoint_stats !== undefined && message.per_endpoint_stats !== false) {
      writer.uint32(24).bool(message.per_endpoint_stats);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrackClusterStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrackClusterStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.timeout_budgets = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.request_response_sizes = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.per_endpoint_stats = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrackClusterStats {
    return {
      $type: TrackClusterStats.$type,
      timeout_budgets: isSet(object.timeout_budgets) ? globalThis.Boolean(object.timeout_budgets) : undefined,
      request_response_sizes: isSet(object.request_response_sizes)
        ? globalThis.Boolean(object.request_response_sizes)
        : undefined,
      per_endpoint_stats: isSet(object.per_endpoint_stats) ? globalThis.Boolean(object.per_endpoint_stats) : undefined,
    };
  },

  toJSON(message: TrackClusterStats): unknown {
    const obj: any = {};
    if (message.timeout_budgets !== undefined) {
      obj.timeout_budgets = message.timeout_budgets;
    }
    if (message.request_response_sizes !== undefined) {
      obj.request_response_sizes = message.request_response_sizes;
    }
    if (message.per_endpoint_stats !== undefined) {
      obj.per_endpoint_stats = message.per_endpoint_stats;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TrackClusterStats>, I>>(base?: I): TrackClusterStats {
    return TrackClusterStats.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TrackClusterStats>, I>>(object: I): TrackClusterStats {
    const message = createBaseTrackClusterStats();
    message.timeout_budgets = object.timeout_budgets ?? undefined;
    message.request_response_sizes = object.request_response_sizes ?? undefined;
    message.per_endpoint_stats = object.per_endpoint_stats ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(TrackClusterStats.$type, TrackClusterStats);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
