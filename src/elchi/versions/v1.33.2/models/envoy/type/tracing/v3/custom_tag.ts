// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/type/tracing/v3/custom_tag.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { messageTypeRegistry } from "../../../../typeRegistry";
import { MetadataKey, MetadataKind } from "../../metadata/v3/metadata";

export const protobufPackage = "envoy.type.tracing.v3";

/**
 * Describes custom tags for the active span.
 * [#next-free-field: 6]
 */
export interface CustomTag {
  $type: "envoy.type.tracing.v3.CustomTag";
  /** Used to populate the tag name. */
  tag?:
    | string
    | undefined;
  /** Used to specify what kind of custom tag. */
  type?:
    | //
    /** A literal custom tag. */
    { $case: "literal"; literal: CustomTag_Literal }
    | //
    /** An environment custom tag. */
    { $case: "environment"; environment: CustomTag_Environment }
    | //
    /** A request header custom tag. */
    { $case: "request_header"; request_header: CustomTag_Header }
    | //
    /** A custom tag to obtain tag value from the metadata. */
    { $case: "metadata"; metadata: CustomTag_Metadata }
    | undefined;
}

/** Literal type custom tag with static value for the tag value. */
export interface CustomTag_Literal {
  $type: "envoy.type.tracing.v3.CustomTag.Literal";
  /** Static literal value to populate the tag value. */
  value?: string | undefined;
}

/** Environment type custom tag with environment name and default value. */
export interface CustomTag_Environment {
  $type: "envoy.type.tracing.v3.CustomTag.Environment";
  /** Environment variable name to obtain the value to populate the tag value. */
  name?:
    | string
    | undefined;
  /**
   * When the environment variable is not found,
   * the tag value will be populated with this default value if specified,
   * otherwise no tag will be populated.
   */
  default_value?: string | undefined;
}

/** Header type custom tag with header name and default value. */
export interface CustomTag_Header {
  $type: "envoy.type.tracing.v3.CustomTag.Header";
  /** Header name to obtain the value to populate the tag value. */
  name?:
    | string
    | undefined;
  /**
   * When the header does not exist,
   * the tag value will be populated with this default value if specified,
   * otherwise no tag will be populated.
   */
  default_value?: string | undefined;
}

/**
 * Metadata type custom tag using
 * :ref:`MetadataKey <envoy_v3_api_msg_type.metadata.v3.MetadataKey>` to retrieve the protobuf value
 * from :ref:`Metadata <envoy_v3_api_msg_config.core.v3.Metadata>`, and populate the tag value with
 * `the canonical JSON <https://developers.google.com/protocol-buffers/docs/proto3#json>`_
 * representation of it.
 */
export interface CustomTag_Metadata {
  $type: "envoy.type.tracing.v3.CustomTag.Metadata";
  /** Specify what kind of metadata to obtain tag value from. */
  kind?:
    | MetadataKind
    | undefined;
  /** Metadata key to define the path to retrieve the tag value. */
  metadata_key?:
    | MetadataKey
    | undefined;
  /**
   * When no valid metadata is found,
   * the tag value would be populated with this default value if specified,
   * otherwise no tag would be populated.
   */
  default_value?: string | undefined;
}

function createBaseCustomTag(): CustomTag {
  return { $type: "envoy.type.tracing.v3.CustomTag", type: undefined };
}

export const CustomTag: MessageFns<CustomTag, "envoy.type.tracing.v3.CustomTag"> = {
  $type: "envoy.type.tracing.v3.CustomTag" as const,

  encode(message: CustomTag, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tag !== undefined && message.tag !== "") {
      writer.uint32(10).string(message.tag);
    }
    switch (message.type?.$case) {
      case "literal":
        CustomTag_Literal.encode(message.type.literal, writer.uint32(18).fork()).join();
        break;
      case "environment":
        CustomTag_Environment.encode(message.type.environment, writer.uint32(26).fork()).join();
        break;
      case "request_header":
        CustomTag_Header.encode(message.type.request_header, writer.uint32(34).fork()).join();
        break;
      case "metadata":
        CustomTag_Metadata.encode(message.type.metadata, writer.uint32(42).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomTag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tag = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type = { $case: "literal", literal: CustomTag_Literal.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.type = { $case: "environment", environment: CustomTag_Environment.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.type = { $case: "request_header", request_header: CustomTag_Header.decode(reader, reader.uint32()) };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.type = { $case: "metadata", metadata: CustomTag_Metadata.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomTag {
    return {
      $type: CustomTag.$type,
      tag: isSet(object.tag) ? globalThis.String(object.tag) : undefined,
      type: isSet(object.literal)
        ? { $case: "literal", literal: CustomTag_Literal.fromJSON(object.literal) }
        : isSet(object.environment)
        ? { $case: "environment", environment: CustomTag_Environment.fromJSON(object.environment) }
        : isSet(object.request_header)
        ? { $case: "request_header", request_header: CustomTag_Header.fromJSON(object.request_header) }
        : isSet(object.metadata)
        ? { $case: "metadata", metadata: CustomTag_Metadata.fromJSON(object.metadata) }
        : undefined,
    };
  },

  toJSON(message: CustomTag): unknown {
    const obj: any = {};
    if (message.tag !== undefined) {
      obj.tag = message.tag;
    }
    if (message.type?.$case === "literal") {
      obj.literal = CustomTag_Literal.toJSON(message.type.literal);
    }
    if (message.type?.$case === "environment") {
      obj.environment = CustomTag_Environment.toJSON(message.type.environment);
    }
    if (message.type?.$case === "request_header") {
      obj.request_header = CustomTag_Header.toJSON(message.type.request_header);
    }
    if (message.type?.$case === "metadata") {
      obj.metadata = CustomTag_Metadata.toJSON(message.type.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CustomTag>, I>>(base?: I): CustomTag {
    return CustomTag.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustomTag>, I>>(object: I): CustomTag {
    const message = createBaseCustomTag();
    message.tag = object.tag ?? undefined;
    if (object.type?.$case === "literal" && object.type?.literal !== undefined && object.type?.literal !== null) {
      message.type = { $case: "literal", literal: CustomTag_Literal.fromPartial(object.type.literal) };
    }
    if (
      object.type?.$case === "environment" &&
      object.type?.environment !== undefined &&
      object.type?.environment !== null
    ) {
      message.type = { $case: "environment", environment: CustomTag_Environment.fromPartial(object.type.environment) };
    }
    if (
      object.type?.$case === "request_header" &&
      object.type?.request_header !== undefined &&
      object.type?.request_header !== null
    ) {
      message.type = {
        $case: "request_header",
        request_header: CustomTag_Header.fromPartial(object.type.request_header),
      };
    }
    if (object.type?.$case === "metadata" && object.type?.metadata !== undefined && object.type?.metadata !== null) {
      message.type = { $case: "metadata", metadata: CustomTag_Metadata.fromPartial(object.type.metadata) };
    }
    return message;
  },
};

messageTypeRegistry.set(CustomTag.$type, CustomTag);

function createBaseCustomTag_Literal(): CustomTag_Literal {
  return { $type: "envoy.type.tracing.v3.CustomTag.Literal" };
}

export const CustomTag_Literal: MessageFns<CustomTag_Literal, "envoy.type.tracing.v3.CustomTag.Literal"> = {
  $type: "envoy.type.tracing.v3.CustomTag.Literal" as const,

  encode(message: CustomTag_Literal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined && message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomTag_Literal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomTag_Literal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomTag_Literal {
    return { $type: CustomTag_Literal.$type, value: isSet(object.value) ? globalThis.String(object.value) : undefined };
  },

  toJSON(message: CustomTag_Literal): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CustomTag_Literal>, I>>(base?: I): CustomTag_Literal {
    return CustomTag_Literal.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustomTag_Literal>, I>>(object: I): CustomTag_Literal {
    const message = createBaseCustomTag_Literal();
    message.value = object.value ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(CustomTag_Literal.$type, CustomTag_Literal);

function createBaseCustomTag_Environment(): CustomTag_Environment {
  return { $type: "envoy.type.tracing.v3.CustomTag.Environment" };
}

export const CustomTag_Environment: MessageFns<CustomTag_Environment, "envoy.type.tracing.v3.CustomTag.Environment"> = {
  $type: "envoy.type.tracing.v3.CustomTag.Environment" as const,

  encode(message: CustomTag_Environment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.default_value !== undefined && message.default_value !== "") {
      writer.uint32(18).string(message.default_value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomTag_Environment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomTag_Environment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.default_value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomTag_Environment {
    return {
      $type: CustomTag_Environment.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      default_value: isSet(object.default_value) ? globalThis.String(object.default_value) : undefined,
    };
  },

  toJSON(message: CustomTag_Environment): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.default_value !== undefined) {
      obj.default_value = message.default_value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CustomTag_Environment>, I>>(base?: I): CustomTag_Environment {
    return CustomTag_Environment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustomTag_Environment>, I>>(object: I): CustomTag_Environment {
    const message = createBaseCustomTag_Environment();
    message.name = object.name ?? undefined;
    message.default_value = object.default_value ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(CustomTag_Environment.$type, CustomTag_Environment);

function createBaseCustomTag_Header(): CustomTag_Header {
  return { $type: "envoy.type.tracing.v3.CustomTag.Header" };
}

export const CustomTag_Header: MessageFns<CustomTag_Header, "envoy.type.tracing.v3.CustomTag.Header"> = {
  $type: "envoy.type.tracing.v3.CustomTag.Header" as const,

  encode(message: CustomTag_Header, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.default_value !== undefined && message.default_value !== "") {
      writer.uint32(18).string(message.default_value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomTag_Header {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomTag_Header();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.default_value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomTag_Header {
    return {
      $type: CustomTag_Header.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      default_value: isSet(object.default_value) ? globalThis.String(object.default_value) : undefined,
    };
  },

  toJSON(message: CustomTag_Header): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.default_value !== undefined) {
      obj.default_value = message.default_value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CustomTag_Header>, I>>(base?: I): CustomTag_Header {
    return CustomTag_Header.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustomTag_Header>, I>>(object: I): CustomTag_Header {
    const message = createBaseCustomTag_Header();
    message.name = object.name ?? undefined;
    message.default_value = object.default_value ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(CustomTag_Header.$type, CustomTag_Header);

function createBaseCustomTag_Metadata(): CustomTag_Metadata {
  return { $type: "envoy.type.tracing.v3.CustomTag.Metadata" };
}

export const CustomTag_Metadata: MessageFns<CustomTag_Metadata, "envoy.type.tracing.v3.CustomTag.Metadata"> = {
  $type: "envoy.type.tracing.v3.CustomTag.Metadata" as const,

  encode(message: CustomTag_Metadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kind !== undefined) {
      MetadataKind.encode(message.kind, writer.uint32(10).fork()).join();
    }
    if (message.metadata_key !== undefined) {
      MetadataKey.encode(message.metadata_key, writer.uint32(18).fork()).join();
    }
    if (message.default_value !== undefined && message.default_value !== "") {
      writer.uint32(26).string(message.default_value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomTag_Metadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomTag_Metadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.kind = MetadataKind.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.metadata_key = MetadataKey.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.default_value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomTag_Metadata {
    return {
      $type: CustomTag_Metadata.$type,
      kind: isSet(object.kind) ? MetadataKind.fromJSON(object.kind) : undefined,
      metadata_key: isSet(object.metadata_key) ? MetadataKey.fromJSON(object.metadata_key) : undefined,
      default_value: isSet(object.default_value) ? globalThis.String(object.default_value) : undefined,
    };
  },

  toJSON(message: CustomTag_Metadata): unknown {
    const obj: any = {};
    if (message.kind !== undefined) {
      obj.kind = MetadataKind.toJSON(message.kind);
    }
    if (message.metadata_key !== undefined) {
      obj.metadata_key = MetadataKey.toJSON(message.metadata_key);
    }
    if (message.default_value !== undefined) {
      obj.default_value = message.default_value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CustomTag_Metadata>, I>>(base?: I): CustomTag_Metadata {
    return CustomTag_Metadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustomTag_Metadata>, I>>(object: I): CustomTag_Metadata {
    const message = createBaseCustomTag_Metadata();
    message.kind = (object.kind !== undefined && object.kind !== null)
      ? MetadataKind.fromPartial(object.kind)
      : undefined;
    message.metadata_key = (object.metadata_key !== undefined && object.metadata_key !== null)
      ? MetadataKey.fromPartial(object.metadata_key)
      : undefined;
    message.default_value = object.default_value ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(CustomTag_Metadata.$type, CustomTag_Metadata);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
