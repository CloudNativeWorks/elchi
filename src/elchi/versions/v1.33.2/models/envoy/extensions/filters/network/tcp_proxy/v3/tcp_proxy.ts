// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/filters/network/tcp_proxy/v3/tcp_proxy.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../../../../google/protobuf/duration";
import { UInt32Value } from "../../../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../../../typeRegistry";
import { AccessLog } from "../../../../../config/accesslog/v3/accesslog";
import { HeaderValueOption, Metadata } from "../../../../../config/core/v3/base";
import { ConfigSource } from "../../../../../config/core/v3/config_source";
import { HashPolicy } from "../../../../../type/v3/hash_policy";

export const protobufPackage = "envoy.extensions.filters.network.tcp_proxy.v3";

/** [#next-free-field: 18] */
export interface TcpProxy {
  $type: "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy";
  /**
   * The prefix to use when emitting :ref:`statistics
   * <config_network_filters_tcp_proxy_stats>`.
   */
  stat_prefix?: string | undefined;
  cluster_specifier?:
    | //
    /** The upstream cluster to connect to. */
    { $case: "cluster"; cluster: string }
    | //
    /**
     * Multiple upstream clusters can be specified for a given route. The
     * request is routed to one of the upstream clusters based on weights
     * assigned to each cluster.
     */
    { $case: "weighted_clusters"; weighted_clusters: TcpProxy_WeightedCluster }
    | undefined;
  /**
   * The on demand policy for the upstream cluster.
   * It applies to both
   * :ref:`TcpProxy.cluster <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.cluster>`
   * and
   * :ref:`TcpProxy.weighted_clusters <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.weighted_clusters>`.
   */
  on_demand?:
    | TcpProxy_OnDemand
    | undefined;
  /**
   * Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints
   * in the upstream cluster with metadata matching what is set in this field will be considered
   * for load balancing. The filter name should be specified as ``envoy.lb``.
   */
  metadata_match?:
    | Metadata
    | undefined;
  /**
   * The idle timeout for connections managed by the TCP proxy filter. The idle timeout
   * is defined as the period in which there are no bytes sent or received on either
   * the upstream or downstream connection. If not set, the default idle timeout is 1 hour. If set
   * to 0s, the timeout will be disabled.
   * It is possible to dynamically override this configuration by setting a per-connection filter
   * state object for the key ``envoy.tcp_proxy.per_connection_idle_timeout_ms``.
   *
   * .. warning::
   *   Disabling this timeout has a highly likelihood of yielding connection leaks due to lost TCP
   *   FIN packets, etc.
   */
  idle_timeout?:
    | Duration
    | undefined;
  /**
   * [#not-implemented-hide:] The idle timeout for connections managed by the TCP proxy
   * filter. The idle timeout is defined as the period in which there is no
   * active traffic. If not set, there is no idle timeout. When the idle timeout
   * is reached the connection will be closed. The distinction between
   * downstream_idle_timeout/upstream_idle_timeout provides a means to set
   * timeout based on the last byte sent on the downstream/upstream connection.
   */
  downstream_idle_timeout?:
    | Duration
    | undefined;
  /** [#not-implemented-hide:] */
  upstream_idle_timeout?:
    | Duration
    | undefined;
  /**
   * Configuration for :ref:`access logs <arch_overview_access_logs>`
   * emitted by the this tcp_proxy.
   */
  access_log?:
    | AccessLog[]
    | undefined;
  /**
   * The maximum number of unsuccessful connection attempts that will be made before
   * giving up. If the parameter is not specified, 1 connection attempt will be made.
   */
  max_connect_attempts?:
    | number
    | undefined;
  /**
   * Optional configuration for TCP proxy hash policy. If hash_policy is not set, the hash-based
   * load balancing algorithms will select a host randomly. Currently the number of hash policies is
   * limited to 1.
   */
  hash_policy?:
    | HashPolicy[]
    | undefined;
  /**
   * If set, this configures tunneling, e.g. configuration options to tunnel TCP payload over
   * HTTP CONNECT. If this message is absent, the payload will be proxied upstream as per usual.
   * It is possible to dynamically override this configuration and disable tunneling per connection,
   * by setting a per-connection filter state object for the key ``envoy.tcp_proxy.disable_tunneling``.
   */
  tunneling_config?:
    | TcpProxy_TunnelingConfig
    | undefined;
  /**
   * The maximum duration of a connection. The duration is defined as the period since a connection
   * was established. If not set, there is no max duration. When max_downstream_connection_duration
   * is reached the connection will be closed. Duration must be at least 1ms.
   */
  max_downstream_connection_duration?:
    | Duration
    | undefined;
  /**
   * .. attention::
   * This field is deprecated in favor of
   * :ref:`access_log_flush_interval
   * <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions.access_log_flush_interval>`.
   * Note that if both this field and :ref:`access_log_flush_interval
   * <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions.access_log_flush_interval>`
   * are specified, the former (deprecated field) is ignored.
   *
   * @deprecated
   */
  access_log_flush_interval?:
    | Duration
    | undefined;
  /**
   * .. attention::
   * This field is deprecated in favor of
   * :ref:`flush_access_log_on_connected
   * <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions.flush_access_log_on_connected>`.
   * Note that if both this field and :ref:`flush_access_log_on_connected
   * <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions.flush_access_log_on_connected>`
   * are specified, the former (deprecated field) is ignored.
   *
   * @deprecated
   */
  flush_access_log_on_connected?:
    | boolean
    | undefined;
  /** Additional access log options for TCP Proxy. */
  access_log_options?: TcpProxy_TcpAccessLogOptions | undefined;
}

/**
 * Allows for specification of multiple upstream clusters along with weights
 * that indicate the percentage of traffic to be forwarded to each cluster.
 * The router selects an upstream cluster based on these weights.
 */
export interface TcpProxy_WeightedCluster {
  $type: "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.WeightedCluster";
  /** Specifies one or more upstream clusters associated with the route. */
  clusters?: TcpProxy_WeightedCluster_ClusterWeight[] | undefined;
}

export interface TcpProxy_WeightedCluster_ClusterWeight {
  $type: "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.WeightedCluster.ClusterWeight";
  /** Name of the upstream cluster. */
  name?:
    | string
    | undefined;
  /**
   * When a request matches the route, the choice of an upstream cluster is
   * determined by its weight. The sum of weights across all entries in the
   * clusters array determines the total weight.
   */
  weight?:
    | number
    | undefined;
  /**
   * Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints
   * in the upstream cluster with metadata matching what is set in this field will be considered
   * for load balancing. Note that this will be merged with what's provided in
   * :ref:`TcpProxy.metadata_match
   * <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.metadata_match>`, with values
   * here taking precedence. The filter name should be specified as ``envoy.lb``.
   */
  metadata_match?: Metadata | undefined;
}

/**
 * Configuration for tunneling TCP over other transports or application layers.
 * Tunneling is supported over both HTTP/1.1 and HTTP/2. Upstream protocol is
 * determined by the cluster configuration.
 * [#next-free-field: 7]
 */
export interface TcpProxy_TunnelingConfig {
  $type: "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.TunnelingConfig";
  /**
   * The hostname to send in the synthesized CONNECT headers to the upstream proxy.
   * This field evaluates command operators if set, otherwise returns hostname as is.
   *
   * Example: dynamically set hostname using downstream SNI
   *
   * .. code-block:: yaml
   *
   *    tunneling_config:
   *      hostname: "%REQUESTED_SERVER_NAME%:443"
   *
   * Example: dynamically set hostname using dynamic metadata
   *
   * .. code-block:: yaml
   *
   *    tunneling_config:
   *      hostname: "%DYNAMIC_METADATA(tunnel:address)%"
   */
  hostname?:
    | string
    | undefined;
  /**
   * Use POST method instead of CONNECT method to tunnel the TCP stream.
   * The 'protocol: bytestream' header is also NOT set for HTTP/2 to comply with the spec.
   *
   * The upstream proxy is expected to convert POST payload as raw TCP.
   */
  use_post?:
    | boolean
    | undefined;
  /**
   * Additional request headers to upstream proxy. This is mainly used to
   * trigger upstream to convert POST requests back to CONNECT requests.
   *
   * Neither ``:-prefixed`` pseudo-headers nor the Host: header can be overridden.
   */
  headers_to_add?:
    | HeaderValueOption[]
    | undefined;
  /**
   * Save the response headers to the downstream info filter state for consumption
   * by the network filters. The filter state key is ``envoy.tcp_proxy.propagate_response_headers``.
   */
  propagate_response_headers?:
    | boolean
    | undefined;
  /**
   * The path used with POST method. Default path is ``/``. If post path is specified and
   * :ref:`use_post field <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.TunnelingConfig.use_post>`
   * isn't true, it will be rejected.
   */
  post_path?:
    | string
    | undefined;
  /**
   * Save the response trailers to the downstream info filter state for consumption
   * by the network filters. The filter state key is ``envoy.tcp_proxy.propagate_response_trailers``.
   */
  propagate_response_trailers?: boolean | undefined;
}

export interface TcpProxy_OnDemand {
  $type: "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.OnDemand";
  /**
   * An optional configuration for on-demand cluster discovery
   * service. If not specified, the on-demand cluster discovery will
   * be disabled. When it's specified, the filter will pause a request
   * to an unknown cluster and will begin a cluster discovery
   * process. When the discovery is finished (successfully or not),
   * the request will be resumed.
   */
  odcds_config?:
    | ConfigSource
    | undefined;
  /**
   * xdstp:// resource locator for on-demand cluster collection.
   * [#not-implemented-hide:]
   */
  resources_locator?:
    | string
    | undefined;
  /**
   * The timeout for on demand cluster lookup. If the CDS cannot return the required cluster,
   * the downstream request will be closed with the error code detail NO_CLUSTER_FOUND.
   * [#not-implemented-hide:]
   */
  timeout?: Duration | undefined;
}

export interface TcpProxy_TcpAccessLogOptions {
  $type: "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions";
  /**
   * The interval to flush access log. The TCP proxy will flush only one access log when the connection
   * is closed by default. If this field is set, the TCP proxy will flush access log periodically with
   * the specified interval.
   * The interval must be at least 1ms.
   */
  access_log_flush_interval?:
    | Duration
    | undefined;
  /**
   * If set to true, access log will be flushed when the TCP proxy has successfully established a
   * connection with the upstream. If the connection failed, the access log will not be flushed.
   */
  flush_access_log_on_connected?: boolean | undefined;
}

function createBaseTcpProxy(): TcpProxy {
  return { $type: "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy", cluster_specifier: undefined };
}

export const TcpProxy: MessageFns<TcpProxy, "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy"> = {
  $type: "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy" as const,

  encode(message: TcpProxy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stat_prefix !== undefined && message.stat_prefix !== "") {
      writer.uint32(10).string(message.stat_prefix);
    }
    switch (message.cluster_specifier?.$case) {
      case "cluster":
        writer.uint32(18).string(message.cluster_specifier.cluster);
        break;
      case "weighted_clusters":
        TcpProxy_WeightedCluster.encode(message.cluster_specifier.weighted_clusters, writer.uint32(82).fork()).join();
        break;
    }
    if (message.on_demand !== undefined) {
      TcpProxy_OnDemand.encode(message.on_demand, writer.uint32(114).fork()).join();
    }
    if (message.metadata_match !== undefined) {
      Metadata.encode(message.metadata_match, writer.uint32(74).fork()).join();
    }
    if (message.idle_timeout !== undefined) {
      Duration.encode(message.idle_timeout, writer.uint32(66).fork()).join();
    }
    if (message.downstream_idle_timeout !== undefined) {
      Duration.encode(message.downstream_idle_timeout, writer.uint32(26).fork()).join();
    }
    if (message.upstream_idle_timeout !== undefined) {
      Duration.encode(message.upstream_idle_timeout, writer.uint32(34).fork()).join();
    }
    if (message.access_log !== undefined && message.access_log.length !== 0) {
      for (const v of message.access_log) {
        AccessLog.encode(v!, writer.uint32(42).fork()).join();
      }
    }
    if (message.max_connect_attempts !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.max_connect_attempts! },
        writer.uint32(58).fork(),
      ).join();
    }
    if (message.hash_policy !== undefined && message.hash_policy.length !== 0) {
      for (const v of message.hash_policy) {
        HashPolicy.encode(v!, writer.uint32(90).fork()).join();
      }
    }
    if (message.tunneling_config !== undefined) {
      TcpProxy_TunnelingConfig.encode(message.tunneling_config, writer.uint32(98).fork()).join();
    }
    if (message.max_downstream_connection_duration !== undefined) {
      Duration.encode(message.max_downstream_connection_duration, writer.uint32(106).fork()).join();
    }
    if (message.access_log_flush_interval !== undefined) {
      Duration.encode(message.access_log_flush_interval, writer.uint32(122).fork()).join();
    }
    if (message.flush_access_log_on_connected !== undefined && message.flush_access_log_on_connected !== false) {
      writer.uint32(128).bool(message.flush_access_log_on_connected);
    }
    if (message.access_log_options !== undefined) {
      TcpProxy_TcpAccessLogOptions.encode(message.access_log_options, writer.uint32(138).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TcpProxy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTcpProxy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stat_prefix = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cluster_specifier = { $case: "cluster", cluster: reader.string() };
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.cluster_specifier = {
            $case: "weighted_clusters",
            weighted_clusters: TcpProxy_WeightedCluster.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.on_demand = TcpProxy_OnDemand.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.metadata_match = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.idle_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.downstream_idle_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.upstream_idle_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          if (message.access_log === undefined) {
            message.access_log = [];
          }
          const el = AccessLog.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.access_log!.push(el);
          }
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.max_connect_attempts = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          if (message.hash_policy === undefined) {
            message.hash_policy = [];
          }
          const el = HashPolicy.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.hash_policy!.push(el);
          }
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.tunneling_config = TcpProxy_TunnelingConfig.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.max_downstream_connection_duration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.access_log_flush_interval = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.flush_access_log_on_connected = reader.bool();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.access_log_options = TcpProxy_TcpAccessLogOptions.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TcpProxy {
    return {
      $type: TcpProxy.$type,
      stat_prefix: isSet(object.stat_prefix) ? globalThis.String(object.stat_prefix) : undefined,
      cluster_specifier: isSet(object.cluster)
        ? { $case: "cluster", cluster: globalThis.String(object.cluster) }
        : isSet(object.weighted_clusters)
        ? { $case: "weighted_clusters", weighted_clusters: TcpProxy_WeightedCluster.fromJSON(object.weighted_clusters) }
        : undefined,
      on_demand: isSet(object.on_demand) ? TcpProxy_OnDemand.fromJSON(object.on_demand) : undefined,
      metadata_match: isSet(object.metadata_match) ? Metadata.fromJSON(object.metadata_match) : undefined,
      idle_timeout: isSet(object.idle_timeout) ? Duration.fromJSON(object.idle_timeout) : undefined,
      downstream_idle_timeout: isSet(object.downstream_idle_timeout)
        ? Duration.fromJSON(object.downstream_idle_timeout)
        : undefined,
      upstream_idle_timeout: isSet(object.upstream_idle_timeout)
        ? Duration.fromJSON(object.upstream_idle_timeout)
        : undefined,
      access_log: globalThis.Array.isArray(object?.access_log)
        ? object.access_log.map((e: any) => AccessLog.fromJSON(e))
        : undefined,
      max_connect_attempts: isSet(object.max_connect_attempts) ? Number(object.max_connect_attempts) : undefined,
      hash_policy: globalThis.Array.isArray(object?.hash_policy)
        ? object.hash_policy.map((e: any) => HashPolicy.fromJSON(e))
        : undefined,
      tunneling_config: isSet(object.tunneling_config)
        ? TcpProxy_TunnelingConfig.fromJSON(object.tunneling_config)
        : undefined,
      max_downstream_connection_duration: isSet(object.max_downstream_connection_duration)
        ? Duration.fromJSON(object.max_downstream_connection_duration)
        : undefined,
      access_log_flush_interval: isSet(object.access_log_flush_interval)
        ? Duration.fromJSON(object.access_log_flush_interval)
        : undefined,
      flush_access_log_on_connected: isSet(object.flush_access_log_on_connected)
        ? globalThis.Boolean(object.flush_access_log_on_connected)
        : undefined,
      access_log_options: isSet(object.access_log_options)
        ? TcpProxy_TcpAccessLogOptions.fromJSON(object.access_log_options)
        : undefined,
    };
  },

  toJSON(message: TcpProxy): unknown {
    const obj: any = {};
    if (message.stat_prefix !== undefined) {
      obj.stat_prefix = message.stat_prefix;
    }
    if (message.cluster_specifier?.$case === "cluster") {
      obj.cluster = message.cluster_specifier.cluster;
    }
    if (message.cluster_specifier?.$case === "weighted_clusters") {
      obj.weighted_clusters = TcpProxy_WeightedCluster.toJSON(message.cluster_specifier.weighted_clusters);
    }
    if (message.on_demand !== undefined) {
      obj.on_demand = TcpProxy_OnDemand.toJSON(message.on_demand);
    }
    if (message.metadata_match !== undefined) {
      obj.metadata_match = Metadata.toJSON(message.metadata_match);
    }
    if (message.idle_timeout !== undefined) {
      obj.idle_timeout = Duration.toJSON(message.idle_timeout);
    }
    if (message.downstream_idle_timeout !== undefined) {
      obj.downstream_idle_timeout = Duration.toJSON(message.downstream_idle_timeout);
    }
    if (message.upstream_idle_timeout !== undefined) {
      obj.upstream_idle_timeout = Duration.toJSON(message.upstream_idle_timeout);
    }
    if (message.access_log?.length) {
      obj.access_log = message.access_log.map((e) => AccessLog.toJSON(e));
    }
    if (message.max_connect_attempts !== undefined) {
      obj.max_connect_attempts = message.max_connect_attempts;
    }
    if (message.hash_policy?.length) {
      obj.hash_policy = message.hash_policy.map((e) => HashPolicy.toJSON(e));
    }
    if (message.tunneling_config !== undefined) {
      obj.tunneling_config = TcpProxy_TunnelingConfig.toJSON(message.tunneling_config);
    }
    if (message.max_downstream_connection_duration !== undefined) {
      obj.max_downstream_connection_duration = Duration.toJSON(message.max_downstream_connection_duration);
    }
    if (message.access_log_flush_interval !== undefined) {
      obj.access_log_flush_interval = Duration.toJSON(message.access_log_flush_interval);
    }
    if (message.flush_access_log_on_connected !== undefined) {
      obj.flush_access_log_on_connected = message.flush_access_log_on_connected;
    }
    if (message.access_log_options !== undefined) {
      obj.access_log_options = TcpProxy_TcpAccessLogOptions.toJSON(message.access_log_options);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TcpProxy>, I>>(base?: I): TcpProxy {
    return TcpProxy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TcpProxy>, I>>(object: I): TcpProxy {
    const message = createBaseTcpProxy();
    message.stat_prefix = object.stat_prefix ?? undefined;
    if (
      object.cluster_specifier?.$case === "cluster" &&
      object.cluster_specifier?.cluster !== undefined &&
      object.cluster_specifier?.cluster !== null
    ) {
      message.cluster_specifier = { $case: "cluster", cluster: object.cluster_specifier.cluster };
    }
    if (
      object.cluster_specifier?.$case === "weighted_clusters" &&
      object.cluster_specifier?.weighted_clusters !== undefined &&
      object.cluster_specifier?.weighted_clusters !== null
    ) {
      message.cluster_specifier = {
        $case: "weighted_clusters",
        weighted_clusters: TcpProxy_WeightedCluster.fromPartial(object.cluster_specifier.weighted_clusters),
      };
    }
    message.on_demand = (object.on_demand !== undefined && object.on_demand !== null)
      ? TcpProxy_OnDemand.fromPartial(object.on_demand)
      : undefined;
    message.metadata_match = (object.metadata_match !== undefined && object.metadata_match !== null)
      ? Metadata.fromPartial(object.metadata_match)
      : undefined;
    message.idle_timeout = (object.idle_timeout !== undefined && object.idle_timeout !== null)
      ? Duration.fromPartial(object.idle_timeout)
      : undefined;
    message.downstream_idle_timeout =
      (object.downstream_idle_timeout !== undefined && object.downstream_idle_timeout !== null)
        ? Duration.fromPartial(object.downstream_idle_timeout)
        : undefined;
    message.upstream_idle_timeout =
      (object.upstream_idle_timeout !== undefined && object.upstream_idle_timeout !== null)
        ? Duration.fromPartial(object.upstream_idle_timeout)
        : undefined;
    message.access_log = object.access_log?.map((e) => AccessLog.fromPartial(e)) || undefined;
    message.max_connect_attempts = object.max_connect_attempts ?? undefined;
    message.hash_policy = object.hash_policy?.map((e) => HashPolicy.fromPartial(e)) || undefined;
    message.tunneling_config = (object.tunneling_config !== undefined && object.tunneling_config !== null)
      ? TcpProxy_TunnelingConfig.fromPartial(object.tunneling_config)
      : undefined;
    message.max_downstream_connection_duration =
      (object.max_downstream_connection_duration !== undefined && object.max_downstream_connection_duration !== null)
        ? Duration.fromPartial(object.max_downstream_connection_duration)
        : undefined;
    message.access_log_flush_interval =
      (object.access_log_flush_interval !== undefined && object.access_log_flush_interval !== null)
        ? Duration.fromPartial(object.access_log_flush_interval)
        : undefined;
    message.flush_access_log_on_connected = object.flush_access_log_on_connected ?? undefined;
    message.access_log_options = (object.access_log_options !== undefined && object.access_log_options !== null)
      ? TcpProxy_TcpAccessLogOptions.fromPartial(object.access_log_options)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(TcpProxy.$type, TcpProxy);

function createBaseTcpProxy_WeightedCluster(): TcpProxy_WeightedCluster {
  return { $type: "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.WeightedCluster" };
}

export const TcpProxy_WeightedCluster: MessageFns<
  TcpProxy_WeightedCluster,
  "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.WeightedCluster"
> = {
  $type: "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.WeightedCluster" as const,

  encode(message: TcpProxy_WeightedCluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clusters !== undefined && message.clusters.length !== 0) {
      for (const v of message.clusters) {
        TcpProxy_WeightedCluster_ClusterWeight.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TcpProxy_WeightedCluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTcpProxy_WeightedCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.clusters === undefined) {
            message.clusters = [];
          }
          const el = TcpProxy_WeightedCluster_ClusterWeight.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.clusters!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TcpProxy_WeightedCluster {
    return {
      $type: TcpProxy_WeightedCluster.$type,
      clusters: globalThis.Array.isArray(object?.clusters)
        ? object.clusters.map((e: any) => TcpProxy_WeightedCluster_ClusterWeight.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: TcpProxy_WeightedCluster): unknown {
    const obj: any = {};
    if (message.clusters?.length) {
      obj.clusters = message.clusters.map((e) => TcpProxy_WeightedCluster_ClusterWeight.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TcpProxy_WeightedCluster>, I>>(base?: I): TcpProxy_WeightedCluster {
    return TcpProxy_WeightedCluster.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TcpProxy_WeightedCluster>, I>>(object: I): TcpProxy_WeightedCluster {
    const message = createBaseTcpProxy_WeightedCluster();
    message.clusters = object.clusters?.map((e) => TcpProxy_WeightedCluster_ClusterWeight.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(TcpProxy_WeightedCluster.$type, TcpProxy_WeightedCluster);

function createBaseTcpProxy_WeightedCluster_ClusterWeight(): TcpProxy_WeightedCluster_ClusterWeight {
  return { $type: "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.WeightedCluster.ClusterWeight" };
}

export const TcpProxy_WeightedCluster_ClusterWeight: MessageFns<
  TcpProxy_WeightedCluster_ClusterWeight,
  "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.WeightedCluster.ClusterWeight"
> = {
  $type: "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.WeightedCluster.ClusterWeight" as const,

  encode(message: TcpProxy_WeightedCluster_ClusterWeight, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.weight !== undefined && message.weight !== 0) {
      writer.uint32(16).uint32(message.weight);
    }
    if (message.metadata_match !== undefined) {
      Metadata.encode(message.metadata_match, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TcpProxy_WeightedCluster_ClusterWeight {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTcpProxy_WeightedCluster_ClusterWeight();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.weight = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata_match = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TcpProxy_WeightedCluster_ClusterWeight {
    return {
      $type: TcpProxy_WeightedCluster_ClusterWeight.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      weight: isSet(object.weight) ? globalThis.Number(object.weight) : undefined,
      metadata_match: isSet(object.metadata_match) ? Metadata.fromJSON(object.metadata_match) : undefined,
    };
  },

  toJSON(message: TcpProxy_WeightedCluster_ClusterWeight): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.weight !== undefined) {
      obj.weight = Math.round(message.weight);
    }
    if (message.metadata_match !== undefined) {
      obj.metadata_match = Metadata.toJSON(message.metadata_match);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TcpProxy_WeightedCluster_ClusterWeight>, I>>(
    base?: I,
  ): TcpProxy_WeightedCluster_ClusterWeight {
    return TcpProxy_WeightedCluster_ClusterWeight.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TcpProxy_WeightedCluster_ClusterWeight>, I>>(
    object: I,
  ): TcpProxy_WeightedCluster_ClusterWeight {
    const message = createBaseTcpProxy_WeightedCluster_ClusterWeight();
    message.name = object.name ?? undefined;
    message.weight = object.weight ?? undefined;
    message.metadata_match = (object.metadata_match !== undefined && object.metadata_match !== null)
      ? Metadata.fromPartial(object.metadata_match)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(TcpProxy_WeightedCluster_ClusterWeight.$type, TcpProxy_WeightedCluster_ClusterWeight);

function createBaseTcpProxy_TunnelingConfig(): TcpProxy_TunnelingConfig {
  return { $type: "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.TunnelingConfig" };
}

export const TcpProxy_TunnelingConfig: MessageFns<
  TcpProxy_TunnelingConfig,
  "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.TunnelingConfig"
> = {
  $type: "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.TunnelingConfig" as const,

  encode(message: TcpProxy_TunnelingConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hostname !== undefined && message.hostname !== "") {
      writer.uint32(10).string(message.hostname);
    }
    if (message.use_post !== undefined && message.use_post !== false) {
      writer.uint32(16).bool(message.use_post);
    }
    if (message.headers_to_add !== undefined && message.headers_to_add.length !== 0) {
      for (const v of message.headers_to_add) {
        HeaderValueOption.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    if (message.propagate_response_headers !== undefined && message.propagate_response_headers !== false) {
      writer.uint32(32).bool(message.propagate_response_headers);
    }
    if (message.post_path !== undefined && message.post_path !== "") {
      writer.uint32(42).string(message.post_path);
    }
    if (message.propagate_response_trailers !== undefined && message.propagate_response_trailers !== false) {
      writer.uint32(48).bool(message.propagate_response_trailers);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TcpProxy_TunnelingConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTcpProxy_TunnelingConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hostname = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.use_post = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.headers_to_add === undefined) {
            message.headers_to_add = [];
          }
          const el = HeaderValueOption.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.headers_to_add!.push(el);
          }
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.propagate_response_headers = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.post_path = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.propagate_response_trailers = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TcpProxy_TunnelingConfig {
    return {
      $type: TcpProxy_TunnelingConfig.$type,
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : undefined,
      use_post: isSet(object.use_post) ? globalThis.Boolean(object.use_post) : undefined,
      headers_to_add: globalThis.Array.isArray(object?.headers_to_add)
        ? object.headers_to_add.map((e: any) => HeaderValueOption.fromJSON(e))
        : undefined,
      propagate_response_headers: isSet(object.propagate_response_headers)
        ? globalThis.Boolean(object.propagate_response_headers)
        : undefined,
      post_path: isSet(object.post_path) ? globalThis.String(object.post_path) : undefined,
      propagate_response_trailers: isSet(object.propagate_response_trailers)
        ? globalThis.Boolean(object.propagate_response_trailers)
        : undefined,
    };
  },

  toJSON(message: TcpProxy_TunnelingConfig): unknown {
    const obj: any = {};
    if (message.hostname !== undefined) {
      obj.hostname = message.hostname;
    }
    if (message.use_post !== undefined) {
      obj.use_post = message.use_post;
    }
    if (message.headers_to_add?.length) {
      obj.headers_to_add = message.headers_to_add.map((e) => HeaderValueOption.toJSON(e));
    }
    if (message.propagate_response_headers !== undefined) {
      obj.propagate_response_headers = message.propagate_response_headers;
    }
    if (message.post_path !== undefined) {
      obj.post_path = message.post_path;
    }
    if (message.propagate_response_trailers !== undefined) {
      obj.propagate_response_trailers = message.propagate_response_trailers;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TcpProxy_TunnelingConfig>, I>>(base?: I): TcpProxy_TunnelingConfig {
    return TcpProxy_TunnelingConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TcpProxy_TunnelingConfig>, I>>(object: I): TcpProxy_TunnelingConfig {
    const message = createBaseTcpProxy_TunnelingConfig();
    message.hostname = object.hostname ?? undefined;
    message.use_post = object.use_post ?? undefined;
    message.headers_to_add = object.headers_to_add?.map((e) => HeaderValueOption.fromPartial(e)) || undefined;
    message.propagate_response_headers = object.propagate_response_headers ?? undefined;
    message.post_path = object.post_path ?? undefined;
    message.propagate_response_trailers = object.propagate_response_trailers ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(TcpProxy_TunnelingConfig.$type, TcpProxy_TunnelingConfig);

function createBaseTcpProxy_OnDemand(): TcpProxy_OnDemand {
  return { $type: "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.OnDemand" };
}

export const TcpProxy_OnDemand: MessageFns<
  TcpProxy_OnDemand,
  "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.OnDemand"
> = {
  $type: "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.OnDemand" as const,

  encode(message: TcpProxy_OnDemand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.odcds_config !== undefined) {
      ConfigSource.encode(message.odcds_config, writer.uint32(10).fork()).join();
    }
    if (message.resources_locator !== undefined && message.resources_locator !== "") {
      writer.uint32(18).string(message.resources_locator);
    }
    if (message.timeout !== undefined) {
      Duration.encode(message.timeout, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TcpProxy_OnDemand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTcpProxy_OnDemand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.odcds_config = ConfigSource.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.resources_locator = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TcpProxy_OnDemand {
    return {
      $type: TcpProxy_OnDemand.$type,
      odcds_config: isSet(object.odcds_config) ? ConfigSource.fromJSON(object.odcds_config) : undefined,
      resources_locator: isSet(object.resources_locator) ? globalThis.String(object.resources_locator) : undefined,
      timeout: isSet(object.timeout) ? Duration.fromJSON(object.timeout) : undefined,
    };
  },

  toJSON(message: TcpProxy_OnDemand): unknown {
    const obj: any = {};
    if (message.odcds_config !== undefined) {
      obj.odcds_config = ConfigSource.toJSON(message.odcds_config);
    }
    if (message.resources_locator !== undefined) {
      obj.resources_locator = message.resources_locator;
    }
    if (message.timeout !== undefined) {
      obj.timeout = Duration.toJSON(message.timeout);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TcpProxy_OnDemand>, I>>(base?: I): TcpProxy_OnDemand {
    return TcpProxy_OnDemand.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TcpProxy_OnDemand>, I>>(object: I): TcpProxy_OnDemand {
    const message = createBaseTcpProxy_OnDemand();
    message.odcds_config = (object.odcds_config !== undefined && object.odcds_config !== null)
      ? ConfigSource.fromPartial(object.odcds_config)
      : undefined;
    message.resources_locator = object.resources_locator ?? undefined;
    message.timeout = (object.timeout !== undefined && object.timeout !== null)
      ? Duration.fromPartial(object.timeout)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(TcpProxy_OnDemand.$type, TcpProxy_OnDemand);

function createBaseTcpProxy_TcpAccessLogOptions(): TcpProxy_TcpAccessLogOptions {
  return { $type: "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions" };
}

export const TcpProxy_TcpAccessLogOptions: MessageFns<
  TcpProxy_TcpAccessLogOptions,
  "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions"
> = {
  $type: "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions" as const,

  encode(message: TcpProxy_TcpAccessLogOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.access_log_flush_interval !== undefined) {
      Duration.encode(message.access_log_flush_interval, writer.uint32(10).fork()).join();
    }
    if (message.flush_access_log_on_connected !== undefined && message.flush_access_log_on_connected !== false) {
      writer.uint32(16).bool(message.flush_access_log_on_connected);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TcpProxy_TcpAccessLogOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTcpProxy_TcpAccessLogOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.access_log_flush_interval = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.flush_access_log_on_connected = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TcpProxy_TcpAccessLogOptions {
    return {
      $type: TcpProxy_TcpAccessLogOptions.$type,
      access_log_flush_interval: isSet(object.access_log_flush_interval)
        ? Duration.fromJSON(object.access_log_flush_interval)
        : undefined,
      flush_access_log_on_connected: isSet(object.flush_access_log_on_connected)
        ? globalThis.Boolean(object.flush_access_log_on_connected)
        : undefined,
    };
  },

  toJSON(message: TcpProxy_TcpAccessLogOptions): unknown {
    const obj: any = {};
    if (message.access_log_flush_interval !== undefined) {
      obj.access_log_flush_interval = Duration.toJSON(message.access_log_flush_interval);
    }
    if (message.flush_access_log_on_connected !== undefined) {
      obj.flush_access_log_on_connected = message.flush_access_log_on_connected;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TcpProxy_TcpAccessLogOptions>, I>>(base?: I): TcpProxy_TcpAccessLogOptions {
    return TcpProxy_TcpAccessLogOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TcpProxy_TcpAccessLogOptions>, I>>(object: I): TcpProxy_TcpAccessLogOptions {
    const message = createBaseTcpProxy_TcpAccessLogOptions();
    message.access_log_flush_interval =
      (object.access_log_flush_interval !== undefined && object.access_log_flush_interval !== null)
        ? Duration.fromPartial(object.access_log_flush_interval)
        : undefined;
    message.flush_access_log_on_connected = object.flush_access_log_on_connected ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(TcpProxy_TcpAccessLogOptions.$type, TcpProxy_TcpAccessLogOptions);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
