// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/api/v2/core/base.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Any } from "../../../../google/protobuf/any";
import { Struct } from "../../../../google/protobuf/struct";
import { BoolValue, UInt32Value } from "../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../typeRegistry";
import { FractionalPercent } from "../../../type/percent";
import { SemanticVersion } from "../../../type/semantic_version";
import { Address } from "./address";
import { BackoffStrategy } from "./backoff";
import { HttpUri } from "./http_uri";

export const protobufPackage = "envoy.api.v2.core";

/**
 * Envoy supports :ref:`upstream priority routing
 * <arch_overview_http_routing_priority>` both at the route and the virtual
 * cluster level. The current priority implementation uses different connection
 * pool and circuit breaking settings for each priority level. This means that
 * even for HTTP/2 requests, two physical connections will be used to an
 * upstream host. In the future Envoy will likely support true HTTP/2 priority
 * over a single upstream connection.
 */
export enum RoutingPriority {
  DEFAULT = "DEFAULT",
  HIGH = "HIGH",
}

export function routingPriorityFromJSON(object: any): RoutingPriority {
  switch (object) {
    case 0:
    case "DEFAULT":
      return RoutingPriority.DEFAULT;
    case 1:
    case "HIGH":
      return RoutingPriority.HIGH;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RoutingPriority");
  }
}

export function routingPriorityToJSON(object: RoutingPriority): string {
  switch (object) {
    case RoutingPriority.DEFAULT:
      return "DEFAULT";
    case RoutingPriority.HIGH:
      return "HIGH";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RoutingPriority");
  }
}

export function routingPriorityToNumber(object: RoutingPriority): number {
  switch (object) {
    case RoutingPriority.DEFAULT:
      return 0;
    case RoutingPriority.HIGH:
      return 1;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RoutingPriority");
  }
}

/** HTTP request method. */
export enum RequestMethod {
  METHOD_UNSPECIFIED = "METHOD_UNSPECIFIED",
  GET = "GET",
  HEAD = "HEAD",
  POST = "POST",
  PUT = "PUT",
  DELETE = "DELETE",
  CONNECT = "CONNECT",
  OPTIONS = "OPTIONS",
  TRACE = "TRACE",
  PATCH = "PATCH",
}

export function requestMethodFromJSON(object: any): RequestMethod {
  switch (object) {
    case 0:
    case "METHOD_UNSPECIFIED":
      return RequestMethod.METHOD_UNSPECIFIED;
    case 1:
    case "GET":
      return RequestMethod.GET;
    case 2:
    case "HEAD":
      return RequestMethod.HEAD;
    case 3:
    case "POST":
      return RequestMethod.POST;
    case 4:
    case "PUT":
      return RequestMethod.PUT;
    case 5:
    case "DELETE":
      return RequestMethod.DELETE;
    case 6:
    case "CONNECT":
      return RequestMethod.CONNECT;
    case 7:
    case "OPTIONS":
      return RequestMethod.OPTIONS;
    case 8:
    case "TRACE":
      return RequestMethod.TRACE;
    case 9:
    case "PATCH":
      return RequestMethod.PATCH;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RequestMethod");
  }
}

export function requestMethodToJSON(object: RequestMethod): string {
  switch (object) {
    case RequestMethod.METHOD_UNSPECIFIED:
      return "METHOD_UNSPECIFIED";
    case RequestMethod.GET:
      return "GET";
    case RequestMethod.HEAD:
      return "HEAD";
    case RequestMethod.POST:
      return "POST";
    case RequestMethod.PUT:
      return "PUT";
    case RequestMethod.DELETE:
      return "DELETE";
    case RequestMethod.CONNECT:
      return "CONNECT";
    case RequestMethod.OPTIONS:
      return "OPTIONS";
    case RequestMethod.TRACE:
      return "TRACE";
    case RequestMethod.PATCH:
      return "PATCH";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RequestMethod");
  }
}

export function requestMethodToNumber(object: RequestMethod): number {
  switch (object) {
    case RequestMethod.METHOD_UNSPECIFIED:
      return 0;
    case RequestMethod.GET:
      return 1;
    case RequestMethod.HEAD:
      return 2;
    case RequestMethod.POST:
      return 3;
    case RequestMethod.PUT:
      return 4;
    case RequestMethod.DELETE:
      return 5;
    case RequestMethod.CONNECT:
      return 6;
    case RequestMethod.OPTIONS:
      return 7;
    case RequestMethod.TRACE:
      return 8;
    case RequestMethod.PATCH:
      return 9;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RequestMethod");
  }
}

/** Identifies the direction of the traffic relative to the local Envoy. */
export enum TrafficDirection {
  /** UNSPECIFIED - Default option is unspecified. */
  UNSPECIFIED = "UNSPECIFIED",
  /** INBOUND - The transport is used for incoming traffic. */
  INBOUND = "INBOUND",
  /** OUTBOUND - The transport is used for outgoing traffic. */
  OUTBOUND = "OUTBOUND",
}

export function trafficDirectionFromJSON(object: any): TrafficDirection {
  switch (object) {
    case 0:
    case "UNSPECIFIED":
      return TrafficDirection.UNSPECIFIED;
    case 1:
    case "INBOUND":
      return TrafficDirection.INBOUND;
    case 2:
    case "OUTBOUND":
      return TrafficDirection.OUTBOUND;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum TrafficDirection");
  }
}

export function trafficDirectionToJSON(object: TrafficDirection): string {
  switch (object) {
    case TrafficDirection.UNSPECIFIED:
      return "UNSPECIFIED";
    case TrafficDirection.INBOUND:
      return "INBOUND";
    case TrafficDirection.OUTBOUND:
      return "OUTBOUND";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum TrafficDirection");
  }
}

export function trafficDirectionToNumber(object: TrafficDirection): number {
  switch (object) {
    case TrafficDirection.UNSPECIFIED:
      return 0;
    case TrafficDirection.INBOUND:
      return 1;
    case TrafficDirection.OUTBOUND:
      return 2;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum TrafficDirection");
  }
}

/** Identifies location of where either Envoy runs or where upstream hosts run. */
export interface Locality {
  $type: "envoy.api.v2.core.Locality";
  /** Region this :ref:`zone <envoy_api_field_core.Locality.zone>` belongs to. */
  region?:
    | string
    | undefined;
  /**
   * Defines the local service zone where Envoy is running. Though optional, it
   * should be set if discovery service routing is used and the discovery
   * service exposes :ref:`zone data <envoy_api_field_endpoint.LocalityLbEndpoints.locality>`,
   * either in this message or via :option:`--service-zone`. The meaning of zone
   * is context dependent, e.g. `Availability Zone (AZ)
   * <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html>`_
   * on AWS, `Zone <https://cloud.google.com/compute/docs/regions-zones/>`_ on
   * GCP, etc.
   */
  zone?:
    | string
    | undefined;
  /**
   * When used for locality of upstream hosts, this field further splits zone
   * into smaller chunks of sub-zones so they can be load balanced
   * independently.
   */
  sub_zone?: string | undefined;
}

/**
 * BuildVersion combines SemVer version of extension with free-form build information
 * (i.e. 'alpha', 'private-build') as a set of strings.
 */
export interface BuildVersion {
  $type: "envoy.api.v2.core.BuildVersion";
  /** SemVer version of extension. */
  version?:
    | SemanticVersion
    | undefined;
  /**
   * Free-form build information.
   * Envoy defines several well known keys in the source/common/version/version.h file
   */
  metadata?: { [key: string]: any } | undefined;
}

/**
 * Version and identification for an Envoy extension.
 * [#next-free-field: 6]
 */
export interface Extension {
  $type: "envoy.api.v2.core.Extension";
  /**
   * This is the name of the Envoy filter as specified in the Envoy
   * configuration, e.g. envoy.filters.http.router, com.acme.widget.
   */
  name?:
    | string
    | undefined;
  /**
   * Category of the extension.
   * Extension category names use reverse DNS notation. For instance "envoy.filters.listener"
   * for Envoy's built-in listener filters or "com.acme.filters.http" for HTTP filters from
   * acme.com vendor.
   * [#comment:TODO(yanavlasov): Link to the doc with existing envoy category names.]
   */
  category?:
    | string
    | undefined;
  /**
   * [#not-implemented-hide:] Type descriptor of extension configuration proto.
   * [#comment:TODO(yanavlasov): Link to the doc with existing configuration protos.]
   * [#comment:TODO(yanavlasov): Add tests when PR #9391 lands.]
   */
  type_descriptor?:
    | string
    | undefined;
  /**
   * The version is a property of the extension and maintained independently
   * of other extensions and the Envoy API.
   * This field is not set when extension did not provide version information.
   */
  version?:
    | BuildVersion
    | undefined;
  /** Indicates that the extension is present but was disabled via dynamic configuration. */
  disabled?: boolean | undefined;
}

/**
 * Identifies a specific Envoy instance. The node identifier is presented to the
 * management server, which may use this identifier to distinguish per Envoy
 * configuration for serving.
 * [#next-free-field: 12]
 */
export interface Node {
  $type: "envoy.api.v2.core.Node";
  /**
   * An opaque node identifier for the Envoy node. This also provides the local
   * service node name. It should be set if any of the following features are
   * used: :ref:`statsd <arch_overview_statistics>`, :ref:`CDS
   * <config_cluster_manager_cds>`, and :ref:`HTTP tracing
   * <arch_overview_tracing>`, either in this message or via
   * :option:`--service-node`.
   */
  id?:
    | string
    | undefined;
  /**
   * Defines the local service cluster name where Envoy is running. Though
   * optional, it should be set if any of the following features are used:
   * :ref:`statsd <arch_overview_statistics>`, :ref:`health check cluster
   * verification
   * <envoy_api_field_core.HealthCheck.HttpHealthCheck.service_name_matcher>`,
   * :ref:`runtime override directory <envoy_api_msg_config.bootstrap.v2.Runtime>`,
   * :ref:`user agent addition
   * <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.add_user_agent>`,
   * :ref:`HTTP global rate limiting <config_http_filters_rate_limit>`,
   * :ref:`CDS <config_cluster_manager_cds>`, and :ref:`HTTP tracing
   * <arch_overview_tracing>`, either in this message or via
   * :option:`--service-cluster`.
   */
  cluster?:
    | string
    | undefined;
  /**
   * Opaque metadata extending the node identifier. Envoy will pass this
   * directly to the management server.
   */
  metadata?:
    | { [key: string]: any }
    | undefined;
  /** Locality specifying where the Envoy instance is running. */
  locality?:
    | Locality
    | undefined;
  /**
   * This is motivated by informing a management server during canary which
   * version of Envoy is being tested in a heterogeneous fleet. This will be set
   * by Envoy in management server RPCs.
   * This field is deprecated in favor of the user_agent_name and user_agent_version values.
   *
   * @deprecated
   */
  build_version?:
    | string
    | undefined;
  /**
   * Free-form string that identifies the entity requesting config.
   * E.g. "envoy" or "grpc"
   */
  user_agent_name?: string | undefined;
  user_agent_version_type?:
    | //
    /**
     * Free-form string that identifies the version of the entity requesting config.
     * E.g. "1.12.2" or "abcd1234", or "SpecialEnvoyBuild"
     */
    { $case: "user_agent_version"; user_agent_version: string }
    | //
    /** Structured version of the entity requesting config. */
    { $case: "user_agent_build_version"; user_agent_build_version: BuildVersion }
    | undefined;
  /** List of extensions and their versions supported by the node. */
  extensions?:
    | Extension[]
    | undefined;
  /**
   * Client feature support list. These are well known features described
   * in the Envoy API repository for a given major version of an API. Client features
   * use reverse DNS naming scheme, for example `com.acme.feature`.
   * See :ref:`the list of features <client_features>` that xDS client may
   * support.
   */
  client_features?:
    | string[]
    | undefined;
  /**
   * Known listening ports on the node as a generic hint to the management server
   * for filtering :ref:`listeners <config_listeners>` to be returned. For example,
   * if there is a listener bound to port 80, the list can optionally contain the
   * SocketAddress `(0.0.0.0,80)`. The field is optional and just a hint.
   */
  listening_addresses?: Address[] | undefined;
}

/**
 * Metadata provides additional inputs to filters based on matched listeners,
 * filter chains, routes and endpoints. It is structured as a map, usually from
 * filter name (in reverse DNS format) to metadata specific to the filter. Metadata
 * key-values for a filter are merged as connection and request handling occurs,
 * with later values for the same key overriding earlier values.
 *
 * An example use of metadata is providing additional values to
 * http_connection_manager in the envoy.http_connection_manager.access_log
 * namespace.
 *
 * Another example use of metadata is to per service config info in cluster metadata, which may get
 * consumed by multiple filters.
 *
 * For load balancing, Metadata provides a means to subset cluster endpoints.
 * Endpoints have a Metadata object associated and routes contain a Metadata
 * object to match against. There are some well defined metadata used today for
 * this purpose:
 *
 * * ``{"envoy.lb": {"canary": <bool> }}`` This indicates the canary status of an
 *   endpoint and is also used during header processing
 *   (x-envoy-upstream-canary) and for stats purposes.
 * [#next-major-version: move to type/metadata/v2]
 */
export interface Metadata {
  $type: "envoy.api.v2.core.Metadata";
  /**
   * Key is the reverse DNS filter name, e.g. com.acme.widget. The envoy.*
   * namespace is reserved for Envoy's built-in filters.
   */
  filter_metadata?: Map<string, { [key: string]: any } | undefined> | undefined;
}

export interface Metadata_FilterMetadataEntry {
  $type: "envoy.api.v2.core.Metadata.FilterMetadataEntry";
  key: string;
  value?: { [key: string]: any } | undefined;
}

/** Runtime derived uint32 with a default when not specified. */
export interface RuntimeUInt32 {
  $type: "envoy.api.v2.core.RuntimeUInt32";
  /** Default value if runtime value is not available. */
  default_value?:
    | number
    | undefined;
  /** Runtime key to get value for comparison. This value is used if defined. */
  runtime_key?: string | undefined;
}

/** Runtime derived double with a default when not specified. */
export interface RuntimeDouble {
  $type: "envoy.api.v2.core.RuntimeDouble";
  /** Default value if runtime value is not available. */
  default_value?:
    | number
    | undefined;
  /** Runtime key to get value for comparison. This value is used if defined. */
  runtime_key?: string | undefined;
}

/** Runtime derived bool with a default when not specified. */
export interface RuntimeFeatureFlag {
  $type: "envoy.api.v2.core.RuntimeFeatureFlag";
  /** Default value if runtime value is not available. */
  default_value?:
    | boolean
    | undefined;
  /**
   * Runtime key to get value for comparison. This value is used if defined. The boolean value must
   * be represented via its
   * `canonical JSON encoding <https://developers.google.com/protocol-buffers/docs/proto3#json>`_.
   */
  runtime_key?: string | undefined;
}

/** Header name/value pair. */
export interface HeaderValue {
  $type: "envoy.api.v2.core.HeaderValue";
  /** Header name. */
  key?:
    | string
    | undefined;
  /**
   * Header value.
   *
   * The same :ref:`format specifier <config_access_log_format>` as used for
   * :ref:`HTTP access logging <config_access_log>` applies here, however
   * unknown header values are replaced with the empty string instead of `-`.
   */
  value?: string | undefined;
}

/** Header name/value pair plus option to control append behavior. */
export interface HeaderValueOption {
  $type: "envoy.api.v2.core.HeaderValueOption";
  /** Header name/value pair that this option applies to. */
  header?:
    | HeaderValue
    | undefined;
  /**
   * Should the value be appended? If true (default), the value is appended to
   * existing values.
   */
  append?: boolean | undefined;
}

/** Wrapper for a set of headers. */
export interface HeaderMap {
  $type: "envoy.api.v2.core.HeaderMap";
  headers?: HeaderValue[] | undefined;
}

/** Data source consisting of either a file or an inline value. */
export interface DataSource {
  $type: "envoy.api.v2.core.DataSource";
  specifier?:
    | //
    /** Local filesystem data source. */
    { $case: "filename"; filename: string }
    | //
    /** Bytes inlined in the configuration. */
    { $case: "inline_bytes"; inline_bytes: Uint8Array }
    | //
    /** String inlined in the configuration. */
    { $case: "inline_string"; inline_string: string }
    | undefined;
}

/** The message specifies the retry policy of remote data source when fetching fails. */
export interface RetryPolicy {
  $type: "envoy.api.v2.core.RetryPolicy";
  /**
   * Specifies parameters that control :ref:`retry backoff strategy <envoy_api_msg_core.BackoffStrategy>`.
   * This parameter is optional, in which case the default base interval is 1000 milliseconds. The
   * default maximum interval is 10 times the base interval.
   */
  retry_back_off?:
    | BackoffStrategy
    | undefined;
  /**
   * Specifies the allowed number of retries. This parameter is optional and
   * defaults to 1.
   */
  num_retries?: number | undefined;
}

/** The message specifies how to fetch data from remote and how to verify it. */
export interface RemoteDataSource {
  $type: "envoy.api.v2.core.RemoteDataSource";
  /** The HTTP URI to fetch the remote data. */
  http_uri?:
    | HttpUri
    | undefined;
  /** SHA256 string for verifying data. */
  sha256?:
    | string
    | undefined;
  /** Retry policy for fetching remote data. */
  retry_policy?: RetryPolicy | undefined;
}

/** Async data source which support async data fetch. */
export interface AsyncDataSource {
  $type: "envoy.api.v2.core.AsyncDataSource";
  specifier?:
    | //
    /** Local async data source. */
    { $case: "local"; local: DataSource }
    | //
    /** Remote async data source. */
    { $case: "remote"; remote: RemoteDataSource }
    | undefined;
}

/**
 * Configuration for transport socket in :ref:`listeners <config_listeners>` and
 * :ref:`clusters <envoy_api_msg_Cluster>`. If the configuration is
 * empty, a default transport socket implementation and configuration will be
 * chosen based on the platform and existence of tls_context.
 */
export interface TransportSocket {
  $type: "envoy.api.v2.core.TransportSocket";
  /**
   * The name of the transport socket to instantiate. The name must match a supported transport
   * socket implementation.
   */
  name?:
    | string
    | undefined;
  /**
   * Implementation specific configuration which depends on the implementation being instantiated.
   * See the supported transport socket implementations for further documentation.
   */
  config_type?:
    | //
    { $case: "config"; config: { [key: string]: any } | undefined }
    | //
    { $case: "typed_config"; typed_config: Any }
    | undefined;
}

/**
 * Runtime derived FractionalPercent with defaults for when the numerator or denominator is not
 * specified via a runtime key.
 *
 * .. note::
 *
 *   Parsing of the runtime key's data is implemented such that it may be represented as a
 *   :ref:`FractionalPercent <envoy_api_msg_type.FractionalPercent>` proto represented as JSON/YAML
 *   and may also be represented as an integer with the assumption that the value is an integral
 *   percentage out of 100. For instance, a runtime key lookup returning the value "42" would parse
 *   as a `FractionalPercent` whose numerator is 42 and denominator is HUNDRED.
 */
export interface RuntimeFractionalPercent {
  $type: "envoy.api.v2.core.RuntimeFractionalPercent";
  /** Default value if the runtime value's for the numerator/denominator keys are not available. */
  default_value?:
    | FractionalPercent
    | undefined;
  /** Runtime key for a YAML representation of a FractionalPercent. */
  runtime_key?: string | undefined;
}

/** Identifies a specific ControlPlane instance that Envoy is connected to. */
export interface ControlPlane {
  $type: "envoy.api.v2.core.ControlPlane";
  /**
   * An opaque control plane identifier that uniquely identifies an instance
   * of control plane. This can be used to identify which control plane instance,
   * the Envoy is connected to.
   */
  identifier?: string | undefined;
}

function createBaseLocality(): Locality {
  return { $type: "envoy.api.v2.core.Locality" };
}

export const Locality: MessageFns<Locality, "envoy.api.v2.core.Locality"> = {
  $type: "envoy.api.v2.core.Locality" as const,

  encode(message: Locality, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.region !== undefined && message.region !== "") {
      writer.uint32(10).string(message.region);
    }
    if (message.zone !== undefined && message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.sub_zone !== undefined && message.sub_zone !== "") {
      writer.uint32(26).string(message.sub_zone);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Locality {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocality();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.region = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sub_zone = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Locality {
    return {
      $type: Locality.$type,
      region: isSet(object.region) ? globalThis.String(object.region) : undefined,
      zone: isSet(object.zone) ? globalThis.String(object.zone) : undefined,
      sub_zone: isSet(object.sub_zone) ? globalThis.String(object.sub_zone) : undefined,
    };
  },

  toJSON(message: Locality): unknown {
    const obj: any = {};
    if (message.region !== undefined) {
      obj.region = message.region;
    }
    if (message.zone !== undefined) {
      obj.zone = message.zone;
    }
    if (message.sub_zone !== undefined) {
      obj.sub_zone = message.sub_zone;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Locality>, I>>(base?: I): Locality {
    return Locality.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Locality>, I>>(object: I): Locality {
    const message = createBaseLocality();
    message.region = object.region ?? undefined;
    message.zone = object.zone ?? undefined;
    message.sub_zone = object.sub_zone ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Locality.$type, Locality);

function createBaseBuildVersion(): BuildVersion {
  return { $type: "envoy.api.v2.core.BuildVersion" };
}

export const BuildVersion: MessageFns<BuildVersion, "envoy.api.v2.core.BuildVersion"> = {
  $type: "envoy.api.v2.core.BuildVersion" as const,

  encode(message: BuildVersion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== undefined) {
      SemanticVersion.encode(message.version, writer.uint32(10).fork()).join();
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildVersion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = SemanticVersion.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildVersion {
    return {
      $type: BuildVersion.$type,
      version: isSet(object.version) ? SemanticVersion.fromJSON(object.version) : undefined,
      metadata: isObject(object.metadata) ? object.metadata : undefined,
    };
  },

  toJSON(message: BuildVersion): unknown {
    const obj: any = {};
    if (message.version !== undefined) {
      obj.version = SemanticVersion.toJSON(message.version);
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildVersion>, I>>(base?: I): BuildVersion {
    return BuildVersion.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildVersion>, I>>(object: I): BuildVersion {
    const message = createBaseBuildVersion();
    message.version = (object.version !== undefined && object.version !== null)
      ? SemanticVersion.fromPartial(object.version)
      : undefined;
    message.metadata = object.metadata ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(BuildVersion.$type, BuildVersion);

function createBaseExtension(): Extension {
  return { $type: "envoy.api.v2.core.Extension" };
}

export const Extension: MessageFns<Extension, "envoy.api.v2.core.Extension"> = {
  $type: "envoy.api.v2.core.Extension" as const,

  encode(message: Extension, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.category !== undefined && message.category !== "") {
      writer.uint32(18).string(message.category);
    }
    if (message.type_descriptor !== undefined && message.type_descriptor !== "") {
      writer.uint32(26).string(message.type_descriptor);
    }
    if (message.version !== undefined) {
      BuildVersion.encode(message.version, writer.uint32(34).fork()).join();
    }
    if (message.disabled !== undefined && message.disabled !== false) {
      writer.uint32(40).bool(message.disabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Extension {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExtension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.category = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.type_descriptor = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.version = BuildVersion.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.disabled = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Extension {
    return {
      $type: Extension.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      category: isSet(object.category) ? globalThis.String(object.category) : undefined,
      type_descriptor: isSet(object.type_descriptor) ? globalThis.String(object.type_descriptor) : undefined,
      version: isSet(object.version) ? BuildVersion.fromJSON(object.version) : undefined,
      disabled: isSet(object.disabled) ? globalThis.Boolean(object.disabled) : undefined,
    };
  },

  toJSON(message: Extension): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.category !== undefined) {
      obj.category = message.category;
    }
    if (message.type_descriptor !== undefined) {
      obj.type_descriptor = message.type_descriptor;
    }
    if (message.version !== undefined) {
      obj.version = BuildVersion.toJSON(message.version);
    }
    if (message.disabled !== undefined) {
      obj.disabled = message.disabled;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Extension>, I>>(base?: I): Extension {
    return Extension.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Extension>, I>>(object: I): Extension {
    const message = createBaseExtension();
    message.name = object.name ?? undefined;
    message.category = object.category ?? undefined;
    message.type_descriptor = object.type_descriptor ?? undefined;
    message.version = (object.version !== undefined && object.version !== null)
      ? BuildVersion.fromPartial(object.version)
      : undefined;
    message.disabled = object.disabled ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Extension.$type, Extension);

function createBaseNode(): Node {
  return { $type: "envoy.api.v2.core.Node", user_agent_version_type: undefined };
}

export const Node: MessageFns<Node, "envoy.api.v2.core.Node"> = {
  $type: "envoy.api.v2.core.Node" as const,

  encode(message: Node, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined && message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.cluster !== undefined && message.cluster !== "") {
      writer.uint32(18).string(message.cluster);
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(26).fork()).join();
    }
    if (message.locality !== undefined) {
      Locality.encode(message.locality, writer.uint32(34).fork()).join();
    }
    if (message.build_version !== undefined && message.build_version !== "") {
      writer.uint32(42).string(message.build_version);
    }
    if (message.user_agent_name !== undefined && message.user_agent_name !== "") {
      writer.uint32(50).string(message.user_agent_name);
    }
    switch (message.user_agent_version_type?.$case) {
      case "user_agent_version":
        writer.uint32(58).string(message.user_agent_version_type.user_agent_version);
        break;
      case "user_agent_build_version":
        BuildVersion.encode(message.user_agent_version_type.user_agent_build_version, writer.uint32(66).fork()).join();
        break;
    }
    if (message.extensions !== undefined && message.extensions.length !== 0) {
      for (const v of message.extensions) {
        Extension.encode(v!, writer.uint32(74).fork()).join();
      }
    }
    if (message.client_features !== undefined && message.client_features.length !== 0) {
      for (const v of message.client_features) {
        writer.uint32(82).string(v!);
      }
    }
    if (message.listening_addresses !== undefined && message.listening_addresses.length !== 0) {
      for (const v of message.listening_addresses) {
        Address.encode(v!, writer.uint32(90).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Node {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cluster = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.locality = Locality.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.build_version = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.user_agent_name = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.user_agent_version_type = { $case: "user_agent_version", user_agent_version: reader.string() };
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.user_agent_version_type = {
            $case: "user_agent_build_version",
            user_agent_build_version: BuildVersion.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          if (message.extensions === undefined) {
            message.extensions = [];
          }
          const el = Extension.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.extensions!.push(el);
          }
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          if (message.client_features === undefined) {
            message.client_features = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.client_features!.push(el);
          }
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          if (message.listening_addresses === undefined) {
            message.listening_addresses = [];
          }
          const el = Address.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.listening_addresses!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Node {
    return {
      $type: Node.$type,
      id: isSet(object.id) ? globalThis.String(object.id) : undefined,
      cluster: isSet(object.cluster) ? globalThis.String(object.cluster) : undefined,
      metadata: isObject(object.metadata) ? object.metadata : undefined,
      locality: isSet(object.locality) ? Locality.fromJSON(object.locality) : undefined,
      build_version: isSet(object.build_version) ? globalThis.String(object.build_version) : undefined,
      user_agent_name: isSet(object.user_agent_name) ? globalThis.String(object.user_agent_name) : undefined,
      user_agent_version_type: isSet(object.user_agent_version)
        ? { $case: "user_agent_version", user_agent_version: globalThis.String(object.user_agent_version) }
        : isSet(object.user_agent_build_version)
        ? {
          $case: "user_agent_build_version",
          user_agent_build_version: BuildVersion.fromJSON(object.user_agent_build_version),
        }
        : undefined,
      extensions: globalThis.Array.isArray(object?.extensions)
        ? object.extensions.map((e: any) => Extension.fromJSON(e))
        : undefined,
      client_features: globalThis.Array.isArray(object?.client_features)
        ? object.client_features.map((e: any) => globalThis.String(e))
        : undefined,
      listening_addresses: globalThis.Array.isArray(object?.listening_addresses)
        ? object.listening_addresses.map((e: any) => Address.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: Node): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = message.id;
    }
    if (message.cluster !== undefined) {
      obj.cluster = message.cluster;
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.locality !== undefined) {
      obj.locality = Locality.toJSON(message.locality);
    }
    if (message.build_version !== undefined) {
      obj.build_version = message.build_version;
    }
    if (message.user_agent_name !== undefined) {
      obj.user_agent_name = message.user_agent_name;
    }
    if (message.user_agent_version_type?.$case === "user_agent_version") {
      obj.user_agent_version = message.user_agent_version_type.user_agent_version;
    }
    if (message.user_agent_version_type?.$case === "user_agent_build_version") {
      obj.user_agent_build_version = BuildVersion.toJSON(message.user_agent_version_type.user_agent_build_version);
    }
    if (message.extensions?.length) {
      obj.extensions = message.extensions.map((e) => Extension.toJSON(e));
    }
    if (message.client_features?.length) {
      obj.client_features = message.client_features;
    }
    if (message.listening_addresses?.length) {
      obj.listening_addresses = message.listening_addresses.map((e) => Address.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Node>, I>>(base?: I): Node {
    return Node.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Node>, I>>(object: I): Node {
    const message = createBaseNode();
    message.id = object.id ?? undefined;
    message.cluster = object.cluster ?? undefined;
    message.metadata = object.metadata ?? undefined;
    message.locality = (object.locality !== undefined && object.locality !== null)
      ? Locality.fromPartial(object.locality)
      : undefined;
    message.build_version = object.build_version ?? undefined;
    message.user_agent_name = object.user_agent_name ?? undefined;
    if (
      object.user_agent_version_type?.$case === "user_agent_version" &&
      object.user_agent_version_type?.user_agent_version !== undefined &&
      object.user_agent_version_type?.user_agent_version !== null
    ) {
      message.user_agent_version_type = {
        $case: "user_agent_version",
        user_agent_version: object.user_agent_version_type.user_agent_version,
      };
    }
    if (
      object.user_agent_version_type?.$case === "user_agent_build_version" &&
      object.user_agent_version_type?.user_agent_build_version !== undefined &&
      object.user_agent_version_type?.user_agent_build_version !== null
    ) {
      message.user_agent_version_type = {
        $case: "user_agent_build_version",
        user_agent_build_version: BuildVersion.fromPartial(object.user_agent_version_type.user_agent_build_version),
      };
    }
    message.extensions = object.extensions?.map((e) => Extension.fromPartial(e)) || undefined;
    message.client_features = object.client_features?.map((e) => e) || undefined;
    message.listening_addresses = object.listening_addresses?.map((e) => Address.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(Node.$type, Node);

function createBaseMetadata(): Metadata {
  return { $type: "envoy.api.v2.core.Metadata" };
}

export const Metadata: MessageFns<Metadata, "envoy.api.v2.core.Metadata"> = {
  $type: "envoy.api.v2.core.Metadata" as const,

  encode(message: Metadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    (message.filter_metadata || new Map()).forEach((value, key) => {
      if (value !== undefined) {
        Metadata_FilterMetadataEntry.encode({
          $type: "envoy.api.v2.core.Metadata.FilterMetadataEntry",
          key: key as any,
          value,
        }, writer.uint32(10).fork()).join();
      }
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Metadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = Metadata_FilterMetadataEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            if (message.filter_metadata === undefined) {
              message.filter_metadata = new Map();
            }
            message.filter_metadata!.set(entry1.key, entry1.value);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Metadata {
    return {
      $type: Metadata.$type,
      filter_metadata: isObject(object.filter_metadata)
        ? Object.entries(object.filter_metadata).reduce<Map<string, { [key: string]: any } | undefined>>(
          (acc, [key, value]) => {
            acc.set(key, value as { [key: string]: any } | undefined);
            return acc;
          },
          new Map(),
        )
        : undefined,
    };
  },

  toJSON(message: Metadata): unknown {
    const obj: any = {};
    if (message.filter_metadata?.size) {
      obj.filter_metadata = {};
      message.filter_metadata.forEach((v, k) => {
        obj.filter_metadata[k] = v;
      });
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Metadata>, I>>(base?: I): Metadata {
    return Metadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Metadata>, I>>(object: I): Metadata {
    const message = createBaseMetadata();
    message.filter_metadata = (object.filter_metadata === undefined || object.filter_metadata === null)
      ? undefined
      : (() => {
        const m = new Map();
        (object.filter_metadata as Map<string, { [key: string]: any } | undefined> ?? new Map()).forEach(
          (value, key) => {
            if (value !== undefined) {
              m.set(key, value);
            }
          },
        );
        return m;
      })();
    return message;
  },
};

messageTypeRegistry.set(Metadata.$type, Metadata);

function createBaseMetadata_FilterMetadataEntry(): Metadata_FilterMetadataEntry {
  return { $type: "envoy.api.v2.core.Metadata.FilterMetadataEntry", key: "" };
}

export const Metadata_FilterMetadataEntry: MessageFns<
  Metadata_FilterMetadataEntry,
  "envoy.api.v2.core.Metadata.FilterMetadataEntry"
> = {
  $type: "envoy.api.v2.core.Metadata.FilterMetadataEntry" as const,

  encode(message: Metadata_FilterMetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Struct.encode(Struct.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Metadata_FilterMetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetadata_FilterMetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Metadata_FilterMetadataEntry {
    return {
      $type: Metadata_FilterMetadataEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isObject(object.value) ? object.value : undefined,
    };
  },

  toJSON(message: Metadata_FilterMetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Metadata_FilterMetadataEntry>, I>>(base?: I): Metadata_FilterMetadataEntry {
    return Metadata_FilterMetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Metadata_FilterMetadataEntry>, I>>(object: I): Metadata_FilterMetadataEntry {
    const message = createBaseMetadata_FilterMetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Metadata_FilterMetadataEntry.$type, Metadata_FilterMetadataEntry);

function createBaseRuntimeUInt32(): RuntimeUInt32 {
  return { $type: "envoy.api.v2.core.RuntimeUInt32" };
}

export const RuntimeUInt32: MessageFns<RuntimeUInt32, "envoy.api.v2.core.RuntimeUInt32"> = {
  $type: "envoy.api.v2.core.RuntimeUInt32" as const,

  encode(message: RuntimeUInt32, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.default_value !== undefined && message.default_value !== 0) {
      writer.uint32(16).uint32(message.default_value);
    }
    if (message.runtime_key !== undefined && message.runtime_key !== "") {
      writer.uint32(26).string(message.runtime_key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuntimeUInt32 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuntimeUInt32();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.default_value = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.runtime_key = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuntimeUInt32 {
    return {
      $type: RuntimeUInt32.$type,
      default_value: isSet(object.default_value) ? globalThis.Number(object.default_value) : undefined,
      runtime_key: isSet(object.runtime_key) ? globalThis.String(object.runtime_key) : undefined,
    };
  },

  toJSON(message: RuntimeUInt32): unknown {
    const obj: any = {};
    if (message.default_value !== undefined) {
      obj.default_value = Math.round(message.default_value);
    }
    if (message.runtime_key !== undefined) {
      obj.runtime_key = message.runtime_key;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RuntimeUInt32>, I>>(base?: I): RuntimeUInt32 {
    return RuntimeUInt32.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RuntimeUInt32>, I>>(object: I): RuntimeUInt32 {
    const message = createBaseRuntimeUInt32();
    message.default_value = object.default_value ?? undefined;
    message.runtime_key = object.runtime_key ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RuntimeUInt32.$type, RuntimeUInt32);

function createBaseRuntimeDouble(): RuntimeDouble {
  return { $type: "envoy.api.v2.core.RuntimeDouble" };
}

export const RuntimeDouble: MessageFns<RuntimeDouble, "envoy.api.v2.core.RuntimeDouble"> = {
  $type: "envoy.api.v2.core.RuntimeDouble" as const,

  encode(message: RuntimeDouble, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.default_value !== undefined && message.default_value !== 0) {
      writer.uint32(9).double(message.default_value);
    }
    if (message.runtime_key !== undefined && message.runtime_key !== "") {
      writer.uint32(18).string(message.runtime_key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuntimeDouble {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuntimeDouble();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.default_value = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.runtime_key = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuntimeDouble {
    return {
      $type: RuntimeDouble.$type,
      default_value: isSet(object.default_value) ? globalThis.Number(object.default_value) : undefined,
      runtime_key: isSet(object.runtime_key) ? globalThis.String(object.runtime_key) : undefined,
    };
  },

  toJSON(message: RuntimeDouble): unknown {
    const obj: any = {};
    if (message.default_value !== undefined) {
      obj.default_value = message.default_value;
    }
    if (message.runtime_key !== undefined) {
      obj.runtime_key = message.runtime_key;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RuntimeDouble>, I>>(base?: I): RuntimeDouble {
    return RuntimeDouble.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RuntimeDouble>, I>>(object: I): RuntimeDouble {
    const message = createBaseRuntimeDouble();
    message.default_value = object.default_value ?? undefined;
    message.runtime_key = object.runtime_key ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RuntimeDouble.$type, RuntimeDouble);

function createBaseRuntimeFeatureFlag(): RuntimeFeatureFlag {
  return { $type: "envoy.api.v2.core.RuntimeFeatureFlag" };
}

export const RuntimeFeatureFlag: MessageFns<RuntimeFeatureFlag, "envoy.api.v2.core.RuntimeFeatureFlag"> = {
  $type: "envoy.api.v2.core.RuntimeFeatureFlag" as const,

  encode(message: RuntimeFeatureFlag, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.default_value !== undefined) {
      BoolValue.encode({ $type: "google.protobuf.BoolValue", value: message.default_value! }, writer.uint32(10).fork())
        .join();
    }
    if (message.runtime_key !== undefined && message.runtime_key !== "") {
      writer.uint32(18).string(message.runtime_key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuntimeFeatureFlag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuntimeFeatureFlag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.default_value = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.runtime_key = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuntimeFeatureFlag {
    return {
      $type: RuntimeFeatureFlag.$type,
      default_value: isSet(object.default_value) ? Boolean(object.default_value) : undefined,
      runtime_key: isSet(object.runtime_key) ? globalThis.String(object.runtime_key) : undefined,
    };
  },

  toJSON(message: RuntimeFeatureFlag): unknown {
    const obj: any = {};
    if (message.default_value !== undefined) {
      obj.default_value = message.default_value;
    }
    if (message.runtime_key !== undefined) {
      obj.runtime_key = message.runtime_key;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RuntimeFeatureFlag>, I>>(base?: I): RuntimeFeatureFlag {
    return RuntimeFeatureFlag.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RuntimeFeatureFlag>, I>>(object: I): RuntimeFeatureFlag {
    const message = createBaseRuntimeFeatureFlag();
    message.default_value = object.default_value ?? undefined;
    message.runtime_key = object.runtime_key ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RuntimeFeatureFlag.$type, RuntimeFeatureFlag);

function createBaseHeaderValue(): HeaderValue {
  return { $type: "envoy.api.v2.core.HeaderValue" };
}

export const HeaderValue: MessageFns<HeaderValue, "envoy.api.v2.core.HeaderValue"> = {
  $type: "envoy.api.v2.core.HeaderValue" as const,

  encode(message: HeaderValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined && message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined && message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeaderValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeaderValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeaderValue {
    return {
      $type: HeaderValue.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : undefined,
      value: isSet(object.value) ? globalThis.String(object.value) : undefined,
    };
  },

  toJSON(message: HeaderValue): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HeaderValue>, I>>(base?: I): HeaderValue {
    return HeaderValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HeaderValue>, I>>(object: I): HeaderValue {
    const message = createBaseHeaderValue();
    message.key = object.key ?? undefined;
    message.value = object.value ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(HeaderValue.$type, HeaderValue);

function createBaseHeaderValueOption(): HeaderValueOption {
  return { $type: "envoy.api.v2.core.HeaderValueOption" };
}

export const HeaderValueOption: MessageFns<HeaderValueOption, "envoy.api.v2.core.HeaderValueOption"> = {
  $type: "envoy.api.v2.core.HeaderValueOption" as const,

  encode(message: HeaderValueOption, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      HeaderValue.encode(message.header, writer.uint32(10).fork()).join();
    }
    if (message.append !== undefined) {
      BoolValue.encode({ $type: "google.protobuf.BoolValue", value: message.append! }, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeaderValueOption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeaderValueOption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header = HeaderValue.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.append = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeaderValueOption {
    return {
      $type: HeaderValueOption.$type,
      header: isSet(object.header) ? HeaderValue.fromJSON(object.header) : undefined,
      append: isSet(object.append) ? Boolean(object.append) : undefined,
    };
  },

  toJSON(message: HeaderValueOption): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = HeaderValue.toJSON(message.header);
    }
    if (message.append !== undefined) {
      obj.append = message.append;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HeaderValueOption>, I>>(base?: I): HeaderValueOption {
    return HeaderValueOption.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HeaderValueOption>, I>>(object: I): HeaderValueOption {
    const message = createBaseHeaderValueOption();
    message.header = (object.header !== undefined && object.header !== null)
      ? HeaderValue.fromPartial(object.header)
      : undefined;
    message.append = object.append ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(HeaderValueOption.$type, HeaderValueOption);

function createBaseHeaderMap(): HeaderMap {
  return { $type: "envoy.api.v2.core.HeaderMap" };
}

export const HeaderMap: MessageFns<HeaderMap, "envoy.api.v2.core.HeaderMap"> = {
  $type: "envoy.api.v2.core.HeaderMap" as const,

  encode(message: HeaderMap, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.headers !== undefined && message.headers.length !== 0) {
      for (const v of message.headers) {
        HeaderValue.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeaderMap {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeaderMap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.headers === undefined) {
            message.headers = [];
          }
          const el = HeaderValue.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.headers!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeaderMap {
    return {
      $type: HeaderMap.$type,
      headers: globalThis.Array.isArray(object?.headers)
        ? object.headers.map((e: any) => HeaderValue.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: HeaderMap): unknown {
    const obj: any = {};
    if (message.headers?.length) {
      obj.headers = message.headers.map((e) => HeaderValue.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HeaderMap>, I>>(base?: I): HeaderMap {
    return HeaderMap.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HeaderMap>, I>>(object: I): HeaderMap {
    const message = createBaseHeaderMap();
    message.headers = object.headers?.map((e) => HeaderValue.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(HeaderMap.$type, HeaderMap);

function createBaseDataSource(): DataSource {
  return { $type: "envoy.api.v2.core.DataSource", specifier: undefined };
}

export const DataSource: MessageFns<DataSource, "envoy.api.v2.core.DataSource"> = {
  $type: "envoy.api.v2.core.DataSource" as const,

  encode(message: DataSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.specifier?.$case) {
      case "filename":
        writer.uint32(10).string(message.specifier.filename);
        break;
      case "inline_bytes":
        writer.uint32(18).bytes(message.specifier.inline_bytes);
        break;
      case "inline_string":
        writer.uint32(26).string(message.specifier.inline_string);
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.specifier = { $case: "filename", filename: reader.string() };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.specifier = { $case: "inline_bytes", inline_bytes: reader.bytes() };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.specifier = { $case: "inline_string", inline_string: reader.string() };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataSource {
    return {
      $type: DataSource.$type,
      specifier: isSet(object.filename)
        ? { $case: "filename", filename: globalThis.String(object.filename) }
        : isSet(object.inline_bytes)
        ? { $case: "inline_bytes", inline_bytes: bytesFromBase64(object.inline_bytes) }
        : isSet(object.inline_string)
        ? { $case: "inline_string", inline_string: globalThis.String(object.inline_string) }
        : undefined,
    };
  },

  toJSON(message: DataSource): unknown {
    const obj: any = {};
    if (message.specifier?.$case === "filename") {
      obj.filename = message.specifier.filename;
    }
    if (message.specifier?.$case === "inline_bytes") {
      obj.inline_bytes = base64FromBytes(message.specifier.inline_bytes);
    }
    if (message.specifier?.$case === "inline_string") {
      obj.inline_string = message.specifier.inline_string;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DataSource>, I>>(base?: I): DataSource {
    return DataSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DataSource>, I>>(object: I): DataSource {
    const message = createBaseDataSource();
    if (
      object.specifier?.$case === "filename" &&
      object.specifier?.filename !== undefined &&
      object.specifier?.filename !== null
    ) {
      message.specifier = { $case: "filename", filename: object.specifier.filename };
    }
    if (
      object.specifier?.$case === "inline_bytes" &&
      object.specifier?.inline_bytes !== undefined &&
      object.specifier?.inline_bytes !== null
    ) {
      message.specifier = { $case: "inline_bytes", inline_bytes: object.specifier.inline_bytes };
    }
    if (
      object.specifier?.$case === "inline_string" &&
      object.specifier?.inline_string !== undefined &&
      object.specifier?.inline_string !== null
    ) {
      message.specifier = { $case: "inline_string", inline_string: object.specifier.inline_string };
    }
    return message;
  },
};

messageTypeRegistry.set(DataSource.$type, DataSource);

function createBaseRetryPolicy(): RetryPolicy {
  return { $type: "envoy.api.v2.core.RetryPolicy" };
}

export const RetryPolicy: MessageFns<RetryPolicy, "envoy.api.v2.core.RetryPolicy"> = {
  $type: "envoy.api.v2.core.RetryPolicy" as const,

  encode(message: RetryPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.retry_back_off !== undefined) {
      BackoffStrategy.encode(message.retry_back_off, writer.uint32(10).fork()).join();
    }
    if (message.num_retries !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.num_retries! },
        writer.uint32(18).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.retry_back_off = BackoffStrategy.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.num_retries = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetryPolicy {
    return {
      $type: RetryPolicy.$type,
      retry_back_off: isSet(object.retry_back_off) ? BackoffStrategy.fromJSON(object.retry_back_off) : undefined,
      num_retries: isSet(object.num_retries) ? Number(object.num_retries) : undefined,
    };
  },

  toJSON(message: RetryPolicy): unknown {
    const obj: any = {};
    if (message.retry_back_off !== undefined) {
      obj.retry_back_off = BackoffStrategy.toJSON(message.retry_back_off);
    }
    if (message.num_retries !== undefined) {
      obj.num_retries = message.num_retries;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetryPolicy>, I>>(base?: I): RetryPolicy {
    return RetryPolicy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetryPolicy>, I>>(object: I): RetryPolicy {
    const message = createBaseRetryPolicy();
    message.retry_back_off = (object.retry_back_off !== undefined && object.retry_back_off !== null)
      ? BackoffStrategy.fromPartial(object.retry_back_off)
      : undefined;
    message.num_retries = object.num_retries ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RetryPolicy.$type, RetryPolicy);

function createBaseRemoteDataSource(): RemoteDataSource {
  return { $type: "envoy.api.v2.core.RemoteDataSource" };
}

export const RemoteDataSource: MessageFns<RemoteDataSource, "envoy.api.v2.core.RemoteDataSource"> = {
  $type: "envoy.api.v2.core.RemoteDataSource" as const,

  encode(message: RemoteDataSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.http_uri !== undefined) {
      HttpUri.encode(message.http_uri, writer.uint32(10).fork()).join();
    }
    if (message.sha256 !== undefined && message.sha256 !== "") {
      writer.uint32(18).string(message.sha256);
    }
    if (message.retry_policy !== undefined) {
      RetryPolicy.encode(message.retry_policy, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoteDataSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoteDataSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.http_uri = HttpUri.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sha256 = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.retry_policy = RetryPolicy.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoteDataSource {
    return {
      $type: RemoteDataSource.$type,
      http_uri: isSet(object.http_uri) ? HttpUri.fromJSON(object.http_uri) : undefined,
      sha256: isSet(object.sha256) ? globalThis.String(object.sha256) : undefined,
      retry_policy: isSet(object.retry_policy) ? RetryPolicy.fromJSON(object.retry_policy) : undefined,
    };
  },

  toJSON(message: RemoteDataSource): unknown {
    const obj: any = {};
    if (message.http_uri !== undefined) {
      obj.http_uri = HttpUri.toJSON(message.http_uri);
    }
    if (message.sha256 !== undefined) {
      obj.sha256 = message.sha256;
    }
    if (message.retry_policy !== undefined) {
      obj.retry_policy = RetryPolicy.toJSON(message.retry_policy);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoteDataSource>, I>>(base?: I): RemoteDataSource {
    return RemoteDataSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoteDataSource>, I>>(object: I): RemoteDataSource {
    const message = createBaseRemoteDataSource();
    message.http_uri = (object.http_uri !== undefined && object.http_uri !== null)
      ? HttpUri.fromPartial(object.http_uri)
      : undefined;
    message.sha256 = object.sha256 ?? undefined;
    message.retry_policy = (object.retry_policy !== undefined && object.retry_policy !== null)
      ? RetryPolicy.fromPartial(object.retry_policy)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(RemoteDataSource.$type, RemoteDataSource);

function createBaseAsyncDataSource(): AsyncDataSource {
  return { $type: "envoy.api.v2.core.AsyncDataSource", specifier: undefined };
}

export const AsyncDataSource: MessageFns<AsyncDataSource, "envoy.api.v2.core.AsyncDataSource"> = {
  $type: "envoy.api.v2.core.AsyncDataSource" as const,

  encode(message: AsyncDataSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.specifier?.$case) {
      case "local":
        DataSource.encode(message.specifier.local, writer.uint32(10).fork()).join();
        break;
      case "remote":
        RemoteDataSource.encode(message.specifier.remote, writer.uint32(18).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AsyncDataSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAsyncDataSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.specifier = { $case: "local", local: DataSource.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.specifier = { $case: "remote", remote: RemoteDataSource.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AsyncDataSource {
    return {
      $type: AsyncDataSource.$type,
      specifier: isSet(object.local)
        ? { $case: "local", local: DataSource.fromJSON(object.local) }
        : isSet(object.remote)
        ? { $case: "remote", remote: RemoteDataSource.fromJSON(object.remote) }
        : undefined,
    };
  },

  toJSON(message: AsyncDataSource): unknown {
    const obj: any = {};
    if (message.specifier?.$case === "local") {
      obj.local = DataSource.toJSON(message.specifier.local);
    }
    if (message.specifier?.$case === "remote") {
      obj.remote = RemoteDataSource.toJSON(message.specifier.remote);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AsyncDataSource>, I>>(base?: I): AsyncDataSource {
    return AsyncDataSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AsyncDataSource>, I>>(object: I): AsyncDataSource {
    const message = createBaseAsyncDataSource();
    if (
      object.specifier?.$case === "local" && object.specifier?.local !== undefined && object.specifier?.local !== null
    ) {
      message.specifier = { $case: "local", local: DataSource.fromPartial(object.specifier.local) };
    }
    if (
      object.specifier?.$case === "remote" &&
      object.specifier?.remote !== undefined &&
      object.specifier?.remote !== null
    ) {
      message.specifier = { $case: "remote", remote: RemoteDataSource.fromPartial(object.specifier.remote) };
    }
    return message;
  },
};

messageTypeRegistry.set(AsyncDataSource.$type, AsyncDataSource);

function createBaseTransportSocket(): TransportSocket {
  return { $type: "envoy.api.v2.core.TransportSocket", config_type: undefined };
}

export const TransportSocket: MessageFns<TransportSocket, "envoy.api.v2.core.TransportSocket"> = {
  $type: "envoy.api.v2.core.TransportSocket" as const,

  encode(message: TransportSocket, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    switch (message.config_type?.$case) {
      case "config":
        Struct.encode(Struct.wrap(message.config_type.config), writer.uint32(18).fork()).join();
        break;
      case "typed_config":
        Any.encode(message.config_type.typed_config, writer.uint32(26).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransportSocket {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransportSocket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.config_type = { $case: "config", config: Struct.unwrap(Struct.decode(reader, reader.uint32())) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.config_type = { $case: "typed_config", typed_config: Any.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransportSocket {
    return {
      $type: TransportSocket.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      config_type: isSet(object.config)
        ? { $case: "config", config: object.config }
        : isSet(object.typed_config)
        ? { $case: "typed_config", typed_config: Any.fromJSON(object.typed_config) }
        : undefined,
    };
  },

  toJSON(message: TransportSocket): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.config_type?.$case === "config") {
      obj.config = message.config_type.config;
    }
    if (message.config_type?.$case === "typed_config") {
      obj.typed_config = Any.toJSON(message.config_type.typed_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransportSocket>, I>>(base?: I): TransportSocket {
    return TransportSocket.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransportSocket>, I>>(object: I): TransportSocket {
    const message = createBaseTransportSocket();
    message.name = object.name ?? undefined;
    if (
      object.config_type?.$case === "config" &&
      object.config_type?.config !== undefined &&
      object.config_type?.config !== null
    ) {
      message.config_type = { $case: "config", config: object.config_type.config };
    }
    if (
      object.config_type?.$case === "typed_config" &&
      object.config_type?.typed_config !== undefined &&
      object.config_type?.typed_config !== null
    ) {
      message.config_type = { $case: "typed_config", typed_config: Any.fromPartial(object.config_type.typed_config) };
    }
    return message;
  },
};

messageTypeRegistry.set(TransportSocket.$type, TransportSocket);

function createBaseRuntimeFractionalPercent(): RuntimeFractionalPercent {
  return { $type: "envoy.api.v2.core.RuntimeFractionalPercent" };
}

export const RuntimeFractionalPercent: MessageFns<
  RuntimeFractionalPercent,
  "envoy.api.v2.core.RuntimeFractionalPercent"
> = {
  $type: "envoy.api.v2.core.RuntimeFractionalPercent" as const,

  encode(message: RuntimeFractionalPercent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.default_value !== undefined) {
      FractionalPercent.encode(message.default_value, writer.uint32(10).fork()).join();
    }
    if (message.runtime_key !== undefined && message.runtime_key !== "") {
      writer.uint32(18).string(message.runtime_key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuntimeFractionalPercent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuntimeFractionalPercent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.default_value = FractionalPercent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.runtime_key = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuntimeFractionalPercent {
    return {
      $type: RuntimeFractionalPercent.$type,
      default_value: isSet(object.default_value) ? FractionalPercent.fromJSON(object.default_value) : undefined,
      runtime_key: isSet(object.runtime_key) ? globalThis.String(object.runtime_key) : undefined,
    };
  },

  toJSON(message: RuntimeFractionalPercent): unknown {
    const obj: any = {};
    if (message.default_value !== undefined) {
      obj.default_value = FractionalPercent.toJSON(message.default_value);
    }
    if (message.runtime_key !== undefined) {
      obj.runtime_key = message.runtime_key;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RuntimeFractionalPercent>, I>>(base?: I): RuntimeFractionalPercent {
    return RuntimeFractionalPercent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RuntimeFractionalPercent>, I>>(object: I): RuntimeFractionalPercent {
    const message = createBaseRuntimeFractionalPercent();
    message.default_value = (object.default_value !== undefined && object.default_value !== null)
      ? FractionalPercent.fromPartial(object.default_value)
      : undefined;
    message.runtime_key = object.runtime_key ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RuntimeFractionalPercent.$type, RuntimeFractionalPercent);

function createBaseControlPlane(): ControlPlane {
  return { $type: "envoy.api.v2.core.ControlPlane" };
}

export const ControlPlane: MessageFns<ControlPlane, "envoy.api.v2.core.ControlPlane"> = {
  $type: "envoy.api.v2.core.ControlPlane" as const,

  encode(message: ControlPlane, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.identifier !== undefined && message.identifier !== "") {
      writer.uint32(10).string(message.identifier);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ControlPlane {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseControlPlane();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.identifier = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ControlPlane {
    return {
      $type: ControlPlane.$type,
      identifier: isSet(object.identifier) ? globalThis.String(object.identifier) : undefined,
    };
  },

  toJSON(message: ControlPlane): unknown {
    const obj: any = {};
    if (message.identifier !== undefined) {
      obj.identifier = message.identifier;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ControlPlane>, I>>(base?: I): ControlPlane {
    return ControlPlane.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ControlPlane>, I>>(object: I): ControlPlane {
    const message = createBaseControlPlane();
    message.identifier = object.identifier ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ControlPlane.$type, ControlPlane);

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
