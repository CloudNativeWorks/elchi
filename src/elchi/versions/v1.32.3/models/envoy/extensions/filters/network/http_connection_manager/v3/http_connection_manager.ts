// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Any } from "../../../../../../google/protobuf/any";
import { Duration } from "../../../../../../google/protobuf/duration";
import { BoolValue, UInt32Value } from "../../../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../../../typeRegistry";
import { AccessLog, AccessLogFilter } from "../../../../../config/accesslog/v3/accesslog";
import { CidrRange } from "../../../../../config/core/v3/address";
import { DataSource, HeaderValueOption } from "../../../../../config/core/v3/base";
import { ConfigSource, ExtensionConfigSource } from "../../../../../config/core/v3/config_source";
import { TypedExtensionConfig } from "../../../../../config/core/v3/extension";
import {
  Http1ProtocolOptions,
  Http2ProtocolOptions,
  Http3ProtocolOptions,
  HttpProtocolOptions,
  SchemeHeaderTransformation,
} from "../../../../../config/core/v3/protocol";
import { SubstitutionFormatString } from "../../../../../config/core/v3/substitution_format_string";
import { RouteConfiguration } from "../../../../../config/route/v3/route";
import { ScopedRouteConfiguration } from "../../../../../config/route/v3/scoped_route";
import { Tracing_Http } from "../../../../../config/trace/v3/http_tracer";
import { PathTransformation } from "../../../../../type/http/v3/path_transformation";
import { CustomTag } from "../../../../../type/tracing/v3/custom_tag";
import { Percent } from "../../../../../type/v3/percent";

export const protobufPackage = "envoy.extensions.filters.network.http_connection_manager.v3";

/** [#next-free-field: 59] */
export interface HttpConnectionManager {
  $type: "envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager";
  /** Supplies the type of codec that the connection manager should use. */
  codec_type?:
    | HttpConnectionManager_CodecType
    | undefined;
  /**
   * The human readable prefix to use when emitting statistics for the
   * connection manager. See the :ref:`statistics documentation <config_http_conn_man_stats>` for
   * more information.
   */
  stat_prefix?: string | undefined;
  route_specifier?:
    | //
    /** The connection manager’s route table will be dynamically loaded via the RDS API. */
    { $case: "rds"; rds: Rds }
    | //
    /** The route table for the connection manager is static and is specified in this property. */
    { $case: "route_config"; route_config: RouteConfiguration }
    | //
    /**
     * A route table will be dynamically assigned to each request based on request attributes
     * (e.g., the value of a header). The "routing scopes" (i.e., route tables) and "scope keys" are
     * specified in this message.
     */
    { $case: "scoped_routes"; scoped_routes: ScopedRoutes }
    | undefined;
  /**
   * A list of individual HTTP filters that make up the filter chain for
   * requests made to the connection manager. :ref:`Order matters <arch_overview_http_filters_ordering>`
   * as the filters are processed sequentially as request events happen.
   */
  http_filters?:
    | HttpFilter[]
    | undefined;
  /**
   * Whether the connection manager manipulates the :ref:`config_http_conn_man_headers_user-agent`
   * and :ref:`config_http_conn_man_headers_downstream-service-cluster` headers. See the linked
   * documentation for more information. Defaults to false.
   */
  add_user_agent?:
    | boolean
    | undefined;
  /**
   * Presence of the object defines whether the connection manager
   * emits :ref:`tracing <arch_overview_tracing>` data to the :ref:`configured tracing provider
   * <envoy_v3_api_msg_config.trace.v3.Tracing>`.
   */
  tracing?:
    | HttpConnectionManager_Tracing
    | undefined;
  /**
   * Additional settings for HTTP requests handled by the connection manager. These will be
   * applicable to both HTTP1 and HTTP2 requests.
   */
  common_http_protocol_options?:
    | HttpProtocolOptions
    | undefined;
  /**
   * If set to true, Envoy will not start a drain timer for downstream HTTP1 connections after
   * :ref:`common_http_protocol_options.max_connection_duration
   * <envoy_v3_api_field_config.core.v3.HttpProtocolOptions.max_connection_duration>` passes.
   * Instead, Envoy will wait for the next downstream request, add connection:close to the response
   * headers, then close the connection after the stream ends.
   *
   * This behavior is compliant with `RFC 9112 section 9.6 <https://www.rfc-editor.org/rfc/rfc9112#name-tear-down>`_
   *
   * If set to false, ``max_connection_duration`` will cause Envoy to enter the normal drain
   * sequence for HTTP1 with Envoy eventually closing the connection (once there are no active
   * streams).
   *
   * Has no effect if ``max_connection_duration`` is unset. Defaults to false.
   */
  http1_safe_max_connection_duration?:
    | boolean
    | undefined;
  /**
   * Additional HTTP/1 settings that are passed to the HTTP/1 codec.
   * [#comment:TODO: The following fields are ignored when the
   * :ref:`header validation configuration <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config>`
   * is present:
   * 1. :ref:`allow_chunked_length <envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.allow_chunked_length>`]
   */
  http_protocol_options?:
    | Http1ProtocolOptions
    | undefined;
  /** Additional HTTP/2 settings that are passed directly to the HTTP/2 codec. */
  http2_protocol_options?:
    | Http2ProtocolOptions
    | undefined;
  /** Additional HTTP/3 settings that are passed directly to the HTTP/3 codec. */
  http3_protocol_options?:
    | Http3ProtocolOptions
    | undefined;
  /**
   * An optional override that the connection manager will write to the server
   * header in responses. If not set, the default is ``envoy``.
   */
  server_name?:
    | string
    | undefined;
  /**
   * Defines the action to be applied to the Server header on the response path.
   * By default, Envoy will overwrite the header with the value specified in
   * server_name.
   */
  server_header_transformation?:
    | HttpConnectionManager_ServerHeaderTransformation
    | undefined;
  /**
   * Allows for explicit transformation of the :scheme header on the request path.
   * If not set, Envoy's default :ref:`scheme  <config_http_conn_man_headers_scheme>`
   * handling applies.
   */
  scheme_header_transformation?:
    | SchemeHeaderTransformation
    | undefined;
  /**
   * The maximum request headers size for incoming connections.
   * If unconfigured, the default max request headers allowed is 60 KiB.
   * The default value can be overridden by setting runtime key ``envoy.reloadable_features.max_request_headers_size_kb``.
   * Requests that exceed this limit will receive a 431 response.
   *
   * Note: currently some protocol codecs impose limits on the maximum size of a single header:
   *   HTTP/2 (when using nghttp2) limits a single header to around 100kb.
   *   HTTP/3 limits a single header to around 1024kb.
   */
  max_request_headers_kb?:
    | number
    | undefined;
  /**
   * The stream idle timeout for connections managed by the connection manager.
   * If not specified, this defaults to 5 minutes. The default value was selected
   * so as not to interfere with any smaller configured timeouts that may have
   * existed in configurations prior to the introduction of this feature, while
   * introducing robustness to TCP connections that terminate without a FIN.
   *
   * This idle timeout applies to new streams and is overridable by the
   * :ref:`route-level idle_timeout
   * <envoy_v3_api_field_config.route.v3.RouteAction.idle_timeout>`. Even on a stream in
   * which the override applies, prior to receipt of the initial request
   * headers, the :ref:`stream_idle_timeout
   * <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout>`
   * applies. Each time an encode/decode event for headers or data is processed
   * for the stream, the timer will be reset. If the timeout fires, the stream
   * is terminated with a 408 Request Timeout error code if no upstream response
   * header has been received, otherwise a stream reset occurs.
   *
   * This timeout also specifies the amount of time that Envoy will wait for the peer to open enough
   * window to write any remaining stream data once the entirety of stream data (local end stream is
   * true) has been buffered pending available window. In other words, this timeout defends against
   * a peer that does not release enough window to completely write the stream, even though all
   * data has been proxied within available flow control windows. If the timeout is hit in this
   * case, the :ref:`tx_flush_timeout <config_http_conn_man_stats_per_codec>` counter will be
   * incremented. Note that :ref:`max_stream_duration
   * <envoy_v3_api_field_config.core.v3.HttpProtocolOptions.max_stream_duration>` does not apply to
   * this corner case.
   *
   * If the :ref:`overload action <config_overload_manager_overload_actions>` "envoy.overload_actions.reduce_timeouts"
   * is configured, this timeout is scaled according to the value for
   * :ref:`HTTP_DOWNSTREAM_STREAM_IDLE <envoy_v3_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_STREAM_IDLE>`.
   *
   * Note that it is possible to idle timeout even if the wire traffic for a stream is non-idle, due
   * to the granularity of events presented to the connection manager. For example, while receiving
   * very large request headers, it may be the case that there is traffic regularly arriving on the
   * wire while the connection manage is only able to observe the end-of-headers event, hence the
   * stream may still idle timeout.
   *
   * A value of 0 will completely disable the connection manager stream idle
   * timeout, although per-route idle timeout overrides will continue to apply.
   */
  stream_idle_timeout?:
    | Duration
    | undefined;
  /**
   * The amount of time that Envoy will wait for the entire request to be received.
   * The timer is activated when the request is initiated, and is disarmed when the last byte of the
   * request is sent upstream (i.e. all decoding filters have processed the request), OR when the
   * response is initiated. If not specified or set to 0, this timeout is disabled.
   */
  request_timeout?:
    | Duration
    | undefined;
  /**
   * The amount of time that Envoy will wait for the request headers to be received. The timer is
   * activated when the first byte of the headers is received, and is disarmed when the last byte of
   * the headers has been received. If not specified or set to 0, this timeout is disabled.
   */
  request_headers_timeout?:
    | Duration
    | undefined;
  /**
   * The time that Envoy will wait between sending an HTTP/2 “shutdown
   * notification” (GOAWAY frame with max stream ID) and a final GOAWAY frame.
   * This is used so that Envoy provides a grace period for new streams that
   * race with the final GOAWAY frame. During this grace period, Envoy will
   * continue to accept new streams. After the grace period, a final GOAWAY
   * frame is sent and Envoy will start refusing new streams. Draining occurs
   * either when a connection hits the idle timeout, when :ref:`max_connection_duration
   * <envoy_v3_api_field_config.core.v3.HttpProtocolOptions.max_connection_duration>`
   * is reached, or during general server draining. The default grace period is
   * 5000 milliseconds (5 seconds) if this option is not specified.
   */
  drain_timeout?:
    | Duration
    | undefined;
  /**
   * The delayed close timeout is for downstream connections managed by the HTTP connection manager.
   * It is defined as a grace period after connection close processing has been locally initiated
   * during which Envoy will wait for the peer to close (i.e., a TCP FIN/RST is received by Envoy
   * from the downstream connection) prior to Envoy closing the socket associated with that
   * connection.
   * NOTE: This timeout is enforced even when the socket associated with the downstream connection
   * is pending a flush of the write buffer. However, any progress made writing data to the socket
   * will restart the timer associated with this timeout. This means that the total grace period for
   * a socket in this state will be
   * <total_time_waiting_for_write_buffer_flushes>+<delayed_close_timeout>.
   *
   * Delaying Envoy's connection close and giving the peer the opportunity to initiate the close
   * sequence mitigates a race condition that exists when downstream clients do not drain/process
   * data in a connection's receive buffer after a remote close has been detected via a socket
   * write(). This race leads to such clients failing to process the response code sent by Envoy,
   * which could result in erroneous downstream processing.
   *
   * If the timeout triggers, Envoy will close the connection's socket.
   *
   * The default timeout is 1000 ms if this option is not specified.
   *
   * .. NOTE::
   *    To be useful in avoiding the race condition described above, this timeout must be set
   *    to *at least* <max round trip time expected between clients and Envoy>+<100ms to account for
   *    a reasonable "worst" case processing time for a full iteration of Envoy's event loop>.
   *
   * .. WARNING::
   *    A value of 0 will completely disable delayed close processing. When disabled, the downstream
   *    connection's socket will be closed immediately after the write flush is completed or will
   *    never close if the write flush does not complete.
   */
  delayed_close_timeout?:
    | Duration
    | undefined;
  /**
   * Configuration for :ref:`HTTP access logs <arch_overview_access_logs>`
   * emitted by the connection manager.
   */
  access_log?:
    | AccessLog[]
    | undefined;
  /**
   * The interval to flush the above access logs.
   *
   * .. attention::
   *
   *   This field is deprecated in favor of
   *   :ref:`access_log_flush_interval
   *   <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.HcmAccessLogOptions.access_log_flush_interval>`.
   *   Note that if both this field and :ref:`access_log_flush_interval
   *   <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.HcmAccessLogOptions.access_log_flush_interval>`
   *   are specified, the former (deprecated field) is ignored.
   *
   * @deprecated
   */
  access_log_flush_interval?:
    | Duration
    | undefined;
  /**
   * If set to true, HCM will flush an access log once when a new HTTP request is received, after the request
   * headers have been evaluated, and before iterating through the HTTP filter chain.
   *
   * .. attention::
   *
   *   This field is deprecated in favor of
   *   :ref:`flush_access_log_on_new_request
   *   <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.HcmAccessLogOptions.flush_access_log_on_new_request>`.
   *   Note that if both this field and :ref:`flush_access_log_on_new_request
   *   <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.HcmAccessLogOptions.flush_access_log_on_new_request>`
   *   are specified, the former (deprecated field) is ignored.
   *
   * @deprecated
   */
  flush_access_log_on_new_request?:
    | boolean
    | undefined;
  /** Additional access log options for HTTP connection manager. */
  access_log_options?:
    | HttpConnectionManager_HcmAccessLogOptions
    | undefined;
  /**
   * If set to true, the connection manager will use the real remote address
   * of the client connection when determining internal versus external origin and manipulating
   * various headers. If set to false or absent, the connection manager will use the
   * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. See the documentation for
   * :ref:`config_http_conn_man_headers_x-forwarded-for`,
   * :ref:`config_http_conn_man_headers_x-envoy-internal`, and
   * :ref:`config_http_conn_man_headers_x-envoy-external-address` for more information.
   */
  use_remote_address?:
    | boolean
    | undefined;
  /**
   * The number of additional ingress proxy hops from the right side of the
   * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header to trust when
   * determining the origin client's IP address. The default is zero if this option
   * is not specified. See the documentation for
   * :ref:`config_http_conn_man_headers_x-forwarded-for` for more information.
   */
  xff_num_trusted_hops?:
    | number
    | undefined;
  /**
   * The configuration for the original IP detection extensions.
   *
   * When configured the extensions will be called along with the request headers
   * and information about the downstream connection, such as the directly connected address.
   * Each extension will then use these parameters to decide the request's effective remote address.
   * If an extension fails to detect the original IP address and isn't configured to reject
   * the request, the HCM will try the remaining extensions until one succeeds or rejects
   * the request. If the request isn't rejected nor any extension succeeds, the HCM will
   * fallback to using the remote address.
   *
   * .. WARNING::
   *    Extensions cannot be used in conjunction with :ref:`use_remote_address
   *    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address>`
   *    nor :ref:`xff_num_trusted_hops
   *    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.xff_num_trusted_hops>`.
   *
   * [#extension-category: envoy.http.original_ip_detection]
   */
  original_ip_detection_extensions?:
    | TypedExtensionConfig[]
    | undefined;
  /**
   * The configuration for the early header mutation extensions.
   *
   * When configured the extensions will be called before any routing, tracing, or any filter processing.
   * Each extension will be applied in the order they are configured.
   * If the same header is mutated by multiple extensions, then the last extension will win.
   *
   * [#extension-category: envoy.http.early_header_mutation]
   */
  early_header_mutation_extensions?:
    | TypedExtensionConfig[]
    | undefined;
  /**
   * Configures what network addresses are considered internal for stats and header sanitation
   * purposes. If unspecified, only RFC1918 IP addresses will be considered internal.
   * See the documentation for :ref:`config_http_conn_man_headers_x-envoy-internal` for more
   * information about internal/external addresses.
   *
   * .. warning::
   *     In the next release, no IP addresses will be considered trusted. If you have tooling such as probes
   *     on your private network which need to be treated as trusted (e.g. changing arbitrary x-envoy headers)
   *     you will have to manually include those addresses or CIDR ranges like:
   *
   * .. validated-code-block:: yaml
   *   :type-name: envoy.extensions.filters.network.http_connection_manager.v3.InternalAddressConfig
   *
   *   cidr_ranges:
   *       address_prefix: 10.0.0.0
   *       prefix_len: 8
   *   cidr_ranges:
   *       address_prefix: 192.168.0.0
   *       prefix_len: 16
   *   cidr_ranges:
   *       address_prefix: 172.16.0.0
   *       prefix_len: 12
   *   cidr_ranges:
   *       address_prefix: 127.0.0.1
   *       prefix_len: 32
   *   cidr_ranges:
   *       address_prefix: fd00::
   *       prefix_len: 8
   *   cidr_ranges:
   *       address_prefix: ::1
   *       prefix_len: 128
   */
  internal_address_config?:
    | HttpConnectionManager_InternalAddressConfig
    | undefined;
  /**
   * If set, Envoy will not append the remote address to the
   * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. This may be used in
   * conjunction with HTTP filters that explicitly manipulate XFF after the HTTP connection manager
   * has mutated the request headers. While :ref:`use_remote_address
   * <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address>`
   * will also suppress XFF addition, it has consequences for logging and other
   * Envoy uses of the remote address, so ``skip_xff_append`` should be used
   * when only an elision of XFF addition is intended.
   */
  skip_xff_append?:
    | boolean
    | undefined;
  /**
   * Via header value to append to request and response headers. If this is
   * empty, no via header will be appended.
   */
  via?:
    | string
    | undefined;
  /**
   * Whether the connection manager will generate the :ref:`x-request-id
   * <config_http_conn_man_headers_x-request-id>` header if it does not exist. This defaults to
   * true. Generating a random UUID4 is expensive so in high throughput scenarios where this feature
   * is not desired it can be disabled.
   */
  generate_request_id?:
    | boolean
    | undefined;
  /**
   * Whether the connection manager will keep the :ref:`x-request-id
   * <config_http_conn_man_headers_x-request-id>` header if passed for a request that is edge
   * (Edge request is the request from external clients to front Envoy) and not reset it, which
   * is the current Envoy behaviour. This defaults to false.
   */
  preserve_external_request_id?:
    | boolean
    | undefined;
  /**
   * If set, Envoy will always set :ref:`x-request-id <config_http_conn_man_headers_x-request-id>` header in response.
   * If this is false or not set, the request ID is returned in responses only if tracing is forced using
   * :ref:`x-envoy-force-trace <config_http_conn_man_headers_x-envoy-force-trace>` header.
   */
  always_set_request_id_in_response?:
    | boolean
    | undefined;
  /**
   * How to handle the :ref:`config_http_conn_man_headers_x-forwarded-client-cert` (XFCC) HTTP
   * header.
   */
  forward_client_cert_details?:
    | HttpConnectionManager_ForwardClientCertDetails
    | undefined;
  /**
   * This field is valid only when :ref:`forward_client_cert_details
   * <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.forward_client_cert_details>`
   * is APPEND_FORWARD or SANITIZE_SET and the client connection is mTLS. It specifies the fields in
   * the client certificate to be forwarded. Note that in the
   * :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header, ``Hash`` is always set, and
   * ``By`` is always set when the client certificate presents the URI type Subject Alternative Name
   * value.
   */
  set_current_client_cert_details?:
    | HttpConnectionManager_SetCurrentClientCertDetails
    | undefined;
  /**
   * If proxy_100_continue is true, Envoy will proxy incoming "Expect:
   * 100-continue" headers upstream, and forward "100 Continue" responses
   * downstream. If this is false or not set, Envoy will instead strip the
   * "Expect: 100-continue" header, and send a "100 Continue" response itself.
   */
  proxy_100_continue?:
    | boolean
    | undefined;
  /**
   * If
   * :ref:`use_remote_address
   * <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address>`
   * is true and represent_ipv4_remote_address_as_ipv4_mapped_ipv6 is true and the remote address is
   * an IPv4 address, the address will be mapped to IPv6 before it is appended to ``x-forwarded-for``.
   * This is useful for testing compatibility of upstream services that parse the header value. For
   * example, 50.0.0.1 is represented as ::FFFF:50.0.0.1. See `IPv4-Mapped IPv6 Addresses
   * <https://tools.ietf.org/html/rfc4291#section-2.5.5.2>`_ for details. This will also affect the
   * :ref:`config_http_conn_man_headers_x-envoy-external-address` header. See
   * :ref:`http_connection_manager.represent_ipv4_remote_address_as_ipv4_mapped_ipv6
   * <config_http_conn_man_runtime_represent_ipv4_remote_address_as_ipv4_mapped_ipv6>` for runtime
   * control.
   * [#not-implemented-hide:]
   */
  represent_ipv4_remote_address_as_ipv4_mapped_ipv6?: boolean | undefined;
  upgrade_configs?:
    | HttpConnectionManager_UpgradeConfig[]
    | undefined;
  /**
   * Should paths be normalized according to RFC 3986 before any processing of
   * requests by HTTP filters or routing? This affects the upstream ``:path`` header
   * as well. For paths that fail this check, Envoy will respond with 400 to
   * paths that are malformed. This defaults to false currently but will default
   * true in the future. When not specified, this value may be overridden by the
   * runtime variable
   * :ref:`http_connection_manager.normalize_path<config_http_conn_man_runtime_normalize_path>`.
   * See `Normalization and Comparison <https://tools.ietf.org/html/rfc3986#section-6>`_
   * for details of normalization.
   * Note that Envoy does not perform
   * `case normalization <https://tools.ietf.org/html/rfc3986#section-6.2.2.1>`_
   * [#comment:TODO: This field is ignored when the
   * :ref:`header validation configuration <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config>`
   * is present.]
   */
  normalize_path?:
    | boolean
    | undefined;
  /**
   * Determines if adjacent slashes in the path are merged into one before any processing of
   * requests by HTTP filters or routing. This affects the upstream ``:path`` header as well. Without
   * setting this option, incoming requests with path ``//dir///file`` will not match against route
   * with ``prefix`` match set to ``/dir``. Defaults to ``false``. Note that slash merging is not part of
   * `HTTP spec <https://tools.ietf.org/html/rfc3986>`_ and is provided for convenience.
   * [#comment:TODO: This field is ignored when the
   * :ref:`header validation configuration <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config>`
   * is present.]
   */
  merge_slashes?:
    | boolean
    | undefined;
  /**
   * Action to take when request URL path contains escaped slash sequences (%2F, %2f, %5C and %5c).
   * The default value can be overridden by the :ref:`http_connection_manager.path_with_escaped_slashes_action<config_http_conn_man_runtime_path_with_escaped_slashes_action>`
   * runtime variable.
   * The :ref:`http_connection_manager.path_with_escaped_slashes_action_sampling<config_http_conn_man_runtime_path_with_escaped_slashes_action_enabled>` runtime
   * variable can be used to apply the action to a portion of all requests.
   * [#comment:TODO: This field is ignored when the
   * :ref:`header validation configuration <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config>`
   * is present.]
   */
  path_with_escaped_slashes_action?:
    | HttpConnectionManager_PathWithEscapedSlashesAction
    | undefined;
  /**
   * The configuration of the request ID extension. This includes operations such as
   * generation, validation, and associated tracing operations. If empty, the
   * :ref:`UuidRequestIdConfig <envoy_v3_api_msg_extensions.request_id.uuid.v3.UuidRequestIdConfig>`
   * default extension is used with default parameters. See the documentation for that extension
   * for details on what it does. Customizing the configuration for the default extension can be
   * achieved by configuring it explicitly here. For example, to disable trace reason packing,
   * the following configuration can be used:
   *
   * .. validated-code-block:: yaml
   *   :type-name: envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension
   *
   *   typed_config:
   *     "@type": type.googleapis.com/envoy.extensions.request_id.uuid.v3.UuidRequestIdConfig
   *     pack_trace_reason: false
   *
   * [#extension-category: envoy.request_id]
   */
  request_id_extension?:
    | RequestIDExtension
    | undefined;
  /**
   * The configuration to customize local reply returned by Envoy. It can customize status code,
   * body text and response content type. If not specified, status code and text body are hard
   * coded in Envoy, the response content type is plain text.
   */
  local_reply_config?:
    | LocalReplyConfig
    | undefined;
  /**
   * Determines if the port part should be removed from host/authority header before any processing
   * of request by HTTP filters or routing. The port would be removed only if it is equal to the :ref:`listener's<envoy_v3_api_field_config.listener.v3.Listener.address>`
   * local port. This affects the upstream host header unless the method is
   * CONNECT in which case if no filter adds a port the original port will be restored before headers are
   * sent upstream.
   * Without setting this option, incoming requests with host ``example:443`` will not match against
   * route with :ref:`domains<envoy_v3_api_field_config.route.v3.VirtualHost.domains>` match set to ``example``. Defaults to ``false``. Note that port removal is not part
   * of `HTTP spec <https://tools.ietf.org/html/rfc3986>`_ and is provided for convenience.
   * Only one of ``strip_matching_host_port`` or ``strip_any_host_port`` can be set.
   */
  strip_matching_host_port?: boolean | undefined;
  strip_port_mode?:
    | //
    /**
     * Determines if the port part should be removed from host/authority header before any processing
     * of request by HTTP filters or routing.
     * This affects the upstream host header unless the method is CONNECT in
     * which case if no filter adds a port the original port will be restored before headers are sent upstream.
     * Without setting this option, incoming requests with host ``example:443`` will not match against
     * route with :ref:`domains<envoy_v3_api_field_config.route.v3.VirtualHost.domains>` match set to ``example``. Defaults to ``false``. Note that port removal is not part
     * of `HTTP spec <https://tools.ietf.org/html/rfc3986>`_ and is provided for convenience.
     * Only one of ``strip_matching_host_port`` or ``strip_any_host_port`` can be set.
     */
    { $case: "strip_any_host_port"; strip_any_host_port: boolean }
    | undefined;
  /**
   * Governs Envoy's behavior when receiving invalid HTTP from downstream.
   * If this option is false (default), Envoy will err on the conservative side handling HTTP
   * errors, terminating both HTTP/1.1 and HTTP/2 connections when receiving an invalid request.
   * If this option is set to true, Envoy will be more permissive, only resetting the invalid
   * stream in the case of HTTP/2 and leaving the connection open where possible (if the entire
   * request is read for HTTP/1.1)
   * In general this should be true for deployments receiving trusted traffic (L2 Envoys,
   * company-internal mesh) and false when receiving untrusted traffic (edge deployments).
   *
   * If different behaviors for invalid_http_message for HTTP/1 and HTTP/2 are
   * desired, one should use the new HTTP/1 option :ref:`override_stream_error_on_invalid_http_message
   * <envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.override_stream_error_on_invalid_http_message>` or the new HTTP/2 option
   * :ref:`override_stream_error_on_invalid_http_message
   * <envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.override_stream_error_on_invalid_http_message>`
   * ``not`` the deprecated but similarly named :ref:`stream_error_on_invalid_http_messaging
   * <envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.stream_error_on_invalid_http_messaging>`
   */
  stream_error_on_invalid_http_message?:
    | boolean
    | undefined;
  /**
   * [#not-implemented-hide:] Path normalization configuration. This includes
   * configurations for transformations (e.g. RFC 3986 normalization or merge
   * adjacent slashes) and the policy to apply them. The policy determines
   * whether transformations affect the forwarded ``:path`` header. RFC 3986 path
   * normalization is enabled by default and the default policy is that the
   * normalized header will be forwarded. See :ref:`PathNormalizationOptions
   * <envoy_v3_api_msg_extensions.filters.network.http_connection_manager.v3.PathNormalizationOptions>`
   * for details.
   */
  path_normalization_options?:
    | HttpConnectionManager_PathNormalizationOptions
    | undefined;
  /**
   * Determines if trailing dot of the host should be removed from host/authority header before any
   * processing of request by HTTP filters or routing.
   * This affects the upstream host header.
   * Without setting this option, incoming requests with host ``example.com.`` will not match against
   * route with :ref:`domains<envoy_v3_api_field_config.route.v3.VirtualHost.domains>` match set to ``example.com``. Defaults to ``false``.
   * When the incoming request contains a host/authority header that includes a port number,
   * setting this option will strip a trailing dot, if present, from the host section,
   * leaving the port as is (e.g. host value ``example.com.:443`` will be updated to ``example.com:443``).
   */
  strip_trailing_host_dot?:
    | boolean
    | undefined;
  /**
   * Proxy-Status HTTP response header configuration.
   * If this config is set, the Proxy-Status HTTP response header field is
   * populated. By default, it is not.
   */
  proxy_status_config?:
    | HttpConnectionManager_ProxyStatusConfig
    | undefined;
  /**
   * Configuration options for Header Validation (UHV).
   * UHV is an extensible mechanism for checking validity of HTTP requests as well as providing
   * normalization for request attributes, such as URI path.
   * If the typed_header_validation_config is present it overrides the following options:
   * ``normalize_path``, ``merge_slashes``, ``path_with_escaped_slashes_action``
   * ``http_protocol_options.allow_chunked_length``, ``common_http_protocol_options.headers_with_underscores_action``.
   *
   * The default UHV checks the following:
   *
   * #. HTTP/1 header map validity according to `RFC 7230 section 3.2<https://datatracker.ietf.org/doc/html/rfc7230#section-3.2>`_
   * #. Syntax of HTTP/1 request target URI and response status
   * #. HTTP/2 header map validity according to `RFC 7540 section 8.1.2<https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2`_
   * #. Syntax of HTTP/2 pseudo headers
   * #. HTTP/3 header map validity according to `RFC 9114 section 4.3 <https://www.rfc-editor.org/rfc/rfc9114.html>`_
   * #. Syntax of HTTP/3 pseudo headers
   * #. Syntax of ``Content-Length`` and ``Transfer-Encoding``
   * #. Validation of HTTP/1 requests with both ``Content-Length`` and ``Transfer-Encoding`` headers
   * #. Normalization of the URI path according to `Normalization and Comparison <https://datatracker.ietf.org/doc/html/rfc3986#section-6>`_
   *    without `case normalization <https://datatracker.ietf.org/doc/html/rfc3986#section-6.2.2.1>`_
   *
   * [#not-implemented-hide:]
   * [#extension-category: envoy.http.header_validators]
   */
  typed_header_validation_config?:
    | TypedExtensionConfig
    | undefined;
  /**
   * Append the ``x-forwarded-port`` header with the port value client used to connect to Envoy. It
   * will be ignored if the ``x-forwarded-port`` header has been set by any trusted proxy in front of Envoy.
   */
  append_x_forwarded_port?:
    | boolean
    | undefined;
  /**
   * Append the :ref:`config_http_conn_man_headers_x-envoy-local-overloaded` HTTP header in the scenario where
   * the Overload Manager has been triggered.
   */
  append_local_overload?:
    | boolean
    | undefined;
  /**
   * Whether the HCM will add ProxyProtocolFilterState to the Connection lifetime filter state. Defaults to ``true``.
   * This should be set to ``false`` in cases where Envoy's view of the downstream address may not correspond to the
   * actual client address, for example, if there's another proxy in front of the Envoy.
   */
  add_proxy_protocol_connection_state?: boolean | undefined;
}

export enum HttpConnectionManager_CodecType {
  /**
   * AUTO - For every new connection, the connection manager will determine which
   * codec to use. This mode supports both ALPN for TLS listeners as well as
   * protocol inference for plaintext listeners. If ALPN data is available, it
   * is preferred, otherwise protocol inference is used. In almost all cases,
   * this is the right option to choose for this setting.
   */
  AUTO = "AUTO",
  /** HTTP1 - The connection manager will assume that the client is speaking HTTP/1.1. */
  HTTP1 = "HTTP1",
  /**
   * HTTP2 - The connection manager will assume that the client is speaking HTTP/2
   * (Envoy does not require HTTP/2 to take place over TLS or to use ALPN.
   * Prior knowledge is allowed).
   */
  HTTP2 = "HTTP2",
  /**
   * HTTP3 - The connection manager will assume that the client is speaking HTTP/3.
   * This needs to be consistent with listener and transport socket config.
   */
  HTTP3 = "HTTP3",
}

export function httpConnectionManager_CodecTypeFromJSON(object: any): HttpConnectionManager_CodecType {
  switch (object) {
    case 0:
    case "AUTO":
      return HttpConnectionManager_CodecType.AUTO;
    case 1:
    case "HTTP1":
      return HttpConnectionManager_CodecType.HTTP1;
    case 2:
    case "HTTP2":
      return HttpConnectionManager_CodecType.HTTP2;
    case 3:
    case "HTTP3":
      return HttpConnectionManager_CodecType.HTTP3;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum HttpConnectionManager_CodecType");
  }
}

export function httpConnectionManager_CodecTypeToJSON(object: HttpConnectionManager_CodecType): string {
  switch (object) {
    case HttpConnectionManager_CodecType.AUTO:
      return "AUTO";
    case HttpConnectionManager_CodecType.HTTP1:
      return "HTTP1";
    case HttpConnectionManager_CodecType.HTTP2:
      return "HTTP2";
    case HttpConnectionManager_CodecType.HTTP3:
      return "HTTP3";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum HttpConnectionManager_CodecType");
  }
}

export function httpConnectionManager_CodecTypeToNumber(object: HttpConnectionManager_CodecType): number {
  switch (object) {
    case HttpConnectionManager_CodecType.AUTO:
      return 0;
    case HttpConnectionManager_CodecType.HTTP1:
      return 1;
    case HttpConnectionManager_CodecType.HTTP2:
      return 2;
    case HttpConnectionManager_CodecType.HTTP3:
      return 3;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum HttpConnectionManager_CodecType");
  }
}

export enum HttpConnectionManager_ServerHeaderTransformation {
  /** OVERWRITE - Overwrite any Server header with the contents of server_name. */
  OVERWRITE = "OVERWRITE",
  /**
   * APPEND_IF_ABSENT - If no Server header is present, append Server server_name
   * If a Server header is present, pass it through.
   */
  APPEND_IF_ABSENT = "APPEND_IF_ABSENT",
  /**
   * PASS_THROUGH - Pass through the value of the server header, and do not append a header
   * if none is present.
   */
  PASS_THROUGH = "PASS_THROUGH",
}

export function httpConnectionManager_ServerHeaderTransformationFromJSON(
  object: any,
): HttpConnectionManager_ServerHeaderTransformation {
  switch (object) {
    case 0:
    case "OVERWRITE":
      return HttpConnectionManager_ServerHeaderTransformation.OVERWRITE;
    case 1:
    case "APPEND_IF_ABSENT":
      return HttpConnectionManager_ServerHeaderTransformation.APPEND_IF_ABSENT;
    case 2:
    case "PASS_THROUGH":
      return HttpConnectionManager_ServerHeaderTransformation.PASS_THROUGH;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum HttpConnectionManager_ServerHeaderTransformation",
      );
  }
}

export function httpConnectionManager_ServerHeaderTransformationToJSON(
  object: HttpConnectionManager_ServerHeaderTransformation,
): string {
  switch (object) {
    case HttpConnectionManager_ServerHeaderTransformation.OVERWRITE:
      return "OVERWRITE";
    case HttpConnectionManager_ServerHeaderTransformation.APPEND_IF_ABSENT:
      return "APPEND_IF_ABSENT";
    case HttpConnectionManager_ServerHeaderTransformation.PASS_THROUGH:
      return "PASS_THROUGH";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum HttpConnectionManager_ServerHeaderTransformation",
      );
  }
}

export function httpConnectionManager_ServerHeaderTransformationToNumber(
  object: HttpConnectionManager_ServerHeaderTransformation,
): number {
  switch (object) {
    case HttpConnectionManager_ServerHeaderTransformation.OVERWRITE:
      return 0;
    case HttpConnectionManager_ServerHeaderTransformation.APPEND_IF_ABSENT:
      return 1;
    case HttpConnectionManager_ServerHeaderTransformation.PASS_THROUGH:
      return 2;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum HttpConnectionManager_ServerHeaderTransformation",
      );
  }
}

/**
 * How to handle the :ref:`config_http_conn_man_headers_x-forwarded-client-cert` (XFCC) HTTP
 * header.
 */
export enum HttpConnectionManager_ForwardClientCertDetails {
  /** SANITIZE - Do not send the XFCC header to the next hop. This is the default value. */
  SANITIZE = "SANITIZE",
  /**
   * FORWARD_ONLY - When the client connection is mTLS (Mutual TLS), forward the XFCC header
   * in the request.
   */
  FORWARD_ONLY = "FORWARD_ONLY",
  /**
   * APPEND_FORWARD - When the client connection is mTLS, append the client certificate
   * information to the request’s XFCC header and forward it.
   */
  APPEND_FORWARD = "APPEND_FORWARD",
  /**
   * SANITIZE_SET - When the client connection is mTLS, reset the XFCC header with the client
   * certificate information and send it to the next hop.
   */
  SANITIZE_SET = "SANITIZE_SET",
  /**
   * ALWAYS_FORWARD_ONLY - Always forward the XFCC header in the request, regardless of whether the
   * client connection is mTLS.
   */
  ALWAYS_FORWARD_ONLY = "ALWAYS_FORWARD_ONLY",
}

export function httpConnectionManager_ForwardClientCertDetailsFromJSON(
  object: any,
): HttpConnectionManager_ForwardClientCertDetails {
  switch (object) {
    case 0:
    case "SANITIZE":
      return HttpConnectionManager_ForwardClientCertDetails.SANITIZE;
    case 1:
    case "FORWARD_ONLY":
      return HttpConnectionManager_ForwardClientCertDetails.FORWARD_ONLY;
    case 2:
    case "APPEND_FORWARD":
      return HttpConnectionManager_ForwardClientCertDetails.APPEND_FORWARD;
    case 3:
    case "SANITIZE_SET":
      return HttpConnectionManager_ForwardClientCertDetails.SANITIZE_SET;
    case 4:
    case "ALWAYS_FORWARD_ONLY":
      return HttpConnectionManager_ForwardClientCertDetails.ALWAYS_FORWARD_ONLY;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum HttpConnectionManager_ForwardClientCertDetails",
      );
  }
}

export function httpConnectionManager_ForwardClientCertDetailsToJSON(
  object: HttpConnectionManager_ForwardClientCertDetails,
): string {
  switch (object) {
    case HttpConnectionManager_ForwardClientCertDetails.SANITIZE:
      return "SANITIZE";
    case HttpConnectionManager_ForwardClientCertDetails.FORWARD_ONLY:
      return "FORWARD_ONLY";
    case HttpConnectionManager_ForwardClientCertDetails.APPEND_FORWARD:
      return "APPEND_FORWARD";
    case HttpConnectionManager_ForwardClientCertDetails.SANITIZE_SET:
      return "SANITIZE_SET";
    case HttpConnectionManager_ForwardClientCertDetails.ALWAYS_FORWARD_ONLY:
      return "ALWAYS_FORWARD_ONLY";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum HttpConnectionManager_ForwardClientCertDetails",
      );
  }
}

export function httpConnectionManager_ForwardClientCertDetailsToNumber(
  object: HttpConnectionManager_ForwardClientCertDetails,
): number {
  switch (object) {
    case HttpConnectionManager_ForwardClientCertDetails.SANITIZE:
      return 0;
    case HttpConnectionManager_ForwardClientCertDetails.FORWARD_ONLY:
      return 1;
    case HttpConnectionManager_ForwardClientCertDetails.APPEND_FORWARD:
      return 2;
    case HttpConnectionManager_ForwardClientCertDetails.SANITIZE_SET:
      return 3;
    case HttpConnectionManager_ForwardClientCertDetails.ALWAYS_FORWARD_ONLY:
      return 4;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum HttpConnectionManager_ForwardClientCertDetails",
      );
  }
}

/**
 * Determines the action for request that contain %2F, %2f, %5C or %5c sequences in the URI path.
 * This operation occurs before URL normalization and the merge slashes transformations if they were enabled.
 */
export enum HttpConnectionManager_PathWithEscapedSlashesAction {
  /**
   * IMPLEMENTATION_SPECIFIC_DEFAULT - Default behavior specific to implementation (i.e. Envoy) of this configuration option.
   * Envoy, by default, takes the KEEP_UNCHANGED action.
   * NOTE: the implementation may change the default behavior at-will.
   */
  IMPLEMENTATION_SPECIFIC_DEFAULT = "IMPLEMENTATION_SPECIFIC_DEFAULT",
  /** KEEP_UNCHANGED - Keep escaped slashes. */
  KEEP_UNCHANGED = "KEEP_UNCHANGED",
  /**
   * REJECT_REQUEST - Reject client request with the 400 status. gRPC requests will be rejected with the INTERNAL (13) error code.
   * The "httpN.downstream_rq_failed_path_normalization" counter is incremented for each rejected request.
   */
  REJECT_REQUEST = "REJECT_REQUEST",
  /**
   * UNESCAPE_AND_REDIRECT - Unescape %2F and %5C sequences and redirect request to the new path if these sequences were present.
   * Redirect occurs after path normalization and merge slashes transformations if they were configured.
   * NOTE: gRPC requests will be rejected with the INTERNAL (13) error code.
   * This option minimizes possibility of path confusion exploits by forcing request with unescaped slashes to
   * traverse all parties: downstream client, intermediate proxies, Envoy and upstream server.
   * The "httpN.downstream_rq_redirected_with_normalized_path" counter is incremented for each
   * redirected request.
   */
  UNESCAPE_AND_REDIRECT = "UNESCAPE_AND_REDIRECT",
  /**
   * UNESCAPE_AND_FORWARD - Unescape %2F and %5C sequences.
   * Note: this option should not be enabled if intermediaries perform path based access control as
   * it may lead to path confusion vulnerabilities.
   */
  UNESCAPE_AND_FORWARD = "UNESCAPE_AND_FORWARD",
}

export function httpConnectionManager_PathWithEscapedSlashesActionFromJSON(
  object: any,
): HttpConnectionManager_PathWithEscapedSlashesAction {
  switch (object) {
    case 0:
    case "IMPLEMENTATION_SPECIFIC_DEFAULT":
      return HttpConnectionManager_PathWithEscapedSlashesAction.IMPLEMENTATION_SPECIFIC_DEFAULT;
    case 1:
    case "KEEP_UNCHANGED":
      return HttpConnectionManager_PathWithEscapedSlashesAction.KEEP_UNCHANGED;
    case 2:
    case "REJECT_REQUEST":
      return HttpConnectionManager_PathWithEscapedSlashesAction.REJECT_REQUEST;
    case 3:
    case "UNESCAPE_AND_REDIRECT":
      return HttpConnectionManager_PathWithEscapedSlashesAction.UNESCAPE_AND_REDIRECT;
    case 4:
    case "UNESCAPE_AND_FORWARD":
      return HttpConnectionManager_PathWithEscapedSlashesAction.UNESCAPE_AND_FORWARD;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum HttpConnectionManager_PathWithEscapedSlashesAction",
      );
  }
}

export function httpConnectionManager_PathWithEscapedSlashesActionToJSON(
  object: HttpConnectionManager_PathWithEscapedSlashesAction,
): string {
  switch (object) {
    case HttpConnectionManager_PathWithEscapedSlashesAction.IMPLEMENTATION_SPECIFIC_DEFAULT:
      return "IMPLEMENTATION_SPECIFIC_DEFAULT";
    case HttpConnectionManager_PathWithEscapedSlashesAction.KEEP_UNCHANGED:
      return "KEEP_UNCHANGED";
    case HttpConnectionManager_PathWithEscapedSlashesAction.REJECT_REQUEST:
      return "REJECT_REQUEST";
    case HttpConnectionManager_PathWithEscapedSlashesAction.UNESCAPE_AND_REDIRECT:
      return "UNESCAPE_AND_REDIRECT";
    case HttpConnectionManager_PathWithEscapedSlashesAction.UNESCAPE_AND_FORWARD:
      return "UNESCAPE_AND_FORWARD";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum HttpConnectionManager_PathWithEscapedSlashesAction",
      );
  }
}

export function httpConnectionManager_PathWithEscapedSlashesActionToNumber(
  object: HttpConnectionManager_PathWithEscapedSlashesAction,
): number {
  switch (object) {
    case HttpConnectionManager_PathWithEscapedSlashesAction.IMPLEMENTATION_SPECIFIC_DEFAULT:
      return 0;
    case HttpConnectionManager_PathWithEscapedSlashesAction.KEEP_UNCHANGED:
      return 1;
    case HttpConnectionManager_PathWithEscapedSlashesAction.REJECT_REQUEST:
      return 2;
    case HttpConnectionManager_PathWithEscapedSlashesAction.UNESCAPE_AND_REDIRECT:
      return 3;
    case HttpConnectionManager_PathWithEscapedSlashesAction.UNESCAPE_AND_FORWARD:
      return 4;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum HttpConnectionManager_PathWithEscapedSlashesAction",
      );
  }
}

/** [#next-free-field: 11] */
export interface HttpConnectionManager_Tracing {
  $type: "envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing";
  /**
   * Target percentage of requests managed by this HTTP connection manager that will be force
   * traced if the :ref:`x-client-trace-id <config_http_conn_man_headers_x-client-trace-id>`
   * header is set. This field is a direct analog for the runtime variable
   * 'tracing.client_enabled' in the :ref:`HTTP Connection Manager
   * <config_http_conn_man_runtime>`.
   * Default: 100%
   */
  client_sampling?:
    | Percent
    | undefined;
  /**
   * Target percentage of requests managed by this HTTP connection manager that will be randomly
   * selected for trace generation, if not requested by the client or not forced. This field is
   * a direct analog for the runtime variable 'tracing.random_sampling' in the
   * :ref:`HTTP Connection Manager <config_http_conn_man_runtime>`.
   * Default: 100%
   */
  random_sampling?:
    | Percent
    | undefined;
  /**
   * Target percentage of requests managed by this HTTP connection manager that will be traced
   * after all other sampling checks have been applied (client-directed, force tracing, random
   * sampling). This field functions as an upper limit on the total configured sampling rate. For
   * instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
   * of client requests with the appropriate headers to be force traced. This field is a direct
   * analog for the runtime variable 'tracing.global_enabled' in the
   * :ref:`HTTP Connection Manager <config_http_conn_man_runtime>`.
   * Default: 100%
   */
  overall_sampling?:
    | Percent
    | undefined;
  /**
   * Whether to annotate spans with additional data. If true, spans will include logs for stream
   * events.
   */
  verbose?:
    | boolean
    | undefined;
  /**
   * Maximum length of the request path to extract and include in the HttpUrl tag. Used to
   * truncate lengthy request paths to meet the needs of a tracing backend.
   * Default: 256
   */
  max_path_tag_length?:
    | number
    | undefined;
  /** A list of custom tags with unique tag name to create tags for the active span. */
  custom_tags?:
    | CustomTag[]
    | undefined;
  /**
   * Configuration for an external tracing provider.
   * If not specified, no tracing will be performed.
   *
   * .. attention::
   *   Please be aware that ``envoy.tracers.opencensus`` provider can only be configured once
   *   in Envoy lifetime.
   *   Any attempts to reconfigure it or to use different configurations for different HCM filters
   *   will be rejected.
   *   Such a constraint is inherent to OpenCensus itself. It cannot be overcome without changes
   *   on OpenCensus side.
   */
  provider?:
    | Tracing_Http
    | undefined;
  /**
   * Create separate tracing span for each upstream request if true. And if this flag is set to true,
   * the tracing provider will assume that Envoy will be independent hop in the trace chain and may
   * set span type to client or server based on this flag.
   * This will deprecate the
   * :ref:`start_child_span <envoy_v3_api_field_extensions.filters.http.router.v3.Router.start_child_span>`
   * in the router.
   *
   * Users should set appropriate value based on their tracing provider and actual scenario:
   *
   * * If Envoy is used as sidecar and users want to make the sidecar and its application as only one
   *   hop in the trace chain, this flag should be set to false. And please also make sure the
   *   :ref:`start_child_span <envoy_v3_api_field_extensions.filters.http.router.v3.Router.start_child_span>`
   *   in the router is not set to true.
   * * If Envoy is used as gateway or independent proxy, or users want to make the sidecar and its
   *   application as different hops in the trace chain, this flag should be set to true.
   * * If tracing provider that has explicit requirements on span creation (like SkyWalking),
   *   this flag should be set to true.
   *
   * The default value is false for now for backward compatibility.
   */
  spawn_upstream_span?: boolean | undefined;
}

export enum HttpConnectionManager_Tracing_OperationName {
  /** INGRESS - The HTTP listener is used for ingress/incoming requests. */
  INGRESS = "INGRESS",
  /** EGRESS - The HTTP listener is used for egress/outgoing requests. */
  EGRESS = "EGRESS",
}

export function httpConnectionManager_Tracing_OperationNameFromJSON(
  object: any,
): HttpConnectionManager_Tracing_OperationName {
  switch (object) {
    case 0:
    case "INGRESS":
      return HttpConnectionManager_Tracing_OperationName.INGRESS;
    case 1:
    case "EGRESS":
      return HttpConnectionManager_Tracing_OperationName.EGRESS;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum HttpConnectionManager_Tracing_OperationName",
      );
  }
}

export function httpConnectionManager_Tracing_OperationNameToJSON(
  object: HttpConnectionManager_Tracing_OperationName,
): string {
  switch (object) {
    case HttpConnectionManager_Tracing_OperationName.INGRESS:
      return "INGRESS";
    case HttpConnectionManager_Tracing_OperationName.EGRESS:
      return "EGRESS";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum HttpConnectionManager_Tracing_OperationName",
      );
  }
}

export function httpConnectionManager_Tracing_OperationNameToNumber(
  object: HttpConnectionManager_Tracing_OperationName,
): number {
  switch (object) {
    case HttpConnectionManager_Tracing_OperationName.INGRESS:
      return 0;
    case HttpConnectionManager_Tracing_OperationName.EGRESS:
      return 1;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum HttpConnectionManager_Tracing_OperationName",
      );
  }
}

export interface HttpConnectionManager_InternalAddressConfig {
  $type: "envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig";
  /** Whether unix socket addresses should be considered internal. */
  unix_sockets?:
    | boolean
    | undefined;
  /**
   * List of CIDR ranges that are treated as internal. If unset, then RFC1918 / RFC4193
   * IP addresses will be considered internal.
   */
  cidr_ranges?: CidrRange[] | undefined;
}

/** [#next-free-field: 7] */
export interface HttpConnectionManager_SetCurrentClientCertDetails {
  $type:
    "envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails";
  /** Whether to forward the subject of the client cert. Defaults to false. */
  subject?:
    | boolean
    | undefined;
  /**
   * Whether to forward the entire client cert in URL encoded PEM format. This will appear in the
   * XFCC header comma separated from other values with the value Cert="PEM".
   * Defaults to false.
   */
  cert?:
    | boolean
    | undefined;
  /**
   * Whether to forward the entire client cert chain (including the leaf cert) in URL encoded PEM
   * format. This will appear in the XFCC header comma separated from other values with the value
   * Chain="PEM".
   * Defaults to false.
   */
  chain?:
    | boolean
    | undefined;
  /**
   * Whether to forward the DNS type Subject Alternative Names of the client cert.
   * Defaults to false.
   */
  dns?:
    | boolean
    | undefined;
  /**
   * Whether to forward the URI type Subject Alternative Name of the client cert. Defaults to
   * false.
   */
  uri?: boolean | undefined;
}

/**
 * The configuration for HTTP upgrades.
 * For each upgrade type desired, an UpgradeConfig must be added.
 *
 * .. warning::
 *
 *    The current implementation of upgrade headers does not handle
 *    multi-valued upgrade headers. Support for multi-valued headers may be
 *    added in the future if needed.
 *
 * .. warning::
 *    The current implementation of upgrade headers does not work with HTTP/2
 *    upstreams.
 */
export interface HttpConnectionManager_UpgradeConfig {
  $type: "envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig";
  /**
   * The case-insensitive name of this upgrade, e.g. "websocket".
   * For each upgrade type present in upgrade_configs, requests with
   * Upgrade: [upgrade_type]
   * will be proxied upstream.
   */
  upgrade_type?:
    | string
    | undefined;
  /**
   * If present, this represents the filter chain which will be created for
   * this type of upgrade. If no filters are present, the filter chain for
   * HTTP connections will be used for this upgrade type.
   */
  filters?:
    | HttpFilter[]
    | undefined;
  /**
   * Determines if upgrades are enabled or disabled by default. Defaults to true.
   * This can be overridden on a per-route basis with :ref:`cluster
   * <envoy_v3_api_field_config.route.v3.RouteAction.upgrade_configs>` as documented in the
   * :ref:`upgrade documentation <arch_overview_upgrades>`.
   */
  enabled?: boolean | undefined;
}

/**
 * [#not-implemented-hide:] Transformations that apply to path headers. Transformations are applied
 * before any processing of requests by HTTP filters, routing, and matching. Only the normalized
 * path will be visible internally if a transformation is enabled. Any path rewrites that the
 * router performs (e.g. :ref:`regex_rewrite
 * <envoy_v3_api_field_config.route.v3.RouteAction.regex_rewrite>` or :ref:`prefix_rewrite
 * <envoy_v3_api_field_config.route.v3.RouteAction.prefix_rewrite>`) will apply to the ``:path`` header
 * destined for the upstream.
 *
 * Note: access logging and tracing will show the original ``:path`` header.
 */
export interface HttpConnectionManager_PathNormalizationOptions {
  $type: "envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions";
  /**
   * [#not-implemented-hide:] Normalization applies internally before any processing of requests by
   * HTTP filters, routing, and matching *and* will affect the forwarded ``:path`` header. Defaults
   * to :ref:`NormalizePathRFC3986
   * <envoy_v3_api_msg_type.http.v3.PathTransformation.Operation.NormalizePathRFC3986>`. When not
   * specified, this value may be overridden by the runtime variable
   * :ref:`http_connection_manager.normalize_path<config_http_conn_man_runtime_normalize_path>`.
   * Envoy will respond with 400 to paths that are malformed (e.g. for paths that fail RFC 3986
   * normalization due to disallowed characters.)
   */
  forwarding_transformation?:
    | PathTransformation
    | undefined;
  /**
   * [#not-implemented-hide:] Normalization only applies internally before any processing of
   * requests by HTTP filters, routing, and matching. These will be applied after full
   * transformation is applied. The ``:path`` header before this transformation will be restored in
   * the router filter and sent upstream unless it was mutated by a filter. Defaults to no
   * transformations.
   * Multiple actions can be applied in the same Transformation, forming a sequential
   * pipeline. The transformations will be performed in the order that they appear. Envoy will
   * respond with 400 to paths that are malformed (e.g. for paths that fail RFC 3986
   * normalization due to disallowed characters.)
   */
  http_filter_transformation?: PathTransformation | undefined;
}

/**
 * Configures the manner in which the Proxy-Status HTTP response header is
 * populated.
 *
 * See the [Proxy-Status
 * RFC](https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-proxy-status-08).
 * [#comment:TODO: Update this with the non-draft URL when finalized.]
 *
 * The Proxy-Status header is a string of the form:
 *
 *   "<server_name>; error=<error_type>; details=<details>"
 * [#next-free-field: 7]
 */
export interface HttpConnectionManager_ProxyStatusConfig {
  $type: "envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig";
  /**
   * If true, the details field of the Proxy-Status header is not populated with stream_info.response_code_details.
   * This value defaults to ``false``, i.e. the ``details`` field is populated by default.
   */
  remove_details?:
    | boolean
    | undefined;
  /**
   * If true, the details field of the Proxy-Status header will not contain
   * connection termination details. This value defaults to ``false``, i.e. the
   * ``details`` field will contain connection termination details by default.
   */
  remove_connection_termination_details?:
    | boolean
    | undefined;
  /**
   * If true, the details field of the Proxy-Status header will not contain an
   * enumeration of the Envoy ResponseFlags. This value defaults to ``false``,
   * i.e. the ``details`` field will contain a list of ResponseFlags by default.
   */
  remove_response_flags?:
    | boolean
    | undefined;
  /**
   * If true, overwrites the existing Status header with the response code
   * recommended by the Proxy-Status spec.
   * This value defaults to ``false``, i.e. the HTTP response code is not
   * overwritten.
   */
  set_recommended_response_code?:
    | boolean
    | undefined;
  /**
   * The name of the proxy as it appears at the start of the Proxy-Status
   * header.
   *
   * If neither of these values are set, this value defaults to ``server_name``,
   * which itself defaults to "envoy".
   */
  proxy_name?:
    | //
    /**
     * If ``use_node_id`` is set, Proxy-Status headers will use the Envoy's node
     * ID as the name of the proxy.
     */
    { $case: "use_node_id"; use_node_id: boolean }
    | //
    /**
     * If ``literal_proxy_name`` is set, Proxy-Status headers will use this
     * value as the name of the proxy.
     */
    { $case: "literal_proxy_name"; literal_proxy_name: string }
    | undefined;
}

export interface HttpConnectionManager_HcmAccessLogOptions {
  $type: "envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.HcmAccessLogOptions";
  /**
   * The interval to flush the above access logs. By default, the HCM will flush exactly one access log
   * on stream close, when the HTTP request is complete. If this field is set, the HCM will flush access
   * logs periodically at the specified interval. This is especially useful in the case of long-lived
   * requests, such as CONNECT and Websockets. Final access logs can be detected via the
   * ``requestComplete()`` method of ``StreamInfo`` in access log filters, or through the ``%DURATION%`` substitution
   * string.
   * The interval must be at least 1 millisecond.
   */
  access_log_flush_interval?:
    | Duration
    | undefined;
  /**
   * If set to true, HCM will flush an access log when a new HTTP request is received, after request
   * headers have been evaluated, before iterating through the HTTP filter chain.
   * This log record, if enabled, does not depend on periodic log records or request completion log.
   * Details related to upstream cluster, such as upstream host, will not be available for this log.
   */
  flush_access_log_on_new_request?:
    | boolean
    | undefined;
  /**
   * If true, the HCM will flush an access log when a tunnel is successfully established. For example,
   * this could be when an upstream has successfully returned 101 Switching Protocols, or when the proxy
   * has returned 200 to a CONNECT request.
   */
  flush_log_on_tunnel_successfully_established?: boolean | undefined;
}

/** The configuration to customize local reply returned by Envoy. */
export interface LocalReplyConfig {
  $type: "envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig";
  /**
   * Configuration of list of mappers which allows to filter and change local response.
   * The mappers will be checked by the specified order until one is matched.
   */
  mappers?:
    | ResponseMapper[]
    | undefined;
  /**
   * The configuration to form response body from the :ref:`command operators <config_access_log_command_operators>`
   * and to specify response content type as one of: plain/text or application/json.
   *
   * Example one: "plain/text" ``body_format``.
   *
   * .. validated-code-block:: yaml
   *   :type-name: envoy.config.core.v3.SubstitutionFormatString
   *
   *   text_format: "%LOCAL_REPLY_BODY%:%RESPONSE_CODE%:path=%REQ(:path)%\n"
   *
   * The following response body in "plain/text" format will be generated for a request with
   * local reply body of "upstream connection error", response_code=503 and path=/foo.
   *
   * .. code-block:: text
   *
   *   upstream connect error:503:path=/foo
   *
   * Example two: "application/json" ``body_format``.
   *
   * .. validated-code-block:: yaml
   *   :type-name: envoy.config.core.v3.SubstitutionFormatString
   *
   *   json_format:
   *     status: "%RESPONSE_CODE%"
   *     message: "%LOCAL_REPLY_BODY%"
   *     path: "%REQ(:path)%"
   *
   * The following response body in "application/json" format would be generated for a request with
   * local reply body of "upstream connection error", response_code=503 and path=/foo.
   *
   * .. code-block:: json
   *
   *  {
   *    "status": 503,
   *    "message": "upstream connection error",
   *    "path": "/foo"
   *  }
   */
  body_format?: SubstitutionFormatString | undefined;
}

/**
 * The configuration to filter and change local response.
 * [#next-free-field: 6]
 */
export interface ResponseMapper {
  $type: "envoy.extensions.filters.network.http_connection_manager.v3.ResponseMapper";
  /** Filter to determine if this mapper should apply. */
  filter?:
    | AccessLogFilter
    | undefined;
  /** The new response status code if specified. */
  status_code?:
    | number
    | undefined;
  /**
   * The new local reply body text if specified. It will be used in the ``%LOCAL_REPLY_BODY%``
   * command operator in the ``body_format``.
   */
  body?:
    | DataSource
    | undefined;
  /**
   * A per mapper ``body_format`` to override the :ref:`body_format <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.LocalReplyConfig.body_format>`.
   * It will be used when this mapper is matched.
   */
  body_format_override?:
    | SubstitutionFormatString
    | undefined;
  /**
   * HTTP headers to add to a local reply. This allows the response mapper to append, to add
   * or to override headers of any local reply before it is sent to a downstream client.
   */
  headers_to_add?: HeaderValueOption[] | undefined;
}

export interface Rds {
  $type: "envoy.extensions.filters.network.http_connection_manager.v3.Rds";
  /** Configuration source specifier for RDS. */
  config_source?:
    | ConfigSource
    | undefined;
  /**
   * The name of the route configuration. This name will be passed to the RDS
   * API. This allows an Envoy configuration with multiple HTTP listeners (and
   * associated HTTP connection manager filters) to use different route
   * configurations.
   */
  route_config_name?: string | undefined;
}

/** This message is used to work around the limitations with 'oneof' and repeated fields. */
export interface ScopedRouteConfigurationsList {
  $type: "envoy.extensions.filters.network.http_connection_manager.v3.ScopedRouteConfigurationsList";
  scoped_route_configurations?: ScopedRouteConfiguration[] | undefined;
}

/** [#next-free-field: 6] */
export interface ScopedRoutes {
  $type: "envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes";
  /** The name assigned to the scoped routing configuration. */
  name?:
    | string
    | undefined;
  /** The algorithm to use for constructing a scope key for each request. */
  scope_key_builder?:
    | ScopedRoutes_ScopeKeyBuilder
    | undefined;
  /**
   * Configuration source specifier for RDS.
   * This config source is used to subscribe to RouteConfiguration resources specified in
   * ScopedRouteConfiguration messages.
   */
  rds_config_source?: ConfigSource | undefined;
  config_specifier?:
    | //
    /**
     * The set of routing scopes corresponding to the HCM. A scope is assigned to a request by
     * matching a key constructed from the request's attributes according to the algorithm specified
     * by the
     * :ref:`ScopeKeyBuilder<envoy_v3_api_msg_extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder>`
     * in this message.
     */
    { $case: "scoped_route_configurations_list"; scoped_route_configurations_list: ScopedRouteConfigurationsList }
    | //
    /**
     * The set of routing scopes associated with the HCM will be dynamically loaded via the SRDS
     * API. A scope is assigned to a request by matching a key constructed from the request's
     * attributes according to the algorithm specified by the
     * :ref:`ScopeKeyBuilder<envoy_v3_api_msg_extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder>`
     * in this message.
     */
    { $case: "scoped_rds"; scoped_rds: ScopedRds }
    | undefined;
}

/**
 * Specifies the mechanism for constructing "scope keys" based on HTTP request attributes. These
 * keys are matched against a set of :ref:`Key<envoy_v3_api_msg_config.route.v3.ScopedRouteConfiguration.Key>`
 * objects assembled from :ref:`ScopedRouteConfiguration<envoy_v3_api_msg_config.route.v3.ScopedRouteConfiguration>`
 * messages distributed via SRDS (the Scoped Route Discovery Service) or assigned statically via
 * :ref:`scoped_route_configurations_list<envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.ScopedRoutes.scoped_route_configurations_list>`.
 *
 * Upon receiving a request's headers, the Router will build a key using the algorithm specified
 * by this message. This key will be used to look up the routing table (i.e., the
 * :ref:`RouteConfiguration<envoy_v3_api_msg_config.route.v3.RouteConfiguration>`) to use for the request.
 */
export interface ScopedRoutes_ScopeKeyBuilder {
  $type: "envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder";
  /**
   * The final(built) scope key consists of the ordered union of these fragments, which are compared in order with the
   * fragments of a :ref:`ScopedRouteConfiguration<envoy_v3_api_msg_config.route.v3.ScopedRouteConfiguration>`.
   * A missing fragment during comparison will make the key invalid, i.e., the computed key doesn't match any key.
   */
  fragments?: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder[] | undefined;
}

/** Specifies the mechanism for constructing key fragments which are composed into scope keys. */
export interface ScopedRoutes_ScopeKeyBuilder_FragmentBuilder {
  $type: "envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder";
  type?:
    | //
    /** Specifies how a header field's value should be extracted. */
    {
      $case: "header_value_extractor";
      header_value_extractor: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor;
    }
    | undefined;
}

/**
 * Specifies how the value of a header should be extracted.
 * The following example maps the structure of a header to the fields in this message.
 *
 * .. code::
 *
 *              <0> <1>   <-- index
 *    X-Header: a=b;c=d
 *    |         || |
 *    |         || \----> <element_separator>
 *    |         ||
 *    |         |\----> <element.separator>
 *    |         |
 *    |         \----> <element.key>
 *    |
 *    \----> <name>
 *
 *    Each 'a=b' key-value pair constitutes an 'element' of the header field.
 */
export interface ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor {
  $type:
    "envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor";
  /**
   * The name of the header field to extract the value from.
   *
   * .. note::
   *
   *   If the header appears multiple times only the first value is used.
   */
  name?:
    | string
    | undefined;
  /**
   * The element separator (e.g., ';' separates 'a;b;c;d').
   * Default: empty string. This causes the entirety of the header field to be extracted.
   * If this field is set to an empty string and 'index' is used in the oneof below, 'index'
   * must be set to 0.
   */
  element_separator?: string | undefined;
  extract_type?:
    | //
    /**
     * Specifies the zero based index of the element to extract.
     * Note Envoy concatenates multiple values of the same header key into a comma separated
     * string, the splitting always happens after the concatenation.
     */
    { $case: "index"; index: number }
    | //
    /** Specifies the key value pair to extract the value from. */
    { $case: "element"; element: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement }
    | undefined;
}

/** Specifies a header field's key value pair to match on. */
export interface ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement {
  $type:
    "envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor.KvElement";
  /**
   * The separator between key and value (e.g., '=' separates 'k=v;...').
   * If an element is an empty string, the element is ignored.
   * If an element contains no separator, the whole element is parsed as key and the
   * fragment value is an empty string.
   * If there are multiple values for a matched key, the first value is returned.
   */
  separator?:
    | string
    | undefined;
  /** The key to match on. */
  key?: string | undefined;
}

export interface ScopedRds {
  $type: "envoy.extensions.filters.network.http_connection_manager.v3.ScopedRds";
  /** Configuration source specifier for scoped RDS. */
  scoped_rds_config_source?:
    | ConfigSource
    | undefined;
  /**
   * xdstp:// resource locator for scoped RDS collection.
   * [#not-implemented-hide:]
   */
  srds_resources_locator?: string | undefined;
}

/** [#next-free-field: 8] */
export interface HttpFilter {
  $type: "envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter";
  /** The name of the filter configuration. It also serves as a resource name in ExtensionConfigDS. */
  name?: string | undefined;
  config_type?:
    | //
    /**
     * Filter specific configuration which depends on the filter being instantiated. See the supported
     * filters for further documentation.
     *
     * To support configuring a :ref:`match tree <arch_overview_matching_api>`, use an
     * :ref:`ExtensionWithMatcher <envoy_v3_api_msg_extensions.common.matching.v3.ExtensionWithMatcher>`
     * with the desired HTTP filter.
     * [#extension-category: envoy.filters.http]
     */
    { $case: "typed_config"; typed_config: Any }
    | //
    /**
     * Configuration source specifier for an extension configuration discovery service.
     * In case of a failure and without the default configuration, the HTTP listener responds with code 500.
     * Extension configs delivered through this mechanism are not expected to require warming (see https://github.com/envoyproxy/envoy/issues/12061).
     *
     * To support configuring a :ref:`match tree <arch_overview_matching_api>`, use an
     * :ref:`ExtensionWithMatcher <envoy_v3_api_msg_extensions.common.matching.v3.ExtensionWithMatcher>`
     * with the desired HTTP filter. This works for both the default filter configuration as well
     * as for filters provided via the API.
     */
    { $case: "config_discovery"; config_discovery: ExtensionConfigSource }
    | undefined;
  /**
   * If true, clients that do not support this filter may ignore the
   * filter but otherwise accept the config.
   * Otherwise, clients that do not support this filter must reject the config.
   */
  is_optional?:
    | boolean
    | undefined;
  /**
   * If true, the filter is disabled by default and must be explicitly enabled by setting
   * per filter configuration in the route configuration.
   * See :ref:`route based filter chain <arch_overview_http_filters_route_based_filter_chain>`
   * for more details.
   *
   * Terminal filters (e.g. ``envoy.filters.http.router``) cannot be marked as disabled.
   */
  disabled?: boolean | undefined;
}

export interface RequestIDExtension {
  $type: "envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension";
  /** Request ID extension specific configuration. */
  typed_config?: Any | undefined;
}

/**
 * [#protodoc-title: Envoy Mobile HTTP connection manager]
 * HTTP connection manager for use in Envoy mobile.
 * [#extension: envoy.filters.network.envoy_mobile_http_connection_manager]
 */
export interface EnvoyMobileHttpConnectionManager {
  $type: "envoy.extensions.filters.network.http_connection_manager.v3.EnvoyMobileHttpConnectionManager";
  /**
   * The configuration for the underlying HttpConnectionManager which will be
   * instantiated for Envoy mobile.
   */
  config?: HttpConnectionManager | undefined;
}

function createBaseHttpConnectionManager(): HttpConnectionManager {
  return {
    $type: "envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager",
    route_specifier: undefined,
    strip_port_mode: undefined,
  };
}

export const HttpConnectionManager: MessageFns<
  HttpConnectionManager,
  "envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager"
> = {
  $type: "envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager" as const,

  encode(message: HttpConnectionManager, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.codec_type !== undefined && message.codec_type !== HttpConnectionManager_CodecType.AUTO) {
      writer.uint32(8).int32(httpConnectionManager_CodecTypeToNumber(message.codec_type));
    }
    if (message.stat_prefix !== undefined && message.stat_prefix !== "") {
      writer.uint32(18).string(message.stat_prefix);
    }
    switch (message.route_specifier?.$case) {
      case "rds":
        Rds.encode(message.route_specifier.rds, writer.uint32(26).fork()).join();
        break;
      case "route_config":
        RouteConfiguration.encode(message.route_specifier.route_config, writer.uint32(34).fork()).join();
        break;
      case "scoped_routes":
        ScopedRoutes.encode(message.route_specifier.scoped_routes, writer.uint32(250).fork()).join();
        break;
    }
    if (message.http_filters !== undefined && message.http_filters.length !== 0) {
      for (const v of message.http_filters) {
        HttpFilter.encode(v!, writer.uint32(42).fork()).join();
      }
    }
    if (message.add_user_agent !== undefined) {
      BoolValue.encode({ $type: "google.protobuf.BoolValue", value: message.add_user_agent! }, writer.uint32(50).fork())
        .join();
    }
    if (message.tracing !== undefined) {
      HttpConnectionManager_Tracing.encode(message.tracing, writer.uint32(58).fork()).join();
    }
    if (message.common_http_protocol_options !== undefined) {
      HttpProtocolOptions.encode(message.common_http_protocol_options, writer.uint32(282).fork()).join();
    }
    if (
      message.http1_safe_max_connection_duration !== undefined && message.http1_safe_max_connection_duration !== false
    ) {
      writer.uint32(464).bool(message.http1_safe_max_connection_duration);
    }
    if (message.http_protocol_options !== undefined) {
      Http1ProtocolOptions.encode(message.http_protocol_options, writer.uint32(66).fork()).join();
    }
    if (message.http2_protocol_options !== undefined) {
      Http2ProtocolOptions.encode(message.http2_protocol_options, writer.uint32(74).fork()).join();
    }
    if (message.http3_protocol_options !== undefined) {
      Http3ProtocolOptions.encode(message.http3_protocol_options, writer.uint32(354).fork()).join();
    }
    if (message.server_name !== undefined && message.server_name !== "") {
      writer.uint32(82).string(message.server_name);
    }
    if (
      message.server_header_transformation !== undefined &&
      message.server_header_transformation !== HttpConnectionManager_ServerHeaderTransformation.OVERWRITE
    ) {
      writer.uint32(272).int32(
        httpConnectionManager_ServerHeaderTransformationToNumber(message.server_header_transformation),
      );
    }
    if (message.scheme_header_transformation !== undefined) {
      SchemeHeaderTransformation.encode(message.scheme_header_transformation, writer.uint32(386).fork()).join();
    }
    if (message.max_request_headers_kb !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.max_request_headers_kb! },
        writer.uint32(234).fork(),
      ).join();
    }
    if (message.stream_idle_timeout !== undefined) {
      Duration.encode(message.stream_idle_timeout, writer.uint32(194).fork()).join();
    }
    if (message.request_timeout !== undefined) {
      Duration.encode(message.request_timeout, writer.uint32(226).fork()).join();
    }
    if (message.request_headers_timeout !== undefined) {
      Duration.encode(message.request_headers_timeout, writer.uint32(330).fork()).join();
    }
    if (message.drain_timeout !== undefined) {
      Duration.encode(message.drain_timeout, writer.uint32(98).fork()).join();
    }
    if (message.delayed_close_timeout !== undefined) {
      Duration.encode(message.delayed_close_timeout, writer.uint32(210).fork()).join();
    }
    if (message.access_log !== undefined && message.access_log.length !== 0) {
      for (const v of message.access_log) {
        AccessLog.encode(v!, writer.uint32(106).fork()).join();
      }
    }
    if (message.access_log_flush_interval !== undefined) {
      Duration.encode(message.access_log_flush_interval, writer.uint32(434).fork()).join();
    }
    if (message.flush_access_log_on_new_request !== undefined && message.flush_access_log_on_new_request !== false) {
      writer.uint32(440).bool(message.flush_access_log_on_new_request);
    }
    if (message.access_log_options !== undefined) {
      HttpConnectionManager_HcmAccessLogOptions.encode(message.access_log_options, writer.uint32(450).fork()).join();
    }
    if (message.use_remote_address !== undefined) {
      BoolValue.encode(
        { $type: "google.protobuf.BoolValue", value: message.use_remote_address! },
        writer.uint32(114).fork(),
      ).join();
    }
    if (message.xff_num_trusted_hops !== undefined && message.xff_num_trusted_hops !== 0) {
      writer.uint32(152).uint32(message.xff_num_trusted_hops);
    }
    if (
      message.original_ip_detection_extensions !== undefined && message.original_ip_detection_extensions.length !== 0
    ) {
      for (const v of message.original_ip_detection_extensions) {
        TypedExtensionConfig.encode(v!, writer.uint32(370).fork()).join();
      }
    }
    if (
      message.early_header_mutation_extensions !== undefined && message.early_header_mutation_extensions.length !== 0
    ) {
      for (const v of message.early_header_mutation_extensions) {
        TypedExtensionConfig.encode(v!, writer.uint32(418).fork()).join();
      }
    }
    if (message.internal_address_config !== undefined) {
      HttpConnectionManager_InternalAddressConfig.encode(message.internal_address_config, writer.uint32(202).fork())
        .join();
    }
    if (message.skip_xff_append !== undefined && message.skip_xff_append !== false) {
      writer.uint32(168).bool(message.skip_xff_append);
    }
    if (message.via !== undefined && message.via !== "") {
      writer.uint32(178).string(message.via);
    }
    if (message.generate_request_id !== undefined) {
      BoolValue.encode(
        { $type: "google.protobuf.BoolValue", value: message.generate_request_id! },
        writer.uint32(122).fork(),
      ).join();
    }
    if (message.preserve_external_request_id !== undefined && message.preserve_external_request_id !== false) {
      writer.uint32(256).bool(message.preserve_external_request_id);
    }
    if (
      message.always_set_request_id_in_response !== undefined && message.always_set_request_id_in_response !== false
    ) {
      writer.uint32(296).bool(message.always_set_request_id_in_response);
    }
    if (
      message.forward_client_cert_details !== undefined &&
      message.forward_client_cert_details !== HttpConnectionManager_ForwardClientCertDetails.SANITIZE
    ) {
      writer.uint32(128).int32(
        httpConnectionManager_ForwardClientCertDetailsToNumber(message.forward_client_cert_details),
      );
    }
    if (message.set_current_client_cert_details !== undefined) {
      HttpConnectionManager_SetCurrentClientCertDetails.encode(
        message.set_current_client_cert_details,
        writer.uint32(138).fork(),
      ).join();
    }
    if (message.proxy_100_continue !== undefined && message.proxy_100_continue !== false) {
      writer.uint32(144).bool(message.proxy_100_continue);
    }
    if (
      message.represent_ipv4_remote_address_as_ipv4_mapped_ipv6 !== undefined &&
      message.represent_ipv4_remote_address_as_ipv4_mapped_ipv6 !== false
    ) {
      writer.uint32(160).bool(message.represent_ipv4_remote_address_as_ipv4_mapped_ipv6);
    }
    if (message.upgrade_configs !== undefined && message.upgrade_configs.length !== 0) {
      for (const v of message.upgrade_configs) {
        HttpConnectionManager_UpgradeConfig.encode(v!, writer.uint32(186).fork()).join();
      }
    }
    if (message.normalize_path !== undefined) {
      BoolValue.encode(
        { $type: "google.protobuf.BoolValue", value: message.normalize_path! },
        writer.uint32(242).fork(),
      ).join();
    }
    if (message.merge_slashes !== undefined && message.merge_slashes !== false) {
      writer.uint32(264).bool(message.merge_slashes);
    }
    if (
      message.path_with_escaped_slashes_action !== undefined &&
      message.path_with_escaped_slashes_action !==
        HttpConnectionManager_PathWithEscapedSlashesAction.IMPLEMENTATION_SPECIFIC_DEFAULT
    ) {
      writer.uint32(360).int32(
        httpConnectionManager_PathWithEscapedSlashesActionToNumber(message.path_with_escaped_slashes_action),
      );
    }
    if (message.request_id_extension !== undefined) {
      RequestIDExtension.encode(message.request_id_extension, writer.uint32(290).fork()).join();
    }
    if (message.local_reply_config !== undefined) {
      LocalReplyConfig.encode(message.local_reply_config, writer.uint32(306).fork()).join();
    }
    if (message.strip_matching_host_port !== undefined && message.strip_matching_host_port !== false) {
      writer.uint32(312).bool(message.strip_matching_host_port);
    }
    switch (message.strip_port_mode?.$case) {
      case "strip_any_host_port":
        writer.uint32(336).bool(message.strip_port_mode.strip_any_host_port);
        break;
    }
    if (message.stream_error_on_invalid_http_message !== undefined) {
      BoolValue.encode(
        { $type: "google.protobuf.BoolValue", value: message.stream_error_on_invalid_http_message! },
        writer.uint32(322).fork(),
      ).join();
    }
    if (message.path_normalization_options !== undefined) {
      HttpConnectionManager_PathNormalizationOptions.encode(
        message.path_normalization_options,
        writer.uint32(346).fork(),
      ).join();
    }
    if (message.strip_trailing_host_dot !== undefined && message.strip_trailing_host_dot !== false) {
      writer.uint32(376).bool(message.strip_trailing_host_dot);
    }
    if (message.proxy_status_config !== undefined) {
      HttpConnectionManager_ProxyStatusConfig.encode(message.proxy_status_config, writer.uint32(394).fork()).join();
    }
    if (message.typed_header_validation_config !== undefined) {
      TypedExtensionConfig.encode(message.typed_header_validation_config, writer.uint32(402).fork()).join();
    }
    if (message.append_x_forwarded_port !== undefined && message.append_x_forwarded_port !== false) {
      writer.uint32(408).bool(message.append_x_forwarded_port);
    }
    if (message.append_local_overload !== undefined && message.append_local_overload !== false) {
      writer.uint32(456).bool(message.append_local_overload);
    }
    if (message.add_proxy_protocol_connection_state !== undefined) {
      BoolValue.encode(
        { $type: "google.protobuf.BoolValue", value: message.add_proxy_protocol_connection_state! },
        writer.uint32(426).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpConnectionManager {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpConnectionManager();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.codec_type = httpConnectionManager_CodecTypeFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stat_prefix = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.route_specifier = { $case: "rds", rds: Rds.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.route_specifier = {
            $case: "route_config",
            route_config: RouteConfiguration.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.route_specifier = {
            $case: "scoped_routes",
            scoped_routes: ScopedRoutes.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          if (message.http_filters === undefined) {
            message.http_filters = [];
          }
          const el = HttpFilter.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.http_filters!.push(el);
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.add_user_agent = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.tracing = HttpConnectionManager_Tracing.decode(reader, reader.uint32());
          continue;
        }
        case 35: {
          if (tag !== 282) {
            break;
          }

          message.common_http_protocol_options = HttpProtocolOptions.decode(reader, reader.uint32());
          continue;
        }
        case 58: {
          if (tag !== 464) {
            break;
          }

          message.http1_safe_max_connection_duration = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.http_protocol_options = Http1ProtocolOptions.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.http2_protocol_options = Http2ProtocolOptions.decode(reader, reader.uint32());
          continue;
        }
        case 44: {
          if (tag !== 354) {
            break;
          }

          message.http3_protocol_options = Http3ProtocolOptions.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.server_name = reader.string();
          continue;
        }
        case 34: {
          if (tag !== 272) {
            break;
          }

          message.server_header_transformation = httpConnectionManager_ServerHeaderTransformationFromJSON(
            reader.int32(),
          );
          continue;
        }
        case 48: {
          if (tag !== 386) {
            break;
          }

          message.scheme_header_transformation = SchemeHeaderTransformation.decode(reader, reader.uint32());
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.max_request_headers_kb = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.stream_idle_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.request_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 41: {
          if (tag !== 330) {
            break;
          }

          message.request_headers_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.drain_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.delayed_close_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          if (message.access_log === undefined) {
            message.access_log = [];
          }
          const el = AccessLog.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.access_log!.push(el);
          }
          continue;
        }
        case 54: {
          if (tag !== 434) {
            break;
          }

          message.access_log_flush_interval = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 55: {
          if (tag !== 440) {
            break;
          }

          message.flush_access_log_on_new_request = reader.bool();
          continue;
        }
        case 56: {
          if (tag !== 450) {
            break;
          }

          message.access_log_options = HttpConnectionManager_HcmAccessLogOptions.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.use_remote_address = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.xff_num_trusted_hops = reader.uint32();
          continue;
        }
        case 46: {
          if (tag !== 370) {
            break;
          }

          if (message.original_ip_detection_extensions === undefined) {
            message.original_ip_detection_extensions = [];
          }
          const el = TypedExtensionConfig.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.original_ip_detection_extensions!.push(el);
          }
          continue;
        }
        case 52: {
          if (tag !== 418) {
            break;
          }

          if (message.early_header_mutation_extensions === undefined) {
            message.early_header_mutation_extensions = [];
          }
          const el = TypedExtensionConfig.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.early_header_mutation_extensions!.push(el);
          }
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.internal_address_config = HttpConnectionManager_InternalAddressConfig.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.skip_xff_append = reader.bool();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.via = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.generate_request_id = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 32: {
          if (tag !== 256) {
            break;
          }

          message.preserve_external_request_id = reader.bool();
          continue;
        }
        case 37: {
          if (tag !== 296) {
            break;
          }

          message.always_set_request_id_in_response = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.forward_client_cert_details = httpConnectionManager_ForwardClientCertDetailsFromJSON(reader.int32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.set_current_client_cert_details = HttpConnectionManager_SetCurrentClientCertDetails.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.proxy_100_continue = reader.bool();
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.represent_ipv4_remote_address_as_ipv4_mapped_ipv6 = reader.bool();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          if (message.upgrade_configs === undefined) {
            message.upgrade_configs = [];
          }
          const el = HttpConnectionManager_UpgradeConfig.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.upgrade_configs!.push(el);
          }
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.normalize_path = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 33: {
          if (tag !== 264) {
            break;
          }

          message.merge_slashes = reader.bool();
          continue;
        }
        case 45: {
          if (tag !== 360) {
            break;
          }

          message.path_with_escaped_slashes_action = httpConnectionManager_PathWithEscapedSlashesActionFromJSON(
            reader.int32(),
          );
          continue;
        }
        case 36: {
          if (tag !== 290) {
            break;
          }

          message.request_id_extension = RequestIDExtension.decode(reader, reader.uint32());
          continue;
        }
        case 38: {
          if (tag !== 306) {
            break;
          }

          message.local_reply_config = LocalReplyConfig.decode(reader, reader.uint32());
          continue;
        }
        case 39: {
          if (tag !== 312) {
            break;
          }

          message.strip_matching_host_port = reader.bool();
          continue;
        }
        case 42: {
          if (tag !== 336) {
            break;
          }

          message.strip_port_mode = { $case: "strip_any_host_port", strip_any_host_port: reader.bool() };
          continue;
        }
        case 40: {
          if (tag !== 322) {
            break;
          }

          message.stream_error_on_invalid_http_message = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 43: {
          if (tag !== 346) {
            break;
          }

          message.path_normalization_options = HttpConnectionManager_PathNormalizationOptions.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 47: {
          if (tag !== 376) {
            break;
          }

          message.strip_trailing_host_dot = reader.bool();
          continue;
        }
        case 49: {
          if (tag !== 394) {
            break;
          }

          message.proxy_status_config = HttpConnectionManager_ProxyStatusConfig.decode(reader, reader.uint32());
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.typed_header_validation_config = TypedExtensionConfig.decode(reader, reader.uint32());
          continue;
        }
        case 51: {
          if (tag !== 408) {
            break;
          }

          message.append_x_forwarded_port = reader.bool();
          continue;
        }
        case 57: {
          if (tag !== 456) {
            break;
          }

          message.append_local_overload = reader.bool();
          continue;
        }
        case 53: {
          if (tag !== 426) {
            break;
          }

          message.add_proxy_protocol_connection_state = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpConnectionManager {
    return {
      $type: HttpConnectionManager.$type,
      codec_type: isSet(object.codec_type) ? httpConnectionManager_CodecTypeFromJSON(object.codec_type) : undefined,
      stat_prefix: isSet(object.stat_prefix) ? globalThis.String(object.stat_prefix) : undefined,
      route_specifier: isSet(object.rds)
        ? { $case: "rds", rds: Rds.fromJSON(object.rds) }
        : isSet(object.route_config)
        ? { $case: "route_config", route_config: RouteConfiguration.fromJSON(object.route_config) }
        : isSet(object.scoped_routes)
        ? { $case: "scoped_routes", scoped_routes: ScopedRoutes.fromJSON(object.scoped_routes) }
        : undefined,
      http_filters: globalThis.Array.isArray(object?.http_filters)
        ? object.http_filters.map((e: any) => HttpFilter.fromJSON(e))
        : undefined,
      add_user_agent: isSet(object.add_user_agent) ? Boolean(object.add_user_agent) : undefined,
      tracing: isSet(object.tracing) ? HttpConnectionManager_Tracing.fromJSON(object.tracing) : undefined,
      common_http_protocol_options: isSet(object.common_http_protocol_options)
        ? HttpProtocolOptions.fromJSON(object.common_http_protocol_options)
        : undefined,
      http1_safe_max_connection_duration: isSet(object.http1_safe_max_connection_duration)
        ? globalThis.Boolean(object.http1_safe_max_connection_duration)
        : undefined,
      http_protocol_options: isSet(object.http_protocol_options)
        ? Http1ProtocolOptions.fromJSON(object.http_protocol_options)
        : undefined,
      http2_protocol_options: isSet(object.http2_protocol_options)
        ? Http2ProtocolOptions.fromJSON(object.http2_protocol_options)
        : undefined,
      http3_protocol_options: isSet(object.http3_protocol_options)
        ? Http3ProtocolOptions.fromJSON(object.http3_protocol_options)
        : undefined,
      server_name: isSet(object.server_name) ? globalThis.String(object.server_name) : undefined,
      server_header_transformation: isSet(object.server_header_transformation)
        ? httpConnectionManager_ServerHeaderTransformationFromJSON(object.server_header_transformation)
        : undefined,
      scheme_header_transformation: isSet(object.scheme_header_transformation)
        ? SchemeHeaderTransformation.fromJSON(object.scheme_header_transformation)
        : undefined,
      max_request_headers_kb: isSet(object.max_request_headers_kb) ? Number(object.max_request_headers_kb) : undefined,
      stream_idle_timeout: isSet(object.stream_idle_timeout)
        ? Duration.fromJSON(object.stream_idle_timeout)
        : undefined,
      request_timeout: isSet(object.request_timeout) ? Duration.fromJSON(object.request_timeout) : undefined,
      request_headers_timeout: isSet(object.request_headers_timeout)
        ? Duration.fromJSON(object.request_headers_timeout)
        : undefined,
      drain_timeout: isSet(object.drain_timeout) ? Duration.fromJSON(object.drain_timeout) : undefined,
      delayed_close_timeout: isSet(object.delayed_close_timeout)
        ? Duration.fromJSON(object.delayed_close_timeout)
        : undefined,
      access_log: globalThis.Array.isArray(object?.access_log)
        ? object.access_log.map((e: any) => AccessLog.fromJSON(e))
        : undefined,
      access_log_flush_interval: isSet(object.access_log_flush_interval)
        ? Duration.fromJSON(object.access_log_flush_interval)
        : undefined,
      flush_access_log_on_new_request: isSet(object.flush_access_log_on_new_request)
        ? globalThis.Boolean(object.flush_access_log_on_new_request)
        : undefined,
      access_log_options: isSet(object.access_log_options)
        ? HttpConnectionManager_HcmAccessLogOptions.fromJSON(object.access_log_options)
        : undefined,
      use_remote_address: isSet(object.use_remote_address) ? Boolean(object.use_remote_address) : undefined,
      xff_num_trusted_hops: isSet(object.xff_num_trusted_hops)
        ? globalThis.Number(object.xff_num_trusted_hops)
        : undefined,
      original_ip_detection_extensions: globalThis.Array.isArray(object?.original_ip_detection_extensions)
        ? object.original_ip_detection_extensions.map((e: any) => TypedExtensionConfig.fromJSON(e))
        : undefined,
      early_header_mutation_extensions: globalThis.Array.isArray(object?.early_header_mutation_extensions)
        ? object.early_header_mutation_extensions.map((e: any) => TypedExtensionConfig.fromJSON(e))
        : undefined,
      internal_address_config: isSet(object.internal_address_config)
        ? HttpConnectionManager_InternalAddressConfig.fromJSON(object.internal_address_config)
        : undefined,
      skip_xff_append: isSet(object.skip_xff_append) ? globalThis.Boolean(object.skip_xff_append) : undefined,
      via: isSet(object.via) ? globalThis.String(object.via) : undefined,
      generate_request_id: isSet(object.generate_request_id) ? Boolean(object.generate_request_id) : undefined,
      preserve_external_request_id: isSet(object.preserve_external_request_id)
        ? globalThis.Boolean(object.preserve_external_request_id)
        : undefined,
      always_set_request_id_in_response: isSet(object.always_set_request_id_in_response)
        ? globalThis.Boolean(object.always_set_request_id_in_response)
        : undefined,
      forward_client_cert_details: isSet(object.forward_client_cert_details)
        ? httpConnectionManager_ForwardClientCertDetailsFromJSON(object.forward_client_cert_details)
        : undefined,
      set_current_client_cert_details: isSet(object.set_current_client_cert_details)
        ? HttpConnectionManager_SetCurrentClientCertDetails.fromJSON(object.set_current_client_cert_details)
        : undefined,
      proxy_100_continue: isSet(object.proxy_100_continue) ? globalThis.Boolean(object.proxy_100_continue) : undefined,
      represent_ipv4_remote_address_as_ipv4_mapped_ipv6: isSet(object.represent_ipv4_remote_address_as_ipv4_mapped_ipv6)
        ? globalThis.Boolean(object.represent_ipv4_remote_address_as_ipv4_mapped_ipv6)
        : undefined,
      upgrade_configs: globalThis.Array.isArray(object?.upgrade_configs)
        ? object.upgrade_configs.map((e: any) => HttpConnectionManager_UpgradeConfig.fromJSON(e))
        : undefined,
      normalize_path: isSet(object.normalize_path) ? Boolean(object.normalize_path) : undefined,
      merge_slashes: isSet(object.merge_slashes) ? globalThis.Boolean(object.merge_slashes) : undefined,
      path_with_escaped_slashes_action: isSet(object.path_with_escaped_slashes_action)
        ? httpConnectionManager_PathWithEscapedSlashesActionFromJSON(object.path_with_escaped_slashes_action)
        : undefined,
      request_id_extension: isSet(object.request_id_extension)
        ? RequestIDExtension.fromJSON(object.request_id_extension)
        : undefined,
      local_reply_config: isSet(object.local_reply_config)
        ? LocalReplyConfig.fromJSON(object.local_reply_config)
        : undefined,
      strip_matching_host_port: isSet(object.strip_matching_host_port)
        ? globalThis.Boolean(object.strip_matching_host_port)
        : undefined,
      strip_port_mode: isSet(object.strip_any_host_port)
        ? { $case: "strip_any_host_port", strip_any_host_port: globalThis.Boolean(object.strip_any_host_port) }
        : undefined,
      stream_error_on_invalid_http_message: isSet(object.stream_error_on_invalid_http_message)
        ? Boolean(object.stream_error_on_invalid_http_message)
        : undefined,
      path_normalization_options: isSet(object.path_normalization_options)
        ? HttpConnectionManager_PathNormalizationOptions.fromJSON(object.path_normalization_options)
        : undefined,
      strip_trailing_host_dot: isSet(object.strip_trailing_host_dot)
        ? globalThis.Boolean(object.strip_trailing_host_dot)
        : undefined,
      proxy_status_config: isSet(object.proxy_status_config)
        ? HttpConnectionManager_ProxyStatusConfig.fromJSON(object.proxy_status_config)
        : undefined,
      typed_header_validation_config: isSet(object.typed_header_validation_config)
        ? TypedExtensionConfig.fromJSON(object.typed_header_validation_config)
        : undefined,
      append_x_forwarded_port: isSet(object.append_x_forwarded_port)
        ? globalThis.Boolean(object.append_x_forwarded_port)
        : undefined,
      append_local_overload: isSet(object.append_local_overload)
        ? globalThis.Boolean(object.append_local_overload)
        : undefined,
      add_proxy_protocol_connection_state: isSet(object.add_proxy_protocol_connection_state)
        ? Boolean(object.add_proxy_protocol_connection_state)
        : undefined,
    };
  },

  toJSON(message: HttpConnectionManager): unknown {
    const obj: any = {};
    if (message.codec_type !== undefined) {
      obj.codec_type = httpConnectionManager_CodecTypeToJSON(message.codec_type);
    }
    if (message.stat_prefix !== undefined) {
      obj.stat_prefix = message.stat_prefix;
    }
    if (message.route_specifier?.$case === "rds") {
      obj.rds = Rds.toJSON(message.route_specifier.rds);
    }
    if (message.route_specifier?.$case === "route_config") {
      obj.route_config = RouteConfiguration.toJSON(message.route_specifier.route_config);
    }
    if (message.route_specifier?.$case === "scoped_routes") {
      obj.scoped_routes = ScopedRoutes.toJSON(message.route_specifier.scoped_routes);
    }
    if (message.http_filters?.length) {
      obj.http_filters = message.http_filters.map((e) => HttpFilter.toJSON(e));
    }
    if (message.add_user_agent !== undefined) {
      obj.add_user_agent = message.add_user_agent;
    }
    if (message.tracing !== undefined) {
      obj.tracing = HttpConnectionManager_Tracing.toJSON(message.tracing);
    }
    if (message.common_http_protocol_options !== undefined) {
      obj.common_http_protocol_options = HttpProtocolOptions.toJSON(message.common_http_protocol_options);
    }
    if (message.http1_safe_max_connection_duration !== undefined) {
      obj.http1_safe_max_connection_duration = message.http1_safe_max_connection_duration;
    }
    if (message.http_protocol_options !== undefined) {
      obj.http_protocol_options = Http1ProtocolOptions.toJSON(message.http_protocol_options);
    }
    if (message.http2_protocol_options !== undefined) {
      obj.http2_protocol_options = Http2ProtocolOptions.toJSON(message.http2_protocol_options);
    }
    if (message.http3_protocol_options !== undefined) {
      obj.http3_protocol_options = Http3ProtocolOptions.toJSON(message.http3_protocol_options);
    }
    if (message.server_name !== undefined) {
      obj.server_name = message.server_name;
    }
    if (message.server_header_transformation !== undefined) {
      obj.server_header_transformation = httpConnectionManager_ServerHeaderTransformationToJSON(
        message.server_header_transformation,
      );
    }
    if (message.scheme_header_transformation !== undefined) {
      obj.scheme_header_transformation = SchemeHeaderTransformation.toJSON(message.scheme_header_transformation);
    }
    if (message.max_request_headers_kb !== undefined) {
      obj.max_request_headers_kb = message.max_request_headers_kb;
    }
    if (message.stream_idle_timeout !== undefined) {
      obj.stream_idle_timeout = Duration.toJSON(message.stream_idle_timeout);
    }
    if (message.request_timeout !== undefined) {
      obj.request_timeout = Duration.toJSON(message.request_timeout);
    }
    if (message.request_headers_timeout !== undefined) {
      obj.request_headers_timeout = Duration.toJSON(message.request_headers_timeout);
    }
    if (message.drain_timeout !== undefined) {
      obj.drain_timeout = Duration.toJSON(message.drain_timeout);
    }
    if (message.delayed_close_timeout !== undefined) {
      obj.delayed_close_timeout = Duration.toJSON(message.delayed_close_timeout);
    }
    if (message.access_log?.length) {
      obj.access_log = message.access_log.map((e) => AccessLog.toJSON(e));
    }
    if (message.access_log_flush_interval !== undefined) {
      obj.access_log_flush_interval = Duration.toJSON(message.access_log_flush_interval);
    }
    if (message.flush_access_log_on_new_request !== undefined) {
      obj.flush_access_log_on_new_request = message.flush_access_log_on_new_request;
    }
    if (message.access_log_options !== undefined) {
      obj.access_log_options = HttpConnectionManager_HcmAccessLogOptions.toJSON(message.access_log_options);
    }
    if (message.use_remote_address !== undefined) {
      obj.use_remote_address = message.use_remote_address;
    }
    if (message.xff_num_trusted_hops !== undefined) {
      obj.xff_num_trusted_hops = Math.round(message.xff_num_trusted_hops);
    }
    if (message.original_ip_detection_extensions?.length) {
      obj.original_ip_detection_extensions = message.original_ip_detection_extensions.map((e) =>
        TypedExtensionConfig.toJSON(e)
      );
    }
    if (message.early_header_mutation_extensions?.length) {
      obj.early_header_mutation_extensions = message.early_header_mutation_extensions.map((e) =>
        TypedExtensionConfig.toJSON(e)
      );
    }
    if (message.internal_address_config !== undefined) {
      obj.internal_address_config = HttpConnectionManager_InternalAddressConfig.toJSON(message.internal_address_config);
    }
    if (message.skip_xff_append !== undefined) {
      obj.skip_xff_append = message.skip_xff_append;
    }
    if (message.via !== undefined) {
      obj.via = message.via;
    }
    if (message.generate_request_id !== undefined) {
      obj.generate_request_id = message.generate_request_id;
    }
    if (message.preserve_external_request_id !== undefined) {
      obj.preserve_external_request_id = message.preserve_external_request_id;
    }
    if (message.always_set_request_id_in_response !== undefined) {
      obj.always_set_request_id_in_response = message.always_set_request_id_in_response;
    }
    if (message.forward_client_cert_details !== undefined) {
      obj.forward_client_cert_details = httpConnectionManager_ForwardClientCertDetailsToJSON(
        message.forward_client_cert_details,
      );
    }
    if (message.set_current_client_cert_details !== undefined) {
      obj.set_current_client_cert_details = HttpConnectionManager_SetCurrentClientCertDetails.toJSON(
        message.set_current_client_cert_details,
      );
    }
    if (message.proxy_100_continue !== undefined) {
      obj.proxy_100_continue = message.proxy_100_continue;
    }
    if (message.represent_ipv4_remote_address_as_ipv4_mapped_ipv6 !== undefined) {
      obj.represent_ipv4_remote_address_as_ipv4_mapped_ipv6 = message.represent_ipv4_remote_address_as_ipv4_mapped_ipv6;
    }
    if (message.upgrade_configs?.length) {
      obj.upgrade_configs = message.upgrade_configs.map((e) => HttpConnectionManager_UpgradeConfig.toJSON(e));
    }
    if (message.normalize_path !== undefined) {
      obj.normalize_path = message.normalize_path;
    }
    if (message.merge_slashes !== undefined) {
      obj.merge_slashes = message.merge_slashes;
    }
    if (message.path_with_escaped_slashes_action !== undefined) {
      obj.path_with_escaped_slashes_action = httpConnectionManager_PathWithEscapedSlashesActionToJSON(
        message.path_with_escaped_slashes_action,
      );
    }
    if (message.request_id_extension !== undefined) {
      obj.request_id_extension = RequestIDExtension.toJSON(message.request_id_extension);
    }
    if (message.local_reply_config !== undefined) {
      obj.local_reply_config = LocalReplyConfig.toJSON(message.local_reply_config);
    }
    if (message.strip_matching_host_port !== undefined) {
      obj.strip_matching_host_port = message.strip_matching_host_port;
    }
    if (message.strip_port_mode?.$case === "strip_any_host_port") {
      obj.strip_any_host_port = message.strip_port_mode.strip_any_host_port;
    }
    if (message.stream_error_on_invalid_http_message !== undefined) {
      obj.stream_error_on_invalid_http_message = message.stream_error_on_invalid_http_message;
    }
    if (message.path_normalization_options !== undefined) {
      obj.path_normalization_options = HttpConnectionManager_PathNormalizationOptions.toJSON(
        message.path_normalization_options,
      );
    }
    if (message.strip_trailing_host_dot !== undefined) {
      obj.strip_trailing_host_dot = message.strip_trailing_host_dot;
    }
    if (message.proxy_status_config !== undefined) {
      obj.proxy_status_config = HttpConnectionManager_ProxyStatusConfig.toJSON(message.proxy_status_config);
    }
    if (message.typed_header_validation_config !== undefined) {
      obj.typed_header_validation_config = TypedExtensionConfig.toJSON(message.typed_header_validation_config);
    }
    if (message.append_x_forwarded_port !== undefined) {
      obj.append_x_forwarded_port = message.append_x_forwarded_port;
    }
    if (message.append_local_overload !== undefined) {
      obj.append_local_overload = message.append_local_overload;
    }
    if (message.add_proxy_protocol_connection_state !== undefined) {
      obj.add_proxy_protocol_connection_state = message.add_proxy_protocol_connection_state;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpConnectionManager>, I>>(base?: I): HttpConnectionManager {
    return HttpConnectionManager.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpConnectionManager>, I>>(object: I): HttpConnectionManager {
    const message = createBaseHttpConnectionManager();
    message.codec_type = object.codec_type ?? undefined;
    message.stat_prefix = object.stat_prefix ?? undefined;
    if (
      object.route_specifier?.$case === "rds" &&
      object.route_specifier?.rds !== undefined &&
      object.route_specifier?.rds !== null
    ) {
      message.route_specifier = { $case: "rds", rds: Rds.fromPartial(object.route_specifier.rds) };
    }
    if (
      object.route_specifier?.$case === "route_config" &&
      object.route_specifier?.route_config !== undefined &&
      object.route_specifier?.route_config !== null
    ) {
      message.route_specifier = {
        $case: "route_config",
        route_config: RouteConfiguration.fromPartial(object.route_specifier.route_config),
      };
    }
    if (
      object.route_specifier?.$case === "scoped_routes" &&
      object.route_specifier?.scoped_routes !== undefined &&
      object.route_specifier?.scoped_routes !== null
    ) {
      message.route_specifier = {
        $case: "scoped_routes",
        scoped_routes: ScopedRoutes.fromPartial(object.route_specifier.scoped_routes),
      };
    }
    message.http_filters = object.http_filters?.map((e) => HttpFilter.fromPartial(e)) || undefined;
    message.add_user_agent = object.add_user_agent ?? undefined;
    message.tracing = (object.tracing !== undefined && object.tracing !== null)
      ? HttpConnectionManager_Tracing.fromPartial(object.tracing)
      : undefined;
    message.common_http_protocol_options =
      (object.common_http_protocol_options !== undefined && object.common_http_protocol_options !== null)
        ? HttpProtocolOptions.fromPartial(object.common_http_protocol_options)
        : undefined;
    message.http1_safe_max_connection_duration = object.http1_safe_max_connection_duration ?? undefined;
    message.http_protocol_options =
      (object.http_protocol_options !== undefined && object.http_protocol_options !== null)
        ? Http1ProtocolOptions.fromPartial(object.http_protocol_options)
        : undefined;
    message.http2_protocol_options =
      (object.http2_protocol_options !== undefined && object.http2_protocol_options !== null)
        ? Http2ProtocolOptions.fromPartial(object.http2_protocol_options)
        : undefined;
    message.http3_protocol_options =
      (object.http3_protocol_options !== undefined && object.http3_protocol_options !== null)
        ? Http3ProtocolOptions.fromPartial(object.http3_protocol_options)
        : undefined;
    message.server_name = object.server_name ?? undefined;
    message.server_header_transformation = object.server_header_transformation ?? undefined;
    message.scheme_header_transformation =
      (object.scheme_header_transformation !== undefined && object.scheme_header_transformation !== null)
        ? SchemeHeaderTransformation.fromPartial(object.scheme_header_transformation)
        : undefined;
    message.max_request_headers_kb = object.max_request_headers_kb ?? undefined;
    message.stream_idle_timeout = (object.stream_idle_timeout !== undefined && object.stream_idle_timeout !== null)
      ? Duration.fromPartial(object.stream_idle_timeout)
      : undefined;
    message.request_timeout = (object.request_timeout !== undefined && object.request_timeout !== null)
      ? Duration.fromPartial(object.request_timeout)
      : undefined;
    message.request_headers_timeout =
      (object.request_headers_timeout !== undefined && object.request_headers_timeout !== null)
        ? Duration.fromPartial(object.request_headers_timeout)
        : undefined;
    message.drain_timeout = (object.drain_timeout !== undefined && object.drain_timeout !== null)
      ? Duration.fromPartial(object.drain_timeout)
      : undefined;
    message.delayed_close_timeout =
      (object.delayed_close_timeout !== undefined && object.delayed_close_timeout !== null)
        ? Duration.fromPartial(object.delayed_close_timeout)
        : undefined;
    message.access_log = object.access_log?.map((e) => AccessLog.fromPartial(e)) || undefined;
    message.access_log_flush_interval =
      (object.access_log_flush_interval !== undefined && object.access_log_flush_interval !== null)
        ? Duration.fromPartial(object.access_log_flush_interval)
        : undefined;
    message.flush_access_log_on_new_request = object.flush_access_log_on_new_request ?? undefined;
    message.access_log_options = (object.access_log_options !== undefined && object.access_log_options !== null)
      ? HttpConnectionManager_HcmAccessLogOptions.fromPartial(object.access_log_options)
      : undefined;
    message.use_remote_address = object.use_remote_address ?? undefined;
    message.xff_num_trusted_hops = object.xff_num_trusted_hops ?? undefined;
    message.original_ip_detection_extensions =
      object.original_ip_detection_extensions?.map((e) => TypedExtensionConfig.fromPartial(e)) || undefined;
    message.early_header_mutation_extensions =
      object.early_header_mutation_extensions?.map((e) => TypedExtensionConfig.fromPartial(e)) || undefined;
    message.internal_address_config =
      (object.internal_address_config !== undefined && object.internal_address_config !== null)
        ? HttpConnectionManager_InternalAddressConfig.fromPartial(object.internal_address_config)
        : undefined;
    message.skip_xff_append = object.skip_xff_append ?? undefined;
    message.via = object.via ?? undefined;
    message.generate_request_id = object.generate_request_id ?? undefined;
    message.preserve_external_request_id = object.preserve_external_request_id ?? undefined;
    message.always_set_request_id_in_response = object.always_set_request_id_in_response ?? undefined;
    message.forward_client_cert_details = object.forward_client_cert_details ?? undefined;
    message.set_current_client_cert_details =
      (object.set_current_client_cert_details !== undefined && object.set_current_client_cert_details !== null)
        ? HttpConnectionManager_SetCurrentClientCertDetails.fromPartial(object.set_current_client_cert_details)
        : undefined;
    message.proxy_100_continue = object.proxy_100_continue ?? undefined;
    message.represent_ipv4_remote_address_as_ipv4_mapped_ipv6 =
      object.represent_ipv4_remote_address_as_ipv4_mapped_ipv6 ?? undefined;
    message.upgrade_configs = object.upgrade_configs?.map((e) => HttpConnectionManager_UpgradeConfig.fromPartial(e)) ||
      undefined;
    message.normalize_path = object.normalize_path ?? undefined;
    message.merge_slashes = object.merge_slashes ?? undefined;
    message.path_with_escaped_slashes_action = object.path_with_escaped_slashes_action ?? undefined;
    message.request_id_extension = (object.request_id_extension !== undefined && object.request_id_extension !== null)
      ? RequestIDExtension.fromPartial(object.request_id_extension)
      : undefined;
    message.local_reply_config = (object.local_reply_config !== undefined && object.local_reply_config !== null)
      ? LocalReplyConfig.fromPartial(object.local_reply_config)
      : undefined;
    message.strip_matching_host_port = object.strip_matching_host_port ?? undefined;
    if (
      object.strip_port_mode?.$case === "strip_any_host_port" &&
      object.strip_port_mode?.strip_any_host_port !== undefined &&
      object.strip_port_mode?.strip_any_host_port !== null
    ) {
      message.strip_port_mode = {
        $case: "strip_any_host_port",
        strip_any_host_port: object.strip_port_mode.strip_any_host_port,
      };
    }
    message.stream_error_on_invalid_http_message = object.stream_error_on_invalid_http_message ?? undefined;
    message.path_normalization_options =
      (object.path_normalization_options !== undefined && object.path_normalization_options !== null)
        ? HttpConnectionManager_PathNormalizationOptions.fromPartial(object.path_normalization_options)
        : undefined;
    message.strip_trailing_host_dot = object.strip_trailing_host_dot ?? undefined;
    message.proxy_status_config = (object.proxy_status_config !== undefined && object.proxy_status_config !== null)
      ? HttpConnectionManager_ProxyStatusConfig.fromPartial(object.proxy_status_config)
      : undefined;
    message.typed_header_validation_config =
      (object.typed_header_validation_config !== undefined && object.typed_header_validation_config !== null)
        ? TypedExtensionConfig.fromPartial(object.typed_header_validation_config)
        : undefined;
    message.append_x_forwarded_port = object.append_x_forwarded_port ?? undefined;
    message.append_local_overload = object.append_local_overload ?? undefined;
    message.add_proxy_protocol_connection_state = object.add_proxy_protocol_connection_state ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(HttpConnectionManager.$type, HttpConnectionManager);

function createBaseHttpConnectionManager_Tracing(): HttpConnectionManager_Tracing {
  return { $type: "envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing" };
}

export const HttpConnectionManager_Tracing: MessageFns<
  HttpConnectionManager_Tracing,
  "envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing"
> = {
  $type: "envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing" as const,

  encode(message: HttpConnectionManager_Tracing, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.client_sampling !== undefined) {
      Percent.encode(message.client_sampling, writer.uint32(26).fork()).join();
    }
    if (message.random_sampling !== undefined) {
      Percent.encode(message.random_sampling, writer.uint32(34).fork()).join();
    }
    if (message.overall_sampling !== undefined) {
      Percent.encode(message.overall_sampling, writer.uint32(42).fork()).join();
    }
    if (message.verbose !== undefined && message.verbose !== false) {
      writer.uint32(48).bool(message.verbose);
    }
    if (message.max_path_tag_length !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.max_path_tag_length! },
        writer.uint32(58).fork(),
      ).join();
    }
    if (message.custom_tags !== undefined && message.custom_tags.length !== 0) {
      for (const v of message.custom_tags) {
        CustomTag.encode(v!, writer.uint32(66).fork()).join();
      }
    }
    if (message.provider !== undefined) {
      Tracing_Http.encode(message.provider, writer.uint32(74).fork()).join();
    }
    if (message.spawn_upstream_span !== undefined) {
      BoolValue.encode(
        { $type: "google.protobuf.BoolValue", value: message.spawn_upstream_span! },
        writer.uint32(82).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpConnectionManager_Tracing {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpConnectionManager_Tracing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.client_sampling = Percent.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.random_sampling = Percent.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.overall_sampling = Percent.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.verbose = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.max_path_tag_length = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          if (message.custom_tags === undefined) {
            message.custom_tags = [];
          }
          const el = CustomTag.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.custom_tags!.push(el);
          }
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.provider = Tracing_Http.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.spawn_upstream_span = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpConnectionManager_Tracing {
    return {
      $type: HttpConnectionManager_Tracing.$type,
      client_sampling: isSet(object.client_sampling) ? Percent.fromJSON(object.client_sampling) : undefined,
      random_sampling: isSet(object.random_sampling) ? Percent.fromJSON(object.random_sampling) : undefined,
      overall_sampling: isSet(object.overall_sampling) ? Percent.fromJSON(object.overall_sampling) : undefined,
      verbose: isSet(object.verbose) ? globalThis.Boolean(object.verbose) : undefined,
      max_path_tag_length: isSet(object.max_path_tag_length) ? Number(object.max_path_tag_length) : undefined,
      custom_tags: globalThis.Array.isArray(object?.custom_tags)
        ? object.custom_tags.map((e: any) => CustomTag.fromJSON(e))
        : undefined,
      provider: isSet(object.provider) ? Tracing_Http.fromJSON(object.provider) : undefined,
      spawn_upstream_span: isSet(object.spawn_upstream_span) ? Boolean(object.spawn_upstream_span) : undefined,
    };
  },

  toJSON(message: HttpConnectionManager_Tracing): unknown {
    const obj: any = {};
    if (message.client_sampling !== undefined) {
      obj.client_sampling = Percent.toJSON(message.client_sampling);
    }
    if (message.random_sampling !== undefined) {
      obj.random_sampling = Percent.toJSON(message.random_sampling);
    }
    if (message.overall_sampling !== undefined) {
      obj.overall_sampling = Percent.toJSON(message.overall_sampling);
    }
    if (message.verbose !== undefined) {
      obj.verbose = message.verbose;
    }
    if (message.max_path_tag_length !== undefined) {
      obj.max_path_tag_length = message.max_path_tag_length;
    }
    if (message.custom_tags?.length) {
      obj.custom_tags = message.custom_tags.map((e) => CustomTag.toJSON(e));
    }
    if (message.provider !== undefined) {
      obj.provider = Tracing_Http.toJSON(message.provider);
    }
    if (message.spawn_upstream_span !== undefined) {
      obj.spawn_upstream_span = message.spawn_upstream_span;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpConnectionManager_Tracing>, I>>(base?: I): HttpConnectionManager_Tracing {
    return HttpConnectionManager_Tracing.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpConnectionManager_Tracing>, I>>(
    object: I,
  ): HttpConnectionManager_Tracing {
    const message = createBaseHttpConnectionManager_Tracing();
    message.client_sampling = (object.client_sampling !== undefined && object.client_sampling !== null)
      ? Percent.fromPartial(object.client_sampling)
      : undefined;
    message.random_sampling = (object.random_sampling !== undefined && object.random_sampling !== null)
      ? Percent.fromPartial(object.random_sampling)
      : undefined;
    message.overall_sampling = (object.overall_sampling !== undefined && object.overall_sampling !== null)
      ? Percent.fromPartial(object.overall_sampling)
      : undefined;
    message.verbose = object.verbose ?? undefined;
    message.max_path_tag_length = object.max_path_tag_length ?? undefined;
    message.custom_tags = object.custom_tags?.map((e) => CustomTag.fromPartial(e)) || undefined;
    message.provider = (object.provider !== undefined && object.provider !== null)
      ? Tracing_Http.fromPartial(object.provider)
      : undefined;
    message.spawn_upstream_span = object.spawn_upstream_span ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(HttpConnectionManager_Tracing.$type, HttpConnectionManager_Tracing);

function createBaseHttpConnectionManager_InternalAddressConfig(): HttpConnectionManager_InternalAddressConfig {
  return {
    $type: "envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig",
  };
}

export const HttpConnectionManager_InternalAddressConfig: MessageFns<
  HttpConnectionManager_InternalAddressConfig,
  "envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig"
> = {
  $type:
    "envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig" as const,

  encode(
    message: HttpConnectionManager_InternalAddressConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.unix_sockets !== undefined && message.unix_sockets !== false) {
      writer.uint32(8).bool(message.unix_sockets);
    }
    if (message.cidr_ranges !== undefined && message.cidr_ranges.length !== 0) {
      for (const v of message.cidr_ranges) {
        CidrRange.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpConnectionManager_InternalAddressConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpConnectionManager_InternalAddressConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.unix_sockets = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.cidr_ranges === undefined) {
            message.cidr_ranges = [];
          }
          const el = CidrRange.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.cidr_ranges!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpConnectionManager_InternalAddressConfig {
    return {
      $type: HttpConnectionManager_InternalAddressConfig.$type,
      unix_sockets: isSet(object.unix_sockets) ? globalThis.Boolean(object.unix_sockets) : undefined,
      cidr_ranges: globalThis.Array.isArray(object?.cidr_ranges)
        ? object.cidr_ranges.map((e: any) => CidrRange.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: HttpConnectionManager_InternalAddressConfig): unknown {
    const obj: any = {};
    if (message.unix_sockets !== undefined) {
      obj.unix_sockets = message.unix_sockets;
    }
    if (message.cidr_ranges?.length) {
      obj.cidr_ranges = message.cidr_ranges.map((e) => CidrRange.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpConnectionManager_InternalAddressConfig>, I>>(
    base?: I,
  ): HttpConnectionManager_InternalAddressConfig {
    return HttpConnectionManager_InternalAddressConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpConnectionManager_InternalAddressConfig>, I>>(
    object: I,
  ): HttpConnectionManager_InternalAddressConfig {
    const message = createBaseHttpConnectionManager_InternalAddressConfig();
    message.unix_sockets = object.unix_sockets ?? undefined;
    message.cidr_ranges = object.cidr_ranges?.map((e) => CidrRange.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(HttpConnectionManager_InternalAddressConfig.$type, HttpConnectionManager_InternalAddressConfig);

function createBaseHttpConnectionManager_SetCurrentClientCertDetails(): HttpConnectionManager_SetCurrentClientCertDetails {
  return {
    $type:
      "envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails",
  };
}

export const HttpConnectionManager_SetCurrentClientCertDetails: MessageFns<
  HttpConnectionManager_SetCurrentClientCertDetails,
  "envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails"
> = {
  $type:
    "envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails" as const,

  encode(
    message: HttpConnectionManager_SetCurrentClientCertDetails,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.subject !== undefined) {
      BoolValue.encode({ $type: "google.protobuf.BoolValue", value: message.subject! }, writer.uint32(10).fork())
        .join();
    }
    if (message.cert !== undefined && message.cert !== false) {
      writer.uint32(24).bool(message.cert);
    }
    if (message.chain !== undefined && message.chain !== false) {
      writer.uint32(48).bool(message.chain);
    }
    if (message.dns !== undefined && message.dns !== false) {
      writer.uint32(32).bool(message.dns);
    }
    if (message.uri !== undefined && message.uri !== false) {
      writer.uint32(40).bool(message.uri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpConnectionManager_SetCurrentClientCertDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpConnectionManager_SetCurrentClientCertDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subject = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.cert = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.chain = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.dns = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.uri = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpConnectionManager_SetCurrentClientCertDetails {
    return {
      $type: HttpConnectionManager_SetCurrentClientCertDetails.$type,
      subject: isSet(object.subject) ? Boolean(object.subject) : undefined,
      cert: isSet(object.cert) ? globalThis.Boolean(object.cert) : undefined,
      chain: isSet(object.chain) ? globalThis.Boolean(object.chain) : undefined,
      dns: isSet(object.dns) ? globalThis.Boolean(object.dns) : undefined,
      uri: isSet(object.uri) ? globalThis.Boolean(object.uri) : undefined,
    };
  },

  toJSON(message: HttpConnectionManager_SetCurrentClientCertDetails): unknown {
    const obj: any = {};
    if (message.subject !== undefined) {
      obj.subject = message.subject;
    }
    if (message.cert !== undefined) {
      obj.cert = message.cert;
    }
    if (message.chain !== undefined) {
      obj.chain = message.chain;
    }
    if (message.dns !== undefined) {
      obj.dns = message.dns;
    }
    if (message.uri !== undefined) {
      obj.uri = message.uri;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpConnectionManager_SetCurrentClientCertDetails>, I>>(
    base?: I,
  ): HttpConnectionManager_SetCurrentClientCertDetails {
    return HttpConnectionManager_SetCurrentClientCertDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpConnectionManager_SetCurrentClientCertDetails>, I>>(
    object: I,
  ): HttpConnectionManager_SetCurrentClientCertDetails {
    const message = createBaseHttpConnectionManager_SetCurrentClientCertDetails();
    message.subject = object.subject ?? undefined;
    message.cert = object.cert ?? undefined;
    message.chain = object.chain ?? undefined;
    message.dns = object.dns ?? undefined;
    message.uri = object.uri ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(
  HttpConnectionManager_SetCurrentClientCertDetails.$type,
  HttpConnectionManager_SetCurrentClientCertDetails,
);

function createBaseHttpConnectionManager_UpgradeConfig(): HttpConnectionManager_UpgradeConfig {
  return { $type: "envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig" };
}

export const HttpConnectionManager_UpgradeConfig: MessageFns<
  HttpConnectionManager_UpgradeConfig,
  "envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig"
> = {
  $type: "envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig" as const,

  encode(message: HttpConnectionManager_UpgradeConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.upgrade_type !== undefined && message.upgrade_type !== "") {
      writer.uint32(10).string(message.upgrade_type);
    }
    if (message.filters !== undefined && message.filters.length !== 0) {
      for (const v of message.filters) {
        HttpFilter.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.enabled !== undefined) {
      BoolValue.encode({ $type: "google.protobuf.BoolValue", value: message.enabled! }, writer.uint32(26).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpConnectionManager_UpgradeConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpConnectionManager_UpgradeConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.upgrade_type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.filters === undefined) {
            message.filters = [];
          }
          const el = HttpFilter.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.filters!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.enabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpConnectionManager_UpgradeConfig {
    return {
      $type: HttpConnectionManager_UpgradeConfig.$type,
      upgrade_type: isSet(object.upgrade_type) ? globalThis.String(object.upgrade_type) : undefined,
      filters: globalThis.Array.isArray(object?.filters)
        ? object.filters.map((e: any) => HttpFilter.fromJSON(e))
        : undefined,
      enabled: isSet(object.enabled) ? Boolean(object.enabled) : undefined,
    };
  },

  toJSON(message: HttpConnectionManager_UpgradeConfig): unknown {
    const obj: any = {};
    if (message.upgrade_type !== undefined) {
      obj.upgrade_type = message.upgrade_type;
    }
    if (message.filters?.length) {
      obj.filters = message.filters.map((e) => HttpFilter.toJSON(e));
    }
    if (message.enabled !== undefined) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpConnectionManager_UpgradeConfig>, I>>(
    base?: I,
  ): HttpConnectionManager_UpgradeConfig {
    return HttpConnectionManager_UpgradeConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpConnectionManager_UpgradeConfig>, I>>(
    object: I,
  ): HttpConnectionManager_UpgradeConfig {
    const message = createBaseHttpConnectionManager_UpgradeConfig();
    message.upgrade_type = object.upgrade_type ?? undefined;
    message.filters = object.filters?.map((e) => HttpFilter.fromPartial(e)) || undefined;
    message.enabled = object.enabled ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(HttpConnectionManager_UpgradeConfig.$type, HttpConnectionManager_UpgradeConfig);

function createBaseHttpConnectionManager_PathNormalizationOptions(): HttpConnectionManager_PathNormalizationOptions {
  return {
    $type: "envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions",
  };
}

export const HttpConnectionManager_PathNormalizationOptions: MessageFns<
  HttpConnectionManager_PathNormalizationOptions,
  "envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions"
> = {
  $type:
    "envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions" as const,

  encode(
    message: HttpConnectionManager_PathNormalizationOptions,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.forwarding_transformation !== undefined) {
      PathTransformation.encode(message.forwarding_transformation, writer.uint32(10).fork()).join();
    }
    if (message.http_filter_transformation !== undefined) {
      PathTransformation.encode(message.http_filter_transformation, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpConnectionManager_PathNormalizationOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpConnectionManager_PathNormalizationOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.forwarding_transformation = PathTransformation.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.http_filter_transformation = PathTransformation.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpConnectionManager_PathNormalizationOptions {
    return {
      $type: HttpConnectionManager_PathNormalizationOptions.$type,
      forwarding_transformation: isSet(object.forwarding_transformation)
        ? PathTransformation.fromJSON(object.forwarding_transformation)
        : undefined,
      http_filter_transformation: isSet(object.http_filter_transformation)
        ? PathTransformation.fromJSON(object.http_filter_transformation)
        : undefined,
    };
  },

  toJSON(message: HttpConnectionManager_PathNormalizationOptions): unknown {
    const obj: any = {};
    if (message.forwarding_transformation !== undefined) {
      obj.forwarding_transformation = PathTransformation.toJSON(message.forwarding_transformation);
    }
    if (message.http_filter_transformation !== undefined) {
      obj.http_filter_transformation = PathTransformation.toJSON(message.http_filter_transformation);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpConnectionManager_PathNormalizationOptions>, I>>(
    base?: I,
  ): HttpConnectionManager_PathNormalizationOptions {
    return HttpConnectionManager_PathNormalizationOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpConnectionManager_PathNormalizationOptions>, I>>(
    object: I,
  ): HttpConnectionManager_PathNormalizationOptions {
    const message = createBaseHttpConnectionManager_PathNormalizationOptions();
    message.forwarding_transformation =
      (object.forwarding_transformation !== undefined && object.forwarding_transformation !== null)
        ? PathTransformation.fromPartial(object.forwarding_transformation)
        : undefined;
    message.http_filter_transformation =
      (object.http_filter_transformation !== undefined && object.http_filter_transformation !== null)
        ? PathTransformation.fromPartial(object.http_filter_transformation)
        : undefined;
    return message;
  },
};

messageTypeRegistry.set(
  HttpConnectionManager_PathNormalizationOptions.$type,
  HttpConnectionManager_PathNormalizationOptions,
);

function createBaseHttpConnectionManager_ProxyStatusConfig(): HttpConnectionManager_ProxyStatusConfig {
  return {
    $type: "envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig",
    proxy_name: undefined,
  };
}

export const HttpConnectionManager_ProxyStatusConfig: MessageFns<
  HttpConnectionManager_ProxyStatusConfig,
  "envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig"
> = {
  $type: "envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig" as const,

  encode(message: HttpConnectionManager_ProxyStatusConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.remove_details !== undefined && message.remove_details !== false) {
      writer.uint32(8).bool(message.remove_details);
    }
    if (
      message.remove_connection_termination_details !== undefined &&
      message.remove_connection_termination_details !== false
    ) {
      writer.uint32(16).bool(message.remove_connection_termination_details);
    }
    if (message.remove_response_flags !== undefined && message.remove_response_flags !== false) {
      writer.uint32(24).bool(message.remove_response_flags);
    }
    if (message.set_recommended_response_code !== undefined && message.set_recommended_response_code !== false) {
      writer.uint32(32).bool(message.set_recommended_response_code);
    }
    switch (message.proxy_name?.$case) {
      case "use_node_id":
        writer.uint32(40).bool(message.proxy_name.use_node_id);
        break;
      case "literal_proxy_name":
        writer.uint32(50).string(message.proxy_name.literal_proxy_name);
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpConnectionManager_ProxyStatusConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpConnectionManager_ProxyStatusConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.remove_details = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.remove_connection_termination_details = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.remove_response_flags = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.set_recommended_response_code = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.proxy_name = { $case: "use_node_id", use_node_id: reader.bool() };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.proxy_name = { $case: "literal_proxy_name", literal_proxy_name: reader.string() };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpConnectionManager_ProxyStatusConfig {
    return {
      $type: HttpConnectionManager_ProxyStatusConfig.$type,
      remove_details: isSet(object.remove_details) ? globalThis.Boolean(object.remove_details) : undefined,
      remove_connection_termination_details: isSet(object.remove_connection_termination_details)
        ? globalThis.Boolean(object.remove_connection_termination_details)
        : undefined,
      remove_response_flags: isSet(object.remove_response_flags)
        ? globalThis.Boolean(object.remove_response_flags)
        : undefined,
      set_recommended_response_code: isSet(object.set_recommended_response_code)
        ? globalThis.Boolean(object.set_recommended_response_code)
        : undefined,
      proxy_name: isSet(object.use_node_id)
        ? { $case: "use_node_id", use_node_id: globalThis.Boolean(object.use_node_id) }
        : isSet(object.literal_proxy_name)
        ? { $case: "literal_proxy_name", literal_proxy_name: globalThis.String(object.literal_proxy_name) }
        : undefined,
    };
  },

  toJSON(message: HttpConnectionManager_ProxyStatusConfig): unknown {
    const obj: any = {};
    if (message.remove_details !== undefined) {
      obj.remove_details = message.remove_details;
    }
    if (message.remove_connection_termination_details !== undefined) {
      obj.remove_connection_termination_details = message.remove_connection_termination_details;
    }
    if (message.remove_response_flags !== undefined) {
      obj.remove_response_flags = message.remove_response_flags;
    }
    if (message.set_recommended_response_code !== undefined) {
      obj.set_recommended_response_code = message.set_recommended_response_code;
    }
    if (message.proxy_name?.$case === "use_node_id") {
      obj.use_node_id = message.proxy_name.use_node_id;
    }
    if (message.proxy_name?.$case === "literal_proxy_name") {
      obj.literal_proxy_name = message.proxy_name.literal_proxy_name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpConnectionManager_ProxyStatusConfig>, I>>(
    base?: I,
  ): HttpConnectionManager_ProxyStatusConfig {
    return HttpConnectionManager_ProxyStatusConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpConnectionManager_ProxyStatusConfig>, I>>(
    object: I,
  ): HttpConnectionManager_ProxyStatusConfig {
    const message = createBaseHttpConnectionManager_ProxyStatusConfig();
    message.remove_details = object.remove_details ?? undefined;
    message.remove_connection_termination_details = object.remove_connection_termination_details ?? undefined;
    message.remove_response_flags = object.remove_response_flags ?? undefined;
    message.set_recommended_response_code = object.set_recommended_response_code ?? undefined;
    if (
      object.proxy_name?.$case === "use_node_id" &&
      object.proxy_name?.use_node_id !== undefined &&
      object.proxy_name?.use_node_id !== null
    ) {
      message.proxy_name = { $case: "use_node_id", use_node_id: object.proxy_name.use_node_id };
    }
    if (
      object.proxy_name?.$case === "literal_proxy_name" &&
      object.proxy_name?.literal_proxy_name !== undefined &&
      object.proxy_name?.literal_proxy_name !== null
    ) {
      message.proxy_name = { $case: "literal_proxy_name", literal_proxy_name: object.proxy_name.literal_proxy_name };
    }
    return message;
  },
};

messageTypeRegistry.set(HttpConnectionManager_ProxyStatusConfig.$type, HttpConnectionManager_ProxyStatusConfig);

function createBaseHttpConnectionManager_HcmAccessLogOptions(): HttpConnectionManager_HcmAccessLogOptions {
  return {
    $type: "envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.HcmAccessLogOptions",
  };
}

export const HttpConnectionManager_HcmAccessLogOptions: MessageFns<
  HttpConnectionManager_HcmAccessLogOptions,
  "envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.HcmAccessLogOptions"
> = {
  $type:
    "envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.HcmAccessLogOptions" as const,

  encode(message: HttpConnectionManager_HcmAccessLogOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.access_log_flush_interval !== undefined) {
      Duration.encode(message.access_log_flush_interval, writer.uint32(10).fork()).join();
    }
    if (message.flush_access_log_on_new_request !== undefined && message.flush_access_log_on_new_request !== false) {
      writer.uint32(16).bool(message.flush_access_log_on_new_request);
    }
    if (
      message.flush_log_on_tunnel_successfully_established !== undefined &&
      message.flush_log_on_tunnel_successfully_established !== false
    ) {
      writer.uint32(24).bool(message.flush_log_on_tunnel_successfully_established);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpConnectionManager_HcmAccessLogOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpConnectionManager_HcmAccessLogOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.access_log_flush_interval = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.flush_access_log_on_new_request = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.flush_log_on_tunnel_successfully_established = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpConnectionManager_HcmAccessLogOptions {
    return {
      $type: HttpConnectionManager_HcmAccessLogOptions.$type,
      access_log_flush_interval: isSet(object.access_log_flush_interval)
        ? Duration.fromJSON(object.access_log_flush_interval)
        : undefined,
      flush_access_log_on_new_request: isSet(object.flush_access_log_on_new_request)
        ? globalThis.Boolean(object.flush_access_log_on_new_request)
        : undefined,
      flush_log_on_tunnel_successfully_established: isSet(object.flush_log_on_tunnel_successfully_established)
        ? globalThis.Boolean(object.flush_log_on_tunnel_successfully_established)
        : undefined,
    };
  },

  toJSON(message: HttpConnectionManager_HcmAccessLogOptions): unknown {
    const obj: any = {};
    if (message.access_log_flush_interval !== undefined) {
      obj.access_log_flush_interval = Duration.toJSON(message.access_log_flush_interval);
    }
    if (message.flush_access_log_on_new_request !== undefined) {
      obj.flush_access_log_on_new_request = message.flush_access_log_on_new_request;
    }
    if (message.flush_log_on_tunnel_successfully_established !== undefined) {
      obj.flush_log_on_tunnel_successfully_established = message.flush_log_on_tunnel_successfully_established;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpConnectionManager_HcmAccessLogOptions>, I>>(
    base?: I,
  ): HttpConnectionManager_HcmAccessLogOptions {
    return HttpConnectionManager_HcmAccessLogOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpConnectionManager_HcmAccessLogOptions>, I>>(
    object: I,
  ): HttpConnectionManager_HcmAccessLogOptions {
    const message = createBaseHttpConnectionManager_HcmAccessLogOptions();
    message.access_log_flush_interval =
      (object.access_log_flush_interval !== undefined && object.access_log_flush_interval !== null)
        ? Duration.fromPartial(object.access_log_flush_interval)
        : undefined;
    message.flush_access_log_on_new_request = object.flush_access_log_on_new_request ?? undefined;
    message.flush_log_on_tunnel_successfully_established = object.flush_log_on_tunnel_successfully_established ??
      undefined;
    return message;
  },
};

messageTypeRegistry.set(HttpConnectionManager_HcmAccessLogOptions.$type, HttpConnectionManager_HcmAccessLogOptions);

function createBaseLocalReplyConfig(): LocalReplyConfig {
  return { $type: "envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig" };
}

export const LocalReplyConfig: MessageFns<
  LocalReplyConfig,
  "envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig"
> = {
  $type: "envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig" as const,

  encode(message: LocalReplyConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mappers !== undefined && message.mappers.length !== 0) {
      for (const v of message.mappers) {
        ResponseMapper.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    if (message.body_format !== undefined) {
      SubstitutionFormatString.encode(message.body_format, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocalReplyConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocalReplyConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.mappers === undefined) {
            message.mappers = [];
          }
          const el = ResponseMapper.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.mappers!.push(el);
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.body_format = SubstitutionFormatString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocalReplyConfig {
    return {
      $type: LocalReplyConfig.$type,
      mappers: globalThis.Array.isArray(object?.mappers)
        ? object.mappers.map((e: any) => ResponseMapper.fromJSON(e))
        : undefined,
      body_format: isSet(object.body_format) ? SubstitutionFormatString.fromJSON(object.body_format) : undefined,
    };
  },

  toJSON(message: LocalReplyConfig): unknown {
    const obj: any = {};
    if (message.mappers?.length) {
      obj.mappers = message.mappers.map((e) => ResponseMapper.toJSON(e));
    }
    if (message.body_format !== undefined) {
      obj.body_format = SubstitutionFormatString.toJSON(message.body_format);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LocalReplyConfig>, I>>(base?: I): LocalReplyConfig {
    return LocalReplyConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LocalReplyConfig>, I>>(object: I): LocalReplyConfig {
    const message = createBaseLocalReplyConfig();
    message.mappers = object.mappers?.map((e) => ResponseMapper.fromPartial(e)) || undefined;
    message.body_format = (object.body_format !== undefined && object.body_format !== null)
      ? SubstitutionFormatString.fromPartial(object.body_format)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(LocalReplyConfig.$type, LocalReplyConfig);

function createBaseResponseMapper(): ResponseMapper {
  return { $type: "envoy.extensions.filters.network.http_connection_manager.v3.ResponseMapper" };
}

export const ResponseMapper: MessageFns<
  ResponseMapper,
  "envoy.extensions.filters.network.http_connection_manager.v3.ResponseMapper"
> = {
  $type: "envoy.extensions.filters.network.http_connection_manager.v3.ResponseMapper" as const,

  encode(message: ResponseMapper, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filter !== undefined) {
      AccessLogFilter.encode(message.filter, writer.uint32(10).fork()).join();
    }
    if (message.status_code !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.status_code! },
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.body !== undefined) {
      DataSource.encode(message.body, writer.uint32(26).fork()).join();
    }
    if (message.body_format_override !== undefined) {
      SubstitutionFormatString.encode(message.body_format_override, writer.uint32(34).fork()).join();
    }
    if (message.headers_to_add !== undefined && message.headers_to_add.length !== 0) {
      for (const v of message.headers_to_add) {
        HeaderValueOption.encode(v!, writer.uint32(42).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResponseMapper {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseMapper();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filter = AccessLogFilter.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status_code = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.body = DataSource.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.body_format_override = SubstitutionFormatString.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          if (message.headers_to_add === undefined) {
            message.headers_to_add = [];
          }
          const el = HeaderValueOption.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.headers_to_add!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResponseMapper {
    return {
      $type: ResponseMapper.$type,
      filter: isSet(object.filter) ? AccessLogFilter.fromJSON(object.filter) : undefined,
      status_code: isSet(object.status_code) ? Number(object.status_code) : undefined,
      body: isSet(object.body) ? DataSource.fromJSON(object.body) : undefined,
      body_format_override: isSet(object.body_format_override)
        ? SubstitutionFormatString.fromJSON(object.body_format_override)
        : undefined,
      headers_to_add: globalThis.Array.isArray(object?.headers_to_add)
        ? object.headers_to_add.map((e: any) => HeaderValueOption.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: ResponseMapper): unknown {
    const obj: any = {};
    if (message.filter !== undefined) {
      obj.filter = AccessLogFilter.toJSON(message.filter);
    }
    if (message.status_code !== undefined) {
      obj.status_code = message.status_code;
    }
    if (message.body !== undefined) {
      obj.body = DataSource.toJSON(message.body);
    }
    if (message.body_format_override !== undefined) {
      obj.body_format_override = SubstitutionFormatString.toJSON(message.body_format_override);
    }
    if (message.headers_to_add?.length) {
      obj.headers_to_add = message.headers_to_add.map((e) => HeaderValueOption.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResponseMapper>, I>>(base?: I): ResponseMapper {
    return ResponseMapper.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResponseMapper>, I>>(object: I): ResponseMapper {
    const message = createBaseResponseMapper();
    message.filter = (object.filter !== undefined && object.filter !== null)
      ? AccessLogFilter.fromPartial(object.filter)
      : undefined;
    message.status_code = object.status_code ?? undefined;
    message.body = (object.body !== undefined && object.body !== null)
      ? DataSource.fromPartial(object.body)
      : undefined;
    message.body_format_override = (object.body_format_override !== undefined && object.body_format_override !== null)
      ? SubstitutionFormatString.fromPartial(object.body_format_override)
      : undefined;
    message.headers_to_add = object.headers_to_add?.map((e) => HeaderValueOption.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(ResponseMapper.$type, ResponseMapper);

function createBaseRds(): Rds {
  return { $type: "envoy.extensions.filters.network.http_connection_manager.v3.Rds" };
}

export const Rds: MessageFns<Rds, "envoy.extensions.filters.network.http_connection_manager.v3.Rds"> = {
  $type: "envoy.extensions.filters.network.http_connection_manager.v3.Rds" as const,

  encode(message: Rds, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.config_source !== undefined) {
      ConfigSource.encode(message.config_source, writer.uint32(10).fork()).join();
    }
    if (message.route_config_name !== undefined && message.route_config_name !== "") {
      writer.uint32(18).string(message.route_config_name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Rds {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRds();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.config_source = ConfigSource.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.route_config_name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Rds {
    return {
      $type: Rds.$type,
      config_source: isSet(object.config_source) ? ConfigSource.fromJSON(object.config_source) : undefined,
      route_config_name: isSet(object.route_config_name) ? globalThis.String(object.route_config_name) : undefined,
    };
  },

  toJSON(message: Rds): unknown {
    const obj: any = {};
    if (message.config_source !== undefined) {
      obj.config_source = ConfigSource.toJSON(message.config_source);
    }
    if (message.route_config_name !== undefined) {
      obj.route_config_name = message.route_config_name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Rds>, I>>(base?: I): Rds {
    return Rds.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Rds>, I>>(object: I): Rds {
    const message = createBaseRds();
    message.config_source = (object.config_source !== undefined && object.config_source !== null)
      ? ConfigSource.fromPartial(object.config_source)
      : undefined;
    message.route_config_name = object.route_config_name ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Rds.$type, Rds);

function createBaseScopedRouteConfigurationsList(): ScopedRouteConfigurationsList {
  return { $type: "envoy.extensions.filters.network.http_connection_manager.v3.ScopedRouteConfigurationsList" };
}

export const ScopedRouteConfigurationsList: MessageFns<
  ScopedRouteConfigurationsList,
  "envoy.extensions.filters.network.http_connection_manager.v3.ScopedRouteConfigurationsList"
> = {
  $type: "envoy.extensions.filters.network.http_connection_manager.v3.ScopedRouteConfigurationsList" as const,

  encode(message: ScopedRouteConfigurationsList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scoped_route_configurations !== undefined && message.scoped_route_configurations.length !== 0) {
      for (const v of message.scoped_route_configurations) {
        ScopedRouteConfiguration.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScopedRouteConfigurationsList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScopedRouteConfigurationsList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.scoped_route_configurations === undefined) {
            message.scoped_route_configurations = [];
          }
          const el = ScopedRouteConfiguration.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.scoped_route_configurations!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScopedRouteConfigurationsList {
    return {
      $type: ScopedRouteConfigurationsList.$type,
      scoped_route_configurations: globalThis.Array.isArray(object?.scoped_route_configurations)
        ? object.scoped_route_configurations.map((e: any) => ScopedRouteConfiguration.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: ScopedRouteConfigurationsList): unknown {
    const obj: any = {};
    if (message.scoped_route_configurations?.length) {
      obj.scoped_route_configurations = message.scoped_route_configurations.map((e) =>
        ScopedRouteConfiguration.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScopedRouteConfigurationsList>, I>>(base?: I): ScopedRouteConfigurationsList {
    return ScopedRouteConfigurationsList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScopedRouteConfigurationsList>, I>>(
    object: I,
  ): ScopedRouteConfigurationsList {
    const message = createBaseScopedRouteConfigurationsList();
    message.scoped_route_configurations =
      object.scoped_route_configurations?.map((e) => ScopedRouteConfiguration.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(ScopedRouteConfigurationsList.$type, ScopedRouteConfigurationsList);

function createBaseScopedRoutes(): ScopedRoutes {
  return {
    $type: "envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes",
    config_specifier: undefined,
  };
}

export const ScopedRoutes: MessageFns<
  ScopedRoutes,
  "envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes"
> = {
  $type: "envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes" as const,

  encode(message: ScopedRoutes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.scope_key_builder !== undefined) {
      ScopedRoutes_ScopeKeyBuilder.encode(message.scope_key_builder, writer.uint32(18).fork()).join();
    }
    if (message.rds_config_source !== undefined) {
      ConfigSource.encode(message.rds_config_source, writer.uint32(26).fork()).join();
    }
    switch (message.config_specifier?.$case) {
      case "scoped_route_configurations_list":
        ScopedRouteConfigurationsList.encode(
          message.config_specifier.scoped_route_configurations_list,
          writer.uint32(34).fork(),
        ).join();
        break;
      case "scoped_rds":
        ScopedRds.encode(message.config_specifier.scoped_rds, writer.uint32(42).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScopedRoutes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScopedRoutes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.scope_key_builder = ScopedRoutes_ScopeKeyBuilder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rds_config_source = ConfigSource.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.config_specifier = {
            $case: "scoped_route_configurations_list",
            scoped_route_configurations_list: ScopedRouteConfigurationsList.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.config_specifier = { $case: "scoped_rds", scoped_rds: ScopedRds.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScopedRoutes {
    return {
      $type: ScopedRoutes.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      scope_key_builder: isSet(object.scope_key_builder)
        ? ScopedRoutes_ScopeKeyBuilder.fromJSON(object.scope_key_builder)
        : undefined,
      rds_config_source: isSet(object.rds_config_source) ? ConfigSource.fromJSON(object.rds_config_source) : undefined,
      config_specifier: isSet(object.scoped_route_configurations_list)
        ? {
          $case: "scoped_route_configurations_list",
          scoped_route_configurations_list: ScopedRouteConfigurationsList.fromJSON(
            object.scoped_route_configurations_list,
          ),
        }
        : isSet(object.scoped_rds)
        ? { $case: "scoped_rds", scoped_rds: ScopedRds.fromJSON(object.scoped_rds) }
        : undefined,
    };
  },

  toJSON(message: ScopedRoutes): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.scope_key_builder !== undefined) {
      obj.scope_key_builder = ScopedRoutes_ScopeKeyBuilder.toJSON(message.scope_key_builder);
    }
    if (message.rds_config_source !== undefined) {
      obj.rds_config_source = ConfigSource.toJSON(message.rds_config_source);
    }
    if (message.config_specifier?.$case === "scoped_route_configurations_list") {
      obj.scoped_route_configurations_list = ScopedRouteConfigurationsList.toJSON(
        message.config_specifier.scoped_route_configurations_list,
      );
    }
    if (message.config_specifier?.$case === "scoped_rds") {
      obj.scoped_rds = ScopedRds.toJSON(message.config_specifier.scoped_rds);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScopedRoutes>, I>>(base?: I): ScopedRoutes {
    return ScopedRoutes.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScopedRoutes>, I>>(object: I): ScopedRoutes {
    const message = createBaseScopedRoutes();
    message.name = object.name ?? undefined;
    message.scope_key_builder = (object.scope_key_builder !== undefined && object.scope_key_builder !== null)
      ? ScopedRoutes_ScopeKeyBuilder.fromPartial(object.scope_key_builder)
      : undefined;
    message.rds_config_source = (object.rds_config_source !== undefined && object.rds_config_source !== null)
      ? ConfigSource.fromPartial(object.rds_config_source)
      : undefined;
    if (
      object.config_specifier?.$case === "scoped_route_configurations_list" &&
      object.config_specifier?.scoped_route_configurations_list !== undefined &&
      object.config_specifier?.scoped_route_configurations_list !== null
    ) {
      message.config_specifier = {
        $case: "scoped_route_configurations_list",
        scoped_route_configurations_list: ScopedRouteConfigurationsList.fromPartial(
          object.config_specifier.scoped_route_configurations_list,
        ),
      };
    }
    if (
      object.config_specifier?.$case === "scoped_rds" &&
      object.config_specifier?.scoped_rds !== undefined &&
      object.config_specifier?.scoped_rds !== null
    ) {
      message.config_specifier = {
        $case: "scoped_rds",
        scoped_rds: ScopedRds.fromPartial(object.config_specifier.scoped_rds),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(ScopedRoutes.$type, ScopedRoutes);

function createBaseScopedRoutes_ScopeKeyBuilder(): ScopedRoutes_ScopeKeyBuilder {
  return { $type: "envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder" };
}

export const ScopedRoutes_ScopeKeyBuilder: MessageFns<
  ScopedRoutes_ScopeKeyBuilder,
  "envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder"
> = {
  $type: "envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder" as const,

  encode(message: ScopedRoutes_ScopeKeyBuilder, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fragments !== undefined && message.fragments.length !== 0) {
      for (const v of message.fragments) {
        ScopedRoutes_ScopeKeyBuilder_FragmentBuilder.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScopedRoutes_ScopeKeyBuilder {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScopedRoutes_ScopeKeyBuilder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.fragments === undefined) {
            message.fragments = [];
          }
          const el = ScopedRoutes_ScopeKeyBuilder_FragmentBuilder.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.fragments!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScopedRoutes_ScopeKeyBuilder {
    return {
      $type: ScopedRoutes_ScopeKeyBuilder.$type,
      fragments: globalThis.Array.isArray(object?.fragments)
        ? object.fragments.map((e: any) => ScopedRoutes_ScopeKeyBuilder_FragmentBuilder.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: ScopedRoutes_ScopeKeyBuilder): unknown {
    const obj: any = {};
    if (message.fragments?.length) {
      obj.fragments = message.fragments.map((e) => ScopedRoutes_ScopeKeyBuilder_FragmentBuilder.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScopedRoutes_ScopeKeyBuilder>, I>>(base?: I): ScopedRoutes_ScopeKeyBuilder {
    return ScopedRoutes_ScopeKeyBuilder.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScopedRoutes_ScopeKeyBuilder>, I>>(object: I): ScopedRoutes_ScopeKeyBuilder {
    const message = createBaseScopedRoutes_ScopeKeyBuilder();
    message.fragments = object.fragments?.map((e) => ScopedRoutes_ScopeKeyBuilder_FragmentBuilder.fromPartial(e)) ||
      undefined;
    return message;
  },
};

messageTypeRegistry.set(ScopedRoutes_ScopeKeyBuilder.$type, ScopedRoutes_ScopeKeyBuilder);

function createBaseScopedRoutes_ScopeKeyBuilder_FragmentBuilder(): ScopedRoutes_ScopeKeyBuilder_FragmentBuilder {
  return {
    $type: "envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder",
    type: undefined,
  };
}

export const ScopedRoutes_ScopeKeyBuilder_FragmentBuilder: MessageFns<
  ScopedRoutes_ScopeKeyBuilder_FragmentBuilder,
  "envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder"
> = {
  $type:
    "envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder" as const,

  encode(
    message: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    switch (message.type?.$case) {
      case "header_value_extractor":
        ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor.encode(
          message.type.header_value_extractor,
          writer.uint32(10).fork(),
        ).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScopedRoutes_ScopeKeyBuilder_FragmentBuilder {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScopedRoutes_ScopeKeyBuilder_FragmentBuilder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = {
            $case: "header_value_extractor",
            header_value_extractor: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor.decode(
              reader,
              reader.uint32(),
            ),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScopedRoutes_ScopeKeyBuilder_FragmentBuilder {
    return {
      $type: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder.$type,
      type: isSet(object.header_value_extractor)
        ? {
          $case: "header_value_extractor",
          header_value_extractor: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor.fromJSON(
            object.header_value_extractor,
          ),
        }
        : undefined,
    };
  },

  toJSON(message: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder): unknown {
    const obj: any = {};
    if (message.type?.$case === "header_value_extractor") {
      obj.header_value_extractor = ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor.toJSON(
        message.type.header_value_extractor,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScopedRoutes_ScopeKeyBuilder_FragmentBuilder>, I>>(
    base?: I,
  ): ScopedRoutes_ScopeKeyBuilder_FragmentBuilder {
    return ScopedRoutes_ScopeKeyBuilder_FragmentBuilder.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScopedRoutes_ScopeKeyBuilder_FragmentBuilder>, I>>(
    object: I,
  ): ScopedRoutes_ScopeKeyBuilder_FragmentBuilder {
    const message = createBaseScopedRoutes_ScopeKeyBuilder_FragmentBuilder();
    if (
      object.type?.$case === "header_value_extractor" &&
      object.type?.header_value_extractor !== undefined &&
      object.type?.header_value_extractor !== null
    ) {
      message.type = {
        $case: "header_value_extractor",
        header_value_extractor: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor.fromPartial(
          object.type.header_value_extractor,
        ),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(
  ScopedRoutes_ScopeKeyBuilder_FragmentBuilder.$type,
  ScopedRoutes_ScopeKeyBuilder_FragmentBuilder,
);

function createBaseScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor(): ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor {
  return {
    $type:
      "envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor",
    extract_type: undefined,
  };
}

export const ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor: MessageFns<
  ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor,
  "envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor"
> = {
  $type:
    "envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor" as const,

  encode(
    message: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.element_separator !== undefined && message.element_separator !== "") {
      writer.uint32(18).string(message.element_separator);
    }
    switch (message.extract_type?.$case) {
      case "index":
        writer.uint32(24).uint32(message.extract_type.index);
        break;
      case "element":
        ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement.encode(
          message.extract_type.element,
          writer.uint32(34).fork(),
        ).join();
        break;
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.element_separator = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.extract_type = { $case: "index", index: reader.uint32() };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.extract_type = {
            $case: "element",
            element: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement.decode(
              reader,
              reader.uint32(),
            ),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor {
    return {
      $type: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      element_separator: isSet(object.element_separator) ? globalThis.String(object.element_separator) : undefined,
      extract_type: isSet(object.index)
        ? { $case: "index", index: globalThis.Number(object.index) }
        : isSet(object.element)
        ? {
          $case: "element",
          element: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement.fromJSON(object.element),
        }
        : undefined,
    };
  },

  toJSON(message: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.element_separator !== undefined) {
      obj.element_separator = message.element_separator;
    }
    if (message.extract_type?.$case === "index") {
      obj.index = Math.round(message.extract_type.index);
    }
    if (message.extract_type?.$case === "element") {
      obj.element = ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement.toJSON(
        message.extract_type.element,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor>, I>>(
    base?: I,
  ): ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor {
    return ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor>, I>>(
    object: I,
  ): ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor {
    const message = createBaseScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor();
    message.name = object.name ?? undefined;
    message.element_separator = object.element_separator ?? undefined;
    if (
      object.extract_type?.$case === "index" &&
      object.extract_type?.index !== undefined &&
      object.extract_type?.index !== null
    ) {
      message.extract_type = { $case: "index", index: object.extract_type.index };
    }
    if (
      object.extract_type?.$case === "element" &&
      object.extract_type?.element !== undefined &&
      object.extract_type?.element !== null
    ) {
      message.extract_type = {
        $case: "element",
        element: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement.fromPartial(
          object.extract_type.element,
        ),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(
  ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor.$type,
  ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor,
);

function createBaseScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement(): ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement {
  return {
    $type:
      "envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor.KvElement",
  };
}

export const ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement: MessageFns<
  ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement,
  "envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor.KvElement"
> = {
  $type:
    "envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor.KvElement" as const,

  encode(
    message: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.separator !== undefined && message.separator !== "") {
      writer.uint32(10).string(message.separator);
    }
    if (message.key !== undefined && message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.separator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement {
    return {
      $type: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement.$type,
      separator: isSet(object.separator) ? globalThis.String(object.separator) : undefined,
      key: isSet(object.key) ? globalThis.String(object.key) : undefined,
    };
  },

  toJSON(message: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement): unknown {
    const obj: any = {};
    if (message.separator !== undefined) {
      obj.separator = message.separator;
    }
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement>, I>>(
    base?: I,
  ): ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement {
    return ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement.fromPartial(base ?? ({} as any));
  },
  fromPartial<
    I extends Exact<DeepPartial<ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement>, I>,
  >(object: I): ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement {
    const message = createBaseScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement();
    message.separator = object.separator ?? undefined;
    message.key = object.key ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(
  ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement.$type,
  ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement,
);

function createBaseScopedRds(): ScopedRds {
  return { $type: "envoy.extensions.filters.network.http_connection_manager.v3.ScopedRds" };
}

export const ScopedRds: MessageFns<ScopedRds, "envoy.extensions.filters.network.http_connection_manager.v3.ScopedRds"> =
  {
    $type: "envoy.extensions.filters.network.http_connection_manager.v3.ScopedRds" as const,

    encode(message: ScopedRds, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
      if (message.scoped_rds_config_source !== undefined) {
        ConfigSource.encode(message.scoped_rds_config_source, writer.uint32(10).fork()).join();
      }
      if (message.srds_resources_locator !== undefined && message.srds_resources_locator !== "") {
        writer.uint32(18).string(message.srds_resources_locator);
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): ScopedRds {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseScopedRds();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.scoped_rds_config_source = ConfigSource.decode(reader, reader.uint32());
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.srds_resources_locator = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): ScopedRds {
      return {
        $type: ScopedRds.$type,
        scoped_rds_config_source: isSet(object.scoped_rds_config_source)
          ? ConfigSource.fromJSON(object.scoped_rds_config_source)
          : undefined,
        srds_resources_locator: isSet(object.srds_resources_locator)
          ? globalThis.String(object.srds_resources_locator)
          : undefined,
      };
    },

    toJSON(message: ScopedRds): unknown {
      const obj: any = {};
      if (message.scoped_rds_config_source !== undefined) {
        obj.scoped_rds_config_source = ConfigSource.toJSON(message.scoped_rds_config_source);
      }
      if (message.srds_resources_locator !== undefined) {
        obj.srds_resources_locator = message.srds_resources_locator;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<ScopedRds>, I>>(base?: I): ScopedRds {
      return ScopedRds.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<ScopedRds>, I>>(object: I): ScopedRds {
      const message = createBaseScopedRds();
      message.scoped_rds_config_source =
        (object.scoped_rds_config_source !== undefined && object.scoped_rds_config_source !== null)
          ? ConfigSource.fromPartial(object.scoped_rds_config_source)
          : undefined;
      message.srds_resources_locator = object.srds_resources_locator ?? undefined;
      return message;
    },
  };

messageTypeRegistry.set(ScopedRds.$type, ScopedRds);

function createBaseHttpFilter(): HttpFilter {
  return { $type: "envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter", config_type: undefined };
}

export const HttpFilter: MessageFns<
  HttpFilter,
  "envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter"
> = {
  $type: "envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter" as const,

  encode(message: HttpFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    switch (message.config_type?.$case) {
      case "typed_config":
        Any.encode(message.config_type.typed_config, writer.uint32(34).fork()).join();
        break;
      case "config_discovery":
        ExtensionConfigSource.encode(message.config_type.config_discovery, writer.uint32(42).fork()).join();
        break;
    }
    if (message.is_optional !== undefined && message.is_optional !== false) {
      writer.uint32(48).bool(message.is_optional);
    }
    if (message.disabled !== undefined && message.disabled !== false) {
      writer.uint32(56).bool(message.disabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.config_type = { $case: "typed_config", typed_config: Any.decode(reader, reader.uint32()) };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.config_type = {
            $case: "config_discovery",
            config_discovery: ExtensionConfigSource.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.is_optional = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.disabled = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpFilter {
    return {
      $type: HttpFilter.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      config_type: isSet(object.typed_config)
        ? { $case: "typed_config", typed_config: Any.fromJSON(object.typed_config) }
        : isSet(object.config_discovery)
        ? { $case: "config_discovery", config_discovery: ExtensionConfigSource.fromJSON(object.config_discovery) }
        : undefined,
      is_optional: isSet(object.is_optional) ? globalThis.Boolean(object.is_optional) : undefined,
      disabled: isSet(object.disabled) ? globalThis.Boolean(object.disabled) : undefined,
    };
  },

  toJSON(message: HttpFilter): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.config_type?.$case === "typed_config") {
      obj.typed_config = Any.toJSON(message.config_type.typed_config);
    }
    if (message.config_type?.$case === "config_discovery") {
      obj.config_discovery = ExtensionConfigSource.toJSON(message.config_type.config_discovery);
    }
    if (message.is_optional !== undefined) {
      obj.is_optional = message.is_optional;
    }
    if (message.disabled !== undefined) {
      obj.disabled = message.disabled;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpFilter>, I>>(base?: I): HttpFilter {
    return HttpFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpFilter>, I>>(object: I): HttpFilter {
    const message = createBaseHttpFilter();
    message.name = object.name ?? undefined;
    if (
      object.config_type?.$case === "typed_config" &&
      object.config_type?.typed_config !== undefined &&
      object.config_type?.typed_config !== null
    ) {
      message.config_type = { $case: "typed_config", typed_config: Any.fromPartial(object.config_type.typed_config) };
    }
    if (
      object.config_type?.$case === "config_discovery" &&
      object.config_type?.config_discovery !== undefined &&
      object.config_type?.config_discovery !== null
    ) {
      message.config_type = {
        $case: "config_discovery",
        config_discovery: ExtensionConfigSource.fromPartial(object.config_type.config_discovery),
      };
    }
    message.is_optional = object.is_optional ?? undefined;
    message.disabled = object.disabled ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(HttpFilter.$type, HttpFilter);

function createBaseRequestIDExtension(): RequestIDExtension {
  return { $type: "envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension" };
}

export const RequestIDExtension: MessageFns<
  RequestIDExtension,
  "envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension"
> = {
  $type: "envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension" as const,

  encode(message: RequestIDExtension, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.typed_config !== undefined) {
      Any.encode(message.typed_config, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestIDExtension {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestIDExtension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.typed_config = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestIDExtension {
    return {
      $type: RequestIDExtension.$type,
      typed_config: isSet(object.typed_config) ? Any.fromJSON(object.typed_config) : undefined,
    };
  },

  toJSON(message: RequestIDExtension): unknown {
    const obj: any = {};
    if (message.typed_config !== undefined) {
      obj.typed_config = Any.toJSON(message.typed_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestIDExtension>, I>>(base?: I): RequestIDExtension {
    return RequestIDExtension.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestIDExtension>, I>>(object: I): RequestIDExtension {
    const message = createBaseRequestIDExtension();
    message.typed_config = (object.typed_config !== undefined && object.typed_config !== null)
      ? Any.fromPartial(object.typed_config)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(RequestIDExtension.$type, RequestIDExtension);

function createBaseEnvoyMobileHttpConnectionManager(): EnvoyMobileHttpConnectionManager {
  return { $type: "envoy.extensions.filters.network.http_connection_manager.v3.EnvoyMobileHttpConnectionManager" };
}

export const EnvoyMobileHttpConnectionManager: MessageFns<
  EnvoyMobileHttpConnectionManager,
  "envoy.extensions.filters.network.http_connection_manager.v3.EnvoyMobileHttpConnectionManager"
> = {
  $type: "envoy.extensions.filters.network.http_connection_manager.v3.EnvoyMobileHttpConnectionManager" as const,

  encode(message: EnvoyMobileHttpConnectionManager, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.config !== undefined) {
      HttpConnectionManager.encode(message.config, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnvoyMobileHttpConnectionManager {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvoyMobileHttpConnectionManager();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.config = HttpConnectionManager.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnvoyMobileHttpConnectionManager {
    return {
      $type: EnvoyMobileHttpConnectionManager.$type,
      config: isSet(object.config) ? HttpConnectionManager.fromJSON(object.config) : undefined,
    };
  },

  toJSON(message: EnvoyMobileHttpConnectionManager): unknown {
    const obj: any = {};
    if (message.config !== undefined) {
      obj.config = HttpConnectionManager.toJSON(message.config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EnvoyMobileHttpConnectionManager>, I>>(
    base?: I,
  ): EnvoyMobileHttpConnectionManager {
    return EnvoyMobileHttpConnectionManager.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EnvoyMobileHttpConnectionManager>, I>>(
    object: I,
  ): EnvoyMobileHttpConnectionManager {
    const message = createBaseEnvoyMobileHttpConnectionManager();
    message.config = (object.config !== undefined && object.config !== null)
      ? HttpConnectionManager.fromPartial(object.config)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(EnvoyMobileHttpConnectionManager.$type, EnvoyMobileHttpConnectionManager);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
