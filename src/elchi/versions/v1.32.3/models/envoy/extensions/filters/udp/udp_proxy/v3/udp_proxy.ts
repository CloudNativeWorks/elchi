// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/filters/udp/udp_proxy/v3/udp_proxy.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Any } from "../../../../../../google/protobuf/any";
import { Duration } from "../../../../../../google/protobuf/duration";
import { UInt32Value, UInt64Value } from "../../../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../../../typeRegistry";
import { Matcher } from "../../../../../../xds/type/matcher/v3/matcher";
import { AccessLog } from "../../../../../config/accesslog/v3/accesslog";
import { HeaderValueOption } from "../../../../../config/core/v3/base";
import { ExtensionConfigSource } from "../../../../../config/core/v3/config_source";
import { UdpSocketConfig } from "../../../../../config/core/v3/udp_socket_config";

export const protobufPackage = "envoy.extensions.filters.udp.udp_proxy.v3";

/**
 * Configuration for the UDP proxy filter.
 * [#next-free-field: 14]
 */
export interface UdpProxyConfig {
  $type: "envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig";
  /** The stat prefix used when emitting UDP proxy filter stats. */
  stat_prefix?: string | undefined;
  route_specifier?:
    | //
    /**
     * The upstream cluster to connect to.
     * This field is deprecated in favor of
     * :ref:`matcher <envoy_v3_api_field_extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.matcher>`.
     */
    { $case: "cluster"; cluster: string }
    | //
    /**
     * The match tree to use when resolving route actions for incoming requests.
     * See :ref:`Routing <config_udp_listener_filters_udp_proxy_routing>` for more information.
     */
    { $case: "matcher"; matcher: Matcher }
    | undefined;
  /**
   * The idle timeout for sessions. Idle is defined as no datagrams between received or sent by
   * the session. The default if not specified is 1 minute.
   */
  idle_timeout?:
    | Duration
    | undefined;
  /**
   * Use the remote downstream IP address as the sender IP address when sending packets to upstream hosts.
   * This option requires Envoy to be run with the ``CAP_NET_ADMIN`` capability on Linux.
   * And the IPv6 stack must be enabled on Linux kernel.
   * This option does not preserve the remote downstream port.
   * If this option is enabled, the IP address of sent datagrams will be changed to the remote downstream IP address.
   * This means that Envoy will not receive packets that are sent by upstream hosts because the upstream hosts
   * will send the packets with the remote downstream IP address as the destination. All packets will be routed
   * to the remote downstream directly if there are route rules on the upstream host side.
   * There are two options to return the packets back to the remote downstream.
   * The first one is to use DSR (Direct Server Return).
   * The other one is to configure routing rules on the upstream hosts to forward
   * all packets back to Envoy and configure iptables rules on the host running Envoy to
   * forward all packets from upstream hosts to the Envoy process so that Envoy can forward the packets to the downstream.
   * If the platform does not support this option, Envoy will raise a configuration error.
   */
  use_original_src_ip?:
    | boolean
    | undefined;
  /**
   * Optional configuration for UDP proxy hash policies. If hash_policies is not set, the hash-based
   * load balancing algorithms will select a host randomly. Currently the number of hash policies is
   * limited to 1.
   */
  hash_policies?:
    | UdpProxyConfig_HashPolicy[]
    | undefined;
  /**
   * UDP socket configuration for upstream sockets. The default for
   * :ref:`prefer_gro <envoy_v3_api_field_config.core.v3.UdpSocketConfig.prefer_gro>` is true for upstream
   * sockets as the assumption is datagrams will be received from a single source.
   */
  upstream_socket_config?:
    | UdpSocketConfig
    | undefined;
  /**
   * Perform per packet load balancing (upstream host selection) on each received data chunk.
   * The default if not specified is false, that means each data chunk is forwarded
   * to upstream host selected on first chunk receival for that "session" (identified by source IP/port and local IP/port).
   * Only one of use_per_packet_load_balancing or session_filters can be used.
   */
  use_per_packet_load_balancing?:
    | boolean
    | undefined;
  /** Configuration for session access logs emitted by the UDP proxy. Note that certain UDP specific data is emitted as :ref:`Dynamic Metadata <config_access_log_format_dynamic_metadata>`. */
  access_log?:
    | AccessLog[]
    | undefined;
  /** Configuration for proxy access logs emitted by the UDP proxy. Note that certain UDP specific data is emitted as :ref:`Dynamic Metadata <config_access_log_format_dynamic_metadata>`. */
  proxy_access_log?:
    | AccessLog[]
    | undefined;
  /**
   * Optional session filters that will run for each UDP session.
   * Only one of use_per_packet_load_balancing or session_filters can be used.
   * [#extension-category: envoy.filters.udp.session]
   */
  session_filters?:
    | UdpProxyConfig_SessionFilter[]
    | undefined;
  /**
   * If set, this configures UDP tunneling. See `Proxying UDP in HTTP <https://www.rfc-editor.org/rfc/rfc9298.html>`_.
   * More information can be found in the UDP Proxy and HTTP upgrade documentation.
   */
  tunneling_config?:
    | UdpProxyConfig_UdpTunnelingConfig
    | undefined;
  /** Additional access log options for UDP Proxy. */
  access_log_options?: UdpProxyConfig_UdpAccessLogOptions | undefined;
}

/**
 * Specifies the UDP hash policy.
 * The packets can be routed by hash policy.
 */
export interface UdpProxyConfig_HashPolicy {
  $type: "envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.HashPolicy";
  policy_specifier?:
    | //
    /** The source IP will be used to compute the hash used by hash-based load balancing algorithms. */
    { $case: "source_ip"; source_ip: boolean }
    | //
    /**
     * A given key will be used to compute the hash used by hash-based load balancing algorithms.
     * In certain cases there is a need to direct different UDP streams jointly towards the selected set of endpoints.
     * A possible use-case is VoIP telephony, where media (RTP) and its corresponding control (RTCP) belong to the same logical session,
     * although they travel in separate streams. To ensure that these pair of streams are load-balanced on session level
     * (instead of individual stream level), dynamically created listeners can use the same hash key for each stream in the session.
     */
    { $case: "key"; key: string }
    | undefined;
}

/** Configuration for UDP session filters. */
export interface UdpProxyConfig_SessionFilter {
  $type: "envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.SessionFilter";
  /** The name of the filter configuration. */
  name?: string | undefined;
  config_type?:
    | //
    /**
     * Filter specific configuration which depends on the filter being
     * instantiated. See the supported filters for further documentation.
     */
    { $case: "typed_config"; typed_config: Any }
    | //
    /**
     * Configuration source specifier for an extension configuration discovery
     * service. In case of a failure and without the default configuration, the
     * UDP session will be removed.
     */
    { $case: "config_discovery"; config_discovery: ExtensionConfigSource }
    | undefined;
}

/**
 * Configuration for tunneling UDP over other transports or application layers.
 * Tunneling is currently supported over HTTP/2.
 * [#next-free-field: 12]
 */
export interface UdpProxyConfig_UdpTunnelingConfig {
  $type: "envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.UdpTunnelingConfig";
  /**
   * The hostname to send in the synthesized CONNECT headers to the upstream proxy.
   * This field evaluates command operators if set, otherwise returns hostname as is.
   *
   * Example: dynamically set hostname using filter state
   *
   * .. code-block:: yaml
   *
   *    tunneling_config:
   *      proxy_host: "%FILTER_STATE(proxy.host.key:PLAIN)%"
   */
  proxy_host?:
    | string
    | undefined;
  /**
   * Optional port value to add to the HTTP request URI.
   * This value can be overridden per-session by setting the required port value for
   * the filter state key ``udp.connect.proxy_port``.
   */
  proxy_port?:
    | number
    | undefined;
  /**
   * The target host to send in the synthesized CONNECT headers to the upstream proxy.
   * This field evaluates command operators if set, otherwise returns hostname as is.
   *
   * Example: dynamically set target host using filter state
   *
   * .. code-block:: yaml
   *
   *    tunneling_config:
   *      target_host: "%FILTER_STATE(target.host.key:PLAIN)%"
   */
  target_host?:
    | string
    | undefined;
  /**
   * The default target port to send in the CONNECT headers to the upstream proxy.
   * This value can be overridden per-session by setting the required port value for
   * the filter state key ``udp.connect.target_port``.
   */
  default_target_port?:
    | number
    | undefined;
  /**
   * Use POST method instead of CONNECT method to tunnel the UDP stream.
   *
   * .. note::
   *   If use_post is set, the upstream stream does not comply with the connect-udp RFC, and
   *   instead it will be a POST request. the path used in the headers will be set from the
   *   post_path field, and the headers will not contain the target host and target port, as
   *   required by the connect-udp protocol. This flag should be used carefully.
   */
  use_post?:
    | boolean
    | undefined;
  /**
   * The path used with POST method. Default path is ``/``. If post path is specified and
   * use_post field isn't true, it will be rejected.
   */
  post_path?:
    | string
    | undefined;
  /** Optional retry options, in case connecting to the upstream failed. */
  retry_options?:
    | UdpProxyConfig_UdpTunnelingConfig_RetryOptions
    | undefined;
  /**
   * Additional request headers to upstream proxy. Neither ``:-prefixed`` pseudo-headers
   * nor the Host: header can be overridden. Values of the added headers evaluates command
   * operators if they are set in the value template.
   *
   * Example: dynamically set a header with the local port
   *
   * .. code-block:: yaml
   *
   *    headers_to_add:
   *    - header:
   *        key: original_dst_port
   *        value: "%DOWNSTREAM_LOCAL_PORT%"
   */
  headers_to_add?:
    | HeaderValueOption[]
    | undefined;
  /**
   * If configured, the filter will buffer datagrams in case that it is waiting for the upstream to be
   * ready, whether if it is during the connection process or due to upstream buffer watermarks.
   * If this field is not configured, there will be no buffering and downstream datagrams that arrive
   * while the upstream is not ready will be dropped. In case this field is set but the options
   * are not configured, the default values will be applied as described in the ``BufferOptions``.
   */
  buffer_options?:
    | UdpProxyConfig_UdpTunnelingConfig_BufferOptions
    | undefined;
  /**
   * Save the response headers to the downstream info filter state for consumption
   * by the session filters. The filter state key is ``envoy.udp_proxy.propagate_response_headers``.
   */
  propagate_response_headers?:
    | boolean
    | undefined;
  /**
   * Save the response trailers to the downstream info filter state for consumption
   * by the session filters. The filter state key is ``envoy.udp_proxy.propagate_response_trailers``.
   */
  propagate_response_trailers?: boolean | undefined;
}

/** Configuration for UDP datagrams buffering. */
export interface UdpProxyConfig_UdpTunnelingConfig_BufferOptions {
  $type: "envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.UdpTunnelingConfig.BufferOptions";
  /**
   * If set, the filter will only buffer datagrams up to the requested limit, and will drop
   * new UDP datagrams if the buffer contains the max_buffered_datagrams value at the time
   * of a new datagram arrival. If not set, the default value is 1024 datagrams.
   */
  max_buffered_datagrams?:
    | number
    | undefined;
  /**
   * If set, the filter will only buffer datagrams up to the requested total buffered bytes limit,
   * and will drop new UDP datagrams if the buffer contains the max_buffered_datagrams value
   * at the time of a new datagram arrival. If not set, the default value is 16,384 (16KB).
   */
  max_buffered_bytes?: number | undefined;
}

export interface UdpProxyConfig_UdpTunnelingConfig_RetryOptions {
  $type: "envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.UdpTunnelingConfig.RetryOptions";
  /**
   * The maximum number of unsuccessful connection attempts that will be made before giving up.
   * If the parameter is not specified, 1 connection attempt will be made.
   */
  max_connect_attempts?: number | undefined;
}

export interface UdpProxyConfig_UdpAccessLogOptions {
  $type: "envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.UdpAccessLogOptions";
  /**
   * The interval to flush access log. The UDP proxy will flush only one access log when the session
   * is ended by default. If this field is set, the UDP proxy will flush access log periodically with
   * the specified interval.
   * This field does not require on-tunnel-connected access logging enabled, and the other way around.
   * The interval must be at least 1ms.
   */
  access_log_flush_interval?:
    | Duration
    | undefined;
  /**
   * If set to true and UDP tunneling is configured, access log will be flushed when the UDP proxy has successfully
   * established a connection tunnel with the upstream. If the connection failed, the access log will not be flushed.
   */
  flush_access_log_on_tunnel_connected?: boolean | undefined;
}

function createBaseUdpProxyConfig(): UdpProxyConfig {
  return { $type: "envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig", route_specifier: undefined };
}

export const UdpProxyConfig: MessageFns<UdpProxyConfig, "envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig"> = {
  $type: "envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig" as const,

  encode(message: UdpProxyConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stat_prefix !== undefined && message.stat_prefix !== "") {
      writer.uint32(10).string(message.stat_prefix);
    }
    switch (message.route_specifier?.$case) {
      case "cluster":
        writer.uint32(18).string(message.route_specifier.cluster);
        break;
      case "matcher":
        Matcher.encode(message.route_specifier.matcher, writer.uint32(74).fork()).join();
        break;
    }
    if (message.idle_timeout !== undefined) {
      Duration.encode(message.idle_timeout, writer.uint32(26).fork()).join();
    }
    if (message.use_original_src_ip !== undefined && message.use_original_src_ip !== false) {
      writer.uint32(32).bool(message.use_original_src_ip);
    }
    if (message.hash_policies !== undefined && message.hash_policies.length !== 0) {
      for (const v of message.hash_policies) {
        UdpProxyConfig_HashPolicy.encode(v!, writer.uint32(42).fork()).join();
      }
    }
    if (message.upstream_socket_config !== undefined) {
      UdpSocketConfig.encode(message.upstream_socket_config, writer.uint32(50).fork()).join();
    }
    if (message.use_per_packet_load_balancing !== undefined && message.use_per_packet_load_balancing !== false) {
      writer.uint32(56).bool(message.use_per_packet_load_balancing);
    }
    if (message.access_log !== undefined && message.access_log.length !== 0) {
      for (const v of message.access_log) {
        AccessLog.encode(v!, writer.uint32(66).fork()).join();
      }
    }
    if (message.proxy_access_log !== undefined && message.proxy_access_log.length !== 0) {
      for (const v of message.proxy_access_log) {
        AccessLog.encode(v!, writer.uint32(82).fork()).join();
      }
    }
    if (message.session_filters !== undefined && message.session_filters.length !== 0) {
      for (const v of message.session_filters) {
        UdpProxyConfig_SessionFilter.encode(v!, writer.uint32(90).fork()).join();
      }
    }
    if (message.tunneling_config !== undefined) {
      UdpProxyConfig_UdpTunnelingConfig.encode(message.tunneling_config, writer.uint32(98).fork()).join();
    }
    if (message.access_log_options !== undefined) {
      UdpProxyConfig_UdpAccessLogOptions.encode(message.access_log_options, writer.uint32(106).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UdpProxyConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUdpProxyConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stat_prefix = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.route_specifier = { $case: "cluster", cluster: reader.string() };
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.route_specifier = { $case: "matcher", matcher: Matcher.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.idle_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.use_original_src_ip = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          if (message.hash_policies === undefined) {
            message.hash_policies = [];
          }
          const el = UdpProxyConfig_HashPolicy.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.hash_policies!.push(el);
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.upstream_socket_config = UdpSocketConfig.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.use_per_packet_load_balancing = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          if (message.access_log === undefined) {
            message.access_log = [];
          }
          const el = AccessLog.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.access_log!.push(el);
          }
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          if (message.proxy_access_log === undefined) {
            message.proxy_access_log = [];
          }
          const el = AccessLog.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.proxy_access_log!.push(el);
          }
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          if (message.session_filters === undefined) {
            message.session_filters = [];
          }
          const el = UdpProxyConfig_SessionFilter.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.session_filters!.push(el);
          }
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.tunneling_config = UdpProxyConfig_UdpTunnelingConfig.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.access_log_options = UdpProxyConfig_UdpAccessLogOptions.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UdpProxyConfig {
    return {
      $type: UdpProxyConfig.$type,
      stat_prefix: isSet(object.stat_prefix) ? globalThis.String(object.stat_prefix) : undefined,
      route_specifier: isSet(object.cluster)
        ? { $case: "cluster", cluster: globalThis.String(object.cluster) }
        : isSet(object.matcher)
        ? { $case: "matcher", matcher: Matcher.fromJSON(object.matcher) }
        : undefined,
      idle_timeout: isSet(object.idle_timeout) ? Duration.fromJSON(object.idle_timeout) : undefined,
      use_original_src_ip: isSet(object.use_original_src_ip)
        ? globalThis.Boolean(object.use_original_src_ip)
        : undefined,
      hash_policies: globalThis.Array.isArray(object?.hash_policies)
        ? object.hash_policies.map((e: any) => UdpProxyConfig_HashPolicy.fromJSON(e))
        : undefined,
      upstream_socket_config: isSet(object.upstream_socket_config)
        ? UdpSocketConfig.fromJSON(object.upstream_socket_config)
        : undefined,
      use_per_packet_load_balancing: isSet(object.use_per_packet_load_balancing)
        ? globalThis.Boolean(object.use_per_packet_load_balancing)
        : undefined,
      access_log: globalThis.Array.isArray(object?.access_log)
        ? object.access_log.map((e: any) => AccessLog.fromJSON(e))
        : undefined,
      proxy_access_log: globalThis.Array.isArray(object?.proxy_access_log)
        ? object.proxy_access_log.map((e: any) => AccessLog.fromJSON(e))
        : undefined,
      session_filters: globalThis.Array.isArray(object?.session_filters)
        ? object.session_filters.map((e: any) => UdpProxyConfig_SessionFilter.fromJSON(e))
        : undefined,
      tunneling_config: isSet(object.tunneling_config)
        ? UdpProxyConfig_UdpTunnelingConfig.fromJSON(object.tunneling_config)
        : undefined,
      access_log_options: isSet(object.access_log_options)
        ? UdpProxyConfig_UdpAccessLogOptions.fromJSON(object.access_log_options)
        : undefined,
    };
  },

  toJSON(message: UdpProxyConfig): unknown {
    const obj: any = {};
    if (message.stat_prefix !== undefined) {
      obj.stat_prefix = message.stat_prefix;
    }
    if (message.route_specifier?.$case === "cluster") {
      obj.cluster = message.route_specifier.cluster;
    }
    if (message.route_specifier?.$case === "matcher") {
      obj.matcher = Matcher.toJSON(message.route_specifier.matcher);
    }
    if (message.idle_timeout !== undefined) {
      obj.idle_timeout = Duration.toJSON(message.idle_timeout);
    }
    if (message.use_original_src_ip !== undefined) {
      obj.use_original_src_ip = message.use_original_src_ip;
    }
    if (message.hash_policies?.length) {
      obj.hash_policies = message.hash_policies.map((e) => UdpProxyConfig_HashPolicy.toJSON(e));
    }
    if (message.upstream_socket_config !== undefined) {
      obj.upstream_socket_config = UdpSocketConfig.toJSON(message.upstream_socket_config);
    }
    if (message.use_per_packet_load_balancing !== undefined) {
      obj.use_per_packet_load_balancing = message.use_per_packet_load_balancing;
    }
    if (message.access_log?.length) {
      obj.access_log = message.access_log.map((e) => AccessLog.toJSON(e));
    }
    if (message.proxy_access_log?.length) {
      obj.proxy_access_log = message.proxy_access_log.map((e) => AccessLog.toJSON(e));
    }
    if (message.session_filters?.length) {
      obj.session_filters = message.session_filters.map((e) => UdpProxyConfig_SessionFilter.toJSON(e));
    }
    if (message.tunneling_config !== undefined) {
      obj.tunneling_config = UdpProxyConfig_UdpTunnelingConfig.toJSON(message.tunneling_config);
    }
    if (message.access_log_options !== undefined) {
      obj.access_log_options = UdpProxyConfig_UdpAccessLogOptions.toJSON(message.access_log_options);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UdpProxyConfig>, I>>(base?: I): UdpProxyConfig {
    return UdpProxyConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UdpProxyConfig>, I>>(object: I): UdpProxyConfig {
    const message = createBaseUdpProxyConfig();
    message.stat_prefix = object.stat_prefix ?? undefined;
    if (
      object.route_specifier?.$case === "cluster" &&
      object.route_specifier?.cluster !== undefined &&
      object.route_specifier?.cluster !== null
    ) {
      message.route_specifier = { $case: "cluster", cluster: object.route_specifier.cluster };
    }
    if (
      object.route_specifier?.$case === "matcher" &&
      object.route_specifier?.matcher !== undefined &&
      object.route_specifier?.matcher !== null
    ) {
      message.route_specifier = { $case: "matcher", matcher: Matcher.fromPartial(object.route_specifier.matcher) };
    }
    message.idle_timeout = (object.idle_timeout !== undefined && object.idle_timeout !== null)
      ? Duration.fromPartial(object.idle_timeout)
      : undefined;
    message.use_original_src_ip = object.use_original_src_ip ?? undefined;
    message.hash_policies = object.hash_policies?.map((e) => UdpProxyConfig_HashPolicy.fromPartial(e)) || undefined;
    message.upstream_socket_config =
      (object.upstream_socket_config !== undefined && object.upstream_socket_config !== null)
        ? UdpSocketConfig.fromPartial(object.upstream_socket_config)
        : undefined;
    message.use_per_packet_load_balancing = object.use_per_packet_load_balancing ?? undefined;
    message.access_log = object.access_log?.map((e) => AccessLog.fromPartial(e)) || undefined;
    message.proxy_access_log = object.proxy_access_log?.map((e) => AccessLog.fromPartial(e)) || undefined;
    message.session_filters = object.session_filters?.map((e) => UdpProxyConfig_SessionFilter.fromPartial(e)) ||
      undefined;
    message.tunneling_config = (object.tunneling_config !== undefined && object.tunneling_config !== null)
      ? UdpProxyConfig_UdpTunnelingConfig.fromPartial(object.tunneling_config)
      : undefined;
    message.access_log_options = (object.access_log_options !== undefined && object.access_log_options !== null)
      ? UdpProxyConfig_UdpAccessLogOptions.fromPartial(object.access_log_options)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(UdpProxyConfig.$type, UdpProxyConfig);

function createBaseUdpProxyConfig_HashPolicy(): UdpProxyConfig_HashPolicy {
  return { $type: "envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.HashPolicy", policy_specifier: undefined };
}

export const UdpProxyConfig_HashPolicy: MessageFns<
  UdpProxyConfig_HashPolicy,
  "envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.HashPolicy"
> = {
  $type: "envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.HashPolicy" as const,

  encode(message: UdpProxyConfig_HashPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.policy_specifier?.$case) {
      case "source_ip":
        writer.uint32(8).bool(message.policy_specifier.source_ip);
        break;
      case "key":
        writer.uint32(18).string(message.policy_specifier.key);
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UdpProxyConfig_HashPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUdpProxyConfig_HashPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.policy_specifier = { $case: "source_ip", source_ip: reader.bool() };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.policy_specifier = { $case: "key", key: reader.string() };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UdpProxyConfig_HashPolicy {
    return {
      $type: UdpProxyConfig_HashPolicy.$type,
      policy_specifier: isSet(object.source_ip)
        ? { $case: "source_ip", source_ip: globalThis.Boolean(object.source_ip) }
        : isSet(object.key)
        ? { $case: "key", key: globalThis.String(object.key) }
        : undefined,
    };
  },

  toJSON(message: UdpProxyConfig_HashPolicy): unknown {
    const obj: any = {};
    if (message.policy_specifier?.$case === "source_ip") {
      obj.source_ip = message.policy_specifier.source_ip;
    }
    if (message.policy_specifier?.$case === "key") {
      obj.key = message.policy_specifier.key;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UdpProxyConfig_HashPolicy>, I>>(base?: I): UdpProxyConfig_HashPolicy {
    return UdpProxyConfig_HashPolicy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UdpProxyConfig_HashPolicy>, I>>(object: I): UdpProxyConfig_HashPolicy {
    const message = createBaseUdpProxyConfig_HashPolicy();
    if (
      object.policy_specifier?.$case === "source_ip" &&
      object.policy_specifier?.source_ip !== undefined &&
      object.policy_specifier?.source_ip !== null
    ) {
      message.policy_specifier = { $case: "source_ip", source_ip: object.policy_specifier.source_ip };
    }
    if (
      object.policy_specifier?.$case === "key" &&
      object.policy_specifier?.key !== undefined &&
      object.policy_specifier?.key !== null
    ) {
      message.policy_specifier = { $case: "key", key: object.policy_specifier.key };
    }
    return message;
  },
};

messageTypeRegistry.set(UdpProxyConfig_HashPolicy.$type, UdpProxyConfig_HashPolicy);

function createBaseUdpProxyConfig_SessionFilter(): UdpProxyConfig_SessionFilter {
  return { $type: "envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.SessionFilter", config_type: undefined };
}

export const UdpProxyConfig_SessionFilter: MessageFns<
  UdpProxyConfig_SessionFilter,
  "envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.SessionFilter"
> = {
  $type: "envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.SessionFilter" as const,

  encode(message: UdpProxyConfig_SessionFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    switch (message.config_type?.$case) {
      case "typed_config":
        Any.encode(message.config_type.typed_config, writer.uint32(18).fork()).join();
        break;
      case "config_discovery":
        ExtensionConfigSource.encode(message.config_type.config_discovery, writer.uint32(26).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UdpProxyConfig_SessionFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUdpProxyConfig_SessionFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.config_type = { $case: "typed_config", typed_config: Any.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.config_type = {
            $case: "config_discovery",
            config_discovery: ExtensionConfigSource.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UdpProxyConfig_SessionFilter {
    return {
      $type: UdpProxyConfig_SessionFilter.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      config_type: isSet(object.typed_config)
        ? { $case: "typed_config", typed_config: Any.fromJSON(object.typed_config) }
        : isSet(object.config_discovery)
        ? { $case: "config_discovery", config_discovery: ExtensionConfigSource.fromJSON(object.config_discovery) }
        : undefined,
    };
  },

  toJSON(message: UdpProxyConfig_SessionFilter): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.config_type?.$case === "typed_config") {
      obj.typed_config = Any.toJSON(message.config_type.typed_config);
    }
    if (message.config_type?.$case === "config_discovery") {
      obj.config_discovery = ExtensionConfigSource.toJSON(message.config_type.config_discovery);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UdpProxyConfig_SessionFilter>, I>>(base?: I): UdpProxyConfig_SessionFilter {
    return UdpProxyConfig_SessionFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UdpProxyConfig_SessionFilter>, I>>(object: I): UdpProxyConfig_SessionFilter {
    const message = createBaseUdpProxyConfig_SessionFilter();
    message.name = object.name ?? undefined;
    if (
      object.config_type?.$case === "typed_config" &&
      object.config_type?.typed_config !== undefined &&
      object.config_type?.typed_config !== null
    ) {
      message.config_type = { $case: "typed_config", typed_config: Any.fromPartial(object.config_type.typed_config) };
    }
    if (
      object.config_type?.$case === "config_discovery" &&
      object.config_type?.config_discovery !== undefined &&
      object.config_type?.config_discovery !== null
    ) {
      message.config_type = {
        $case: "config_discovery",
        config_discovery: ExtensionConfigSource.fromPartial(object.config_type.config_discovery),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(UdpProxyConfig_SessionFilter.$type, UdpProxyConfig_SessionFilter);

function createBaseUdpProxyConfig_UdpTunnelingConfig(): UdpProxyConfig_UdpTunnelingConfig {
  return { $type: "envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.UdpTunnelingConfig" };
}

export const UdpProxyConfig_UdpTunnelingConfig: MessageFns<
  UdpProxyConfig_UdpTunnelingConfig,
  "envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.UdpTunnelingConfig"
> = {
  $type: "envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.UdpTunnelingConfig" as const,

  encode(message: UdpProxyConfig_UdpTunnelingConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.proxy_host !== undefined && message.proxy_host !== "") {
      writer.uint32(10).string(message.proxy_host);
    }
    if (message.proxy_port !== undefined) {
      UInt32Value.encode({ $type: "google.protobuf.UInt32Value", value: message.proxy_port! }, writer.uint32(18).fork())
        .join();
    }
    if (message.target_host !== undefined && message.target_host !== "") {
      writer.uint32(26).string(message.target_host);
    }
    if (message.default_target_port !== undefined && message.default_target_port !== 0) {
      writer.uint32(32).uint32(message.default_target_port);
    }
    if (message.use_post !== undefined && message.use_post !== false) {
      writer.uint32(40).bool(message.use_post);
    }
    if (message.post_path !== undefined && message.post_path !== "") {
      writer.uint32(50).string(message.post_path);
    }
    if (message.retry_options !== undefined) {
      UdpProxyConfig_UdpTunnelingConfig_RetryOptions.encode(message.retry_options, writer.uint32(58).fork()).join();
    }
    if (message.headers_to_add !== undefined && message.headers_to_add.length !== 0) {
      for (const v of message.headers_to_add) {
        HeaderValueOption.encode(v!, writer.uint32(66).fork()).join();
      }
    }
    if (message.buffer_options !== undefined) {
      UdpProxyConfig_UdpTunnelingConfig_BufferOptions.encode(message.buffer_options, writer.uint32(74).fork()).join();
    }
    if (message.propagate_response_headers !== undefined && message.propagate_response_headers !== false) {
      writer.uint32(80).bool(message.propagate_response_headers);
    }
    if (message.propagate_response_trailers !== undefined && message.propagate_response_trailers !== false) {
      writer.uint32(88).bool(message.propagate_response_trailers);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UdpProxyConfig_UdpTunnelingConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUdpProxyConfig_UdpTunnelingConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.proxy_host = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.proxy_port = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.target_host = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.default_target_port = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.use_post = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.post_path = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.retry_options = UdpProxyConfig_UdpTunnelingConfig_RetryOptions.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          if (message.headers_to_add === undefined) {
            message.headers_to_add = [];
          }
          const el = HeaderValueOption.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.headers_to_add!.push(el);
          }
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.buffer_options = UdpProxyConfig_UdpTunnelingConfig_BufferOptions.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.propagate_response_headers = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.propagate_response_trailers = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UdpProxyConfig_UdpTunnelingConfig {
    return {
      $type: UdpProxyConfig_UdpTunnelingConfig.$type,
      proxy_host: isSet(object.proxy_host) ? globalThis.String(object.proxy_host) : undefined,
      proxy_port: isSet(object.proxy_port) ? Number(object.proxy_port) : undefined,
      target_host: isSet(object.target_host) ? globalThis.String(object.target_host) : undefined,
      default_target_port: isSet(object.default_target_port)
        ? globalThis.Number(object.default_target_port)
        : undefined,
      use_post: isSet(object.use_post) ? globalThis.Boolean(object.use_post) : undefined,
      post_path: isSet(object.post_path) ? globalThis.String(object.post_path) : undefined,
      retry_options: isSet(object.retry_options)
        ? UdpProxyConfig_UdpTunnelingConfig_RetryOptions.fromJSON(object.retry_options)
        : undefined,
      headers_to_add: globalThis.Array.isArray(object?.headers_to_add)
        ? object.headers_to_add.map((e: any) => HeaderValueOption.fromJSON(e))
        : undefined,
      buffer_options: isSet(object.buffer_options)
        ? UdpProxyConfig_UdpTunnelingConfig_BufferOptions.fromJSON(object.buffer_options)
        : undefined,
      propagate_response_headers: isSet(object.propagate_response_headers)
        ? globalThis.Boolean(object.propagate_response_headers)
        : undefined,
      propagate_response_trailers: isSet(object.propagate_response_trailers)
        ? globalThis.Boolean(object.propagate_response_trailers)
        : undefined,
    };
  },

  toJSON(message: UdpProxyConfig_UdpTunnelingConfig): unknown {
    const obj: any = {};
    if (message.proxy_host !== undefined) {
      obj.proxy_host = message.proxy_host;
    }
    if (message.proxy_port !== undefined) {
      obj.proxy_port = message.proxy_port;
    }
    if (message.target_host !== undefined) {
      obj.target_host = message.target_host;
    }
    if (message.default_target_port !== undefined) {
      obj.default_target_port = Math.round(message.default_target_port);
    }
    if (message.use_post !== undefined) {
      obj.use_post = message.use_post;
    }
    if (message.post_path !== undefined) {
      obj.post_path = message.post_path;
    }
    if (message.retry_options !== undefined) {
      obj.retry_options = UdpProxyConfig_UdpTunnelingConfig_RetryOptions.toJSON(message.retry_options);
    }
    if (message.headers_to_add?.length) {
      obj.headers_to_add = message.headers_to_add.map((e) => HeaderValueOption.toJSON(e));
    }
    if (message.buffer_options !== undefined) {
      obj.buffer_options = UdpProxyConfig_UdpTunnelingConfig_BufferOptions.toJSON(message.buffer_options);
    }
    if (message.propagate_response_headers !== undefined) {
      obj.propagate_response_headers = message.propagate_response_headers;
    }
    if (message.propagate_response_trailers !== undefined) {
      obj.propagate_response_trailers = message.propagate_response_trailers;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UdpProxyConfig_UdpTunnelingConfig>, I>>(
    base?: I,
  ): UdpProxyConfig_UdpTunnelingConfig {
    return UdpProxyConfig_UdpTunnelingConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UdpProxyConfig_UdpTunnelingConfig>, I>>(
    object: I,
  ): UdpProxyConfig_UdpTunnelingConfig {
    const message = createBaseUdpProxyConfig_UdpTunnelingConfig();
    message.proxy_host = object.proxy_host ?? undefined;
    message.proxy_port = object.proxy_port ?? undefined;
    message.target_host = object.target_host ?? undefined;
    message.default_target_port = object.default_target_port ?? undefined;
    message.use_post = object.use_post ?? undefined;
    message.post_path = object.post_path ?? undefined;
    message.retry_options = (object.retry_options !== undefined && object.retry_options !== null)
      ? UdpProxyConfig_UdpTunnelingConfig_RetryOptions.fromPartial(object.retry_options)
      : undefined;
    message.headers_to_add = object.headers_to_add?.map((e) => HeaderValueOption.fromPartial(e)) || undefined;
    message.buffer_options = (object.buffer_options !== undefined && object.buffer_options !== null)
      ? UdpProxyConfig_UdpTunnelingConfig_BufferOptions.fromPartial(object.buffer_options)
      : undefined;
    message.propagate_response_headers = object.propagate_response_headers ?? undefined;
    message.propagate_response_trailers = object.propagate_response_trailers ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(UdpProxyConfig_UdpTunnelingConfig.$type, UdpProxyConfig_UdpTunnelingConfig);

function createBaseUdpProxyConfig_UdpTunnelingConfig_BufferOptions(): UdpProxyConfig_UdpTunnelingConfig_BufferOptions {
  return { $type: "envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.UdpTunnelingConfig.BufferOptions" };
}

export const UdpProxyConfig_UdpTunnelingConfig_BufferOptions: MessageFns<
  UdpProxyConfig_UdpTunnelingConfig_BufferOptions,
  "envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.UdpTunnelingConfig.BufferOptions"
> = {
  $type: "envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.UdpTunnelingConfig.BufferOptions" as const,

  encode(
    message: UdpProxyConfig_UdpTunnelingConfig_BufferOptions,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.max_buffered_datagrams !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.max_buffered_datagrams! },
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.max_buffered_bytes !== undefined) {
      UInt64Value.encode(
        { $type: "google.protobuf.UInt64Value", value: message.max_buffered_bytes! },
        writer.uint32(18).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UdpProxyConfig_UdpTunnelingConfig_BufferOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUdpProxyConfig_UdpTunnelingConfig_BufferOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.max_buffered_datagrams = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.max_buffered_bytes = UInt64Value.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UdpProxyConfig_UdpTunnelingConfig_BufferOptions {
    return {
      $type: UdpProxyConfig_UdpTunnelingConfig_BufferOptions.$type,
      max_buffered_datagrams: isSet(object.max_buffered_datagrams) ? Number(object.max_buffered_datagrams) : undefined,
      max_buffered_bytes: isSet(object.max_buffered_bytes) ? Number(object.max_buffered_bytes) : undefined,
    };
  },

  toJSON(message: UdpProxyConfig_UdpTunnelingConfig_BufferOptions): unknown {
    const obj: any = {};
    if (message.max_buffered_datagrams !== undefined) {
      obj.max_buffered_datagrams = message.max_buffered_datagrams;
    }
    if (message.max_buffered_bytes !== undefined) {
      obj.max_buffered_bytes = message.max_buffered_bytes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UdpProxyConfig_UdpTunnelingConfig_BufferOptions>, I>>(
    base?: I,
  ): UdpProxyConfig_UdpTunnelingConfig_BufferOptions {
    return UdpProxyConfig_UdpTunnelingConfig_BufferOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UdpProxyConfig_UdpTunnelingConfig_BufferOptions>, I>>(
    object: I,
  ): UdpProxyConfig_UdpTunnelingConfig_BufferOptions {
    const message = createBaseUdpProxyConfig_UdpTunnelingConfig_BufferOptions();
    message.max_buffered_datagrams = object.max_buffered_datagrams ?? undefined;
    message.max_buffered_bytes = object.max_buffered_bytes ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(
  UdpProxyConfig_UdpTunnelingConfig_BufferOptions.$type,
  UdpProxyConfig_UdpTunnelingConfig_BufferOptions,
);

function createBaseUdpProxyConfig_UdpTunnelingConfig_RetryOptions(): UdpProxyConfig_UdpTunnelingConfig_RetryOptions {
  return { $type: "envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.UdpTunnelingConfig.RetryOptions" };
}

export const UdpProxyConfig_UdpTunnelingConfig_RetryOptions: MessageFns<
  UdpProxyConfig_UdpTunnelingConfig_RetryOptions,
  "envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.UdpTunnelingConfig.RetryOptions"
> = {
  $type: "envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.UdpTunnelingConfig.RetryOptions" as const,

  encode(
    message: UdpProxyConfig_UdpTunnelingConfig_RetryOptions,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.max_connect_attempts !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.max_connect_attempts! },
        writer.uint32(10).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UdpProxyConfig_UdpTunnelingConfig_RetryOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUdpProxyConfig_UdpTunnelingConfig_RetryOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.max_connect_attempts = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UdpProxyConfig_UdpTunnelingConfig_RetryOptions {
    return {
      $type: UdpProxyConfig_UdpTunnelingConfig_RetryOptions.$type,
      max_connect_attempts: isSet(object.max_connect_attempts) ? Number(object.max_connect_attempts) : undefined,
    };
  },

  toJSON(message: UdpProxyConfig_UdpTunnelingConfig_RetryOptions): unknown {
    const obj: any = {};
    if (message.max_connect_attempts !== undefined) {
      obj.max_connect_attempts = message.max_connect_attempts;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UdpProxyConfig_UdpTunnelingConfig_RetryOptions>, I>>(
    base?: I,
  ): UdpProxyConfig_UdpTunnelingConfig_RetryOptions {
    return UdpProxyConfig_UdpTunnelingConfig_RetryOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UdpProxyConfig_UdpTunnelingConfig_RetryOptions>, I>>(
    object: I,
  ): UdpProxyConfig_UdpTunnelingConfig_RetryOptions {
    const message = createBaseUdpProxyConfig_UdpTunnelingConfig_RetryOptions();
    message.max_connect_attempts = object.max_connect_attempts ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(
  UdpProxyConfig_UdpTunnelingConfig_RetryOptions.$type,
  UdpProxyConfig_UdpTunnelingConfig_RetryOptions,
);

function createBaseUdpProxyConfig_UdpAccessLogOptions(): UdpProxyConfig_UdpAccessLogOptions {
  return { $type: "envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.UdpAccessLogOptions" };
}

export const UdpProxyConfig_UdpAccessLogOptions: MessageFns<
  UdpProxyConfig_UdpAccessLogOptions,
  "envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.UdpAccessLogOptions"
> = {
  $type: "envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.UdpAccessLogOptions" as const,

  encode(message: UdpProxyConfig_UdpAccessLogOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.access_log_flush_interval !== undefined) {
      Duration.encode(message.access_log_flush_interval, writer.uint32(10).fork()).join();
    }
    if (
      message.flush_access_log_on_tunnel_connected !== undefined &&
      message.flush_access_log_on_tunnel_connected !== false
    ) {
      writer.uint32(16).bool(message.flush_access_log_on_tunnel_connected);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UdpProxyConfig_UdpAccessLogOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUdpProxyConfig_UdpAccessLogOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.access_log_flush_interval = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.flush_access_log_on_tunnel_connected = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UdpProxyConfig_UdpAccessLogOptions {
    return {
      $type: UdpProxyConfig_UdpAccessLogOptions.$type,
      access_log_flush_interval: isSet(object.access_log_flush_interval)
        ? Duration.fromJSON(object.access_log_flush_interval)
        : undefined,
      flush_access_log_on_tunnel_connected: isSet(object.flush_access_log_on_tunnel_connected)
        ? globalThis.Boolean(object.flush_access_log_on_tunnel_connected)
        : undefined,
    };
  },

  toJSON(message: UdpProxyConfig_UdpAccessLogOptions): unknown {
    const obj: any = {};
    if (message.access_log_flush_interval !== undefined) {
      obj.access_log_flush_interval = Duration.toJSON(message.access_log_flush_interval);
    }
    if (message.flush_access_log_on_tunnel_connected !== undefined) {
      obj.flush_access_log_on_tunnel_connected = message.flush_access_log_on_tunnel_connected;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UdpProxyConfig_UdpAccessLogOptions>, I>>(
    base?: I,
  ): UdpProxyConfig_UdpAccessLogOptions {
    return UdpProxyConfig_UdpAccessLogOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UdpProxyConfig_UdpAccessLogOptions>, I>>(
    object: I,
  ): UdpProxyConfig_UdpAccessLogOptions {
    const message = createBaseUdpProxyConfig_UdpAccessLogOptions();
    message.access_log_flush_interval =
      (object.access_log_flush_interval !== undefined && object.access_log_flush_interval !== null)
        ? Duration.fromPartial(object.access_log_flush_interval)
        : undefined;
    message.flush_access_log_on_tunnel_connected = object.flush_access_log_on_tunnel_connected ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(UdpProxyConfig_UdpAccessLogOptions.$type, UdpProxyConfig_UdpAccessLogOptions);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
