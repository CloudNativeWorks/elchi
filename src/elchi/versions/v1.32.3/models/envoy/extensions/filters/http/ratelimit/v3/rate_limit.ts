// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/filters/http/ratelimit/v3/rate_limit.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../../../../google/protobuf/duration";
import { messageTypeRegistry } from "../../../../../../typeRegistry";
import { HeaderValueOption } from "../../../../../config/core/v3/base";
import { TypedExtensionConfig } from "../../../../../config/core/v3/extension";
import { RateLimitServiceConfig } from "../../../../../config/ratelimit/v3/rls";
import { HeaderMatcher } from "../../../../../config/route/v3/route_components";
import { MetadataKey } from "../../../../../type/metadata/v3/metadata";
import { HttpStatus } from "../../../../../type/v3/http_status";

export const protobufPackage = "envoy.extensions.filters.http.ratelimit.v3";

/** [#next-free-field: 14] */
export interface RateLimit {
  $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimit";
  /** The rate limit domain to use when calling the rate limit service. */
  domain?:
    | string
    | undefined;
  /**
   * Specifies the rate limit configurations to be applied with the same
   * stage number. If not set, the default stage number is 0.
   *
   * .. note::
   *
   *  The filter supports a range of 0 - 10 inclusively for stage numbers.
   */
  stage?:
    | number
    | undefined;
  /**
   * The type of requests the filter should apply to. The supported
   * types are ``internal``, ``external`` or ``both``. A request is considered internal if
   * :ref:`x-envoy-internal<config_http_conn_man_headers_x-envoy-internal>` is set to true. If
   * :ref:`x-envoy-internal<config_http_conn_man_headers_x-envoy-internal>` is not set or false, a
   * request is considered external. The filter defaults to ``both``, and it will apply to all request
   * types.
   */
  request_type?:
    | string
    | undefined;
  /**
   * The timeout in milliseconds for the rate limit service RPC. If not
   * set, this defaults to 20ms.
   */
  timeout?:
    | Duration
    | undefined;
  /**
   * The filter's behaviour in case the rate limiting service does
   * not respond back. When it is set to true, Envoy will not allow traffic in case of
   * communication failure between rate limiting service and the proxy.
   */
  failure_mode_deny?:
    | boolean
    | undefined;
  /**
   * Specifies whether a ``RESOURCE_EXHAUSTED`` gRPC code must be returned instead
   * of the default ``UNAVAILABLE`` gRPC code for a rate limited gRPC call. The
   * HTTP code will be 200 for a gRPC response.
   */
  rate_limited_as_resource_exhausted?:
    | boolean
    | undefined;
  /**
   * Configuration for an external rate limit service provider. If not
   * specified, any calls to the rate limit service will immediately return
   * success.
   */
  rate_limit_service?:
    | RateLimitServiceConfig
    | undefined;
  /**
   * Defines the standard version to use for X-RateLimit headers emitted by the filter:
   *
   * * ``X-RateLimit-Limit`` - indicates the request-quota associated to the
   *   client in the current time-window followed by the description of the
   *   quota policy. The values are returned by the rate limiting service in
   *   :ref:`current_limit<envoy_v3_api_field_service.ratelimit.v3.RateLimitResponse.DescriptorStatus.current_limit>`
   *   field. Example: ``10, 10;w=1;name="per-ip", 1000;w=3600``.
   * * ``X-RateLimit-Remaining`` - indicates the remaining requests in the
   *   current time-window. The values are returned by the rate limiting service
   *   in :ref:`limit_remaining<envoy_v3_api_field_service.ratelimit.v3.RateLimitResponse.DescriptorStatus.limit_remaining>`
   *   field.
   * * ``X-RateLimit-Reset`` - indicates the number of seconds until reset of
   *   the current time-window. The values are returned by the rate limiting service
   *   in :ref:`duration_until_reset<envoy_v3_api_field_service.ratelimit.v3.RateLimitResponse.DescriptorStatus.duration_until_reset>`
   *   field.
   *
   * In case rate limiting policy specifies more then one time window, the values
   * above represent the window that is closest to reaching its limit.
   *
   * For more information about the headers specification see selected version of
   * the `draft RFC <https://tools.ietf.org/id/draft-polli-ratelimit-headers-03.html>`_.
   *
   * Disabled by default.
   *
   * [#next-major-version: unify with local ratelimit, should use common.ratelimit.v3.XRateLimitHeadersRFCVersion instead.]
   */
  enable_x_ratelimit_headers?:
    | RateLimit_XRateLimitHeadersRFCVersion
    | undefined;
  /**
   * Disables emitting the :ref:`x-envoy-ratelimited<config_http_filters_router_x-envoy-ratelimited>` header
   * in case of rate limiting (i.e. 429 responses).
   * Having this header not present potentially makes the request retriable.
   */
  disable_x_envoy_ratelimited_header?:
    | boolean
    | undefined;
  /**
   * This field allows for a custom HTTP response status code to the downstream client when
   * the request has been rate limited.
   * Defaults to 429 (TooManyRequests).
   *
   * .. note::
   *   If this is set to < 400, 429 will be used instead.
   */
  rate_limited_status?:
    | HttpStatus
    | undefined;
  /**
   * Specifies a list of HTTP headers that should be added to each response for requests that
   * have been rate limited.
   */
  response_headers_to_add?:
    | HeaderValueOption[]
    | undefined;
  /**
   * Sets the HTTP status that is returned to the client when the ratelimit server returns an error
   * or cannot be reached. The default status is 500.
   */
  status_on_error?:
    | HttpStatus
    | undefined;
  /**
   * Optional additional prefix to use when emitting statistics. This allows to distinguish
   * emitted statistics between configured ``ratelimit`` filters in an HTTP filter chain.
   */
  stat_prefix?: string | undefined;
}

/**
 * Defines the version of the standard to use for X-RateLimit headers.
 *
 * [#next-major-version: unify with local ratelimit, should use common.ratelimit.v3.XRateLimitHeadersRFCVersion instead.]
 */
export enum RateLimit_XRateLimitHeadersRFCVersion {
  /** OFF - X-RateLimit headers disabled. */
  OFF = "OFF",
  /** DRAFT_VERSION_03 - Use `draft RFC Version 03 <https://tools.ietf.org/id/draft-polli-ratelimit-headers-03.html>`_. */
  DRAFT_VERSION_03 = "DRAFT_VERSION_03",
}

export function rateLimit_XRateLimitHeadersRFCVersionFromJSON(object: any): RateLimit_XRateLimitHeadersRFCVersion {
  switch (object) {
    case 0:
    case "OFF":
      return RateLimit_XRateLimitHeadersRFCVersion.OFF;
    case 1:
    case "DRAFT_VERSION_03":
      return RateLimit_XRateLimitHeadersRFCVersion.DRAFT_VERSION_03;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum RateLimit_XRateLimitHeadersRFCVersion",
      );
  }
}

export function rateLimit_XRateLimitHeadersRFCVersionToJSON(object: RateLimit_XRateLimitHeadersRFCVersion): string {
  switch (object) {
    case RateLimit_XRateLimitHeadersRFCVersion.OFF:
      return "OFF";
    case RateLimit_XRateLimitHeadersRFCVersion.DRAFT_VERSION_03:
      return "DRAFT_VERSION_03";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum RateLimit_XRateLimitHeadersRFCVersion",
      );
  }
}

export function rateLimit_XRateLimitHeadersRFCVersionToNumber(object: RateLimit_XRateLimitHeadersRFCVersion): number {
  switch (object) {
    case RateLimit_XRateLimitHeadersRFCVersion.OFF:
      return 0;
    case RateLimit_XRateLimitHeadersRFCVersion.DRAFT_VERSION_03:
      return 1;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum RateLimit_XRateLimitHeadersRFCVersion",
      );
  }
}

/**
 * Global rate limiting :ref:`architecture overview <arch_overview_global_rate_limit>`.
 * Also applies to Local rate limiting :ref:`using descriptors <config_http_filters_local_rate_limit_descriptors>`.
 * [#not-implemented-hide:]
 */
export interface RateLimitConfig {
  $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig";
  /**
   * Refers to the stage set in the filter. The rate limit configuration only
   * applies to filters with the same stage number. The default stage number is
   * 0.
   *
   * .. note::
   *
   *   The filter supports a range of 0 - 10 inclusively for stage numbers.
   */
  stage?:
    | number
    | undefined;
  /** The key to be set in runtime to disable this rate limit configuration. */
  disable_key?:
    | string
    | undefined;
  /**
   * A list of actions that are to be applied for this rate limit configuration.
   * Order matters as the actions are processed sequentially and the descriptor
   * is composed by appending descriptor entries in that sequence. If an action
   * cannot append a descriptor entry, no descriptor is generated for the
   * configuration. See :ref:`composing actions
   * <config_http_filters_rate_limit_composing_actions>` for additional documentation.
   */
  actions?:
    | RateLimitConfig_Action[]
    | undefined;
  /**
   * An optional limit override to be appended to the descriptor produced by this
   * rate limit configuration. If the override value is invalid or cannot be resolved
   * from metadata, no override is provided. See :ref:`rate limit override
   * <config_http_filters_rate_limit_rate_limit_override>` for more information.
   */
  limit?: RateLimitConfig_Override | undefined;
}

/** [#next-free-field: 10] */
export interface RateLimitConfig_Action {
  $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action";
  action_specifier?:
    | //
    /** Rate limit on source cluster. */
    { $case: "source_cluster"; source_cluster: RateLimitConfig_Action_SourceCluster }
    | //
    /** Rate limit on destination cluster. */
    { $case: "destination_cluster"; destination_cluster: RateLimitConfig_Action_DestinationCluster }
    | //
    /** Rate limit on request headers. */
    { $case: "request_headers"; request_headers: RateLimitConfig_Action_RequestHeaders }
    | //
    /** Rate limit on remote address. */
    { $case: "remote_address"; remote_address: RateLimitConfig_Action_RemoteAddress }
    | //
    /** Rate limit on a generic key. */
    { $case: "generic_key"; generic_key: RateLimitConfig_Action_GenericKey }
    | //
    /** Rate limit on the existence of request headers. */
    { $case: "header_value_match"; header_value_match: RateLimitConfig_Action_HeaderValueMatch }
    | //
    /** Rate limit on metadata. */
    { $case: "metadata"; metadata: RateLimitConfig_Action_MetaData }
    | //
    /**
     * Rate limit descriptor extension. See the rate limit descriptor extensions documentation.
     * [#extension-category: envoy.rate_limit_descriptors]
     */
    { $case: "extension"; extension: TypedExtensionConfig }
    | undefined;
}

/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("source_cluster", "<local service cluster>")
 *
 * <local service cluster> is derived from the :option:`--service-cluster` option.
 */
export interface RateLimitConfig_Action_SourceCluster {
  $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.SourceCluster";
}

/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("destination_cluster", "<routed target cluster>")
 *
 * Once a request matches against a route table rule, a routed cluster is determined by one of
 * the following :ref:`route table configuration <envoy_v3_api_msg_config.route.v3.RouteConfiguration>`
 * settings:
 *
 * * :ref:`cluster <envoy_v3_api_field_config.route.v3.RouteAction.cluster>` indicates the upstream cluster
 *   to route to.
 * * :ref:`weighted_clusters <envoy_v3_api_field_config.route.v3.RouteAction.weighted_clusters>`
 *   chooses a cluster randomly from a set of clusters with attributed weight.
 * * :ref:`cluster_header <envoy_v3_api_field_config.route.v3.RouteAction.cluster_header>` indicates which
 *   header in the request contains the target cluster.
 */
export interface RateLimitConfig_Action_DestinationCluster {
  $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.DestinationCluster";
}

/**
 * The following descriptor entry is appended when a header contains a key that matches the
 * ``header_name``:
 *
 * .. code-block:: cpp
 *
 *   ("<descriptor_key>", "<header_value_queried_from_header>")
 */
export interface RateLimitConfig_Action_RequestHeaders {
  $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.RequestHeaders";
  /**
   * The header name to be queried from the request headers. The header’s
   * value is used to populate the value of the descriptor entry for the
   * descriptor_key.
   */
  header_name?:
    | string
    | undefined;
  /** The key to use in the descriptor entry. */
  descriptor_key?:
    | string
    | undefined;
  /**
   * If set to true, Envoy skips the descriptor while calling rate limiting service
   * when header is not present in the request. By default it skips calling the
   * rate limiting service if this header is not present in the request.
   */
  skip_if_absent?: boolean | undefined;
}

/**
 * The following descriptor entry is appended to the descriptor and is populated using the
 * trusted address from :ref:`x-forwarded-for <config_http_conn_man_headers_x-forwarded-for>`:
 *
 * .. code-block:: cpp
 *
 *   ("remote_address", "<trusted address from x-forwarded-for>")
 */
export interface RateLimitConfig_Action_RemoteAddress {
  $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.RemoteAddress";
}

/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("generic_key", "<descriptor_value>")
 */
export interface RateLimitConfig_Action_GenericKey {
  $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.GenericKey";
  /** The value to use in the descriptor entry. */
  descriptor_value?:
    | string
    | undefined;
  /**
   * An optional key to use in the descriptor entry. If not set it defaults
   * to 'generic_key' as the descriptor key.
   */
  descriptor_key?: string | undefined;
}

/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("header_match", "<descriptor_value>")
 */
export interface RateLimitConfig_Action_HeaderValueMatch {
  $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.HeaderValueMatch";
  /** The value to use in the descriptor entry. */
  descriptor_value?:
    | string
    | undefined;
  /**
   * If set to true, the action will append a descriptor entry when the
   * request matches the headers. If set to false, the action will append a
   * descriptor entry when the request does not match the headers. The
   * default value is true.
   */
  expect_match?:
    | boolean
    | undefined;
  /**
   * Specifies a set of headers that the rate limit action should match
   * on. The action will check the request’s headers against all the
   * specified headers in the config. A match will happen if all the
   * headers in the config are present in the request with the same values
   * (or based on presence if the value field is not in the config).
   */
  headers?: HeaderMatcher[] | undefined;
}

/**
 * The following descriptor entry is appended when the metadata contains a key value:
 *
 * .. code-block:: cpp
 *
 *   ("<descriptor_key>", "<value_queried_from_metadata>")
 * [#next-free-field: 6]
 */
export interface RateLimitConfig_Action_MetaData {
  $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.MetaData";
  /** The key to use in the descriptor entry. */
  descriptor_key?:
    | string
    | undefined;
  /**
   * Metadata struct that defines the key and path to retrieve the string value. A match will
   * only happen if the value in the metadata is of type string.
   */
  metadata_key?:
    | MetadataKey
    | undefined;
  /**
   * An optional value to use if ``metadata_key`` is empty. If not set and
   * no value is present under the metadata_key then ``skip_if_absent`` is followed to
   * skip calling the rate limiting service or skip the descriptor.
   */
  default_value?:
    | string
    | undefined;
  /** Source of metadata */
  source?:
    | RateLimitConfig_Action_MetaData_Source
    | undefined;
  /**
   * If set to true, Envoy skips the descriptor while calling rate limiting service
   * when ``metadata_key`` is empty and ``default_value`` is not set. By default it skips calling the
   * rate limiting service in that case.
   */
  skip_if_absent?: boolean | undefined;
}

export enum RateLimitConfig_Action_MetaData_Source {
  /** DYNAMIC - Query :ref:`dynamic metadata <well_known_dynamic_metadata>` */
  DYNAMIC = "DYNAMIC",
  /** ROUTE_ENTRY - Query :ref:`route entry metadata <envoy_v3_api_field_config.route.v3.Route.metadata>` */
  ROUTE_ENTRY = "ROUTE_ENTRY",
}

export function rateLimitConfig_Action_MetaData_SourceFromJSON(object: any): RateLimitConfig_Action_MetaData_Source {
  switch (object) {
    case 0:
    case "DYNAMIC":
      return RateLimitConfig_Action_MetaData_Source.DYNAMIC;
    case 1:
    case "ROUTE_ENTRY":
      return RateLimitConfig_Action_MetaData_Source.ROUTE_ENTRY;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum RateLimitConfig_Action_MetaData_Source",
      );
  }
}

export function rateLimitConfig_Action_MetaData_SourceToJSON(object: RateLimitConfig_Action_MetaData_Source): string {
  switch (object) {
    case RateLimitConfig_Action_MetaData_Source.DYNAMIC:
      return "DYNAMIC";
    case RateLimitConfig_Action_MetaData_Source.ROUTE_ENTRY:
      return "ROUTE_ENTRY";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum RateLimitConfig_Action_MetaData_Source",
      );
  }
}

export function rateLimitConfig_Action_MetaData_SourceToNumber(object: RateLimitConfig_Action_MetaData_Source): number {
  switch (object) {
    case RateLimitConfig_Action_MetaData_Source.DYNAMIC:
      return 0;
    case RateLimitConfig_Action_MetaData_Source.ROUTE_ENTRY:
      return 1;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum RateLimitConfig_Action_MetaData_Source",
      );
  }
}

export interface RateLimitConfig_Override {
  $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Override";
  override_specifier?:
    | //
    /** Limit override from dynamic metadata. */
    { $case: "dynamic_metadata"; dynamic_metadata: RateLimitConfig_Override_DynamicMetadata }
    | undefined;
}

/** Fetches the override from the dynamic metadata. */
export interface RateLimitConfig_Override_DynamicMetadata {
  $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Override.DynamicMetadata";
  /**
   * Metadata struct that defines the key and path to retrieve the struct value.
   * The value must be a struct containing an integer "requests_per_unit" property
   * and a "unit" property with a value parseable to :ref:`RateLimitUnit
   * enum <envoy_v3_api_enum_type.v3.RateLimitUnit>`
   */
  metadata_key?: MetadataKey | undefined;
}

export interface RateLimitPerRoute {
  $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimitPerRoute";
  /**
   * Specifies if the rate limit filter should include the virtual host rate limits.
   * [#next-major-version: unify with local ratelimit, should use common.ratelimit.v3.VhRateLimitsOptions instead.]
   */
  vh_rate_limits?:
    | RateLimitPerRoute_VhRateLimitsOptions
    | undefined;
  /**
   * Specifies if the rate limit filter should include the lower levels (route level, virtual host level or cluster weight level) rate limits override options.
   * [#not-implemented-hide:]
   */
  override_option?:
    | RateLimitPerRoute_OverrideOptions
    | undefined;
  /**
   * Rate limit configuration. If not set, uses the
   * :ref:`VirtualHost.rate_limits<envoy_v3_api_field_config.route.v3.VirtualHost.rate_limits>` or
   * :ref:`RouteAction.rate_limits<envoy_v3_api_field_config.route.v3.RouteAction.rate_limits>` fields instead.
   * [#not-implemented-hide:]
   */
  rate_limits?:
    | RateLimitConfig[]
    | undefined;
  /** Overrides the domain. If not set, uses the filter-level domain instead. */
  domain?: string | undefined;
}

/** [#next-major-version: unify with local ratelimit, should use common.ratelimit.v3.VhRateLimitsOptions instead.] */
export enum RateLimitPerRoute_VhRateLimitsOptions {
  /** OVERRIDE - Use the virtual host rate limits unless the route has a rate limit policy. */
  OVERRIDE = "OVERRIDE",
  /** INCLUDE - Use the virtual host rate limits even if the route has a rate limit policy. */
  INCLUDE = "INCLUDE",
  /** IGNORE - Ignore the virtual host rate limits even if the route does not have a rate limit policy. */
  IGNORE = "IGNORE",
}

export function rateLimitPerRoute_VhRateLimitsOptionsFromJSON(object: any): RateLimitPerRoute_VhRateLimitsOptions {
  switch (object) {
    case 0:
    case "OVERRIDE":
      return RateLimitPerRoute_VhRateLimitsOptions.OVERRIDE;
    case 1:
    case "INCLUDE":
      return RateLimitPerRoute_VhRateLimitsOptions.INCLUDE;
    case 2:
    case "IGNORE":
      return RateLimitPerRoute_VhRateLimitsOptions.IGNORE;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum RateLimitPerRoute_VhRateLimitsOptions",
      );
  }
}

export function rateLimitPerRoute_VhRateLimitsOptionsToJSON(object: RateLimitPerRoute_VhRateLimitsOptions): string {
  switch (object) {
    case RateLimitPerRoute_VhRateLimitsOptions.OVERRIDE:
      return "OVERRIDE";
    case RateLimitPerRoute_VhRateLimitsOptions.INCLUDE:
      return "INCLUDE";
    case RateLimitPerRoute_VhRateLimitsOptions.IGNORE:
      return "IGNORE";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum RateLimitPerRoute_VhRateLimitsOptions",
      );
  }
}

export function rateLimitPerRoute_VhRateLimitsOptionsToNumber(object: RateLimitPerRoute_VhRateLimitsOptions): number {
  switch (object) {
    case RateLimitPerRoute_VhRateLimitsOptions.OVERRIDE:
      return 0;
    case RateLimitPerRoute_VhRateLimitsOptions.INCLUDE:
      return 1;
    case RateLimitPerRoute_VhRateLimitsOptions.IGNORE:
      return 2;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum RateLimitPerRoute_VhRateLimitsOptions",
      );
  }
}

/**
 * The override option determines how the filter handles the cases where there is an override config at a more specific level than this one (from least to most specific: virtual host, route, cluster weight).
 * [#not-implemented-hide:]
 */
export enum RateLimitPerRoute_OverrideOptions {
  /** DEFAULT - Client-defined default, typically OVERRIDE_POLICY. If VhRateLimitsOptions is set, that will be used instead. */
  DEFAULT = "DEFAULT",
  /** OVERRIDE_POLICY - If there is an override config at a more specific level, use that instead of this one. */
  OVERRIDE_POLICY = "OVERRIDE_POLICY",
  /** INCLUDE_POLICY - If there is an override config at a more specific level, use data from both. */
  INCLUDE_POLICY = "INCLUDE_POLICY",
  /** IGNORE_POLICY - If there is an override config at a more specific level, ignore it and use only this one. */
  IGNORE_POLICY = "IGNORE_POLICY",
}

export function rateLimitPerRoute_OverrideOptionsFromJSON(object: any): RateLimitPerRoute_OverrideOptions {
  switch (object) {
    case 0:
    case "DEFAULT":
      return RateLimitPerRoute_OverrideOptions.DEFAULT;
    case 1:
    case "OVERRIDE_POLICY":
      return RateLimitPerRoute_OverrideOptions.OVERRIDE_POLICY;
    case 2:
    case "INCLUDE_POLICY":
      return RateLimitPerRoute_OverrideOptions.INCLUDE_POLICY;
    case 3:
    case "IGNORE_POLICY":
      return RateLimitPerRoute_OverrideOptions.IGNORE_POLICY;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RateLimitPerRoute_OverrideOptions");
  }
}

export function rateLimitPerRoute_OverrideOptionsToJSON(object: RateLimitPerRoute_OverrideOptions): string {
  switch (object) {
    case RateLimitPerRoute_OverrideOptions.DEFAULT:
      return "DEFAULT";
    case RateLimitPerRoute_OverrideOptions.OVERRIDE_POLICY:
      return "OVERRIDE_POLICY";
    case RateLimitPerRoute_OverrideOptions.INCLUDE_POLICY:
      return "INCLUDE_POLICY";
    case RateLimitPerRoute_OverrideOptions.IGNORE_POLICY:
      return "IGNORE_POLICY";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RateLimitPerRoute_OverrideOptions");
  }
}

export function rateLimitPerRoute_OverrideOptionsToNumber(object: RateLimitPerRoute_OverrideOptions): number {
  switch (object) {
    case RateLimitPerRoute_OverrideOptions.DEFAULT:
      return 0;
    case RateLimitPerRoute_OverrideOptions.OVERRIDE_POLICY:
      return 1;
    case RateLimitPerRoute_OverrideOptions.INCLUDE_POLICY:
      return 2;
    case RateLimitPerRoute_OverrideOptions.IGNORE_POLICY:
      return 3;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RateLimitPerRoute_OverrideOptions");
  }
}

function createBaseRateLimit(): RateLimit {
  return { $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimit" };
}

export const RateLimit: MessageFns<RateLimit, "envoy.extensions.filters.http.ratelimit.v3.RateLimit"> = {
  $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimit" as const,

  encode(message: RateLimit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.domain !== undefined && message.domain !== "") {
      writer.uint32(10).string(message.domain);
    }
    if (message.stage !== undefined && message.stage !== 0) {
      writer.uint32(16).uint32(message.stage);
    }
    if (message.request_type !== undefined && message.request_type !== "") {
      writer.uint32(26).string(message.request_type);
    }
    if (message.timeout !== undefined) {
      Duration.encode(message.timeout, writer.uint32(34).fork()).join();
    }
    if (message.failure_mode_deny !== undefined && message.failure_mode_deny !== false) {
      writer.uint32(40).bool(message.failure_mode_deny);
    }
    if (
      message.rate_limited_as_resource_exhausted !== undefined && message.rate_limited_as_resource_exhausted !== false
    ) {
      writer.uint32(48).bool(message.rate_limited_as_resource_exhausted);
    }
    if (message.rate_limit_service !== undefined) {
      RateLimitServiceConfig.encode(message.rate_limit_service, writer.uint32(58).fork()).join();
    }
    if (
      message.enable_x_ratelimit_headers !== undefined &&
      message.enable_x_ratelimit_headers !== RateLimit_XRateLimitHeadersRFCVersion.OFF
    ) {
      writer.uint32(64).int32(rateLimit_XRateLimitHeadersRFCVersionToNumber(message.enable_x_ratelimit_headers));
    }
    if (
      message.disable_x_envoy_ratelimited_header !== undefined && message.disable_x_envoy_ratelimited_header !== false
    ) {
      writer.uint32(72).bool(message.disable_x_envoy_ratelimited_header);
    }
    if (message.rate_limited_status !== undefined) {
      HttpStatus.encode(message.rate_limited_status, writer.uint32(82).fork()).join();
    }
    if (message.response_headers_to_add !== undefined && message.response_headers_to_add.length !== 0) {
      for (const v of message.response_headers_to_add) {
        HeaderValueOption.encode(v!, writer.uint32(90).fork()).join();
      }
    }
    if (message.status_on_error !== undefined) {
      HttpStatus.encode(message.status_on_error, writer.uint32(98).fork()).join();
    }
    if (message.stat_prefix !== undefined && message.stat_prefix !== "") {
      writer.uint32(106).string(message.stat_prefix);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.domain = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.stage = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.request_type = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.failure_mode_deny = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.rate_limited_as_resource_exhausted = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.rate_limit_service = RateLimitServiceConfig.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.enable_x_ratelimit_headers = rateLimit_XRateLimitHeadersRFCVersionFromJSON(reader.int32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.disable_x_envoy_ratelimited_header = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.rate_limited_status = HttpStatus.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          if (message.response_headers_to_add === undefined) {
            message.response_headers_to_add = [];
          }
          const el = HeaderValueOption.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.response_headers_to_add!.push(el);
          }
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.status_on_error = HttpStatus.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.stat_prefix = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimit {
    return {
      $type: RateLimit.$type,
      domain: isSet(object.domain) ? globalThis.String(object.domain) : undefined,
      stage: isSet(object.stage) ? globalThis.Number(object.stage) : undefined,
      request_type: isSet(object.request_type) ? globalThis.String(object.request_type) : undefined,
      timeout: isSet(object.timeout) ? Duration.fromJSON(object.timeout) : undefined,
      failure_mode_deny: isSet(object.failure_mode_deny) ? globalThis.Boolean(object.failure_mode_deny) : undefined,
      rate_limited_as_resource_exhausted: isSet(object.rate_limited_as_resource_exhausted)
        ? globalThis.Boolean(object.rate_limited_as_resource_exhausted)
        : undefined,
      rate_limit_service: isSet(object.rate_limit_service)
        ? RateLimitServiceConfig.fromJSON(object.rate_limit_service)
        : undefined,
      enable_x_ratelimit_headers: isSet(object.enable_x_ratelimit_headers)
        ? rateLimit_XRateLimitHeadersRFCVersionFromJSON(object.enable_x_ratelimit_headers)
        : undefined,
      disable_x_envoy_ratelimited_header: isSet(object.disable_x_envoy_ratelimited_header)
        ? globalThis.Boolean(object.disable_x_envoy_ratelimited_header)
        : undefined,
      rate_limited_status: isSet(object.rate_limited_status)
        ? HttpStatus.fromJSON(object.rate_limited_status)
        : undefined,
      response_headers_to_add: globalThis.Array.isArray(object?.response_headers_to_add)
        ? object.response_headers_to_add.map((e: any) => HeaderValueOption.fromJSON(e))
        : undefined,
      status_on_error: isSet(object.status_on_error) ? HttpStatus.fromJSON(object.status_on_error) : undefined,
      stat_prefix: isSet(object.stat_prefix) ? globalThis.String(object.stat_prefix) : undefined,
    };
  },

  toJSON(message: RateLimit): unknown {
    const obj: any = {};
    if (message.domain !== undefined) {
      obj.domain = message.domain;
    }
    if (message.stage !== undefined) {
      obj.stage = Math.round(message.stage);
    }
    if (message.request_type !== undefined) {
      obj.request_type = message.request_type;
    }
    if (message.timeout !== undefined) {
      obj.timeout = Duration.toJSON(message.timeout);
    }
    if (message.failure_mode_deny !== undefined) {
      obj.failure_mode_deny = message.failure_mode_deny;
    }
    if (message.rate_limited_as_resource_exhausted !== undefined) {
      obj.rate_limited_as_resource_exhausted = message.rate_limited_as_resource_exhausted;
    }
    if (message.rate_limit_service !== undefined) {
      obj.rate_limit_service = RateLimitServiceConfig.toJSON(message.rate_limit_service);
    }
    if (message.enable_x_ratelimit_headers !== undefined) {
      obj.enable_x_ratelimit_headers = rateLimit_XRateLimitHeadersRFCVersionToJSON(message.enable_x_ratelimit_headers);
    }
    if (message.disable_x_envoy_ratelimited_header !== undefined) {
      obj.disable_x_envoy_ratelimited_header = message.disable_x_envoy_ratelimited_header;
    }
    if (message.rate_limited_status !== undefined) {
      obj.rate_limited_status = HttpStatus.toJSON(message.rate_limited_status);
    }
    if (message.response_headers_to_add?.length) {
      obj.response_headers_to_add = message.response_headers_to_add.map((e) => HeaderValueOption.toJSON(e));
    }
    if (message.status_on_error !== undefined) {
      obj.status_on_error = HttpStatus.toJSON(message.status_on_error);
    }
    if (message.stat_prefix !== undefined) {
      obj.stat_prefix = message.stat_prefix;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimit>, I>>(base?: I): RateLimit {
    return RateLimit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimit>, I>>(object: I): RateLimit {
    const message = createBaseRateLimit();
    message.domain = object.domain ?? undefined;
    message.stage = object.stage ?? undefined;
    message.request_type = object.request_type ?? undefined;
    message.timeout = (object.timeout !== undefined && object.timeout !== null)
      ? Duration.fromPartial(object.timeout)
      : undefined;
    message.failure_mode_deny = object.failure_mode_deny ?? undefined;
    message.rate_limited_as_resource_exhausted = object.rate_limited_as_resource_exhausted ?? undefined;
    message.rate_limit_service = (object.rate_limit_service !== undefined && object.rate_limit_service !== null)
      ? RateLimitServiceConfig.fromPartial(object.rate_limit_service)
      : undefined;
    message.enable_x_ratelimit_headers = object.enable_x_ratelimit_headers ?? undefined;
    message.disable_x_envoy_ratelimited_header = object.disable_x_envoy_ratelimited_header ?? undefined;
    message.rate_limited_status = (object.rate_limited_status !== undefined && object.rate_limited_status !== null)
      ? HttpStatus.fromPartial(object.rate_limited_status)
      : undefined;
    message.response_headers_to_add = object.response_headers_to_add?.map((e) => HeaderValueOption.fromPartial(e)) ||
      undefined;
    message.status_on_error = (object.status_on_error !== undefined && object.status_on_error !== null)
      ? HttpStatus.fromPartial(object.status_on_error)
      : undefined;
    message.stat_prefix = object.stat_prefix ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RateLimit.$type, RateLimit);

function createBaseRateLimitConfig(): RateLimitConfig {
  return { $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig" };
}

export const RateLimitConfig: MessageFns<
  RateLimitConfig,
  "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig"
> = {
  $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig" as const,

  encode(message: RateLimitConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stage !== undefined && message.stage !== 0) {
      writer.uint32(8).uint32(message.stage);
    }
    if (message.disable_key !== undefined && message.disable_key !== "") {
      writer.uint32(18).string(message.disable_key);
    }
    if (message.actions !== undefined && message.actions.length !== 0) {
      for (const v of message.actions) {
        RateLimitConfig_Action.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    if (message.limit !== undefined) {
      RateLimitConfig_Override.encode(message.limit, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimitConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimitConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.stage = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.disable_key = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.actions === undefined) {
            message.actions = [];
          }
          const el = RateLimitConfig_Action.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.actions!.push(el);
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.limit = RateLimitConfig_Override.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimitConfig {
    return {
      $type: RateLimitConfig.$type,
      stage: isSet(object.stage) ? globalThis.Number(object.stage) : undefined,
      disable_key: isSet(object.disable_key) ? globalThis.String(object.disable_key) : undefined,
      actions: globalThis.Array.isArray(object?.actions)
        ? object.actions.map((e: any) => RateLimitConfig_Action.fromJSON(e))
        : undefined,
      limit: isSet(object.limit) ? RateLimitConfig_Override.fromJSON(object.limit) : undefined,
    };
  },

  toJSON(message: RateLimitConfig): unknown {
    const obj: any = {};
    if (message.stage !== undefined) {
      obj.stage = Math.round(message.stage);
    }
    if (message.disable_key !== undefined) {
      obj.disable_key = message.disable_key;
    }
    if (message.actions?.length) {
      obj.actions = message.actions.map((e) => RateLimitConfig_Action.toJSON(e));
    }
    if (message.limit !== undefined) {
      obj.limit = RateLimitConfig_Override.toJSON(message.limit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimitConfig>, I>>(base?: I): RateLimitConfig {
    return RateLimitConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimitConfig>, I>>(object: I): RateLimitConfig {
    const message = createBaseRateLimitConfig();
    message.stage = object.stage ?? undefined;
    message.disable_key = object.disable_key ?? undefined;
    message.actions = object.actions?.map((e) => RateLimitConfig_Action.fromPartial(e)) || undefined;
    message.limit = (object.limit !== undefined && object.limit !== null)
      ? RateLimitConfig_Override.fromPartial(object.limit)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(RateLimitConfig.$type, RateLimitConfig);

function createBaseRateLimitConfig_Action(): RateLimitConfig_Action {
  return { $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action", action_specifier: undefined };
}

export const RateLimitConfig_Action: MessageFns<
  RateLimitConfig_Action,
  "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action"
> = {
  $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action" as const,

  encode(message: RateLimitConfig_Action, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.action_specifier?.$case) {
      case "source_cluster":
        RateLimitConfig_Action_SourceCluster.encode(message.action_specifier.source_cluster, writer.uint32(10).fork())
          .join();
        break;
      case "destination_cluster":
        RateLimitConfig_Action_DestinationCluster.encode(
          message.action_specifier.destination_cluster,
          writer.uint32(18).fork(),
        ).join();
        break;
      case "request_headers":
        RateLimitConfig_Action_RequestHeaders.encode(message.action_specifier.request_headers, writer.uint32(26).fork())
          .join();
        break;
      case "remote_address":
        RateLimitConfig_Action_RemoteAddress.encode(message.action_specifier.remote_address, writer.uint32(34).fork())
          .join();
        break;
      case "generic_key":
        RateLimitConfig_Action_GenericKey.encode(message.action_specifier.generic_key, writer.uint32(42).fork()).join();
        break;
      case "header_value_match":
        RateLimitConfig_Action_HeaderValueMatch.encode(
          message.action_specifier.header_value_match,
          writer.uint32(50).fork(),
        ).join();
        break;
      case "metadata":
        RateLimitConfig_Action_MetaData.encode(message.action_specifier.metadata, writer.uint32(66).fork()).join();
        break;
      case "extension":
        TypedExtensionConfig.encode(message.action_specifier.extension, writer.uint32(74).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimitConfig_Action {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimitConfig_Action();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.action_specifier = {
            $case: "source_cluster",
            source_cluster: RateLimitConfig_Action_SourceCluster.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.action_specifier = {
            $case: "destination_cluster",
            destination_cluster: RateLimitConfig_Action_DestinationCluster.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.action_specifier = {
            $case: "request_headers",
            request_headers: RateLimitConfig_Action_RequestHeaders.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.action_specifier = {
            $case: "remote_address",
            remote_address: RateLimitConfig_Action_RemoteAddress.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.action_specifier = {
            $case: "generic_key",
            generic_key: RateLimitConfig_Action_GenericKey.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.action_specifier = {
            $case: "header_value_match",
            header_value_match: RateLimitConfig_Action_HeaderValueMatch.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.action_specifier = {
            $case: "metadata",
            metadata: RateLimitConfig_Action_MetaData.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.action_specifier = {
            $case: "extension",
            extension: TypedExtensionConfig.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimitConfig_Action {
    return {
      $type: RateLimitConfig_Action.$type,
      action_specifier: isSet(object.source_cluster)
        ? {
          $case: "source_cluster",
          source_cluster: RateLimitConfig_Action_SourceCluster.fromJSON(object.source_cluster),
        }
        : isSet(object.destination_cluster)
        ? {
          $case: "destination_cluster",
          destination_cluster: RateLimitConfig_Action_DestinationCluster.fromJSON(object.destination_cluster),
        }
        : isSet(object.request_headers)
        ? {
          $case: "request_headers",
          request_headers: RateLimitConfig_Action_RequestHeaders.fromJSON(object.request_headers),
        }
        : isSet(object.remote_address)
        ? {
          $case: "remote_address",
          remote_address: RateLimitConfig_Action_RemoteAddress.fromJSON(object.remote_address),
        }
        : isSet(object.generic_key)
        ? { $case: "generic_key", generic_key: RateLimitConfig_Action_GenericKey.fromJSON(object.generic_key) }
        : isSet(object.header_value_match)
        ? {
          $case: "header_value_match",
          header_value_match: RateLimitConfig_Action_HeaderValueMatch.fromJSON(object.header_value_match),
        }
        : isSet(object.metadata)
        ? { $case: "metadata", metadata: RateLimitConfig_Action_MetaData.fromJSON(object.metadata) }
        : isSet(object.extension)
        ? { $case: "extension", extension: TypedExtensionConfig.fromJSON(object.extension) }
        : undefined,
    };
  },

  toJSON(message: RateLimitConfig_Action): unknown {
    const obj: any = {};
    if (message.action_specifier?.$case === "source_cluster") {
      obj.source_cluster = RateLimitConfig_Action_SourceCluster.toJSON(message.action_specifier.source_cluster);
    }
    if (message.action_specifier?.$case === "destination_cluster") {
      obj.destination_cluster = RateLimitConfig_Action_DestinationCluster.toJSON(
        message.action_specifier.destination_cluster,
      );
    }
    if (message.action_specifier?.$case === "request_headers") {
      obj.request_headers = RateLimitConfig_Action_RequestHeaders.toJSON(message.action_specifier.request_headers);
    }
    if (message.action_specifier?.$case === "remote_address") {
      obj.remote_address = RateLimitConfig_Action_RemoteAddress.toJSON(message.action_specifier.remote_address);
    }
    if (message.action_specifier?.$case === "generic_key") {
      obj.generic_key = RateLimitConfig_Action_GenericKey.toJSON(message.action_specifier.generic_key);
    }
    if (message.action_specifier?.$case === "header_value_match") {
      obj.header_value_match = RateLimitConfig_Action_HeaderValueMatch.toJSON(
        message.action_specifier.header_value_match,
      );
    }
    if (message.action_specifier?.$case === "metadata") {
      obj.metadata = RateLimitConfig_Action_MetaData.toJSON(message.action_specifier.metadata);
    }
    if (message.action_specifier?.$case === "extension") {
      obj.extension = TypedExtensionConfig.toJSON(message.action_specifier.extension);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimitConfig_Action>, I>>(base?: I): RateLimitConfig_Action {
    return RateLimitConfig_Action.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimitConfig_Action>, I>>(object: I): RateLimitConfig_Action {
    const message = createBaseRateLimitConfig_Action();
    if (
      object.action_specifier?.$case === "source_cluster" &&
      object.action_specifier?.source_cluster !== undefined &&
      object.action_specifier?.source_cluster !== null
    ) {
      message.action_specifier = {
        $case: "source_cluster",
        source_cluster: RateLimitConfig_Action_SourceCluster.fromPartial(object.action_specifier.source_cluster),
      };
    }
    if (
      object.action_specifier?.$case === "destination_cluster" &&
      object.action_specifier?.destination_cluster !== undefined &&
      object.action_specifier?.destination_cluster !== null
    ) {
      message.action_specifier = {
        $case: "destination_cluster",
        destination_cluster: RateLimitConfig_Action_DestinationCluster.fromPartial(
          object.action_specifier.destination_cluster,
        ),
      };
    }
    if (
      object.action_specifier?.$case === "request_headers" &&
      object.action_specifier?.request_headers !== undefined &&
      object.action_specifier?.request_headers !== null
    ) {
      message.action_specifier = {
        $case: "request_headers",
        request_headers: RateLimitConfig_Action_RequestHeaders.fromPartial(object.action_specifier.request_headers),
      };
    }
    if (
      object.action_specifier?.$case === "remote_address" &&
      object.action_specifier?.remote_address !== undefined &&
      object.action_specifier?.remote_address !== null
    ) {
      message.action_specifier = {
        $case: "remote_address",
        remote_address: RateLimitConfig_Action_RemoteAddress.fromPartial(object.action_specifier.remote_address),
      };
    }
    if (
      object.action_specifier?.$case === "generic_key" &&
      object.action_specifier?.generic_key !== undefined &&
      object.action_specifier?.generic_key !== null
    ) {
      message.action_specifier = {
        $case: "generic_key",
        generic_key: RateLimitConfig_Action_GenericKey.fromPartial(object.action_specifier.generic_key),
      };
    }
    if (
      object.action_specifier?.$case === "header_value_match" &&
      object.action_specifier?.header_value_match !== undefined &&
      object.action_specifier?.header_value_match !== null
    ) {
      message.action_specifier = {
        $case: "header_value_match",
        header_value_match: RateLimitConfig_Action_HeaderValueMatch.fromPartial(
          object.action_specifier.header_value_match,
        ),
      };
    }
    if (
      object.action_specifier?.$case === "metadata" &&
      object.action_specifier?.metadata !== undefined &&
      object.action_specifier?.metadata !== null
    ) {
      message.action_specifier = {
        $case: "metadata",
        metadata: RateLimitConfig_Action_MetaData.fromPartial(object.action_specifier.metadata),
      };
    }
    if (
      object.action_specifier?.$case === "extension" &&
      object.action_specifier?.extension !== undefined &&
      object.action_specifier?.extension !== null
    ) {
      message.action_specifier = {
        $case: "extension",
        extension: TypedExtensionConfig.fromPartial(object.action_specifier.extension),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(RateLimitConfig_Action.$type, RateLimitConfig_Action);

function createBaseRateLimitConfig_Action_SourceCluster(): RateLimitConfig_Action_SourceCluster {
  return { $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.SourceCluster" };
}

export const RateLimitConfig_Action_SourceCluster: MessageFns<
  RateLimitConfig_Action_SourceCluster,
  "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.SourceCluster"
> = {
  $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.SourceCluster" as const,

  encode(_: RateLimitConfig_Action_SourceCluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimitConfig_Action_SourceCluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimitConfig_Action_SourceCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RateLimitConfig_Action_SourceCluster {
    return { $type: RateLimitConfig_Action_SourceCluster.$type };
  },

  toJSON(_: RateLimitConfig_Action_SourceCluster): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimitConfig_Action_SourceCluster>, I>>(
    base?: I,
  ): RateLimitConfig_Action_SourceCluster {
    return RateLimitConfig_Action_SourceCluster.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimitConfig_Action_SourceCluster>, I>>(
    _: I,
  ): RateLimitConfig_Action_SourceCluster {
    const message = createBaseRateLimitConfig_Action_SourceCluster();
    return message;
  },
};

messageTypeRegistry.set(RateLimitConfig_Action_SourceCluster.$type, RateLimitConfig_Action_SourceCluster);

function createBaseRateLimitConfig_Action_DestinationCluster(): RateLimitConfig_Action_DestinationCluster {
  return { $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.DestinationCluster" };
}

export const RateLimitConfig_Action_DestinationCluster: MessageFns<
  RateLimitConfig_Action_DestinationCluster,
  "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.DestinationCluster"
> = {
  $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.DestinationCluster" as const,

  encode(_: RateLimitConfig_Action_DestinationCluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimitConfig_Action_DestinationCluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimitConfig_Action_DestinationCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RateLimitConfig_Action_DestinationCluster {
    return { $type: RateLimitConfig_Action_DestinationCluster.$type };
  },

  toJSON(_: RateLimitConfig_Action_DestinationCluster): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimitConfig_Action_DestinationCluster>, I>>(
    base?: I,
  ): RateLimitConfig_Action_DestinationCluster {
    return RateLimitConfig_Action_DestinationCluster.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimitConfig_Action_DestinationCluster>, I>>(
    _: I,
  ): RateLimitConfig_Action_DestinationCluster {
    const message = createBaseRateLimitConfig_Action_DestinationCluster();
    return message;
  },
};

messageTypeRegistry.set(RateLimitConfig_Action_DestinationCluster.$type, RateLimitConfig_Action_DestinationCluster);

function createBaseRateLimitConfig_Action_RequestHeaders(): RateLimitConfig_Action_RequestHeaders {
  return { $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.RequestHeaders" };
}

export const RateLimitConfig_Action_RequestHeaders: MessageFns<
  RateLimitConfig_Action_RequestHeaders,
  "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.RequestHeaders"
> = {
  $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.RequestHeaders" as const,

  encode(message: RateLimitConfig_Action_RequestHeaders, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header_name !== undefined && message.header_name !== "") {
      writer.uint32(10).string(message.header_name);
    }
    if (message.descriptor_key !== undefined && message.descriptor_key !== "") {
      writer.uint32(18).string(message.descriptor_key);
    }
    if (message.skip_if_absent !== undefined && message.skip_if_absent !== false) {
      writer.uint32(24).bool(message.skip_if_absent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimitConfig_Action_RequestHeaders {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimitConfig_Action_RequestHeaders();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header_name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.descriptor_key = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.skip_if_absent = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimitConfig_Action_RequestHeaders {
    return {
      $type: RateLimitConfig_Action_RequestHeaders.$type,
      header_name: isSet(object.header_name) ? globalThis.String(object.header_name) : undefined,
      descriptor_key: isSet(object.descriptor_key) ? globalThis.String(object.descriptor_key) : undefined,
      skip_if_absent: isSet(object.skip_if_absent) ? globalThis.Boolean(object.skip_if_absent) : undefined,
    };
  },

  toJSON(message: RateLimitConfig_Action_RequestHeaders): unknown {
    const obj: any = {};
    if (message.header_name !== undefined) {
      obj.header_name = message.header_name;
    }
    if (message.descriptor_key !== undefined) {
      obj.descriptor_key = message.descriptor_key;
    }
    if (message.skip_if_absent !== undefined) {
      obj.skip_if_absent = message.skip_if_absent;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimitConfig_Action_RequestHeaders>, I>>(
    base?: I,
  ): RateLimitConfig_Action_RequestHeaders {
    return RateLimitConfig_Action_RequestHeaders.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimitConfig_Action_RequestHeaders>, I>>(
    object: I,
  ): RateLimitConfig_Action_RequestHeaders {
    const message = createBaseRateLimitConfig_Action_RequestHeaders();
    message.header_name = object.header_name ?? undefined;
    message.descriptor_key = object.descriptor_key ?? undefined;
    message.skip_if_absent = object.skip_if_absent ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RateLimitConfig_Action_RequestHeaders.$type, RateLimitConfig_Action_RequestHeaders);

function createBaseRateLimitConfig_Action_RemoteAddress(): RateLimitConfig_Action_RemoteAddress {
  return { $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.RemoteAddress" };
}

export const RateLimitConfig_Action_RemoteAddress: MessageFns<
  RateLimitConfig_Action_RemoteAddress,
  "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.RemoteAddress"
> = {
  $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.RemoteAddress" as const,

  encode(_: RateLimitConfig_Action_RemoteAddress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimitConfig_Action_RemoteAddress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimitConfig_Action_RemoteAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RateLimitConfig_Action_RemoteAddress {
    return { $type: RateLimitConfig_Action_RemoteAddress.$type };
  },

  toJSON(_: RateLimitConfig_Action_RemoteAddress): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimitConfig_Action_RemoteAddress>, I>>(
    base?: I,
  ): RateLimitConfig_Action_RemoteAddress {
    return RateLimitConfig_Action_RemoteAddress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimitConfig_Action_RemoteAddress>, I>>(
    _: I,
  ): RateLimitConfig_Action_RemoteAddress {
    const message = createBaseRateLimitConfig_Action_RemoteAddress();
    return message;
  },
};

messageTypeRegistry.set(RateLimitConfig_Action_RemoteAddress.$type, RateLimitConfig_Action_RemoteAddress);

function createBaseRateLimitConfig_Action_GenericKey(): RateLimitConfig_Action_GenericKey {
  return { $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.GenericKey" };
}

export const RateLimitConfig_Action_GenericKey: MessageFns<
  RateLimitConfig_Action_GenericKey,
  "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.GenericKey"
> = {
  $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.GenericKey" as const,

  encode(message: RateLimitConfig_Action_GenericKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.descriptor_value !== undefined && message.descriptor_value !== "") {
      writer.uint32(10).string(message.descriptor_value);
    }
    if (message.descriptor_key !== undefined && message.descriptor_key !== "") {
      writer.uint32(18).string(message.descriptor_key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimitConfig_Action_GenericKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimitConfig_Action_GenericKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.descriptor_value = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.descriptor_key = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimitConfig_Action_GenericKey {
    return {
      $type: RateLimitConfig_Action_GenericKey.$type,
      descriptor_value: isSet(object.descriptor_value) ? globalThis.String(object.descriptor_value) : undefined,
      descriptor_key: isSet(object.descriptor_key) ? globalThis.String(object.descriptor_key) : undefined,
    };
  },

  toJSON(message: RateLimitConfig_Action_GenericKey): unknown {
    const obj: any = {};
    if (message.descriptor_value !== undefined) {
      obj.descriptor_value = message.descriptor_value;
    }
    if (message.descriptor_key !== undefined) {
      obj.descriptor_key = message.descriptor_key;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimitConfig_Action_GenericKey>, I>>(
    base?: I,
  ): RateLimitConfig_Action_GenericKey {
    return RateLimitConfig_Action_GenericKey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimitConfig_Action_GenericKey>, I>>(
    object: I,
  ): RateLimitConfig_Action_GenericKey {
    const message = createBaseRateLimitConfig_Action_GenericKey();
    message.descriptor_value = object.descriptor_value ?? undefined;
    message.descriptor_key = object.descriptor_key ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RateLimitConfig_Action_GenericKey.$type, RateLimitConfig_Action_GenericKey);

function createBaseRateLimitConfig_Action_HeaderValueMatch(): RateLimitConfig_Action_HeaderValueMatch {
  return { $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.HeaderValueMatch" };
}

export const RateLimitConfig_Action_HeaderValueMatch: MessageFns<
  RateLimitConfig_Action_HeaderValueMatch,
  "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.HeaderValueMatch"
> = {
  $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.HeaderValueMatch" as const,

  encode(message: RateLimitConfig_Action_HeaderValueMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.descriptor_value !== undefined && message.descriptor_value !== "") {
      writer.uint32(10).string(message.descriptor_value);
    }
    if (message.expect_match !== undefined && message.expect_match !== false) {
      writer.uint32(16).bool(message.expect_match);
    }
    if (message.headers !== undefined && message.headers.length !== 0) {
      for (const v of message.headers) {
        HeaderMatcher.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimitConfig_Action_HeaderValueMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimitConfig_Action_HeaderValueMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.descriptor_value = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.expect_match = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.headers === undefined) {
            message.headers = [];
          }
          const el = HeaderMatcher.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.headers!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimitConfig_Action_HeaderValueMatch {
    return {
      $type: RateLimitConfig_Action_HeaderValueMatch.$type,
      descriptor_value: isSet(object.descriptor_value) ? globalThis.String(object.descriptor_value) : undefined,
      expect_match: isSet(object.expect_match) ? globalThis.Boolean(object.expect_match) : undefined,
      headers: globalThis.Array.isArray(object?.headers)
        ? object.headers.map((e: any) => HeaderMatcher.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: RateLimitConfig_Action_HeaderValueMatch): unknown {
    const obj: any = {};
    if (message.descriptor_value !== undefined) {
      obj.descriptor_value = message.descriptor_value;
    }
    if (message.expect_match !== undefined) {
      obj.expect_match = message.expect_match;
    }
    if (message.headers?.length) {
      obj.headers = message.headers.map((e) => HeaderMatcher.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimitConfig_Action_HeaderValueMatch>, I>>(
    base?: I,
  ): RateLimitConfig_Action_HeaderValueMatch {
    return RateLimitConfig_Action_HeaderValueMatch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimitConfig_Action_HeaderValueMatch>, I>>(
    object: I,
  ): RateLimitConfig_Action_HeaderValueMatch {
    const message = createBaseRateLimitConfig_Action_HeaderValueMatch();
    message.descriptor_value = object.descriptor_value ?? undefined;
    message.expect_match = object.expect_match ?? undefined;
    message.headers = object.headers?.map((e) => HeaderMatcher.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(RateLimitConfig_Action_HeaderValueMatch.$type, RateLimitConfig_Action_HeaderValueMatch);

function createBaseRateLimitConfig_Action_MetaData(): RateLimitConfig_Action_MetaData {
  return { $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.MetaData" };
}

export const RateLimitConfig_Action_MetaData: MessageFns<
  RateLimitConfig_Action_MetaData,
  "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.MetaData"
> = {
  $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.MetaData" as const,

  encode(message: RateLimitConfig_Action_MetaData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.descriptor_key !== undefined && message.descriptor_key !== "") {
      writer.uint32(10).string(message.descriptor_key);
    }
    if (message.metadata_key !== undefined) {
      MetadataKey.encode(message.metadata_key, writer.uint32(18).fork()).join();
    }
    if (message.default_value !== undefined && message.default_value !== "") {
      writer.uint32(26).string(message.default_value);
    }
    if (message.source !== undefined && message.source !== RateLimitConfig_Action_MetaData_Source.DYNAMIC) {
      writer.uint32(32).int32(rateLimitConfig_Action_MetaData_SourceToNumber(message.source));
    }
    if (message.skip_if_absent !== undefined && message.skip_if_absent !== false) {
      writer.uint32(40).bool(message.skip_if_absent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimitConfig_Action_MetaData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimitConfig_Action_MetaData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.descriptor_key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.metadata_key = MetadataKey.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.default_value = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.source = rateLimitConfig_Action_MetaData_SourceFromJSON(reader.int32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.skip_if_absent = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimitConfig_Action_MetaData {
    return {
      $type: RateLimitConfig_Action_MetaData.$type,
      descriptor_key: isSet(object.descriptor_key) ? globalThis.String(object.descriptor_key) : undefined,
      metadata_key: isSet(object.metadata_key) ? MetadataKey.fromJSON(object.metadata_key) : undefined,
      default_value: isSet(object.default_value) ? globalThis.String(object.default_value) : undefined,
      source: isSet(object.source) ? rateLimitConfig_Action_MetaData_SourceFromJSON(object.source) : undefined,
      skip_if_absent: isSet(object.skip_if_absent) ? globalThis.Boolean(object.skip_if_absent) : undefined,
    };
  },

  toJSON(message: RateLimitConfig_Action_MetaData): unknown {
    const obj: any = {};
    if (message.descriptor_key !== undefined) {
      obj.descriptor_key = message.descriptor_key;
    }
    if (message.metadata_key !== undefined) {
      obj.metadata_key = MetadataKey.toJSON(message.metadata_key);
    }
    if (message.default_value !== undefined) {
      obj.default_value = message.default_value;
    }
    if (message.source !== undefined) {
      obj.source = rateLimitConfig_Action_MetaData_SourceToJSON(message.source);
    }
    if (message.skip_if_absent !== undefined) {
      obj.skip_if_absent = message.skip_if_absent;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimitConfig_Action_MetaData>, I>>(base?: I): RateLimitConfig_Action_MetaData {
    return RateLimitConfig_Action_MetaData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimitConfig_Action_MetaData>, I>>(
    object: I,
  ): RateLimitConfig_Action_MetaData {
    const message = createBaseRateLimitConfig_Action_MetaData();
    message.descriptor_key = object.descriptor_key ?? undefined;
    message.metadata_key = (object.metadata_key !== undefined && object.metadata_key !== null)
      ? MetadataKey.fromPartial(object.metadata_key)
      : undefined;
    message.default_value = object.default_value ?? undefined;
    message.source = object.source ?? undefined;
    message.skip_if_absent = object.skip_if_absent ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RateLimitConfig_Action_MetaData.$type, RateLimitConfig_Action_MetaData);

function createBaseRateLimitConfig_Override(): RateLimitConfig_Override {
  return {
    $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Override",
    override_specifier: undefined,
  };
}

export const RateLimitConfig_Override: MessageFns<
  RateLimitConfig_Override,
  "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Override"
> = {
  $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Override" as const,

  encode(message: RateLimitConfig_Override, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.override_specifier?.$case) {
      case "dynamic_metadata":
        RateLimitConfig_Override_DynamicMetadata.encode(
          message.override_specifier.dynamic_metadata,
          writer.uint32(10).fork(),
        ).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimitConfig_Override {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimitConfig_Override();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.override_specifier = {
            $case: "dynamic_metadata",
            dynamic_metadata: RateLimitConfig_Override_DynamicMetadata.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimitConfig_Override {
    return {
      $type: RateLimitConfig_Override.$type,
      override_specifier: isSet(object.dynamic_metadata)
        ? {
          $case: "dynamic_metadata",
          dynamic_metadata: RateLimitConfig_Override_DynamicMetadata.fromJSON(object.dynamic_metadata),
        }
        : undefined,
    };
  },

  toJSON(message: RateLimitConfig_Override): unknown {
    const obj: any = {};
    if (message.override_specifier?.$case === "dynamic_metadata") {
      obj.dynamic_metadata = RateLimitConfig_Override_DynamicMetadata.toJSON(
        message.override_specifier.dynamic_metadata,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimitConfig_Override>, I>>(base?: I): RateLimitConfig_Override {
    return RateLimitConfig_Override.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimitConfig_Override>, I>>(object: I): RateLimitConfig_Override {
    const message = createBaseRateLimitConfig_Override();
    if (
      object.override_specifier?.$case === "dynamic_metadata" &&
      object.override_specifier?.dynamic_metadata !== undefined &&
      object.override_specifier?.dynamic_metadata !== null
    ) {
      message.override_specifier = {
        $case: "dynamic_metadata",
        dynamic_metadata: RateLimitConfig_Override_DynamicMetadata.fromPartial(
          object.override_specifier.dynamic_metadata,
        ),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(RateLimitConfig_Override.$type, RateLimitConfig_Override);

function createBaseRateLimitConfig_Override_DynamicMetadata(): RateLimitConfig_Override_DynamicMetadata {
  return { $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Override.DynamicMetadata" };
}

export const RateLimitConfig_Override_DynamicMetadata: MessageFns<
  RateLimitConfig_Override_DynamicMetadata,
  "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Override.DynamicMetadata"
> = {
  $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Override.DynamicMetadata" as const,

  encode(message: RateLimitConfig_Override_DynamicMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadata_key !== undefined) {
      MetadataKey.encode(message.metadata_key, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimitConfig_Override_DynamicMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimitConfig_Override_DynamicMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.metadata_key = MetadataKey.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimitConfig_Override_DynamicMetadata {
    return {
      $type: RateLimitConfig_Override_DynamicMetadata.$type,
      metadata_key: isSet(object.metadata_key) ? MetadataKey.fromJSON(object.metadata_key) : undefined,
    };
  },

  toJSON(message: RateLimitConfig_Override_DynamicMetadata): unknown {
    const obj: any = {};
    if (message.metadata_key !== undefined) {
      obj.metadata_key = MetadataKey.toJSON(message.metadata_key);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimitConfig_Override_DynamicMetadata>, I>>(
    base?: I,
  ): RateLimitConfig_Override_DynamicMetadata {
    return RateLimitConfig_Override_DynamicMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimitConfig_Override_DynamicMetadata>, I>>(
    object: I,
  ): RateLimitConfig_Override_DynamicMetadata {
    const message = createBaseRateLimitConfig_Override_DynamicMetadata();
    message.metadata_key = (object.metadata_key !== undefined && object.metadata_key !== null)
      ? MetadataKey.fromPartial(object.metadata_key)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(RateLimitConfig_Override_DynamicMetadata.$type, RateLimitConfig_Override_DynamicMetadata);

function createBaseRateLimitPerRoute(): RateLimitPerRoute {
  return { $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimitPerRoute" };
}

export const RateLimitPerRoute: MessageFns<
  RateLimitPerRoute,
  "envoy.extensions.filters.http.ratelimit.v3.RateLimitPerRoute"
> = {
  $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimitPerRoute" as const,

  encode(message: RateLimitPerRoute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (
      message.vh_rate_limits !== undefined && message.vh_rate_limits !== RateLimitPerRoute_VhRateLimitsOptions.OVERRIDE
    ) {
      writer.uint32(8).int32(rateLimitPerRoute_VhRateLimitsOptionsToNumber(message.vh_rate_limits));
    }
    if (
      message.override_option !== undefined && message.override_option !== RateLimitPerRoute_OverrideOptions.DEFAULT
    ) {
      writer.uint32(16).int32(rateLimitPerRoute_OverrideOptionsToNumber(message.override_option));
    }
    if (message.rate_limits !== undefined && message.rate_limits.length !== 0) {
      for (const v of message.rate_limits) {
        RateLimitConfig.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    if (message.domain !== undefined && message.domain !== "") {
      writer.uint32(34).string(message.domain);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimitPerRoute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimitPerRoute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.vh_rate_limits = rateLimitPerRoute_VhRateLimitsOptionsFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.override_option = rateLimitPerRoute_OverrideOptionsFromJSON(reader.int32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.rate_limits === undefined) {
            message.rate_limits = [];
          }
          const el = RateLimitConfig.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.rate_limits!.push(el);
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.domain = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimitPerRoute {
    return {
      $type: RateLimitPerRoute.$type,
      vh_rate_limits: isSet(object.vh_rate_limits)
        ? rateLimitPerRoute_VhRateLimitsOptionsFromJSON(object.vh_rate_limits)
        : undefined,
      override_option: isSet(object.override_option)
        ? rateLimitPerRoute_OverrideOptionsFromJSON(object.override_option)
        : undefined,
      rate_limits: globalThis.Array.isArray(object?.rate_limits)
        ? object.rate_limits.map((e: any) => RateLimitConfig.fromJSON(e))
        : undefined,
      domain: isSet(object.domain) ? globalThis.String(object.domain) : undefined,
    };
  },

  toJSON(message: RateLimitPerRoute): unknown {
    const obj: any = {};
    if (message.vh_rate_limits !== undefined) {
      obj.vh_rate_limits = rateLimitPerRoute_VhRateLimitsOptionsToJSON(message.vh_rate_limits);
    }
    if (message.override_option !== undefined) {
      obj.override_option = rateLimitPerRoute_OverrideOptionsToJSON(message.override_option);
    }
    if (message.rate_limits?.length) {
      obj.rate_limits = message.rate_limits.map((e) => RateLimitConfig.toJSON(e));
    }
    if (message.domain !== undefined) {
      obj.domain = message.domain;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimitPerRoute>, I>>(base?: I): RateLimitPerRoute {
    return RateLimitPerRoute.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimitPerRoute>, I>>(object: I): RateLimitPerRoute {
    const message = createBaseRateLimitPerRoute();
    message.vh_rate_limits = object.vh_rate_limits ?? undefined;
    message.override_option = object.override_option ?? undefined;
    message.rate_limits = object.rate_limits?.map((e) => RateLimitConfig.fromPartial(e)) || undefined;
    message.domain = object.domain ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RateLimitPerRoute.$type, RateLimitPerRoute);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
