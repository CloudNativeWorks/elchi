// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/service/status/v3/csds.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Observable } from "rxjs";
import { map } from "rxjs/operators";
import { Any } from "../../../../google/protobuf/any";
import { Timestamp } from "../../../../google/protobuf/timestamp";
import { messageTypeRegistry } from "../../../../typeRegistry";
import {
  ClientResourceStatus,
  clientResourceStatusFromJSON,
  clientResourceStatusToJSON,
  clientResourceStatusToNumber,
  ClustersConfigDump,
  EndpointsConfigDump,
  ListenersConfigDump,
  RoutesConfigDump,
  ScopedRoutesConfigDump,
  UpdateFailureState,
} from "../../../admin/v3/config_dump_shared";
import { Node } from "../../../config/core/v3/base";
import { NodeMatcher } from "../../../type/matcher/v3/node";

export const protobufPackage = "envoy.service.status.v3";

/** Status of a config from a management server view. */
export enum ConfigStatus {
  /** UNKNOWN - Status info is not available/unknown. */
  UNKNOWN = "UNKNOWN",
  /** SYNCED - Management server has sent the config to client and received ACK. */
  SYNCED = "SYNCED",
  /** NOT_SENT - Config is not sent. */
  NOT_SENT = "NOT_SENT",
  /**
   * STALE - Management server has sent the config to client but hasnâ€™t received
   * ACK/NACK.
   */
  STALE = "STALE",
  /**
   * ERROR - Management server has sent the config to client but received NACK. The
   * attached config dump will be the latest config (the rejected one), since
   * it is the persisted version in the management server.
   */
  ERROR = "ERROR",
}

export function configStatusFromJSON(object: any): ConfigStatus {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return ConfigStatus.UNKNOWN;
    case 1:
    case "SYNCED":
      return ConfigStatus.SYNCED;
    case 2:
    case "NOT_SENT":
      return ConfigStatus.NOT_SENT;
    case 3:
    case "STALE":
      return ConfigStatus.STALE;
    case 4:
    case "ERROR":
      return ConfigStatus.ERROR;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ConfigStatus");
  }
}

export function configStatusToJSON(object: ConfigStatus): string {
  switch (object) {
    case ConfigStatus.UNKNOWN:
      return "UNKNOWN";
    case ConfigStatus.SYNCED:
      return "SYNCED";
    case ConfigStatus.NOT_SENT:
      return "NOT_SENT";
    case ConfigStatus.STALE:
      return "STALE";
    case ConfigStatus.ERROR:
      return "ERROR";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ConfigStatus");
  }
}

export function configStatusToNumber(object: ConfigStatus): number {
  switch (object) {
    case ConfigStatus.UNKNOWN:
      return 0;
    case ConfigStatus.SYNCED:
      return 1;
    case ConfigStatus.NOT_SENT:
      return 2;
    case ConfigStatus.STALE:
      return 3;
    case ConfigStatus.ERROR:
      return 4;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ConfigStatus");
  }
}

/** Config status from a client-side view. */
export enum ClientConfigStatus {
  /** CLIENT_UNKNOWN - Config status is not available/unknown. */
  CLIENT_UNKNOWN = "CLIENT_UNKNOWN",
  /**
   * CLIENT_REQUESTED - Client requested the config but hasn't received any config from management
   * server yet.
   */
  CLIENT_REQUESTED = "CLIENT_REQUESTED",
  /** CLIENT_ACKED - Client received the config and replied with ACK. */
  CLIENT_ACKED = "CLIENT_ACKED",
  /**
   * CLIENT_NACKED - Client received the config and replied with NACK. Notably, the attached
   * config dump is not the NACKed version, but the most recent accepted one. If
   * no config is accepted yet, the attached config dump will be empty.
   */
  CLIENT_NACKED = "CLIENT_NACKED",
}

export function clientConfigStatusFromJSON(object: any): ClientConfigStatus {
  switch (object) {
    case 0:
    case "CLIENT_UNKNOWN":
      return ClientConfigStatus.CLIENT_UNKNOWN;
    case 1:
    case "CLIENT_REQUESTED":
      return ClientConfigStatus.CLIENT_REQUESTED;
    case 2:
    case "CLIENT_ACKED":
      return ClientConfigStatus.CLIENT_ACKED;
    case 3:
    case "CLIENT_NACKED":
      return ClientConfigStatus.CLIENT_NACKED;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ClientConfigStatus");
  }
}

export function clientConfigStatusToJSON(object: ClientConfigStatus): string {
  switch (object) {
    case ClientConfigStatus.CLIENT_UNKNOWN:
      return "CLIENT_UNKNOWN";
    case ClientConfigStatus.CLIENT_REQUESTED:
      return "CLIENT_REQUESTED";
    case ClientConfigStatus.CLIENT_ACKED:
      return "CLIENT_ACKED";
    case ClientConfigStatus.CLIENT_NACKED:
      return "CLIENT_NACKED";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ClientConfigStatus");
  }
}

export function clientConfigStatusToNumber(object: ClientConfigStatus): number {
  switch (object) {
    case ClientConfigStatus.CLIENT_UNKNOWN:
      return 0;
    case ClientConfigStatus.CLIENT_REQUESTED:
      return 1;
    case ClientConfigStatus.CLIENT_ACKED:
      return 2;
    case ClientConfigStatus.CLIENT_NACKED:
      return 3;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ClientConfigStatus");
  }
}

/** Request for client status of clients identified by a list of NodeMatchers. */
export interface ClientStatusRequest {
  $type: "envoy.service.status.v3.ClientStatusRequest";
  /**
   * Management server can use these match criteria to identify clients.
   * The match follows OR semantics.
   */
  node_matchers?:
    | NodeMatcher[]
    | undefined;
  /** The node making the csds request. */
  node?:
    | Node
    | undefined;
  /**
   * If true, the server will not include the resource contents in the response
   * (i.e., the generic_xds_configs.xds_config field will not be populated).
   * [#not-implemented-hide:]
   */
  exclude_resource_contents?: boolean | undefined;
}

/**
 * Detailed config (per xDS) with status.
 * [#next-free-field: 8]
 */
export interface PerXdsConfig {
  $type: "envoy.service.status.v3.PerXdsConfig";
  /**
   * Config status generated by management servers. Will not be present if the
   * CSDS server is an xDS client.
   */
  status?:
    | ConfigStatus
    | undefined;
  /**
   * Client config status is populated by xDS clients. Will not be present if
   * the CSDS server is an xDS server. No matter what the client config status
   * is, xDS clients should always dump the most recent accepted xDS config.
   *
   * .. attention::
   *   This field is deprecated. Use :ref:`ClientResourceStatus
   *   <envoy_v3_api_enum_admin.v3.ClientResourceStatus>` for per-resource
   *   config status instead.
   *
   * @deprecated
   */
  client_status?: ClientConfigStatus | undefined;
  per_xds_config?:
    | //
    { $case: "listener_config"; listener_config: ListenersConfigDump }
    | //
    { $case: "cluster_config"; cluster_config: ClustersConfigDump }
    | //
    { $case: "route_config"; route_config: RoutesConfigDump }
    | //
    { $case: "scoped_route_config"; scoped_route_config: ScopedRoutesConfigDump }
    | //
    { $case: "endpoint_config"; endpoint_config: EndpointsConfigDump }
    | undefined;
}

/** All xds configs for a particular client. */
export interface ClientConfig {
  $type: "envoy.service.status.v3.ClientConfig";
  /** Node for a particular client. */
  node?:
    | Node
    | undefined;
  /**
   * This field is deprecated in favor of generic_xds_configs which is
   * much simpler and uniform in structure.
   *
   * @deprecated
   */
  xds_config?:
    | PerXdsConfig[]
    | undefined;
  /**
   * Represents generic xDS config and the exact config structure depends on
   * the type URL (like Cluster if it is CDS)
   */
  generic_xds_configs?:
    | ClientConfig_GenericXdsConfig[]
    | undefined;
  /**
   * For xDS clients, the scope in which the data is used.
   * For example, gRPC indicates the data plane target or that the data is
   * associated with gRPC server(s).
   */
  client_scope?: string | undefined;
}

/**
 * GenericXdsConfig is used to specify the config status and the dump
 * of any xDS resource identified by their type URL. It is the generalized
 * version of the now deprecated ListenersConfigDump, ClustersConfigDump etc
 * [#next-free-field: 10]
 */
export interface ClientConfig_GenericXdsConfig {
  $type: "envoy.service.status.v3.ClientConfig.GenericXdsConfig";
  /**
   * Type_url represents the fully qualified name of xDS resource type
   * like envoy.v3.Cluster, envoy.v3.ClusterLoadAssignment etc.
   */
  type_url?:
    | string
    | undefined;
  /** Name of the xDS resource */
  name?:
    | string
    | undefined;
  /**
   * This is the :ref:`version_info <envoy_v3_api_field_service.discovery.v3.DiscoveryResponse.version_info>`
   * in the last processed xDS discovery response. If there are only
   * static bootstrap listeners, this field will be ""
   */
  version_info?:
    | string
    | undefined;
  /** The xDS resource config. Actual content depends on the type */
  xds_config?:
    | Any
    | undefined;
  /** Timestamp when the xDS resource was last updated */
  last_updated?:
    | Date
    | undefined;
  /**
   * Per xDS resource config status. It is generated by management servers.
   * It will not be present if the CSDS server is an xDS client.
   */
  config_status?:
    | ConfigStatus
    | undefined;
  /** Per xDS resource status from the view of a xDS client */
  client_status?:
    | ClientResourceStatus
    | undefined;
  /**
   * Set if the last update failed, cleared after the next successful
   * update. The *error_state* field contains the rejected version of
   * this particular resource along with the reason and timestamp. For
   * successfully updated or acknowledged resource, this field should
   * be empty.
   * [#not-implemented-hide:]
   */
  error_state?:
    | UpdateFailureState
    | undefined;
  /**
   * Is static resource is true if it is specified in the config supplied
   * through the file at the startup.
   */
  is_static_resource?: boolean | undefined;
}

export interface ClientStatusResponse {
  $type: "envoy.service.status.v3.ClientStatusResponse";
  /** Client configs for the clients specified in the ClientStatusRequest. */
  config?: ClientConfig[] | undefined;
}

function createBaseClientStatusRequest(): ClientStatusRequest {
  return { $type: "envoy.service.status.v3.ClientStatusRequest" };
}

export const ClientStatusRequest: MessageFns<ClientStatusRequest, "envoy.service.status.v3.ClientStatusRequest"> = {
  $type: "envoy.service.status.v3.ClientStatusRequest" as const,

  encode(message: ClientStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.node_matchers !== undefined && message.node_matchers.length !== 0) {
      for (const v of message.node_matchers) {
        NodeMatcher.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    if (message.node !== undefined) {
      Node.encode(message.node, writer.uint32(18).fork()).join();
    }
    if (message.exclude_resource_contents !== undefined && message.exclude_resource_contents !== false) {
      writer.uint32(24).bool(message.exclude_resource_contents);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.node_matchers === undefined) {
            message.node_matchers = [];
          }
          const el = NodeMatcher.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.node_matchers!.push(el);
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.node = Node.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.exclude_resource_contents = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientStatusRequest {
    return {
      $type: ClientStatusRequest.$type,
      node_matchers: globalThis.Array.isArray(object?.node_matchers)
        ? object.node_matchers.map((e: any) => NodeMatcher.fromJSON(e))
        : undefined,
      node: isSet(object.node) ? Node.fromJSON(object.node) : undefined,
      exclude_resource_contents: isSet(object.exclude_resource_contents)
        ? globalThis.Boolean(object.exclude_resource_contents)
        : undefined,
    };
  },

  toJSON(message: ClientStatusRequest): unknown {
    const obj: any = {};
    if (message.node_matchers?.length) {
      obj.node_matchers = message.node_matchers.map((e) => NodeMatcher.toJSON(e));
    }
    if (message.node !== undefined) {
      obj.node = Node.toJSON(message.node);
    }
    if (message.exclude_resource_contents !== undefined) {
      obj.exclude_resource_contents = message.exclude_resource_contents;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientStatusRequest>, I>>(base?: I): ClientStatusRequest {
    return ClientStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientStatusRequest>, I>>(object: I): ClientStatusRequest {
    const message = createBaseClientStatusRequest();
    message.node_matchers = object.node_matchers?.map((e) => NodeMatcher.fromPartial(e)) || undefined;
    message.node = (object.node !== undefined && object.node !== null) ? Node.fromPartial(object.node) : undefined;
    message.exclude_resource_contents = object.exclude_resource_contents ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ClientStatusRequest.$type, ClientStatusRequest);

function createBasePerXdsConfig(): PerXdsConfig {
  return { $type: "envoy.service.status.v3.PerXdsConfig", per_xds_config: undefined };
}

export const PerXdsConfig: MessageFns<PerXdsConfig, "envoy.service.status.v3.PerXdsConfig"> = {
  $type: "envoy.service.status.v3.PerXdsConfig" as const,

  encode(message: PerXdsConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined && message.status !== ConfigStatus.UNKNOWN) {
      writer.uint32(8).int32(configStatusToNumber(message.status));
    }
    if (message.client_status !== undefined && message.client_status !== ClientConfigStatus.CLIENT_UNKNOWN) {
      writer.uint32(56).int32(clientConfigStatusToNumber(message.client_status));
    }
    switch (message.per_xds_config?.$case) {
      case "listener_config":
        ListenersConfigDump.encode(message.per_xds_config.listener_config, writer.uint32(18).fork()).join();
        break;
      case "cluster_config":
        ClustersConfigDump.encode(message.per_xds_config.cluster_config, writer.uint32(26).fork()).join();
        break;
      case "route_config":
        RoutesConfigDump.encode(message.per_xds_config.route_config, writer.uint32(34).fork()).join();
        break;
      case "scoped_route_config":
        ScopedRoutesConfigDump.encode(message.per_xds_config.scoped_route_config, writer.uint32(42).fork()).join();
        break;
      case "endpoint_config":
        EndpointsConfigDump.encode(message.per_xds_config.endpoint_config, writer.uint32(50).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PerXdsConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePerXdsConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = configStatusFromJSON(reader.int32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.client_status = clientConfigStatusFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.per_xds_config = {
            $case: "listener_config",
            listener_config: ListenersConfigDump.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.per_xds_config = {
            $case: "cluster_config",
            cluster_config: ClustersConfigDump.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.per_xds_config = {
            $case: "route_config",
            route_config: RoutesConfigDump.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.per_xds_config = {
            $case: "scoped_route_config",
            scoped_route_config: ScopedRoutesConfigDump.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.per_xds_config = {
            $case: "endpoint_config",
            endpoint_config: EndpointsConfigDump.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PerXdsConfig {
    return {
      $type: PerXdsConfig.$type,
      status: isSet(object.status) ? configStatusFromJSON(object.status) : undefined,
      client_status: isSet(object.client_status) ? clientConfigStatusFromJSON(object.client_status) : undefined,
      per_xds_config: isSet(object.listener_config)
        ? { $case: "listener_config", listener_config: ListenersConfigDump.fromJSON(object.listener_config) }
        : isSet(object.cluster_config)
        ? { $case: "cluster_config", cluster_config: ClustersConfigDump.fromJSON(object.cluster_config) }
        : isSet(object.route_config)
        ? { $case: "route_config", route_config: RoutesConfigDump.fromJSON(object.route_config) }
        : isSet(object.scoped_route_config)
        ? {
          $case: "scoped_route_config",
          scoped_route_config: ScopedRoutesConfigDump.fromJSON(object.scoped_route_config),
        }
        : isSet(object.endpoint_config)
        ? { $case: "endpoint_config", endpoint_config: EndpointsConfigDump.fromJSON(object.endpoint_config) }
        : undefined,
    };
  },

  toJSON(message: PerXdsConfig): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = configStatusToJSON(message.status);
    }
    if (message.client_status !== undefined) {
      obj.client_status = clientConfigStatusToJSON(message.client_status);
    }
    if (message.per_xds_config?.$case === "listener_config") {
      obj.listener_config = ListenersConfigDump.toJSON(message.per_xds_config.listener_config);
    }
    if (message.per_xds_config?.$case === "cluster_config") {
      obj.cluster_config = ClustersConfigDump.toJSON(message.per_xds_config.cluster_config);
    }
    if (message.per_xds_config?.$case === "route_config") {
      obj.route_config = RoutesConfigDump.toJSON(message.per_xds_config.route_config);
    }
    if (message.per_xds_config?.$case === "scoped_route_config") {
      obj.scoped_route_config = ScopedRoutesConfigDump.toJSON(message.per_xds_config.scoped_route_config);
    }
    if (message.per_xds_config?.$case === "endpoint_config") {
      obj.endpoint_config = EndpointsConfigDump.toJSON(message.per_xds_config.endpoint_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PerXdsConfig>, I>>(base?: I): PerXdsConfig {
    return PerXdsConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PerXdsConfig>, I>>(object: I): PerXdsConfig {
    const message = createBasePerXdsConfig();
    message.status = object.status ?? undefined;
    message.client_status = object.client_status ?? undefined;
    if (
      object.per_xds_config?.$case === "listener_config" &&
      object.per_xds_config?.listener_config !== undefined &&
      object.per_xds_config?.listener_config !== null
    ) {
      message.per_xds_config = {
        $case: "listener_config",
        listener_config: ListenersConfigDump.fromPartial(object.per_xds_config.listener_config),
      };
    }
    if (
      object.per_xds_config?.$case === "cluster_config" &&
      object.per_xds_config?.cluster_config !== undefined &&
      object.per_xds_config?.cluster_config !== null
    ) {
      message.per_xds_config = {
        $case: "cluster_config",
        cluster_config: ClustersConfigDump.fromPartial(object.per_xds_config.cluster_config),
      };
    }
    if (
      object.per_xds_config?.$case === "route_config" &&
      object.per_xds_config?.route_config !== undefined &&
      object.per_xds_config?.route_config !== null
    ) {
      message.per_xds_config = {
        $case: "route_config",
        route_config: RoutesConfigDump.fromPartial(object.per_xds_config.route_config),
      };
    }
    if (
      object.per_xds_config?.$case === "scoped_route_config" &&
      object.per_xds_config?.scoped_route_config !== undefined &&
      object.per_xds_config?.scoped_route_config !== null
    ) {
      message.per_xds_config = {
        $case: "scoped_route_config",
        scoped_route_config: ScopedRoutesConfigDump.fromPartial(object.per_xds_config.scoped_route_config),
      };
    }
    if (
      object.per_xds_config?.$case === "endpoint_config" &&
      object.per_xds_config?.endpoint_config !== undefined &&
      object.per_xds_config?.endpoint_config !== null
    ) {
      message.per_xds_config = {
        $case: "endpoint_config",
        endpoint_config: EndpointsConfigDump.fromPartial(object.per_xds_config.endpoint_config),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(PerXdsConfig.$type, PerXdsConfig);

function createBaseClientConfig(): ClientConfig {
  return { $type: "envoy.service.status.v3.ClientConfig" };
}

export const ClientConfig: MessageFns<ClientConfig, "envoy.service.status.v3.ClientConfig"> = {
  $type: "envoy.service.status.v3.ClientConfig" as const,

  encode(message: ClientConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.node !== undefined) {
      Node.encode(message.node, writer.uint32(10).fork()).join();
    }
    if (message.xds_config !== undefined && message.xds_config.length !== 0) {
      for (const v of message.xds_config) {
        PerXdsConfig.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.generic_xds_configs !== undefined && message.generic_xds_configs.length !== 0) {
      for (const v of message.generic_xds_configs) {
        ClientConfig_GenericXdsConfig.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    if (message.client_scope !== undefined && message.client_scope !== "") {
      writer.uint32(34).string(message.client_scope);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.node = Node.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.xds_config === undefined) {
            message.xds_config = [];
          }
          const el = PerXdsConfig.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.xds_config!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.generic_xds_configs === undefined) {
            message.generic_xds_configs = [];
          }
          const el = ClientConfig_GenericXdsConfig.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.generic_xds_configs!.push(el);
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.client_scope = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientConfig {
    return {
      $type: ClientConfig.$type,
      node: isSet(object.node) ? Node.fromJSON(object.node) : undefined,
      xds_config: globalThis.Array.isArray(object?.xds_config)
        ? object.xds_config.map((e: any) => PerXdsConfig.fromJSON(e))
        : undefined,
      generic_xds_configs: globalThis.Array.isArray(object?.generic_xds_configs)
        ? object.generic_xds_configs.map((e: any) => ClientConfig_GenericXdsConfig.fromJSON(e))
        : undefined,
      client_scope: isSet(object.client_scope) ? globalThis.String(object.client_scope) : undefined,
    };
  },

  toJSON(message: ClientConfig): unknown {
    const obj: any = {};
    if (message.node !== undefined) {
      obj.node = Node.toJSON(message.node);
    }
    if (message.xds_config?.length) {
      obj.xds_config = message.xds_config.map((e) => PerXdsConfig.toJSON(e));
    }
    if (message.generic_xds_configs?.length) {
      obj.generic_xds_configs = message.generic_xds_configs.map((e) => ClientConfig_GenericXdsConfig.toJSON(e));
    }
    if (message.client_scope !== undefined) {
      obj.client_scope = message.client_scope;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientConfig>, I>>(base?: I): ClientConfig {
    return ClientConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientConfig>, I>>(object: I): ClientConfig {
    const message = createBaseClientConfig();
    message.node = (object.node !== undefined && object.node !== null) ? Node.fromPartial(object.node) : undefined;
    message.xds_config = object.xds_config?.map((e) => PerXdsConfig.fromPartial(e)) || undefined;
    message.generic_xds_configs =
      object.generic_xds_configs?.map((e) => ClientConfig_GenericXdsConfig.fromPartial(e)) || undefined;
    message.client_scope = object.client_scope ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ClientConfig.$type, ClientConfig);

function createBaseClientConfig_GenericXdsConfig(): ClientConfig_GenericXdsConfig {
  return { $type: "envoy.service.status.v3.ClientConfig.GenericXdsConfig" };
}

export const ClientConfig_GenericXdsConfig: MessageFns<
  ClientConfig_GenericXdsConfig,
  "envoy.service.status.v3.ClientConfig.GenericXdsConfig"
> = {
  $type: "envoy.service.status.v3.ClientConfig.GenericXdsConfig" as const,

  encode(message: ClientConfig_GenericXdsConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type_url !== undefined && message.type_url !== "") {
      writer.uint32(10).string(message.type_url);
    }
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.version_info !== undefined && message.version_info !== "") {
      writer.uint32(26).string(message.version_info);
    }
    if (message.xds_config !== undefined) {
      Any.encode(message.xds_config, writer.uint32(34).fork()).join();
    }
    if (message.last_updated !== undefined) {
      Timestamp.encode(toTimestamp(message.last_updated), writer.uint32(42).fork()).join();
    }
    if (message.config_status !== undefined && message.config_status !== ConfigStatus.UNKNOWN) {
      writer.uint32(48).int32(configStatusToNumber(message.config_status));
    }
    if (message.client_status !== undefined && message.client_status !== ClientResourceStatus.UNKNOWN) {
      writer.uint32(56).int32(clientResourceStatusToNumber(message.client_status));
    }
    if (message.error_state !== undefined) {
      UpdateFailureState.encode(message.error_state, writer.uint32(66).fork()).join();
    }
    if (message.is_static_resource !== undefined && message.is_static_resource !== false) {
      writer.uint32(72).bool(message.is_static_resource);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientConfig_GenericXdsConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientConfig_GenericXdsConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type_url = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.version_info = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.xds_config = Any.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.last_updated = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.config_status = configStatusFromJSON(reader.int32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.client_status = clientResourceStatusFromJSON(reader.int32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.error_state = UpdateFailureState.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.is_static_resource = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientConfig_GenericXdsConfig {
    return {
      $type: ClientConfig_GenericXdsConfig.$type,
      type_url: isSet(object.type_url) ? globalThis.String(object.type_url) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      version_info: isSet(object.version_info) ? globalThis.String(object.version_info) : undefined,
      xds_config: isSet(object.xds_config) ? Any.fromJSON(object.xds_config) : undefined,
      last_updated: isSet(object.last_updated) ? fromJsonTimestamp(object.last_updated) : undefined,
      config_status: isSet(object.config_status) ? configStatusFromJSON(object.config_status) : undefined,
      client_status: isSet(object.client_status) ? clientResourceStatusFromJSON(object.client_status) : undefined,
      error_state: isSet(object.error_state) ? UpdateFailureState.fromJSON(object.error_state) : undefined,
      is_static_resource: isSet(object.is_static_resource) ? globalThis.Boolean(object.is_static_resource) : undefined,
    };
  },

  toJSON(message: ClientConfig_GenericXdsConfig): unknown {
    const obj: any = {};
    if (message.type_url !== undefined) {
      obj.type_url = message.type_url;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.version_info !== undefined) {
      obj.version_info = message.version_info;
    }
    if (message.xds_config !== undefined) {
      obj.xds_config = Any.toJSON(message.xds_config);
    }
    if (message.last_updated !== undefined) {
      obj.last_updated = message.last_updated.toISOString();
    }
    if (message.config_status !== undefined) {
      obj.config_status = configStatusToJSON(message.config_status);
    }
    if (message.client_status !== undefined) {
      obj.client_status = clientResourceStatusToJSON(message.client_status);
    }
    if (message.error_state !== undefined) {
      obj.error_state = UpdateFailureState.toJSON(message.error_state);
    }
    if (message.is_static_resource !== undefined) {
      obj.is_static_resource = message.is_static_resource;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientConfig_GenericXdsConfig>, I>>(base?: I): ClientConfig_GenericXdsConfig {
    return ClientConfig_GenericXdsConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientConfig_GenericXdsConfig>, I>>(
    object: I,
  ): ClientConfig_GenericXdsConfig {
    const message = createBaseClientConfig_GenericXdsConfig();
    message.type_url = object.type_url ?? undefined;
    message.name = object.name ?? undefined;
    message.version_info = object.version_info ?? undefined;
    message.xds_config = (object.xds_config !== undefined && object.xds_config !== null)
      ? Any.fromPartial(object.xds_config)
      : undefined;
    message.last_updated = object.last_updated ?? undefined;
    message.config_status = object.config_status ?? undefined;
    message.client_status = object.client_status ?? undefined;
    message.error_state = (object.error_state !== undefined && object.error_state !== null)
      ? UpdateFailureState.fromPartial(object.error_state)
      : undefined;
    message.is_static_resource = object.is_static_resource ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ClientConfig_GenericXdsConfig.$type, ClientConfig_GenericXdsConfig);

function createBaseClientStatusResponse(): ClientStatusResponse {
  return { $type: "envoy.service.status.v3.ClientStatusResponse" };
}

export const ClientStatusResponse: MessageFns<ClientStatusResponse, "envoy.service.status.v3.ClientStatusResponse"> = {
  $type: "envoy.service.status.v3.ClientStatusResponse" as const,

  encode(message: ClientStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.config !== undefined && message.config.length !== 0) {
      for (const v of message.config) {
        ClientConfig.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.config === undefined) {
            message.config = [];
          }
          const el = ClientConfig.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.config!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientStatusResponse {
    return {
      $type: ClientStatusResponse.$type,
      config: globalThis.Array.isArray(object?.config)
        ? object.config.map((e: any) => ClientConfig.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: ClientStatusResponse): unknown {
    const obj: any = {};
    if (message.config?.length) {
      obj.config = message.config.map((e) => ClientConfig.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientStatusResponse>, I>>(base?: I): ClientStatusResponse {
    return ClientStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientStatusResponse>, I>>(object: I): ClientStatusResponse {
    const message = createBaseClientStatusResponse();
    message.config = object.config?.map((e) => ClientConfig.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(ClientStatusResponse.$type, ClientStatusResponse);

/**
 * CSDS is Client Status Discovery Service. It can be used to get the status of
 * an xDS-compliant client from the management server's point of view. It can
 * also be used to get the current xDS states directly from the client.
 */
export interface ClientStatusDiscoveryService {
  StreamClientStatus(request: Observable<ClientStatusRequest>): Observable<ClientStatusResponse>;
  FetchClientStatus(request: ClientStatusRequest): Promise<ClientStatusResponse>;
}

export const ClientStatusDiscoveryServiceServiceName = "envoy.service.status.v3.ClientStatusDiscoveryService";
export class ClientStatusDiscoveryServiceClientImpl implements ClientStatusDiscoveryService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || ClientStatusDiscoveryServiceServiceName;
    this.rpc = rpc;
    this.StreamClientStatus = this.StreamClientStatus.bind(this);
    this.FetchClientStatus = this.FetchClientStatus.bind(this);
  }
  StreamClientStatus(request: Observable<ClientStatusRequest>): Observable<ClientStatusResponse> {
    const data = request.pipe(map((request) => ClientStatusRequest.encode(request).finish()));
    const result = this.rpc.bidirectionalStreamingRequest(this.service, "StreamClientStatus", data);
    return result.pipe(map((data) => ClientStatusResponse.decode(new BinaryReader(data))));
  }

  FetchClientStatus(request: ClientStatusRequest): Promise<ClientStatusResponse> {
    const data = ClientStatusRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "FetchClientStatus", data);
    return promise.then((data) => ClientStatusResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
  clientStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Promise<Uint8Array>;
  serverStreamingRequest(service: string, method: string, data: Uint8Array): Observable<Uint8Array>;
  bidirectionalStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Observable<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { $type: "google.protobuf.Timestamp", seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
