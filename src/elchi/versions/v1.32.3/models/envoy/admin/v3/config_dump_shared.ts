// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/admin/v3/config_dump_shared.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Any } from "../../../google/protobuf/any";
import { Timestamp } from "../../../google/protobuf/timestamp";
import { messageTypeRegistry } from "../../../typeRegistry";

export const protobufPackage = "envoy.admin.v3";

/**
 * Resource status from the view of a xDS client, which tells the synchronization
 * status between the xDS client and the xDS server.
 */
export enum ClientResourceStatus {
  /** UNKNOWN - Resource status is not available/unknown. */
  UNKNOWN = "UNKNOWN",
  /**
   * REQUESTED - Client requested this resource but hasn't received any update from management
   * server. The client will not fail requests, but will queue them until update
   * arrives or the client times out waiting for the resource.
   */
  REQUESTED = "REQUESTED",
  /**
   * DOES_NOT_EXIST - This resource has been requested by the client but has either not been
   * delivered by the server or was previously delivered by the server and then
   * subsequently removed from resources provided by the server. For more
   * information, please refer to the :ref:`"Knowing When a Requested Resource
   * Does Not Exist" <xds_protocol_resource_not_existed>` section.
   */
  DOES_NOT_EXIST = "DOES_NOT_EXIST",
  /** ACKED - Client received this resource and replied with ACK. */
  ACKED = "ACKED",
  /** NACKED - Client received this resource and replied with NACK. */
  NACKED = "NACKED",
}

export function clientResourceStatusFromJSON(object: any): ClientResourceStatus {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return ClientResourceStatus.UNKNOWN;
    case 1:
    case "REQUESTED":
      return ClientResourceStatus.REQUESTED;
    case 2:
    case "DOES_NOT_EXIST":
      return ClientResourceStatus.DOES_NOT_EXIST;
    case 3:
    case "ACKED":
      return ClientResourceStatus.ACKED;
    case 4:
    case "NACKED":
      return ClientResourceStatus.NACKED;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ClientResourceStatus");
  }
}

export function clientResourceStatusToJSON(object: ClientResourceStatus): string {
  switch (object) {
    case ClientResourceStatus.UNKNOWN:
      return "UNKNOWN";
    case ClientResourceStatus.REQUESTED:
      return "REQUESTED";
    case ClientResourceStatus.DOES_NOT_EXIST:
      return "DOES_NOT_EXIST";
    case ClientResourceStatus.ACKED:
      return "ACKED";
    case ClientResourceStatus.NACKED:
      return "NACKED";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ClientResourceStatus");
  }
}

export function clientResourceStatusToNumber(object: ClientResourceStatus): number {
  switch (object) {
    case ClientResourceStatus.UNKNOWN:
      return 0;
    case ClientResourceStatus.REQUESTED:
      return 1;
    case ClientResourceStatus.DOES_NOT_EXIST:
      return 2;
    case ClientResourceStatus.ACKED:
      return 3;
    case ClientResourceStatus.NACKED:
      return 4;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ClientResourceStatus");
  }
}

export interface UpdateFailureState {
  $type: "envoy.admin.v3.UpdateFailureState";
  /**
   * What the component configuration would have been if the update had succeeded.
   * This field may not be populated by xDS clients due to storage overhead.
   */
  failed_configuration?:
    | Any
    | undefined;
  /** Time of the latest failed update attempt. */
  last_update_attempt?:
    | Date
    | undefined;
  /** Details about the last failed update attempt. */
  details?:
    | string
    | undefined;
  /**
   * This is the version of the rejected resource.
   * [#not-implemented-hide:]
   */
  version_info?: string | undefined;
}

/**
 * Envoy's listener manager fills this message with all currently known listeners. Listener
 * configuration information can be used to recreate an Envoy configuration by populating all
 * listeners as static listeners or by returning them in a LDS response.
 */
export interface ListenersConfigDump {
  $type: "envoy.admin.v3.ListenersConfigDump";
  /**
   * This is the :ref:`version_info <envoy_v3_api_field_service.discovery.v3.DiscoveryResponse.version_info>` in the
   * last processed LDS discovery response. If there are only static bootstrap listeners, this field
   * will be "".
   */
  version_info?:
    | string
    | undefined;
  /** The statically loaded listener configs. */
  static_listeners?:
    | ListenersConfigDump_StaticListener[]
    | undefined;
  /** State for any warming, active, or draining listeners. */
  dynamic_listeners?: ListenersConfigDump_DynamicListener[] | undefined;
}

/** Describes a statically loaded listener. */
export interface ListenersConfigDump_StaticListener {
  $type: "envoy.admin.v3.ListenersConfigDump.StaticListener";
  /** The listener config. */
  listener?:
    | Any
    | undefined;
  /** The timestamp when the Listener was last successfully updated. */
  last_updated?: Date | undefined;
}

export interface ListenersConfigDump_DynamicListenerState {
  $type: "envoy.admin.v3.ListenersConfigDump.DynamicListenerState";
  /**
   * This is the per-resource version information. This version is currently taken from the
   * :ref:`version_info <envoy_v3_api_field_service.discovery.v3.DiscoveryResponse.version_info>` field at the time
   * that the listener was loaded. In the future, discrete per-listener versions may be supported
   * by the API.
   */
  version_info?:
    | string
    | undefined;
  /** The listener config. */
  listener?:
    | Any
    | undefined;
  /** The timestamp when the Listener was last successfully updated. */
  last_updated?: Date | undefined;
}

/**
 * Describes a dynamically loaded listener via the LDS API.
 * [#next-free-field: 7]
 */
export interface ListenersConfigDump_DynamicListener {
  $type: "envoy.admin.v3.ListenersConfigDump.DynamicListener";
  /** The name or unique id of this listener, pulled from the DynamicListenerState config. */
  name?:
    | string
    | undefined;
  /**
   * The listener state for any active listener by this name.
   * These are listeners that are available to service data plane traffic.
   */
  active_state?:
    | ListenersConfigDump_DynamicListenerState
    | undefined;
  /**
   * The listener state for any warming listener by this name.
   * These are listeners that are currently undergoing warming in preparation to service data
   * plane traffic. Note that if attempting to recreate an Envoy configuration from a
   * configuration dump, the warming listeners should generally be discarded.
   */
  warming_state?:
    | ListenersConfigDump_DynamicListenerState
    | undefined;
  /**
   * The listener state for any draining listener by this name.
   * These are listeners that are currently undergoing draining in preparation to stop servicing
   * data plane traffic. Note that if attempting to recreate an Envoy configuration from a
   * configuration dump, the draining listeners should generally be discarded.
   */
  draining_state?:
    | ListenersConfigDump_DynamicListenerState
    | undefined;
  /**
   * Set if the last update failed, cleared after the next successful update.
   * The ``error_state`` field contains the rejected version of this particular
   * resource along with the reason and timestamp. For successfully updated or
   * acknowledged resource, this field should be empty.
   */
  error_state?:
    | UpdateFailureState
    | undefined;
  /**
   * The client status of this resource.
   * [#not-implemented-hide:]
   */
  client_status?: ClientResourceStatus | undefined;
}

/**
 * Envoy's cluster manager fills this message with all currently known clusters. Cluster
 * configuration information can be used to recreate an Envoy configuration by populating all
 * clusters as static clusters or by returning them in a CDS response.
 */
export interface ClustersConfigDump {
  $type: "envoy.admin.v3.ClustersConfigDump";
  /**
   * This is the :ref:`version_info <envoy_v3_api_field_service.discovery.v3.DiscoveryResponse.version_info>` in the
   * last processed CDS discovery response. If there are only static bootstrap clusters, this field
   * will be "".
   */
  version_info?:
    | string
    | undefined;
  /** The statically loaded cluster configs. */
  static_clusters?:
    | ClustersConfigDump_StaticCluster[]
    | undefined;
  /**
   * The dynamically loaded active clusters. These are clusters that are available to service
   * data plane traffic.
   */
  dynamic_active_clusters?:
    | ClustersConfigDump_DynamicCluster[]
    | undefined;
  /**
   * The dynamically loaded warming clusters. These are clusters that are currently undergoing
   * warming in preparation to service data plane traffic. Note that if attempting to recreate an
   * Envoy configuration from a configuration dump, the warming clusters should generally be
   * discarded.
   */
  dynamic_warming_clusters?: ClustersConfigDump_DynamicCluster[] | undefined;
}

/** Describes a statically loaded cluster. */
export interface ClustersConfigDump_StaticCluster {
  $type: "envoy.admin.v3.ClustersConfigDump.StaticCluster";
  /** The cluster config. */
  cluster?:
    | Any
    | undefined;
  /** The timestamp when the Cluster was last updated. */
  last_updated?: Date | undefined;
}

/**
 * Describes a dynamically loaded cluster via the CDS API.
 * [#next-free-field: 6]
 */
export interface ClustersConfigDump_DynamicCluster {
  $type: "envoy.admin.v3.ClustersConfigDump.DynamicCluster";
  /**
   * This is the per-resource version information. This version is currently taken from the
   * :ref:`version_info <envoy_v3_api_field_service.discovery.v3.DiscoveryResponse.version_info>` field at the time
   * that the cluster was loaded. In the future, discrete per-cluster versions may be supported by
   * the API.
   */
  version_info?:
    | string
    | undefined;
  /** The cluster config. */
  cluster?:
    | Any
    | undefined;
  /** The timestamp when the Cluster was last updated. */
  last_updated?:
    | Date
    | undefined;
  /**
   * Set if the last update failed, cleared after the next successful update.
   * The ``error_state`` field contains the rejected version of this particular
   * resource along with the reason and timestamp. For successfully updated or
   * acknowledged resource, this field should be empty.
   * [#not-implemented-hide:]
   */
  error_state?:
    | UpdateFailureState
    | undefined;
  /**
   * The client status of this resource.
   * [#not-implemented-hide:]
   */
  client_status?: ClientResourceStatus | undefined;
}

/**
 * Envoy's RDS implementation fills this message with all currently loaded routes, as described by
 * their RouteConfiguration objects. Static routes that are either defined in the bootstrap configuration
 * or defined inline while configuring listeners are separated from those configured dynamically via RDS.
 * Route configuration information can be used to recreate an Envoy configuration by populating all routes
 * as static routes or by returning them in RDS responses.
 */
export interface RoutesConfigDump {
  $type: "envoy.admin.v3.RoutesConfigDump";
  /** The statically loaded route configs. */
  static_route_configs?:
    | RoutesConfigDump_StaticRouteConfig[]
    | undefined;
  /** The dynamically loaded route configs. */
  dynamic_route_configs?: RoutesConfigDump_DynamicRouteConfig[] | undefined;
}

export interface RoutesConfigDump_StaticRouteConfig {
  $type: "envoy.admin.v3.RoutesConfigDump.StaticRouteConfig";
  /** The route config. */
  route_config?:
    | Any
    | undefined;
  /** The timestamp when the Route was last updated. */
  last_updated?: Date | undefined;
}

/** [#next-free-field: 6] */
export interface RoutesConfigDump_DynamicRouteConfig {
  $type: "envoy.admin.v3.RoutesConfigDump.DynamicRouteConfig";
  /**
   * This is the per-resource version information. This version is currently taken from the
   * :ref:`version_info <envoy_v3_api_field_service.discovery.v3.DiscoveryResponse.version_info>` field at the time that
   * the route configuration was loaded.
   */
  version_info?:
    | string
    | undefined;
  /** The route config. */
  route_config?:
    | Any
    | undefined;
  /** The timestamp when the Route was last updated. */
  last_updated?:
    | Date
    | undefined;
  /**
   * Set if the last update failed, cleared after the next successful update.
   * The ``error_state`` field contains the rejected version of this particular
   * resource along with the reason and timestamp. For successfully updated or
   * acknowledged resource, this field should be empty.
   * [#not-implemented-hide:]
   */
  error_state?:
    | UpdateFailureState
    | undefined;
  /**
   * The client status of this resource.
   * [#not-implemented-hide:]
   */
  client_status?: ClientResourceStatus | undefined;
}

/**
 * Envoy's scoped RDS implementation fills this message with all currently loaded route
 * configuration scopes (defined via ScopedRouteConfigurationsSet protos). This message lists both
 * the scopes defined inline with the higher order object (i.e., the HttpConnectionManager) and the
 * dynamically obtained scopes via the SRDS API.
 */
export interface ScopedRoutesConfigDump {
  $type: "envoy.admin.v3.ScopedRoutesConfigDump";
  /** The statically loaded scoped route configs. */
  inline_scoped_route_configs?:
    | ScopedRoutesConfigDump_InlineScopedRouteConfigs[]
    | undefined;
  /** The dynamically loaded scoped route configs. */
  dynamic_scoped_route_configs?: ScopedRoutesConfigDump_DynamicScopedRouteConfigs[] | undefined;
}

export interface ScopedRoutesConfigDump_InlineScopedRouteConfigs {
  $type: "envoy.admin.v3.ScopedRoutesConfigDump.InlineScopedRouteConfigs";
  /** The name assigned to the scoped route configurations. */
  name?:
    | string
    | undefined;
  /** The scoped route configurations. */
  scoped_route_configs?:
    | Any[]
    | undefined;
  /** The timestamp when the scoped route config set was last updated. */
  last_updated?: Date | undefined;
}

/** [#next-free-field: 7] */
export interface ScopedRoutesConfigDump_DynamicScopedRouteConfigs {
  $type: "envoy.admin.v3.ScopedRoutesConfigDump.DynamicScopedRouteConfigs";
  /** The name assigned to the scoped route configurations. */
  name?:
    | string
    | undefined;
  /**
   * This is the per-resource version information. This version is currently taken from the
   * :ref:`version_info <envoy_v3_api_field_service.discovery.v3.DiscoveryResponse.version_info>` field at the time that
   * the scoped routes configuration was loaded.
   */
  version_info?:
    | string
    | undefined;
  /** The scoped route configurations. */
  scoped_route_configs?:
    | Any[]
    | undefined;
  /** The timestamp when the scoped route config set was last updated. */
  last_updated?:
    | Date
    | undefined;
  /**
   * Set if the last update failed, cleared after the next successful update.
   * The ``error_state`` field contains the rejected version of this particular
   * resource along with the reason and timestamp. For successfully updated or
   * acknowledged resource, this field should be empty.
   * [#not-implemented-hide:]
   */
  error_state?:
    | UpdateFailureState
    | undefined;
  /**
   * The client status of this resource.
   * [#not-implemented-hide:]
   */
  client_status?: ClientResourceStatus | undefined;
}

/**
 * Envoy's admin fill this message with all currently known endpoints. Endpoint
 * configuration information can be used to recreate an Envoy configuration by populating all
 * endpoints as static endpoints or by returning them in an EDS response.
 */
export interface EndpointsConfigDump {
  $type: "envoy.admin.v3.EndpointsConfigDump";
  /** The statically loaded endpoint configs. */
  static_endpoint_configs?:
    | EndpointsConfigDump_StaticEndpointConfig[]
    | undefined;
  /** The dynamically loaded endpoint configs. */
  dynamic_endpoint_configs?: EndpointsConfigDump_DynamicEndpointConfig[] | undefined;
}

export interface EndpointsConfigDump_StaticEndpointConfig {
  $type: "envoy.admin.v3.EndpointsConfigDump.StaticEndpointConfig";
  /** The endpoint config. */
  endpoint_config?:
    | Any
    | undefined;
  /** [#not-implemented-hide:] The timestamp when the Endpoint was last updated. */
  last_updated?: Date | undefined;
}

/** [#next-free-field: 6] */
export interface EndpointsConfigDump_DynamicEndpointConfig {
  $type: "envoy.admin.v3.EndpointsConfigDump.DynamicEndpointConfig";
  /**
   * [#not-implemented-hide:] This is the per-resource version information. This version is currently taken from the
   * :ref:`version_info <envoy_v3_api_field_service.discovery.v3.DiscoveryResponse.version_info>` field at the time that
   * the endpoint configuration was loaded.
   */
  version_info?:
    | string
    | undefined;
  /** The endpoint config. */
  endpoint_config?:
    | Any
    | undefined;
  /** [#not-implemented-hide:] The timestamp when the Endpoint was last updated. */
  last_updated?:
    | Date
    | undefined;
  /**
   * Set if the last update failed, cleared after the next successful update.
   * The ``error_state`` field contains the rejected version of this particular
   * resource along with the reason and timestamp. For successfully updated or
   * acknowledged resource, this field should be empty.
   * [#not-implemented-hide:]
   */
  error_state?:
    | UpdateFailureState
    | undefined;
  /**
   * The client status of this resource.
   * [#not-implemented-hide:]
   */
  client_status?: ClientResourceStatus | undefined;
}

/**
 * Envoy's ECDS service fills this message with all currently extension
 * configuration. Extension configuration information can be used to recreate
 * an Envoy ECDS listener and HTTP filters as static filters or by returning
 * them in ECDS response.
 */
export interface EcdsConfigDump {
  $type: "envoy.admin.v3.EcdsConfigDump";
  /** The ECDS filter configs. */
  ecds_filters?: EcdsConfigDump_EcdsFilterConfig[] | undefined;
}

/** [#next-free-field: 6] */
export interface EcdsConfigDump_EcdsFilterConfig {
  $type: "envoy.admin.v3.EcdsConfigDump.EcdsFilterConfig";
  /**
   * This is the per-resource version information. This version is currently
   * taken from the :ref:`version_info
   * <envoy_v3_api_field_service.discovery.v3.DiscoveryResponse.version_info>`
   * field at the time that the ECDS filter was loaded.
   */
  version_info?:
    | string
    | undefined;
  /** The ECDS filter config. */
  ecds_filter?:
    | Any
    | undefined;
  /** The timestamp when the ECDS filter was last updated. */
  last_updated?:
    | Date
    | undefined;
  /**
   * Set if the last update failed, cleared after the next successful update.
   * The ``error_state`` field contains the rejected version of this
   * particular resource along with the reason and timestamp. For successfully
   * updated or acknowledged resource, this field should be empty.
   * [#not-implemented-hide:]
   */
  error_state?:
    | UpdateFailureState
    | undefined;
  /**
   * The client status of this resource.
   * [#not-implemented-hide:]
   */
  client_status?: ClientResourceStatus | undefined;
}

function createBaseUpdateFailureState(): UpdateFailureState {
  return { $type: "envoy.admin.v3.UpdateFailureState" };
}

export const UpdateFailureState: MessageFns<UpdateFailureState, "envoy.admin.v3.UpdateFailureState"> = {
  $type: "envoy.admin.v3.UpdateFailureState" as const,

  encode(message: UpdateFailureState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.failed_configuration !== undefined) {
      Any.encode(message.failed_configuration, writer.uint32(10).fork()).join();
    }
    if (message.last_update_attempt !== undefined) {
      Timestamp.encode(toTimestamp(message.last_update_attempt), writer.uint32(18).fork()).join();
    }
    if (message.details !== undefined && message.details !== "") {
      writer.uint32(26).string(message.details);
    }
    if (message.version_info !== undefined && message.version_info !== "") {
      writer.uint32(34).string(message.version_info);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateFailureState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateFailureState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.failed_configuration = Any.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.last_update_attempt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.details = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.version_info = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateFailureState {
    return {
      $type: UpdateFailureState.$type,
      failed_configuration: isSet(object.failed_configuration) ? Any.fromJSON(object.failed_configuration) : undefined,
      last_update_attempt: isSet(object.last_update_attempt)
        ? fromJsonTimestamp(object.last_update_attempt)
        : undefined,
      details: isSet(object.details) ? globalThis.String(object.details) : undefined,
      version_info: isSet(object.version_info) ? globalThis.String(object.version_info) : undefined,
    };
  },

  toJSON(message: UpdateFailureState): unknown {
    const obj: any = {};
    if (message.failed_configuration !== undefined) {
      obj.failed_configuration = Any.toJSON(message.failed_configuration);
    }
    if (message.last_update_attempt !== undefined) {
      obj.last_update_attempt = message.last_update_attempt.toISOString();
    }
    if (message.details !== undefined) {
      obj.details = message.details;
    }
    if (message.version_info !== undefined) {
      obj.version_info = message.version_info;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateFailureState>, I>>(base?: I): UpdateFailureState {
    return UpdateFailureState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateFailureState>, I>>(object: I): UpdateFailureState {
    const message = createBaseUpdateFailureState();
    message.failed_configuration = (object.failed_configuration !== undefined && object.failed_configuration !== null)
      ? Any.fromPartial(object.failed_configuration)
      : undefined;
    message.last_update_attempt = object.last_update_attempt ?? undefined;
    message.details = object.details ?? undefined;
    message.version_info = object.version_info ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(UpdateFailureState.$type, UpdateFailureState);

function createBaseListenersConfigDump(): ListenersConfigDump {
  return { $type: "envoy.admin.v3.ListenersConfigDump" };
}

export const ListenersConfigDump: MessageFns<ListenersConfigDump, "envoy.admin.v3.ListenersConfigDump"> = {
  $type: "envoy.admin.v3.ListenersConfigDump" as const,

  encode(message: ListenersConfigDump, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version_info !== undefined && message.version_info !== "") {
      writer.uint32(10).string(message.version_info);
    }
    if (message.static_listeners !== undefined && message.static_listeners.length !== 0) {
      for (const v of message.static_listeners) {
        ListenersConfigDump_StaticListener.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.dynamic_listeners !== undefined && message.dynamic_listeners.length !== 0) {
      for (const v of message.dynamic_listeners) {
        ListenersConfigDump_DynamicListener.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListenersConfigDump {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListenersConfigDump();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version_info = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.static_listeners === undefined) {
            message.static_listeners = [];
          }
          const el = ListenersConfigDump_StaticListener.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.static_listeners!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.dynamic_listeners === undefined) {
            message.dynamic_listeners = [];
          }
          const el = ListenersConfigDump_DynamicListener.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.dynamic_listeners!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListenersConfigDump {
    return {
      $type: ListenersConfigDump.$type,
      version_info: isSet(object.version_info) ? globalThis.String(object.version_info) : undefined,
      static_listeners: globalThis.Array.isArray(object?.static_listeners)
        ? object.static_listeners.map((e: any) => ListenersConfigDump_StaticListener.fromJSON(e))
        : undefined,
      dynamic_listeners: globalThis.Array.isArray(object?.dynamic_listeners)
        ? object.dynamic_listeners.map((e: any) => ListenersConfigDump_DynamicListener.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: ListenersConfigDump): unknown {
    const obj: any = {};
    if (message.version_info !== undefined) {
      obj.version_info = message.version_info;
    }
    if (message.static_listeners?.length) {
      obj.static_listeners = message.static_listeners.map((e) => ListenersConfigDump_StaticListener.toJSON(e));
    }
    if (message.dynamic_listeners?.length) {
      obj.dynamic_listeners = message.dynamic_listeners.map((e) => ListenersConfigDump_DynamicListener.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListenersConfigDump>, I>>(base?: I): ListenersConfigDump {
    return ListenersConfigDump.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListenersConfigDump>, I>>(object: I): ListenersConfigDump {
    const message = createBaseListenersConfigDump();
    message.version_info = object.version_info ?? undefined;
    message.static_listeners = object.static_listeners?.map((e) => ListenersConfigDump_StaticListener.fromPartial(e)) ||
      undefined;
    message.dynamic_listeners =
      object.dynamic_listeners?.map((e) => ListenersConfigDump_DynamicListener.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(ListenersConfigDump.$type, ListenersConfigDump);

function createBaseListenersConfigDump_StaticListener(): ListenersConfigDump_StaticListener {
  return { $type: "envoy.admin.v3.ListenersConfigDump.StaticListener" };
}

export const ListenersConfigDump_StaticListener: MessageFns<
  ListenersConfigDump_StaticListener,
  "envoy.admin.v3.ListenersConfigDump.StaticListener"
> = {
  $type: "envoy.admin.v3.ListenersConfigDump.StaticListener" as const,

  encode(message: ListenersConfigDump_StaticListener, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.listener !== undefined) {
      Any.encode(message.listener, writer.uint32(10).fork()).join();
    }
    if (message.last_updated !== undefined) {
      Timestamp.encode(toTimestamp(message.last_updated), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListenersConfigDump_StaticListener {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListenersConfigDump_StaticListener();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.listener = Any.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.last_updated = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListenersConfigDump_StaticListener {
    return {
      $type: ListenersConfigDump_StaticListener.$type,
      listener: isSet(object.listener) ? Any.fromJSON(object.listener) : undefined,
      last_updated: isSet(object.last_updated) ? fromJsonTimestamp(object.last_updated) : undefined,
    };
  },

  toJSON(message: ListenersConfigDump_StaticListener): unknown {
    const obj: any = {};
    if (message.listener !== undefined) {
      obj.listener = Any.toJSON(message.listener);
    }
    if (message.last_updated !== undefined) {
      obj.last_updated = message.last_updated.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListenersConfigDump_StaticListener>, I>>(
    base?: I,
  ): ListenersConfigDump_StaticListener {
    return ListenersConfigDump_StaticListener.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListenersConfigDump_StaticListener>, I>>(
    object: I,
  ): ListenersConfigDump_StaticListener {
    const message = createBaseListenersConfigDump_StaticListener();
    message.listener = (object.listener !== undefined && object.listener !== null)
      ? Any.fromPartial(object.listener)
      : undefined;
    message.last_updated = object.last_updated ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ListenersConfigDump_StaticListener.$type, ListenersConfigDump_StaticListener);

function createBaseListenersConfigDump_DynamicListenerState(): ListenersConfigDump_DynamicListenerState {
  return { $type: "envoy.admin.v3.ListenersConfigDump.DynamicListenerState" };
}

export const ListenersConfigDump_DynamicListenerState: MessageFns<
  ListenersConfigDump_DynamicListenerState,
  "envoy.admin.v3.ListenersConfigDump.DynamicListenerState"
> = {
  $type: "envoy.admin.v3.ListenersConfigDump.DynamicListenerState" as const,

  encode(message: ListenersConfigDump_DynamicListenerState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version_info !== undefined && message.version_info !== "") {
      writer.uint32(10).string(message.version_info);
    }
    if (message.listener !== undefined) {
      Any.encode(message.listener, writer.uint32(18).fork()).join();
    }
    if (message.last_updated !== undefined) {
      Timestamp.encode(toTimestamp(message.last_updated), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListenersConfigDump_DynamicListenerState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListenersConfigDump_DynamicListenerState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version_info = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.listener = Any.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.last_updated = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListenersConfigDump_DynamicListenerState {
    return {
      $type: ListenersConfigDump_DynamicListenerState.$type,
      version_info: isSet(object.version_info) ? globalThis.String(object.version_info) : undefined,
      listener: isSet(object.listener) ? Any.fromJSON(object.listener) : undefined,
      last_updated: isSet(object.last_updated) ? fromJsonTimestamp(object.last_updated) : undefined,
    };
  },

  toJSON(message: ListenersConfigDump_DynamicListenerState): unknown {
    const obj: any = {};
    if (message.version_info !== undefined) {
      obj.version_info = message.version_info;
    }
    if (message.listener !== undefined) {
      obj.listener = Any.toJSON(message.listener);
    }
    if (message.last_updated !== undefined) {
      obj.last_updated = message.last_updated.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListenersConfigDump_DynamicListenerState>, I>>(
    base?: I,
  ): ListenersConfigDump_DynamicListenerState {
    return ListenersConfigDump_DynamicListenerState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListenersConfigDump_DynamicListenerState>, I>>(
    object: I,
  ): ListenersConfigDump_DynamicListenerState {
    const message = createBaseListenersConfigDump_DynamicListenerState();
    message.version_info = object.version_info ?? undefined;
    message.listener = (object.listener !== undefined && object.listener !== null)
      ? Any.fromPartial(object.listener)
      : undefined;
    message.last_updated = object.last_updated ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ListenersConfigDump_DynamicListenerState.$type, ListenersConfigDump_DynamicListenerState);

function createBaseListenersConfigDump_DynamicListener(): ListenersConfigDump_DynamicListener {
  return { $type: "envoy.admin.v3.ListenersConfigDump.DynamicListener" };
}

export const ListenersConfigDump_DynamicListener: MessageFns<
  ListenersConfigDump_DynamicListener,
  "envoy.admin.v3.ListenersConfigDump.DynamicListener"
> = {
  $type: "envoy.admin.v3.ListenersConfigDump.DynamicListener" as const,

  encode(message: ListenersConfigDump_DynamicListener, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.active_state !== undefined) {
      ListenersConfigDump_DynamicListenerState.encode(message.active_state, writer.uint32(18).fork()).join();
    }
    if (message.warming_state !== undefined) {
      ListenersConfigDump_DynamicListenerState.encode(message.warming_state, writer.uint32(26).fork()).join();
    }
    if (message.draining_state !== undefined) {
      ListenersConfigDump_DynamicListenerState.encode(message.draining_state, writer.uint32(34).fork()).join();
    }
    if (message.error_state !== undefined) {
      UpdateFailureState.encode(message.error_state, writer.uint32(42).fork()).join();
    }
    if (message.client_status !== undefined && message.client_status !== ClientResourceStatus.UNKNOWN) {
      writer.uint32(48).int32(clientResourceStatusToNumber(message.client_status));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListenersConfigDump_DynamicListener {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListenersConfigDump_DynamicListener();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.active_state = ListenersConfigDump_DynamicListenerState.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.warming_state = ListenersConfigDump_DynamicListenerState.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.draining_state = ListenersConfigDump_DynamicListenerState.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.error_state = UpdateFailureState.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.client_status = clientResourceStatusFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListenersConfigDump_DynamicListener {
    return {
      $type: ListenersConfigDump_DynamicListener.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      active_state: isSet(object.active_state)
        ? ListenersConfigDump_DynamicListenerState.fromJSON(object.active_state)
        : undefined,
      warming_state: isSet(object.warming_state)
        ? ListenersConfigDump_DynamicListenerState.fromJSON(object.warming_state)
        : undefined,
      draining_state: isSet(object.draining_state)
        ? ListenersConfigDump_DynamicListenerState.fromJSON(object.draining_state)
        : undefined,
      error_state: isSet(object.error_state) ? UpdateFailureState.fromJSON(object.error_state) : undefined,
      client_status: isSet(object.client_status) ? clientResourceStatusFromJSON(object.client_status) : undefined,
    };
  },

  toJSON(message: ListenersConfigDump_DynamicListener): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.active_state !== undefined) {
      obj.active_state = ListenersConfigDump_DynamicListenerState.toJSON(message.active_state);
    }
    if (message.warming_state !== undefined) {
      obj.warming_state = ListenersConfigDump_DynamicListenerState.toJSON(message.warming_state);
    }
    if (message.draining_state !== undefined) {
      obj.draining_state = ListenersConfigDump_DynamicListenerState.toJSON(message.draining_state);
    }
    if (message.error_state !== undefined) {
      obj.error_state = UpdateFailureState.toJSON(message.error_state);
    }
    if (message.client_status !== undefined) {
      obj.client_status = clientResourceStatusToJSON(message.client_status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListenersConfigDump_DynamicListener>, I>>(
    base?: I,
  ): ListenersConfigDump_DynamicListener {
    return ListenersConfigDump_DynamicListener.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListenersConfigDump_DynamicListener>, I>>(
    object: I,
  ): ListenersConfigDump_DynamicListener {
    const message = createBaseListenersConfigDump_DynamicListener();
    message.name = object.name ?? undefined;
    message.active_state = (object.active_state !== undefined && object.active_state !== null)
      ? ListenersConfigDump_DynamicListenerState.fromPartial(object.active_state)
      : undefined;
    message.warming_state = (object.warming_state !== undefined && object.warming_state !== null)
      ? ListenersConfigDump_DynamicListenerState.fromPartial(object.warming_state)
      : undefined;
    message.draining_state = (object.draining_state !== undefined && object.draining_state !== null)
      ? ListenersConfigDump_DynamicListenerState.fromPartial(object.draining_state)
      : undefined;
    message.error_state = (object.error_state !== undefined && object.error_state !== null)
      ? UpdateFailureState.fromPartial(object.error_state)
      : undefined;
    message.client_status = object.client_status ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ListenersConfigDump_DynamicListener.$type, ListenersConfigDump_DynamicListener);

function createBaseClustersConfigDump(): ClustersConfigDump {
  return { $type: "envoy.admin.v3.ClustersConfigDump" };
}

export const ClustersConfigDump: MessageFns<ClustersConfigDump, "envoy.admin.v3.ClustersConfigDump"> = {
  $type: "envoy.admin.v3.ClustersConfigDump" as const,

  encode(message: ClustersConfigDump, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version_info !== undefined && message.version_info !== "") {
      writer.uint32(10).string(message.version_info);
    }
    if (message.static_clusters !== undefined && message.static_clusters.length !== 0) {
      for (const v of message.static_clusters) {
        ClustersConfigDump_StaticCluster.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.dynamic_active_clusters !== undefined && message.dynamic_active_clusters.length !== 0) {
      for (const v of message.dynamic_active_clusters) {
        ClustersConfigDump_DynamicCluster.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    if (message.dynamic_warming_clusters !== undefined && message.dynamic_warming_clusters.length !== 0) {
      for (const v of message.dynamic_warming_clusters) {
        ClustersConfigDump_DynamicCluster.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClustersConfigDump {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClustersConfigDump();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version_info = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.static_clusters === undefined) {
            message.static_clusters = [];
          }
          const el = ClustersConfigDump_StaticCluster.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.static_clusters!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.dynamic_active_clusters === undefined) {
            message.dynamic_active_clusters = [];
          }
          const el = ClustersConfigDump_DynamicCluster.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.dynamic_active_clusters!.push(el);
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          if (message.dynamic_warming_clusters === undefined) {
            message.dynamic_warming_clusters = [];
          }
          const el = ClustersConfigDump_DynamicCluster.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.dynamic_warming_clusters!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClustersConfigDump {
    return {
      $type: ClustersConfigDump.$type,
      version_info: isSet(object.version_info) ? globalThis.String(object.version_info) : undefined,
      static_clusters: globalThis.Array.isArray(object?.static_clusters)
        ? object.static_clusters.map((e: any) => ClustersConfigDump_StaticCluster.fromJSON(e))
        : undefined,
      dynamic_active_clusters: globalThis.Array.isArray(object?.dynamic_active_clusters)
        ? object.dynamic_active_clusters.map((e: any) => ClustersConfigDump_DynamicCluster.fromJSON(e))
        : undefined,
      dynamic_warming_clusters: globalThis.Array.isArray(object?.dynamic_warming_clusters)
        ? object.dynamic_warming_clusters.map((e: any) => ClustersConfigDump_DynamicCluster.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: ClustersConfigDump): unknown {
    const obj: any = {};
    if (message.version_info !== undefined) {
      obj.version_info = message.version_info;
    }
    if (message.static_clusters?.length) {
      obj.static_clusters = message.static_clusters.map((e) => ClustersConfigDump_StaticCluster.toJSON(e));
    }
    if (message.dynamic_active_clusters?.length) {
      obj.dynamic_active_clusters = message.dynamic_active_clusters.map((e) =>
        ClustersConfigDump_DynamicCluster.toJSON(e)
      );
    }
    if (message.dynamic_warming_clusters?.length) {
      obj.dynamic_warming_clusters = message.dynamic_warming_clusters.map((e) =>
        ClustersConfigDump_DynamicCluster.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClustersConfigDump>, I>>(base?: I): ClustersConfigDump {
    return ClustersConfigDump.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClustersConfigDump>, I>>(object: I): ClustersConfigDump {
    const message = createBaseClustersConfigDump();
    message.version_info = object.version_info ?? undefined;
    message.static_clusters = object.static_clusters?.map((e) => ClustersConfigDump_StaticCluster.fromPartial(e)) ||
      undefined;
    message.dynamic_active_clusters =
      object.dynamic_active_clusters?.map((e) => ClustersConfigDump_DynamicCluster.fromPartial(e)) || undefined;
    message.dynamic_warming_clusters =
      object.dynamic_warming_clusters?.map((e) => ClustersConfigDump_DynamicCluster.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(ClustersConfigDump.$type, ClustersConfigDump);

function createBaseClustersConfigDump_StaticCluster(): ClustersConfigDump_StaticCluster {
  return { $type: "envoy.admin.v3.ClustersConfigDump.StaticCluster" };
}

export const ClustersConfigDump_StaticCluster: MessageFns<
  ClustersConfigDump_StaticCluster,
  "envoy.admin.v3.ClustersConfigDump.StaticCluster"
> = {
  $type: "envoy.admin.v3.ClustersConfigDump.StaticCluster" as const,

  encode(message: ClustersConfigDump_StaticCluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cluster !== undefined) {
      Any.encode(message.cluster, writer.uint32(10).fork()).join();
    }
    if (message.last_updated !== undefined) {
      Timestamp.encode(toTimestamp(message.last_updated), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClustersConfigDump_StaticCluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClustersConfigDump_StaticCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cluster = Any.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.last_updated = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClustersConfigDump_StaticCluster {
    return {
      $type: ClustersConfigDump_StaticCluster.$type,
      cluster: isSet(object.cluster) ? Any.fromJSON(object.cluster) : undefined,
      last_updated: isSet(object.last_updated) ? fromJsonTimestamp(object.last_updated) : undefined,
    };
  },

  toJSON(message: ClustersConfigDump_StaticCluster): unknown {
    const obj: any = {};
    if (message.cluster !== undefined) {
      obj.cluster = Any.toJSON(message.cluster);
    }
    if (message.last_updated !== undefined) {
      obj.last_updated = message.last_updated.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClustersConfigDump_StaticCluster>, I>>(
    base?: I,
  ): ClustersConfigDump_StaticCluster {
    return ClustersConfigDump_StaticCluster.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClustersConfigDump_StaticCluster>, I>>(
    object: I,
  ): ClustersConfigDump_StaticCluster {
    const message = createBaseClustersConfigDump_StaticCluster();
    message.cluster = (object.cluster !== undefined && object.cluster !== null)
      ? Any.fromPartial(object.cluster)
      : undefined;
    message.last_updated = object.last_updated ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ClustersConfigDump_StaticCluster.$type, ClustersConfigDump_StaticCluster);

function createBaseClustersConfigDump_DynamicCluster(): ClustersConfigDump_DynamicCluster {
  return { $type: "envoy.admin.v3.ClustersConfigDump.DynamicCluster" };
}

export const ClustersConfigDump_DynamicCluster: MessageFns<
  ClustersConfigDump_DynamicCluster,
  "envoy.admin.v3.ClustersConfigDump.DynamicCluster"
> = {
  $type: "envoy.admin.v3.ClustersConfigDump.DynamicCluster" as const,

  encode(message: ClustersConfigDump_DynamicCluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version_info !== undefined && message.version_info !== "") {
      writer.uint32(10).string(message.version_info);
    }
    if (message.cluster !== undefined) {
      Any.encode(message.cluster, writer.uint32(18).fork()).join();
    }
    if (message.last_updated !== undefined) {
      Timestamp.encode(toTimestamp(message.last_updated), writer.uint32(26).fork()).join();
    }
    if (message.error_state !== undefined) {
      UpdateFailureState.encode(message.error_state, writer.uint32(34).fork()).join();
    }
    if (message.client_status !== undefined && message.client_status !== ClientResourceStatus.UNKNOWN) {
      writer.uint32(40).int32(clientResourceStatusToNumber(message.client_status));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClustersConfigDump_DynamicCluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClustersConfigDump_DynamicCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version_info = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cluster = Any.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.last_updated = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error_state = UpdateFailureState.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.client_status = clientResourceStatusFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClustersConfigDump_DynamicCluster {
    return {
      $type: ClustersConfigDump_DynamicCluster.$type,
      version_info: isSet(object.version_info) ? globalThis.String(object.version_info) : undefined,
      cluster: isSet(object.cluster) ? Any.fromJSON(object.cluster) : undefined,
      last_updated: isSet(object.last_updated) ? fromJsonTimestamp(object.last_updated) : undefined,
      error_state: isSet(object.error_state) ? UpdateFailureState.fromJSON(object.error_state) : undefined,
      client_status: isSet(object.client_status) ? clientResourceStatusFromJSON(object.client_status) : undefined,
    };
  },

  toJSON(message: ClustersConfigDump_DynamicCluster): unknown {
    const obj: any = {};
    if (message.version_info !== undefined) {
      obj.version_info = message.version_info;
    }
    if (message.cluster !== undefined) {
      obj.cluster = Any.toJSON(message.cluster);
    }
    if (message.last_updated !== undefined) {
      obj.last_updated = message.last_updated.toISOString();
    }
    if (message.error_state !== undefined) {
      obj.error_state = UpdateFailureState.toJSON(message.error_state);
    }
    if (message.client_status !== undefined) {
      obj.client_status = clientResourceStatusToJSON(message.client_status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClustersConfigDump_DynamicCluster>, I>>(
    base?: I,
  ): ClustersConfigDump_DynamicCluster {
    return ClustersConfigDump_DynamicCluster.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClustersConfigDump_DynamicCluster>, I>>(
    object: I,
  ): ClustersConfigDump_DynamicCluster {
    const message = createBaseClustersConfigDump_DynamicCluster();
    message.version_info = object.version_info ?? undefined;
    message.cluster = (object.cluster !== undefined && object.cluster !== null)
      ? Any.fromPartial(object.cluster)
      : undefined;
    message.last_updated = object.last_updated ?? undefined;
    message.error_state = (object.error_state !== undefined && object.error_state !== null)
      ? UpdateFailureState.fromPartial(object.error_state)
      : undefined;
    message.client_status = object.client_status ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ClustersConfigDump_DynamicCluster.$type, ClustersConfigDump_DynamicCluster);

function createBaseRoutesConfigDump(): RoutesConfigDump {
  return { $type: "envoy.admin.v3.RoutesConfigDump" };
}

export const RoutesConfigDump: MessageFns<RoutesConfigDump, "envoy.admin.v3.RoutesConfigDump"> = {
  $type: "envoy.admin.v3.RoutesConfigDump" as const,

  encode(message: RoutesConfigDump, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.static_route_configs !== undefined && message.static_route_configs.length !== 0) {
      for (const v of message.static_route_configs) {
        RoutesConfigDump_StaticRouteConfig.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.dynamic_route_configs !== undefined && message.dynamic_route_configs.length !== 0) {
      for (const v of message.dynamic_route_configs) {
        RoutesConfigDump_DynamicRouteConfig.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoutesConfigDump {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoutesConfigDump();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.static_route_configs === undefined) {
            message.static_route_configs = [];
          }
          const el = RoutesConfigDump_StaticRouteConfig.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.static_route_configs!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.dynamic_route_configs === undefined) {
            message.dynamic_route_configs = [];
          }
          const el = RoutesConfigDump_DynamicRouteConfig.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.dynamic_route_configs!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoutesConfigDump {
    return {
      $type: RoutesConfigDump.$type,
      static_route_configs: globalThis.Array.isArray(object?.static_route_configs)
        ? object.static_route_configs.map((e: any) => RoutesConfigDump_StaticRouteConfig.fromJSON(e))
        : undefined,
      dynamic_route_configs: globalThis.Array.isArray(object?.dynamic_route_configs)
        ? object.dynamic_route_configs.map((e: any) => RoutesConfigDump_DynamicRouteConfig.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: RoutesConfigDump): unknown {
    const obj: any = {};
    if (message.static_route_configs?.length) {
      obj.static_route_configs = message.static_route_configs.map((e) => RoutesConfigDump_StaticRouteConfig.toJSON(e));
    }
    if (message.dynamic_route_configs?.length) {
      obj.dynamic_route_configs = message.dynamic_route_configs.map((e) =>
        RoutesConfigDump_DynamicRouteConfig.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RoutesConfigDump>, I>>(base?: I): RoutesConfigDump {
    return RoutesConfigDump.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RoutesConfigDump>, I>>(object: I): RoutesConfigDump {
    const message = createBaseRoutesConfigDump();
    message.static_route_configs =
      object.static_route_configs?.map((e) => RoutesConfigDump_StaticRouteConfig.fromPartial(e)) || undefined;
    message.dynamic_route_configs =
      object.dynamic_route_configs?.map((e) => RoutesConfigDump_DynamicRouteConfig.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(RoutesConfigDump.$type, RoutesConfigDump);

function createBaseRoutesConfigDump_StaticRouteConfig(): RoutesConfigDump_StaticRouteConfig {
  return { $type: "envoy.admin.v3.RoutesConfigDump.StaticRouteConfig" };
}

export const RoutesConfigDump_StaticRouteConfig: MessageFns<
  RoutesConfigDump_StaticRouteConfig,
  "envoy.admin.v3.RoutesConfigDump.StaticRouteConfig"
> = {
  $type: "envoy.admin.v3.RoutesConfigDump.StaticRouteConfig" as const,

  encode(message: RoutesConfigDump_StaticRouteConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.route_config !== undefined) {
      Any.encode(message.route_config, writer.uint32(10).fork()).join();
    }
    if (message.last_updated !== undefined) {
      Timestamp.encode(toTimestamp(message.last_updated), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoutesConfigDump_StaticRouteConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoutesConfigDump_StaticRouteConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.route_config = Any.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.last_updated = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoutesConfigDump_StaticRouteConfig {
    return {
      $type: RoutesConfigDump_StaticRouteConfig.$type,
      route_config: isSet(object.route_config) ? Any.fromJSON(object.route_config) : undefined,
      last_updated: isSet(object.last_updated) ? fromJsonTimestamp(object.last_updated) : undefined,
    };
  },

  toJSON(message: RoutesConfigDump_StaticRouteConfig): unknown {
    const obj: any = {};
    if (message.route_config !== undefined) {
      obj.route_config = Any.toJSON(message.route_config);
    }
    if (message.last_updated !== undefined) {
      obj.last_updated = message.last_updated.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RoutesConfigDump_StaticRouteConfig>, I>>(
    base?: I,
  ): RoutesConfigDump_StaticRouteConfig {
    return RoutesConfigDump_StaticRouteConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RoutesConfigDump_StaticRouteConfig>, I>>(
    object: I,
  ): RoutesConfigDump_StaticRouteConfig {
    const message = createBaseRoutesConfigDump_StaticRouteConfig();
    message.route_config = (object.route_config !== undefined && object.route_config !== null)
      ? Any.fromPartial(object.route_config)
      : undefined;
    message.last_updated = object.last_updated ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RoutesConfigDump_StaticRouteConfig.$type, RoutesConfigDump_StaticRouteConfig);

function createBaseRoutesConfigDump_DynamicRouteConfig(): RoutesConfigDump_DynamicRouteConfig {
  return { $type: "envoy.admin.v3.RoutesConfigDump.DynamicRouteConfig" };
}

export const RoutesConfigDump_DynamicRouteConfig: MessageFns<
  RoutesConfigDump_DynamicRouteConfig,
  "envoy.admin.v3.RoutesConfigDump.DynamicRouteConfig"
> = {
  $type: "envoy.admin.v3.RoutesConfigDump.DynamicRouteConfig" as const,

  encode(message: RoutesConfigDump_DynamicRouteConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version_info !== undefined && message.version_info !== "") {
      writer.uint32(10).string(message.version_info);
    }
    if (message.route_config !== undefined) {
      Any.encode(message.route_config, writer.uint32(18).fork()).join();
    }
    if (message.last_updated !== undefined) {
      Timestamp.encode(toTimestamp(message.last_updated), writer.uint32(26).fork()).join();
    }
    if (message.error_state !== undefined) {
      UpdateFailureState.encode(message.error_state, writer.uint32(34).fork()).join();
    }
    if (message.client_status !== undefined && message.client_status !== ClientResourceStatus.UNKNOWN) {
      writer.uint32(40).int32(clientResourceStatusToNumber(message.client_status));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoutesConfigDump_DynamicRouteConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoutesConfigDump_DynamicRouteConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version_info = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.route_config = Any.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.last_updated = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error_state = UpdateFailureState.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.client_status = clientResourceStatusFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoutesConfigDump_DynamicRouteConfig {
    return {
      $type: RoutesConfigDump_DynamicRouteConfig.$type,
      version_info: isSet(object.version_info) ? globalThis.String(object.version_info) : undefined,
      route_config: isSet(object.route_config) ? Any.fromJSON(object.route_config) : undefined,
      last_updated: isSet(object.last_updated) ? fromJsonTimestamp(object.last_updated) : undefined,
      error_state: isSet(object.error_state) ? UpdateFailureState.fromJSON(object.error_state) : undefined,
      client_status: isSet(object.client_status) ? clientResourceStatusFromJSON(object.client_status) : undefined,
    };
  },

  toJSON(message: RoutesConfigDump_DynamicRouteConfig): unknown {
    const obj: any = {};
    if (message.version_info !== undefined) {
      obj.version_info = message.version_info;
    }
    if (message.route_config !== undefined) {
      obj.route_config = Any.toJSON(message.route_config);
    }
    if (message.last_updated !== undefined) {
      obj.last_updated = message.last_updated.toISOString();
    }
    if (message.error_state !== undefined) {
      obj.error_state = UpdateFailureState.toJSON(message.error_state);
    }
    if (message.client_status !== undefined) {
      obj.client_status = clientResourceStatusToJSON(message.client_status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RoutesConfigDump_DynamicRouteConfig>, I>>(
    base?: I,
  ): RoutesConfigDump_DynamicRouteConfig {
    return RoutesConfigDump_DynamicRouteConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RoutesConfigDump_DynamicRouteConfig>, I>>(
    object: I,
  ): RoutesConfigDump_DynamicRouteConfig {
    const message = createBaseRoutesConfigDump_DynamicRouteConfig();
    message.version_info = object.version_info ?? undefined;
    message.route_config = (object.route_config !== undefined && object.route_config !== null)
      ? Any.fromPartial(object.route_config)
      : undefined;
    message.last_updated = object.last_updated ?? undefined;
    message.error_state = (object.error_state !== undefined && object.error_state !== null)
      ? UpdateFailureState.fromPartial(object.error_state)
      : undefined;
    message.client_status = object.client_status ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RoutesConfigDump_DynamicRouteConfig.$type, RoutesConfigDump_DynamicRouteConfig);

function createBaseScopedRoutesConfigDump(): ScopedRoutesConfigDump {
  return { $type: "envoy.admin.v3.ScopedRoutesConfigDump" };
}

export const ScopedRoutesConfigDump: MessageFns<ScopedRoutesConfigDump, "envoy.admin.v3.ScopedRoutesConfigDump"> = {
  $type: "envoy.admin.v3.ScopedRoutesConfigDump" as const,

  encode(message: ScopedRoutesConfigDump, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inline_scoped_route_configs !== undefined && message.inline_scoped_route_configs.length !== 0) {
      for (const v of message.inline_scoped_route_configs) {
        ScopedRoutesConfigDump_InlineScopedRouteConfigs.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    if (message.dynamic_scoped_route_configs !== undefined && message.dynamic_scoped_route_configs.length !== 0) {
      for (const v of message.dynamic_scoped_route_configs) {
        ScopedRoutesConfigDump_DynamicScopedRouteConfigs.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScopedRoutesConfigDump {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScopedRoutesConfigDump();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.inline_scoped_route_configs === undefined) {
            message.inline_scoped_route_configs = [];
          }
          const el = ScopedRoutesConfigDump_InlineScopedRouteConfigs.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.inline_scoped_route_configs!.push(el);
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.dynamic_scoped_route_configs === undefined) {
            message.dynamic_scoped_route_configs = [];
          }
          const el = ScopedRoutesConfigDump_DynamicScopedRouteConfigs.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.dynamic_scoped_route_configs!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScopedRoutesConfigDump {
    return {
      $type: ScopedRoutesConfigDump.$type,
      inline_scoped_route_configs: globalThis.Array.isArray(object?.inline_scoped_route_configs)
        ? object.inline_scoped_route_configs.map((e: any) =>
          ScopedRoutesConfigDump_InlineScopedRouteConfigs.fromJSON(e)
        )
        : undefined,
      dynamic_scoped_route_configs: globalThis.Array.isArray(object?.dynamic_scoped_route_configs)
        ? object.dynamic_scoped_route_configs.map((e: any) =>
          ScopedRoutesConfigDump_DynamicScopedRouteConfigs.fromJSON(e)
        )
        : undefined,
    };
  },

  toJSON(message: ScopedRoutesConfigDump): unknown {
    const obj: any = {};
    if (message.inline_scoped_route_configs?.length) {
      obj.inline_scoped_route_configs = message.inline_scoped_route_configs.map((e) =>
        ScopedRoutesConfigDump_InlineScopedRouteConfigs.toJSON(e)
      );
    }
    if (message.dynamic_scoped_route_configs?.length) {
      obj.dynamic_scoped_route_configs = message.dynamic_scoped_route_configs.map((e) =>
        ScopedRoutesConfigDump_DynamicScopedRouteConfigs.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScopedRoutesConfigDump>, I>>(base?: I): ScopedRoutesConfigDump {
    return ScopedRoutesConfigDump.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScopedRoutesConfigDump>, I>>(object: I): ScopedRoutesConfigDump {
    const message = createBaseScopedRoutesConfigDump();
    message.inline_scoped_route_configs =
      object.inline_scoped_route_configs?.map((e) => ScopedRoutesConfigDump_InlineScopedRouteConfigs.fromPartial(e)) ||
      undefined;
    message.dynamic_scoped_route_configs =
      object.dynamic_scoped_route_configs?.map((e) =>
        ScopedRoutesConfigDump_DynamicScopedRouteConfigs.fromPartial(e)
      ) || undefined;
    return message;
  },
};

messageTypeRegistry.set(ScopedRoutesConfigDump.$type, ScopedRoutesConfigDump);

function createBaseScopedRoutesConfigDump_InlineScopedRouteConfigs(): ScopedRoutesConfigDump_InlineScopedRouteConfigs {
  return { $type: "envoy.admin.v3.ScopedRoutesConfigDump.InlineScopedRouteConfigs" };
}

export const ScopedRoutesConfigDump_InlineScopedRouteConfigs: MessageFns<
  ScopedRoutesConfigDump_InlineScopedRouteConfigs,
  "envoy.admin.v3.ScopedRoutesConfigDump.InlineScopedRouteConfigs"
> = {
  $type: "envoy.admin.v3.ScopedRoutesConfigDump.InlineScopedRouteConfigs" as const,

  encode(
    message: ScopedRoutesConfigDump_InlineScopedRouteConfigs,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.scoped_route_configs !== undefined && message.scoped_route_configs.length !== 0) {
      for (const v of message.scoped_route_configs) {
        Any.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.last_updated !== undefined) {
      Timestamp.encode(toTimestamp(message.last_updated), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScopedRoutesConfigDump_InlineScopedRouteConfigs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScopedRoutesConfigDump_InlineScopedRouteConfigs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.scoped_route_configs === undefined) {
            message.scoped_route_configs = [];
          }
          const el = Any.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.scoped_route_configs!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.last_updated = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScopedRoutesConfigDump_InlineScopedRouteConfigs {
    return {
      $type: ScopedRoutesConfigDump_InlineScopedRouteConfigs.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      scoped_route_configs: globalThis.Array.isArray(object?.scoped_route_configs)
        ? object.scoped_route_configs.map((e: any) => Any.fromJSON(e))
        : undefined,
      last_updated: isSet(object.last_updated) ? fromJsonTimestamp(object.last_updated) : undefined,
    };
  },

  toJSON(message: ScopedRoutesConfigDump_InlineScopedRouteConfigs): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.scoped_route_configs?.length) {
      obj.scoped_route_configs = message.scoped_route_configs.map((e) => Any.toJSON(e));
    }
    if (message.last_updated !== undefined) {
      obj.last_updated = message.last_updated.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScopedRoutesConfigDump_InlineScopedRouteConfigs>, I>>(
    base?: I,
  ): ScopedRoutesConfigDump_InlineScopedRouteConfigs {
    return ScopedRoutesConfigDump_InlineScopedRouteConfigs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScopedRoutesConfigDump_InlineScopedRouteConfigs>, I>>(
    object: I,
  ): ScopedRoutesConfigDump_InlineScopedRouteConfigs {
    const message = createBaseScopedRoutesConfigDump_InlineScopedRouteConfigs();
    message.name = object.name ?? undefined;
    message.scoped_route_configs = object.scoped_route_configs?.map((e) => Any.fromPartial(e)) || undefined;
    message.last_updated = object.last_updated ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(
  ScopedRoutesConfigDump_InlineScopedRouteConfigs.$type,
  ScopedRoutesConfigDump_InlineScopedRouteConfigs,
);

function createBaseScopedRoutesConfigDump_DynamicScopedRouteConfigs(): ScopedRoutesConfigDump_DynamicScopedRouteConfigs {
  return { $type: "envoy.admin.v3.ScopedRoutesConfigDump.DynamicScopedRouteConfigs" };
}

export const ScopedRoutesConfigDump_DynamicScopedRouteConfigs: MessageFns<
  ScopedRoutesConfigDump_DynamicScopedRouteConfigs,
  "envoy.admin.v3.ScopedRoutesConfigDump.DynamicScopedRouteConfigs"
> = {
  $type: "envoy.admin.v3.ScopedRoutesConfigDump.DynamicScopedRouteConfigs" as const,

  encode(
    message: ScopedRoutesConfigDump_DynamicScopedRouteConfigs,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version_info !== undefined && message.version_info !== "") {
      writer.uint32(18).string(message.version_info);
    }
    if (message.scoped_route_configs !== undefined && message.scoped_route_configs.length !== 0) {
      for (const v of message.scoped_route_configs) {
        Any.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    if (message.last_updated !== undefined) {
      Timestamp.encode(toTimestamp(message.last_updated), writer.uint32(34).fork()).join();
    }
    if (message.error_state !== undefined) {
      UpdateFailureState.encode(message.error_state, writer.uint32(42).fork()).join();
    }
    if (message.client_status !== undefined && message.client_status !== ClientResourceStatus.UNKNOWN) {
      writer.uint32(48).int32(clientResourceStatusToNumber(message.client_status));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScopedRoutesConfigDump_DynamicScopedRouteConfigs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScopedRoutesConfigDump_DynamicScopedRouteConfigs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.version_info = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.scoped_route_configs === undefined) {
            message.scoped_route_configs = [];
          }
          const el = Any.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.scoped_route_configs!.push(el);
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.last_updated = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.error_state = UpdateFailureState.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.client_status = clientResourceStatusFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScopedRoutesConfigDump_DynamicScopedRouteConfigs {
    return {
      $type: ScopedRoutesConfigDump_DynamicScopedRouteConfigs.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      version_info: isSet(object.version_info) ? globalThis.String(object.version_info) : undefined,
      scoped_route_configs: globalThis.Array.isArray(object?.scoped_route_configs)
        ? object.scoped_route_configs.map((e: any) => Any.fromJSON(e))
        : undefined,
      last_updated: isSet(object.last_updated) ? fromJsonTimestamp(object.last_updated) : undefined,
      error_state: isSet(object.error_state) ? UpdateFailureState.fromJSON(object.error_state) : undefined,
      client_status: isSet(object.client_status) ? clientResourceStatusFromJSON(object.client_status) : undefined,
    };
  },

  toJSON(message: ScopedRoutesConfigDump_DynamicScopedRouteConfigs): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.version_info !== undefined) {
      obj.version_info = message.version_info;
    }
    if (message.scoped_route_configs?.length) {
      obj.scoped_route_configs = message.scoped_route_configs.map((e) => Any.toJSON(e));
    }
    if (message.last_updated !== undefined) {
      obj.last_updated = message.last_updated.toISOString();
    }
    if (message.error_state !== undefined) {
      obj.error_state = UpdateFailureState.toJSON(message.error_state);
    }
    if (message.client_status !== undefined) {
      obj.client_status = clientResourceStatusToJSON(message.client_status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScopedRoutesConfigDump_DynamicScopedRouteConfigs>, I>>(
    base?: I,
  ): ScopedRoutesConfigDump_DynamicScopedRouteConfigs {
    return ScopedRoutesConfigDump_DynamicScopedRouteConfigs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScopedRoutesConfigDump_DynamicScopedRouteConfigs>, I>>(
    object: I,
  ): ScopedRoutesConfigDump_DynamicScopedRouteConfigs {
    const message = createBaseScopedRoutesConfigDump_DynamicScopedRouteConfigs();
    message.name = object.name ?? undefined;
    message.version_info = object.version_info ?? undefined;
    message.scoped_route_configs = object.scoped_route_configs?.map((e) => Any.fromPartial(e)) || undefined;
    message.last_updated = object.last_updated ?? undefined;
    message.error_state = (object.error_state !== undefined && object.error_state !== null)
      ? UpdateFailureState.fromPartial(object.error_state)
      : undefined;
    message.client_status = object.client_status ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(
  ScopedRoutesConfigDump_DynamicScopedRouteConfigs.$type,
  ScopedRoutesConfigDump_DynamicScopedRouteConfigs,
);

function createBaseEndpointsConfigDump(): EndpointsConfigDump {
  return { $type: "envoy.admin.v3.EndpointsConfigDump" };
}

export const EndpointsConfigDump: MessageFns<EndpointsConfigDump, "envoy.admin.v3.EndpointsConfigDump"> = {
  $type: "envoy.admin.v3.EndpointsConfigDump" as const,

  encode(message: EndpointsConfigDump, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.static_endpoint_configs !== undefined && message.static_endpoint_configs.length !== 0) {
      for (const v of message.static_endpoint_configs) {
        EndpointsConfigDump_StaticEndpointConfig.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.dynamic_endpoint_configs !== undefined && message.dynamic_endpoint_configs.length !== 0) {
      for (const v of message.dynamic_endpoint_configs) {
        EndpointsConfigDump_DynamicEndpointConfig.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EndpointsConfigDump {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndpointsConfigDump();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.static_endpoint_configs === undefined) {
            message.static_endpoint_configs = [];
          }
          const el = EndpointsConfigDump_StaticEndpointConfig.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.static_endpoint_configs!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.dynamic_endpoint_configs === undefined) {
            message.dynamic_endpoint_configs = [];
          }
          const el = EndpointsConfigDump_DynamicEndpointConfig.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.dynamic_endpoint_configs!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EndpointsConfigDump {
    return {
      $type: EndpointsConfigDump.$type,
      static_endpoint_configs: globalThis.Array.isArray(object?.static_endpoint_configs)
        ? object.static_endpoint_configs.map((e: any) => EndpointsConfigDump_StaticEndpointConfig.fromJSON(e))
        : undefined,
      dynamic_endpoint_configs: globalThis.Array.isArray(object?.dynamic_endpoint_configs)
        ? object.dynamic_endpoint_configs.map((e: any) => EndpointsConfigDump_DynamicEndpointConfig.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: EndpointsConfigDump): unknown {
    const obj: any = {};
    if (message.static_endpoint_configs?.length) {
      obj.static_endpoint_configs = message.static_endpoint_configs.map((e) =>
        EndpointsConfigDump_StaticEndpointConfig.toJSON(e)
      );
    }
    if (message.dynamic_endpoint_configs?.length) {
      obj.dynamic_endpoint_configs = message.dynamic_endpoint_configs.map((e) =>
        EndpointsConfigDump_DynamicEndpointConfig.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EndpointsConfigDump>, I>>(base?: I): EndpointsConfigDump {
    return EndpointsConfigDump.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EndpointsConfigDump>, I>>(object: I): EndpointsConfigDump {
    const message = createBaseEndpointsConfigDump();
    message.static_endpoint_configs =
      object.static_endpoint_configs?.map((e) => EndpointsConfigDump_StaticEndpointConfig.fromPartial(e)) || undefined;
    message.dynamic_endpoint_configs =
      object.dynamic_endpoint_configs?.map((e) => EndpointsConfigDump_DynamicEndpointConfig.fromPartial(e)) ||
      undefined;
    return message;
  },
};

messageTypeRegistry.set(EndpointsConfigDump.$type, EndpointsConfigDump);

function createBaseEndpointsConfigDump_StaticEndpointConfig(): EndpointsConfigDump_StaticEndpointConfig {
  return { $type: "envoy.admin.v3.EndpointsConfigDump.StaticEndpointConfig" };
}

export const EndpointsConfigDump_StaticEndpointConfig: MessageFns<
  EndpointsConfigDump_StaticEndpointConfig,
  "envoy.admin.v3.EndpointsConfigDump.StaticEndpointConfig"
> = {
  $type: "envoy.admin.v3.EndpointsConfigDump.StaticEndpointConfig" as const,

  encode(message: EndpointsConfigDump_StaticEndpointConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.endpoint_config !== undefined) {
      Any.encode(message.endpoint_config, writer.uint32(10).fork()).join();
    }
    if (message.last_updated !== undefined) {
      Timestamp.encode(toTimestamp(message.last_updated), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EndpointsConfigDump_StaticEndpointConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndpointsConfigDump_StaticEndpointConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.endpoint_config = Any.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.last_updated = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EndpointsConfigDump_StaticEndpointConfig {
    return {
      $type: EndpointsConfigDump_StaticEndpointConfig.$type,
      endpoint_config: isSet(object.endpoint_config) ? Any.fromJSON(object.endpoint_config) : undefined,
      last_updated: isSet(object.last_updated) ? fromJsonTimestamp(object.last_updated) : undefined,
    };
  },

  toJSON(message: EndpointsConfigDump_StaticEndpointConfig): unknown {
    const obj: any = {};
    if (message.endpoint_config !== undefined) {
      obj.endpoint_config = Any.toJSON(message.endpoint_config);
    }
    if (message.last_updated !== undefined) {
      obj.last_updated = message.last_updated.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EndpointsConfigDump_StaticEndpointConfig>, I>>(
    base?: I,
  ): EndpointsConfigDump_StaticEndpointConfig {
    return EndpointsConfigDump_StaticEndpointConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EndpointsConfigDump_StaticEndpointConfig>, I>>(
    object: I,
  ): EndpointsConfigDump_StaticEndpointConfig {
    const message = createBaseEndpointsConfigDump_StaticEndpointConfig();
    message.endpoint_config = (object.endpoint_config !== undefined && object.endpoint_config !== null)
      ? Any.fromPartial(object.endpoint_config)
      : undefined;
    message.last_updated = object.last_updated ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(EndpointsConfigDump_StaticEndpointConfig.$type, EndpointsConfigDump_StaticEndpointConfig);

function createBaseEndpointsConfigDump_DynamicEndpointConfig(): EndpointsConfigDump_DynamicEndpointConfig {
  return { $type: "envoy.admin.v3.EndpointsConfigDump.DynamicEndpointConfig" };
}

export const EndpointsConfigDump_DynamicEndpointConfig: MessageFns<
  EndpointsConfigDump_DynamicEndpointConfig,
  "envoy.admin.v3.EndpointsConfigDump.DynamicEndpointConfig"
> = {
  $type: "envoy.admin.v3.EndpointsConfigDump.DynamicEndpointConfig" as const,

  encode(message: EndpointsConfigDump_DynamicEndpointConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version_info !== undefined && message.version_info !== "") {
      writer.uint32(10).string(message.version_info);
    }
    if (message.endpoint_config !== undefined) {
      Any.encode(message.endpoint_config, writer.uint32(18).fork()).join();
    }
    if (message.last_updated !== undefined) {
      Timestamp.encode(toTimestamp(message.last_updated), writer.uint32(26).fork()).join();
    }
    if (message.error_state !== undefined) {
      UpdateFailureState.encode(message.error_state, writer.uint32(34).fork()).join();
    }
    if (message.client_status !== undefined && message.client_status !== ClientResourceStatus.UNKNOWN) {
      writer.uint32(40).int32(clientResourceStatusToNumber(message.client_status));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EndpointsConfigDump_DynamicEndpointConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndpointsConfigDump_DynamicEndpointConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version_info = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.endpoint_config = Any.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.last_updated = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error_state = UpdateFailureState.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.client_status = clientResourceStatusFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EndpointsConfigDump_DynamicEndpointConfig {
    return {
      $type: EndpointsConfigDump_DynamicEndpointConfig.$type,
      version_info: isSet(object.version_info) ? globalThis.String(object.version_info) : undefined,
      endpoint_config: isSet(object.endpoint_config) ? Any.fromJSON(object.endpoint_config) : undefined,
      last_updated: isSet(object.last_updated) ? fromJsonTimestamp(object.last_updated) : undefined,
      error_state: isSet(object.error_state) ? UpdateFailureState.fromJSON(object.error_state) : undefined,
      client_status: isSet(object.client_status) ? clientResourceStatusFromJSON(object.client_status) : undefined,
    };
  },

  toJSON(message: EndpointsConfigDump_DynamicEndpointConfig): unknown {
    const obj: any = {};
    if (message.version_info !== undefined) {
      obj.version_info = message.version_info;
    }
    if (message.endpoint_config !== undefined) {
      obj.endpoint_config = Any.toJSON(message.endpoint_config);
    }
    if (message.last_updated !== undefined) {
      obj.last_updated = message.last_updated.toISOString();
    }
    if (message.error_state !== undefined) {
      obj.error_state = UpdateFailureState.toJSON(message.error_state);
    }
    if (message.client_status !== undefined) {
      obj.client_status = clientResourceStatusToJSON(message.client_status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EndpointsConfigDump_DynamicEndpointConfig>, I>>(
    base?: I,
  ): EndpointsConfigDump_DynamicEndpointConfig {
    return EndpointsConfigDump_DynamicEndpointConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EndpointsConfigDump_DynamicEndpointConfig>, I>>(
    object: I,
  ): EndpointsConfigDump_DynamicEndpointConfig {
    const message = createBaseEndpointsConfigDump_DynamicEndpointConfig();
    message.version_info = object.version_info ?? undefined;
    message.endpoint_config = (object.endpoint_config !== undefined && object.endpoint_config !== null)
      ? Any.fromPartial(object.endpoint_config)
      : undefined;
    message.last_updated = object.last_updated ?? undefined;
    message.error_state = (object.error_state !== undefined && object.error_state !== null)
      ? UpdateFailureState.fromPartial(object.error_state)
      : undefined;
    message.client_status = object.client_status ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(EndpointsConfigDump_DynamicEndpointConfig.$type, EndpointsConfigDump_DynamicEndpointConfig);

function createBaseEcdsConfigDump(): EcdsConfigDump {
  return { $type: "envoy.admin.v3.EcdsConfigDump" };
}

export const EcdsConfigDump: MessageFns<EcdsConfigDump, "envoy.admin.v3.EcdsConfigDump"> = {
  $type: "envoy.admin.v3.EcdsConfigDump" as const,

  encode(message: EcdsConfigDump, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ecds_filters !== undefined && message.ecds_filters.length !== 0) {
      for (const v of message.ecds_filters) {
        EcdsConfigDump_EcdsFilterConfig.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EcdsConfigDump {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEcdsConfigDump();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.ecds_filters === undefined) {
            message.ecds_filters = [];
          }
          const el = EcdsConfigDump_EcdsFilterConfig.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.ecds_filters!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EcdsConfigDump {
    return {
      $type: EcdsConfigDump.$type,
      ecds_filters: globalThis.Array.isArray(object?.ecds_filters)
        ? object.ecds_filters.map((e: any) => EcdsConfigDump_EcdsFilterConfig.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: EcdsConfigDump): unknown {
    const obj: any = {};
    if (message.ecds_filters?.length) {
      obj.ecds_filters = message.ecds_filters.map((e) => EcdsConfigDump_EcdsFilterConfig.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EcdsConfigDump>, I>>(base?: I): EcdsConfigDump {
    return EcdsConfigDump.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EcdsConfigDump>, I>>(object: I): EcdsConfigDump {
    const message = createBaseEcdsConfigDump();
    message.ecds_filters = object.ecds_filters?.map((e) => EcdsConfigDump_EcdsFilterConfig.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(EcdsConfigDump.$type, EcdsConfigDump);

function createBaseEcdsConfigDump_EcdsFilterConfig(): EcdsConfigDump_EcdsFilterConfig {
  return { $type: "envoy.admin.v3.EcdsConfigDump.EcdsFilterConfig" };
}

export const EcdsConfigDump_EcdsFilterConfig: MessageFns<
  EcdsConfigDump_EcdsFilterConfig,
  "envoy.admin.v3.EcdsConfigDump.EcdsFilterConfig"
> = {
  $type: "envoy.admin.v3.EcdsConfigDump.EcdsFilterConfig" as const,

  encode(message: EcdsConfigDump_EcdsFilterConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version_info !== undefined && message.version_info !== "") {
      writer.uint32(10).string(message.version_info);
    }
    if (message.ecds_filter !== undefined) {
      Any.encode(message.ecds_filter, writer.uint32(18).fork()).join();
    }
    if (message.last_updated !== undefined) {
      Timestamp.encode(toTimestamp(message.last_updated), writer.uint32(26).fork()).join();
    }
    if (message.error_state !== undefined) {
      UpdateFailureState.encode(message.error_state, writer.uint32(34).fork()).join();
    }
    if (message.client_status !== undefined && message.client_status !== ClientResourceStatus.UNKNOWN) {
      writer.uint32(40).int32(clientResourceStatusToNumber(message.client_status));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EcdsConfigDump_EcdsFilterConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEcdsConfigDump_EcdsFilterConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version_info = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ecds_filter = Any.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.last_updated = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error_state = UpdateFailureState.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.client_status = clientResourceStatusFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EcdsConfigDump_EcdsFilterConfig {
    return {
      $type: EcdsConfigDump_EcdsFilterConfig.$type,
      version_info: isSet(object.version_info) ? globalThis.String(object.version_info) : undefined,
      ecds_filter: isSet(object.ecds_filter) ? Any.fromJSON(object.ecds_filter) : undefined,
      last_updated: isSet(object.last_updated) ? fromJsonTimestamp(object.last_updated) : undefined,
      error_state: isSet(object.error_state) ? UpdateFailureState.fromJSON(object.error_state) : undefined,
      client_status: isSet(object.client_status) ? clientResourceStatusFromJSON(object.client_status) : undefined,
    };
  },

  toJSON(message: EcdsConfigDump_EcdsFilterConfig): unknown {
    const obj: any = {};
    if (message.version_info !== undefined) {
      obj.version_info = message.version_info;
    }
    if (message.ecds_filter !== undefined) {
      obj.ecds_filter = Any.toJSON(message.ecds_filter);
    }
    if (message.last_updated !== undefined) {
      obj.last_updated = message.last_updated.toISOString();
    }
    if (message.error_state !== undefined) {
      obj.error_state = UpdateFailureState.toJSON(message.error_state);
    }
    if (message.client_status !== undefined) {
      obj.client_status = clientResourceStatusToJSON(message.client_status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EcdsConfigDump_EcdsFilterConfig>, I>>(base?: I): EcdsConfigDump_EcdsFilterConfig {
    return EcdsConfigDump_EcdsFilterConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EcdsConfigDump_EcdsFilterConfig>, I>>(
    object: I,
  ): EcdsConfigDump_EcdsFilterConfig {
    const message = createBaseEcdsConfigDump_EcdsFilterConfig();
    message.version_info = object.version_info ?? undefined;
    message.ecds_filter = (object.ecds_filter !== undefined && object.ecds_filter !== null)
      ? Any.fromPartial(object.ecds_filter)
      : undefined;
    message.last_updated = object.last_updated ?? undefined;
    message.error_state = (object.error_state !== undefined && object.error_state !== null)
      ? UpdateFailureState.fromPartial(object.error_state)
      : undefined;
    message.client_status = object.client_status ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(EcdsConfigDump_EcdsFilterConfig.$type, EcdsConfigDump_EcdsFilterConfig);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { $type: "google.protobuf.Timestamp", seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
