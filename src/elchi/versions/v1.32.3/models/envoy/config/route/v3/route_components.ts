// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/config/route/v3/route_components.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Any } from "../../../../google/protobuf/any";
import { Duration } from "../../../../google/protobuf/duration";
import { BoolValue, UInt32Value } from "../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../typeRegistry";
import { Matcher } from "../../../../xds/type/matcher/v3/matcher";
import { MetadataMatcher } from "../../../type/matcher/v3/metadata";
import { RegexMatchAndSubstitute, RegexMatcher } from "../../../type/matcher/v3/regex";
import { StringMatcher } from "../../../type/matcher/v3/string";
import { MetadataKey } from "../../../type/metadata/v3/metadata";
import { CustomTag } from "../../../type/tracing/v3/custom_tag";
import { FractionalPercent } from "../../../type/v3/percent";
import { Int64Range } from "../../../type/v3/range";
import {
  DataSource,
  HeaderValueOption,
  Metadata,
  RoutingPriority,
  routingPriorityFromJSON,
  routingPriorityToJSON,
  routingPriorityToNumber,
  RuntimeFractionalPercent,
} from "../../core/v3/base";
import { TypedExtensionConfig } from "../../core/v3/extension";
import { ProxyProtocolConfig } from "../../core/v3/proxy_protocol";

export const protobufPackage = "envoy.config.route.v3";

/**
 * The top level element in the routing configuration is a virtual host. Each virtual host has
 * a logical name as well as a set of domains that get routed to it based on the incoming request's
 * host header. This allows a single listener to service multiple top level domain path trees. Once
 * a virtual host is selected based on the domain, the routes are processed in order to see which
 * upstream cluster to route to or whether to perform a redirect.
 * [#next-free-field: 25]
 */
export interface VirtualHost {
  $type: "envoy.config.route.v3.VirtualHost";
  /**
   * The logical name of the virtual host. This is used when emitting certain
   * statistics but is not relevant for routing.
   */
  name?:
    | string
    | undefined;
  /**
   * A list of domains (host/authority header) that will be matched to this
   * virtual host. Wildcard hosts are supported in the suffix or prefix form.
   *
   * Domain search order:
   *  1. Exact domain names: ``www.foo.com``.
   *  2. Suffix domain wildcards: ``*.foo.com`` or ``*-bar.foo.com``.
   *  3. Prefix domain wildcards: ``foo.*`` or ``foo-*``.
   *  4. Special wildcard ``*`` matching any domain.
   *
   * .. note::
   *
   *   The wildcard will not match the empty string.
   *   e.g. ``*-bar.foo.com`` will match ``baz-bar.foo.com`` but not ``-bar.foo.com``.
   *   The longest wildcards match first.
   *   Only a single virtual host in the entire route configuration can match on ``*``. A domain
   *   must be unique across all virtual hosts or the config will fail to load.
   *
   * Domains cannot contain control characters. This is validated by the well_known_regex HTTP_HEADER_VALUE.
   */
  domains?:
    | string[]
    | undefined;
  /**
   * The list of routes that will be matched, in order, for incoming requests.
   * The first route that matches will be used.
   * Only one of this and ``matcher`` can be specified.
   */
  routes?:
    | Route[]
    | undefined;
  /**
   * [#next-major-version: This should be included in a oneof with routes wrapped in a message.]
   * The match tree to use when resolving route actions for incoming requests. Only one of this and ``routes``
   * can be specified.
   */
  matcher?:
    | Matcher
    | undefined;
  /**
   * Specifies the type of TLS enforcement the virtual host expects. If this option is not
   * specified, there is no TLS requirement for the virtual host.
   */
  require_tls?:
    | VirtualHost_TlsRequirementType
    | undefined;
  /**
   * A list of virtual clusters defined for this virtual host. Virtual clusters
   * are used for additional statistics gathering.
   */
  virtual_clusters?:
    | VirtualCluster[]
    | undefined;
  /**
   * Specifies a set of rate limit configurations that will be applied to the
   * virtual host.
   */
  rate_limits?:
    | RateLimit[]
    | undefined;
  /**
   * Specifies a list of HTTP headers that should be added to each request
   * handled by this virtual host. Headers specified at this level are applied
   * after headers from enclosed :ref:`envoy_v3_api_msg_config.route.v3.Route` and before headers from the
   * enclosing :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration`. For more information, including
   * details on header value syntax, see the documentation on :ref:`custom request headers
   * <config_http_conn_man_headers_custom_request_headers>`.
   */
  request_headers_to_add?:
    | HeaderValueOption[]
    | undefined;
  /**
   * Specifies a list of HTTP headers that should be removed from each request
   * handled by this virtual host.
   */
  request_headers_to_remove?:
    | string[]
    | undefined;
  /**
   * Specifies a list of HTTP headers that should be added to each response
   * handled by this virtual host. Headers specified at this level are applied
   * after headers from enclosed :ref:`envoy_v3_api_msg_config.route.v3.Route` and before headers from the
   * enclosing :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration`. For more information, including
   * details on header value syntax, see the documentation on :ref:`custom request headers
   * <config_http_conn_man_headers_custom_request_headers>`.
   */
  response_headers_to_add?:
    | HeaderValueOption[]
    | undefined;
  /**
   * Specifies a list of HTTP headers that should be removed from each response
   * handled by this virtual host.
   */
  response_headers_to_remove?:
    | string[]
    | undefined;
  /**
   * Indicates that the virtual host has a CORS policy. This field is ignored if related cors policy is
   * found in the
   * :ref:`VirtualHost.typed_per_filter_config<envoy_v3_api_field_config.route.v3.VirtualHost.typed_per_filter_config>`.
   *
   * .. attention::
   *
   *   This option has been deprecated. Please use
   *   :ref:`VirtualHost.typed_per_filter_config<envoy_v3_api_field_config.route.v3.VirtualHost.typed_per_filter_config>`
   *   to configure the CORS HTTP filter.
   *
   * @deprecated
   */
  cors?:
    | CorsPolicy
    | undefined;
  /**
   * This field can be used to provide virtual host level per filter config. The key should match the
   * :ref:`filter config name
   * <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpFilter.name>`.
   * See :ref:`Http filter route specific config <arch_overview_http_filters_per_filter_config>`
   * for details.
   * [#comment: An entry's value may be wrapped in a
   * :ref:`FilterConfig<envoy_v3_api_msg_config.route.v3.FilterConfig>`
   * message to specify additional options.]
   */
  typed_per_filter_config?:
    | Map<string, Any>
    | undefined;
  /**
   * Decides whether the :ref:`x-envoy-attempt-count
   * <config_http_filters_router_x-envoy-attempt-count>` header should be included
   * in the upstream request. Setting this option will cause it to override any existing header
   * value, so in the case of two Envoys on the request path with this option enabled, the upstream
   * will see the attempt count as perceived by the second Envoy. Defaults to false.
   * This header is unaffected by the
   * :ref:`suppress_envoy_headers
   * <envoy_v3_api_field_extensions.filters.http.router.v3.Router.suppress_envoy_headers>` flag.
   *
   * [#next-major-version: rename to include_attempt_count_in_request.]
   */
  include_request_attempt_count?:
    | boolean
    | undefined;
  /**
   * Decides whether the :ref:`x-envoy-attempt-count
   * <config_http_filters_router_x-envoy-attempt-count>` header should be included
   * in the downstream response. Setting this option will cause the router to override any existing header
   * value, so in the case of two Envoys on the request path with this option enabled, the downstream
   * will see the attempt count as perceived by the Envoy closest upstream from itself. Defaults to false.
   * This header is unaffected by the
   * :ref:`suppress_envoy_headers
   * <envoy_v3_api_field_extensions.filters.http.router.v3.Router.suppress_envoy_headers>` flag.
   */
  include_attempt_count_in_response?:
    | boolean
    | undefined;
  /**
   * Indicates the retry policy for all routes in this virtual host. Note that setting a
   * route level entry will take precedence over this config and it'll be treated
   * independently (e.g.: values are not inherited).
   */
  retry_policy?:
    | RetryPolicy
    | undefined;
  /**
   * [#not-implemented-hide:]
   * Specifies the configuration for retry policy extension. Note that setting a route level entry
   * will take precedence over this config and it'll be treated independently (e.g.: values are not
   * inherited). :ref:`Retry policy <envoy_v3_api_field_config.route.v3.VirtualHost.retry_policy>` should not be
   * set if this field is used.
   */
  retry_policy_typed_config?:
    | Any
    | undefined;
  /**
   * Indicates the hedge policy for all routes in this virtual host. Note that setting a
   * route level entry will take precedence over this config and it'll be treated
   * independently (e.g.: values are not inherited).
   */
  hedge_policy?:
    | HedgePolicy
    | undefined;
  /**
   * Decides whether to include the :ref:`x-envoy-is-timeout-retry <config_http_filters_router_x-envoy-is-timeout-retry>`
   * request header in retries initiated by per try timeouts.
   */
  include_is_timeout_retry_header?:
    | boolean
    | undefined;
  /**
   * The maximum bytes which will be buffered for retries and shadowing.
   * If set and a route-specific limit is not set, the bytes actually buffered will be the minimum
   * value of this and the listener per_connection_buffer_limit_bytes.
   */
  per_request_buffer_limit_bytes?:
    | number
    | undefined;
  /**
   * Specify a set of default request mirroring policies for every route under this virtual host.
   * It takes precedence over the route config mirror policy entirely.
   * That is, policies are not merged, the most specific non-empty one becomes the mirror policies.
   */
  request_mirror_policies?:
    | RouteAction_RequestMirrorPolicy[]
    | undefined;
  /**
   * The metadata field can be used to provide additional information
   * about the virtual host. It can be used for configuration, stats, and logging.
   * The metadata should go under the filter namespace that will need it.
   * For instance, if the metadata is intended for the Router filter,
   * the filter name should be specified as ``envoy.filters.http.router``.
   */
  metadata?: Metadata | undefined;
}

export enum VirtualHost_TlsRequirementType {
  /** NONE - No TLS requirement for the virtual host. */
  NONE = "NONE",
  /**
   * EXTERNAL_ONLY - External requests must use TLS. If a request is external and it is not
   * using TLS, a 301 redirect will be sent telling the client to use HTTPS.
   */
  EXTERNAL_ONLY = "EXTERNAL_ONLY",
  /**
   * ALL - All requests must use TLS. If a request is not using TLS, a 301 redirect
   * will be sent telling the client to use HTTPS.
   */
  ALL = "ALL",
}

export function virtualHost_TlsRequirementTypeFromJSON(object: any): VirtualHost_TlsRequirementType {
  switch (object) {
    case 0:
    case "NONE":
      return VirtualHost_TlsRequirementType.NONE;
    case 1:
    case "EXTERNAL_ONLY":
      return VirtualHost_TlsRequirementType.EXTERNAL_ONLY;
    case 2:
    case "ALL":
      return VirtualHost_TlsRequirementType.ALL;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum VirtualHost_TlsRequirementType");
  }
}

export function virtualHost_TlsRequirementTypeToJSON(object: VirtualHost_TlsRequirementType): string {
  switch (object) {
    case VirtualHost_TlsRequirementType.NONE:
      return "NONE";
    case VirtualHost_TlsRequirementType.EXTERNAL_ONLY:
      return "EXTERNAL_ONLY";
    case VirtualHost_TlsRequirementType.ALL:
      return "ALL";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum VirtualHost_TlsRequirementType");
  }
}

export function virtualHost_TlsRequirementTypeToNumber(object: VirtualHost_TlsRequirementType): number {
  switch (object) {
    case VirtualHost_TlsRequirementType.NONE:
      return 0;
    case VirtualHost_TlsRequirementType.EXTERNAL_ONLY:
      return 1;
    case VirtualHost_TlsRequirementType.ALL:
      return 2;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum VirtualHost_TlsRequirementType");
  }
}

export interface VirtualHost_TypedPerFilterConfigEntry {
  $type: "envoy.config.route.v3.VirtualHost.TypedPerFilterConfigEntry";
  key: string;
  value?: Any | undefined;
}

/** A filter-defined action type. */
export interface FilterAction {
  $type: "envoy.config.route.v3.FilterAction";
  action?: Any | undefined;
}

/**
 * This can be used in route matcher :ref:`VirtualHost.matcher <envoy_v3_api_field_config.route.v3.VirtualHost.matcher>`.
 * When the matcher matches, routes will be matched and run.
 */
export interface RouteList {
  $type: "envoy.config.route.v3.RouteList";
  /** The list of routes that will be matched and run, in order. The first route that matches will be used. */
  routes?: Route[] | undefined;
}

/**
 * A route is both a specification of how to match a request as well as an indication of what to do
 * next (e.g., redirect, forward, rewrite, etc.).
 *
 * .. attention::
 *
 *   Envoy supports routing on HTTP method via :ref:`header matching
 *   <envoy_v3_api_msg_config.route.v3.HeaderMatcher>`.
 * [#next-free-field: 20]
 */
export interface Route {
  $type: "envoy.config.route.v3.Route";
  /** Name for the route. */
  name?:
    | string
    | undefined;
  /** Route matching parameters. */
  match?: RouteMatch | undefined;
  action?:
    | //
    /** Route request to some upstream cluster. */
    { $case: "route"; route: RouteAction }
    | //
    /** Return a redirect. */
    { $case: "redirect"; redirect: RedirectAction }
    | //
    /** Return an arbitrary HTTP response directly, without proxying. */
    { $case: "direct_response"; direct_response: DirectResponseAction }
    | //
    /**
     * [#not-implemented-hide:]
     * A filter-defined action (e.g., it could dynamically generate the RouteAction).
     * [#comment: TODO(samflattery): Remove cleanup in route_fuzz_test.cc when
     * implemented]
     */
    { $case: "filter_action"; filter_action: FilterAction }
    | //
    /**
     * [#not-implemented-hide:]
     * An action used when the route will generate a response directly,
     * without forwarding to an upstream host. This will be used in non-proxy
     * xDS clients like the gRPC server. It could also be used in the future
     * in Envoy for a filter that directly generates responses for requests.
     */
    { $case: "non_forwarding_action"; non_forwarding_action: NonForwardingAction }
    | undefined;
  /**
   * The Metadata field can be used to provide additional information
   * about the route. It can be used for configuration, stats, and logging.
   * The metadata should go under the filter namespace that will need it.
   * For instance, if the metadata is intended for the Router filter,
   * the filter name should be specified as ``envoy.filters.http.router``.
   */
  metadata?:
    | Metadata
    | undefined;
  /** Decorator for the matched route. */
  decorator?:
    | Decorator
    | undefined;
  /**
   * This field can be used to provide route specific per filter config. The key should match the
   * :ref:`filter config name
   * <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpFilter.name>`.
   * See :ref:`Http filter route specific config <arch_overview_http_filters_per_filter_config>`
   * for details.
   * [#comment: An entry's value may be wrapped in a
   * :ref:`FilterConfig<envoy_v3_api_msg_config.route.v3.FilterConfig>`
   * message to specify additional options.]
   */
  typed_per_filter_config?:
    | Map<string, Any>
    | undefined;
  /**
   * Specifies a set of headers that will be added to requests matching this
   * route. Headers specified at this level are applied before headers from the
   * enclosing :ref:`envoy_v3_api_msg_config.route.v3.VirtualHost` and
   * :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration`. For more information, including details on
   * header value syntax, see the documentation on :ref:`custom request headers
   * <config_http_conn_man_headers_custom_request_headers>`.
   */
  request_headers_to_add?:
    | HeaderValueOption[]
    | undefined;
  /**
   * Specifies a list of HTTP headers that should be removed from each request
   * matching this route.
   */
  request_headers_to_remove?:
    | string[]
    | undefined;
  /**
   * Specifies a set of headers that will be added to responses to requests
   * matching this route. Headers specified at this level are applied before
   * headers from the enclosing :ref:`envoy_v3_api_msg_config.route.v3.VirtualHost` and
   * :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration`. For more information, including
   * details on header value syntax, see the documentation on
   * :ref:`custom request headers <config_http_conn_man_headers_custom_request_headers>`.
   */
  response_headers_to_add?:
    | HeaderValueOption[]
    | undefined;
  /**
   * Specifies a list of HTTP headers that should be removed from each response
   * to requests matching this route.
   */
  response_headers_to_remove?:
    | string[]
    | undefined;
  /**
   * Presence of the object defines whether the connection manager's tracing configuration
   * is overridden by this route specific instance.
   */
  tracing?:
    | Tracing
    | undefined;
  /**
   * The maximum bytes which will be buffered for retries and shadowing.
   * If set, the bytes actually buffered will be the minimum value of this and the
   * listener per_connection_buffer_limit_bytes.
   */
  per_request_buffer_limit_bytes?:
    | number
    | undefined;
  /**
   * The human readable prefix to use when emitting statistics for this endpoint.
   * The statistics are rooted at vhost.<virtual host name>.route.<stat_prefix>.
   * This should be set for highly critical
   * endpoints that one wishes to get “per-route” statistics on.
   * If not set, endpoint statistics are not generated.
   *
   * The emitted statistics are the same as those documented for :ref:`virtual clusters <config_http_filters_router_vcluster_stats>`.
   *
   * .. warning::
   *
   *    We do not recommend setting up a stat prefix for
   *    every application endpoint. This is both not easily maintainable and
   *    statistics use a non-trivial amount of memory(approximately 1KiB per route).
   */
  stat_prefix?: string | undefined;
}

export interface Route_TypedPerFilterConfigEntry {
  $type: "envoy.config.route.v3.Route.TypedPerFilterConfigEntry";
  key: string;
  value?: Any | undefined;
}

/**
 * Compared to the :ref:`cluster <envoy_v3_api_field_config.route.v3.RouteAction.cluster>` field that specifies a
 * single upstream cluster as the target of a request, the :ref:`weighted_clusters
 * <envoy_v3_api_field_config.route.v3.RouteAction.weighted_clusters>` option allows for specification of
 * multiple upstream clusters along with weights that indicate the percentage of
 * traffic to be forwarded to each cluster. The router selects an upstream cluster based on the
 * weights.
 */
export interface WeightedCluster {
  $type: "envoy.config.route.v3.WeightedCluster";
  /** Specifies one or more upstream clusters associated with the route. */
  clusters?:
    | WeightedCluster_ClusterWeight[]
    | undefined;
  /**
   * Specifies the total weight across all clusters. The sum of all cluster weights must equal this
   * value, if this is greater than 0.
   * This field is now deprecated, and the client will use the sum of all
   * cluster weights. It is up to the management server to supply the correct weights.
   *
   * @deprecated
   */
  total_weight?:
    | number
    | undefined;
  /**
   * Specifies the runtime key prefix that should be used to construct the
   * runtime keys associated with each cluster. When the ``runtime_key_prefix`` is
   * specified, the router will look for weights associated with each upstream
   * cluster under the key ``runtime_key_prefix`` + ``.`` + ``cluster[i].name`` where
   * ``cluster[i]`` denotes an entry in the clusters array field. If the runtime
   * key for the cluster does not exist, the value specified in the
   * configuration file will be used as the default weight. See the :ref:`runtime documentation
   * <operations_runtime>` for how key names map to the underlying implementation.
   */
  runtime_key_prefix?: string | undefined;
  random_value_specifier?:
    | //
    /**
     * Specifies the header name that is used to look up the random value passed in the request header.
     * This is used to ensure consistent cluster picking across multiple proxy levels for weighted traffic.
     * If header is not present or invalid, Envoy will fall back to use the internally generated random value.
     * This header is expected to be single-valued header as we only want to have one selected value throughout
     * the process for the consistency. And the value is a unsigned number between 0 and UINT64_MAX.
     */
    { $case: "header_name"; header_name: string }
    | undefined;
}

/** [#next-free-field: 13] */
export interface WeightedCluster_ClusterWeight {
  $type: "envoy.config.route.v3.WeightedCluster.ClusterWeight";
  /**
   * Only one of ``name`` and ``cluster_header`` may be specified.
   * [#next-major-version: Need to add back the validation rule: (validate.rules).string = {min_len: 1}]
   * Name of the upstream cluster. The cluster must exist in the
   * :ref:`cluster manager configuration <config_cluster_manager>`.
   */
  name?:
    | string
    | undefined;
  /**
   * Only one of ``name`` and ``cluster_header`` may be specified.
   * [#next-major-version: Need to add back the validation rule: (validate.rules).string = {min_len: 1 }]
   * Envoy will determine the cluster to route to by reading the value of the
   * HTTP header named by cluster_header from the request headers. If the
   * header is not found or the referenced cluster does not exist, Envoy will
   * return a 404 response.
   *
   * .. attention::
   *
   *   Internally, Envoy always uses the HTTP/2 ``:authority`` header to represent the HTTP/1
   *   ``Host`` header. Thus, if attempting to match on ``Host``, match on ``:authority`` instead.
   *
   * .. note::
   *
   *   If the header appears multiple times only the first value is used.
   */
  cluster_header?:
    | string
    | undefined;
  /**
   * The weight of the cluster. This value is relative to the other clusters'
   * weights. When a request matches the route, the choice of an upstream cluster
   * is determined by its weight. The sum of weights across all
   * entries in the clusters array must be greater than 0, and must not exceed
   * uint32_t maximal value (4294967295).
   */
  weight?:
    | number
    | undefined;
  /**
   * Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints in
   * the upstream cluster with metadata matching what is set in this field will be considered for
   * load balancing. Note that this will be merged with what's provided in
   * :ref:`RouteAction.metadata_match <envoy_v3_api_field_config.route.v3.RouteAction.metadata_match>`, with
   * values here taking precedence. The filter name should be specified as ``envoy.lb``.
   */
  metadata_match?:
    | Metadata
    | undefined;
  /**
   * Specifies a list of headers to be added to requests when this cluster is selected
   * through the enclosing :ref:`envoy_v3_api_msg_config.route.v3.RouteAction`.
   * Headers specified at this level are applied before headers from the enclosing
   * :ref:`envoy_v3_api_msg_config.route.v3.Route`, :ref:`envoy_v3_api_msg_config.route.v3.VirtualHost`, and
   * :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration`. For more information, including details on
   * header value syntax, see the documentation on :ref:`custom request headers
   * <config_http_conn_man_headers_custom_request_headers>`.
   */
  request_headers_to_add?:
    | HeaderValueOption[]
    | undefined;
  /**
   * Specifies a list of HTTP headers that should be removed from each request when
   * this cluster is selected through the enclosing :ref:`envoy_v3_api_msg_config.route.v3.RouteAction`.
   */
  request_headers_to_remove?:
    | string[]
    | undefined;
  /**
   * Specifies a list of headers to be added to responses when this cluster is selected
   * through the enclosing :ref:`envoy_v3_api_msg_config.route.v3.RouteAction`.
   * Headers specified at this level are applied before headers from the enclosing
   * :ref:`envoy_v3_api_msg_config.route.v3.Route`, :ref:`envoy_v3_api_msg_config.route.v3.VirtualHost`, and
   * :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration`. For more information, including details on
   * header value syntax, see the documentation on :ref:`custom request headers
   * <config_http_conn_man_headers_custom_request_headers>`.
   */
  response_headers_to_add?:
    | HeaderValueOption[]
    | undefined;
  /**
   * Specifies a list of headers to be removed from responses when this cluster is selected
   * through the enclosing :ref:`envoy_v3_api_msg_config.route.v3.RouteAction`.
   */
  response_headers_to_remove?:
    | string[]
    | undefined;
  /**
   * This field can be used to provide weighted cluster specific per filter config. The key should match the
   * :ref:`filter config name
   * <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpFilter.name>`.
   * See :ref:`Http filter route specific config <arch_overview_http_filters_per_filter_config>`
   * for details.
   * [#comment: An entry's value may be wrapped in a
   * :ref:`FilterConfig<envoy_v3_api_msg_config.route.v3.FilterConfig>`
   * message to specify additional options.]
   */
  typed_per_filter_config?: Map<string, Any> | undefined;
  host_rewrite_specifier?:
    | //
    /**
     * Indicates that during forwarding, the host header will be swapped with
     * this value.
     */
    { $case: "host_rewrite_literal"; host_rewrite_literal: string }
    | undefined;
}

export interface WeightedCluster_ClusterWeight_TypedPerFilterConfigEntry {
  $type: "envoy.config.route.v3.WeightedCluster.ClusterWeight.TypedPerFilterConfigEntry";
  key: string;
  value?: Any | undefined;
}

/** Configuration for a cluster specifier plugin. */
export interface ClusterSpecifierPlugin {
  $type: "envoy.config.route.v3.ClusterSpecifierPlugin";
  /** The name of the plugin and its opaque configuration. */
  extension?:
    | TypedExtensionConfig
    | undefined;
  /**
   * If is_optional is not set or is set to false and the plugin defined by this message is not a
   * supported type, the containing resource is NACKed. If is_optional is set to true, the resource
   * would not be NACKed for this reason. In this case, routes referencing this plugin's name would
   * not be treated as an illegal configuration, but would result in a failure if the route is
   * selected.
   */
  is_optional?: boolean | undefined;
}

/** [#next-free-field: 16] */
export interface RouteMatch {
  $type: "envoy.config.route.v3.RouteMatch";
  path_specifier?:
    | //
    /**
     * If specified, the route is a prefix rule meaning that the prefix must
     * match the beginning of the ``:path`` header.
     */
    { $case: "prefix"; prefix: string }
    | //
    /**
     * If specified, the route is an exact path rule meaning that the path must
     * exactly match the ``:path`` header once the query string is removed.
     */
    { $case: "path"; path: string }
    | //
    /**
     * If specified, the route is a regular expression rule meaning that the
     * regex must match the ``:path`` header once the query string is removed. The entire path
     * (without the query string) must match the regex. The rule will not match if only a
     * subsequence of the ``:path`` header matches the regex.
     *
     * [#next-major-version: In the v3 API we should redo how path specification works such
     * that we utilize StringMatcher, and additionally have consistent options around whether we
     * strip query strings, do a case sensitive match, etc. In the interim it will be too disruptive
     * to deprecate the existing options. We should even consider whether we want to do away with
     * path_specifier entirely and just rely on a set of header matchers which can already match
     * on :path, etc. The issue with that is it is unclear how to generically deal with query string
     * stripping. This needs more thought.]
     */
    { $case: "safe_regex"; safe_regex: RegexMatcher }
    | //
    /**
     * If this is used as the matcher, the matcher will only match CONNECT or CONNECT-UDP requests.
     * Note that this will not match other Extended CONNECT requests (WebSocket and the like) as
     * they are normalized in Envoy as HTTP/1.1 style upgrades.
     * This is the only way to match CONNECT requests for HTTP/1.1. For HTTP/2 and HTTP/3,
     * where Extended CONNECT requests may have a path, the path matchers will work if
     * there is a path present.
     * Note that CONNECT support is currently considered alpha in Envoy.
     * [#comment: TODO(htuch): Replace the above comment with an alpha tag.]
     */
    { $case: "connect_matcher"; connect_matcher: RouteMatch_ConnectMatcher }
    | //
    /**
     * If specified, the route is a path-separated prefix rule meaning that the
     * ``:path`` header (without the query string) must either exactly match the
     * ``path_separated_prefix`` or have it as a prefix, followed by ``/``
     *
     * For example, ``/api/dev`` would match
     * ``/api/dev``, ``/api/dev/``, ``/api/dev/v1``, and ``/api/dev?param=true``
     * but would not match ``/api/developer``
     *
     * Expect the value to not contain ``?`` or ``#`` and not to end in ``/``
     */
    { $case: "path_separated_prefix"; path_separated_prefix: string }
    | //
    /** [#extension-category: envoy.path.match] */
    { $case: "path_match_policy"; path_match_policy: TypedExtensionConfig }
    | undefined;
  /**
   * Indicates that prefix/path matching should be case sensitive. The default
   * is true. Ignored for safe_regex matching.
   */
  case_sensitive?:
    | boolean
    | undefined;
  /**
   * Indicates that the route should additionally match on a runtime key. Every time the route
   * is considered for a match, it must also fall under the percentage of matches indicated by
   * this field. For some fraction N/D, a random number in the range [0,D) is selected. If the
   * number is <= the value of the numerator N, or if the key is not present, the default
   * value, the router continues to evaluate the remaining match criteria. A runtime_fraction
   * route configuration can be used to roll out route changes in a gradual manner without full
   * code/config deploys. Refer to the :ref:`traffic shifting
   * <config_http_conn_man_route_table_traffic_splitting_shift>` docs for additional documentation.
   *
   * .. note::
   *
   *    Parsing this field is implemented such that the runtime key's data may be represented
   *    as a FractionalPercent proto represented as JSON/YAML and may also be represented as an
   *    integer with the assumption that the value is an integral percentage out of 100. For
   *    instance, a runtime key lookup returning the value "42" would parse as a FractionalPercent
   *    whose numerator is 42 and denominator is HUNDRED. This preserves legacy semantics.
   */
  runtime_fraction?:
    | RuntimeFractionalPercent
    | undefined;
  /**
   * Specifies a set of headers that the route should match on. The router will
   * check the request’s headers against all the specified headers in the route
   * config. A match will happen if all the headers in the route are present in
   * the request with the same values (or based on presence if the value field
   * is not in the config).
   */
  headers?:
    | HeaderMatcher[]
    | undefined;
  /**
   * Specifies a set of URL query parameters on which the route should
   * match. The router will check the query string from the ``path`` header
   * against all the specified query parameters. If the number of specified
   * query parameters is nonzero, they all must match the ``path`` header's
   * query string for a match to occur. In the event query parameters are
   * repeated, only the first value for each key will be considered.
   *
   * .. note::
   *
   *    If query parameters are used to pass request message fields when
   *    `grpc_json_transcoder <https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/grpc_json_transcoder_filter>`_
   *    is used, the transcoded message fields maybe different. The query parameters are
   *    url encoded, but the message fields are not. For example, if a query
   *    parameter is "foo%20bar", the message field will be "foo bar".
   */
  query_parameters?:
    | QueryParameterMatcher[]
    | undefined;
  /**
   * If specified, only gRPC requests will be matched. The router will check
   * that the content-type header has a application/grpc or one of the various
   * application/grpc+ values.
   */
  grpc?:
    | RouteMatch_GrpcRouteMatchOptions
    | undefined;
  /**
   * If specified, the client tls context will be matched against the defined
   * match options.
   *
   * [#next-major-version: unify with RBAC]
   */
  tls_context?:
    | RouteMatch_TlsContextMatchOptions
    | undefined;
  /**
   * Specifies a set of dynamic metadata matchers on which the route should match.
   * The router will check the dynamic metadata against all the specified dynamic metadata matchers.
   * If the number of specified dynamic metadata matchers is nonzero, they all must match the
   * dynamic metadata for a match to occur.
   */
  dynamic_metadata?: MetadataMatcher[] | undefined;
}

export interface RouteMatch_GrpcRouteMatchOptions {
  $type: "envoy.config.route.v3.RouteMatch.GrpcRouteMatchOptions";
}

export interface RouteMatch_TlsContextMatchOptions {
  $type: "envoy.config.route.v3.RouteMatch.TlsContextMatchOptions";
  /**
   * If specified, the route will match against whether or not a certificate is presented.
   * If not specified, certificate presentation status (true or false) will not be considered when route matching.
   */
  presented?:
    | boolean
    | undefined;
  /**
   * If specified, the route will match against whether or not a certificate is validated.
   * If not specified, certificate validation status (true or false) will not be considered when route matching.
   *
   * .. warning::
   *
   *    Client certificate validation is not currently performed upon TLS session resumption. For
   *    a resumed TLS session the route will match only when ``validated`` is false, regardless of
   *    whether the client TLS certificate is valid.
   *
   *    The only known workaround for this issue is to disable TLS session resumption entirely, by
   *    setting both :ref:`disable_stateless_session_resumption <envoy_v3_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.disable_stateless_session_resumption>`
   *    and :ref:`disable_stateful_session_resumption <envoy_v3_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.disable_stateful_session_resumption>` on the DownstreamTlsContext.
   */
  validated?: boolean | undefined;
}

/** An extensible message for matching CONNECT or CONNECT-UDP requests. */
export interface RouteMatch_ConnectMatcher {
  $type: "envoy.config.route.v3.RouteMatch.ConnectMatcher";
}

/**
 * Cors policy configuration.
 *
 * .. attention::
 *
 *   This message has been deprecated. Please use
 *   :ref:`CorsPolicy in filter extension <envoy_v3_api_msg_extensions.filters.http.cors.v3.CorsPolicy>`
 *   as as alternative.
 *
 * [#next-free-field: 14]
 */
export interface CorsPolicy {
  $type: "envoy.config.route.v3.CorsPolicy";
  /**
   * Specifies string patterns that match allowed origins. An origin is allowed if any of the
   * string matchers match.
   */
  allow_origin_string_match?:
    | StringMatcher[]
    | undefined;
  /** Specifies the content for the ``access-control-allow-methods`` header. */
  allow_methods?:
    | string
    | undefined;
  /** Specifies the content for the ``access-control-allow-headers`` header. */
  allow_headers?:
    | string
    | undefined;
  /** Specifies the content for the ``access-control-expose-headers`` header. */
  expose_headers?:
    | string
    | undefined;
  /** Specifies the content for the ``access-control-max-age`` header. */
  max_age?:
    | string
    | undefined;
  /** Specifies whether the resource allows credentials. */
  allow_credentials?: boolean | undefined;
  enabled_specifier?:
    | //
    /**
     * Specifies the % of requests for which the CORS filter is enabled.
     *
     * If neither ``enabled``, ``filter_enabled``, nor ``shadow_enabled`` are specified, the CORS
     * filter will be enabled for 100% of the requests.
     *
     * If :ref:`runtime_key <envoy_v3_api_field_config.core.v3.RuntimeFractionalPercent.runtime_key>` is
     * specified, Envoy will lookup the runtime key to get the percentage of requests to filter.
     */
    { $case: "filter_enabled"; filter_enabled: RuntimeFractionalPercent }
    | undefined;
  /**
   * Specifies the % of requests for which the CORS policies will be evaluated and tracked, but not
   * enforced.
   *
   * This field is intended to be used when ``filter_enabled`` and ``enabled`` are off. One of those
   * fields have to explicitly disable the filter in order for this setting to take effect.
   *
   * If :ref:`runtime_key <envoy_v3_api_field_config.core.v3.RuntimeFractionalPercent.runtime_key>` is specified,
   * Envoy will lookup the runtime key to get the percentage of requests for which it will evaluate
   * and track the request's ``Origin`` to determine if it's valid but will not enforce any policies.
   */
  shadow_enabled?:
    | RuntimeFractionalPercent
    | undefined;
  /**
   * Specify whether allow requests whose target server's IP address is more private than that from
   * which the request initiator was fetched.
   *
   * More details refer to https://developer.chrome.com/blog/private-network-access-preflight.
   */
  allow_private_network_access?:
    | boolean
    | undefined;
  /**
   * Specifies if preflight requests not matching the configured allowed origin should be forwarded
   * to the upstream. Default is true.
   */
  forward_not_matching_preflights?: boolean | undefined;
}

/** [#next-free-field: 42] */
export interface RouteAction {
  $type: "envoy.config.route.v3.RouteAction";
  cluster_specifier?:
    | //
    /**
     * Indicates the upstream cluster to which the request should be routed
     * to.
     */
    { $case: "cluster"; cluster: string }
    | //
    /**
     * Envoy will determine the cluster to route to by reading the value of the
     * HTTP header named by cluster_header from the request headers. If the
     * header is not found or the referenced cluster does not exist, Envoy will
     * return a 404 response.
     *
     * .. attention::
     *
     *   Internally, Envoy always uses the HTTP/2 ``:authority`` header to represent the HTTP/1
     *   ``Host`` header. Thus, if attempting to match on ``Host``, match on ``:authority`` instead.
     *
     * .. note::
     *
     *   If the header appears multiple times only the first value is used.
     */
    { $case: "cluster_header"; cluster_header: string }
    | //
    /**
     * Multiple upstream clusters can be specified for a given route. The
     * request is routed to one of the upstream clusters based on weights
     * assigned to each cluster. See
     * :ref:`traffic splitting <config_http_conn_man_route_table_traffic_splitting_split>`
     * for additional documentation.
     */
    { $case: "weighted_clusters"; weighted_clusters: WeightedCluster }
    | //
    /**
     * Name of the cluster specifier plugin to use to determine the cluster for requests on this route.
     * The cluster specifier plugin name must be defined in the associated
     * :ref:`cluster specifier plugins <envoy_v3_api_field_config.route.v3.RouteConfiguration.cluster_specifier_plugins>`
     * in the :ref:`name <envoy_v3_api_field_config.core.v3.TypedExtensionConfig.name>` field.
     */
    { $case: "cluster_specifier_plugin"; cluster_specifier_plugin: string }
    | //
    /**
     * Custom cluster specifier plugin configuration to use to determine the cluster for requests
     * on this route.
     */
    { $case: "inline_cluster_specifier_plugin"; inline_cluster_specifier_plugin: ClusterSpecifierPlugin }
    | undefined;
  /**
   * The HTTP status code to use when configured cluster is not found.
   * The default response code is 503 Service Unavailable.
   */
  cluster_not_found_response_code?:
    | RouteAction_ClusterNotFoundResponseCode
    | undefined;
  /**
   * Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints
   * in the upstream cluster with metadata matching what's set in this field will be considered
   * for load balancing. If using :ref:`weighted_clusters
   * <envoy_v3_api_field_config.route.v3.RouteAction.weighted_clusters>`, metadata will be merged, with values
   * provided there taking precedence. The filter name should be specified as ``envoy.lb``.
   */
  metadata_match?:
    | Metadata
    | undefined;
  /**
   * Indicates that during forwarding, the matched prefix (or path) should be
   * swapped with this value. This option allows application URLs to be rooted
   * at a different path from those exposed at the reverse proxy layer. The router filter will
   * place the original path before rewrite into the :ref:`x-envoy-original-path
   * <config_http_filters_router_x-envoy-original-path>` header.
   *
   * Only one of :ref:`regex_rewrite <envoy_v3_api_field_config.route.v3.RouteAction.regex_rewrite>`
   * :ref:`path_rewrite_policy <envoy_v3_api_field_config.route.v3.RouteAction.path_rewrite_policy>`,
   * or :ref:`prefix_rewrite <envoy_v3_api_field_config.route.v3.RouteAction.prefix_rewrite>` may be specified.
   *
   * .. attention::
   *
   *   Pay careful attention to the use of trailing slashes in the
   *   :ref:`route's match <envoy_v3_api_field_config.route.v3.Route.match>` prefix value.
   *   Stripping a prefix from a path requires multiple Routes to handle all cases. For example,
   *   rewriting ``/prefix`` to ``/`` and ``/prefix/etc`` to ``/etc`` cannot be done in a single
   *   :ref:`Route <envoy_v3_api_msg_config.route.v3.Route>`, as shown by the below config entries:
   *
   *   .. code-block:: yaml
   *
   *     - match:
   *         prefix: "/prefix/"
   *       route:
   *         prefix_rewrite: "/"
   *     - match:
   *         prefix: "/prefix"
   *       route:
   *         prefix_rewrite: "/"
   *
   *   Having above entries in the config, requests to ``/prefix`` will be stripped to ``/``, while
   *   requests to ``/prefix/etc`` will be stripped to ``/etc``.
   */
  prefix_rewrite?:
    | string
    | undefined;
  /**
   * Indicates that during forwarding, portions of the path that match the
   * pattern should be rewritten, even allowing the substitution of capture
   * groups from the pattern into the new path as specified by the rewrite
   * substitution string. This is useful to allow application paths to be
   * rewritten in a way that is aware of segments with variable content like
   * identifiers. The router filter will place the original path as it was
   * before the rewrite into the :ref:`x-envoy-original-path
   * <config_http_filters_router_x-envoy-original-path>` header.
   *
   * Only one of :ref:`regex_rewrite <envoy_v3_api_field_config.route.v3.RouteAction.regex_rewrite>`,
   * :ref:`prefix_rewrite <envoy_v3_api_field_config.route.v3.RouteAction.prefix_rewrite>`, or
   * :ref:`path_rewrite_policy <envoy_v3_api_field_config.route.v3.RouteAction.path_rewrite_policy>`]
   * may be specified.
   *
   * Examples using Google's `RE2 <https://github.com/google/re2>`_ engine:
   *
   * * The path pattern ``^/service/([^/]+)(/.*)$`` paired with a substitution
   *   string of ``\2/instance/\1`` would transform ``/service/foo/v1/api``
   *   into ``/v1/api/instance/foo``.
   *
   * * The pattern ``one`` paired with a substitution string of ``two`` would
   *   transform ``/xxx/one/yyy/one/zzz`` into ``/xxx/two/yyy/two/zzz``.
   *
   * * The pattern ``^(.*?)one(.*)$`` paired with a substitution string of
   *   ``\1two\2`` would replace only the first occurrence of ``one``,
   *   transforming path ``/xxx/one/yyy/one/zzz`` into ``/xxx/two/yyy/one/zzz``.
   *
   * * The pattern ``(?i)/xxx/`` paired with a substitution string of ``/yyy/``
   *   would do a case-insensitive match and transform path ``/aaa/XxX/bbb`` to
   *   ``/aaa/yyy/bbb``.
   */
  regex_rewrite?:
    | RegexMatchAndSubstitute
    | undefined;
  /** [#extension-category: envoy.path.rewrite] */
  path_rewrite_policy?: TypedExtensionConfig | undefined;
  host_rewrite_specifier?:
    | //
    /**
     * Indicates that during forwarding, the host header will be swapped with
     * this value. Using this option will append the
     * :ref:`config_http_conn_man_headers_x-forwarded-host` header if
     * :ref:`append_x_forwarded_host <envoy_v3_api_field_config.route.v3.RouteAction.append_x_forwarded_host>`
     * is set.
     */
    { $case: "host_rewrite_literal"; host_rewrite_literal: string }
    | //
    /**
     * Indicates that during forwarding, the host header will be swapped with
     * the hostname of the upstream host chosen by the cluster manager. This
     * option is applicable only when the destination cluster for a route is of
     * type ``strict_dns`` or ``logical_dns``,
     * or when :ref:`hostname <envoy_v3_api_field_config.endpoint.v3.Endpoint.hostname>`
     * field is not empty. Setting this to true with other cluster types
     * has no effect. Using this option will append the
     * :ref:`config_http_conn_man_headers_x-forwarded-host` header if
     * :ref:`append_x_forwarded_host <envoy_v3_api_field_config.route.v3.RouteAction.append_x_forwarded_host>`
     * is set.
     */
    { $case: "auto_host_rewrite"; auto_host_rewrite: boolean | undefined }
    | //
    /**
     * Indicates that during forwarding, the host header will be swapped with the content of given
     * downstream or :ref:`custom <config_http_conn_man_headers_custom_request_headers>` header.
     * If header value is empty, host header is left intact. Using this option will append the
     * :ref:`config_http_conn_man_headers_x-forwarded-host` header if
     * :ref:`append_x_forwarded_host <envoy_v3_api_field_config.route.v3.RouteAction.append_x_forwarded_host>`
     * is set.
     *
     * .. attention::
     *
     *   Pay attention to the potential security implications of using this option. Provided header
     *   must come from trusted source.
     *
     * .. note::
     *
     *   If the header appears multiple times only the first value is used.
     */
    { $case: "host_rewrite_header"; host_rewrite_header: string }
    | //
    /**
     * Indicates that during forwarding, the host header will be swapped with
     * the result of the regex substitution executed on path value with query and fragment removed.
     * This is useful for transitioning variable content between path segment and subdomain.
     * Using this option will append the
     * :ref:`config_http_conn_man_headers_x-forwarded-host` header if
     * :ref:`append_x_forwarded_host <envoy_v3_api_field_config.route.v3.RouteAction.append_x_forwarded_host>`
     * is set.
     *
     * For example with the following config:
     *
     *   .. code-block:: yaml
     *
     *     host_rewrite_path_regex:
     *       pattern:
     *         google_re2: {}
     *         regex: "^/(.+)/.+$"
     *       substitution: \1
     *
     * Would rewrite the host header to ``envoyproxy.io`` given the path ``/envoyproxy.io/some/path``.
     */
    { $case: "host_rewrite_path_regex"; host_rewrite_path_regex: RegexMatchAndSubstitute }
    | undefined;
  /**
   * If set, then a host rewrite action (one of
   * :ref:`host_rewrite_literal <envoy_v3_api_field_config.route.v3.RouteAction.host_rewrite_literal>`,
   * :ref:`auto_host_rewrite <envoy_v3_api_field_config.route.v3.RouteAction.auto_host_rewrite>`,
   * :ref:`host_rewrite_header <envoy_v3_api_field_config.route.v3.RouteAction.host_rewrite_header>`, or
   * :ref:`host_rewrite_path_regex <envoy_v3_api_field_config.route.v3.RouteAction.host_rewrite_path_regex>`)
   * causes the original value of the host header, if any, to be appended to the
   * :ref:`config_http_conn_man_headers_x-forwarded-host` HTTP header if it is different to the last value appended.
   */
  append_x_forwarded_host?:
    | boolean
    | undefined;
  /**
   * Specifies the upstream timeout for the route. If not specified, the default is 15s. This
   * spans between the point at which the entire downstream request (i.e. end-of-stream) has been
   * processed and when the upstream response has been completely processed. A value of 0 will
   * disable the route's timeout.
   *
   * .. note::
   *
   *   This timeout includes all retries. See also
   *   :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`,
   *   :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms`, and the
   *   :ref:`retry overview <arch_overview_http_routing_retry>`.
   */
  timeout?:
    | Duration
    | undefined;
  /**
   * Specifies the idle timeout for the route. If not specified, there is no per-route idle timeout,
   * although the connection manager wide :ref:`stream_idle_timeout
   * <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout>`
   * will still apply. A value of 0 will completely disable the route's idle timeout, even if a
   * connection manager stream idle timeout is configured.
   *
   * The idle timeout is distinct to :ref:`timeout
   * <envoy_v3_api_field_config.route.v3.RouteAction.timeout>`, which provides an upper bound
   * on the upstream response time; :ref:`idle_timeout
   * <envoy_v3_api_field_config.route.v3.RouteAction.idle_timeout>` instead bounds the amount
   * of time the request's stream may be idle.
   *
   * After header decoding, the idle timeout will apply on downstream and
   * upstream request events. Each time an encode/decode event for headers or
   * data is processed for the stream, the timer will be reset. If the timeout
   * fires, the stream is terminated with a 408 Request Timeout error code if no
   * upstream response header has been received, otherwise a stream reset
   * occurs.
   *
   * If the :ref:`overload action <config_overload_manager_overload_actions>` "envoy.overload_actions.reduce_timeouts"
   * is configured, this timeout is scaled according to the value for
   * :ref:`HTTP_DOWNSTREAM_STREAM_IDLE <envoy_v3_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_STREAM_IDLE>`.
   */
  idle_timeout?:
    | Duration
    | undefined;
  /**
   * Specifies how to send request over TLS early data.
   * If absent, allows `safe HTTP requests <https://www.rfc-editor.org/rfc/rfc7231#section-4.2.1>`_ to be sent on early data.
   * [#extension-category: envoy.route.early_data_policy]
   */
  early_data_policy?:
    | TypedExtensionConfig
    | undefined;
  /**
   * Indicates that the route has a retry policy. Note that if this is set,
   * it'll take precedence over the virtual host level retry policy entirely
   * (e.g.: policies are not merged, most internal one becomes the enforced policy).
   */
  retry_policy?:
    | RetryPolicy
    | undefined;
  /**
   * [#not-implemented-hide:]
   * Specifies the configuration for retry policy extension. Note that if this is set, it'll take
   * precedence over the virtual host level retry policy entirely (e.g.: policies are not merged,
   * most internal one becomes the enforced policy). :ref:`Retry policy <envoy_v3_api_field_config.route.v3.VirtualHost.retry_policy>`
   * should not be set if this field is used.
   */
  retry_policy_typed_config?:
    | Any
    | undefined;
  /**
   * Specify a set of route request mirroring policies.
   * It takes precedence over the virtual host and route config mirror policy entirely.
   * That is, policies are not merged, the most specific non-empty one becomes the mirror policies.
   */
  request_mirror_policies?:
    | RouteAction_RequestMirrorPolicy[]
    | undefined;
  /** Optionally specifies the :ref:`routing priority <arch_overview_http_routing_priority>`. */
  priority?:
    | RoutingPriority
    | undefined;
  /**
   * Specifies a set of rate limit configurations that could be applied to the
   * route.
   */
  rate_limits?:
    | RateLimit[]
    | undefined;
  /**
   * Specifies if the rate limit filter should include the virtual host rate
   * limits. By default, if the route configured rate limits, the virtual host
   * :ref:`rate_limits <envoy_v3_api_field_config.route.v3.VirtualHost.rate_limits>` are not applied to the
   * request.
   *
   * This field is deprecated. Please use :ref:`vh_rate_limits <envoy_v3_api_field_extensions.filters.http.ratelimit.v3.RateLimitPerRoute.vh_rate_limits>`
   *
   * @deprecated
   */
  include_vh_rate_limits?:
    | boolean
    | undefined;
  /**
   * Specifies a list of hash policies to use for ring hash load balancing. Each
   * hash policy is evaluated individually and the combined result is used to
   * route the request. The method of combination is deterministic such that
   * identical lists of hash policies will produce the same hash. Since a hash
   * policy examines specific parts of a request, it can fail to produce a hash
   * (i.e. if the hashed header is not present). If (and only if) all configured
   * hash policies fail to generate a hash, no hash will be produced for
   * the route. In this case, the behavior is the same as if no hash policies
   * were specified (i.e. the ring hash load balancer will choose a random
   * backend). If a hash policy has the "terminal" attribute set to true, and
   * there is already a hash generated, the hash is returned immediately,
   * ignoring the rest of the hash policy list.
   */
  hash_policy?:
    | RouteAction_HashPolicy[]
    | undefined;
  /**
   * Indicates that the route has a CORS policy. This field is ignored if related cors policy is
   * found in the :ref:`Route.typed_per_filter_config<envoy_v3_api_field_config.route.v3.Route.typed_per_filter_config>` or
   * :ref:`WeightedCluster.ClusterWeight.typed_per_filter_config<envoy_v3_api_field_config.route.v3.WeightedCluster.ClusterWeight.typed_per_filter_config>`.
   *
   * .. attention::
   *
   *   This option has been deprecated. Please use
   *   :ref:`Route.typed_per_filter_config<envoy_v3_api_field_config.route.v3.Route.typed_per_filter_config>` or
   *   :ref:`WeightedCluster.ClusterWeight.typed_per_filter_config<envoy_v3_api_field_config.route.v3.WeightedCluster.ClusterWeight.typed_per_filter_config>`
   *   to configure the CORS HTTP filter.
   *
   * @deprecated
   */
  cors?:
    | CorsPolicy
    | undefined;
  /**
   * Deprecated by :ref:`grpc_timeout_header_max <envoy_v3_api_field_config.route.v3.RouteAction.MaxStreamDuration.grpc_timeout_header_max>`
   * If present, and the request is a gRPC request, use the
   * `grpc-timeout header <https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md>`_,
   * or its default value (infinity) instead of
   * :ref:`timeout <envoy_v3_api_field_config.route.v3.RouteAction.timeout>`, but limit the applied timeout
   * to the maximum value specified here. If configured as 0, the maximum allowed timeout for
   * gRPC requests is infinity. If not configured at all, the ``grpc-timeout`` header is not used
   * and gRPC requests time out like any other requests using
   * :ref:`timeout <envoy_v3_api_field_config.route.v3.RouteAction.timeout>` or its default.
   * This can be used to prevent unexpected upstream request timeouts due to potentially long
   * time gaps between gRPC request and response in gRPC streaming mode.
   *
   * .. note::
   *
   *    If a timeout is specified using :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`, it takes
   *    precedence over `grpc-timeout header <https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md>`_, when
   *    both are present. See also
   *    :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`,
   *    :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms`, and the
   *    :ref:`retry overview <arch_overview_http_routing_retry>`.
   *
   * @deprecated
   */
  max_grpc_timeout?:
    | Duration
    | undefined;
  /**
   * Deprecated by :ref:`grpc_timeout_header_offset <envoy_v3_api_field_config.route.v3.RouteAction.MaxStreamDuration.grpc_timeout_header_offset>`.
   * If present, Envoy will adjust the timeout provided by the ``grpc-timeout`` header by subtracting
   * the provided duration from the header. This is useful in allowing Envoy to set its global
   * timeout to be less than that of the deadline imposed by the calling client, which makes it more
   * likely that Envoy will handle the timeout instead of having the call canceled by the client.
   * The offset will only be applied if the provided grpc_timeout is greater than the offset. This
   * ensures that the offset will only ever decrease the timeout and never set it to 0 (meaning
   * infinity).
   *
   * @deprecated
   */
  grpc_timeout_offset?: Duration | undefined;
  upgrade_configs?:
    | RouteAction_UpgradeConfig[]
    | undefined;
  /**
   * If present, Envoy will try to follow an upstream redirect response instead of proxying the
   * response back to the downstream. An upstream redirect response is defined
   * by :ref:`redirect_response_codes
   * <envoy_v3_api_field_config.route.v3.InternalRedirectPolicy.redirect_response_codes>`.
   */
  internal_redirect_policy?:
    | InternalRedirectPolicy
    | undefined;
  /** @deprecated */
  internal_redirect_action?:
    | RouteAction_InternalRedirectAction
    | undefined;
  /**
   * An internal redirect is handled, iff the number of previous internal redirects that a
   * downstream request has encountered is lower than this value, and
   * :ref:`internal_redirect_action <envoy_v3_api_field_config.route.v3.RouteAction.internal_redirect_action>`
   * is set to :ref:`HANDLE_INTERNAL_REDIRECT
   * <envoy_v3_api_enum_value_config.route.v3.RouteAction.InternalRedirectAction.HANDLE_INTERNAL_REDIRECT>`
   * In the case where a downstream request is bounced among multiple routes by internal redirect,
   * the first route that hits this threshold, or has
   * :ref:`internal_redirect_action <envoy_v3_api_field_config.route.v3.RouteAction.internal_redirect_action>`
   * set to
   * :ref:`PASS_THROUGH_INTERNAL_REDIRECT
   * <envoy_v3_api_enum_value_config.route.v3.RouteAction.InternalRedirectAction.PASS_THROUGH_INTERNAL_REDIRECT>`
   * will pass the redirect back to downstream.
   *
   * If not specified, at most one redirect will be followed.
   *
   * @deprecated
   */
  max_internal_redirects?:
    | number
    | undefined;
  /**
   * Indicates that the route has a hedge policy. Note that if this is set,
   * it'll take precedence over the virtual host level hedge policy entirely
   * (e.g.: policies are not merged, most internal one becomes the enforced policy).
   */
  hedge_policy?:
    | HedgePolicy
    | undefined;
  /** Specifies the maximum stream duration for this route. */
  max_stream_duration?: RouteAction_MaxStreamDuration | undefined;
}

export enum RouteAction_ClusterNotFoundResponseCode {
  /** SERVICE_UNAVAILABLE - HTTP status code - 503 Service Unavailable. */
  SERVICE_UNAVAILABLE = "SERVICE_UNAVAILABLE",
  /** NOT_FOUND - HTTP status code - 404 Not Found. */
  NOT_FOUND = "NOT_FOUND",
  /** INTERNAL_SERVER_ERROR - HTTP status code - 500 Internal Server Error. */
  INTERNAL_SERVER_ERROR = "INTERNAL_SERVER_ERROR",
}

export function routeAction_ClusterNotFoundResponseCodeFromJSON(object: any): RouteAction_ClusterNotFoundResponseCode {
  switch (object) {
    case 0:
    case "SERVICE_UNAVAILABLE":
      return RouteAction_ClusterNotFoundResponseCode.SERVICE_UNAVAILABLE;
    case 1:
    case "NOT_FOUND":
      return RouteAction_ClusterNotFoundResponseCode.NOT_FOUND;
    case 2:
    case "INTERNAL_SERVER_ERROR":
      return RouteAction_ClusterNotFoundResponseCode.INTERNAL_SERVER_ERROR;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum RouteAction_ClusterNotFoundResponseCode",
      );
  }
}

export function routeAction_ClusterNotFoundResponseCodeToJSON(object: RouteAction_ClusterNotFoundResponseCode): string {
  switch (object) {
    case RouteAction_ClusterNotFoundResponseCode.SERVICE_UNAVAILABLE:
      return "SERVICE_UNAVAILABLE";
    case RouteAction_ClusterNotFoundResponseCode.NOT_FOUND:
      return "NOT_FOUND";
    case RouteAction_ClusterNotFoundResponseCode.INTERNAL_SERVER_ERROR:
      return "INTERNAL_SERVER_ERROR";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum RouteAction_ClusterNotFoundResponseCode",
      );
  }
}

export function routeAction_ClusterNotFoundResponseCodeToNumber(
  object: RouteAction_ClusterNotFoundResponseCode,
): number {
  switch (object) {
    case RouteAction_ClusterNotFoundResponseCode.SERVICE_UNAVAILABLE:
      return 0;
    case RouteAction_ClusterNotFoundResponseCode.NOT_FOUND:
      return 1;
    case RouteAction_ClusterNotFoundResponseCode.INTERNAL_SERVER_ERROR:
      return 2;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum RouteAction_ClusterNotFoundResponseCode",
      );
  }
}

/**
 * Configures :ref:`internal redirect <arch_overview_internal_redirects>` behavior.
 * [#next-major-version: remove this definition - it's defined in the InternalRedirectPolicy message.]
 *
 * @deprecated
 */
export enum RouteAction_InternalRedirectAction {
  PASS_THROUGH_INTERNAL_REDIRECT = "PASS_THROUGH_INTERNAL_REDIRECT",
  HANDLE_INTERNAL_REDIRECT = "HANDLE_INTERNAL_REDIRECT",
}

export function routeAction_InternalRedirectActionFromJSON(object: any): RouteAction_InternalRedirectAction {
  switch (object) {
    case 0:
    case "PASS_THROUGH_INTERNAL_REDIRECT":
      return RouteAction_InternalRedirectAction.PASS_THROUGH_INTERNAL_REDIRECT;
    case 1:
    case "HANDLE_INTERNAL_REDIRECT":
      return RouteAction_InternalRedirectAction.HANDLE_INTERNAL_REDIRECT;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RouteAction_InternalRedirectAction");
  }
}

export function routeAction_InternalRedirectActionToJSON(object: RouteAction_InternalRedirectAction): string {
  switch (object) {
    case RouteAction_InternalRedirectAction.PASS_THROUGH_INTERNAL_REDIRECT:
      return "PASS_THROUGH_INTERNAL_REDIRECT";
    case RouteAction_InternalRedirectAction.HANDLE_INTERNAL_REDIRECT:
      return "HANDLE_INTERNAL_REDIRECT";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RouteAction_InternalRedirectAction");
  }
}

export function routeAction_InternalRedirectActionToNumber(object: RouteAction_InternalRedirectAction): number {
  switch (object) {
    case RouteAction_InternalRedirectAction.PASS_THROUGH_INTERNAL_REDIRECT:
      return 0;
    case RouteAction_InternalRedirectAction.HANDLE_INTERNAL_REDIRECT:
      return 1;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RouteAction_InternalRedirectAction");
  }
}

/**
 * The router is capable of shadowing traffic from one cluster to another. The current
 * implementation is "fire and forget," meaning Envoy will not wait for the shadow cluster to
 * respond before returning the response from the primary cluster. All normal statistics are
 * collected for the shadow cluster making this feature useful for testing.
 *
 * During shadowing, the host/authority header is altered such that ``-shadow`` is appended. This is
 * useful for logging. For example, ``cluster1`` becomes ``cluster1-shadow``. This behavior can be
 * disabled by setting ``disable_shadow_host_suffix_append`` to ``true``.
 *
 * .. note::
 *
 *   Shadowing will not be triggered if the primary cluster does not exist.
 *
 * .. note::
 *
 *   Shadowing doesn't support Http CONNECT and upgrades.
 * [#next-free-field: 7]
 */
export interface RouteAction_RequestMirrorPolicy {
  $type: "envoy.config.route.v3.RouteAction.RequestMirrorPolicy";
  /**
   * Only one of ``cluster`` and ``cluster_header`` can be specified.
   * [#next-major-version: Need to add back the validation rule: (validate.rules).string = {min_len: 1}]
   * Specifies the cluster that requests will be mirrored to. The cluster must
   * exist in the cluster manager configuration.
   */
  cluster?:
    | string
    | undefined;
  /**
   * Only one of ``cluster`` and ``cluster_header`` can be specified.
   * Envoy will determine the cluster to route to by reading the value of the
   * HTTP header named by cluster_header from the request headers. Only the first value in header is used,
   * and no shadow request will happen if the value is not found in headers. Envoy will not wait for
   * the shadow cluster to respond before returning the response from the primary cluster.
   *
   * .. attention::
   *
   *   Internally, Envoy always uses the HTTP/2 ``:authority`` header to represent the HTTP/1
   *   ``Host`` header. Thus, if attempting to match on ``Host``, match on ``:authority`` instead.
   *
   * .. note::
   *
   *   If the header appears multiple times only the first value is used.
   */
  cluster_header?:
    | string
    | undefined;
  /**
   * If not specified, all requests to the target cluster will be mirrored.
   *
   * If specified, this field takes precedence over the ``runtime_key`` field and requests must also
   * fall under the percentage of matches indicated by this field.
   *
   * For some fraction N/D, a random number in the range [0,D) is selected. If the
   * number is <= the value of the numerator N, or if the key is not present, the default
   * value, the request will be mirrored.
   */
  runtime_fraction?:
    | RuntimeFractionalPercent
    | undefined;
  /** Determines if the trace span should be sampled. Defaults to true. */
  trace_sampled?:
    | boolean
    | undefined;
  /** Disables appending the ``-shadow`` suffix to the shadowed ``Host`` header. Defaults to ``false``. */
  disable_shadow_host_suffix_append?: boolean | undefined;
}

/**
 * Specifies the route's hashing policy if the upstream cluster uses a hashing :ref:`load balancer
 * <arch_overview_load_balancing_types>`.
 * [#next-free-field: 7]
 */
export interface RouteAction_HashPolicy {
  $type: "envoy.config.route.v3.RouteAction.HashPolicy";
  policy_specifier?:
    | //
    /** Header hash policy. */
    { $case: "header"; header: RouteAction_HashPolicy_Header }
    | //
    /** Cookie hash policy. */
    { $case: "cookie"; cookie: RouteAction_HashPolicy_Cookie }
    | //
    /** Connection properties hash policy. */
    { $case: "connection_properties"; connection_properties: RouteAction_HashPolicy_ConnectionProperties }
    | //
    /** Query parameter hash policy. */
    { $case: "query_parameter"; query_parameter: RouteAction_HashPolicy_QueryParameter }
    | //
    /** Filter state hash policy. */
    { $case: "filter_state"; filter_state: RouteAction_HashPolicy_FilterState }
    | undefined;
  /**
   * The flag that short-circuits the hash computing. This field provides a
   * 'fallback' style of configuration: "if a terminal policy doesn't work,
   * fallback to rest of the policy list", it saves time when the terminal
   * policy works.
   *
   * If true, and there is already a hash computed, ignore rest of the
   * list of hash polices.
   * For example, if the following hash methods are configured:
   *
   *  ========= ========
   *  specifier terminal
   *  ========= ========
   *  Header A  true
   *  Header B  false
   *  Header C  false
   *  ========= ========
   *
   * The generateHash process ends if policy "header A" generates a hash, as
   * it's a terminal policy.
   */
  terminal?: boolean | undefined;
}

export interface RouteAction_HashPolicy_Header {
  $type: "envoy.config.route.v3.RouteAction.HashPolicy.Header";
  /**
   * The name of the request header that will be used to obtain the hash
   * key. If the request header is not present, no hash will be produced.
   */
  header_name?:
    | string
    | undefined;
  /**
   * If specified, the request header value will be rewritten and used
   * to produce the hash key.
   */
  regex_rewrite?: RegexMatchAndSubstitute | undefined;
}

/** CookieAttribute defines an API for adding additional attributes for a HTTP cookie. */
export interface RouteAction_HashPolicy_CookieAttribute {
  $type: "envoy.config.route.v3.RouteAction.HashPolicy.CookieAttribute";
  /** The name of the cookie attribute. */
  name?:
    | string
    | undefined;
  /** The optional value of the cookie attribute. */
  value?: string | undefined;
}

/**
 * Envoy supports two types of cookie affinity:
 *
 * 1. Passive. Envoy takes a cookie that's present in the cookies header and
 *    hashes on its value.
 *
 * 2. Generated. Envoy generates and sets a cookie with an expiration (TTL)
 *    on the first request from the client in its response to the client,
 *    based on the endpoint the request gets sent to. The client then
 *    presents this on the next and all subsequent requests. The hash of
 *    this is sufficient to ensure these requests get sent to the same
 *    endpoint. The cookie is generated by hashing the source and
 *    destination ports and addresses so that multiple independent HTTP2
 *    streams on the same connection will independently receive the same
 *    cookie, even if they arrive at the Envoy simultaneously.
 */
export interface RouteAction_HashPolicy_Cookie {
  $type: "envoy.config.route.v3.RouteAction.HashPolicy.Cookie";
  /**
   * The name of the cookie that will be used to obtain the hash key. If the
   * cookie is not present and ttl below is not set, no hash will be
   * produced.
   */
  name?:
    | string
    | undefined;
  /**
   * If specified, a cookie with the TTL will be generated if the cookie is
   * not present. If the TTL is present and zero, the generated cookie will
   * be a session cookie.
   */
  ttl?:
    | Duration
    | undefined;
  /**
   * The name of the path for the cookie. If no path is specified here, no path
   * will be set for the cookie.
   */
  path?:
    | string
    | undefined;
  /** Additional attributes for the cookie. They will be used when generating a new cookie. */
  attributes?: RouteAction_HashPolicy_CookieAttribute[] | undefined;
}

export interface RouteAction_HashPolicy_ConnectionProperties {
  $type: "envoy.config.route.v3.RouteAction.HashPolicy.ConnectionProperties";
  /** Hash on source IP address. */
  source_ip?: boolean | undefined;
}

export interface RouteAction_HashPolicy_QueryParameter {
  $type: "envoy.config.route.v3.RouteAction.HashPolicy.QueryParameter";
  /**
   * The name of the URL query parameter that will be used to obtain the hash
   * key. If the parameter is not present, no hash will be produced. Query
   * parameter names are case-sensitive. If query parameters are repeated, only
   * the first value will be considered.
   */
  name?: string | undefined;
}

export interface RouteAction_HashPolicy_FilterState {
  $type: "envoy.config.route.v3.RouteAction.HashPolicy.FilterState";
  /**
   * The name of the Object in the per-request filterState, which is an
   * Envoy::Hashable object. If there is no data associated with the key,
   * or the stored object is not Envoy::Hashable, no hash will be produced.
   */
  key?: string | undefined;
}

/**
 * Allows enabling and disabling upgrades on a per-route basis.
 * This overrides any enabled/disabled upgrade filter chain specified in the
 * HttpConnectionManager
 * :ref:`upgrade_configs
 * <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.upgrade_configs>`
 * but does not affect any custom filter chain specified there.
 */
export interface RouteAction_UpgradeConfig {
  $type: "envoy.config.route.v3.RouteAction.UpgradeConfig";
  /**
   * The case-insensitive name of this upgrade, e.g. "websocket".
   * For each upgrade type present in upgrade_configs, requests with
   * Upgrade: [upgrade_type] will be proxied upstream.
   */
  upgrade_type?:
    | string
    | undefined;
  /** Determines if upgrades are available on this route. Defaults to true. */
  enabled?:
    | boolean
    | undefined;
  /**
   * Configuration for sending data upstream as a raw data payload. This is used for
   * CONNECT requests, when forwarding CONNECT payload as raw TCP.
   * Note that CONNECT support is currently considered alpha in Envoy.
   * [#comment: TODO(htuch): Replace the above comment with an alpha tag.]
   */
  connect_config?: RouteAction_UpgradeConfig_ConnectConfig | undefined;
}

/**
 * Configuration for sending data upstream as a raw data payload. This is used for
 * CONNECT or POST requests, when forwarding request payload as raw TCP.
 */
export interface RouteAction_UpgradeConfig_ConnectConfig {
  $type: "envoy.config.route.v3.RouteAction.UpgradeConfig.ConnectConfig";
  /** If present, the proxy protocol header will be prepended to the CONNECT payload sent upstream. */
  proxy_protocol_config?:
    | ProxyProtocolConfig
    | undefined;
  /** If set, the route will also allow forwarding POST payload as raw TCP. */
  allow_post?: boolean | undefined;
}

export interface RouteAction_MaxStreamDuration {
  $type: "envoy.config.route.v3.RouteAction.MaxStreamDuration";
  /**
   * Specifies the maximum duration allowed for streams on the route. If not specified, the value
   * from the :ref:`max_stream_duration
   * <envoy_v3_api_field_config.core.v3.HttpProtocolOptions.max_stream_duration>` field in
   * :ref:`HttpConnectionManager.common_http_protocol_options
   * <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.common_http_protocol_options>`
   * is used. If this field is set explicitly to zero, any
   * HttpConnectionManager max_stream_duration timeout will be disabled for
   * this route.
   */
  max_stream_duration?:
    | Duration
    | undefined;
  /**
   * If present, and the request contains a `grpc-timeout header
   * <https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md>`_, use that value as the
   * ``max_stream_duration``, but limit the applied timeout to the maximum value specified here.
   * If set to 0, the ``grpc-timeout`` header is used without modification.
   */
  grpc_timeout_header_max?:
    | Duration
    | undefined;
  /**
   * If present, Envoy will adjust the timeout provided by the ``grpc-timeout`` header by
   * subtracting the provided duration from the header. This is useful for allowing Envoy to set
   * its global timeout to be less than that of the deadline imposed by the calling client, which
   * makes it more likely that Envoy will handle the timeout instead of having the call canceled
   * by the client. If, after applying the offset, the resulting timeout is zero or negative,
   * the stream will timeout immediately.
   */
  grpc_timeout_header_offset?: Duration | undefined;
}

/**
 * HTTP retry :ref:`architecture overview <arch_overview_http_routing_retry>`.
 * [#next-free-field: 14]
 */
export interface RetryPolicy {
  $type: "envoy.config.route.v3.RetryPolicy";
  /**
   * Specifies the conditions under which retry takes place. These are the same
   * conditions documented for :ref:`config_http_filters_router_x-envoy-retry-on` and
   * :ref:`config_http_filters_router_x-envoy-retry-grpc-on`.
   */
  retry_on?:
    | string
    | undefined;
  /**
   * Specifies the allowed number of retries. This parameter is optional and
   * defaults to 1. These are the same conditions documented for
   * :ref:`config_http_filters_router_x-envoy-max-retries`.
   */
  num_retries?:
    | number
    | undefined;
  /**
   * Specifies a non-zero upstream timeout per retry attempt (including the initial attempt). This
   * parameter is optional. The same conditions documented for
   * :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms` apply.
   *
   * .. note::
   *
   *   If left unspecified, Envoy will use the global
   *   :ref:`route timeout <envoy_v3_api_field_config.route.v3.RouteAction.timeout>` for the request.
   *   Consequently, when using a :ref:`5xx <config_http_filters_router_x-envoy-retry-on>` based
   *   retry policy, a request that times out will not be retried as the total timeout budget
   *   would have been exhausted.
   */
  per_try_timeout?:
    | Duration
    | undefined;
  /**
   * Specifies an upstream idle timeout per retry attempt (including the initial attempt). This
   * parameter is optional and if absent there is no per try idle timeout. The semantics of the per
   * try idle timeout are similar to the
   * :ref:`route idle timeout <envoy_v3_api_field_config.route.v3.RouteAction.timeout>` and
   * :ref:`stream idle timeout
   * <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout>`
   * both enforced by the HTTP connection manager. The difference is that this idle timeout
   * is enforced by the router for each individual attempt and thus after all previous filters have
   * run, as opposed to *before* all previous filters run for the other idle timeouts. This timeout
   * is useful in cases in which total request timeout is bounded by a number of retries and a
   * :ref:`per_try_timeout <envoy_v3_api_field_config.route.v3.RetryPolicy.per_try_timeout>`, but
   * there is a desire to ensure each try is making incremental progress. Note also that similar
   * to :ref:`per_try_timeout <envoy_v3_api_field_config.route.v3.RetryPolicy.per_try_timeout>`,
   * this idle timeout does not start until after both the entire request has been received by the
   * router *and* a connection pool connection has been obtained. Unlike
   * :ref:`per_try_timeout <envoy_v3_api_field_config.route.v3.RetryPolicy.per_try_timeout>`,
   * the idle timer continues once the response starts streaming back to the downstream client.
   * This ensures that response data continues to make progress without using one of the HTTP
   * connection manager idle timeouts.
   */
  per_try_idle_timeout?:
    | Duration
    | undefined;
  /**
   * Specifies an implementation of a RetryPriority which is used to determine the
   * distribution of load across priorities used for retries. Refer to
   * :ref:`retry plugin configuration <arch_overview_http_retry_plugins>` for more details.
   */
  retry_priority?:
    | RetryPolicy_RetryPriority
    | undefined;
  /**
   * Specifies a collection of RetryHostPredicates that will be consulted when selecting a host
   * for retries. If any of the predicates reject the host, host selection will be reattempted.
   * Refer to :ref:`retry plugin configuration <arch_overview_http_retry_plugins>` for more
   * details.
   */
  retry_host_predicate?:
    | RetryPolicy_RetryHostPredicate[]
    | undefined;
  /**
   * Retry options predicates that will be applied prior to retrying a request. These predicates
   * allow customizing request behavior between retries.
   * [#comment: add [#extension-category: envoy.retry_options_predicates] when there are built-in extensions]
   */
  retry_options_predicates?:
    | TypedExtensionConfig[]
    | undefined;
  /**
   * The maximum number of times host selection will be reattempted before giving up, at which
   * point the host that was last selected will be routed to. If unspecified, this will default to
   * retrying once.
   */
  host_selection_retry_max_attempts?:
    | number
    | undefined;
  /** HTTP status codes that should trigger a retry in addition to those specified by retry_on. */
  retriable_status_codes?:
    | number[]
    | undefined;
  /**
   * Specifies parameters that control exponential retry back off. This parameter is optional, in which case the
   * default base interval is 25 milliseconds or, if set, the current value of the
   * ``upstream.base_retry_backoff_ms`` runtime parameter. The default maximum interval is 10 times
   * the base interval. The documentation for :ref:`config_http_filters_router_x-envoy-max-retries`
   * describes Envoy's back-off algorithm.
   */
  retry_back_off?:
    | RetryPolicy_RetryBackOff
    | undefined;
  /**
   * Specifies parameters that control a retry back-off strategy that is used
   * when the request is rate limited by the upstream server. The server may
   * return a response header like ``Retry-After`` or ``X-RateLimit-Reset`` to
   * provide feedback to the client on how long to wait before retrying. If
   * configured, this back-off strategy will be used instead of the
   * default exponential back off strategy (configured using ``retry_back_off``)
   * whenever a response includes the matching headers.
   */
  rate_limited_retry_back_off?:
    | RetryPolicy_RateLimitedRetryBackOff
    | undefined;
  /**
   * HTTP response headers that trigger a retry if present in the response. A retry will be
   * triggered if any of the header matches match the upstream response headers.
   * The field is only consulted if 'retriable-headers' retry policy is active.
   */
  retriable_headers?:
    | HeaderMatcher[]
    | undefined;
  /** HTTP headers which must be present in the request for retries to be attempted. */
  retriable_request_headers?: HeaderMatcher[] | undefined;
}

export enum RetryPolicy_ResetHeaderFormat {
  SECONDS = "SECONDS",
  UNIX_TIMESTAMP = "UNIX_TIMESTAMP",
}

export function retryPolicy_ResetHeaderFormatFromJSON(object: any): RetryPolicy_ResetHeaderFormat {
  switch (object) {
    case 0:
    case "SECONDS":
      return RetryPolicy_ResetHeaderFormat.SECONDS;
    case 1:
    case "UNIX_TIMESTAMP":
      return RetryPolicy_ResetHeaderFormat.UNIX_TIMESTAMP;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RetryPolicy_ResetHeaderFormat");
  }
}

export function retryPolicy_ResetHeaderFormatToJSON(object: RetryPolicy_ResetHeaderFormat): string {
  switch (object) {
    case RetryPolicy_ResetHeaderFormat.SECONDS:
      return "SECONDS";
    case RetryPolicy_ResetHeaderFormat.UNIX_TIMESTAMP:
      return "UNIX_TIMESTAMP";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RetryPolicy_ResetHeaderFormat");
  }
}

export function retryPolicy_ResetHeaderFormatToNumber(object: RetryPolicy_ResetHeaderFormat): number {
  switch (object) {
    case RetryPolicy_ResetHeaderFormat.SECONDS:
      return 0;
    case RetryPolicy_ResetHeaderFormat.UNIX_TIMESTAMP:
      return 1;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RetryPolicy_ResetHeaderFormat");
  }
}

export interface RetryPolicy_RetryPriority {
  $type: "envoy.config.route.v3.RetryPolicy.RetryPriority";
  name?:
    | string
    | undefined;
  /** [#extension-category: envoy.retry_priorities] */
  config_type?:
    | //
    { $case: "typed_config"; typed_config: Any }
    | undefined;
}

export interface RetryPolicy_RetryHostPredicate {
  $type: "envoy.config.route.v3.RetryPolicy.RetryHostPredicate";
  name?:
    | string
    | undefined;
  /** [#extension-category: envoy.retry_host_predicates] */
  config_type?:
    | //
    { $case: "typed_config"; typed_config: Any }
    | undefined;
}

export interface RetryPolicy_RetryBackOff {
  $type: "envoy.config.route.v3.RetryPolicy.RetryBackOff";
  /**
   * Specifies the base interval between retries. This parameter is required and must be greater
   * than zero. Values less than 1 ms are rounded up to 1 ms.
   * See :ref:`config_http_filters_router_x-envoy-max-retries` for a discussion of Envoy's
   * back-off algorithm.
   */
  base_interval?:
    | Duration
    | undefined;
  /**
   * Specifies the maximum interval between retries. This parameter is optional, but must be
   * greater than or equal to the ``base_interval`` if set. The default is 10 times the
   * ``base_interval``. See :ref:`config_http_filters_router_x-envoy-max-retries` for a discussion
   * of Envoy's back-off algorithm.
   */
  max_interval?: Duration | undefined;
}

export interface RetryPolicy_ResetHeader {
  $type: "envoy.config.route.v3.RetryPolicy.ResetHeader";
  /**
   * The name of the reset header.
   *
   * .. note::
   *
   *   If the header appears multiple times only the first value is used.
   */
  name?:
    | string
    | undefined;
  /** The format of the reset header. */
  format?: RetryPolicy_ResetHeaderFormat | undefined;
}

/**
 * A retry back-off strategy that applies when the upstream server rate limits
 * the request.
 *
 * Given this configuration:
 *
 * .. code-block:: yaml
 *
 *   rate_limited_retry_back_off:
 *     reset_headers:
 *     - name: Retry-After
 *       format: SECONDS
 *     - name: X-RateLimit-Reset
 *       format: UNIX_TIMESTAMP
 *     max_interval: "300s"
 *
 * The following algorithm will apply:
 *
 *  1. If the response contains the header ``Retry-After`` its value must be on
 *     the form ``120`` (an integer that represents the number of seconds to
 *     wait before retrying). If so, this value is used as the back-off interval.
 *  2. Otherwise, if the response contains the header ``X-RateLimit-Reset`` its
 *     value must be on the form ``1595320702`` (an integer that represents the
 *     point in time at which to retry, as a Unix timestamp in seconds). If so,
 *     the current time is subtracted from this value and the result is used as
 *     the back-off interval.
 *  3. Otherwise, Envoy will use the default
 *     :ref:`exponential back-off <envoy_v3_api_field_config.route.v3.RetryPolicy.retry_back_off>`
 *     strategy.
 *
 * No matter which format is used, if the resulting back-off interval exceeds
 * ``max_interval`` it is discarded and the next header in ``reset_headers``
 * is tried. If a request timeout is configured for the route it will further
 * limit how long the request will be allowed to run.
 *
 * To prevent many clients retrying at the same point in time jitter is added
 * to the back-off interval, so the resulting interval is decided by taking:
 * ``random(interval, interval * 1.5)``.
 *
 * .. attention::
 *
 *   Configuring ``rate_limited_retry_back_off`` will not by itself cause a request
 *   to be retried. You will still need to configure the right retry policy to match
 *   the responses from the upstream server.
 */
export interface RetryPolicy_RateLimitedRetryBackOff {
  $type: "envoy.config.route.v3.RetryPolicy.RateLimitedRetryBackOff";
  /**
   * Specifies the reset headers (like ``Retry-After`` or ``X-RateLimit-Reset``)
   * to match against the response. Headers are tried in order, and matched case
   * insensitive. The first header to be parsed successfully is used. If no headers
   * match the default exponential back-off is used instead.
   */
  reset_headers?:
    | RetryPolicy_ResetHeader[]
    | undefined;
  /**
   * Specifies the maximum back off interval that Envoy will allow. If a reset
   * header contains an interval longer than this then it will be discarded and
   * the next header will be tried. Defaults to 300 seconds.
   */
  max_interval?: Duration | undefined;
}

/** HTTP request hedging :ref:`architecture overview <arch_overview_http_routing_hedging>`. */
export interface HedgePolicy {
  $type: "envoy.config.route.v3.HedgePolicy";
  /**
   * Specifies the number of initial requests that should be sent upstream.
   * Must be at least 1.
   * Defaults to 1.
   * [#not-implemented-hide:]
   */
  initial_requests?:
    | number
    | undefined;
  /**
   * Specifies a probability that an additional upstream request should be sent
   * on top of what is specified by initial_requests.
   * Defaults to 0.
   * [#not-implemented-hide:]
   */
  additional_request_chance?:
    | FractionalPercent
    | undefined;
  /**
   * Indicates that a hedged request should be sent when the per-try timeout is hit.
   * This means that a retry will be issued without resetting the original request, leaving multiple upstream requests in flight.
   * The first request to complete successfully will be the one returned to the caller.
   *
   * * At any time, a successful response (i.e. not triggering any of the retry-on conditions) would be returned to the client.
   * * Before per-try timeout, an error response (per retry-on conditions) would be retried immediately or returned ot the client
   *   if there are no more retries left.
   * * After per-try timeout, an error response would be discarded, as a retry in the form of a hedged request is already in progress.
   *
   * Note: For this to have effect, you must have a :ref:`RetryPolicy <envoy_v3_api_msg_config.route.v3.RetryPolicy>` that retries at least
   * one error code and specifies a maximum number of retries.
   *
   * Defaults to false.
   */
  hedge_on_per_try_timeout?: boolean | undefined;
}

/** [#next-free-field: 10] */
export interface RedirectAction {
  $type: "envoy.config.route.v3.RedirectAction";
  /**
   * When the scheme redirection take place, the following rules apply:
   *  1. If the source URI scheme is ``http`` and the port is explicitly
   *     set to ``:80``, the port will be removed after the redirection
   *  2. If the source URI scheme is ``https`` and the port is explicitly
   *     set to ``:443``, the port will be removed after the redirection
   */
  scheme_rewrite_specifier?:
    | //
    /** The scheme portion of the URL will be swapped with "https". */
    { $case: "https_redirect"; https_redirect: boolean }
    | //
    /** The scheme portion of the URL will be swapped with this value. */
    { $case: "scheme_redirect"; scheme_redirect: string }
    | undefined;
  /** The host portion of the URL will be swapped with this value. */
  host_redirect?:
    | string
    | undefined;
  /** The port value of the URL will be swapped with this value. */
  port_redirect?: number | undefined;
  path_rewrite_specifier?:
    | //
    /**
     * The path portion of the URL will be swapped with this value.
     * Please note that query string in path_redirect will override the
     * request's query string and will not be stripped.
     *
     * For example, let's say we have the following routes:
     *
     * - match: { path: "/old-path-1" }
     *   redirect: { path_redirect: "/new-path-1" }
     * - match: { path: "/old-path-2" }
     *   redirect: { path_redirect: "/new-path-2", strip-query: "true" }
     * - match: { path: "/old-path-3" }
     *   redirect: { path_redirect: "/new-path-3?foo=1", strip_query: "true" }
     *
     * 1. if request uri is "/old-path-1?bar=1", users will be redirected to "/new-path-1?bar=1"
     * 2. if request uri is "/old-path-2?bar=1", users will be redirected to "/new-path-2"
     * 3. if request uri is "/old-path-3?bar=1", users will be redirected to "/new-path-3?foo=1"
     */
    { $case: "path_redirect"; path_redirect: string }
    | //
    /**
     * Indicates that during redirection, the matched prefix (or path)
     * should be swapped with this value. This option allows redirect URLs be dynamically created
     * based on the request.
     *
     * .. attention::
     *
     *   Pay attention to the use of trailing slashes as mentioned in
     *   :ref:`RouteAction's prefix_rewrite <envoy_v3_api_field_config.route.v3.RouteAction.prefix_rewrite>`.
     */
    { $case: "prefix_rewrite"; prefix_rewrite: string }
    | //
    /**
     * Indicates that during redirect, portions of the path that match the
     * pattern should be rewritten, even allowing the substitution of capture
     * groups from the pattern into the new path as specified by the rewrite
     * substitution string. This is useful to allow application paths to be
     * rewritten in a way that is aware of segments with variable content like
     * identifiers.
     *
     * Examples using Google's `RE2 <https://github.com/google/re2>`_ engine:
     *
     * * The path pattern ``^/service/([^/]+)(/.*)$`` paired with a substitution
     *   string of ``\2/instance/\1`` would transform ``/service/foo/v1/api``
     *   into ``/v1/api/instance/foo``.
     *
     * * The pattern ``one`` paired with a substitution string of ``two`` would
     *   transform ``/xxx/one/yyy/one/zzz`` into ``/xxx/two/yyy/two/zzz``.
     *
     * * The pattern ``^(.*?)one(.*)$`` paired with a substitution string of
     *   ``\1two\2`` would replace only the first occurrence of ``one``,
     *   transforming path ``/xxx/one/yyy/one/zzz`` into ``/xxx/two/yyy/one/zzz``.
     *
     * * The pattern ``(?i)/xxx/`` paired with a substitution string of ``/yyy/``
     *   would do a case-insensitive match and transform path ``/aaa/XxX/bbb`` to
     *   ``/aaa/yyy/bbb``.
     */
    { $case: "regex_rewrite"; regex_rewrite: RegexMatchAndSubstitute }
    | undefined;
  /**
   * The HTTP status code to use in the redirect response. The default response
   * code is MOVED_PERMANENTLY (301).
   */
  response_code?:
    | RedirectAction_RedirectResponseCode
    | undefined;
  /**
   * Indicates that during redirection, the query portion of the URL will
   * be removed. Default value is false.
   */
  strip_query?: boolean | undefined;
}

export enum RedirectAction_RedirectResponseCode {
  /** MOVED_PERMANENTLY - Moved Permanently HTTP Status Code - 301. */
  MOVED_PERMANENTLY = "MOVED_PERMANENTLY",
  /** FOUND - Found HTTP Status Code - 302. */
  FOUND = "FOUND",
  /** SEE_OTHER - See Other HTTP Status Code - 303. */
  SEE_OTHER = "SEE_OTHER",
  /** TEMPORARY_REDIRECT - Temporary Redirect HTTP Status Code - 307. */
  TEMPORARY_REDIRECT = "TEMPORARY_REDIRECT",
  /** PERMANENT_REDIRECT - Permanent Redirect HTTP Status Code - 308. */
  PERMANENT_REDIRECT = "PERMANENT_REDIRECT",
}

export function redirectAction_RedirectResponseCodeFromJSON(object: any): RedirectAction_RedirectResponseCode {
  switch (object) {
    case 0:
    case "MOVED_PERMANENTLY":
      return RedirectAction_RedirectResponseCode.MOVED_PERMANENTLY;
    case 1:
    case "FOUND":
      return RedirectAction_RedirectResponseCode.FOUND;
    case 2:
    case "SEE_OTHER":
      return RedirectAction_RedirectResponseCode.SEE_OTHER;
    case 3:
    case "TEMPORARY_REDIRECT":
      return RedirectAction_RedirectResponseCode.TEMPORARY_REDIRECT;
    case 4:
    case "PERMANENT_REDIRECT":
      return RedirectAction_RedirectResponseCode.PERMANENT_REDIRECT;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RedirectAction_RedirectResponseCode");
  }
}

export function redirectAction_RedirectResponseCodeToJSON(object: RedirectAction_RedirectResponseCode): string {
  switch (object) {
    case RedirectAction_RedirectResponseCode.MOVED_PERMANENTLY:
      return "MOVED_PERMANENTLY";
    case RedirectAction_RedirectResponseCode.FOUND:
      return "FOUND";
    case RedirectAction_RedirectResponseCode.SEE_OTHER:
      return "SEE_OTHER";
    case RedirectAction_RedirectResponseCode.TEMPORARY_REDIRECT:
      return "TEMPORARY_REDIRECT";
    case RedirectAction_RedirectResponseCode.PERMANENT_REDIRECT:
      return "PERMANENT_REDIRECT";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RedirectAction_RedirectResponseCode");
  }
}

export function redirectAction_RedirectResponseCodeToNumber(object: RedirectAction_RedirectResponseCode): number {
  switch (object) {
    case RedirectAction_RedirectResponseCode.MOVED_PERMANENTLY:
      return 0;
    case RedirectAction_RedirectResponseCode.FOUND:
      return 1;
    case RedirectAction_RedirectResponseCode.SEE_OTHER:
      return 2;
    case RedirectAction_RedirectResponseCode.TEMPORARY_REDIRECT:
      return 3;
    case RedirectAction_RedirectResponseCode.PERMANENT_REDIRECT:
      return 4;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RedirectAction_RedirectResponseCode");
  }
}

export interface DirectResponseAction {
  $type: "envoy.config.route.v3.DirectResponseAction";
  /** Specifies the HTTP response status to be returned. */
  status?:
    | number
    | undefined;
  /**
   * Specifies the content of the response body. If this setting is omitted,
   * no body is included in the generated response.
   *
   * .. note::
   *
   *   Headers can be specified using ``response_headers_to_add`` in the enclosing
   *   :ref:`envoy_v3_api_msg_config.route.v3.Route`, :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration` or
   *   :ref:`envoy_v3_api_msg_config.route.v3.VirtualHost`.
   */
  body?: DataSource | undefined;
}

/** [#not-implemented-hide:] */
export interface NonForwardingAction {
  $type: "envoy.config.route.v3.NonForwardingAction";
}

export interface Decorator {
  $type: "envoy.config.route.v3.Decorator";
  /**
   * The operation name associated with the request matched to this route. If tracing is
   * enabled, this information will be used as the span name reported for this request.
   *
   * .. note::
   *
   *   For ingress (inbound) requests, or egress (outbound) responses, this value may be overridden
   *   by the :ref:`x-envoy-decorator-operation
   *   <config_http_filters_router_x-envoy-decorator-operation>` header.
   */
  operation?:
    | string
    | undefined;
  /** Whether the decorated details should be propagated to the other party. The default is true. */
  propagate?: boolean | undefined;
}

export interface Tracing {
  $type: "envoy.config.route.v3.Tracing";
  /**
   * Target percentage of requests managed by this HTTP connection manager that will be force
   * traced if the :ref:`x-client-trace-id <config_http_conn_man_headers_x-client-trace-id>`
   * header is set. This field is a direct analog for the runtime variable
   * 'tracing.client_enabled' in the :ref:`HTTP Connection Manager
   * <config_http_conn_man_runtime>`.
   * Default: 100%
   */
  client_sampling?:
    | FractionalPercent
    | undefined;
  /**
   * Target percentage of requests managed by this HTTP connection manager that will be randomly
   * selected for trace generation, if not requested by the client or not forced. This field is
   * a direct analog for the runtime variable 'tracing.random_sampling' in the
   * :ref:`HTTP Connection Manager <config_http_conn_man_runtime>`.
   * Default: 100%
   */
  random_sampling?:
    | FractionalPercent
    | undefined;
  /**
   * Target percentage of requests managed by this HTTP connection manager that will be traced
   * after all other sampling checks have been applied (client-directed, force tracing, random
   * sampling). This field functions as an upper limit on the total configured sampling rate. For
   * instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
   * of client requests with the appropriate headers to be force traced. This field is a direct
   * analog for the runtime variable 'tracing.global_enabled' in the
   * :ref:`HTTP Connection Manager <config_http_conn_man_runtime>`.
   * Default: 100%
   */
  overall_sampling?:
    | FractionalPercent
    | undefined;
  /**
   * A list of custom tags with unique tag name to create tags for the active span.
   * It will take effect after merging with the :ref:`corresponding configuration
   * <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.custom_tags>`
   * configured in the HTTP connection manager. If two tags with the same name are configured
   * each in the HTTP connection manager and the route level, the one configured here takes
   * priority.
   */
  custom_tags?: CustomTag[] | undefined;
}

/**
 * A virtual cluster is a way of specifying a regex matching rule against
 * certain important endpoints such that statistics are generated explicitly for
 * the matched requests. The reason this is useful is that when doing
 * prefix/path matching Envoy does not always know what the application
 * considers to be an endpoint. Thus, it’s impossible for Envoy to generically
 * emit per endpoint statistics. However, often systems have highly critical
 * endpoints that they wish to get “perfect” statistics on. Virtual cluster
 * statistics are perfect in the sense that they are emitted on the downstream
 * side such that they include network level failures.
 *
 * Documentation for :ref:`virtual cluster statistics <config_http_filters_router_vcluster_stats>`.
 *
 * .. note::
 *
 *    Virtual clusters are a useful tool, but we do not recommend setting up a virtual cluster for
 *    every application endpoint. This is both not easily maintainable and as well the matching and
 *    statistics output are not free.
 */
export interface VirtualCluster {
  $type: "envoy.config.route.v3.VirtualCluster";
  /**
   * Specifies a list of header matchers to use for matching requests. Each specified header must
   * match. The pseudo-headers ``:path`` and ``:method`` can be used to match the request path and
   * method, respectively.
   */
  headers?:
    | HeaderMatcher[]
    | undefined;
  /**
   * Specifies the name of the virtual cluster. The virtual cluster name as well
   * as the virtual host name are used when emitting statistics. The statistics are emitted by the
   * router filter and are documented :ref:`here <config_http_filters_router_stats>`.
   */
  name?: string | undefined;
}

/**
 * Global rate limiting :ref:`architecture overview <arch_overview_global_rate_limit>`.
 * Also applies to Local rate limiting :ref:`using descriptors <config_http_filters_local_rate_limit_descriptors>`.
 */
export interface RateLimit {
  $type: "envoy.config.route.v3.RateLimit";
  /**
   * Refers to the stage set in the filter. The rate limit configuration only
   * applies to filters with the same stage number. The default stage number is
   * 0.
   *
   * .. note::
   *
   *   The filter supports a range of 0 - 10 inclusively for stage numbers.
   */
  stage?:
    | number
    | undefined;
  /** The key to be set in runtime to disable this rate limit configuration. */
  disable_key?:
    | string
    | undefined;
  /**
   * A list of actions that are to be applied for this rate limit configuration.
   * Order matters as the actions are processed sequentially and the descriptor
   * is composed by appending descriptor entries in that sequence. If an action
   * cannot append a descriptor entry, no descriptor is generated for the
   * configuration. See :ref:`composing actions
   * <config_http_filters_rate_limit_composing_actions>` for additional documentation.
   */
  actions?:
    | RateLimit_Action[]
    | undefined;
  /**
   * An optional limit override to be appended to the descriptor produced by this
   * rate limit configuration. If the override value is invalid or cannot be resolved
   * from metadata, no override is provided. See :ref:`rate limit override
   * <config_http_filters_rate_limit_rate_limit_override>` for more information.
   */
  limit?: RateLimit_Override | undefined;
}

/** [#next-free-field: 12] */
export interface RateLimit_Action {
  $type: "envoy.config.route.v3.RateLimit.Action";
  action_specifier?:
    | //
    /** Rate limit on source cluster. */
    { $case: "source_cluster"; source_cluster: RateLimit_Action_SourceCluster }
    | //
    /** Rate limit on destination cluster. */
    { $case: "destination_cluster"; destination_cluster: RateLimit_Action_DestinationCluster }
    | //
    /** Rate limit on request headers. */
    { $case: "request_headers"; request_headers: RateLimit_Action_RequestHeaders }
    | //
    /** Rate limit on remote address. */
    { $case: "remote_address"; remote_address: RateLimit_Action_RemoteAddress }
    | //
    /** Rate limit on a generic key. */
    { $case: "generic_key"; generic_key: RateLimit_Action_GenericKey }
    | //
    /** Rate limit on the existence of request headers. */
    { $case: "header_value_match"; header_value_match: RateLimit_Action_HeaderValueMatch }
    | //
    /**
     * Rate limit on dynamic metadata.
     *
     * .. attention::
     *   This field has been deprecated in favor of the :ref:`metadata <envoy_v3_api_field_config.route.v3.RateLimit.Action.metadata>` field
     */
    { $case: "dynamic_metadata"; dynamic_metadata: RateLimit_Action_DynamicMetaData }
    | //
    /** Rate limit on metadata. */
    { $case: "metadata"; metadata: RateLimit_Action_MetaData }
    | //
    /**
     * Rate limit descriptor extension. See the rate limit descriptor extensions documentation.
     *
     * :ref:`HTTP matching input functions <arch_overview_matching_api>` are
     * permitted as descriptor extensions. The input functions are only
     * looked up if there is no rate limit descriptor extension matching
     * the type URL.
     *
     * [#extension-category: envoy.rate_limit_descriptors]
     */
    { $case: "extension"; extension: TypedExtensionConfig }
    | //
    /** Rate limit on masked remote address. */
    { $case: "masked_remote_address"; masked_remote_address: RateLimit_Action_MaskedRemoteAddress }
    | //
    /** Rate limit on the existence of query parameters. */
    { $case: "query_parameter_value_match"; query_parameter_value_match: RateLimit_Action_QueryParameterValueMatch }
    | undefined;
}

/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("source_cluster", "<local service cluster>")
 *
 * <local service cluster> is derived from the :option:`--service-cluster` option.
 */
export interface RateLimit_Action_SourceCluster {
  $type: "envoy.config.route.v3.RateLimit.Action.SourceCluster";
}

/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("destination_cluster", "<routed target cluster>")
 *
 * Once a request matches against a route table rule, a routed cluster is determined by one of
 * the following :ref:`route table configuration <envoy_v3_api_msg_config.route.v3.RouteConfiguration>`
 * settings:
 *
 * * :ref:`cluster <envoy_v3_api_field_config.route.v3.RouteAction.cluster>` indicates the upstream cluster
 *   to route to.
 * * :ref:`weighted_clusters <envoy_v3_api_field_config.route.v3.RouteAction.weighted_clusters>`
 *   chooses a cluster randomly from a set of clusters with attributed weight.
 * * :ref:`cluster_header <envoy_v3_api_field_config.route.v3.RouteAction.cluster_header>` indicates which
 *   header in the request contains the target cluster.
 */
export interface RateLimit_Action_DestinationCluster {
  $type: "envoy.config.route.v3.RateLimit.Action.DestinationCluster";
}

/**
 * The following descriptor entry is appended when a header contains a key that matches the
 * ``header_name``:
 *
 * .. code-block:: cpp
 *
 *   ("<descriptor_key>", "<header_value_queried_from_header>")
 */
export interface RateLimit_Action_RequestHeaders {
  $type: "envoy.config.route.v3.RateLimit.Action.RequestHeaders";
  /**
   * The header name to be queried from the request headers. The header’s
   * value is used to populate the value of the descriptor entry for the
   * descriptor_key.
   */
  header_name?:
    | string
    | undefined;
  /** The key to use in the descriptor entry. */
  descriptor_key?:
    | string
    | undefined;
  /**
   * If set to true, Envoy skips the descriptor while calling rate limiting service
   * when header is not present in the request. By default it skips calling the
   * rate limiting service if this header is not present in the request.
   */
  skip_if_absent?: boolean | undefined;
}

/**
 * The following descriptor entry is appended to the descriptor and is populated using the
 * trusted address from :ref:`x-forwarded-for <config_http_conn_man_headers_x-forwarded-for>`:
 *
 * .. code-block:: cpp
 *
 *   ("remote_address", "<trusted address from x-forwarded-for>")
 */
export interface RateLimit_Action_RemoteAddress {
  $type: "envoy.config.route.v3.RateLimit.Action.RemoteAddress";
}

/**
 * The following descriptor entry is appended to the descriptor and is populated using the
 * masked address from :ref:`x-forwarded-for <config_http_conn_man_headers_x-forwarded-for>`:
 *
 * .. code-block:: cpp
 *
 *   ("masked_remote_address", "<masked address from x-forwarded-for>")
 */
export interface RateLimit_Action_MaskedRemoteAddress {
  $type: "envoy.config.route.v3.RateLimit.Action.MaskedRemoteAddress";
  /**
   * Length of prefix mask len for IPv4 (e.g. 0, 32).
   * Defaults to 32 when unset.
   * For example, trusted address from x-forwarded-for is ``192.168.1.1``,
   * the descriptor entry is ("masked_remote_address", "192.168.1.1/32");
   * if mask len is 24, the descriptor entry is ("masked_remote_address", "192.168.1.0/24").
   */
  v4_prefix_mask_len?:
    | number
    | undefined;
  /**
   * Length of prefix mask len for IPv6 (e.g. 0, 128).
   * Defaults to 128 when unset.
   * For example, trusted address from x-forwarded-for is ``2001:abcd:ef01:2345:6789:abcd:ef01:234``,
   * the descriptor entry is ("masked_remote_address", "2001:abcd:ef01:2345:6789:abcd:ef01:234/128");
   * if mask len is 64, the descriptor entry is ("masked_remote_address", "2001:abcd:ef01:2345::/64").
   */
  v6_prefix_mask_len?: number | undefined;
}

/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("generic_key", "<descriptor_value>")
 */
export interface RateLimit_Action_GenericKey {
  $type: "envoy.config.route.v3.RateLimit.Action.GenericKey";
  /** The value to use in the descriptor entry. */
  descriptor_value?:
    | string
    | undefined;
  /**
   * An optional key to use in the descriptor entry. If not set it defaults
   * to 'generic_key' as the descriptor key.
   */
  descriptor_key?: string | undefined;
}

/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("header_match", "<descriptor_value>")
 */
export interface RateLimit_Action_HeaderValueMatch {
  $type: "envoy.config.route.v3.RateLimit.Action.HeaderValueMatch";
  /** The key to use in the descriptor entry. Defaults to ``header_match``. */
  descriptor_key?:
    | string
    | undefined;
  /** The value to use in the descriptor entry. */
  descriptor_value?:
    | string
    | undefined;
  /**
   * If set to true, the action will append a descriptor entry when the
   * request matches the headers. If set to false, the action will append a
   * descriptor entry when the request does not match the headers. The
   * default value is true.
   */
  expect_match?:
    | boolean
    | undefined;
  /**
   * Specifies a set of headers that the rate limit action should match
   * on. The action will check the request’s headers against all the
   * specified headers in the config. A match will happen if all the
   * headers in the config are present in the request with the same values
   * (or based on presence if the value field is not in the config).
   */
  headers?: HeaderMatcher[] | undefined;
}

/**
 * The following descriptor entry is appended when the
 * :ref:`dynamic metadata <well_known_dynamic_metadata>` contains a key value:
 *
 * .. code-block:: cpp
 *
 *   ("<descriptor_key>", "<value_queried_from_dynamic_metadata>")
 *
 * .. attention::
 *   This action has been deprecated in favor of the :ref:`metadata <envoy_v3_api_msg_config.route.v3.RateLimit.Action.MetaData>` action
 */
export interface RateLimit_Action_DynamicMetaData {
  $type: "envoy.config.route.v3.RateLimit.Action.DynamicMetaData";
  /** The key to use in the descriptor entry. */
  descriptor_key?:
    | string
    | undefined;
  /**
   * Metadata struct that defines the key and path to retrieve the string value. A match will
   * only happen if the value in the dynamic metadata is of type string.
   */
  metadata_key?:
    | MetadataKey
    | undefined;
  /**
   * An optional value to use if ``metadata_key`` is empty. If not set and
   * no value is present under the metadata_key then no descriptor is generated.
   */
  default_value?: string | undefined;
}

/**
 * The following descriptor entry is appended when the metadata contains a key value:
 *
 * .. code-block:: cpp
 *
 *   ("<descriptor_key>", "<value_queried_from_metadata>")
 * [#next-free-field: 6]
 */
export interface RateLimit_Action_MetaData {
  $type: "envoy.config.route.v3.RateLimit.Action.MetaData";
  /** The key to use in the descriptor entry. */
  descriptor_key?:
    | string
    | undefined;
  /**
   * Metadata struct that defines the key and path to retrieve the string value. A match will
   * only happen if the value in the metadata is of type string.
   */
  metadata_key?:
    | MetadataKey
    | undefined;
  /**
   * An optional value to use if ``metadata_key`` is empty. If not set and
   * no value is present under the metadata_key then ``skip_if_absent`` is followed to
   * skip calling the rate limiting service or skip the descriptor.
   */
  default_value?:
    | string
    | undefined;
  /** Source of metadata */
  source?:
    | RateLimit_Action_MetaData_Source
    | undefined;
  /**
   * If set to true, Envoy skips the descriptor while calling rate limiting service
   * when ``metadata_key`` is empty and ``default_value`` is not set. By default it skips calling the
   * rate limiting service in that case.
   */
  skip_if_absent?: boolean | undefined;
}

export enum RateLimit_Action_MetaData_Source {
  /** DYNAMIC - Query :ref:`dynamic metadata <well_known_dynamic_metadata>` */
  DYNAMIC = "DYNAMIC",
  /** ROUTE_ENTRY - Query :ref:`route entry metadata <envoy_v3_api_field_config.route.v3.Route.metadata>` */
  ROUTE_ENTRY = "ROUTE_ENTRY",
}

export function rateLimit_Action_MetaData_SourceFromJSON(object: any): RateLimit_Action_MetaData_Source {
  switch (object) {
    case 0:
    case "DYNAMIC":
      return RateLimit_Action_MetaData_Source.DYNAMIC;
    case 1:
    case "ROUTE_ENTRY":
      return RateLimit_Action_MetaData_Source.ROUTE_ENTRY;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RateLimit_Action_MetaData_Source");
  }
}

export function rateLimit_Action_MetaData_SourceToJSON(object: RateLimit_Action_MetaData_Source): string {
  switch (object) {
    case RateLimit_Action_MetaData_Source.DYNAMIC:
      return "DYNAMIC";
    case RateLimit_Action_MetaData_Source.ROUTE_ENTRY:
      return "ROUTE_ENTRY";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RateLimit_Action_MetaData_Source");
  }
}

export function rateLimit_Action_MetaData_SourceToNumber(object: RateLimit_Action_MetaData_Source): number {
  switch (object) {
    case RateLimit_Action_MetaData_Source.DYNAMIC:
      return 0;
    case RateLimit_Action_MetaData_Source.ROUTE_ENTRY:
      return 1;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RateLimit_Action_MetaData_Source");
  }
}

/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("query_match", "<descriptor_value>")
 */
export interface RateLimit_Action_QueryParameterValueMatch {
  $type: "envoy.config.route.v3.RateLimit.Action.QueryParameterValueMatch";
  /** The key to use in the descriptor entry. Defaults to ``query_match``. */
  descriptor_key?:
    | string
    | undefined;
  /** The value to use in the descriptor entry. */
  descriptor_value?:
    | string
    | undefined;
  /**
   * If set to true, the action will append a descriptor entry when the
   * request matches the headers. If set to false, the action will append a
   * descriptor entry when the request does not match the headers. The
   * default value is true.
   */
  expect_match?:
    | boolean
    | undefined;
  /**
   * Specifies a set of query parameters that the rate limit action should match
   * on. The action will check the request’s query parameters against all the
   * specified query parameters in the config. A match will happen if all the
   * query parameters in the config are present in the request with the same values
   * (or based on presence if the value field is not in the config).
   */
  query_parameters?: QueryParameterMatcher[] | undefined;
}

export interface RateLimit_Override {
  $type: "envoy.config.route.v3.RateLimit.Override";
  override_specifier?:
    | //
    /** Limit override from dynamic metadata. */
    { $case: "dynamic_metadata"; dynamic_metadata: RateLimit_Override_DynamicMetadata }
    | undefined;
}

/** Fetches the override from the dynamic metadata. */
export interface RateLimit_Override_DynamicMetadata {
  $type: "envoy.config.route.v3.RateLimit.Override.DynamicMetadata";
  /**
   * Metadata struct that defines the key and path to retrieve the struct value.
   * The value must be a struct containing an integer "requests_per_unit" property
   * and a "unit" property with a value parseable to :ref:`RateLimitUnit
   * enum <envoy_v3_api_enum_type.v3.RateLimitUnit>`
   */
  metadata_key?: MetadataKey | undefined;
}

/**
 * .. attention::
 *
 *   Internally, Envoy always uses the HTTP/2 ``:authority`` header to represent the HTTP/1 ``Host``
 *   header. Thus, if attempting to match on ``Host``, match on ``:authority`` instead.
 *
 * .. attention::
 *
 *   To route on HTTP method, use the special HTTP/2 ``:method`` header. This works for both
 *   HTTP/1 and HTTP/2 as Envoy normalizes headers. E.g.,
 *
 *   .. code-block:: json
 *
 *     {
 *       "name": ":method",
 *       "string_match": {
 *         "exact": "POST"
 *       }
 *     }
 *
 * .. attention::
 *   In the absence of any header match specifier, match will default to :ref:`present_match
 *   <envoy_v3_api_field_config.route.v3.HeaderMatcher.present_match>`. i.e, a request that has the :ref:`name
 *   <envoy_v3_api_field_config.route.v3.HeaderMatcher.name>` header will match, regardless of the header's
 *   value.
 *
 *  [#next-major-version: HeaderMatcher should be refactored to use StringMatcher.]
 * [#next-free-field: 15]
 */
export interface HeaderMatcher {
  $type: "envoy.config.route.v3.HeaderMatcher";
  /** Specifies the name of the header in the request. */
  name?:
    | string
    | undefined;
  /** Specifies how the header match will be performed to route the request. */
  header_match_specifier?:
    | //
    /**
     * If specified, header match will be performed based on the value of the header.
     * This field is deprecated. Please use :ref:`string_match <envoy_v3_api_field_config.route.v3.HeaderMatcher.string_match>`.
     */
    { $case: "exact_match"; exact_match: string }
    | //
    /**
     * If specified, this regex string is a regular expression rule which implies the entire request
     * header value must match the regex. The rule will not match if only a subsequence of the
     * request header value matches the regex.
     * This field is deprecated. Please use :ref:`string_match <envoy_v3_api_field_config.route.v3.HeaderMatcher.string_match>`.
     */
    { $case: "safe_regex_match"; safe_regex_match: RegexMatcher }
    | //
    /**
     * If specified, header match will be performed based on range.
     * The rule will match if the request header value is within this range.
     * The entire request header value must represent an integer in base 10 notation: consisting of
     * an optional plus or minus sign followed by a sequence of digits. The rule will not match if
     * the header value does not represent an integer. Match will fail for empty values, floating
     * point numbers or if only a subsequence of the header value is an integer.
     *
     * Examples:
     *
     * * For range [-10,0), route will match for header value -1, but not for 0, ``somestring``, 10.9,
     *   ``-1somestring``
     */
    { $case: "range_match"; range_match: Int64Range }
    | //
    /**
     * If specified as true, header match will be performed based on whether the header is in the
     * request. If specified as false, header match will be performed based on whether the header is absent.
     */
    { $case: "present_match"; present_match: boolean }
    | //
    /**
     * If specified, header match will be performed based on the prefix of the header value.
     * Note: empty prefix is not allowed, please use present_match instead.
     * This field is deprecated. Please use :ref:`string_match <envoy_v3_api_field_config.route.v3.HeaderMatcher.string_match>`.
     *
     * Examples:
     *
     * * The prefix ``abcd`` matches the value ``abcdxyz``, but not for ``abcxyz``.
     */
    { $case: "prefix_match"; prefix_match: string }
    | //
    /**
     * If specified, header match will be performed based on the suffix of the header value.
     * Note: empty suffix is not allowed, please use present_match instead.
     * This field is deprecated. Please use :ref:`string_match <envoy_v3_api_field_config.route.v3.HeaderMatcher.string_match>`.
     *
     * Examples:
     *
     * * The suffix ``abcd`` matches the value ``xyzabcd``, but not for ``xyzbcd``.
     */
    { $case: "suffix_match"; suffix_match: string }
    | //
    /**
     * If specified, header match will be performed based on whether the header value contains
     * the given value or not.
     * Note: empty contains match is not allowed, please use present_match instead.
     * This field is deprecated. Please use :ref:`string_match <envoy_v3_api_field_config.route.v3.HeaderMatcher.string_match>`.
     *
     * Examples:
     *
     * * The value ``abcd`` matches the value ``xyzabcdpqr``, but not for ``xyzbcdpqr``.
     */
    { $case: "contains_match"; contains_match: string }
    | //
    /** If specified, header match will be performed based on the string match of the header value. */
    { $case: "string_match"; string_match: StringMatcher }
    | undefined;
  /**
   * If specified, the match result will be inverted before checking. Defaults to false.
   *
   * Examples:
   *
   * * The regex ``\d{3}`` does not match the value ``1234``, so it will match when inverted.
   * * The range [-10,0) will match the value -1, so it will not match when inverted.
   */
  invert_match?:
    | boolean
    | undefined;
  /**
   * If specified, for any header match rule, if the header match rule specified header
   * does not exist, this header value will be treated as empty. Defaults to false.
   *
   * Examples:
   *
   * * The header match rule specified header "header1" to range match of [0, 10],
   *   :ref:`invert_match <envoy_v3_api_field_config.route.v3.HeaderMatcher.invert_match>`
   *   is set to true and :ref:`treat_missing_header_as_empty <envoy_v3_api_field_config.route.v3.HeaderMatcher.treat_missing_header_as_empty>`
   *   is set to true; The "header1" header is not present. The match rule will
   *   treat the "header1" as an empty header. The empty header does not match the range,
   *   so it will match when inverted.
   * * The header match rule specified header "header2" to range match of [0, 10],
   *   :ref:`invert_match <envoy_v3_api_field_config.route.v3.HeaderMatcher.invert_match>`
   *   is set to true and :ref:`treat_missing_header_as_empty <envoy_v3_api_field_config.route.v3.HeaderMatcher.treat_missing_header_as_empty>`
   *   is set to false; The "header2" header is not present and the header
   *   matcher rule for "header2" will be ignored so it will not match.
   * * The header match rule specified header "header3" to a string regex match
   *   ``^$`` which means an empty string, and
   *   :ref:`treat_missing_header_as_empty <envoy_v3_api_field_config.route.v3.HeaderMatcher.treat_missing_header_as_empty>`
   *   is set to true; The "header3" header is not present.
   *   The match rule will treat the "header3" header as an empty header so it will match.
   * * The header match rule specified header "header4" to a string regex match
   *   ``^$`` which means an empty string, and
   *   :ref:`treat_missing_header_as_empty <envoy_v3_api_field_config.route.v3.HeaderMatcher.treat_missing_header_as_empty>`
   *   is set to false; The "header4" header is not present.
   *   The match rule for "header4" will be ignored so it will not match.
   */
  treat_missing_header_as_empty?: boolean | undefined;
}

/**
 * Query parameter matching treats the query string of a request's :path header
 * as an ampersand-separated list of keys and/or key=value elements.
 * [#next-free-field: 7]
 */
export interface QueryParameterMatcher {
  $type: "envoy.config.route.v3.QueryParameterMatcher";
  /**
   * Specifies the name of a key that must be present in the requested
   * ``path``'s query string.
   */
  name?: string | undefined;
  query_parameter_match_specifier?:
    | //
    /** Specifies whether a query parameter value should match against a string. */
    { $case: "string_match"; string_match: StringMatcher }
    | //
    /** Specifies whether a query parameter should be present. */
    { $case: "present_match"; present_match: boolean }
    | undefined;
}

/**
 * HTTP Internal Redirect :ref:`architecture overview <arch_overview_internal_redirects>`.
 * [#next-free-field: 6]
 */
export interface InternalRedirectPolicy {
  $type: "envoy.config.route.v3.InternalRedirectPolicy";
  /**
   * An internal redirect is not handled, unless the number of previous internal redirects that a
   * downstream request has encountered is lower than this value.
   * In the case where a downstream request is bounced among multiple routes by internal redirect,
   * the first route that hits this threshold, or does not set :ref:`internal_redirect_policy
   * <envoy_v3_api_field_config.route.v3.RouteAction.internal_redirect_policy>`
   * will pass the redirect back to downstream.
   *
   * If not specified, at most one redirect will be followed.
   */
  max_internal_redirects?:
    | number
    | undefined;
  /**
   * Defines what upstream response codes are allowed to trigger internal redirect. If unspecified,
   * only 302 will be treated as internal redirect.
   * Only 301, 302, 303, 307 and 308 are valid values. Any other codes will be ignored.
   */
  redirect_response_codes?:
    | number[]
    | undefined;
  /**
   * Specifies a list of predicates that are queried when an upstream response is deemed
   * to trigger an internal redirect by all other criteria. Any predicate in the list can reject
   * the redirect, causing the response to be proxied to downstream.
   * [#extension-category: envoy.internal_redirect_predicates]
   */
  predicates?:
    | TypedExtensionConfig[]
    | undefined;
  /**
   * Allow internal redirect to follow a target URI with a different scheme than the value of
   * x-forwarded-proto. The default is false.
   */
  allow_cross_scheme_redirect?:
    | boolean
    | undefined;
  /**
   * Specifies a list of headers, by name, to copy from the internal redirect into the subsequent
   * request. If a header is specified here but not present in the redirect, it will be cleared in
   * the subsequent request.
   */
  response_headers_to_copy?: string[] | undefined;
}

/**
 * A simple wrapper for an HTTP filter config. This is intended to be used as a wrapper for the
 * map value in
 * :ref:`VirtualHost.typed_per_filter_config<envoy_v3_api_field_config.route.v3.VirtualHost.typed_per_filter_config>`,
 * :ref:`Route.typed_per_filter_config<envoy_v3_api_field_config.route.v3.Route.typed_per_filter_config>`,
 * or :ref:`WeightedCluster.ClusterWeight.typed_per_filter_config<envoy_v3_api_field_config.route.v3.WeightedCluster.ClusterWeight.typed_per_filter_config>`
 * to add additional flags to the filter.
 */
export interface FilterConfig {
  $type: "envoy.config.route.v3.FilterConfig";
  /** The filter config. */
  config?:
    | Any
    | undefined;
  /**
   * If true, the filter is optional, meaning that if the client does
   * not support the specified filter, it may ignore the map entry rather
   * than rejecting the config.
   */
  is_optional?:
    | boolean
    | undefined;
  /**
   * If true, the filter is disabled in the route or virtual host and the ``config`` field is ignored.
   * See :ref:`route based filter chain <arch_overview_http_filters_route_based_filter_chain>`
   * for more details.
   *
   * .. note::
   *
   *   This field will take effect when the request arrive and filter chain is created for the request.
   *   If initial route is selected for the request and a filter is disabled in the initial route, then
   *   the filter will not be added to the filter chain.
   *   And if the request is mutated later and re-match to another route, the disabled filter by the
   *   initial route will not be added back to the filter chain because the filter chain is already
   *   created and it is too late to change the chain.
   *
   *   This field only make sense for the downstream HTTP filters for now.
   */
  disabled?: boolean | undefined;
}

function createBaseVirtualHost(): VirtualHost {
  return { $type: "envoy.config.route.v3.VirtualHost" };
}

export const VirtualHost: MessageFns<VirtualHost, "envoy.config.route.v3.VirtualHost"> = {
  $type: "envoy.config.route.v3.VirtualHost" as const,

  encode(message: VirtualHost, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.domains !== undefined && message.domains.length !== 0) {
      for (const v of message.domains) {
        writer.uint32(18).string(v!);
      }
    }
    if (message.routes !== undefined && message.routes.length !== 0) {
      for (const v of message.routes) {
        Route.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    if (message.matcher !== undefined) {
      Matcher.encode(message.matcher, writer.uint32(170).fork()).join();
    }
    if (message.require_tls !== undefined && message.require_tls !== VirtualHost_TlsRequirementType.NONE) {
      writer.uint32(32).int32(virtualHost_TlsRequirementTypeToNumber(message.require_tls));
    }
    if (message.virtual_clusters !== undefined && message.virtual_clusters.length !== 0) {
      for (const v of message.virtual_clusters) {
        VirtualCluster.encode(v!, writer.uint32(42).fork()).join();
      }
    }
    if (message.rate_limits !== undefined && message.rate_limits.length !== 0) {
      for (const v of message.rate_limits) {
        RateLimit.encode(v!, writer.uint32(50).fork()).join();
      }
    }
    if (message.request_headers_to_add !== undefined && message.request_headers_to_add.length !== 0) {
      for (const v of message.request_headers_to_add) {
        HeaderValueOption.encode(v!, writer.uint32(58).fork()).join();
      }
    }
    if (message.request_headers_to_remove !== undefined && message.request_headers_to_remove.length !== 0) {
      for (const v of message.request_headers_to_remove) {
        writer.uint32(106).string(v!);
      }
    }
    if (message.response_headers_to_add !== undefined && message.response_headers_to_add.length !== 0) {
      for (const v of message.response_headers_to_add) {
        HeaderValueOption.encode(v!, writer.uint32(82).fork()).join();
      }
    }
    if (message.response_headers_to_remove !== undefined && message.response_headers_to_remove.length !== 0) {
      for (const v of message.response_headers_to_remove) {
        writer.uint32(90).string(v!);
      }
    }
    if (message.cors !== undefined) {
      CorsPolicy.encode(message.cors, writer.uint32(66).fork()).join();
    }
    (message.typed_per_filter_config || new Map()).forEach((value, key) => {
      VirtualHost_TypedPerFilterConfigEntry.encode({
        $type: "envoy.config.route.v3.VirtualHost.TypedPerFilterConfigEntry",
        key: key as any,
        value,
      }, writer.uint32(122).fork()).join();
    });
    if (message.include_request_attempt_count !== undefined && message.include_request_attempt_count !== false) {
      writer.uint32(112).bool(message.include_request_attempt_count);
    }
    if (
      message.include_attempt_count_in_response !== undefined && message.include_attempt_count_in_response !== false
    ) {
      writer.uint32(152).bool(message.include_attempt_count_in_response);
    }
    if (message.retry_policy !== undefined) {
      RetryPolicy.encode(message.retry_policy, writer.uint32(130).fork()).join();
    }
    if (message.retry_policy_typed_config !== undefined) {
      Any.encode(message.retry_policy_typed_config, writer.uint32(162).fork()).join();
    }
    if (message.hedge_policy !== undefined) {
      HedgePolicy.encode(message.hedge_policy, writer.uint32(138).fork()).join();
    }
    if (message.include_is_timeout_retry_header !== undefined && message.include_is_timeout_retry_header !== false) {
      writer.uint32(184).bool(message.include_is_timeout_retry_header);
    }
    if (message.per_request_buffer_limit_bytes !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.per_request_buffer_limit_bytes! },
        writer.uint32(146).fork(),
      ).join();
    }
    if (message.request_mirror_policies !== undefined && message.request_mirror_policies.length !== 0) {
      for (const v of message.request_mirror_policies) {
        RouteAction_RequestMirrorPolicy.encode(v!, writer.uint32(178).fork()).join();
      }
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(194).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VirtualHost {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVirtualHost();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.domains === undefined) {
            message.domains = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.domains!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.routes === undefined) {
            message.routes = [];
          }
          const el = Route.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.routes!.push(el);
          }
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.matcher = Matcher.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.require_tls = virtualHost_TlsRequirementTypeFromJSON(reader.int32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          if (message.virtual_clusters === undefined) {
            message.virtual_clusters = [];
          }
          const el = VirtualCluster.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.virtual_clusters!.push(el);
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          if (message.rate_limits === undefined) {
            message.rate_limits = [];
          }
          const el = RateLimit.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.rate_limits!.push(el);
          }
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          if (message.request_headers_to_add === undefined) {
            message.request_headers_to_add = [];
          }
          const el = HeaderValueOption.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.request_headers_to_add!.push(el);
          }
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          if (message.request_headers_to_remove === undefined) {
            message.request_headers_to_remove = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.request_headers_to_remove!.push(el);
          }
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          if (message.response_headers_to_add === undefined) {
            message.response_headers_to_add = [];
          }
          const el = HeaderValueOption.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.response_headers_to_add!.push(el);
          }
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          if (message.response_headers_to_remove === undefined) {
            message.response_headers_to_remove = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.response_headers_to_remove!.push(el);
          }
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.cors = CorsPolicy.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          const entry15 = VirtualHost_TypedPerFilterConfigEntry.decode(reader, reader.uint32());
          if (entry15.value !== undefined) {
            if (message.typed_per_filter_config === undefined) {
              message.typed_per_filter_config = new Map();
            }
            message.typed_per_filter_config!.set(entry15.key, entry15.value);
          }
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.include_request_attempt_count = reader.bool();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.include_attempt_count_in_response = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.retry_policy = RetryPolicy.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.retry_policy_typed_config = Any.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.hedge_policy = HedgePolicy.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }

          message.include_is_timeout_retry_header = reader.bool();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.per_request_buffer_limit_bytes = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          if (message.request_mirror_policies === undefined) {
            message.request_mirror_policies = [];
          }
          const el = RouteAction_RequestMirrorPolicy.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.request_mirror_policies!.push(el);
          }
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VirtualHost {
    return {
      $type: VirtualHost.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      domains: globalThis.Array.isArray(object?.domains)
        ? object.domains.map((e: any) => globalThis.String(e))
        : undefined,
      routes: globalThis.Array.isArray(object?.routes) ? object.routes.map((e: any) => Route.fromJSON(e)) : undefined,
      matcher: isSet(object.matcher) ? Matcher.fromJSON(object.matcher) : undefined,
      require_tls: isSet(object.require_tls) ? virtualHost_TlsRequirementTypeFromJSON(object.require_tls) : undefined,
      virtual_clusters: globalThis.Array.isArray(object?.virtual_clusters)
        ? object.virtual_clusters.map((e: any) => VirtualCluster.fromJSON(e))
        : undefined,
      rate_limits: globalThis.Array.isArray(object?.rate_limits)
        ? object.rate_limits.map((e: any) => RateLimit.fromJSON(e))
        : undefined,
      request_headers_to_add: globalThis.Array.isArray(object?.request_headers_to_add)
        ? object.request_headers_to_add.map((e: any) => HeaderValueOption.fromJSON(e))
        : undefined,
      request_headers_to_remove: globalThis.Array.isArray(object?.request_headers_to_remove)
        ? object.request_headers_to_remove.map((e: any) => globalThis.String(e))
        : undefined,
      response_headers_to_add: globalThis.Array.isArray(object?.response_headers_to_add)
        ? object.response_headers_to_add.map((e: any) => HeaderValueOption.fromJSON(e))
        : undefined,
      response_headers_to_remove: globalThis.Array.isArray(object?.response_headers_to_remove)
        ? object.response_headers_to_remove.map((e: any) => globalThis.String(e))
        : undefined,
      cors: isSet(object.cors) ? CorsPolicy.fromJSON(object.cors) : undefined,
      typed_per_filter_config: isObject(object.typed_per_filter_config)
        ? Object.entries(object.typed_per_filter_config).reduce<Map<string, Any>>((acc, [key, value]) => {
          acc.set(key, Any.fromJSON(value));
          return acc;
        }, new Map())
        : undefined,
      include_request_attempt_count: isSet(object.include_request_attempt_count)
        ? globalThis.Boolean(object.include_request_attempt_count)
        : undefined,
      include_attempt_count_in_response: isSet(object.include_attempt_count_in_response)
        ? globalThis.Boolean(object.include_attempt_count_in_response)
        : undefined,
      retry_policy: isSet(object.retry_policy) ? RetryPolicy.fromJSON(object.retry_policy) : undefined,
      retry_policy_typed_config: isSet(object.retry_policy_typed_config)
        ? Any.fromJSON(object.retry_policy_typed_config)
        : undefined,
      hedge_policy: isSet(object.hedge_policy) ? HedgePolicy.fromJSON(object.hedge_policy) : undefined,
      include_is_timeout_retry_header: isSet(object.include_is_timeout_retry_header)
        ? globalThis.Boolean(object.include_is_timeout_retry_header)
        : undefined,
      per_request_buffer_limit_bytes: isSet(object.per_request_buffer_limit_bytes)
        ? Number(object.per_request_buffer_limit_bytes)
        : undefined,
      request_mirror_policies: globalThis.Array.isArray(object?.request_mirror_policies)
        ? object.request_mirror_policies.map((e: any) => RouteAction_RequestMirrorPolicy.fromJSON(e))
        : undefined,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: VirtualHost): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.domains?.length) {
      obj.domains = message.domains;
    }
    if (message.routes?.length) {
      obj.routes = message.routes.map((e) => Route.toJSON(e));
    }
    if (message.matcher !== undefined) {
      obj.matcher = Matcher.toJSON(message.matcher);
    }
    if (message.require_tls !== undefined) {
      obj.require_tls = virtualHost_TlsRequirementTypeToJSON(message.require_tls);
    }
    if (message.virtual_clusters?.length) {
      obj.virtual_clusters = message.virtual_clusters.map((e) => VirtualCluster.toJSON(e));
    }
    if (message.rate_limits?.length) {
      obj.rate_limits = message.rate_limits.map((e) => RateLimit.toJSON(e));
    }
    if (message.request_headers_to_add?.length) {
      obj.request_headers_to_add = message.request_headers_to_add.map((e) => HeaderValueOption.toJSON(e));
    }
    if (message.request_headers_to_remove?.length) {
      obj.request_headers_to_remove = message.request_headers_to_remove;
    }
    if (message.response_headers_to_add?.length) {
      obj.response_headers_to_add = message.response_headers_to_add.map((e) => HeaderValueOption.toJSON(e));
    }
    if (message.response_headers_to_remove?.length) {
      obj.response_headers_to_remove = message.response_headers_to_remove;
    }
    if (message.cors !== undefined) {
      obj.cors = CorsPolicy.toJSON(message.cors);
    }
    if (message.typed_per_filter_config?.size) {
      obj.typed_per_filter_config = {};
      message.typed_per_filter_config.forEach((v, k) => {
        obj.typed_per_filter_config[k] = Any.toJSON(v);
      });
    }
    if (message.include_request_attempt_count !== undefined) {
      obj.include_request_attempt_count = message.include_request_attempt_count;
    }
    if (message.include_attempt_count_in_response !== undefined) {
      obj.include_attempt_count_in_response = message.include_attempt_count_in_response;
    }
    if (message.retry_policy !== undefined) {
      obj.retry_policy = RetryPolicy.toJSON(message.retry_policy);
    }
    if (message.retry_policy_typed_config !== undefined) {
      obj.retry_policy_typed_config = Any.toJSON(message.retry_policy_typed_config);
    }
    if (message.hedge_policy !== undefined) {
      obj.hedge_policy = HedgePolicy.toJSON(message.hedge_policy);
    }
    if (message.include_is_timeout_retry_header !== undefined) {
      obj.include_is_timeout_retry_header = message.include_is_timeout_retry_header;
    }
    if (message.per_request_buffer_limit_bytes !== undefined) {
      obj.per_request_buffer_limit_bytes = message.per_request_buffer_limit_bytes;
    }
    if (message.request_mirror_policies?.length) {
      obj.request_mirror_policies = message.request_mirror_policies.map((e) =>
        RouteAction_RequestMirrorPolicy.toJSON(e)
      );
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VirtualHost>, I>>(base?: I): VirtualHost {
    return VirtualHost.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VirtualHost>, I>>(object: I): VirtualHost {
    const message = createBaseVirtualHost();
    message.name = object.name ?? undefined;
    message.domains = object.domains?.map((e) => e) || undefined;
    message.routes = object.routes?.map((e) => Route.fromPartial(e)) || undefined;
    message.matcher = (object.matcher !== undefined && object.matcher !== null)
      ? Matcher.fromPartial(object.matcher)
      : undefined;
    message.require_tls = object.require_tls ?? undefined;
    message.virtual_clusters = object.virtual_clusters?.map((e) => VirtualCluster.fromPartial(e)) || undefined;
    message.rate_limits = object.rate_limits?.map((e) => RateLimit.fromPartial(e)) || undefined;
    message.request_headers_to_add = object.request_headers_to_add?.map((e) => HeaderValueOption.fromPartial(e)) ||
      undefined;
    message.request_headers_to_remove = object.request_headers_to_remove?.map((e) => e) || undefined;
    message.response_headers_to_add = object.response_headers_to_add?.map((e) => HeaderValueOption.fromPartial(e)) ||
      undefined;
    message.response_headers_to_remove = object.response_headers_to_remove?.map((e) => e) || undefined;
    message.cors = (object.cors !== undefined && object.cors !== null)
      ? CorsPolicy.fromPartial(object.cors)
      : undefined;
    message.typed_per_filter_config =
      (object.typed_per_filter_config === undefined || object.typed_per_filter_config === null) ? undefined : (() => {
        const m = new Map();
        (object.typed_per_filter_config as Map<string, Any> ?? new Map()).forEach((value, key) => {
          if (value !== undefined) {
            m.set(key, Any.fromPartial(value));
          }
        });
        return m;
      })();
    message.include_request_attempt_count = object.include_request_attempt_count ?? undefined;
    message.include_attempt_count_in_response = object.include_attempt_count_in_response ?? undefined;
    message.retry_policy = (object.retry_policy !== undefined && object.retry_policy !== null)
      ? RetryPolicy.fromPartial(object.retry_policy)
      : undefined;
    message.retry_policy_typed_config =
      (object.retry_policy_typed_config !== undefined && object.retry_policy_typed_config !== null)
        ? Any.fromPartial(object.retry_policy_typed_config)
        : undefined;
    message.hedge_policy = (object.hedge_policy !== undefined && object.hedge_policy !== null)
      ? HedgePolicy.fromPartial(object.hedge_policy)
      : undefined;
    message.include_is_timeout_retry_header = object.include_is_timeout_retry_header ?? undefined;
    message.per_request_buffer_limit_bytes = object.per_request_buffer_limit_bytes ?? undefined;
    message.request_mirror_policies =
      object.request_mirror_policies?.map((e) => RouteAction_RequestMirrorPolicy.fromPartial(e)) || undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(VirtualHost.$type, VirtualHost);

function createBaseVirtualHost_TypedPerFilterConfigEntry(): VirtualHost_TypedPerFilterConfigEntry {
  return { $type: "envoy.config.route.v3.VirtualHost.TypedPerFilterConfigEntry", key: "" };
}

export const VirtualHost_TypedPerFilterConfigEntry: MessageFns<
  VirtualHost_TypedPerFilterConfigEntry,
  "envoy.config.route.v3.VirtualHost.TypedPerFilterConfigEntry"
> = {
  $type: "envoy.config.route.v3.VirtualHost.TypedPerFilterConfigEntry" as const,

  encode(message: VirtualHost_TypedPerFilterConfigEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Any.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VirtualHost_TypedPerFilterConfigEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVirtualHost_TypedPerFilterConfigEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VirtualHost_TypedPerFilterConfigEntry {
    return {
      $type: VirtualHost_TypedPerFilterConfigEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Any.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: VirtualHost_TypedPerFilterConfigEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Any.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VirtualHost_TypedPerFilterConfigEntry>, I>>(
    base?: I,
  ): VirtualHost_TypedPerFilterConfigEntry {
    return VirtualHost_TypedPerFilterConfigEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VirtualHost_TypedPerFilterConfigEntry>, I>>(
    object: I,
  ): VirtualHost_TypedPerFilterConfigEntry {
    const message = createBaseVirtualHost_TypedPerFilterConfigEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Any.fromPartial(object.value) : undefined;
    return message;
  },
};

messageTypeRegistry.set(VirtualHost_TypedPerFilterConfigEntry.$type, VirtualHost_TypedPerFilterConfigEntry);

function createBaseFilterAction(): FilterAction {
  return { $type: "envoy.config.route.v3.FilterAction" };
}

export const FilterAction: MessageFns<FilterAction, "envoy.config.route.v3.FilterAction"> = {
  $type: "envoy.config.route.v3.FilterAction" as const,

  encode(message: FilterAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.action !== undefined) {
      Any.encode(message.action, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FilterAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilterAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.action = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FilterAction {
    return { $type: FilterAction.$type, action: isSet(object.action) ? Any.fromJSON(object.action) : undefined };
  },

  toJSON(message: FilterAction): unknown {
    const obj: any = {};
    if (message.action !== undefined) {
      obj.action = Any.toJSON(message.action);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FilterAction>, I>>(base?: I): FilterAction {
    return FilterAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FilterAction>, I>>(object: I): FilterAction {
    const message = createBaseFilterAction();
    message.action = (object.action !== undefined && object.action !== null)
      ? Any.fromPartial(object.action)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(FilterAction.$type, FilterAction);

function createBaseRouteList(): RouteList {
  return { $type: "envoy.config.route.v3.RouteList" };
}

export const RouteList: MessageFns<RouteList, "envoy.config.route.v3.RouteList"> = {
  $type: "envoy.config.route.v3.RouteList" as const,

  encode(message: RouteList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.routes !== undefined && message.routes.length !== 0) {
      for (const v of message.routes) {
        Route.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.routes === undefined) {
            message.routes = [];
          }
          const el = Route.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.routes!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteList {
    return {
      $type: RouteList.$type,
      routes: globalThis.Array.isArray(object?.routes) ? object.routes.map((e: any) => Route.fromJSON(e)) : undefined,
    };
  },

  toJSON(message: RouteList): unknown {
    const obj: any = {};
    if (message.routes?.length) {
      obj.routes = message.routes.map((e) => Route.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RouteList>, I>>(base?: I): RouteList {
    return RouteList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RouteList>, I>>(object: I): RouteList {
    const message = createBaseRouteList();
    message.routes = object.routes?.map((e) => Route.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(RouteList.$type, RouteList);

function createBaseRoute(): Route {
  return { $type: "envoy.config.route.v3.Route", action: undefined };
}

export const Route: MessageFns<Route, "envoy.config.route.v3.Route"> = {
  $type: "envoy.config.route.v3.Route" as const,

  encode(message: Route, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(114).string(message.name);
    }
    if (message.match !== undefined) {
      RouteMatch.encode(message.match, writer.uint32(10).fork()).join();
    }
    switch (message.action?.$case) {
      case "route":
        RouteAction.encode(message.action.route, writer.uint32(18).fork()).join();
        break;
      case "redirect":
        RedirectAction.encode(message.action.redirect, writer.uint32(26).fork()).join();
        break;
      case "direct_response":
        DirectResponseAction.encode(message.action.direct_response, writer.uint32(58).fork()).join();
        break;
      case "filter_action":
        FilterAction.encode(message.action.filter_action, writer.uint32(138).fork()).join();
        break;
      case "non_forwarding_action":
        NonForwardingAction.encode(message.action.non_forwarding_action, writer.uint32(146).fork()).join();
        break;
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.decorator !== undefined) {
      Decorator.encode(message.decorator, writer.uint32(42).fork()).join();
    }
    (message.typed_per_filter_config || new Map()).forEach((value, key) => {
      Route_TypedPerFilterConfigEntry.encode({
        $type: "envoy.config.route.v3.Route.TypedPerFilterConfigEntry",
        key: key as any,
        value,
      }, writer.uint32(106).fork()).join();
    });
    if (message.request_headers_to_add !== undefined && message.request_headers_to_add.length !== 0) {
      for (const v of message.request_headers_to_add) {
        HeaderValueOption.encode(v!, writer.uint32(74).fork()).join();
      }
    }
    if (message.request_headers_to_remove !== undefined && message.request_headers_to_remove.length !== 0) {
      for (const v of message.request_headers_to_remove) {
        writer.uint32(98).string(v!);
      }
    }
    if (message.response_headers_to_add !== undefined && message.response_headers_to_add.length !== 0) {
      for (const v of message.response_headers_to_add) {
        HeaderValueOption.encode(v!, writer.uint32(82).fork()).join();
      }
    }
    if (message.response_headers_to_remove !== undefined && message.response_headers_to_remove.length !== 0) {
      for (const v of message.response_headers_to_remove) {
        writer.uint32(90).string(v!);
      }
    }
    if (message.tracing !== undefined) {
      Tracing.encode(message.tracing, writer.uint32(122).fork()).join();
    }
    if (message.per_request_buffer_limit_bytes !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.per_request_buffer_limit_bytes! },
        writer.uint32(130).fork(),
      ).join();
    }
    if (message.stat_prefix !== undefined && message.stat_prefix !== "") {
      writer.uint32(154).string(message.stat_prefix);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Route {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.match = RouteMatch.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.action = { $case: "route", route: RouteAction.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.action = { $case: "redirect", redirect: RedirectAction.decode(reader, reader.uint32()) };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.action = {
            $case: "direct_response",
            direct_response: DirectResponseAction.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.action = { $case: "filter_action", filter_action: FilterAction.decode(reader, reader.uint32()) };
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.action = {
            $case: "non_forwarding_action",
            non_forwarding_action: NonForwardingAction.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.decorator = Decorator.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          const entry13 = Route_TypedPerFilterConfigEntry.decode(reader, reader.uint32());
          if (entry13.value !== undefined) {
            if (message.typed_per_filter_config === undefined) {
              message.typed_per_filter_config = new Map();
            }
            message.typed_per_filter_config!.set(entry13.key, entry13.value);
          }
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          if (message.request_headers_to_add === undefined) {
            message.request_headers_to_add = [];
          }
          const el = HeaderValueOption.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.request_headers_to_add!.push(el);
          }
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          if (message.request_headers_to_remove === undefined) {
            message.request_headers_to_remove = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.request_headers_to_remove!.push(el);
          }
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          if (message.response_headers_to_add === undefined) {
            message.response_headers_to_add = [];
          }
          const el = HeaderValueOption.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.response_headers_to_add!.push(el);
          }
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          if (message.response_headers_to_remove === undefined) {
            message.response_headers_to_remove = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.response_headers_to_remove!.push(el);
          }
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.tracing = Tracing.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.per_request_buffer_limit_bytes = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.stat_prefix = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Route {
    return {
      $type: Route.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      match: isSet(object.match) ? RouteMatch.fromJSON(object.match) : undefined,
      action: isSet(object.route)
        ? { $case: "route", route: RouteAction.fromJSON(object.route) }
        : isSet(object.redirect)
        ? { $case: "redirect", redirect: RedirectAction.fromJSON(object.redirect) }
        : isSet(object.direct_response)
        ? { $case: "direct_response", direct_response: DirectResponseAction.fromJSON(object.direct_response) }
        : isSet(object.filter_action)
        ? { $case: "filter_action", filter_action: FilterAction.fromJSON(object.filter_action) }
        : isSet(object.non_forwarding_action)
        ? {
          $case: "non_forwarding_action",
          non_forwarding_action: NonForwardingAction.fromJSON(object.non_forwarding_action),
        }
        : undefined,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      decorator: isSet(object.decorator) ? Decorator.fromJSON(object.decorator) : undefined,
      typed_per_filter_config: isObject(object.typed_per_filter_config)
        ? Object.entries(object.typed_per_filter_config).reduce<Map<string, Any>>((acc, [key, value]) => {
          acc.set(key, Any.fromJSON(value));
          return acc;
        }, new Map())
        : undefined,
      request_headers_to_add: globalThis.Array.isArray(object?.request_headers_to_add)
        ? object.request_headers_to_add.map((e: any) => HeaderValueOption.fromJSON(e))
        : undefined,
      request_headers_to_remove: globalThis.Array.isArray(object?.request_headers_to_remove)
        ? object.request_headers_to_remove.map((e: any) => globalThis.String(e))
        : undefined,
      response_headers_to_add: globalThis.Array.isArray(object?.response_headers_to_add)
        ? object.response_headers_to_add.map((e: any) => HeaderValueOption.fromJSON(e))
        : undefined,
      response_headers_to_remove: globalThis.Array.isArray(object?.response_headers_to_remove)
        ? object.response_headers_to_remove.map((e: any) => globalThis.String(e))
        : undefined,
      tracing: isSet(object.tracing) ? Tracing.fromJSON(object.tracing) : undefined,
      per_request_buffer_limit_bytes: isSet(object.per_request_buffer_limit_bytes)
        ? Number(object.per_request_buffer_limit_bytes)
        : undefined,
      stat_prefix: isSet(object.stat_prefix) ? globalThis.String(object.stat_prefix) : undefined,
    };
  },

  toJSON(message: Route): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.match !== undefined) {
      obj.match = RouteMatch.toJSON(message.match);
    }
    if (message.action?.$case === "route") {
      obj.route = RouteAction.toJSON(message.action.route);
    }
    if (message.action?.$case === "redirect") {
      obj.redirect = RedirectAction.toJSON(message.action.redirect);
    }
    if (message.action?.$case === "direct_response") {
      obj.direct_response = DirectResponseAction.toJSON(message.action.direct_response);
    }
    if (message.action?.$case === "filter_action") {
      obj.filter_action = FilterAction.toJSON(message.action.filter_action);
    }
    if (message.action?.$case === "non_forwarding_action") {
      obj.non_forwarding_action = NonForwardingAction.toJSON(message.action.non_forwarding_action);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.decorator !== undefined) {
      obj.decorator = Decorator.toJSON(message.decorator);
    }
    if (message.typed_per_filter_config?.size) {
      obj.typed_per_filter_config = {};
      message.typed_per_filter_config.forEach((v, k) => {
        obj.typed_per_filter_config[k] = Any.toJSON(v);
      });
    }
    if (message.request_headers_to_add?.length) {
      obj.request_headers_to_add = message.request_headers_to_add.map((e) => HeaderValueOption.toJSON(e));
    }
    if (message.request_headers_to_remove?.length) {
      obj.request_headers_to_remove = message.request_headers_to_remove;
    }
    if (message.response_headers_to_add?.length) {
      obj.response_headers_to_add = message.response_headers_to_add.map((e) => HeaderValueOption.toJSON(e));
    }
    if (message.response_headers_to_remove?.length) {
      obj.response_headers_to_remove = message.response_headers_to_remove;
    }
    if (message.tracing !== undefined) {
      obj.tracing = Tracing.toJSON(message.tracing);
    }
    if (message.per_request_buffer_limit_bytes !== undefined) {
      obj.per_request_buffer_limit_bytes = message.per_request_buffer_limit_bytes;
    }
    if (message.stat_prefix !== undefined) {
      obj.stat_prefix = message.stat_prefix;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Route>, I>>(base?: I): Route {
    return Route.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Route>, I>>(object: I): Route {
    const message = createBaseRoute();
    message.name = object.name ?? undefined;
    message.match = (object.match !== undefined && object.match !== null)
      ? RouteMatch.fromPartial(object.match)
      : undefined;
    if (object.action?.$case === "route" && object.action?.route !== undefined && object.action?.route !== null) {
      message.action = { $case: "route", route: RouteAction.fromPartial(object.action.route) };
    }
    if (
      object.action?.$case === "redirect" && object.action?.redirect !== undefined && object.action?.redirect !== null
    ) {
      message.action = { $case: "redirect", redirect: RedirectAction.fromPartial(object.action.redirect) };
    }
    if (
      object.action?.$case === "direct_response" &&
      object.action?.direct_response !== undefined &&
      object.action?.direct_response !== null
    ) {
      message.action = {
        $case: "direct_response",
        direct_response: DirectResponseAction.fromPartial(object.action.direct_response),
      };
    }
    if (
      object.action?.$case === "filter_action" &&
      object.action?.filter_action !== undefined &&
      object.action?.filter_action !== null
    ) {
      message.action = { $case: "filter_action", filter_action: FilterAction.fromPartial(object.action.filter_action) };
    }
    if (
      object.action?.$case === "non_forwarding_action" &&
      object.action?.non_forwarding_action !== undefined &&
      object.action?.non_forwarding_action !== null
    ) {
      message.action = {
        $case: "non_forwarding_action",
        non_forwarding_action: NonForwardingAction.fromPartial(object.action.non_forwarding_action),
      };
    }
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.decorator = (object.decorator !== undefined && object.decorator !== null)
      ? Decorator.fromPartial(object.decorator)
      : undefined;
    message.typed_per_filter_config =
      (object.typed_per_filter_config === undefined || object.typed_per_filter_config === null) ? undefined : (() => {
        const m = new Map();
        (object.typed_per_filter_config as Map<string, Any> ?? new Map()).forEach((value, key) => {
          if (value !== undefined) {
            m.set(key, Any.fromPartial(value));
          }
        });
        return m;
      })();
    message.request_headers_to_add = object.request_headers_to_add?.map((e) => HeaderValueOption.fromPartial(e)) ||
      undefined;
    message.request_headers_to_remove = object.request_headers_to_remove?.map((e) => e) || undefined;
    message.response_headers_to_add = object.response_headers_to_add?.map((e) => HeaderValueOption.fromPartial(e)) ||
      undefined;
    message.response_headers_to_remove = object.response_headers_to_remove?.map((e) => e) || undefined;
    message.tracing = (object.tracing !== undefined && object.tracing !== null)
      ? Tracing.fromPartial(object.tracing)
      : undefined;
    message.per_request_buffer_limit_bytes = object.per_request_buffer_limit_bytes ?? undefined;
    message.stat_prefix = object.stat_prefix ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Route.$type, Route);

function createBaseRoute_TypedPerFilterConfigEntry(): Route_TypedPerFilterConfigEntry {
  return { $type: "envoy.config.route.v3.Route.TypedPerFilterConfigEntry", key: "" };
}

export const Route_TypedPerFilterConfigEntry: MessageFns<
  Route_TypedPerFilterConfigEntry,
  "envoy.config.route.v3.Route.TypedPerFilterConfigEntry"
> = {
  $type: "envoy.config.route.v3.Route.TypedPerFilterConfigEntry" as const,

  encode(message: Route_TypedPerFilterConfigEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Any.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Route_TypedPerFilterConfigEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoute_TypedPerFilterConfigEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Route_TypedPerFilterConfigEntry {
    return {
      $type: Route_TypedPerFilterConfigEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Any.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Route_TypedPerFilterConfigEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Any.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Route_TypedPerFilterConfigEntry>, I>>(base?: I): Route_TypedPerFilterConfigEntry {
    return Route_TypedPerFilterConfigEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Route_TypedPerFilterConfigEntry>, I>>(
    object: I,
  ): Route_TypedPerFilterConfigEntry {
    const message = createBaseRoute_TypedPerFilterConfigEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Any.fromPartial(object.value) : undefined;
    return message;
  },
};

messageTypeRegistry.set(Route_TypedPerFilterConfigEntry.$type, Route_TypedPerFilterConfigEntry);

function createBaseWeightedCluster(): WeightedCluster {
  return { $type: "envoy.config.route.v3.WeightedCluster", random_value_specifier: undefined };
}

export const WeightedCluster: MessageFns<WeightedCluster, "envoy.config.route.v3.WeightedCluster"> = {
  $type: "envoy.config.route.v3.WeightedCluster" as const,

  encode(message: WeightedCluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clusters !== undefined && message.clusters.length !== 0) {
      for (const v of message.clusters) {
        WeightedCluster_ClusterWeight.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    if (message.total_weight !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.total_weight! },
        writer.uint32(26).fork(),
      ).join();
    }
    if (message.runtime_key_prefix !== undefined && message.runtime_key_prefix !== "") {
      writer.uint32(18).string(message.runtime_key_prefix);
    }
    switch (message.random_value_specifier?.$case) {
      case "header_name":
        writer.uint32(34).string(message.random_value_specifier.header_name);
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WeightedCluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWeightedCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.clusters === undefined) {
            message.clusters = [];
          }
          const el = WeightedCluster_ClusterWeight.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.clusters!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.total_weight = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.runtime_key_prefix = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.random_value_specifier = { $case: "header_name", header_name: reader.string() };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WeightedCluster {
    return {
      $type: WeightedCluster.$type,
      clusters: globalThis.Array.isArray(object?.clusters)
        ? object.clusters.map((e: any) => WeightedCluster_ClusterWeight.fromJSON(e))
        : undefined,
      total_weight: isSet(object.total_weight) ? Number(object.total_weight) : undefined,
      runtime_key_prefix: isSet(object.runtime_key_prefix) ? globalThis.String(object.runtime_key_prefix) : undefined,
      random_value_specifier: isSet(object.header_name)
        ? { $case: "header_name", header_name: globalThis.String(object.header_name) }
        : undefined,
    };
  },

  toJSON(message: WeightedCluster): unknown {
    const obj: any = {};
    if (message.clusters?.length) {
      obj.clusters = message.clusters.map((e) => WeightedCluster_ClusterWeight.toJSON(e));
    }
    if (message.total_weight !== undefined) {
      obj.total_weight = message.total_weight;
    }
    if (message.runtime_key_prefix !== undefined) {
      obj.runtime_key_prefix = message.runtime_key_prefix;
    }
    if (message.random_value_specifier?.$case === "header_name") {
      obj.header_name = message.random_value_specifier.header_name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WeightedCluster>, I>>(base?: I): WeightedCluster {
    return WeightedCluster.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WeightedCluster>, I>>(object: I): WeightedCluster {
    const message = createBaseWeightedCluster();
    message.clusters = object.clusters?.map((e) => WeightedCluster_ClusterWeight.fromPartial(e)) || undefined;
    message.total_weight = object.total_weight ?? undefined;
    message.runtime_key_prefix = object.runtime_key_prefix ?? undefined;
    if (
      object.random_value_specifier?.$case === "header_name" &&
      object.random_value_specifier?.header_name !== undefined &&
      object.random_value_specifier?.header_name !== null
    ) {
      message.random_value_specifier = { $case: "header_name", header_name: object.random_value_specifier.header_name };
    }
    return message;
  },
};

messageTypeRegistry.set(WeightedCluster.$type, WeightedCluster);

function createBaseWeightedCluster_ClusterWeight(): WeightedCluster_ClusterWeight {
  return { $type: "envoy.config.route.v3.WeightedCluster.ClusterWeight", host_rewrite_specifier: undefined };
}

export const WeightedCluster_ClusterWeight: MessageFns<
  WeightedCluster_ClusterWeight,
  "envoy.config.route.v3.WeightedCluster.ClusterWeight"
> = {
  $type: "envoy.config.route.v3.WeightedCluster.ClusterWeight" as const,

  encode(message: WeightedCluster_ClusterWeight, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.cluster_header !== undefined && message.cluster_header !== "") {
      writer.uint32(98).string(message.cluster_header);
    }
    if (message.weight !== undefined) {
      UInt32Value.encode({ $type: "google.protobuf.UInt32Value", value: message.weight! }, writer.uint32(18).fork())
        .join();
    }
    if (message.metadata_match !== undefined) {
      Metadata.encode(message.metadata_match, writer.uint32(26).fork()).join();
    }
    if (message.request_headers_to_add !== undefined && message.request_headers_to_add.length !== 0) {
      for (const v of message.request_headers_to_add) {
        HeaderValueOption.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    if (message.request_headers_to_remove !== undefined && message.request_headers_to_remove.length !== 0) {
      for (const v of message.request_headers_to_remove) {
        writer.uint32(74).string(v!);
      }
    }
    if (message.response_headers_to_add !== undefined && message.response_headers_to_add.length !== 0) {
      for (const v of message.response_headers_to_add) {
        HeaderValueOption.encode(v!, writer.uint32(42).fork()).join();
      }
    }
    if (message.response_headers_to_remove !== undefined && message.response_headers_to_remove.length !== 0) {
      for (const v of message.response_headers_to_remove) {
        writer.uint32(50).string(v!);
      }
    }
    (message.typed_per_filter_config || new Map()).forEach((value, key) => {
      WeightedCluster_ClusterWeight_TypedPerFilterConfigEntry.encode({
        $type: "envoy.config.route.v3.WeightedCluster.ClusterWeight.TypedPerFilterConfigEntry",
        key: key as any,
        value,
      }, writer.uint32(82).fork()).join();
    });
    switch (message.host_rewrite_specifier?.$case) {
      case "host_rewrite_literal":
        writer.uint32(90).string(message.host_rewrite_specifier.host_rewrite_literal);
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WeightedCluster_ClusterWeight {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWeightedCluster_ClusterWeight();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.cluster_header = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.weight = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata_match = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          if (message.request_headers_to_add === undefined) {
            message.request_headers_to_add = [];
          }
          const el = HeaderValueOption.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.request_headers_to_add!.push(el);
          }
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          if (message.request_headers_to_remove === undefined) {
            message.request_headers_to_remove = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.request_headers_to_remove!.push(el);
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          if (message.response_headers_to_add === undefined) {
            message.response_headers_to_add = [];
          }
          const el = HeaderValueOption.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.response_headers_to_add!.push(el);
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          if (message.response_headers_to_remove === undefined) {
            message.response_headers_to_remove = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.response_headers_to_remove!.push(el);
          }
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          const entry10 = WeightedCluster_ClusterWeight_TypedPerFilterConfigEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            if (message.typed_per_filter_config === undefined) {
              message.typed_per_filter_config = new Map();
            }
            message.typed_per_filter_config!.set(entry10.key, entry10.value);
          }
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.host_rewrite_specifier = { $case: "host_rewrite_literal", host_rewrite_literal: reader.string() };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WeightedCluster_ClusterWeight {
    return {
      $type: WeightedCluster_ClusterWeight.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      cluster_header: isSet(object.cluster_header) ? globalThis.String(object.cluster_header) : undefined,
      weight: isSet(object.weight) ? Number(object.weight) : undefined,
      metadata_match: isSet(object.metadata_match) ? Metadata.fromJSON(object.metadata_match) : undefined,
      request_headers_to_add: globalThis.Array.isArray(object?.request_headers_to_add)
        ? object.request_headers_to_add.map((e: any) => HeaderValueOption.fromJSON(e))
        : undefined,
      request_headers_to_remove: globalThis.Array.isArray(object?.request_headers_to_remove)
        ? object.request_headers_to_remove.map((e: any) => globalThis.String(e))
        : undefined,
      response_headers_to_add: globalThis.Array.isArray(object?.response_headers_to_add)
        ? object.response_headers_to_add.map((e: any) => HeaderValueOption.fromJSON(e))
        : undefined,
      response_headers_to_remove: globalThis.Array.isArray(object?.response_headers_to_remove)
        ? object.response_headers_to_remove.map((e: any) => globalThis.String(e))
        : undefined,
      typed_per_filter_config: isObject(object.typed_per_filter_config)
        ? Object.entries(object.typed_per_filter_config).reduce<Map<string, Any>>((acc, [key, value]) => {
          acc.set(key, Any.fromJSON(value));
          return acc;
        }, new Map())
        : undefined,
      host_rewrite_specifier: isSet(object.host_rewrite_literal)
        ? { $case: "host_rewrite_literal", host_rewrite_literal: globalThis.String(object.host_rewrite_literal) }
        : undefined,
    };
  },

  toJSON(message: WeightedCluster_ClusterWeight): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.cluster_header !== undefined) {
      obj.cluster_header = message.cluster_header;
    }
    if (message.weight !== undefined) {
      obj.weight = message.weight;
    }
    if (message.metadata_match !== undefined) {
      obj.metadata_match = Metadata.toJSON(message.metadata_match);
    }
    if (message.request_headers_to_add?.length) {
      obj.request_headers_to_add = message.request_headers_to_add.map((e) => HeaderValueOption.toJSON(e));
    }
    if (message.request_headers_to_remove?.length) {
      obj.request_headers_to_remove = message.request_headers_to_remove;
    }
    if (message.response_headers_to_add?.length) {
      obj.response_headers_to_add = message.response_headers_to_add.map((e) => HeaderValueOption.toJSON(e));
    }
    if (message.response_headers_to_remove?.length) {
      obj.response_headers_to_remove = message.response_headers_to_remove;
    }
    if (message.typed_per_filter_config?.size) {
      obj.typed_per_filter_config = {};
      message.typed_per_filter_config.forEach((v, k) => {
        obj.typed_per_filter_config[k] = Any.toJSON(v);
      });
    }
    if (message.host_rewrite_specifier?.$case === "host_rewrite_literal") {
      obj.host_rewrite_literal = message.host_rewrite_specifier.host_rewrite_literal;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WeightedCluster_ClusterWeight>, I>>(base?: I): WeightedCluster_ClusterWeight {
    return WeightedCluster_ClusterWeight.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WeightedCluster_ClusterWeight>, I>>(
    object: I,
  ): WeightedCluster_ClusterWeight {
    const message = createBaseWeightedCluster_ClusterWeight();
    message.name = object.name ?? undefined;
    message.cluster_header = object.cluster_header ?? undefined;
    message.weight = object.weight ?? undefined;
    message.metadata_match = (object.metadata_match !== undefined && object.metadata_match !== null)
      ? Metadata.fromPartial(object.metadata_match)
      : undefined;
    message.request_headers_to_add = object.request_headers_to_add?.map((e) => HeaderValueOption.fromPartial(e)) ||
      undefined;
    message.request_headers_to_remove = object.request_headers_to_remove?.map((e) => e) || undefined;
    message.response_headers_to_add = object.response_headers_to_add?.map((e) => HeaderValueOption.fromPartial(e)) ||
      undefined;
    message.response_headers_to_remove = object.response_headers_to_remove?.map((e) => e) || undefined;
    message.typed_per_filter_config =
      (object.typed_per_filter_config === undefined || object.typed_per_filter_config === null) ? undefined : (() => {
        const m = new Map();
        (object.typed_per_filter_config as Map<string, Any> ?? new Map()).forEach((value, key) => {
          if (value !== undefined) {
            m.set(key, Any.fromPartial(value));
          }
        });
        return m;
      })();
    if (
      object.host_rewrite_specifier?.$case === "host_rewrite_literal" &&
      object.host_rewrite_specifier?.host_rewrite_literal !== undefined &&
      object.host_rewrite_specifier?.host_rewrite_literal !== null
    ) {
      message.host_rewrite_specifier = {
        $case: "host_rewrite_literal",
        host_rewrite_literal: object.host_rewrite_specifier.host_rewrite_literal,
      };
    }
    return message;
  },
};

messageTypeRegistry.set(WeightedCluster_ClusterWeight.$type, WeightedCluster_ClusterWeight);

function createBaseWeightedCluster_ClusterWeight_TypedPerFilterConfigEntry(): WeightedCluster_ClusterWeight_TypedPerFilterConfigEntry {
  return { $type: "envoy.config.route.v3.WeightedCluster.ClusterWeight.TypedPerFilterConfigEntry", key: "" };
}

export const WeightedCluster_ClusterWeight_TypedPerFilterConfigEntry: MessageFns<
  WeightedCluster_ClusterWeight_TypedPerFilterConfigEntry,
  "envoy.config.route.v3.WeightedCluster.ClusterWeight.TypedPerFilterConfigEntry"
> = {
  $type: "envoy.config.route.v3.WeightedCluster.ClusterWeight.TypedPerFilterConfigEntry" as const,

  encode(
    message: WeightedCluster_ClusterWeight_TypedPerFilterConfigEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Any.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WeightedCluster_ClusterWeight_TypedPerFilterConfigEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWeightedCluster_ClusterWeight_TypedPerFilterConfigEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WeightedCluster_ClusterWeight_TypedPerFilterConfigEntry {
    return {
      $type: WeightedCluster_ClusterWeight_TypedPerFilterConfigEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Any.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: WeightedCluster_ClusterWeight_TypedPerFilterConfigEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Any.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WeightedCluster_ClusterWeight_TypedPerFilterConfigEntry>, I>>(
    base?: I,
  ): WeightedCluster_ClusterWeight_TypedPerFilterConfigEntry {
    return WeightedCluster_ClusterWeight_TypedPerFilterConfigEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WeightedCluster_ClusterWeight_TypedPerFilterConfigEntry>, I>>(
    object: I,
  ): WeightedCluster_ClusterWeight_TypedPerFilterConfigEntry {
    const message = createBaseWeightedCluster_ClusterWeight_TypedPerFilterConfigEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Any.fromPartial(object.value) : undefined;
    return message;
  },
};

messageTypeRegistry.set(
  WeightedCluster_ClusterWeight_TypedPerFilterConfigEntry.$type,
  WeightedCluster_ClusterWeight_TypedPerFilterConfigEntry,
);

function createBaseClusterSpecifierPlugin(): ClusterSpecifierPlugin {
  return { $type: "envoy.config.route.v3.ClusterSpecifierPlugin" };
}

export const ClusterSpecifierPlugin: MessageFns<
  ClusterSpecifierPlugin,
  "envoy.config.route.v3.ClusterSpecifierPlugin"
> = {
  $type: "envoy.config.route.v3.ClusterSpecifierPlugin" as const,

  encode(message: ClusterSpecifierPlugin, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.extension !== undefined) {
      TypedExtensionConfig.encode(message.extension, writer.uint32(10).fork()).join();
    }
    if (message.is_optional !== undefined && message.is_optional !== false) {
      writer.uint32(16).bool(message.is_optional);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClusterSpecifierPlugin {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClusterSpecifierPlugin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.extension = TypedExtensionConfig.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.is_optional = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClusterSpecifierPlugin {
    return {
      $type: ClusterSpecifierPlugin.$type,
      extension: isSet(object.extension) ? TypedExtensionConfig.fromJSON(object.extension) : undefined,
      is_optional: isSet(object.is_optional) ? globalThis.Boolean(object.is_optional) : undefined,
    };
  },

  toJSON(message: ClusterSpecifierPlugin): unknown {
    const obj: any = {};
    if (message.extension !== undefined) {
      obj.extension = TypedExtensionConfig.toJSON(message.extension);
    }
    if (message.is_optional !== undefined) {
      obj.is_optional = message.is_optional;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClusterSpecifierPlugin>, I>>(base?: I): ClusterSpecifierPlugin {
    return ClusterSpecifierPlugin.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClusterSpecifierPlugin>, I>>(object: I): ClusterSpecifierPlugin {
    const message = createBaseClusterSpecifierPlugin();
    message.extension = (object.extension !== undefined && object.extension !== null)
      ? TypedExtensionConfig.fromPartial(object.extension)
      : undefined;
    message.is_optional = object.is_optional ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ClusterSpecifierPlugin.$type, ClusterSpecifierPlugin);

function createBaseRouteMatch(): RouteMatch {
  return { $type: "envoy.config.route.v3.RouteMatch", path_specifier: undefined };
}

export const RouteMatch: MessageFns<RouteMatch, "envoy.config.route.v3.RouteMatch"> = {
  $type: "envoy.config.route.v3.RouteMatch" as const,

  encode(message: RouteMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.path_specifier?.$case) {
      case "prefix":
        writer.uint32(10).string(message.path_specifier.prefix);
        break;
      case "path":
        writer.uint32(18).string(message.path_specifier.path);
        break;
      case "safe_regex":
        RegexMatcher.encode(message.path_specifier.safe_regex, writer.uint32(82).fork()).join();
        break;
      case "connect_matcher":
        RouteMatch_ConnectMatcher.encode(message.path_specifier.connect_matcher, writer.uint32(98).fork()).join();
        break;
      case "path_separated_prefix":
        writer.uint32(114).string(message.path_specifier.path_separated_prefix);
        break;
      case "path_match_policy":
        TypedExtensionConfig.encode(message.path_specifier.path_match_policy, writer.uint32(122).fork()).join();
        break;
    }
    if (message.case_sensitive !== undefined) {
      BoolValue.encode({ $type: "google.protobuf.BoolValue", value: message.case_sensitive! }, writer.uint32(34).fork())
        .join();
    }
    if (message.runtime_fraction !== undefined) {
      RuntimeFractionalPercent.encode(message.runtime_fraction, writer.uint32(74).fork()).join();
    }
    if (message.headers !== undefined && message.headers.length !== 0) {
      for (const v of message.headers) {
        HeaderMatcher.encode(v!, writer.uint32(50).fork()).join();
      }
    }
    if (message.query_parameters !== undefined && message.query_parameters.length !== 0) {
      for (const v of message.query_parameters) {
        QueryParameterMatcher.encode(v!, writer.uint32(58).fork()).join();
      }
    }
    if (message.grpc !== undefined) {
      RouteMatch_GrpcRouteMatchOptions.encode(message.grpc, writer.uint32(66).fork()).join();
    }
    if (message.tls_context !== undefined) {
      RouteMatch_TlsContextMatchOptions.encode(message.tls_context, writer.uint32(90).fork()).join();
    }
    if (message.dynamic_metadata !== undefined && message.dynamic_metadata.length !== 0) {
      for (const v of message.dynamic_metadata) {
        MetadataMatcher.encode(v!, writer.uint32(106).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path_specifier = { $case: "prefix", prefix: reader.string() };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.path_specifier = { $case: "path", path: reader.string() };
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.path_specifier = { $case: "safe_regex", safe_regex: RegexMatcher.decode(reader, reader.uint32()) };
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.path_specifier = {
            $case: "connect_matcher",
            connect_matcher: RouteMatch_ConnectMatcher.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.path_specifier = { $case: "path_separated_prefix", path_separated_prefix: reader.string() };
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.path_specifier = {
            $case: "path_match_policy",
            path_match_policy: TypedExtensionConfig.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.case_sensitive = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.runtime_fraction = RuntimeFractionalPercent.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          if (message.headers === undefined) {
            message.headers = [];
          }
          const el = HeaderMatcher.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.headers!.push(el);
          }
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          if (message.query_parameters === undefined) {
            message.query_parameters = [];
          }
          const el = QueryParameterMatcher.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.query_parameters!.push(el);
          }
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.grpc = RouteMatch_GrpcRouteMatchOptions.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.tls_context = RouteMatch_TlsContextMatchOptions.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          if (message.dynamic_metadata === undefined) {
            message.dynamic_metadata = [];
          }
          const el = MetadataMatcher.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.dynamic_metadata!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteMatch {
    return {
      $type: RouteMatch.$type,
      path_specifier: isSet(object.prefix)
        ? { $case: "prefix", prefix: globalThis.String(object.prefix) }
        : isSet(object.path)
        ? { $case: "path", path: globalThis.String(object.path) }
        : isSet(object.safe_regex)
        ? { $case: "safe_regex", safe_regex: RegexMatcher.fromJSON(object.safe_regex) }
        : isSet(object.connect_matcher)
        ? { $case: "connect_matcher", connect_matcher: RouteMatch_ConnectMatcher.fromJSON(object.connect_matcher) }
        : isSet(object.path_separated_prefix)
        ? { $case: "path_separated_prefix", path_separated_prefix: globalThis.String(object.path_separated_prefix) }
        : isSet(object.path_match_policy)
        ? { $case: "path_match_policy", path_match_policy: TypedExtensionConfig.fromJSON(object.path_match_policy) }
        : undefined,
      case_sensitive: isSet(object.case_sensitive) ? Boolean(object.case_sensitive) : undefined,
      runtime_fraction: isSet(object.runtime_fraction)
        ? RuntimeFractionalPercent.fromJSON(object.runtime_fraction)
        : undefined,
      headers: globalThis.Array.isArray(object?.headers)
        ? object.headers.map((e: any) => HeaderMatcher.fromJSON(e))
        : undefined,
      query_parameters: globalThis.Array.isArray(object?.query_parameters)
        ? object.query_parameters.map((e: any) => QueryParameterMatcher.fromJSON(e))
        : undefined,
      grpc: isSet(object.grpc) ? RouteMatch_GrpcRouteMatchOptions.fromJSON(object.grpc) : undefined,
      tls_context: isSet(object.tls_context)
        ? RouteMatch_TlsContextMatchOptions.fromJSON(object.tls_context)
        : undefined,
      dynamic_metadata: globalThis.Array.isArray(object?.dynamic_metadata)
        ? object.dynamic_metadata.map((e: any) => MetadataMatcher.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: RouteMatch): unknown {
    const obj: any = {};
    if (message.path_specifier?.$case === "prefix") {
      obj.prefix = message.path_specifier.prefix;
    }
    if (message.path_specifier?.$case === "path") {
      obj.path = message.path_specifier.path;
    }
    if (message.path_specifier?.$case === "safe_regex") {
      obj.safe_regex = RegexMatcher.toJSON(message.path_specifier.safe_regex);
    }
    if (message.path_specifier?.$case === "connect_matcher") {
      obj.connect_matcher = RouteMatch_ConnectMatcher.toJSON(message.path_specifier.connect_matcher);
    }
    if (message.path_specifier?.$case === "path_separated_prefix") {
      obj.path_separated_prefix = message.path_specifier.path_separated_prefix;
    }
    if (message.path_specifier?.$case === "path_match_policy") {
      obj.path_match_policy = TypedExtensionConfig.toJSON(message.path_specifier.path_match_policy);
    }
    if (message.case_sensitive !== undefined) {
      obj.case_sensitive = message.case_sensitive;
    }
    if (message.runtime_fraction !== undefined) {
      obj.runtime_fraction = RuntimeFractionalPercent.toJSON(message.runtime_fraction);
    }
    if (message.headers?.length) {
      obj.headers = message.headers.map((e) => HeaderMatcher.toJSON(e));
    }
    if (message.query_parameters?.length) {
      obj.query_parameters = message.query_parameters.map((e) => QueryParameterMatcher.toJSON(e));
    }
    if (message.grpc !== undefined) {
      obj.grpc = RouteMatch_GrpcRouteMatchOptions.toJSON(message.grpc);
    }
    if (message.tls_context !== undefined) {
      obj.tls_context = RouteMatch_TlsContextMatchOptions.toJSON(message.tls_context);
    }
    if (message.dynamic_metadata?.length) {
      obj.dynamic_metadata = message.dynamic_metadata.map((e) => MetadataMatcher.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RouteMatch>, I>>(base?: I): RouteMatch {
    return RouteMatch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RouteMatch>, I>>(object: I): RouteMatch {
    const message = createBaseRouteMatch();
    if (
      object.path_specifier?.$case === "prefix" &&
      object.path_specifier?.prefix !== undefined &&
      object.path_specifier?.prefix !== null
    ) {
      message.path_specifier = { $case: "prefix", prefix: object.path_specifier.prefix };
    }
    if (
      object.path_specifier?.$case === "path" &&
      object.path_specifier?.path !== undefined &&
      object.path_specifier?.path !== null
    ) {
      message.path_specifier = { $case: "path", path: object.path_specifier.path };
    }
    if (
      object.path_specifier?.$case === "safe_regex" &&
      object.path_specifier?.safe_regex !== undefined &&
      object.path_specifier?.safe_regex !== null
    ) {
      message.path_specifier = {
        $case: "safe_regex",
        safe_regex: RegexMatcher.fromPartial(object.path_specifier.safe_regex),
      };
    }
    if (
      object.path_specifier?.$case === "connect_matcher" &&
      object.path_specifier?.connect_matcher !== undefined &&
      object.path_specifier?.connect_matcher !== null
    ) {
      message.path_specifier = {
        $case: "connect_matcher",
        connect_matcher: RouteMatch_ConnectMatcher.fromPartial(object.path_specifier.connect_matcher),
      };
    }
    if (
      object.path_specifier?.$case === "path_separated_prefix" &&
      object.path_specifier?.path_separated_prefix !== undefined &&
      object.path_specifier?.path_separated_prefix !== null
    ) {
      message.path_specifier = {
        $case: "path_separated_prefix",
        path_separated_prefix: object.path_specifier.path_separated_prefix,
      };
    }
    if (
      object.path_specifier?.$case === "path_match_policy" &&
      object.path_specifier?.path_match_policy !== undefined &&
      object.path_specifier?.path_match_policy !== null
    ) {
      message.path_specifier = {
        $case: "path_match_policy",
        path_match_policy: TypedExtensionConfig.fromPartial(object.path_specifier.path_match_policy),
      };
    }
    message.case_sensitive = object.case_sensitive ?? undefined;
    message.runtime_fraction = (object.runtime_fraction !== undefined && object.runtime_fraction !== null)
      ? RuntimeFractionalPercent.fromPartial(object.runtime_fraction)
      : undefined;
    message.headers = object.headers?.map((e) => HeaderMatcher.fromPartial(e)) || undefined;
    message.query_parameters = object.query_parameters?.map((e) => QueryParameterMatcher.fromPartial(e)) || undefined;
    message.grpc = (object.grpc !== undefined && object.grpc !== null)
      ? RouteMatch_GrpcRouteMatchOptions.fromPartial(object.grpc)
      : undefined;
    message.tls_context = (object.tls_context !== undefined && object.tls_context !== null)
      ? RouteMatch_TlsContextMatchOptions.fromPartial(object.tls_context)
      : undefined;
    message.dynamic_metadata = object.dynamic_metadata?.map((e) => MetadataMatcher.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(RouteMatch.$type, RouteMatch);

function createBaseRouteMatch_GrpcRouteMatchOptions(): RouteMatch_GrpcRouteMatchOptions {
  return { $type: "envoy.config.route.v3.RouteMatch.GrpcRouteMatchOptions" };
}

export const RouteMatch_GrpcRouteMatchOptions: MessageFns<
  RouteMatch_GrpcRouteMatchOptions,
  "envoy.config.route.v3.RouteMatch.GrpcRouteMatchOptions"
> = {
  $type: "envoy.config.route.v3.RouteMatch.GrpcRouteMatchOptions" as const,

  encode(_: RouteMatch_GrpcRouteMatchOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteMatch_GrpcRouteMatchOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteMatch_GrpcRouteMatchOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RouteMatch_GrpcRouteMatchOptions {
    return { $type: RouteMatch_GrpcRouteMatchOptions.$type };
  },

  toJSON(_: RouteMatch_GrpcRouteMatchOptions): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RouteMatch_GrpcRouteMatchOptions>, I>>(
    base?: I,
  ): RouteMatch_GrpcRouteMatchOptions {
    return RouteMatch_GrpcRouteMatchOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RouteMatch_GrpcRouteMatchOptions>, I>>(
    _: I,
  ): RouteMatch_GrpcRouteMatchOptions {
    const message = createBaseRouteMatch_GrpcRouteMatchOptions();
    return message;
  },
};

messageTypeRegistry.set(RouteMatch_GrpcRouteMatchOptions.$type, RouteMatch_GrpcRouteMatchOptions);

function createBaseRouteMatch_TlsContextMatchOptions(): RouteMatch_TlsContextMatchOptions {
  return { $type: "envoy.config.route.v3.RouteMatch.TlsContextMatchOptions" };
}

export const RouteMatch_TlsContextMatchOptions: MessageFns<
  RouteMatch_TlsContextMatchOptions,
  "envoy.config.route.v3.RouteMatch.TlsContextMatchOptions"
> = {
  $type: "envoy.config.route.v3.RouteMatch.TlsContextMatchOptions" as const,

  encode(message: RouteMatch_TlsContextMatchOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.presented !== undefined) {
      BoolValue.encode({ $type: "google.protobuf.BoolValue", value: message.presented! }, writer.uint32(10).fork())
        .join();
    }
    if (message.validated !== undefined) {
      BoolValue.encode({ $type: "google.protobuf.BoolValue", value: message.validated! }, writer.uint32(18).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteMatch_TlsContextMatchOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteMatch_TlsContextMatchOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.presented = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.validated = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteMatch_TlsContextMatchOptions {
    return {
      $type: RouteMatch_TlsContextMatchOptions.$type,
      presented: isSet(object.presented) ? Boolean(object.presented) : undefined,
      validated: isSet(object.validated) ? Boolean(object.validated) : undefined,
    };
  },

  toJSON(message: RouteMatch_TlsContextMatchOptions): unknown {
    const obj: any = {};
    if (message.presented !== undefined) {
      obj.presented = message.presented;
    }
    if (message.validated !== undefined) {
      obj.validated = message.validated;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RouteMatch_TlsContextMatchOptions>, I>>(
    base?: I,
  ): RouteMatch_TlsContextMatchOptions {
    return RouteMatch_TlsContextMatchOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RouteMatch_TlsContextMatchOptions>, I>>(
    object: I,
  ): RouteMatch_TlsContextMatchOptions {
    const message = createBaseRouteMatch_TlsContextMatchOptions();
    message.presented = object.presented ?? undefined;
    message.validated = object.validated ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RouteMatch_TlsContextMatchOptions.$type, RouteMatch_TlsContextMatchOptions);

function createBaseRouteMatch_ConnectMatcher(): RouteMatch_ConnectMatcher {
  return { $type: "envoy.config.route.v3.RouteMatch.ConnectMatcher" };
}

export const RouteMatch_ConnectMatcher: MessageFns<
  RouteMatch_ConnectMatcher,
  "envoy.config.route.v3.RouteMatch.ConnectMatcher"
> = {
  $type: "envoy.config.route.v3.RouteMatch.ConnectMatcher" as const,

  encode(_: RouteMatch_ConnectMatcher, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteMatch_ConnectMatcher {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteMatch_ConnectMatcher();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RouteMatch_ConnectMatcher {
    return { $type: RouteMatch_ConnectMatcher.$type };
  },

  toJSON(_: RouteMatch_ConnectMatcher): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RouteMatch_ConnectMatcher>, I>>(base?: I): RouteMatch_ConnectMatcher {
    return RouteMatch_ConnectMatcher.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RouteMatch_ConnectMatcher>, I>>(_: I): RouteMatch_ConnectMatcher {
    const message = createBaseRouteMatch_ConnectMatcher();
    return message;
  },
};

messageTypeRegistry.set(RouteMatch_ConnectMatcher.$type, RouteMatch_ConnectMatcher);

function createBaseCorsPolicy(): CorsPolicy {
  return { $type: "envoy.config.route.v3.CorsPolicy", enabled_specifier: undefined };
}

export const CorsPolicy: MessageFns<CorsPolicy, "envoy.config.route.v3.CorsPolicy"> = {
  $type: "envoy.config.route.v3.CorsPolicy" as const,

  encode(message: CorsPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.allow_origin_string_match !== undefined && message.allow_origin_string_match.length !== 0) {
      for (const v of message.allow_origin_string_match) {
        StringMatcher.encode(v!, writer.uint32(90).fork()).join();
      }
    }
    if (message.allow_methods !== undefined && message.allow_methods !== "") {
      writer.uint32(18).string(message.allow_methods);
    }
    if (message.allow_headers !== undefined && message.allow_headers !== "") {
      writer.uint32(26).string(message.allow_headers);
    }
    if (message.expose_headers !== undefined && message.expose_headers !== "") {
      writer.uint32(34).string(message.expose_headers);
    }
    if (message.max_age !== undefined && message.max_age !== "") {
      writer.uint32(42).string(message.max_age);
    }
    if (message.allow_credentials !== undefined) {
      BoolValue.encode(
        { $type: "google.protobuf.BoolValue", value: message.allow_credentials! },
        writer.uint32(50).fork(),
      ).join();
    }
    switch (message.enabled_specifier?.$case) {
      case "filter_enabled":
        RuntimeFractionalPercent.encode(message.enabled_specifier.filter_enabled, writer.uint32(74).fork()).join();
        break;
    }
    if (message.shadow_enabled !== undefined) {
      RuntimeFractionalPercent.encode(message.shadow_enabled, writer.uint32(82).fork()).join();
    }
    if (message.allow_private_network_access !== undefined) {
      BoolValue.encode(
        { $type: "google.protobuf.BoolValue", value: message.allow_private_network_access! },
        writer.uint32(98).fork(),
      ).join();
    }
    if (message.forward_not_matching_preflights !== undefined) {
      BoolValue.encode(
        { $type: "google.protobuf.BoolValue", value: message.forward_not_matching_preflights! },
        writer.uint32(106).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CorsPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCorsPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 11: {
          if (tag !== 90) {
            break;
          }

          if (message.allow_origin_string_match === undefined) {
            message.allow_origin_string_match = [];
          }
          const el = StringMatcher.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.allow_origin_string_match!.push(el);
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.allow_methods = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.allow_headers = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.expose_headers = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.max_age = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.allow_credentials = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.enabled_specifier = {
            $case: "filter_enabled",
            filter_enabled: RuntimeFractionalPercent.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.shadow_enabled = RuntimeFractionalPercent.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.allow_private_network_access = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.forward_not_matching_preflights = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CorsPolicy {
    return {
      $type: CorsPolicy.$type,
      allow_origin_string_match: globalThis.Array.isArray(object?.allow_origin_string_match)
        ? object.allow_origin_string_match.map((e: any) => StringMatcher.fromJSON(e))
        : undefined,
      allow_methods: isSet(object.allow_methods) ? globalThis.String(object.allow_methods) : undefined,
      allow_headers: isSet(object.allow_headers) ? globalThis.String(object.allow_headers) : undefined,
      expose_headers: isSet(object.expose_headers) ? globalThis.String(object.expose_headers) : undefined,
      max_age: isSet(object.max_age) ? globalThis.String(object.max_age) : undefined,
      allow_credentials: isSet(object.allow_credentials) ? Boolean(object.allow_credentials) : undefined,
      enabled_specifier: isSet(object.filter_enabled)
        ? { $case: "filter_enabled", filter_enabled: RuntimeFractionalPercent.fromJSON(object.filter_enabled) }
        : undefined,
      shadow_enabled: isSet(object.shadow_enabled)
        ? RuntimeFractionalPercent.fromJSON(object.shadow_enabled)
        : undefined,
      allow_private_network_access: isSet(object.allow_private_network_access)
        ? Boolean(object.allow_private_network_access)
        : undefined,
      forward_not_matching_preflights: isSet(object.forward_not_matching_preflights)
        ? Boolean(object.forward_not_matching_preflights)
        : undefined,
    };
  },

  toJSON(message: CorsPolicy): unknown {
    const obj: any = {};
    if (message.allow_origin_string_match?.length) {
      obj.allow_origin_string_match = message.allow_origin_string_match.map((e) => StringMatcher.toJSON(e));
    }
    if (message.allow_methods !== undefined) {
      obj.allow_methods = message.allow_methods;
    }
    if (message.allow_headers !== undefined) {
      obj.allow_headers = message.allow_headers;
    }
    if (message.expose_headers !== undefined) {
      obj.expose_headers = message.expose_headers;
    }
    if (message.max_age !== undefined) {
      obj.max_age = message.max_age;
    }
    if (message.allow_credentials !== undefined) {
      obj.allow_credentials = message.allow_credentials;
    }
    if (message.enabled_specifier?.$case === "filter_enabled") {
      obj.filter_enabled = RuntimeFractionalPercent.toJSON(message.enabled_specifier.filter_enabled);
    }
    if (message.shadow_enabled !== undefined) {
      obj.shadow_enabled = RuntimeFractionalPercent.toJSON(message.shadow_enabled);
    }
    if (message.allow_private_network_access !== undefined) {
      obj.allow_private_network_access = message.allow_private_network_access;
    }
    if (message.forward_not_matching_preflights !== undefined) {
      obj.forward_not_matching_preflights = message.forward_not_matching_preflights;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CorsPolicy>, I>>(base?: I): CorsPolicy {
    return CorsPolicy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CorsPolicy>, I>>(object: I): CorsPolicy {
    const message = createBaseCorsPolicy();
    message.allow_origin_string_match = object.allow_origin_string_match?.map((e) => StringMatcher.fromPartial(e)) ||
      undefined;
    message.allow_methods = object.allow_methods ?? undefined;
    message.allow_headers = object.allow_headers ?? undefined;
    message.expose_headers = object.expose_headers ?? undefined;
    message.max_age = object.max_age ?? undefined;
    message.allow_credentials = object.allow_credentials ?? undefined;
    if (
      object.enabled_specifier?.$case === "filter_enabled" &&
      object.enabled_specifier?.filter_enabled !== undefined &&
      object.enabled_specifier?.filter_enabled !== null
    ) {
      message.enabled_specifier = {
        $case: "filter_enabled",
        filter_enabled: RuntimeFractionalPercent.fromPartial(object.enabled_specifier.filter_enabled),
      };
    }
    message.shadow_enabled = (object.shadow_enabled !== undefined && object.shadow_enabled !== null)
      ? RuntimeFractionalPercent.fromPartial(object.shadow_enabled)
      : undefined;
    message.allow_private_network_access = object.allow_private_network_access ?? undefined;
    message.forward_not_matching_preflights = object.forward_not_matching_preflights ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(CorsPolicy.$type, CorsPolicy);

function createBaseRouteAction(): RouteAction {
  return {
    $type: "envoy.config.route.v3.RouteAction",
    cluster_specifier: undefined,
    host_rewrite_specifier: undefined,
  };
}

export const RouteAction: MessageFns<RouteAction, "envoy.config.route.v3.RouteAction"> = {
  $type: "envoy.config.route.v3.RouteAction" as const,

  encode(message: RouteAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.cluster_specifier?.$case) {
      case "cluster":
        writer.uint32(10).string(message.cluster_specifier.cluster);
        break;
      case "cluster_header":
        writer.uint32(18).string(message.cluster_specifier.cluster_header);
        break;
      case "weighted_clusters":
        WeightedCluster.encode(message.cluster_specifier.weighted_clusters, writer.uint32(26).fork()).join();
        break;
      case "cluster_specifier_plugin":
        writer.uint32(298).string(message.cluster_specifier.cluster_specifier_plugin);
        break;
      case "inline_cluster_specifier_plugin":
        ClusterSpecifierPlugin.encode(
          message.cluster_specifier.inline_cluster_specifier_plugin,
          writer.uint32(314).fork(),
        ).join();
        break;
    }
    if (
      message.cluster_not_found_response_code !== undefined &&
      message.cluster_not_found_response_code !== RouteAction_ClusterNotFoundResponseCode.SERVICE_UNAVAILABLE
    ) {
      writer.uint32(160).int32(
        routeAction_ClusterNotFoundResponseCodeToNumber(message.cluster_not_found_response_code),
      );
    }
    if (message.metadata_match !== undefined) {
      Metadata.encode(message.metadata_match, writer.uint32(34).fork()).join();
    }
    if (message.prefix_rewrite !== undefined && message.prefix_rewrite !== "") {
      writer.uint32(42).string(message.prefix_rewrite);
    }
    if (message.regex_rewrite !== undefined) {
      RegexMatchAndSubstitute.encode(message.regex_rewrite, writer.uint32(258).fork()).join();
    }
    if (message.path_rewrite_policy !== undefined) {
      TypedExtensionConfig.encode(message.path_rewrite_policy, writer.uint32(330).fork()).join();
    }
    switch (message.host_rewrite_specifier?.$case) {
      case "host_rewrite_literal":
        writer.uint32(50).string(message.host_rewrite_specifier.host_rewrite_literal);
        break;
      case "auto_host_rewrite":
        BoolValue.encode({
          $type: "google.protobuf.BoolValue",
          value: message.host_rewrite_specifier.auto_host_rewrite!,
        }, writer.uint32(58).fork()).join();
        break;
      case "host_rewrite_header":
        writer.uint32(234).string(message.host_rewrite_specifier.host_rewrite_header);
        break;
      case "host_rewrite_path_regex":
        RegexMatchAndSubstitute.encode(
          message.host_rewrite_specifier.host_rewrite_path_regex,
          writer.uint32(282).fork(),
        ).join();
        break;
    }
    if (message.append_x_forwarded_host !== undefined && message.append_x_forwarded_host !== false) {
      writer.uint32(304).bool(message.append_x_forwarded_host);
    }
    if (message.timeout !== undefined) {
      Duration.encode(message.timeout, writer.uint32(66).fork()).join();
    }
    if (message.idle_timeout !== undefined) {
      Duration.encode(message.idle_timeout, writer.uint32(194).fork()).join();
    }
    if (message.early_data_policy !== undefined) {
      TypedExtensionConfig.encode(message.early_data_policy, writer.uint32(322).fork()).join();
    }
    if (message.retry_policy !== undefined) {
      RetryPolicy.encode(message.retry_policy, writer.uint32(74).fork()).join();
    }
    if (message.retry_policy_typed_config !== undefined) {
      Any.encode(message.retry_policy_typed_config, writer.uint32(266).fork()).join();
    }
    if (message.request_mirror_policies !== undefined && message.request_mirror_policies.length !== 0) {
      for (const v of message.request_mirror_policies) {
        RouteAction_RequestMirrorPolicy.encode(v!, writer.uint32(242).fork()).join();
      }
    }
    if (message.priority !== undefined && message.priority !== RoutingPriority.DEFAULT) {
      writer.uint32(88).int32(routingPriorityToNumber(message.priority));
    }
    if (message.rate_limits !== undefined && message.rate_limits.length !== 0) {
      for (const v of message.rate_limits) {
        RateLimit.encode(v!, writer.uint32(106).fork()).join();
      }
    }
    if (message.include_vh_rate_limits !== undefined) {
      BoolValue.encode(
        { $type: "google.protobuf.BoolValue", value: message.include_vh_rate_limits! },
        writer.uint32(114).fork(),
      ).join();
    }
    if (message.hash_policy !== undefined && message.hash_policy.length !== 0) {
      for (const v of message.hash_policy) {
        RouteAction_HashPolicy.encode(v!, writer.uint32(122).fork()).join();
      }
    }
    if (message.cors !== undefined) {
      CorsPolicy.encode(message.cors, writer.uint32(138).fork()).join();
    }
    if (message.max_grpc_timeout !== undefined) {
      Duration.encode(message.max_grpc_timeout, writer.uint32(186).fork()).join();
    }
    if (message.grpc_timeout_offset !== undefined) {
      Duration.encode(message.grpc_timeout_offset, writer.uint32(226).fork()).join();
    }
    if (message.upgrade_configs !== undefined && message.upgrade_configs.length !== 0) {
      for (const v of message.upgrade_configs) {
        RouteAction_UpgradeConfig.encode(v!, writer.uint32(202).fork()).join();
      }
    }
    if (message.internal_redirect_policy !== undefined) {
      InternalRedirectPolicy.encode(message.internal_redirect_policy, writer.uint32(274).fork()).join();
    }
    if (
      message.internal_redirect_action !== undefined &&
      message.internal_redirect_action !== RouteAction_InternalRedirectAction.PASS_THROUGH_INTERNAL_REDIRECT
    ) {
      writer.uint32(208).int32(routeAction_InternalRedirectActionToNumber(message.internal_redirect_action));
    }
    if (message.max_internal_redirects !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.max_internal_redirects! },
        writer.uint32(250).fork(),
      ).join();
    }
    if (message.hedge_policy !== undefined) {
      HedgePolicy.encode(message.hedge_policy, writer.uint32(218).fork()).join();
    }
    if (message.max_stream_duration !== undefined) {
      RouteAction_MaxStreamDuration.encode(message.max_stream_duration, writer.uint32(290).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cluster_specifier = { $case: "cluster", cluster: reader.string() };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cluster_specifier = { $case: "cluster_header", cluster_header: reader.string() };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.cluster_specifier = {
            $case: "weighted_clusters",
            weighted_clusters: WeightedCluster.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 37: {
          if (tag !== 298) {
            break;
          }

          message.cluster_specifier = { $case: "cluster_specifier_plugin", cluster_specifier_plugin: reader.string() };
          continue;
        }
        case 39: {
          if (tag !== 314) {
            break;
          }

          message.cluster_specifier = {
            $case: "inline_cluster_specifier_plugin",
            inline_cluster_specifier_plugin: ClusterSpecifierPlugin.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.cluster_not_found_response_code = routeAction_ClusterNotFoundResponseCodeFromJSON(reader.int32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata_match = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.prefix_rewrite = reader.string();
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.regex_rewrite = RegexMatchAndSubstitute.decode(reader, reader.uint32());
          continue;
        }
        case 41: {
          if (tag !== 330) {
            break;
          }

          message.path_rewrite_policy = TypedExtensionConfig.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.host_rewrite_specifier = { $case: "host_rewrite_literal", host_rewrite_literal: reader.string() };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.host_rewrite_specifier = {
            $case: "auto_host_rewrite",
            auto_host_rewrite: BoolValue.decode(reader, reader.uint32()).value,
          };
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.host_rewrite_specifier = { $case: "host_rewrite_header", host_rewrite_header: reader.string() };
          continue;
        }
        case 35: {
          if (tag !== 282) {
            break;
          }

          message.host_rewrite_specifier = {
            $case: "host_rewrite_path_regex",
            host_rewrite_path_regex: RegexMatchAndSubstitute.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 38: {
          if (tag !== 304) {
            break;
          }

          message.append_x_forwarded_host = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.idle_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 40: {
          if (tag !== 322) {
            break;
          }

          message.early_data_policy = TypedExtensionConfig.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.retry_policy = RetryPolicy.decode(reader, reader.uint32());
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }

          message.retry_policy_typed_config = Any.decode(reader, reader.uint32());
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          if (message.request_mirror_policies === undefined) {
            message.request_mirror_policies = [];
          }
          const el = RouteAction_RequestMirrorPolicy.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.request_mirror_policies!.push(el);
          }
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.priority = routingPriorityFromJSON(reader.int32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          if (message.rate_limits === undefined) {
            message.rate_limits = [];
          }
          const el = RateLimit.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.rate_limits!.push(el);
          }
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.include_vh_rate_limits = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          if (message.hash_policy === undefined) {
            message.hash_policy = [];
          }
          const el = RouteAction_HashPolicy.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.hash_policy!.push(el);
          }
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.cors = CorsPolicy.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.max_grpc_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.grpc_timeout_offset = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          if (message.upgrade_configs === undefined) {
            message.upgrade_configs = [];
          }
          const el = RouteAction_UpgradeConfig.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.upgrade_configs!.push(el);
          }
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          message.internal_redirect_policy = InternalRedirectPolicy.decode(reader, reader.uint32());
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.internal_redirect_action = routeAction_InternalRedirectActionFromJSON(reader.int32());
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.max_internal_redirects = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.hedge_policy = HedgePolicy.decode(reader, reader.uint32());
          continue;
        }
        case 36: {
          if (tag !== 290) {
            break;
          }

          message.max_stream_duration = RouteAction_MaxStreamDuration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteAction {
    return {
      $type: RouteAction.$type,
      cluster_specifier: isSet(object.cluster)
        ? { $case: "cluster", cluster: globalThis.String(object.cluster) }
        : isSet(object.cluster_header)
        ? { $case: "cluster_header", cluster_header: globalThis.String(object.cluster_header) }
        : isSet(object.weighted_clusters)
        ? { $case: "weighted_clusters", weighted_clusters: WeightedCluster.fromJSON(object.weighted_clusters) }
        : isSet(object.cluster_specifier_plugin)
        ? {
          $case: "cluster_specifier_plugin",
          cluster_specifier_plugin: globalThis.String(object.cluster_specifier_plugin),
        }
        : isSet(object.inline_cluster_specifier_plugin)
        ? {
          $case: "inline_cluster_specifier_plugin",
          inline_cluster_specifier_plugin: ClusterSpecifierPlugin.fromJSON(object.inline_cluster_specifier_plugin),
        }
        : undefined,
      cluster_not_found_response_code: isSet(object.cluster_not_found_response_code)
        ? routeAction_ClusterNotFoundResponseCodeFromJSON(object.cluster_not_found_response_code)
        : undefined,
      metadata_match: isSet(object.metadata_match) ? Metadata.fromJSON(object.metadata_match) : undefined,
      prefix_rewrite: isSet(object.prefix_rewrite) ? globalThis.String(object.prefix_rewrite) : undefined,
      regex_rewrite: isSet(object.regex_rewrite) ? RegexMatchAndSubstitute.fromJSON(object.regex_rewrite) : undefined,
      path_rewrite_policy: isSet(object.path_rewrite_policy)
        ? TypedExtensionConfig.fromJSON(object.path_rewrite_policy)
        : undefined,
      host_rewrite_specifier: isSet(object.host_rewrite_literal)
        ? { $case: "host_rewrite_literal", host_rewrite_literal: globalThis.String(object.host_rewrite_literal) }
        : isSet(object.auto_host_rewrite)
        ? { $case: "auto_host_rewrite", auto_host_rewrite: Boolean(object.auto_host_rewrite) }
        : isSet(object.host_rewrite_header)
        ? { $case: "host_rewrite_header", host_rewrite_header: globalThis.String(object.host_rewrite_header) }
        : isSet(object.host_rewrite_path_regex)
        ? {
          $case: "host_rewrite_path_regex",
          host_rewrite_path_regex: RegexMatchAndSubstitute.fromJSON(object.host_rewrite_path_regex),
        }
        : undefined,
      append_x_forwarded_host: isSet(object.append_x_forwarded_host)
        ? globalThis.Boolean(object.append_x_forwarded_host)
        : undefined,
      timeout: isSet(object.timeout) ? Duration.fromJSON(object.timeout) : undefined,
      idle_timeout: isSet(object.idle_timeout) ? Duration.fromJSON(object.idle_timeout) : undefined,
      early_data_policy: isSet(object.early_data_policy)
        ? TypedExtensionConfig.fromJSON(object.early_data_policy)
        : undefined,
      retry_policy: isSet(object.retry_policy) ? RetryPolicy.fromJSON(object.retry_policy) : undefined,
      retry_policy_typed_config: isSet(object.retry_policy_typed_config)
        ? Any.fromJSON(object.retry_policy_typed_config)
        : undefined,
      request_mirror_policies: globalThis.Array.isArray(object?.request_mirror_policies)
        ? object.request_mirror_policies.map((e: any) => RouteAction_RequestMirrorPolicy.fromJSON(e))
        : undefined,
      priority: isSet(object.priority) ? routingPriorityFromJSON(object.priority) : undefined,
      rate_limits: globalThis.Array.isArray(object?.rate_limits)
        ? object.rate_limits.map((e: any) => RateLimit.fromJSON(e))
        : undefined,
      include_vh_rate_limits: isSet(object.include_vh_rate_limits) ? Boolean(object.include_vh_rate_limits) : undefined,
      hash_policy: globalThis.Array.isArray(object?.hash_policy)
        ? object.hash_policy.map((e: any) => RouteAction_HashPolicy.fromJSON(e))
        : undefined,
      cors: isSet(object.cors) ? CorsPolicy.fromJSON(object.cors) : undefined,
      max_grpc_timeout: isSet(object.max_grpc_timeout) ? Duration.fromJSON(object.max_grpc_timeout) : undefined,
      grpc_timeout_offset: isSet(object.grpc_timeout_offset)
        ? Duration.fromJSON(object.grpc_timeout_offset)
        : undefined,
      upgrade_configs: globalThis.Array.isArray(object?.upgrade_configs)
        ? object.upgrade_configs.map((e: any) => RouteAction_UpgradeConfig.fromJSON(e))
        : undefined,
      internal_redirect_policy: isSet(object.internal_redirect_policy)
        ? InternalRedirectPolicy.fromJSON(object.internal_redirect_policy)
        : undefined,
      internal_redirect_action: isSet(object.internal_redirect_action)
        ? routeAction_InternalRedirectActionFromJSON(object.internal_redirect_action)
        : undefined,
      max_internal_redirects: isSet(object.max_internal_redirects) ? Number(object.max_internal_redirects) : undefined,
      hedge_policy: isSet(object.hedge_policy) ? HedgePolicy.fromJSON(object.hedge_policy) : undefined,
      max_stream_duration: isSet(object.max_stream_duration)
        ? RouteAction_MaxStreamDuration.fromJSON(object.max_stream_duration)
        : undefined,
    };
  },

  toJSON(message: RouteAction): unknown {
    const obj: any = {};
    if (message.cluster_specifier?.$case === "cluster") {
      obj.cluster = message.cluster_specifier.cluster;
    }
    if (message.cluster_specifier?.$case === "cluster_header") {
      obj.cluster_header = message.cluster_specifier.cluster_header;
    }
    if (message.cluster_specifier?.$case === "weighted_clusters") {
      obj.weighted_clusters = WeightedCluster.toJSON(message.cluster_specifier.weighted_clusters);
    }
    if (message.cluster_specifier?.$case === "cluster_specifier_plugin") {
      obj.cluster_specifier_plugin = message.cluster_specifier.cluster_specifier_plugin;
    }
    if (message.cluster_specifier?.$case === "inline_cluster_specifier_plugin") {
      obj.inline_cluster_specifier_plugin = ClusterSpecifierPlugin.toJSON(
        message.cluster_specifier.inline_cluster_specifier_plugin,
      );
    }
    if (message.cluster_not_found_response_code !== undefined) {
      obj.cluster_not_found_response_code = routeAction_ClusterNotFoundResponseCodeToJSON(
        message.cluster_not_found_response_code,
      );
    }
    if (message.metadata_match !== undefined) {
      obj.metadata_match = Metadata.toJSON(message.metadata_match);
    }
    if (message.prefix_rewrite !== undefined) {
      obj.prefix_rewrite = message.prefix_rewrite;
    }
    if (message.regex_rewrite !== undefined) {
      obj.regex_rewrite = RegexMatchAndSubstitute.toJSON(message.regex_rewrite);
    }
    if (message.path_rewrite_policy !== undefined) {
      obj.path_rewrite_policy = TypedExtensionConfig.toJSON(message.path_rewrite_policy);
    }
    if (message.host_rewrite_specifier?.$case === "host_rewrite_literal") {
      obj.host_rewrite_literal = message.host_rewrite_specifier.host_rewrite_literal;
    }
    if (message.host_rewrite_specifier?.$case === "auto_host_rewrite") {
      obj.auto_host_rewrite = message.host_rewrite_specifier.auto_host_rewrite;
    }
    if (message.host_rewrite_specifier?.$case === "host_rewrite_header") {
      obj.host_rewrite_header = message.host_rewrite_specifier.host_rewrite_header;
    }
    if (message.host_rewrite_specifier?.$case === "host_rewrite_path_regex") {
      obj.host_rewrite_path_regex = RegexMatchAndSubstitute.toJSON(
        message.host_rewrite_specifier.host_rewrite_path_regex,
      );
    }
    if (message.append_x_forwarded_host !== undefined) {
      obj.append_x_forwarded_host = message.append_x_forwarded_host;
    }
    if (message.timeout !== undefined) {
      obj.timeout = Duration.toJSON(message.timeout);
    }
    if (message.idle_timeout !== undefined) {
      obj.idle_timeout = Duration.toJSON(message.idle_timeout);
    }
    if (message.early_data_policy !== undefined) {
      obj.early_data_policy = TypedExtensionConfig.toJSON(message.early_data_policy);
    }
    if (message.retry_policy !== undefined) {
      obj.retry_policy = RetryPolicy.toJSON(message.retry_policy);
    }
    if (message.retry_policy_typed_config !== undefined) {
      obj.retry_policy_typed_config = Any.toJSON(message.retry_policy_typed_config);
    }
    if (message.request_mirror_policies?.length) {
      obj.request_mirror_policies = message.request_mirror_policies.map((e) =>
        RouteAction_RequestMirrorPolicy.toJSON(e)
      );
    }
    if (message.priority !== undefined) {
      obj.priority = routingPriorityToJSON(message.priority);
    }
    if (message.rate_limits?.length) {
      obj.rate_limits = message.rate_limits.map((e) => RateLimit.toJSON(e));
    }
    if (message.include_vh_rate_limits !== undefined) {
      obj.include_vh_rate_limits = message.include_vh_rate_limits;
    }
    if (message.hash_policy?.length) {
      obj.hash_policy = message.hash_policy.map((e) => RouteAction_HashPolicy.toJSON(e));
    }
    if (message.cors !== undefined) {
      obj.cors = CorsPolicy.toJSON(message.cors);
    }
    if (message.max_grpc_timeout !== undefined) {
      obj.max_grpc_timeout = Duration.toJSON(message.max_grpc_timeout);
    }
    if (message.grpc_timeout_offset !== undefined) {
      obj.grpc_timeout_offset = Duration.toJSON(message.grpc_timeout_offset);
    }
    if (message.upgrade_configs?.length) {
      obj.upgrade_configs = message.upgrade_configs.map((e) => RouteAction_UpgradeConfig.toJSON(e));
    }
    if (message.internal_redirect_policy !== undefined) {
      obj.internal_redirect_policy = InternalRedirectPolicy.toJSON(message.internal_redirect_policy);
    }
    if (message.internal_redirect_action !== undefined) {
      obj.internal_redirect_action = routeAction_InternalRedirectActionToJSON(message.internal_redirect_action);
    }
    if (message.max_internal_redirects !== undefined) {
      obj.max_internal_redirects = message.max_internal_redirects;
    }
    if (message.hedge_policy !== undefined) {
      obj.hedge_policy = HedgePolicy.toJSON(message.hedge_policy);
    }
    if (message.max_stream_duration !== undefined) {
      obj.max_stream_duration = RouteAction_MaxStreamDuration.toJSON(message.max_stream_duration);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RouteAction>, I>>(base?: I): RouteAction {
    return RouteAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RouteAction>, I>>(object: I): RouteAction {
    const message = createBaseRouteAction();
    if (
      object.cluster_specifier?.$case === "cluster" &&
      object.cluster_specifier?.cluster !== undefined &&
      object.cluster_specifier?.cluster !== null
    ) {
      message.cluster_specifier = { $case: "cluster", cluster: object.cluster_specifier.cluster };
    }
    if (
      object.cluster_specifier?.$case === "cluster_header" &&
      object.cluster_specifier?.cluster_header !== undefined &&
      object.cluster_specifier?.cluster_header !== null
    ) {
      message.cluster_specifier = { $case: "cluster_header", cluster_header: object.cluster_specifier.cluster_header };
    }
    if (
      object.cluster_specifier?.$case === "weighted_clusters" &&
      object.cluster_specifier?.weighted_clusters !== undefined &&
      object.cluster_specifier?.weighted_clusters !== null
    ) {
      message.cluster_specifier = {
        $case: "weighted_clusters",
        weighted_clusters: WeightedCluster.fromPartial(object.cluster_specifier.weighted_clusters),
      };
    }
    if (
      object.cluster_specifier?.$case === "cluster_specifier_plugin" &&
      object.cluster_specifier?.cluster_specifier_plugin !== undefined &&
      object.cluster_specifier?.cluster_specifier_plugin !== null
    ) {
      message.cluster_specifier = {
        $case: "cluster_specifier_plugin",
        cluster_specifier_plugin: object.cluster_specifier.cluster_specifier_plugin,
      };
    }
    if (
      object.cluster_specifier?.$case === "inline_cluster_specifier_plugin" &&
      object.cluster_specifier?.inline_cluster_specifier_plugin !== undefined &&
      object.cluster_specifier?.inline_cluster_specifier_plugin !== null
    ) {
      message.cluster_specifier = {
        $case: "inline_cluster_specifier_plugin",
        inline_cluster_specifier_plugin: ClusterSpecifierPlugin.fromPartial(
          object.cluster_specifier.inline_cluster_specifier_plugin,
        ),
      };
    }
    message.cluster_not_found_response_code = object.cluster_not_found_response_code ?? undefined;
    message.metadata_match = (object.metadata_match !== undefined && object.metadata_match !== null)
      ? Metadata.fromPartial(object.metadata_match)
      : undefined;
    message.prefix_rewrite = object.prefix_rewrite ?? undefined;
    message.regex_rewrite = (object.regex_rewrite !== undefined && object.regex_rewrite !== null)
      ? RegexMatchAndSubstitute.fromPartial(object.regex_rewrite)
      : undefined;
    message.path_rewrite_policy = (object.path_rewrite_policy !== undefined && object.path_rewrite_policy !== null)
      ? TypedExtensionConfig.fromPartial(object.path_rewrite_policy)
      : undefined;
    if (
      object.host_rewrite_specifier?.$case === "host_rewrite_literal" &&
      object.host_rewrite_specifier?.host_rewrite_literal !== undefined &&
      object.host_rewrite_specifier?.host_rewrite_literal !== null
    ) {
      message.host_rewrite_specifier = {
        $case: "host_rewrite_literal",
        host_rewrite_literal: object.host_rewrite_specifier.host_rewrite_literal,
      };
    }
    if (
      object.host_rewrite_specifier?.$case === "auto_host_rewrite" &&
      object.host_rewrite_specifier?.auto_host_rewrite !== undefined &&
      object.host_rewrite_specifier?.auto_host_rewrite !== null
    ) {
      message.host_rewrite_specifier = {
        $case: "auto_host_rewrite",
        auto_host_rewrite: object.host_rewrite_specifier.auto_host_rewrite,
      };
    }
    if (
      object.host_rewrite_specifier?.$case === "host_rewrite_header" &&
      object.host_rewrite_specifier?.host_rewrite_header !== undefined &&
      object.host_rewrite_specifier?.host_rewrite_header !== null
    ) {
      message.host_rewrite_specifier = {
        $case: "host_rewrite_header",
        host_rewrite_header: object.host_rewrite_specifier.host_rewrite_header,
      };
    }
    if (
      object.host_rewrite_specifier?.$case === "host_rewrite_path_regex" &&
      object.host_rewrite_specifier?.host_rewrite_path_regex !== undefined &&
      object.host_rewrite_specifier?.host_rewrite_path_regex !== null
    ) {
      message.host_rewrite_specifier = {
        $case: "host_rewrite_path_regex",
        host_rewrite_path_regex: RegexMatchAndSubstitute.fromPartial(
          object.host_rewrite_specifier.host_rewrite_path_regex,
        ),
      };
    }
    message.append_x_forwarded_host = object.append_x_forwarded_host ?? undefined;
    message.timeout = (object.timeout !== undefined && object.timeout !== null)
      ? Duration.fromPartial(object.timeout)
      : undefined;
    message.idle_timeout = (object.idle_timeout !== undefined && object.idle_timeout !== null)
      ? Duration.fromPartial(object.idle_timeout)
      : undefined;
    message.early_data_policy = (object.early_data_policy !== undefined && object.early_data_policy !== null)
      ? TypedExtensionConfig.fromPartial(object.early_data_policy)
      : undefined;
    message.retry_policy = (object.retry_policy !== undefined && object.retry_policy !== null)
      ? RetryPolicy.fromPartial(object.retry_policy)
      : undefined;
    message.retry_policy_typed_config =
      (object.retry_policy_typed_config !== undefined && object.retry_policy_typed_config !== null)
        ? Any.fromPartial(object.retry_policy_typed_config)
        : undefined;
    message.request_mirror_policies =
      object.request_mirror_policies?.map((e) => RouteAction_RequestMirrorPolicy.fromPartial(e)) || undefined;
    message.priority = object.priority ?? undefined;
    message.rate_limits = object.rate_limits?.map((e) => RateLimit.fromPartial(e)) || undefined;
    message.include_vh_rate_limits = object.include_vh_rate_limits ?? undefined;
    message.hash_policy = object.hash_policy?.map((e) => RouteAction_HashPolicy.fromPartial(e)) || undefined;
    message.cors = (object.cors !== undefined && object.cors !== null)
      ? CorsPolicy.fromPartial(object.cors)
      : undefined;
    message.max_grpc_timeout = (object.max_grpc_timeout !== undefined && object.max_grpc_timeout !== null)
      ? Duration.fromPartial(object.max_grpc_timeout)
      : undefined;
    message.grpc_timeout_offset = (object.grpc_timeout_offset !== undefined && object.grpc_timeout_offset !== null)
      ? Duration.fromPartial(object.grpc_timeout_offset)
      : undefined;
    message.upgrade_configs = object.upgrade_configs?.map((e) => RouteAction_UpgradeConfig.fromPartial(e)) || undefined;
    message.internal_redirect_policy =
      (object.internal_redirect_policy !== undefined && object.internal_redirect_policy !== null)
        ? InternalRedirectPolicy.fromPartial(object.internal_redirect_policy)
        : undefined;
    message.internal_redirect_action = object.internal_redirect_action ?? undefined;
    message.max_internal_redirects = object.max_internal_redirects ?? undefined;
    message.hedge_policy = (object.hedge_policy !== undefined && object.hedge_policy !== null)
      ? HedgePolicy.fromPartial(object.hedge_policy)
      : undefined;
    message.max_stream_duration = (object.max_stream_duration !== undefined && object.max_stream_duration !== null)
      ? RouteAction_MaxStreamDuration.fromPartial(object.max_stream_duration)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(RouteAction.$type, RouteAction);

function createBaseRouteAction_RequestMirrorPolicy(): RouteAction_RequestMirrorPolicy {
  return { $type: "envoy.config.route.v3.RouteAction.RequestMirrorPolicy" };
}

export const RouteAction_RequestMirrorPolicy: MessageFns<
  RouteAction_RequestMirrorPolicy,
  "envoy.config.route.v3.RouteAction.RequestMirrorPolicy"
> = {
  $type: "envoy.config.route.v3.RouteAction.RequestMirrorPolicy" as const,

  encode(message: RouteAction_RequestMirrorPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cluster !== undefined && message.cluster !== "") {
      writer.uint32(10).string(message.cluster);
    }
    if (message.cluster_header !== undefined && message.cluster_header !== "") {
      writer.uint32(42).string(message.cluster_header);
    }
    if (message.runtime_fraction !== undefined) {
      RuntimeFractionalPercent.encode(message.runtime_fraction, writer.uint32(26).fork()).join();
    }
    if (message.trace_sampled !== undefined) {
      BoolValue.encode({ $type: "google.protobuf.BoolValue", value: message.trace_sampled! }, writer.uint32(34).fork())
        .join();
    }
    if (
      message.disable_shadow_host_suffix_append !== undefined && message.disable_shadow_host_suffix_append !== false
    ) {
      writer.uint32(48).bool(message.disable_shadow_host_suffix_append);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteAction_RequestMirrorPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteAction_RequestMirrorPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cluster = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.cluster_header = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.runtime_fraction = RuntimeFractionalPercent.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.trace_sampled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.disable_shadow_host_suffix_append = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteAction_RequestMirrorPolicy {
    return {
      $type: RouteAction_RequestMirrorPolicy.$type,
      cluster: isSet(object.cluster) ? globalThis.String(object.cluster) : undefined,
      cluster_header: isSet(object.cluster_header) ? globalThis.String(object.cluster_header) : undefined,
      runtime_fraction: isSet(object.runtime_fraction)
        ? RuntimeFractionalPercent.fromJSON(object.runtime_fraction)
        : undefined,
      trace_sampled: isSet(object.trace_sampled) ? Boolean(object.trace_sampled) : undefined,
      disable_shadow_host_suffix_append: isSet(object.disable_shadow_host_suffix_append)
        ? globalThis.Boolean(object.disable_shadow_host_suffix_append)
        : undefined,
    };
  },

  toJSON(message: RouteAction_RequestMirrorPolicy): unknown {
    const obj: any = {};
    if (message.cluster !== undefined) {
      obj.cluster = message.cluster;
    }
    if (message.cluster_header !== undefined) {
      obj.cluster_header = message.cluster_header;
    }
    if (message.runtime_fraction !== undefined) {
      obj.runtime_fraction = RuntimeFractionalPercent.toJSON(message.runtime_fraction);
    }
    if (message.trace_sampled !== undefined) {
      obj.trace_sampled = message.trace_sampled;
    }
    if (message.disable_shadow_host_suffix_append !== undefined) {
      obj.disable_shadow_host_suffix_append = message.disable_shadow_host_suffix_append;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RouteAction_RequestMirrorPolicy>, I>>(base?: I): RouteAction_RequestMirrorPolicy {
    return RouteAction_RequestMirrorPolicy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RouteAction_RequestMirrorPolicy>, I>>(
    object: I,
  ): RouteAction_RequestMirrorPolicy {
    const message = createBaseRouteAction_RequestMirrorPolicy();
    message.cluster = object.cluster ?? undefined;
    message.cluster_header = object.cluster_header ?? undefined;
    message.runtime_fraction = (object.runtime_fraction !== undefined && object.runtime_fraction !== null)
      ? RuntimeFractionalPercent.fromPartial(object.runtime_fraction)
      : undefined;
    message.trace_sampled = object.trace_sampled ?? undefined;
    message.disable_shadow_host_suffix_append = object.disable_shadow_host_suffix_append ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RouteAction_RequestMirrorPolicy.$type, RouteAction_RequestMirrorPolicy);

function createBaseRouteAction_HashPolicy(): RouteAction_HashPolicy {
  return { $type: "envoy.config.route.v3.RouteAction.HashPolicy", policy_specifier: undefined };
}

export const RouteAction_HashPolicy: MessageFns<
  RouteAction_HashPolicy,
  "envoy.config.route.v3.RouteAction.HashPolicy"
> = {
  $type: "envoy.config.route.v3.RouteAction.HashPolicy" as const,

  encode(message: RouteAction_HashPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.policy_specifier?.$case) {
      case "header":
        RouteAction_HashPolicy_Header.encode(message.policy_specifier.header, writer.uint32(10).fork()).join();
        break;
      case "cookie":
        RouteAction_HashPolicy_Cookie.encode(message.policy_specifier.cookie, writer.uint32(18).fork()).join();
        break;
      case "connection_properties":
        RouteAction_HashPolicy_ConnectionProperties.encode(
          message.policy_specifier.connection_properties,
          writer.uint32(26).fork(),
        ).join();
        break;
      case "query_parameter":
        RouteAction_HashPolicy_QueryParameter.encode(message.policy_specifier.query_parameter, writer.uint32(42).fork())
          .join();
        break;
      case "filter_state":
        RouteAction_HashPolicy_FilterState.encode(message.policy_specifier.filter_state, writer.uint32(50).fork())
          .join();
        break;
    }
    if (message.terminal !== undefined && message.terminal !== false) {
      writer.uint32(32).bool(message.terminal);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteAction_HashPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteAction_HashPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.policy_specifier = {
            $case: "header",
            header: RouteAction_HashPolicy_Header.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.policy_specifier = {
            $case: "cookie",
            cookie: RouteAction_HashPolicy_Cookie.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.policy_specifier = {
            $case: "connection_properties",
            connection_properties: RouteAction_HashPolicy_ConnectionProperties.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.policy_specifier = {
            $case: "query_parameter",
            query_parameter: RouteAction_HashPolicy_QueryParameter.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.policy_specifier = {
            $case: "filter_state",
            filter_state: RouteAction_HashPolicy_FilterState.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.terminal = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteAction_HashPolicy {
    return {
      $type: RouteAction_HashPolicy.$type,
      policy_specifier: isSet(object.header)
        ? { $case: "header", header: RouteAction_HashPolicy_Header.fromJSON(object.header) }
        : isSet(object.cookie)
        ? { $case: "cookie", cookie: RouteAction_HashPolicy_Cookie.fromJSON(object.cookie) }
        : isSet(object.connection_properties)
        ? {
          $case: "connection_properties",
          connection_properties: RouteAction_HashPolicy_ConnectionProperties.fromJSON(object.connection_properties),
        }
        : isSet(object.query_parameter)
        ? {
          $case: "query_parameter",
          query_parameter: RouteAction_HashPolicy_QueryParameter.fromJSON(object.query_parameter),
        }
        : isSet(object.filter_state)
        ? { $case: "filter_state", filter_state: RouteAction_HashPolicy_FilterState.fromJSON(object.filter_state) }
        : undefined,
      terminal: isSet(object.terminal) ? globalThis.Boolean(object.terminal) : undefined,
    };
  },

  toJSON(message: RouteAction_HashPolicy): unknown {
    const obj: any = {};
    if (message.policy_specifier?.$case === "header") {
      obj.header = RouteAction_HashPolicy_Header.toJSON(message.policy_specifier.header);
    }
    if (message.policy_specifier?.$case === "cookie") {
      obj.cookie = RouteAction_HashPolicy_Cookie.toJSON(message.policy_specifier.cookie);
    }
    if (message.policy_specifier?.$case === "connection_properties") {
      obj.connection_properties = RouteAction_HashPolicy_ConnectionProperties.toJSON(
        message.policy_specifier.connection_properties,
      );
    }
    if (message.policy_specifier?.$case === "query_parameter") {
      obj.query_parameter = RouteAction_HashPolicy_QueryParameter.toJSON(message.policy_specifier.query_parameter);
    }
    if (message.policy_specifier?.$case === "filter_state") {
      obj.filter_state = RouteAction_HashPolicy_FilterState.toJSON(message.policy_specifier.filter_state);
    }
    if (message.terminal !== undefined) {
      obj.terminal = message.terminal;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RouteAction_HashPolicy>, I>>(base?: I): RouteAction_HashPolicy {
    return RouteAction_HashPolicy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RouteAction_HashPolicy>, I>>(object: I): RouteAction_HashPolicy {
    const message = createBaseRouteAction_HashPolicy();
    if (
      object.policy_specifier?.$case === "header" &&
      object.policy_specifier?.header !== undefined &&
      object.policy_specifier?.header !== null
    ) {
      message.policy_specifier = {
        $case: "header",
        header: RouteAction_HashPolicy_Header.fromPartial(object.policy_specifier.header),
      };
    }
    if (
      object.policy_specifier?.$case === "cookie" &&
      object.policy_specifier?.cookie !== undefined &&
      object.policy_specifier?.cookie !== null
    ) {
      message.policy_specifier = {
        $case: "cookie",
        cookie: RouteAction_HashPolicy_Cookie.fromPartial(object.policy_specifier.cookie),
      };
    }
    if (
      object.policy_specifier?.$case === "connection_properties" &&
      object.policy_specifier?.connection_properties !== undefined &&
      object.policy_specifier?.connection_properties !== null
    ) {
      message.policy_specifier = {
        $case: "connection_properties",
        connection_properties: RouteAction_HashPolicy_ConnectionProperties.fromPartial(
          object.policy_specifier.connection_properties,
        ),
      };
    }
    if (
      object.policy_specifier?.$case === "query_parameter" &&
      object.policy_specifier?.query_parameter !== undefined &&
      object.policy_specifier?.query_parameter !== null
    ) {
      message.policy_specifier = {
        $case: "query_parameter",
        query_parameter: RouteAction_HashPolicy_QueryParameter.fromPartial(object.policy_specifier.query_parameter),
      };
    }
    if (
      object.policy_specifier?.$case === "filter_state" &&
      object.policy_specifier?.filter_state !== undefined &&
      object.policy_specifier?.filter_state !== null
    ) {
      message.policy_specifier = {
        $case: "filter_state",
        filter_state: RouteAction_HashPolicy_FilterState.fromPartial(object.policy_specifier.filter_state),
      };
    }
    message.terminal = object.terminal ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RouteAction_HashPolicy.$type, RouteAction_HashPolicy);

function createBaseRouteAction_HashPolicy_Header(): RouteAction_HashPolicy_Header {
  return { $type: "envoy.config.route.v3.RouteAction.HashPolicy.Header" };
}

export const RouteAction_HashPolicy_Header: MessageFns<
  RouteAction_HashPolicy_Header,
  "envoy.config.route.v3.RouteAction.HashPolicy.Header"
> = {
  $type: "envoy.config.route.v3.RouteAction.HashPolicy.Header" as const,

  encode(message: RouteAction_HashPolicy_Header, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header_name !== undefined && message.header_name !== "") {
      writer.uint32(10).string(message.header_name);
    }
    if (message.regex_rewrite !== undefined) {
      RegexMatchAndSubstitute.encode(message.regex_rewrite, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteAction_HashPolicy_Header {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteAction_HashPolicy_Header();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header_name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.regex_rewrite = RegexMatchAndSubstitute.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteAction_HashPolicy_Header {
    return {
      $type: RouteAction_HashPolicy_Header.$type,
      header_name: isSet(object.header_name) ? globalThis.String(object.header_name) : undefined,
      regex_rewrite: isSet(object.regex_rewrite) ? RegexMatchAndSubstitute.fromJSON(object.regex_rewrite) : undefined,
    };
  },

  toJSON(message: RouteAction_HashPolicy_Header): unknown {
    const obj: any = {};
    if (message.header_name !== undefined) {
      obj.header_name = message.header_name;
    }
    if (message.regex_rewrite !== undefined) {
      obj.regex_rewrite = RegexMatchAndSubstitute.toJSON(message.regex_rewrite);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RouteAction_HashPolicy_Header>, I>>(base?: I): RouteAction_HashPolicy_Header {
    return RouteAction_HashPolicy_Header.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RouteAction_HashPolicy_Header>, I>>(
    object: I,
  ): RouteAction_HashPolicy_Header {
    const message = createBaseRouteAction_HashPolicy_Header();
    message.header_name = object.header_name ?? undefined;
    message.regex_rewrite = (object.regex_rewrite !== undefined && object.regex_rewrite !== null)
      ? RegexMatchAndSubstitute.fromPartial(object.regex_rewrite)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(RouteAction_HashPolicy_Header.$type, RouteAction_HashPolicy_Header);

function createBaseRouteAction_HashPolicy_CookieAttribute(): RouteAction_HashPolicy_CookieAttribute {
  return { $type: "envoy.config.route.v3.RouteAction.HashPolicy.CookieAttribute" };
}

export const RouteAction_HashPolicy_CookieAttribute: MessageFns<
  RouteAction_HashPolicy_CookieAttribute,
  "envoy.config.route.v3.RouteAction.HashPolicy.CookieAttribute"
> = {
  $type: "envoy.config.route.v3.RouteAction.HashPolicy.CookieAttribute" as const,

  encode(message: RouteAction_HashPolicy_CookieAttribute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== undefined && message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteAction_HashPolicy_CookieAttribute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteAction_HashPolicy_CookieAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteAction_HashPolicy_CookieAttribute {
    return {
      $type: RouteAction_HashPolicy_CookieAttribute.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      value: isSet(object.value) ? globalThis.String(object.value) : undefined,
    };
  },

  toJSON(message: RouteAction_HashPolicy_CookieAttribute): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RouteAction_HashPolicy_CookieAttribute>, I>>(
    base?: I,
  ): RouteAction_HashPolicy_CookieAttribute {
    return RouteAction_HashPolicy_CookieAttribute.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RouteAction_HashPolicy_CookieAttribute>, I>>(
    object: I,
  ): RouteAction_HashPolicy_CookieAttribute {
    const message = createBaseRouteAction_HashPolicy_CookieAttribute();
    message.name = object.name ?? undefined;
    message.value = object.value ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RouteAction_HashPolicy_CookieAttribute.$type, RouteAction_HashPolicy_CookieAttribute);

function createBaseRouteAction_HashPolicy_Cookie(): RouteAction_HashPolicy_Cookie {
  return { $type: "envoy.config.route.v3.RouteAction.HashPolicy.Cookie" };
}

export const RouteAction_HashPolicy_Cookie: MessageFns<
  RouteAction_HashPolicy_Cookie,
  "envoy.config.route.v3.RouteAction.HashPolicy.Cookie"
> = {
  $type: "envoy.config.route.v3.RouteAction.HashPolicy.Cookie" as const,

  encode(message: RouteAction_HashPolicy_Cookie, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.ttl !== undefined) {
      Duration.encode(message.ttl, writer.uint32(18).fork()).join();
    }
    if (message.path !== undefined && message.path !== "") {
      writer.uint32(26).string(message.path);
    }
    if (message.attributes !== undefined && message.attributes.length !== 0) {
      for (const v of message.attributes) {
        RouteAction_HashPolicy_CookieAttribute.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteAction_HashPolicy_Cookie {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteAction_HashPolicy_Cookie();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ttl = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          if (message.attributes === undefined) {
            message.attributes = [];
          }
          const el = RouteAction_HashPolicy_CookieAttribute.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.attributes!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteAction_HashPolicy_Cookie {
    return {
      $type: RouteAction_HashPolicy_Cookie.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      ttl: isSet(object.ttl) ? Duration.fromJSON(object.ttl) : undefined,
      path: isSet(object.path) ? globalThis.String(object.path) : undefined,
      attributes: globalThis.Array.isArray(object?.attributes)
        ? object.attributes.map((e: any) => RouteAction_HashPolicy_CookieAttribute.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: RouteAction_HashPolicy_Cookie): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.ttl !== undefined) {
      obj.ttl = Duration.toJSON(message.ttl);
    }
    if (message.path !== undefined) {
      obj.path = message.path;
    }
    if (message.attributes?.length) {
      obj.attributes = message.attributes.map((e) => RouteAction_HashPolicy_CookieAttribute.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RouteAction_HashPolicy_Cookie>, I>>(base?: I): RouteAction_HashPolicy_Cookie {
    return RouteAction_HashPolicy_Cookie.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RouteAction_HashPolicy_Cookie>, I>>(
    object: I,
  ): RouteAction_HashPolicy_Cookie {
    const message = createBaseRouteAction_HashPolicy_Cookie();
    message.name = object.name ?? undefined;
    message.ttl = (object.ttl !== undefined && object.ttl !== null) ? Duration.fromPartial(object.ttl) : undefined;
    message.path = object.path ?? undefined;
    message.attributes = object.attributes?.map((e) => RouteAction_HashPolicy_CookieAttribute.fromPartial(e)) ||
      undefined;
    return message;
  },
};

messageTypeRegistry.set(RouteAction_HashPolicy_Cookie.$type, RouteAction_HashPolicy_Cookie);

function createBaseRouteAction_HashPolicy_ConnectionProperties(): RouteAction_HashPolicy_ConnectionProperties {
  return { $type: "envoy.config.route.v3.RouteAction.HashPolicy.ConnectionProperties" };
}

export const RouteAction_HashPolicy_ConnectionProperties: MessageFns<
  RouteAction_HashPolicy_ConnectionProperties,
  "envoy.config.route.v3.RouteAction.HashPolicy.ConnectionProperties"
> = {
  $type: "envoy.config.route.v3.RouteAction.HashPolicy.ConnectionProperties" as const,

  encode(
    message: RouteAction_HashPolicy_ConnectionProperties,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.source_ip !== undefined && message.source_ip !== false) {
      writer.uint32(8).bool(message.source_ip);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteAction_HashPolicy_ConnectionProperties {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteAction_HashPolicy_ConnectionProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.source_ip = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteAction_HashPolicy_ConnectionProperties {
    return {
      $type: RouteAction_HashPolicy_ConnectionProperties.$type,
      source_ip: isSet(object.source_ip) ? globalThis.Boolean(object.source_ip) : undefined,
    };
  },

  toJSON(message: RouteAction_HashPolicy_ConnectionProperties): unknown {
    const obj: any = {};
    if (message.source_ip !== undefined) {
      obj.source_ip = message.source_ip;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RouteAction_HashPolicy_ConnectionProperties>, I>>(
    base?: I,
  ): RouteAction_HashPolicy_ConnectionProperties {
    return RouteAction_HashPolicy_ConnectionProperties.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RouteAction_HashPolicy_ConnectionProperties>, I>>(
    object: I,
  ): RouteAction_HashPolicy_ConnectionProperties {
    const message = createBaseRouteAction_HashPolicy_ConnectionProperties();
    message.source_ip = object.source_ip ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RouteAction_HashPolicy_ConnectionProperties.$type, RouteAction_HashPolicy_ConnectionProperties);

function createBaseRouteAction_HashPolicy_QueryParameter(): RouteAction_HashPolicy_QueryParameter {
  return { $type: "envoy.config.route.v3.RouteAction.HashPolicy.QueryParameter" };
}

export const RouteAction_HashPolicy_QueryParameter: MessageFns<
  RouteAction_HashPolicy_QueryParameter,
  "envoy.config.route.v3.RouteAction.HashPolicy.QueryParameter"
> = {
  $type: "envoy.config.route.v3.RouteAction.HashPolicy.QueryParameter" as const,

  encode(message: RouteAction_HashPolicy_QueryParameter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteAction_HashPolicy_QueryParameter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteAction_HashPolicy_QueryParameter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteAction_HashPolicy_QueryParameter {
    return {
      $type: RouteAction_HashPolicy_QueryParameter.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
    };
  },

  toJSON(message: RouteAction_HashPolicy_QueryParameter): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RouteAction_HashPolicy_QueryParameter>, I>>(
    base?: I,
  ): RouteAction_HashPolicy_QueryParameter {
    return RouteAction_HashPolicy_QueryParameter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RouteAction_HashPolicy_QueryParameter>, I>>(
    object: I,
  ): RouteAction_HashPolicy_QueryParameter {
    const message = createBaseRouteAction_HashPolicy_QueryParameter();
    message.name = object.name ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RouteAction_HashPolicy_QueryParameter.$type, RouteAction_HashPolicy_QueryParameter);

function createBaseRouteAction_HashPolicy_FilterState(): RouteAction_HashPolicy_FilterState {
  return { $type: "envoy.config.route.v3.RouteAction.HashPolicy.FilterState" };
}

export const RouteAction_HashPolicy_FilterState: MessageFns<
  RouteAction_HashPolicy_FilterState,
  "envoy.config.route.v3.RouteAction.HashPolicy.FilterState"
> = {
  $type: "envoy.config.route.v3.RouteAction.HashPolicy.FilterState" as const,

  encode(message: RouteAction_HashPolicy_FilterState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined && message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteAction_HashPolicy_FilterState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteAction_HashPolicy_FilterState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteAction_HashPolicy_FilterState {
    return {
      $type: RouteAction_HashPolicy_FilterState.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : undefined,
    };
  },

  toJSON(message: RouteAction_HashPolicy_FilterState): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RouteAction_HashPolicy_FilterState>, I>>(
    base?: I,
  ): RouteAction_HashPolicy_FilterState {
    return RouteAction_HashPolicy_FilterState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RouteAction_HashPolicy_FilterState>, I>>(
    object: I,
  ): RouteAction_HashPolicy_FilterState {
    const message = createBaseRouteAction_HashPolicy_FilterState();
    message.key = object.key ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RouteAction_HashPolicy_FilterState.$type, RouteAction_HashPolicy_FilterState);

function createBaseRouteAction_UpgradeConfig(): RouteAction_UpgradeConfig {
  return { $type: "envoy.config.route.v3.RouteAction.UpgradeConfig" };
}

export const RouteAction_UpgradeConfig: MessageFns<
  RouteAction_UpgradeConfig,
  "envoy.config.route.v3.RouteAction.UpgradeConfig"
> = {
  $type: "envoy.config.route.v3.RouteAction.UpgradeConfig" as const,

  encode(message: RouteAction_UpgradeConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.upgrade_type !== undefined && message.upgrade_type !== "") {
      writer.uint32(10).string(message.upgrade_type);
    }
    if (message.enabled !== undefined) {
      BoolValue.encode({ $type: "google.protobuf.BoolValue", value: message.enabled! }, writer.uint32(18).fork())
        .join();
    }
    if (message.connect_config !== undefined) {
      RouteAction_UpgradeConfig_ConnectConfig.encode(message.connect_config, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteAction_UpgradeConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteAction_UpgradeConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.upgrade_type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.enabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.connect_config = RouteAction_UpgradeConfig_ConnectConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteAction_UpgradeConfig {
    return {
      $type: RouteAction_UpgradeConfig.$type,
      upgrade_type: isSet(object.upgrade_type) ? globalThis.String(object.upgrade_type) : undefined,
      enabled: isSet(object.enabled) ? Boolean(object.enabled) : undefined,
      connect_config: isSet(object.connect_config)
        ? RouteAction_UpgradeConfig_ConnectConfig.fromJSON(object.connect_config)
        : undefined,
    };
  },

  toJSON(message: RouteAction_UpgradeConfig): unknown {
    const obj: any = {};
    if (message.upgrade_type !== undefined) {
      obj.upgrade_type = message.upgrade_type;
    }
    if (message.enabled !== undefined) {
      obj.enabled = message.enabled;
    }
    if (message.connect_config !== undefined) {
      obj.connect_config = RouteAction_UpgradeConfig_ConnectConfig.toJSON(message.connect_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RouteAction_UpgradeConfig>, I>>(base?: I): RouteAction_UpgradeConfig {
    return RouteAction_UpgradeConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RouteAction_UpgradeConfig>, I>>(object: I): RouteAction_UpgradeConfig {
    const message = createBaseRouteAction_UpgradeConfig();
    message.upgrade_type = object.upgrade_type ?? undefined;
    message.enabled = object.enabled ?? undefined;
    message.connect_config = (object.connect_config !== undefined && object.connect_config !== null)
      ? RouteAction_UpgradeConfig_ConnectConfig.fromPartial(object.connect_config)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(RouteAction_UpgradeConfig.$type, RouteAction_UpgradeConfig);

function createBaseRouteAction_UpgradeConfig_ConnectConfig(): RouteAction_UpgradeConfig_ConnectConfig {
  return { $type: "envoy.config.route.v3.RouteAction.UpgradeConfig.ConnectConfig" };
}

export const RouteAction_UpgradeConfig_ConnectConfig: MessageFns<
  RouteAction_UpgradeConfig_ConnectConfig,
  "envoy.config.route.v3.RouteAction.UpgradeConfig.ConnectConfig"
> = {
  $type: "envoy.config.route.v3.RouteAction.UpgradeConfig.ConnectConfig" as const,

  encode(message: RouteAction_UpgradeConfig_ConnectConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.proxy_protocol_config !== undefined) {
      ProxyProtocolConfig.encode(message.proxy_protocol_config, writer.uint32(10).fork()).join();
    }
    if (message.allow_post !== undefined && message.allow_post !== false) {
      writer.uint32(16).bool(message.allow_post);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteAction_UpgradeConfig_ConnectConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteAction_UpgradeConfig_ConnectConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.proxy_protocol_config = ProxyProtocolConfig.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.allow_post = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteAction_UpgradeConfig_ConnectConfig {
    return {
      $type: RouteAction_UpgradeConfig_ConnectConfig.$type,
      proxy_protocol_config: isSet(object.proxy_protocol_config)
        ? ProxyProtocolConfig.fromJSON(object.proxy_protocol_config)
        : undefined,
      allow_post: isSet(object.allow_post) ? globalThis.Boolean(object.allow_post) : undefined,
    };
  },

  toJSON(message: RouteAction_UpgradeConfig_ConnectConfig): unknown {
    const obj: any = {};
    if (message.proxy_protocol_config !== undefined) {
      obj.proxy_protocol_config = ProxyProtocolConfig.toJSON(message.proxy_protocol_config);
    }
    if (message.allow_post !== undefined) {
      obj.allow_post = message.allow_post;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RouteAction_UpgradeConfig_ConnectConfig>, I>>(
    base?: I,
  ): RouteAction_UpgradeConfig_ConnectConfig {
    return RouteAction_UpgradeConfig_ConnectConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RouteAction_UpgradeConfig_ConnectConfig>, I>>(
    object: I,
  ): RouteAction_UpgradeConfig_ConnectConfig {
    const message = createBaseRouteAction_UpgradeConfig_ConnectConfig();
    message.proxy_protocol_config =
      (object.proxy_protocol_config !== undefined && object.proxy_protocol_config !== null)
        ? ProxyProtocolConfig.fromPartial(object.proxy_protocol_config)
        : undefined;
    message.allow_post = object.allow_post ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RouteAction_UpgradeConfig_ConnectConfig.$type, RouteAction_UpgradeConfig_ConnectConfig);

function createBaseRouteAction_MaxStreamDuration(): RouteAction_MaxStreamDuration {
  return { $type: "envoy.config.route.v3.RouteAction.MaxStreamDuration" };
}

export const RouteAction_MaxStreamDuration: MessageFns<
  RouteAction_MaxStreamDuration,
  "envoy.config.route.v3.RouteAction.MaxStreamDuration"
> = {
  $type: "envoy.config.route.v3.RouteAction.MaxStreamDuration" as const,

  encode(message: RouteAction_MaxStreamDuration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.max_stream_duration !== undefined) {
      Duration.encode(message.max_stream_duration, writer.uint32(10).fork()).join();
    }
    if (message.grpc_timeout_header_max !== undefined) {
      Duration.encode(message.grpc_timeout_header_max, writer.uint32(18).fork()).join();
    }
    if (message.grpc_timeout_header_offset !== undefined) {
      Duration.encode(message.grpc_timeout_header_offset, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteAction_MaxStreamDuration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteAction_MaxStreamDuration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.max_stream_duration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.grpc_timeout_header_max = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.grpc_timeout_header_offset = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteAction_MaxStreamDuration {
    return {
      $type: RouteAction_MaxStreamDuration.$type,
      max_stream_duration: isSet(object.max_stream_duration)
        ? Duration.fromJSON(object.max_stream_duration)
        : undefined,
      grpc_timeout_header_max: isSet(object.grpc_timeout_header_max)
        ? Duration.fromJSON(object.grpc_timeout_header_max)
        : undefined,
      grpc_timeout_header_offset: isSet(object.grpc_timeout_header_offset)
        ? Duration.fromJSON(object.grpc_timeout_header_offset)
        : undefined,
    };
  },

  toJSON(message: RouteAction_MaxStreamDuration): unknown {
    const obj: any = {};
    if (message.max_stream_duration !== undefined) {
      obj.max_stream_duration = Duration.toJSON(message.max_stream_duration);
    }
    if (message.grpc_timeout_header_max !== undefined) {
      obj.grpc_timeout_header_max = Duration.toJSON(message.grpc_timeout_header_max);
    }
    if (message.grpc_timeout_header_offset !== undefined) {
      obj.grpc_timeout_header_offset = Duration.toJSON(message.grpc_timeout_header_offset);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RouteAction_MaxStreamDuration>, I>>(base?: I): RouteAction_MaxStreamDuration {
    return RouteAction_MaxStreamDuration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RouteAction_MaxStreamDuration>, I>>(
    object: I,
  ): RouteAction_MaxStreamDuration {
    const message = createBaseRouteAction_MaxStreamDuration();
    message.max_stream_duration = (object.max_stream_duration !== undefined && object.max_stream_duration !== null)
      ? Duration.fromPartial(object.max_stream_duration)
      : undefined;
    message.grpc_timeout_header_max =
      (object.grpc_timeout_header_max !== undefined && object.grpc_timeout_header_max !== null)
        ? Duration.fromPartial(object.grpc_timeout_header_max)
        : undefined;
    message.grpc_timeout_header_offset =
      (object.grpc_timeout_header_offset !== undefined && object.grpc_timeout_header_offset !== null)
        ? Duration.fromPartial(object.grpc_timeout_header_offset)
        : undefined;
    return message;
  },
};

messageTypeRegistry.set(RouteAction_MaxStreamDuration.$type, RouteAction_MaxStreamDuration);

function createBaseRetryPolicy(): RetryPolicy {
  return { $type: "envoy.config.route.v3.RetryPolicy" };
}

export const RetryPolicy: MessageFns<RetryPolicy, "envoy.config.route.v3.RetryPolicy"> = {
  $type: "envoy.config.route.v3.RetryPolicy" as const,

  encode(message: RetryPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.retry_on !== undefined && message.retry_on !== "") {
      writer.uint32(10).string(message.retry_on);
    }
    if (message.num_retries !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.num_retries! },
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.per_try_timeout !== undefined) {
      Duration.encode(message.per_try_timeout, writer.uint32(26).fork()).join();
    }
    if (message.per_try_idle_timeout !== undefined) {
      Duration.encode(message.per_try_idle_timeout, writer.uint32(106).fork()).join();
    }
    if (message.retry_priority !== undefined) {
      RetryPolicy_RetryPriority.encode(message.retry_priority, writer.uint32(34).fork()).join();
    }
    if (message.retry_host_predicate !== undefined && message.retry_host_predicate.length !== 0) {
      for (const v of message.retry_host_predicate) {
        RetryPolicy_RetryHostPredicate.encode(v!, writer.uint32(42).fork()).join();
      }
    }
    if (message.retry_options_predicates !== undefined && message.retry_options_predicates.length !== 0) {
      for (const v of message.retry_options_predicates) {
        TypedExtensionConfig.encode(v!, writer.uint32(98).fork()).join();
      }
    }
    if (message.host_selection_retry_max_attempts !== undefined && message.host_selection_retry_max_attempts !== 0) {
      writer.uint32(48).int64(message.host_selection_retry_max_attempts);
    }
    if (message.retriable_status_codes !== undefined && message.retriable_status_codes.length !== 0) {
      writer.uint32(58).fork();
      for (const v of message.retriable_status_codes) {
        writer.uint32(v);
      }
      writer.join();
    }
    if (message.retry_back_off !== undefined) {
      RetryPolicy_RetryBackOff.encode(message.retry_back_off, writer.uint32(66).fork()).join();
    }
    if (message.rate_limited_retry_back_off !== undefined) {
      RetryPolicy_RateLimitedRetryBackOff.encode(message.rate_limited_retry_back_off, writer.uint32(90).fork()).join();
    }
    if (message.retriable_headers !== undefined && message.retriable_headers.length !== 0) {
      for (const v of message.retriable_headers) {
        HeaderMatcher.encode(v!, writer.uint32(74).fork()).join();
      }
    }
    if (message.retriable_request_headers !== undefined && message.retriable_request_headers.length !== 0) {
      for (const v of message.retriable_request_headers) {
        HeaderMatcher.encode(v!, writer.uint32(82).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.retry_on = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.num_retries = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.per_try_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.per_try_idle_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.retry_priority = RetryPolicy_RetryPriority.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          if (message.retry_host_predicate === undefined) {
            message.retry_host_predicate = [];
          }
          const el = RetryPolicy_RetryHostPredicate.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.retry_host_predicate!.push(el);
          }
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          if (message.retry_options_predicates === undefined) {
            message.retry_options_predicates = [];
          }
          const el = TypedExtensionConfig.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.retry_options_predicates!.push(el);
          }
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.host_selection_retry_max_attempts = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag === 56) {
            if (message.retriable_status_codes === undefined) {
              message.retriable_status_codes = [];
            }
            message.retriable_status_codes!.push(reader.uint32());

            continue;
          }

          if (tag === 58) {
            if (message.retriable_status_codes === undefined) {
              message.retriable_status_codes = [];
            }
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.retriable_status_codes!.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.retry_back_off = RetryPolicy_RetryBackOff.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.rate_limited_retry_back_off = RetryPolicy_RateLimitedRetryBackOff.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          if (message.retriable_headers === undefined) {
            message.retriable_headers = [];
          }
          const el = HeaderMatcher.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.retriable_headers!.push(el);
          }
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          if (message.retriable_request_headers === undefined) {
            message.retriable_request_headers = [];
          }
          const el = HeaderMatcher.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.retriable_request_headers!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetryPolicy {
    return {
      $type: RetryPolicy.$type,
      retry_on: isSet(object.retry_on) ? globalThis.String(object.retry_on) : undefined,
      num_retries: isSet(object.num_retries) ? Number(object.num_retries) : undefined,
      per_try_timeout: isSet(object.per_try_timeout) ? Duration.fromJSON(object.per_try_timeout) : undefined,
      per_try_idle_timeout: isSet(object.per_try_idle_timeout)
        ? Duration.fromJSON(object.per_try_idle_timeout)
        : undefined,
      retry_priority: isSet(object.retry_priority)
        ? RetryPolicy_RetryPriority.fromJSON(object.retry_priority)
        : undefined,
      retry_host_predicate: globalThis.Array.isArray(object?.retry_host_predicate)
        ? object.retry_host_predicate.map((e: any) => RetryPolicy_RetryHostPredicate.fromJSON(e))
        : undefined,
      retry_options_predicates: globalThis.Array.isArray(object?.retry_options_predicates)
        ? object.retry_options_predicates.map((e: any) => TypedExtensionConfig.fromJSON(e))
        : undefined,
      host_selection_retry_max_attempts: isSet(object.host_selection_retry_max_attempts)
        ? globalThis.Number(object.host_selection_retry_max_attempts)
        : undefined,
      retriable_status_codes: globalThis.Array.isArray(object?.retriable_status_codes)
        ? object.retriable_status_codes.map((e: any) => globalThis.Number(e))
        : undefined,
      retry_back_off: isSet(object.retry_back_off)
        ? RetryPolicy_RetryBackOff.fromJSON(object.retry_back_off)
        : undefined,
      rate_limited_retry_back_off: isSet(object.rate_limited_retry_back_off)
        ? RetryPolicy_RateLimitedRetryBackOff.fromJSON(object.rate_limited_retry_back_off)
        : undefined,
      retriable_headers: globalThis.Array.isArray(object?.retriable_headers)
        ? object.retriable_headers.map((e: any) => HeaderMatcher.fromJSON(e))
        : undefined,
      retriable_request_headers: globalThis.Array.isArray(object?.retriable_request_headers)
        ? object.retriable_request_headers.map((e: any) => HeaderMatcher.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: RetryPolicy): unknown {
    const obj: any = {};
    if (message.retry_on !== undefined) {
      obj.retry_on = message.retry_on;
    }
    if (message.num_retries !== undefined) {
      obj.num_retries = message.num_retries;
    }
    if (message.per_try_timeout !== undefined) {
      obj.per_try_timeout = Duration.toJSON(message.per_try_timeout);
    }
    if (message.per_try_idle_timeout !== undefined) {
      obj.per_try_idle_timeout = Duration.toJSON(message.per_try_idle_timeout);
    }
    if (message.retry_priority !== undefined) {
      obj.retry_priority = RetryPolicy_RetryPriority.toJSON(message.retry_priority);
    }
    if (message.retry_host_predicate?.length) {
      obj.retry_host_predicate = message.retry_host_predicate.map((e) => RetryPolicy_RetryHostPredicate.toJSON(e));
    }
    if (message.retry_options_predicates?.length) {
      obj.retry_options_predicates = message.retry_options_predicates.map((e) => TypedExtensionConfig.toJSON(e));
    }
    if (message.host_selection_retry_max_attempts !== undefined) {
      obj.host_selection_retry_max_attempts = Math.round(message.host_selection_retry_max_attempts);
    }
    if (message.retriable_status_codes?.length) {
      obj.retriable_status_codes = message.retriable_status_codes.map((e) => Math.round(e));
    }
    if (message.retry_back_off !== undefined) {
      obj.retry_back_off = RetryPolicy_RetryBackOff.toJSON(message.retry_back_off);
    }
    if (message.rate_limited_retry_back_off !== undefined) {
      obj.rate_limited_retry_back_off = RetryPolicy_RateLimitedRetryBackOff.toJSON(message.rate_limited_retry_back_off);
    }
    if (message.retriable_headers?.length) {
      obj.retriable_headers = message.retriable_headers.map((e) => HeaderMatcher.toJSON(e));
    }
    if (message.retriable_request_headers?.length) {
      obj.retriable_request_headers = message.retriable_request_headers.map((e) => HeaderMatcher.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetryPolicy>, I>>(base?: I): RetryPolicy {
    return RetryPolicy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetryPolicy>, I>>(object: I): RetryPolicy {
    const message = createBaseRetryPolicy();
    message.retry_on = object.retry_on ?? undefined;
    message.num_retries = object.num_retries ?? undefined;
    message.per_try_timeout = (object.per_try_timeout !== undefined && object.per_try_timeout !== null)
      ? Duration.fromPartial(object.per_try_timeout)
      : undefined;
    message.per_try_idle_timeout = (object.per_try_idle_timeout !== undefined && object.per_try_idle_timeout !== null)
      ? Duration.fromPartial(object.per_try_idle_timeout)
      : undefined;
    message.retry_priority = (object.retry_priority !== undefined && object.retry_priority !== null)
      ? RetryPolicy_RetryPriority.fromPartial(object.retry_priority)
      : undefined;
    message.retry_host_predicate =
      object.retry_host_predicate?.map((e) => RetryPolicy_RetryHostPredicate.fromPartial(e)) || undefined;
    message.retry_options_predicates =
      object.retry_options_predicates?.map((e) => TypedExtensionConfig.fromPartial(e)) || undefined;
    message.host_selection_retry_max_attempts = object.host_selection_retry_max_attempts ?? undefined;
    message.retriable_status_codes = object.retriable_status_codes?.map((e) => e) || undefined;
    message.retry_back_off = (object.retry_back_off !== undefined && object.retry_back_off !== null)
      ? RetryPolicy_RetryBackOff.fromPartial(object.retry_back_off)
      : undefined;
    message.rate_limited_retry_back_off =
      (object.rate_limited_retry_back_off !== undefined && object.rate_limited_retry_back_off !== null)
        ? RetryPolicy_RateLimitedRetryBackOff.fromPartial(object.rate_limited_retry_back_off)
        : undefined;
    message.retriable_headers = object.retriable_headers?.map((e) => HeaderMatcher.fromPartial(e)) || undefined;
    message.retriable_request_headers = object.retriable_request_headers?.map((e) => HeaderMatcher.fromPartial(e)) ||
      undefined;
    return message;
  },
};

messageTypeRegistry.set(RetryPolicy.$type, RetryPolicy);

function createBaseRetryPolicy_RetryPriority(): RetryPolicy_RetryPriority {
  return { $type: "envoy.config.route.v3.RetryPolicy.RetryPriority", config_type: undefined };
}

export const RetryPolicy_RetryPriority: MessageFns<
  RetryPolicy_RetryPriority,
  "envoy.config.route.v3.RetryPolicy.RetryPriority"
> = {
  $type: "envoy.config.route.v3.RetryPolicy.RetryPriority" as const,

  encode(message: RetryPolicy_RetryPriority, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    switch (message.config_type?.$case) {
      case "typed_config":
        Any.encode(message.config_type.typed_config, writer.uint32(26).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryPolicy_RetryPriority {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryPolicy_RetryPriority();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.config_type = { $case: "typed_config", typed_config: Any.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetryPolicy_RetryPriority {
    return {
      $type: RetryPolicy_RetryPriority.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      config_type: isSet(object.typed_config)
        ? { $case: "typed_config", typed_config: Any.fromJSON(object.typed_config) }
        : undefined,
    };
  },

  toJSON(message: RetryPolicy_RetryPriority): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.config_type?.$case === "typed_config") {
      obj.typed_config = Any.toJSON(message.config_type.typed_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetryPolicy_RetryPriority>, I>>(base?: I): RetryPolicy_RetryPriority {
    return RetryPolicy_RetryPriority.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetryPolicy_RetryPriority>, I>>(object: I): RetryPolicy_RetryPriority {
    const message = createBaseRetryPolicy_RetryPriority();
    message.name = object.name ?? undefined;
    if (
      object.config_type?.$case === "typed_config" &&
      object.config_type?.typed_config !== undefined &&
      object.config_type?.typed_config !== null
    ) {
      message.config_type = { $case: "typed_config", typed_config: Any.fromPartial(object.config_type.typed_config) };
    }
    return message;
  },
};

messageTypeRegistry.set(RetryPolicy_RetryPriority.$type, RetryPolicy_RetryPriority);

function createBaseRetryPolicy_RetryHostPredicate(): RetryPolicy_RetryHostPredicate {
  return { $type: "envoy.config.route.v3.RetryPolicy.RetryHostPredicate", config_type: undefined };
}

export const RetryPolicy_RetryHostPredicate: MessageFns<
  RetryPolicy_RetryHostPredicate,
  "envoy.config.route.v3.RetryPolicy.RetryHostPredicate"
> = {
  $type: "envoy.config.route.v3.RetryPolicy.RetryHostPredicate" as const,

  encode(message: RetryPolicy_RetryHostPredicate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    switch (message.config_type?.$case) {
      case "typed_config":
        Any.encode(message.config_type.typed_config, writer.uint32(26).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryPolicy_RetryHostPredicate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryPolicy_RetryHostPredicate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.config_type = { $case: "typed_config", typed_config: Any.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetryPolicy_RetryHostPredicate {
    return {
      $type: RetryPolicy_RetryHostPredicate.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      config_type: isSet(object.typed_config)
        ? { $case: "typed_config", typed_config: Any.fromJSON(object.typed_config) }
        : undefined,
    };
  },

  toJSON(message: RetryPolicy_RetryHostPredicate): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.config_type?.$case === "typed_config") {
      obj.typed_config = Any.toJSON(message.config_type.typed_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetryPolicy_RetryHostPredicate>, I>>(base?: I): RetryPolicy_RetryHostPredicate {
    return RetryPolicy_RetryHostPredicate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetryPolicy_RetryHostPredicate>, I>>(
    object: I,
  ): RetryPolicy_RetryHostPredicate {
    const message = createBaseRetryPolicy_RetryHostPredicate();
    message.name = object.name ?? undefined;
    if (
      object.config_type?.$case === "typed_config" &&
      object.config_type?.typed_config !== undefined &&
      object.config_type?.typed_config !== null
    ) {
      message.config_type = { $case: "typed_config", typed_config: Any.fromPartial(object.config_type.typed_config) };
    }
    return message;
  },
};

messageTypeRegistry.set(RetryPolicy_RetryHostPredicate.$type, RetryPolicy_RetryHostPredicate);

function createBaseRetryPolicy_RetryBackOff(): RetryPolicy_RetryBackOff {
  return { $type: "envoy.config.route.v3.RetryPolicy.RetryBackOff" };
}

export const RetryPolicy_RetryBackOff: MessageFns<
  RetryPolicy_RetryBackOff,
  "envoy.config.route.v3.RetryPolicy.RetryBackOff"
> = {
  $type: "envoy.config.route.v3.RetryPolicy.RetryBackOff" as const,

  encode(message: RetryPolicy_RetryBackOff, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.base_interval !== undefined) {
      Duration.encode(message.base_interval, writer.uint32(10).fork()).join();
    }
    if (message.max_interval !== undefined) {
      Duration.encode(message.max_interval, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryPolicy_RetryBackOff {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryPolicy_RetryBackOff();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.base_interval = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.max_interval = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetryPolicy_RetryBackOff {
    return {
      $type: RetryPolicy_RetryBackOff.$type,
      base_interval: isSet(object.base_interval) ? Duration.fromJSON(object.base_interval) : undefined,
      max_interval: isSet(object.max_interval) ? Duration.fromJSON(object.max_interval) : undefined,
    };
  },

  toJSON(message: RetryPolicy_RetryBackOff): unknown {
    const obj: any = {};
    if (message.base_interval !== undefined) {
      obj.base_interval = Duration.toJSON(message.base_interval);
    }
    if (message.max_interval !== undefined) {
      obj.max_interval = Duration.toJSON(message.max_interval);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetryPolicy_RetryBackOff>, I>>(base?: I): RetryPolicy_RetryBackOff {
    return RetryPolicy_RetryBackOff.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetryPolicy_RetryBackOff>, I>>(object: I): RetryPolicy_RetryBackOff {
    const message = createBaseRetryPolicy_RetryBackOff();
    message.base_interval = (object.base_interval !== undefined && object.base_interval !== null)
      ? Duration.fromPartial(object.base_interval)
      : undefined;
    message.max_interval = (object.max_interval !== undefined && object.max_interval !== null)
      ? Duration.fromPartial(object.max_interval)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(RetryPolicy_RetryBackOff.$type, RetryPolicy_RetryBackOff);

function createBaseRetryPolicy_ResetHeader(): RetryPolicy_ResetHeader {
  return { $type: "envoy.config.route.v3.RetryPolicy.ResetHeader" };
}

export const RetryPolicy_ResetHeader: MessageFns<
  RetryPolicy_ResetHeader,
  "envoy.config.route.v3.RetryPolicy.ResetHeader"
> = {
  $type: "envoy.config.route.v3.RetryPolicy.ResetHeader" as const,

  encode(message: RetryPolicy_ResetHeader, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.format !== undefined && message.format !== RetryPolicy_ResetHeaderFormat.SECONDS) {
      writer.uint32(16).int32(retryPolicy_ResetHeaderFormatToNumber(message.format));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryPolicy_ResetHeader {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryPolicy_ResetHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.format = retryPolicy_ResetHeaderFormatFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetryPolicy_ResetHeader {
    return {
      $type: RetryPolicy_ResetHeader.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      format: isSet(object.format) ? retryPolicy_ResetHeaderFormatFromJSON(object.format) : undefined,
    };
  },

  toJSON(message: RetryPolicy_ResetHeader): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.format !== undefined) {
      obj.format = retryPolicy_ResetHeaderFormatToJSON(message.format);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetryPolicy_ResetHeader>, I>>(base?: I): RetryPolicy_ResetHeader {
    return RetryPolicy_ResetHeader.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetryPolicy_ResetHeader>, I>>(object: I): RetryPolicy_ResetHeader {
    const message = createBaseRetryPolicy_ResetHeader();
    message.name = object.name ?? undefined;
    message.format = object.format ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RetryPolicy_ResetHeader.$type, RetryPolicy_ResetHeader);

function createBaseRetryPolicy_RateLimitedRetryBackOff(): RetryPolicy_RateLimitedRetryBackOff {
  return { $type: "envoy.config.route.v3.RetryPolicy.RateLimitedRetryBackOff" };
}

export const RetryPolicy_RateLimitedRetryBackOff: MessageFns<
  RetryPolicy_RateLimitedRetryBackOff,
  "envoy.config.route.v3.RetryPolicy.RateLimitedRetryBackOff"
> = {
  $type: "envoy.config.route.v3.RetryPolicy.RateLimitedRetryBackOff" as const,

  encode(message: RetryPolicy_RateLimitedRetryBackOff, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reset_headers !== undefined && message.reset_headers.length !== 0) {
      for (const v of message.reset_headers) {
        RetryPolicy_ResetHeader.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    if (message.max_interval !== undefined) {
      Duration.encode(message.max_interval, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryPolicy_RateLimitedRetryBackOff {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryPolicy_RateLimitedRetryBackOff();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.reset_headers === undefined) {
            message.reset_headers = [];
          }
          const el = RetryPolicy_ResetHeader.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.reset_headers!.push(el);
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.max_interval = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetryPolicy_RateLimitedRetryBackOff {
    return {
      $type: RetryPolicy_RateLimitedRetryBackOff.$type,
      reset_headers: globalThis.Array.isArray(object?.reset_headers)
        ? object.reset_headers.map((e: any) => RetryPolicy_ResetHeader.fromJSON(e))
        : undefined,
      max_interval: isSet(object.max_interval) ? Duration.fromJSON(object.max_interval) : undefined,
    };
  },

  toJSON(message: RetryPolicy_RateLimitedRetryBackOff): unknown {
    const obj: any = {};
    if (message.reset_headers?.length) {
      obj.reset_headers = message.reset_headers.map((e) => RetryPolicy_ResetHeader.toJSON(e));
    }
    if (message.max_interval !== undefined) {
      obj.max_interval = Duration.toJSON(message.max_interval);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetryPolicy_RateLimitedRetryBackOff>, I>>(
    base?: I,
  ): RetryPolicy_RateLimitedRetryBackOff {
    return RetryPolicy_RateLimitedRetryBackOff.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetryPolicy_RateLimitedRetryBackOff>, I>>(
    object: I,
  ): RetryPolicy_RateLimitedRetryBackOff {
    const message = createBaseRetryPolicy_RateLimitedRetryBackOff();
    message.reset_headers = object.reset_headers?.map((e) => RetryPolicy_ResetHeader.fromPartial(e)) || undefined;
    message.max_interval = (object.max_interval !== undefined && object.max_interval !== null)
      ? Duration.fromPartial(object.max_interval)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(RetryPolicy_RateLimitedRetryBackOff.$type, RetryPolicy_RateLimitedRetryBackOff);

function createBaseHedgePolicy(): HedgePolicy {
  return { $type: "envoy.config.route.v3.HedgePolicy" };
}

export const HedgePolicy: MessageFns<HedgePolicy, "envoy.config.route.v3.HedgePolicy"> = {
  $type: "envoy.config.route.v3.HedgePolicy" as const,

  encode(message: HedgePolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.initial_requests !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.initial_requests! },
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.additional_request_chance !== undefined) {
      FractionalPercent.encode(message.additional_request_chance, writer.uint32(18).fork()).join();
    }
    if (message.hedge_on_per_try_timeout !== undefined && message.hedge_on_per_try_timeout !== false) {
      writer.uint32(24).bool(message.hedge_on_per_try_timeout);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HedgePolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHedgePolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.initial_requests = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.additional_request_chance = FractionalPercent.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.hedge_on_per_try_timeout = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HedgePolicy {
    return {
      $type: HedgePolicy.$type,
      initial_requests: isSet(object.initial_requests) ? Number(object.initial_requests) : undefined,
      additional_request_chance: isSet(object.additional_request_chance)
        ? FractionalPercent.fromJSON(object.additional_request_chance)
        : undefined,
      hedge_on_per_try_timeout: isSet(object.hedge_on_per_try_timeout)
        ? globalThis.Boolean(object.hedge_on_per_try_timeout)
        : undefined,
    };
  },

  toJSON(message: HedgePolicy): unknown {
    const obj: any = {};
    if (message.initial_requests !== undefined) {
      obj.initial_requests = message.initial_requests;
    }
    if (message.additional_request_chance !== undefined) {
      obj.additional_request_chance = FractionalPercent.toJSON(message.additional_request_chance);
    }
    if (message.hedge_on_per_try_timeout !== undefined) {
      obj.hedge_on_per_try_timeout = message.hedge_on_per_try_timeout;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HedgePolicy>, I>>(base?: I): HedgePolicy {
    return HedgePolicy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HedgePolicy>, I>>(object: I): HedgePolicy {
    const message = createBaseHedgePolicy();
    message.initial_requests = object.initial_requests ?? undefined;
    message.additional_request_chance =
      (object.additional_request_chance !== undefined && object.additional_request_chance !== null)
        ? FractionalPercent.fromPartial(object.additional_request_chance)
        : undefined;
    message.hedge_on_per_try_timeout = object.hedge_on_per_try_timeout ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(HedgePolicy.$type, HedgePolicy);

function createBaseRedirectAction(): RedirectAction {
  return {
    $type: "envoy.config.route.v3.RedirectAction",
    scheme_rewrite_specifier: undefined,
    path_rewrite_specifier: undefined,
  };
}

export const RedirectAction: MessageFns<RedirectAction, "envoy.config.route.v3.RedirectAction"> = {
  $type: "envoy.config.route.v3.RedirectAction" as const,

  encode(message: RedirectAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.scheme_rewrite_specifier?.$case) {
      case "https_redirect":
        writer.uint32(32).bool(message.scheme_rewrite_specifier.https_redirect);
        break;
      case "scheme_redirect":
        writer.uint32(58).string(message.scheme_rewrite_specifier.scheme_redirect);
        break;
    }
    if (message.host_redirect !== undefined && message.host_redirect !== "") {
      writer.uint32(10).string(message.host_redirect);
    }
    if (message.port_redirect !== undefined && message.port_redirect !== 0) {
      writer.uint32(64).uint32(message.port_redirect);
    }
    switch (message.path_rewrite_specifier?.$case) {
      case "path_redirect":
        writer.uint32(18).string(message.path_rewrite_specifier.path_redirect);
        break;
      case "prefix_rewrite":
        writer.uint32(42).string(message.path_rewrite_specifier.prefix_rewrite);
        break;
      case "regex_rewrite":
        RegexMatchAndSubstitute.encode(message.path_rewrite_specifier.regex_rewrite, writer.uint32(74).fork()).join();
        break;
    }
    if (
      message.response_code !== undefined &&
      message.response_code !== RedirectAction_RedirectResponseCode.MOVED_PERMANENTLY
    ) {
      writer.uint32(24).int32(redirectAction_RedirectResponseCodeToNumber(message.response_code));
    }
    if (message.strip_query !== undefined && message.strip_query !== false) {
      writer.uint32(48).bool(message.strip_query);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RedirectAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRedirectAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.scheme_rewrite_specifier = { $case: "https_redirect", https_redirect: reader.bool() };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.scheme_rewrite_specifier = { $case: "scheme_redirect", scheme_redirect: reader.string() };
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.host_redirect = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.port_redirect = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.path_rewrite_specifier = { $case: "path_redirect", path_redirect: reader.string() };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.path_rewrite_specifier = { $case: "prefix_rewrite", prefix_rewrite: reader.string() };
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.path_rewrite_specifier = {
            $case: "regex_rewrite",
            regex_rewrite: RegexMatchAndSubstitute.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.response_code = redirectAction_RedirectResponseCodeFromJSON(reader.int32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.strip_query = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RedirectAction {
    return {
      $type: RedirectAction.$type,
      scheme_rewrite_specifier: isSet(object.https_redirect)
        ? { $case: "https_redirect", https_redirect: globalThis.Boolean(object.https_redirect) }
        : isSet(object.scheme_redirect)
        ? { $case: "scheme_redirect", scheme_redirect: globalThis.String(object.scheme_redirect) }
        : undefined,
      host_redirect: isSet(object.host_redirect) ? globalThis.String(object.host_redirect) : undefined,
      port_redirect: isSet(object.port_redirect) ? globalThis.Number(object.port_redirect) : undefined,
      path_rewrite_specifier: isSet(object.path_redirect)
        ? { $case: "path_redirect", path_redirect: globalThis.String(object.path_redirect) }
        : isSet(object.prefix_rewrite)
        ? { $case: "prefix_rewrite", prefix_rewrite: globalThis.String(object.prefix_rewrite) }
        : isSet(object.regex_rewrite)
        ? { $case: "regex_rewrite", regex_rewrite: RegexMatchAndSubstitute.fromJSON(object.regex_rewrite) }
        : undefined,
      response_code: isSet(object.response_code)
        ? redirectAction_RedirectResponseCodeFromJSON(object.response_code)
        : undefined,
      strip_query: isSet(object.strip_query) ? globalThis.Boolean(object.strip_query) : undefined,
    };
  },

  toJSON(message: RedirectAction): unknown {
    const obj: any = {};
    if (message.scheme_rewrite_specifier?.$case === "https_redirect") {
      obj.https_redirect = message.scheme_rewrite_specifier.https_redirect;
    }
    if (message.scheme_rewrite_specifier?.$case === "scheme_redirect") {
      obj.scheme_redirect = message.scheme_rewrite_specifier.scheme_redirect;
    }
    if (message.host_redirect !== undefined) {
      obj.host_redirect = message.host_redirect;
    }
    if (message.port_redirect !== undefined) {
      obj.port_redirect = Math.round(message.port_redirect);
    }
    if (message.path_rewrite_specifier?.$case === "path_redirect") {
      obj.path_redirect = message.path_rewrite_specifier.path_redirect;
    }
    if (message.path_rewrite_specifier?.$case === "prefix_rewrite") {
      obj.prefix_rewrite = message.path_rewrite_specifier.prefix_rewrite;
    }
    if (message.path_rewrite_specifier?.$case === "regex_rewrite") {
      obj.regex_rewrite = RegexMatchAndSubstitute.toJSON(message.path_rewrite_specifier.regex_rewrite);
    }
    if (message.response_code !== undefined) {
      obj.response_code = redirectAction_RedirectResponseCodeToJSON(message.response_code);
    }
    if (message.strip_query !== undefined) {
      obj.strip_query = message.strip_query;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RedirectAction>, I>>(base?: I): RedirectAction {
    return RedirectAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RedirectAction>, I>>(object: I): RedirectAction {
    const message = createBaseRedirectAction();
    if (
      object.scheme_rewrite_specifier?.$case === "https_redirect" &&
      object.scheme_rewrite_specifier?.https_redirect !== undefined &&
      object.scheme_rewrite_specifier?.https_redirect !== null
    ) {
      message.scheme_rewrite_specifier = {
        $case: "https_redirect",
        https_redirect: object.scheme_rewrite_specifier.https_redirect,
      };
    }
    if (
      object.scheme_rewrite_specifier?.$case === "scheme_redirect" &&
      object.scheme_rewrite_specifier?.scheme_redirect !== undefined &&
      object.scheme_rewrite_specifier?.scheme_redirect !== null
    ) {
      message.scheme_rewrite_specifier = {
        $case: "scheme_redirect",
        scheme_redirect: object.scheme_rewrite_specifier.scheme_redirect,
      };
    }
    message.host_redirect = object.host_redirect ?? undefined;
    message.port_redirect = object.port_redirect ?? undefined;
    if (
      object.path_rewrite_specifier?.$case === "path_redirect" &&
      object.path_rewrite_specifier?.path_redirect !== undefined &&
      object.path_rewrite_specifier?.path_redirect !== null
    ) {
      message.path_rewrite_specifier = {
        $case: "path_redirect",
        path_redirect: object.path_rewrite_specifier.path_redirect,
      };
    }
    if (
      object.path_rewrite_specifier?.$case === "prefix_rewrite" &&
      object.path_rewrite_specifier?.prefix_rewrite !== undefined &&
      object.path_rewrite_specifier?.prefix_rewrite !== null
    ) {
      message.path_rewrite_specifier = {
        $case: "prefix_rewrite",
        prefix_rewrite: object.path_rewrite_specifier.prefix_rewrite,
      };
    }
    if (
      object.path_rewrite_specifier?.$case === "regex_rewrite" &&
      object.path_rewrite_specifier?.regex_rewrite !== undefined &&
      object.path_rewrite_specifier?.regex_rewrite !== null
    ) {
      message.path_rewrite_specifier = {
        $case: "regex_rewrite",
        regex_rewrite: RegexMatchAndSubstitute.fromPartial(object.path_rewrite_specifier.regex_rewrite),
      };
    }
    message.response_code = object.response_code ?? undefined;
    message.strip_query = object.strip_query ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RedirectAction.$type, RedirectAction);

function createBaseDirectResponseAction(): DirectResponseAction {
  return { $type: "envoy.config.route.v3.DirectResponseAction" };
}

export const DirectResponseAction: MessageFns<DirectResponseAction, "envoy.config.route.v3.DirectResponseAction"> = {
  $type: "envoy.config.route.v3.DirectResponseAction" as const,

  encode(message: DirectResponseAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined && message.status !== 0) {
      writer.uint32(8).uint32(message.status);
    }
    if (message.body !== undefined) {
      DataSource.encode(message.body, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DirectResponseAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDirectResponseAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.body = DataSource.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DirectResponseAction {
    return {
      $type: DirectResponseAction.$type,
      status: isSet(object.status) ? globalThis.Number(object.status) : undefined,
      body: isSet(object.body) ? DataSource.fromJSON(object.body) : undefined,
    };
  },

  toJSON(message: DirectResponseAction): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Math.round(message.status);
    }
    if (message.body !== undefined) {
      obj.body = DataSource.toJSON(message.body);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DirectResponseAction>, I>>(base?: I): DirectResponseAction {
    return DirectResponseAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DirectResponseAction>, I>>(object: I): DirectResponseAction {
    const message = createBaseDirectResponseAction();
    message.status = object.status ?? undefined;
    message.body = (object.body !== undefined && object.body !== null)
      ? DataSource.fromPartial(object.body)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(DirectResponseAction.$type, DirectResponseAction);

function createBaseNonForwardingAction(): NonForwardingAction {
  return { $type: "envoy.config.route.v3.NonForwardingAction" };
}

export const NonForwardingAction: MessageFns<NonForwardingAction, "envoy.config.route.v3.NonForwardingAction"> = {
  $type: "envoy.config.route.v3.NonForwardingAction" as const,

  encode(_: NonForwardingAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NonForwardingAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNonForwardingAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): NonForwardingAction {
    return { $type: NonForwardingAction.$type };
  },

  toJSON(_: NonForwardingAction): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<NonForwardingAction>, I>>(base?: I): NonForwardingAction {
    return NonForwardingAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NonForwardingAction>, I>>(_: I): NonForwardingAction {
    const message = createBaseNonForwardingAction();
    return message;
  },
};

messageTypeRegistry.set(NonForwardingAction.$type, NonForwardingAction);

function createBaseDecorator(): Decorator {
  return { $type: "envoy.config.route.v3.Decorator" };
}

export const Decorator: MessageFns<Decorator, "envoy.config.route.v3.Decorator"> = {
  $type: "envoy.config.route.v3.Decorator" as const,

  encode(message: Decorator, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operation !== undefined && message.operation !== "") {
      writer.uint32(10).string(message.operation);
    }
    if (message.propagate !== undefined) {
      BoolValue.encode({ $type: "google.protobuf.BoolValue", value: message.propagate! }, writer.uint32(18).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Decorator {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecorator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.operation = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.propagate = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Decorator {
    return {
      $type: Decorator.$type,
      operation: isSet(object.operation) ? globalThis.String(object.operation) : undefined,
      propagate: isSet(object.propagate) ? Boolean(object.propagate) : undefined,
    };
  },

  toJSON(message: Decorator): unknown {
    const obj: any = {};
    if (message.operation !== undefined) {
      obj.operation = message.operation;
    }
    if (message.propagate !== undefined) {
      obj.propagate = message.propagate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Decorator>, I>>(base?: I): Decorator {
    return Decorator.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Decorator>, I>>(object: I): Decorator {
    const message = createBaseDecorator();
    message.operation = object.operation ?? undefined;
    message.propagate = object.propagate ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Decorator.$type, Decorator);

function createBaseTracing(): Tracing {
  return { $type: "envoy.config.route.v3.Tracing" };
}

export const Tracing: MessageFns<Tracing, "envoy.config.route.v3.Tracing"> = {
  $type: "envoy.config.route.v3.Tracing" as const,

  encode(message: Tracing, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.client_sampling !== undefined) {
      FractionalPercent.encode(message.client_sampling, writer.uint32(10).fork()).join();
    }
    if (message.random_sampling !== undefined) {
      FractionalPercent.encode(message.random_sampling, writer.uint32(18).fork()).join();
    }
    if (message.overall_sampling !== undefined) {
      FractionalPercent.encode(message.overall_sampling, writer.uint32(26).fork()).join();
    }
    if (message.custom_tags !== undefined && message.custom_tags.length !== 0) {
      for (const v of message.custom_tags) {
        CustomTag.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Tracing {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTracing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.client_sampling = FractionalPercent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.random_sampling = FractionalPercent.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.overall_sampling = FractionalPercent.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          if (message.custom_tags === undefined) {
            message.custom_tags = [];
          }
          const el = CustomTag.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.custom_tags!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Tracing {
    return {
      $type: Tracing.$type,
      client_sampling: isSet(object.client_sampling) ? FractionalPercent.fromJSON(object.client_sampling) : undefined,
      random_sampling: isSet(object.random_sampling) ? FractionalPercent.fromJSON(object.random_sampling) : undefined,
      overall_sampling: isSet(object.overall_sampling)
        ? FractionalPercent.fromJSON(object.overall_sampling)
        : undefined,
      custom_tags: globalThis.Array.isArray(object?.custom_tags)
        ? object.custom_tags.map((e: any) => CustomTag.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: Tracing): unknown {
    const obj: any = {};
    if (message.client_sampling !== undefined) {
      obj.client_sampling = FractionalPercent.toJSON(message.client_sampling);
    }
    if (message.random_sampling !== undefined) {
      obj.random_sampling = FractionalPercent.toJSON(message.random_sampling);
    }
    if (message.overall_sampling !== undefined) {
      obj.overall_sampling = FractionalPercent.toJSON(message.overall_sampling);
    }
    if (message.custom_tags?.length) {
      obj.custom_tags = message.custom_tags.map((e) => CustomTag.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Tracing>, I>>(base?: I): Tracing {
    return Tracing.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Tracing>, I>>(object: I): Tracing {
    const message = createBaseTracing();
    message.client_sampling = (object.client_sampling !== undefined && object.client_sampling !== null)
      ? FractionalPercent.fromPartial(object.client_sampling)
      : undefined;
    message.random_sampling = (object.random_sampling !== undefined && object.random_sampling !== null)
      ? FractionalPercent.fromPartial(object.random_sampling)
      : undefined;
    message.overall_sampling = (object.overall_sampling !== undefined && object.overall_sampling !== null)
      ? FractionalPercent.fromPartial(object.overall_sampling)
      : undefined;
    message.custom_tags = object.custom_tags?.map((e) => CustomTag.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(Tracing.$type, Tracing);

function createBaseVirtualCluster(): VirtualCluster {
  return { $type: "envoy.config.route.v3.VirtualCluster" };
}

export const VirtualCluster: MessageFns<VirtualCluster, "envoy.config.route.v3.VirtualCluster"> = {
  $type: "envoy.config.route.v3.VirtualCluster" as const,

  encode(message: VirtualCluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.headers !== undefined && message.headers.length !== 0) {
      for (const v of message.headers) {
        HeaderMatcher.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VirtualCluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVirtualCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4: {
          if (tag !== 34) {
            break;
          }

          if (message.headers === undefined) {
            message.headers = [];
          }
          const el = HeaderMatcher.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.headers!.push(el);
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VirtualCluster {
    return {
      $type: VirtualCluster.$type,
      headers: globalThis.Array.isArray(object?.headers)
        ? object.headers.map((e: any) => HeaderMatcher.fromJSON(e))
        : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
    };
  },

  toJSON(message: VirtualCluster): unknown {
    const obj: any = {};
    if (message.headers?.length) {
      obj.headers = message.headers.map((e) => HeaderMatcher.toJSON(e));
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VirtualCluster>, I>>(base?: I): VirtualCluster {
    return VirtualCluster.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VirtualCluster>, I>>(object: I): VirtualCluster {
    const message = createBaseVirtualCluster();
    message.headers = object.headers?.map((e) => HeaderMatcher.fromPartial(e)) || undefined;
    message.name = object.name ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(VirtualCluster.$type, VirtualCluster);

function createBaseRateLimit(): RateLimit {
  return { $type: "envoy.config.route.v3.RateLimit" };
}

export const RateLimit: MessageFns<RateLimit, "envoy.config.route.v3.RateLimit"> = {
  $type: "envoy.config.route.v3.RateLimit" as const,

  encode(message: RateLimit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stage !== undefined) {
      UInt32Value.encode({ $type: "google.protobuf.UInt32Value", value: message.stage! }, writer.uint32(10).fork())
        .join();
    }
    if (message.disable_key !== undefined && message.disable_key !== "") {
      writer.uint32(18).string(message.disable_key);
    }
    if (message.actions !== undefined && message.actions.length !== 0) {
      for (const v of message.actions) {
        RateLimit_Action.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    if (message.limit !== undefined) {
      RateLimit_Override.encode(message.limit, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stage = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.disable_key = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.actions === undefined) {
            message.actions = [];
          }
          const el = RateLimit_Action.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.actions!.push(el);
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.limit = RateLimit_Override.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimit {
    return {
      $type: RateLimit.$type,
      stage: isSet(object.stage) ? Number(object.stage) : undefined,
      disable_key: isSet(object.disable_key) ? globalThis.String(object.disable_key) : undefined,
      actions: globalThis.Array.isArray(object?.actions)
        ? object.actions.map((e: any) => RateLimit_Action.fromJSON(e))
        : undefined,
      limit: isSet(object.limit) ? RateLimit_Override.fromJSON(object.limit) : undefined,
    };
  },

  toJSON(message: RateLimit): unknown {
    const obj: any = {};
    if (message.stage !== undefined) {
      obj.stage = message.stage;
    }
    if (message.disable_key !== undefined) {
      obj.disable_key = message.disable_key;
    }
    if (message.actions?.length) {
      obj.actions = message.actions.map((e) => RateLimit_Action.toJSON(e));
    }
    if (message.limit !== undefined) {
      obj.limit = RateLimit_Override.toJSON(message.limit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimit>, I>>(base?: I): RateLimit {
    return RateLimit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimit>, I>>(object: I): RateLimit {
    const message = createBaseRateLimit();
    message.stage = object.stage ?? undefined;
    message.disable_key = object.disable_key ?? undefined;
    message.actions = object.actions?.map((e) => RateLimit_Action.fromPartial(e)) || undefined;
    message.limit = (object.limit !== undefined && object.limit !== null)
      ? RateLimit_Override.fromPartial(object.limit)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(RateLimit.$type, RateLimit);

function createBaseRateLimit_Action(): RateLimit_Action {
  return { $type: "envoy.config.route.v3.RateLimit.Action", action_specifier: undefined };
}

export const RateLimit_Action: MessageFns<RateLimit_Action, "envoy.config.route.v3.RateLimit.Action"> = {
  $type: "envoy.config.route.v3.RateLimit.Action" as const,

  encode(message: RateLimit_Action, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.action_specifier?.$case) {
      case "source_cluster":
        RateLimit_Action_SourceCluster.encode(message.action_specifier.source_cluster, writer.uint32(10).fork()).join();
        break;
      case "destination_cluster":
        RateLimit_Action_DestinationCluster.encode(
          message.action_specifier.destination_cluster,
          writer.uint32(18).fork(),
        ).join();
        break;
      case "request_headers":
        RateLimit_Action_RequestHeaders.encode(message.action_specifier.request_headers, writer.uint32(26).fork())
          .join();
        break;
      case "remote_address":
        RateLimit_Action_RemoteAddress.encode(message.action_specifier.remote_address, writer.uint32(34).fork()).join();
        break;
      case "generic_key":
        RateLimit_Action_GenericKey.encode(message.action_specifier.generic_key, writer.uint32(42).fork()).join();
        break;
      case "header_value_match":
        RateLimit_Action_HeaderValueMatch.encode(message.action_specifier.header_value_match, writer.uint32(50).fork())
          .join();
        break;
      case "dynamic_metadata":
        RateLimit_Action_DynamicMetaData.encode(message.action_specifier.dynamic_metadata, writer.uint32(58).fork())
          .join();
        break;
      case "metadata":
        RateLimit_Action_MetaData.encode(message.action_specifier.metadata, writer.uint32(66).fork()).join();
        break;
      case "extension":
        TypedExtensionConfig.encode(message.action_specifier.extension, writer.uint32(74).fork()).join();
        break;
      case "masked_remote_address":
        RateLimit_Action_MaskedRemoteAddress.encode(
          message.action_specifier.masked_remote_address,
          writer.uint32(82).fork(),
        ).join();
        break;
      case "query_parameter_value_match":
        RateLimit_Action_QueryParameterValueMatch.encode(
          message.action_specifier.query_parameter_value_match,
          writer.uint32(90).fork(),
        ).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimit_Action {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimit_Action();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.action_specifier = {
            $case: "source_cluster",
            source_cluster: RateLimit_Action_SourceCluster.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.action_specifier = {
            $case: "destination_cluster",
            destination_cluster: RateLimit_Action_DestinationCluster.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.action_specifier = {
            $case: "request_headers",
            request_headers: RateLimit_Action_RequestHeaders.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.action_specifier = {
            $case: "remote_address",
            remote_address: RateLimit_Action_RemoteAddress.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.action_specifier = {
            $case: "generic_key",
            generic_key: RateLimit_Action_GenericKey.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.action_specifier = {
            $case: "header_value_match",
            header_value_match: RateLimit_Action_HeaderValueMatch.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.action_specifier = {
            $case: "dynamic_metadata",
            dynamic_metadata: RateLimit_Action_DynamicMetaData.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.action_specifier = {
            $case: "metadata",
            metadata: RateLimit_Action_MetaData.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.action_specifier = {
            $case: "extension",
            extension: TypedExtensionConfig.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.action_specifier = {
            $case: "masked_remote_address",
            masked_remote_address: RateLimit_Action_MaskedRemoteAddress.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.action_specifier = {
            $case: "query_parameter_value_match",
            query_parameter_value_match: RateLimit_Action_QueryParameterValueMatch.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimit_Action {
    return {
      $type: RateLimit_Action.$type,
      action_specifier: isSet(object.source_cluster)
        ? { $case: "source_cluster", source_cluster: RateLimit_Action_SourceCluster.fromJSON(object.source_cluster) }
        : isSet(object.destination_cluster)
        ? {
          $case: "destination_cluster",
          destination_cluster: RateLimit_Action_DestinationCluster.fromJSON(object.destination_cluster),
        }
        : isSet(object.request_headers)
        ? {
          $case: "request_headers",
          request_headers: RateLimit_Action_RequestHeaders.fromJSON(object.request_headers),
        }
        : isSet(object.remote_address)
        ? { $case: "remote_address", remote_address: RateLimit_Action_RemoteAddress.fromJSON(object.remote_address) }
        : isSet(object.generic_key)
        ? { $case: "generic_key", generic_key: RateLimit_Action_GenericKey.fromJSON(object.generic_key) }
        : isSet(object.header_value_match)
        ? {
          $case: "header_value_match",
          header_value_match: RateLimit_Action_HeaderValueMatch.fromJSON(object.header_value_match),
        }
        : isSet(object.dynamic_metadata)
        ? {
          $case: "dynamic_metadata",
          dynamic_metadata: RateLimit_Action_DynamicMetaData.fromJSON(object.dynamic_metadata),
        }
        : isSet(object.metadata)
        ? { $case: "metadata", metadata: RateLimit_Action_MetaData.fromJSON(object.metadata) }
        : isSet(object.extension)
        ? { $case: "extension", extension: TypedExtensionConfig.fromJSON(object.extension) }
        : isSet(object.masked_remote_address)
        ? {
          $case: "masked_remote_address",
          masked_remote_address: RateLimit_Action_MaskedRemoteAddress.fromJSON(object.masked_remote_address),
        }
        : isSet(object.query_parameter_value_match)
        ? {
          $case: "query_parameter_value_match",
          query_parameter_value_match: RateLimit_Action_QueryParameterValueMatch.fromJSON(
            object.query_parameter_value_match,
          ),
        }
        : undefined,
    };
  },

  toJSON(message: RateLimit_Action): unknown {
    const obj: any = {};
    if (message.action_specifier?.$case === "source_cluster") {
      obj.source_cluster = RateLimit_Action_SourceCluster.toJSON(message.action_specifier.source_cluster);
    }
    if (message.action_specifier?.$case === "destination_cluster") {
      obj.destination_cluster = RateLimit_Action_DestinationCluster.toJSON(
        message.action_specifier.destination_cluster,
      );
    }
    if (message.action_specifier?.$case === "request_headers") {
      obj.request_headers = RateLimit_Action_RequestHeaders.toJSON(message.action_specifier.request_headers);
    }
    if (message.action_specifier?.$case === "remote_address") {
      obj.remote_address = RateLimit_Action_RemoteAddress.toJSON(message.action_specifier.remote_address);
    }
    if (message.action_specifier?.$case === "generic_key") {
      obj.generic_key = RateLimit_Action_GenericKey.toJSON(message.action_specifier.generic_key);
    }
    if (message.action_specifier?.$case === "header_value_match") {
      obj.header_value_match = RateLimit_Action_HeaderValueMatch.toJSON(message.action_specifier.header_value_match);
    }
    if (message.action_specifier?.$case === "dynamic_metadata") {
      obj.dynamic_metadata = RateLimit_Action_DynamicMetaData.toJSON(message.action_specifier.dynamic_metadata);
    }
    if (message.action_specifier?.$case === "metadata") {
      obj.metadata = RateLimit_Action_MetaData.toJSON(message.action_specifier.metadata);
    }
    if (message.action_specifier?.$case === "extension") {
      obj.extension = TypedExtensionConfig.toJSON(message.action_specifier.extension);
    }
    if (message.action_specifier?.$case === "masked_remote_address") {
      obj.masked_remote_address = RateLimit_Action_MaskedRemoteAddress.toJSON(
        message.action_specifier.masked_remote_address,
      );
    }
    if (message.action_specifier?.$case === "query_parameter_value_match") {
      obj.query_parameter_value_match = RateLimit_Action_QueryParameterValueMatch.toJSON(
        message.action_specifier.query_parameter_value_match,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimit_Action>, I>>(base?: I): RateLimit_Action {
    return RateLimit_Action.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimit_Action>, I>>(object: I): RateLimit_Action {
    const message = createBaseRateLimit_Action();
    if (
      object.action_specifier?.$case === "source_cluster" &&
      object.action_specifier?.source_cluster !== undefined &&
      object.action_specifier?.source_cluster !== null
    ) {
      message.action_specifier = {
        $case: "source_cluster",
        source_cluster: RateLimit_Action_SourceCluster.fromPartial(object.action_specifier.source_cluster),
      };
    }
    if (
      object.action_specifier?.$case === "destination_cluster" &&
      object.action_specifier?.destination_cluster !== undefined &&
      object.action_specifier?.destination_cluster !== null
    ) {
      message.action_specifier = {
        $case: "destination_cluster",
        destination_cluster: RateLimit_Action_DestinationCluster.fromPartial(
          object.action_specifier.destination_cluster,
        ),
      };
    }
    if (
      object.action_specifier?.$case === "request_headers" &&
      object.action_specifier?.request_headers !== undefined &&
      object.action_specifier?.request_headers !== null
    ) {
      message.action_specifier = {
        $case: "request_headers",
        request_headers: RateLimit_Action_RequestHeaders.fromPartial(object.action_specifier.request_headers),
      };
    }
    if (
      object.action_specifier?.$case === "remote_address" &&
      object.action_specifier?.remote_address !== undefined &&
      object.action_specifier?.remote_address !== null
    ) {
      message.action_specifier = {
        $case: "remote_address",
        remote_address: RateLimit_Action_RemoteAddress.fromPartial(object.action_specifier.remote_address),
      };
    }
    if (
      object.action_specifier?.$case === "generic_key" &&
      object.action_specifier?.generic_key !== undefined &&
      object.action_specifier?.generic_key !== null
    ) {
      message.action_specifier = {
        $case: "generic_key",
        generic_key: RateLimit_Action_GenericKey.fromPartial(object.action_specifier.generic_key),
      };
    }
    if (
      object.action_specifier?.$case === "header_value_match" &&
      object.action_specifier?.header_value_match !== undefined &&
      object.action_specifier?.header_value_match !== null
    ) {
      message.action_specifier = {
        $case: "header_value_match",
        header_value_match: RateLimit_Action_HeaderValueMatch.fromPartial(object.action_specifier.header_value_match),
      };
    }
    if (
      object.action_specifier?.$case === "dynamic_metadata" &&
      object.action_specifier?.dynamic_metadata !== undefined &&
      object.action_specifier?.dynamic_metadata !== null
    ) {
      message.action_specifier = {
        $case: "dynamic_metadata",
        dynamic_metadata: RateLimit_Action_DynamicMetaData.fromPartial(object.action_specifier.dynamic_metadata),
      };
    }
    if (
      object.action_specifier?.$case === "metadata" &&
      object.action_specifier?.metadata !== undefined &&
      object.action_specifier?.metadata !== null
    ) {
      message.action_specifier = {
        $case: "metadata",
        metadata: RateLimit_Action_MetaData.fromPartial(object.action_specifier.metadata),
      };
    }
    if (
      object.action_specifier?.$case === "extension" &&
      object.action_specifier?.extension !== undefined &&
      object.action_specifier?.extension !== null
    ) {
      message.action_specifier = {
        $case: "extension",
        extension: TypedExtensionConfig.fromPartial(object.action_specifier.extension),
      };
    }
    if (
      object.action_specifier?.$case === "masked_remote_address" &&
      object.action_specifier?.masked_remote_address !== undefined &&
      object.action_specifier?.masked_remote_address !== null
    ) {
      message.action_specifier = {
        $case: "masked_remote_address",
        masked_remote_address: RateLimit_Action_MaskedRemoteAddress.fromPartial(
          object.action_specifier.masked_remote_address,
        ),
      };
    }
    if (
      object.action_specifier?.$case === "query_parameter_value_match" &&
      object.action_specifier?.query_parameter_value_match !== undefined &&
      object.action_specifier?.query_parameter_value_match !== null
    ) {
      message.action_specifier = {
        $case: "query_parameter_value_match",
        query_parameter_value_match: RateLimit_Action_QueryParameterValueMatch.fromPartial(
          object.action_specifier.query_parameter_value_match,
        ),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(RateLimit_Action.$type, RateLimit_Action);

function createBaseRateLimit_Action_SourceCluster(): RateLimit_Action_SourceCluster {
  return { $type: "envoy.config.route.v3.RateLimit.Action.SourceCluster" };
}

export const RateLimit_Action_SourceCluster: MessageFns<
  RateLimit_Action_SourceCluster,
  "envoy.config.route.v3.RateLimit.Action.SourceCluster"
> = {
  $type: "envoy.config.route.v3.RateLimit.Action.SourceCluster" as const,

  encode(_: RateLimit_Action_SourceCluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimit_Action_SourceCluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimit_Action_SourceCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RateLimit_Action_SourceCluster {
    return { $type: RateLimit_Action_SourceCluster.$type };
  },

  toJSON(_: RateLimit_Action_SourceCluster): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimit_Action_SourceCluster>, I>>(base?: I): RateLimit_Action_SourceCluster {
    return RateLimit_Action_SourceCluster.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimit_Action_SourceCluster>, I>>(_: I): RateLimit_Action_SourceCluster {
    const message = createBaseRateLimit_Action_SourceCluster();
    return message;
  },
};

messageTypeRegistry.set(RateLimit_Action_SourceCluster.$type, RateLimit_Action_SourceCluster);

function createBaseRateLimit_Action_DestinationCluster(): RateLimit_Action_DestinationCluster {
  return { $type: "envoy.config.route.v3.RateLimit.Action.DestinationCluster" };
}

export const RateLimit_Action_DestinationCluster: MessageFns<
  RateLimit_Action_DestinationCluster,
  "envoy.config.route.v3.RateLimit.Action.DestinationCluster"
> = {
  $type: "envoy.config.route.v3.RateLimit.Action.DestinationCluster" as const,

  encode(_: RateLimit_Action_DestinationCluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimit_Action_DestinationCluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimit_Action_DestinationCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RateLimit_Action_DestinationCluster {
    return { $type: RateLimit_Action_DestinationCluster.$type };
  },

  toJSON(_: RateLimit_Action_DestinationCluster): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimit_Action_DestinationCluster>, I>>(
    base?: I,
  ): RateLimit_Action_DestinationCluster {
    return RateLimit_Action_DestinationCluster.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimit_Action_DestinationCluster>, I>>(
    _: I,
  ): RateLimit_Action_DestinationCluster {
    const message = createBaseRateLimit_Action_DestinationCluster();
    return message;
  },
};

messageTypeRegistry.set(RateLimit_Action_DestinationCluster.$type, RateLimit_Action_DestinationCluster);

function createBaseRateLimit_Action_RequestHeaders(): RateLimit_Action_RequestHeaders {
  return { $type: "envoy.config.route.v3.RateLimit.Action.RequestHeaders" };
}

export const RateLimit_Action_RequestHeaders: MessageFns<
  RateLimit_Action_RequestHeaders,
  "envoy.config.route.v3.RateLimit.Action.RequestHeaders"
> = {
  $type: "envoy.config.route.v3.RateLimit.Action.RequestHeaders" as const,

  encode(message: RateLimit_Action_RequestHeaders, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header_name !== undefined && message.header_name !== "") {
      writer.uint32(10).string(message.header_name);
    }
    if (message.descriptor_key !== undefined && message.descriptor_key !== "") {
      writer.uint32(18).string(message.descriptor_key);
    }
    if (message.skip_if_absent !== undefined && message.skip_if_absent !== false) {
      writer.uint32(24).bool(message.skip_if_absent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimit_Action_RequestHeaders {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimit_Action_RequestHeaders();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header_name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.descriptor_key = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.skip_if_absent = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimit_Action_RequestHeaders {
    return {
      $type: RateLimit_Action_RequestHeaders.$type,
      header_name: isSet(object.header_name) ? globalThis.String(object.header_name) : undefined,
      descriptor_key: isSet(object.descriptor_key) ? globalThis.String(object.descriptor_key) : undefined,
      skip_if_absent: isSet(object.skip_if_absent) ? globalThis.Boolean(object.skip_if_absent) : undefined,
    };
  },

  toJSON(message: RateLimit_Action_RequestHeaders): unknown {
    const obj: any = {};
    if (message.header_name !== undefined) {
      obj.header_name = message.header_name;
    }
    if (message.descriptor_key !== undefined) {
      obj.descriptor_key = message.descriptor_key;
    }
    if (message.skip_if_absent !== undefined) {
      obj.skip_if_absent = message.skip_if_absent;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimit_Action_RequestHeaders>, I>>(base?: I): RateLimit_Action_RequestHeaders {
    return RateLimit_Action_RequestHeaders.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimit_Action_RequestHeaders>, I>>(
    object: I,
  ): RateLimit_Action_RequestHeaders {
    const message = createBaseRateLimit_Action_RequestHeaders();
    message.header_name = object.header_name ?? undefined;
    message.descriptor_key = object.descriptor_key ?? undefined;
    message.skip_if_absent = object.skip_if_absent ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RateLimit_Action_RequestHeaders.$type, RateLimit_Action_RequestHeaders);

function createBaseRateLimit_Action_RemoteAddress(): RateLimit_Action_RemoteAddress {
  return { $type: "envoy.config.route.v3.RateLimit.Action.RemoteAddress" };
}

export const RateLimit_Action_RemoteAddress: MessageFns<
  RateLimit_Action_RemoteAddress,
  "envoy.config.route.v3.RateLimit.Action.RemoteAddress"
> = {
  $type: "envoy.config.route.v3.RateLimit.Action.RemoteAddress" as const,

  encode(_: RateLimit_Action_RemoteAddress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimit_Action_RemoteAddress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimit_Action_RemoteAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RateLimit_Action_RemoteAddress {
    return { $type: RateLimit_Action_RemoteAddress.$type };
  },

  toJSON(_: RateLimit_Action_RemoteAddress): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimit_Action_RemoteAddress>, I>>(base?: I): RateLimit_Action_RemoteAddress {
    return RateLimit_Action_RemoteAddress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimit_Action_RemoteAddress>, I>>(_: I): RateLimit_Action_RemoteAddress {
    const message = createBaseRateLimit_Action_RemoteAddress();
    return message;
  },
};

messageTypeRegistry.set(RateLimit_Action_RemoteAddress.$type, RateLimit_Action_RemoteAddress);

function createBaseRateLimit_Action_MaskedRemoteAddress(): RateLimit_Action_MaskedRemoteAddress {
  return { $type: "envoy.config.route.v3.RateLimit.Action.MaskedRemoteAddress" };
}

export const RateLimit_Action_MaskedRemoteAddress: MessageFns<
  RateLimit_Action_MaskedRemoteAddress,
  "envoy.config.route.v3.RateLimit.Action.MaskedRemoteAddress"
> = {
  $type: "envoy.config.route.v3.RateLimit.Action.MaskedRemoteAddress" as const,

  encode(message: RateLimit_Action_MaskedRemoteAddress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.v4_prefix_mask_len !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.v4_prefix_mask_len! },
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.v6_prefix_mask_len !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.v6_prefix_mask_len! },
        writer.uint32(18).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimit_Action_MaskedRemoteAddress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimit_Action_MaskedRemoteAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.v4_prefix_mask_len = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.v6_prefix_mask_len = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimit_Action_MaskedRemoteAddress {
    return {
      $type: RateLimit_Action_MaskedRemoteAddress.$type,
      v4_prefix_mask_len: isSet(object.v4_prefix_mask_len) ? Number(object.v4_prefix_mask_len) : undefined,
      v6_prefix_mask_len: isSet(object.v6_prefix_mask_len) ? Number(object.v6_prefix_mask_len) : undefined,
    };
  },

  toJSON(message: RateLimit_Action_MaskedRemoteAddress): unknown {
    const obj: any = {};
    if (message.v4_prefix_mask_len !== undefined) {
      obj.v4_prefix_mask_len = message.v4_prefix_mask_len;
    }
    if (message.v6_prefix_mask_len !== undefined) {
      obj.v6_prefix_mask_len = message.v6_prefix_mask_len;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimit_Action_MaskedRemoteAddress>, I>>(
    base?: I,
  ): RateLimit_Action_MaskedRemoteAddress {
    return RateLimit_Action_MaskedRemoteAddress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimit_Action_MaskedRemoteAddress>, I>>(
    object: I,
  ): RateLimit_Action_MaskedRemoteAddress {
    const message = createBaseRateLimit_Action_MaskedRemoteAddress();
    message.v4_prefix_mask_len = object.v4_prefix_mask_len ?? undefined;
    message.v6_prefix_mask_len = object.v6_prefix_mask_len ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RateLimit_Action_MaskedRemoteAddress.$type, RateLimit_Action_MaskedRemoteAddress);

function createBaseRateLimit_Action_GenericKey(): RateLimit_Action_GenericKey {
  return { $type: "envoy.config.route.v3.RateLimit.Action.GenericKey" };
}

export const RateLimit_Action_GenericKey: MessageFns<
  RateLimit_Action_GenericKey,
  "envoy.config.route.v3.RateLimit.Action.GenericKey"
> = {
  $type: "envoy.config.route.v3.RateLimit.Action.GenericKey" as const,

  encode(message: RateLimit_Action_GenericKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.descriptor_value !== undefined && message.descriptor_value !== "") {
      writer.uint32(10).string(message.descriptor_value);
    }
    if (message.descriptor_key !== undefined && message.descriptor_key !== "") {
      writer.uint32(18).string(message.descriptor_key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimit_Action_GenericKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimit_Action_GenericKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.descriptor_value = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.descriptor_key = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimit_Action_GenericKey {
    return {
      $type: RateLimit_Action_GenericKey.$type,
      descriptor_value: isSet(object.descriptor_value) ? globalThis.String(object.descriptor_value) : undefined,
      descriptor_key: isSet(object.descriptor_key) ? globalThis.String(object.descriptor_key) : undefined,
    };
  },

  toJSON(message: RateLimit_Action_GenericKey): unknown {
    const obj: any = {};
    if (message.descriptor_value !== undefined) {
      obj.descriptor_value = message.descriptor_value;
    }
    if (message.descriptor_key !== undefined) {
      obj.descriptor_key = message.descriptor_key;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimit_Action_GenericKey>, I>>(base?: I): RateLimit_Action_GenericKey {
    return RateLimit_Action_GenericKey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimit_Action_GenericKey>, I>>(object: I): RateLimit_Action_GenericKey {
    const message = createBaseRateLimit_Action_GenericKey();
    message.descriptor_value = object.descriptor_value ?? undefined;
    message.descriptor_key = object.descriptor_key ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RateLimit_Action_GenericKey.$type, RateLimit_Action_GenericKey);

function createBaseRateLimit_Action_HeaderValueMatch(): RateLimit_Action_HeaderValueMatch {
  return { $type: "envoy.config.route.v3.RateLimit.Action.HeaderValueMatch" };
}

export const RateLimit_Action_HeaderValueMatch: MessageFns<
  RateLimit_Action_HeaderValueMatch,
  "envoy.config.route.v3.RateLimit.Action.HeaderValueMatch"
> = {
  $type: "envoy.config.route.v3.RateLimit.Action.HeaderValueMatch" as const,

  encode(message: RateLimit_Action_HeaderValueMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.descriptor_key !== undefined && message.descriptor_key !== "") {
      writer.uint32(34).string(message.descriptor_key);
    }
    if (message.descriptor_value !== undefined && message.descriptor_value !== "") {
      writer.uint32(10).string(message.descriptor_value);
    }
    if (message.expect_match !== undefined) {
      BoolValue.encode({ $type: "google.protobuf.BoolValue", value: message.expect_match! }, writer.uint32(18).fork())
        .join();
    }
    if (message.headers !== undefined && message.headers.length !== 0) {
      for (const v of message.headers) {
        HeaderMatcher.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimit_Action_HeaderValueMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimit_Action_HeaderValueMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.descriptor_key = reader.string();
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.descriptor_value = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.expect_match = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.headers === undefined) {
            message.headers = [];
          }
          const el = HeaderMatcher.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.headers!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimit_Action_HeaderValueMatch {
    return {
      $type: RateLimit_Action_HeaderValueMatch.$type,
      descriptor_key: isSet(object.descriptor_key) ? globalThis.String(object.descriptor_key) : undefined,
      descriptor_value: isSet(object.descriptor_value) ? globalThis.String(object.descriptor_value) : undefined,
      expect_match: isSet(object.expect_match) ? Boolean(object.expect_match) : undefined,
      headers: globalThis.Array.isArray(object?.headers)
        ? object.headers.map((e: any) => HeaderMatcher.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: RateLimit_Action_HeaderValueMatch): unknown {
    const obj: any = {};
    if (message.descriptor_key !== undefined) {
      obj.descriptor_key = message.descriptor_key;
    }
    if (message.descriptor_value !== undefined) {
      obj.descriptor_value = message.descriptor_value;
    }
    if (message.expect_match !== undefined) {
      obj.expect_match = message.expect_match;
    }
    if (message.headers?.length) {
      obj.headers = message.headers.map((e) => HeaderMatcher.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimit_Action_HeaderValueMatch>, I>>(
    base?: I,
  ): RateLimit_Action_HeaderValueMatch {
    return RateLimit_Action_HeaderValueMatch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimit_Action_HeaderValueMatch>, I>>(
    object: I,
  ): RateLimit_Action_HeaderValueMatch {
    const message = createBaseRateLimit_Action_HeaderValueMatch();
    message.descriptor_key = object.descriptor_key ?? undefined;
    message.descriptor_value = object.descriptor_value ?? undefined;
    message.expect_match = object.expect_match ?? undefined;
    message.headers = object.headers?.map((e) => HeaderMatcher.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(RateLimit_Action_HeaderValueMatch.$type, RateLimit_Action_HeaderValueMatch);

function createBaseRateLimit_Action_DynamicMetaData(): RateLimit_Action_DynamicMetaData {
  return { $type: "envoy.config.route.v3.RateLimit.Action.DynamicMetaData" };
}

export const RateLimit_Action_DynamicMetaData: MessageFns<
  RateLimit_Action_DynamicMetaData,
  "envoy.config.route.v3.RateLimit.Action.DynamicMetaData"
> = {
  $type: "envoy.config.route.v3.RateLimit.Action.DynamicMetaData" as const,

  encode(message: RateLimit_Action_DynamicMetaData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.descriptor_key !== undefined && message.descriptor_key !== "") {
      writer.uint32(10).string(message.descriptor_key);
    }
    if (message.metadata_key !== undefined) {
      MetadataKey.encode(message.metadata_key, writer.uint32(18).fork()).join();
    }
    if (message.default_value !== undefined && message.default_value !== "") {
      writer.uint32(26).string(message.default_value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimit_Action_DynamicMetaData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimit_Action_DynamicMetaData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.descriptor_key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.metadata_key = MetadataKey.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.default_value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimit_Action_DynamicMetaData {
    return {
      $type: RateLimit_Action_DynamicMetaData.$type,
      descriptor_key: isSet(object.descriptor_key) ? globalThis.String(object.descriptor_key) : undefined,
      metadata_key: isSet(object.metadata_key) ? MetadataKey.fromJSON(object.metadata_key) : undefined,
      default_value: isSet(object.default_value) ? globalThis.String(object.default_value) : undefined,
    };
  },

  toJSON(message: RateLimit_Action_DynamicMetaData): unknown {
    const obj: any = {};
    if (message.descriptor_key !== undefined) {
      obj.descriptor_key = message.descriptor_key;
    }
    if (message.metadata_key !== undefined) {
      obj.metadata_key = MetadataKey.toJSON(message.metadata_key);
    }
    if (message.default_value !== undefined) {
      obj.default_value = message.default_value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimit_Action_DynamicMetaData>, I>>(
    base?: I,
  ): RateLimit_Action_DynamicMetaData {
    return RateLimit_Action_DynamicMetaData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimit_Action_DynamicMetaData>, I>>(
    object: I,
  ): RateLimit_Action_DynamicMetaData {
    const message = createBaseRateLimit_Action_DynamicMetaData();
    message.descriptor_key = object.descriptor_key ?? undefined;
    message.metadata_key = (object.metadata_key !== undefined && object.metadata_key !== null)
      ? MetadataKey.fromPartial(object.metadata_key)
      : undefined;
    message.default_value = object.default_value ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RateLimit_Action_DynamicMetaData.$type, RateLimit_Action_DynamicMetaData);

function createBaseRateLimit_Action_MetaData(): RateLimit_Action_MetaData {
  return { $type: "envoy.config.route.v3.RateLimit.Action.MetaData" };
}

export const RateLimit_Action_MetaData: MessageFns<
  RateLimit_Action_MetaData,
  "envoy.config.route.v3.RateLimit.Action.MetaData"
> = {
  $type: "envoy.config.route.v3.RateLimit.Action.MetaData" as const,

  encode(message: RateLimit_Action_MetaData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.descriptor_key !== undefined && message.descriptor_key !== "") {
      writer.uint32(10).string(message.descriptor_key);
    }
    if (message.metadata_key !== undefined) {
      MetadataKey.encode(message.metadata_key, writer.uint32(18).fork()).join();
    }
    if (message.default_value !== undefined && message.default_value !== "") {
      writer.uint32(26).string(message.default_value);
    }
    if (message.source !== undefined && message.source !== RateLimit_Action_MetaData_Source.DYNAMIC) {
      writer.uint32(32).int32(rateLimit_Action_MetaData_SourceToNumber(message.source));
    }
    if (message.skip_if_absent !== undefined && message.skip_if_absent !== false) {
      writer.uint32(40).bool(message.skip_if_absent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimit_Action_MetaData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimit_Action_MetaData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.descriptor_key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.metadata_key = MetadataKey.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.default_value = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.source = rateLimit_Action_MetaData_SourceFromJSON(reader.int32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.skip_if_absent = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimit_Action_MetaData {
    return {
      $type: RateLimit_Action_MetaData.$type,
      descriptor_key: isSet(object.descriptor_key) ? globalThis.String(object.descriptor_key) : undefined,
      metadata_key: isSet(object.metadata_key) ? MetadataKey.fromJSON(object.metadata_key) : undefined,
      default_value: isSet(object.default_value) ? globalThis.String(object.default_value) : undefined,
      source: isSet(object.source) ? rateLimit_Action_MetaData_SourceFromJSON(object.source) : undefined,
      skip_if_absent: isSet(object.skip_if_absent) ? globalThis.Boolean(object.skip_if_absent) : undefined,
    };
  },

  toJSON(message: RateLimit_Action_MetaData): unknown {
    const obj: any = {};
    if (message.descriptor_key !== undefined) {
      obj.descriptor_key = message.descriptor_key;
    }
    if (message.metadata_key !== undefined) {
      obj.metadata_key = MetadataKey.toJSON(message.metadata_key);
    }
    if (message.default_value !== undefined) {
      obj.default_value = message.default_value;
    }
    if (message.source !== undefined) {
      obj.source = rateLimit_Action_MetaData_SourceToJSON(message.source);
    }
    if (message.skip_if_absent !== undefined) {
      obj.skip_if_absent = message.skip_if_absent;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimit_Action_MetaData>, I>>(base?: I): RateLimit_Action_MetaData {
    return RateLimit_Action_MetaData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimit_Action_MetaData>, I>>(object: I): RateLimit_Action_MetaData {
    const message = createBaseRateLimit_Action_MetaData();
    message.descriptor_key = object.descriptor_key ?? undefined;
    message.metadata_key = (object.metadata_key !== undefined && object.metadata_key !== null)
      ? MetadataKey.fromPartial(object.metadata_key)
      : undefined;
    message.default_value = object.default_value ?? undefined;
    message.source = object.source ?? undefined;
    message.skip_if_absent = object.skip_if_absent ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RateLimit_Action_MetaData.$type, RateLimit_Action_MetaData);

function createBaseRateLimit_Action_QueryParameterValueMatch(): RateLimit_Action_QueryParameterValueMatch {
  return { $type: "envoy.config.route.v3.RateLimit.Action.QueryParameterValueMatch" };
}

export const RateLimit_Action_QueryParameterValueMatch: MessageFns<
  RateLimit_Action_QueryParameterValueMatch,
  "envoy.config.route.v3.RateLimit.Action.QueryParameterValueMatch"
> = {
  $type: "envoy.config.route.v3.RateLimit.Action.QueryParameterValueMatch" as const,

  encode(message: RateLimit_Action_QueryParameterValueMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.descriptor_key !== undefined && message.descriptor_key !== "") {
      writer.uint32(34).string(message.descriptor_key);
    }
    if (message.descriptor_value !== undefined && message.descriptor_value !== "") {
      writer.uint32(10).string(message.descriptor_value);
    }
    if (message.expect_match !== undefined) {
      BoolValue.encode({ $type: "google.protobuf.BoolValue", value: message.expect_match! }, writer.uint32(18).fork())
        .join();
    }
    if (message.query_parameters !== undefined && message.query_parameters.length !== 0) {
      for (const v of message.query_parameters) {
        QueryParameterMatcher.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimit_Action_QueryParameterValueMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimit_Action_QueryParameterValueMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.descriptor_key = reader.string();
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.descriptor_value = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.expect_match = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.query_parameters === undefined) {
            message.query_parameters = [];
          }
          const el = QueryParameterMatcher.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.query_parameters!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimit_Action_QueryParameterValueMatch {
    return {
      $type: RateLimit_Action_QueryParameterValueMatch.$type,
      descriptor_key: isSet(object.descriptor_key) ? globalThis.String(object.descriptor_key) : undefined,
      descriptor_value: isSet(object.descriptor_value) ? globalThis.String(object.descriptor_value) : undefined,
      expect_match: isSet(object.expect_match) ? Boolean(object.expect_match) : undefined,
      query_parameters: globalThis.Array.isArray(object?.query_parameters)
        ? object.query_parameters.map((e: any) => QueryParameterMatcher.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: RateLimit_Action_QueryParameterValueMatch): unknown {
    const obj: any = {};
    if (message.descriptor_key !== undefined) {
      obj.descriptor_key = message.descriptor_key;
    }
    if (message.descriptor_value !== undefined) {
      obj.descriptor_value = message.descriptor_value;
    }
    if (message.expect_match !== undefined) {
      obj.expect_match = message.expect_match;
    }
    if (message.query_parameters?.length) {
      obj.query_parameters = message.query_parameters.map((e) => QueryParameterMatcher.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimit_Action_QueryParameterValueMatch>, I>>(
    base?: I,
  ): RateLimit_Action_QueryParameterValueMatch {
    return RateLimit_Action_QueryParameterValueMatch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimit_Action_QueryParameterValueMatch>, I>>(
    object: I,
  ): RateLimit_Action_QueryParameterValueMatch {
    const message = createBaseRateLimit_Action_QueryParameterValueMatch();
    message.descriptor_key = object.descriptor_key ?? undefined;
    message.descriptor_value = object.descriptor_value ?? undefined;
    message.expect_match = object.expect_match ?? undefined;
    message.query_parameters = object.query_parameters?.map((e) => QueryParameterMatcher.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(RateLimit_Action_QueryParameterValueMatch.$type, RateLimit_Action_QueryParameterValueMatch);

function createBaseRateLimit_Override(): RateLimit_Override {
  return { $type: "envoy.config.route.v3.RateLimit.Override", override_specifier: undefined };
}

export const RateLimit_Override: MessageFns<RateLimit_Override, "envoy.config.route.v3.RateLimit.Override"> = {
  $type: "envoy.config.route.v3.RateLimit.Override" as const,

  encode(message: RateLimit_Override, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.override_specifier?.$case) {
      case "dynamic_metadata":
        RateLimit_Override_DynamicMetadata.encode(message.override_specifier.dynamic_metadata, writer.uint32(10).fork())
          .join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimit_Override {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimit_Override();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.override_specifier = {
            $case: "dynamic_metadata",
            dynamic_metadata: RateLimit_Override_DynamicMetadata.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimit_Override {
    return {
      $type: RateLimit_Override.$type,
      override_specifier: isSet(object.dynamic_metadata)
        ? {
          $case: "dynamic_metadata",
          dynamic_metadata: RateLimit_Override_DynamicMetadata.fromJSON(object.dynamic_metadata),
        }
        : undefined,
    };
  },

  toJSON(message: RateLimit_Override): unknown {
    const obj: any = {};
    if (message.override_specifier?.$case === "dynamic_metadata") {
      obj.dynamic_metadata = RateLimit_Override_DynamicMetadata.toJSON(message.override_specifier.dynamic_metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimit_Override>, I>>(base?: I): RateLimit_Override {
    return RateLimit_Override.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimit_Override>, I>>(object: I): RateLimit_Override {
    const message = createBaseRateLimit_Override();
    if (
      object.override_specifier?.$case === "dynamic_metadata" &&
      object.override_specifier?.dynamic_metadata !== undefined &&
      object.override_specifier?.dynamic_metadata !== null
    ) {
      message.override_specifier = {
        $case: "dynamic_metadata",
        dynamic_metadata: RateLimit_Override_DynamicMetadata.fromPartial(object.override_specifier.dynamic_metadata),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(RateLimit_Override.$type, RateLimit_Override);

function createBaseRateLimit_Override_DynamicMetadata(): RateLimit_Override_DynamicMetadata {
  return { $type: "envoy.config.route.v3.RateLimit.Override.DynamicMetadata" };
}

export const RateLimit_Override_DynamicMetadata: MessageFns<
  RateLimit_Override_DynamicMetadata,
  "envoy.config.route.v3.RateLimit.Override.DynamicMetadata"
> = {
  $type: "envoy.config.route.v3.RateLimit.Override.DynamicMetadata" as const,

  encode(message: RateLimit_Override_DynamicMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadata_key !== undefined) {
      MetadataKey.encode(message.metadata_key, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimit_Override_DynamicMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimit_Override_DynamicMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.metadata_key = MetadataKey.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimit_Override_DynamicMetadata {
    return {
      $type: RateLimit_Override_DynamicMetadata.$type,
      metadata_key: isSet(object.metadata_key) ? MetadataKey.fromJSON(object.metadata_key) : undefined,
    };
  },

  toJSON(message: RateLimit_Override_DynamicMetadata): unknown {
    const obj: any = {};
    if (message.metadata_key !== undefined) {
      obj.metadata_key = MetadataKey.toJSON(message.metadata_key);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimit_Override_DynamicMetadata>, I>>(
    base?: I,
  ): RateLimit_Override_DynamicMetadata {
    return RateLimit_Override_DynamicMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimit_Override_DynamicMetadata>, I>>(
    object: I,
  ): RateLimit_Override_DynamicMetadata {
    const message = createBaseRateLimit_Override_DynamicMetadata();
    message.metadata_key = (object.metadata_key !== undefined && object.metadata_key !== null)
      ? MetadataKey.fromPartial(object.metadata_key)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(RateLimit_Override_DynamicMetadata.$type, RateLimit_Override_DynamicMetadata);

function createBaseHeaderMatcher(): HeaderMatcher {
  return { $type: "envoy.config.route.v3.HeaderMatcher", header_match_specifier: undefined };
}

export const HeaderMatcher: MessageFns<HeaderMatcher, "envoy.config.route.v3.HeaderMatcher"> = {
  $type: "envoy.config.route.v3.HeaderMatcher" as const,

  encode(message: HeaderMatcher, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    switch (message.header_match_specifier?.$case) {
      case "exact_match":
        writer.uint32(34).string(message.header_match_specifier.exact_match);
        break;
      case "safe_regex_match":
        RegexMatcher.encode(message.header_match_specifier.safe_regex_match, writer.uint32(90).fork()).join();
        break;
      case "range_match":
        Int64Range.encode(message.header_match_specifier.range_match, writer.uint32(50).fork()).join();
        break;
      case "present_match":
        writer.uint32(56).bool(message.header_match_specifier.present_match);
        break;
      case "prefix_match":
        writer.uint32(74).string(message.header_match_specifier.prefix_match);
        break;
      case "suffix_match":
        writer.uint32(82).string(message.header_match_specifier.suffix_match);
        break;
      case "contains_match":
        writer.uint32(98).string(message.header_match_specifier.contains_match);
        break;
      case "string_match":
        StringMatcher.encode(message.header_match_specifier.string_match, writer.uint32(106).fork()).join();
        break;
    }
    if (message.invert_match !== undefined && message.invert_match !== false) {
      writer.uint32(64).bool(message.invert_match);
    }
    if (message.treat_missing_header_as_empty !== undefined && message.treat_missing_header_as_empty !== false) {
      writer.uint32(112).bool(message.treat_missing_header_as_empty);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeaderMatcher {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeaderMatcher();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.header_match_specifier = { $case: "exact_match", exact_match: reader.string() };
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.header_match_specifier = {
            $case: "safe_regex_match",
            safe_regex_match: RegexMatcher.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.header_match_specifier = {
            $case: "range_match",
            range_match: Int64Range.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.header_match_specifier = { $case: "present_match", present_match: reader.bool() };
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.header_match_specifier = { $case: "prefix_match", prefix_match: reader.string() };
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.header_match_specifier = { $case: "suffix_match", suffix_match: reader.string() };
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.header_match_specifier = { $case: "contains_match", contains_match: reader.string() };
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.header_match_specifier = {
            $case: "string_match",
            string_match: StringMatcher.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.invert_match = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.treat_missing_header_as_empty = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeaderMatcher {
    return {
      $type: HeaderMatcher.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      header_match_specifier: isSet(object.exact_match)
        ? { $case: "exact_match", exact_match: globalThis.String(object.exact_match) }
        : isSet(object.safe_regex_match)
        ? { $case: "safe_regex_match", safe_regex_match: RegexMatcher.fromJSON(object.safe_regex_match) }
        : isSet(object.range_match)
        ? { $case: "range_match", range_match: Int64Range.fromJSON(object.range_match) }
        : isSet(object.present_match)
        ? { $case: "present_match", present_match: globalThis.Boolean(object.present_match) }
        : isSet(object.prefix_match)
        ? { $case: "prefix_match", prefix_match: globalThis.String(object.prefix_match) }
        : isSet(object.suffix_match)
        ? { $case: "suffix_match", suffix_match: globalThis.String(object.suffix_match) }
        : isSet(object.contains_match)
        ? { $case: "contains_match", contains_match: globalThis.String(object.contains_match) }
        : isSet(object.string_match)
        ? { $case: "string_match", string_match: StringMatcher.fromJSON(object.string_match) }
        : undefined,
      invert_match: isSet(object.invert_match) ? globalThis.Boolean(object.invert_match) : undefined,
      treat_missing_header_as_empty: isSet(object.treat_missing_header_as_empty)
        ? globalThis.Boolean(object.treat_missing_header_as_empty)
        : undefined,
    };
  },

  toJSON(message: HeaderMatcher): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.header_match_specifier?.$case === "exact_match") {
      obj.exact_match = message.header_match_specifier.exact_match;
    }
    if (message.header_match_specifier?.$case === "safe_regex_match") {
      obj.safe_regex_match = RegexMatcher.toJSON(message.header_match_specifier.safe_regex_match);
    }
    if (message.header_match_specifier?.$case === "range_match") {
      obj.range_match = Int64Range.toJSON(message.header_match_specifier.range_match);
    }
    if (message.header_match_specifier?.$case === "present_match") {
      obj.present_match = message.header_match_specifier.present_match;
    }
    if (message.header_match_specifier?.$case === "prefix_match") {
      obj.prefix_match = message.header_match_specifier.prefix_match;
    }
    if (message.header_match_specifier?.$case === "suffix_match") {
      obj.suffix_match = message.header_match_specifier.suffix_match;
    }
    if (message.header_match_specifier?.$case === "contains_match") {
      obj.contains_match = message.header_match_specifier.contains_match;
    }
    if (message.header_match_specifier?.$case === "string_match") {
      obj.string_match = StringMatcher.toJSON(message.header_match_specifier.string_match);
    }
    if (message.invert_match !== undefined) {
      obj.invert_match = message.invert_match;
    }
    if (message.treat_missing_header_as_empty !== undefined) {
      obj.treat_missing_header_as_empty = message.treat_missing_header_as_empty;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HeaderMatcher>, I>>(base?: I): HeaderMatcher {
    return HeaderMatcher.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HeaderMatcher>, I>>(object: I): HeaderMatcher {
    const message = createBaseHeaderMatcher();
    message.name = object.name ?? undefined;
    if (
      object.header_match_specifier?.$case === "exact_match" &&
      object.header_match_specifier?.exact_match !== undefined &&
      object.header_match_specifier?.exact_match !== null
    ) {
      message.header_match_specifier = { $case: "exact_match", exact_match: object.header_match_specifier.exact_match };
    }
    if (
      object.header_match_specifier?.$case === "safe_regex_match" &&
      object.header_match_specifier?.safe_regex_match !== undefined &&
      object.header_match_specifier?.safe_regex_match !== null
    ) {
      message.header_match_specifier = {
        $case: "safe_regex_match",
        safe_regex_match: RegexMatcher.fromPartial(object.header_match_specifier.safe_regex_match),
      };
    }
    if (
      object.header_match_specifier?.$case === "range_match" &&
      object.header_match_specifier?.range_match !== undefined &&
      object.header_match_specifier?.range_match !== null
    ) {
      message.header_match_specifier = {
        $case: "range_match",
        range_match: Int64Range.fromPartial(object.header_match_specifier.range_match),
      };
    }
    if (
      object.header_match_specifier?.$case === "present_match" &&
      object.header_match_specifier?.present_match !== undefined &&
      object.header_match_specifier?.present_match !== null
    ) {
      message.header_match_specifier = {
        $case: "present_match",
        present_match: object.header_match_specifier.present_match,
      };
    }
    if (
      object.header_match_specifier?.$case === "prefix_match" &&
      object.header_match_specifier?.prefix_match !== undefined &&
      object.header_match_specifier?.prefix_match !== null
    ) {
      message.header_match_specifier = {
        $case: "prefix_match",
        prefix_match: object.header_match_specifier.prefix_match,
      };
    }
    if (
      object.header_match_specifier?.$case === "suffix_match" &&
      object.header_match_specifier?.suffix_match !== undefined &&
      object.header_match_specifier?.suffix_match !== null
    ) {
      message.header_match_specifier = {
        $case: "suffix_match",
        suffix_match: object.header_match_specifier.suffix_match,
      };
    }
    if (
      object.header_match_specifier?.$case === "contains_match" &&
      object.header_match_specifier?.contains_match !== undefined &&
      object.header_match_specifier?.contains_match !== null
    ) {
      message.header_match_specifier = {
        $case: "contains_match",
        contains_match: object.header_match_specifier.contains_match,
      };
    }
    if (
      object.header_match_specifier?.$case === "string_match" &&
      object.header_match_specifier?.string_match !== undefined &&
      object.header_match_specifier?.string_match !== null
    ) {
      message.header_match_specifier = {
        $case: "string_match",
        string_match: StringMatcher.fromPartial(object.header_match_specifier.string_match),
      };
    }
    message.invert_match = object.invert_match ?? undefined;
    message.treat_missing_header_as_empty = object.treat_missing_header_as_empty ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(HeaderMatcher.$type, HeaderMatcher);

function createBaseQueryParameterMatcher(): QueryParameterMatcher {
  return { $type: "envoy.config.route.v3.QueryParameterMatcher", query_parameter_match_specifier: undefined };
}

export const QueryParameterMatcher: MessageFns<QueryParameterMatcher, "envoy.config.route.v3.QueryParameterMatcher"> = {
  $type: "envoy.config.route.v3.QueryParameterMatcher" as const,

  encode(message: QueryParameterMatcher, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    switch (message.query_parameter_match_specifier?.$case) {
      case "string_match":
        StringMatcher.encode(message.query_parameter_match_specifier.string_match, writer.uint32(42).fork()).join();
        break;
      case "present_match":
        writer.uint32(48).bool(message.query_parameter_match_specifier.present_match);
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryParameterMatcher {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParameterMatcher();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.query_parameter_match_specifier = {
            $case: "string_match",
            string_match: StringMatcher.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.query_parameter_match_specifier = { $case: "present_match", present_match: reader.bool() };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryParameterMatcher {
    return {
      $type: QueryParameterMatcher.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      query_parameter_match_specifier: isSet(object.string_match)
        ? { $case: "string_match", string_match: StringMatcher.fromJSON(object.string_match) }
        : isSet(object.present_match)
        ? { $case: "present_match", present_match: globalThis.Boolean(object.present_match) }
        : undefined,
    };
  },

  toJSON(message: QueryParameterMatcher): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.query_parameter_match_specifier?.$case === "string_match") {
      obj.string_match = StringMatcher.toJSON(message.query_parameter_match_specifier.string_match);
    }
    if (message.query_parameter_match_specifier?.$case === "present_match") {
      obj.present_match = message.query_parameter_match_specifier.present_match;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParameterMatcher>, I>>(base?: I): QueryParameterMatcher {
    return QueryParameterMatcher.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParameterMatcher>, I>>(object: I): QueryParameterMatcher {
    const message = createBaseQueryParameterMatcher();
    message.name = object.name ?? undefined;
    if (
      object.query_parameter_match_specifier?.$case === "string_match" &&
      object.query_parameter_match_specifier?.string_match !== undefined &&
      object.query_parameter_match_specifier?.string_match !== null
    ) {
      message.query_parameter_match_specifier = {
        $case: "string_match",
        string_match: StringMatcher.fromPartial(object.query_parameter_match_specifier.string_match),
      };
    }
    if (
      object.query_parameter_match_specifier?.$case === "present_match" &&
      object.query_parameter_match_specifier?.present_match !== undefined &&
      object.query_parameter_match_specifier?.present_match !== null
    ) {
      message.query_parameter_match_specifier = {
        $case: "present_match",
        present_match: object.query_parameter_match_specifier.present_match,
      };
    }
    return message;
  },
};

messageTypeRegistry.set(QueryParameterMatcher.$type, QueryParameterMatcher);

function createBaseInternalRedirectPolicy(): InternalRedirectPolicy {
  return { $type: "envoy.config.route.v3.InternalRedirectPolicy" };
}

export const InternalRedirectPolicy: MessageFns<
  InternalRedirectPolicy,
  "envoy.config.route.v3.InternalRedirectPolicy"
> = {
  $type: "envoy.config.route.v3.InternalRedirectPolicy" as const,

  encode(message: InternalRedirectPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.max_internal_redirects !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.max_internal_redirects! },
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.redirect_response_codes !== undefined && message.redirect_response_codes.length !== 0) {
      writer.uint32(18).fork();
      for (const v of message.redirect_response_codes) {
        writer.uint32(v);
      }
      writer.join();
    }
    if (message.predicates !== undefined && message.predicates.length !== 0) {
      for (const v of message.predicates) {
        TypedExtensionConfig.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    if (message.allow_cross_scheme_redirect !== undefined && message.allow_cross_scheme_redirect !== false) {
      writer.uint32(32).bool(message.allow_cross_scheme_redirect);
    }
    if (message.response_headers_to_copy !== undefined && message.response_headers_to_copy.length !== 0) {
      for (const v of message.response_headers_to_copy) {
        writer.uint32(42).string(v!);
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InternalRedirectPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInternalRedirectPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.max_internal_redirects = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 2: {
          if (tag === 16) {
            if (message.redirect_response_codes === undefined) {
              message.redirect_response_codes = [];
            }
            message.redirect_response_codes!.push(reader.uint32());

            continue;
          }

          if (tag === 18) {
            if (message.redirect_response_codes === undefined) {
              message.redirect_response_codes = [];
            }
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.redirect_response_codes!.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.predicates === undefined) {
            message.predicates = [];
          }
          const el = TypedExtensionConfig.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.predicates!.push(el);
          }
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.allow_cross_scheme_redirect = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          if (message.response_headers_to_copy === undefined) {
            message.response_headers_to_copy = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.response_headers_to_copy!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InternalRedirectPolicy {
    return {
      $type: InternalRedirectPolicy.$type,
      max_internal_redirects: isSet(object.max_internal_redirects) ? Number(object.max_internal_redirects) : undefined,
      redirect_response_codes: globalThis.Array.isArray(object?.redirect_response_codes)
        ? object.redirect_response_codes.map((e: any) => globalThis.Number(e))
        : undefined,
      predicates: globalThis.Array.isArray(object?.predicates)
        ? object.predicates.map((e: any) => TypedExtensionConfig.fromJSON(e))
        : undefined,
      allow_cross_scheme_redirect: isSet(object.allow_cross_scheme_redirect)
        ? globalThis.Boolean(object.allow_cross_scheme_redirect)
        : undefined,
      response_headers_to_copy: globalThis.Array.isArray(object?.response_headers_to_copy)
        ? object.response_headers_to_copy.map((e: any) => globalThis.String(e))
        : undefined,
    };
  },

  toJSON(message: InternalRedirectPolicy): unknown {
    const obj: any = {};
    if (message.max_internal_redirects !== undefined) {
      obj.max_internal_redirects = message.max_internal_redirects;
    }
    if (message.redirect_response_codes?.length) {
      obj.redirect_response_codes = message.redirect_response_codes.map((e) => Math.round(e));
    }
    if (message.predicates?.length) {
      obj.predicates = message.predicates.map((e) => TypedExtensionConfig.toJSON(e));
    }
    if (message.allow_cross_scheme_redirect !== undefined) {
      obj.allow_cross_scheme_redirect = message.allow_cross_scheme_redirect;
    }
    if (message.response_headers_to_copy?.length) {
      obj.response_headers_to_copy = message.response_headers_to_copy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InternalRedirectPolicy>, I>>(base?: I): InternalRedirectPolicy {
    return InternalRedirectPolicy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InternalRedirectPolicy>, I>>(object: I): InternalRedirectPolicy {
    const message = createBaseInternalRedirectPolicy();
    message.max_internal_redirects = object.max_internal_redirects ?? undefined;
    message.redirect_response_codes = object.redirect_response_codes?.map((e) => e) || undefined;
    message.predicates = object.predicates?.map((e) => TypedExtensionConfig.fromPartial(e)) || undefined;
    message.allow_cross_scheme_redirect = object.allow_cross_scheme_redirect ?? undefined;
    message.response_headers_to_copy = object.response_headers_to_copy?.map((e) => e) || undefined;
    return message;
  },
};

messageTypeRegistry.set(InternalRedirectPolicy.$type, InternalRedirectPolicy);

function createBaseFilterConfig(): FilterConfig {
  return { $type: "envoy.config.route.v3.FilterConfig" };
}

export const FilterConfig: MessageFns<FilterConfig, "envoy.config.route.v3.FilterConfig"> = {
  $type: "envoy.config.route.v3.FilterConfig" as const,

  encode(message: FilterConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.config !== undefined) {
      Any.encode(message.config, writer.uint32(10).fork()).join();
    }
    if (message.is_optional !== undefined && message.is_optional !== false) {
      writer.uint32(16).bool(message.is_optional);
    }
    if (message.disabled !== undefined && message.disabled !== false) {
      writer.uint32(24).bool(message.disabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FilterConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilterConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.config = Any.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.is_optional = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.disabled = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FilterConfig {
    return {
      $type: FilterConfig.$type,
      config: isSet(object.config) ? Any.fromJSON(object.config) : undefined,
      is_optional: isSet(object.is_optional) ? globalThis.Boolean(object.is_optional) : undefined,
      disabled: isSet(object.disabled) ? globalThis.Boolean(object.disabled) : undefined,
    };
  },

  toJSON(message: FilterConfig): unknown {
    const obj: any = {};
    if (message.config !== undefined) {
      obj.config = Any.toJSON(message.config);
    }
    if (message.is_optional !== undefined) {
      obj.is_optional = message.is_optional;
    }
    if (message.disabled !== undefined) {
      obj.disabled = message.disabled;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FilterConfig>, I>>(base?: I): FilterConfig {
    return FilterConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FilterConfig>, I>>(object: I): FilterConfig {
    const message = createBaseFilterConfig();
    message.config = (object.config !== undefined && object.config !== null)
      ? Any.fromPartial(object.config)
      : undefined;
    message.is_optional = object.is_optional ?? undefined;
    message.disabled = object.disabled ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(FilterConfig.$type, FilterConfig);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
