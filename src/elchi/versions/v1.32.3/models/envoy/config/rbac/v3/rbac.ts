// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/config/rbac/v3/rbac.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { CheckedExpr } from "../../../../google/api/expr/v1alpha1/checked";
import { Expr } from "../../../../google/api/expr/v1alpha1/syntax";
import { messageTypeRegistry } from "../../../../typeRegistry";
import { FilterStateMatcher } from "../../../type/matcher/v3/filter_state";
import { MetadataMatcher } from "../../../type/matcher/v3/metadata";
import { PathMatcher } from "../../../type/matcher/v3/path";
import { StringMatcher } from "../../../type/matcher/v3/string";
import { Int32Range } from "../../../type/v3/range";
import { CidrRange } from "../../core/v3/address";
import { TypedExtensionConfig } from "../../core/v3/extension";
import { HeaderMatcher } from "../../route/v3/route_components";

export const protobufPackage = "envoy.config.rbac.v3";

/**
 * Role Based Access Control (RBAC) provides service-level and method-level access control for a
 * service. Requests are allowed or denied based on the ``action`` and whether a matching policy is
 * found. For instance, if the action is ALLOW and a matching policy is found the request should be
 * allowed.
 *
 * RBAC can also be used to make access logging decisions by communicating with access loggers
 * through dynamic metadata. When the action is LOG and at least one policy matches, the
 * ``access_log_hint`` value in the shared key namespace 'envoy.common' is set to ``true`` indicating
 * the request should be logged.
 *
 * Here is an example of RBAC configuration. It has two policies:
 *
 * * Service account ``cluster.local/ns/default/sa/admin`` has full access to the service, and so
 *   does "cluster.local/ns/default/sa/superuser".
 *
 * * Any user can read (``GET``) the service at paths with prefix ``/products``, so long as the
 *   destination port is either 80 or 443.
 *
 *  .. code-block:: yaml
 *
 *   action: ALLOW
 *   policies:
 *     "service-admin":
 *       permissions:
 *         - any: true
 *       principals:
 *         - authenticated:
 *             principal_name:
 *               exact: "cluster.local/ns/default/sa/admin"
 *         - authenticated:
 *             principal_name:
 *               exact: "cluster.local/ns/default/sa/superuser"
 *     "product-viewer":
 *       permissions:
 *           - and_rules:
 *               rules:
 *                 - header:
 *                     name: ":method"
 *                     string_match:
 *                       exact: "GET"
 *                 - url_path:
 *                     path: { prefix: "/products" }
 *                 - or_rules:
 *                     rules:
 *                       - destination_port: 80
 *                       - destination_port: 443
 *       principals:
 *         - any: true
 */
export interface RBAC {
  $type: "envoy.config.rbac.v3.RBAC";
  /**
   * The action to take if a policy matches. Every action either allows or denies a request,
   * and can also carry out action-specific operations.
   *
   * Actions:
   *
   *  * ``ALLOW``: Allows the request if and only if there is a policy that matches
   *    the request.
   *  * ``DENY``: Allows the request if and only if there are no policies that
   *    match the request.
   *  * ``LOG``: Allows all requests. If at least one policy matches, the dynamic
   *    metadata key ``access_log_hint`` is set to the value ``true`` under the shared
   *    key namespace ``envoy.common``. If no policies match, it is set to ``false``.
   *    Other actions do not modify this key.
   */
  action?:
    | RBAC_Action
    | undefined;
  /**
   * Maps from policy name to policy. A match occurs when at least one policy matches the request.
   * The policies are evaluated in lexicographic order of the policy name.
   */
  policies?:
    | Map<string, Policy>
    | undefined;
  /**
   * Audit logging options that include the condition for audit logging to happen
   * and audit logger configurations.
   *
   * [#not-implemented-hide:]
   */
  audit_logging_options?: RBAC_AuditLoggingOptions | undefined;
}

/** Should we do safe-list or block-list style access control? */
export enum RBAC_Action {
  /**
   * ALLOW - The policies grant access to principals. The rest are denied. This is safe-list style
   * access control. This is the default type.
   */
  ALLOW = "ALLOW",
  /**
   * DENY - The policies deny access to principals. The rest are allowed. This is block-list style
   * access control.
   */
  DENY = "DENY",
  /**
   * LOG - The policies set the ``access_log_hint`` dynamic metadata key based on if requests match.
   * All requests are allowed.
   */
  LOG = "LOG",
}

export function rBAC_ActionFromJSON(object: any): RBAC_Action {
  switch (object) {
    case 0:
    case "ALLOW":
      return RBAC_Action.ALLOW;
    case 1:
    case "DENY":
      return RBAC_Action.DENY;
    case 2:
    case "LOG":
      return RBAC_Action.LOG;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RBAC_Action");
  }
}

export function rBAC_ActionToJSON(object: RBAC_Action): string {
  switch (object) {
    case RBAC_Action.ALLOW:
      return "ALLOW";
    case RBAC_Action.DENY:
      return "DENY";
    case RBAC_Action.LOG:
      return "LOG";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RBAC_Action");
  }
}

export function rBAC_ActionToNumber(object: RBAC_Action): number {
  switch (object) {
    case RBAC_Action.ALLOW:
      return 0;
    case RBAC_Action.DENY:
      return 1;
    case RBAC_Action.LOG:
      return 2;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RBAC_Action");
  }
}

export interface RBAC_AuditLoggingOptions {
  $type: "envoy.config.rbac.v3.RBAC.AuditLoggingOptions";
  /**
   * Condition for the audit logging to happen.
   * If this condition is met, all the audit loggers configured here will be invoked.
   *
   * [#not-implemented-hide:]
   */
  audit_condition?:
    | RBAC_AuditLoggingOptions_AuditCondition
    | undefined;
  /**
   * Configurations for RBAC-based authorization audit loggers.
   *
   * [#not-implemented-hide:]
   */
  logger_configs?: RBAC_AuditLoggingOptions_AuditLoggerConfig[] | undefined;
}

/** Deny and allow here refer to RBAC decisions, not actions. */
export enum RBAC_AuditLoggingOptions_AuditCondition {
  /** NONE - Never audit. */
  NONE = "NONE",
  /** ON_DENY - Audit when RBAC denies the request. */
  ON_DENY = "ON_DENY",
  /** ON_ALLOW - Audit when RBAC allows the request. */
  ON_ALLOW = "ON_ALLOW",
  /** ON_DENY_AND_ALLOW - Audit whether RBAC allows or denies the request. */
  ON_DENY_AND_ALLOW = "ON_DENY_AND_ALLOW",
}

export function rBAC_AuditLoggingOptions_AuditConditionFromJSON(object: any): RBAC_AuditLoggingOptions_AuditCondition {
  switch (object) {
    case 0:
    case "NONE":
      return RBAC_AuditLoggingOptions_AuditCondition.NONE;
    case 1:
    case "ON_DENY":
      return RBAC_AuditLoggingOptions_AuditCondition.ON_DENY;
    case 2:
    case "ON_ALLOW":
      return RBAC_AuditLoggingOptions_AuditCondition.ON_ALLOW;
    case 3:
    case "ON_DENY_AND_ALLOW":
      return RBAC_AuditLoggingOptions_AuditCondition.ON_DENY_AND_ALLOW;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum RBAC_AuditLoggingOptions_AuditCondition",
      );
  }
}

export function rBAC_AuditLoggingOptions_AuditConditionToJSON(object: RBAC_AuditLoggingOptions_AuditCondition): string {
  switch (object) {
    case RBAC_AuditLoggingOptions_AuditCondition.NONE:
      return "NONE";
    case RBAC_AuditLoggingOptions_AuditCondition.ON_DENY:
      return "ON_DENY";
    case RBAC_AuditLoggingOptions_AuditCondition.ON_ALLOW:
      return "ON_ALLOW";
    case RBAC_AuditLoggingOptions_AuditCondition.ON_DENY_AND_ALLOW:
      return "ON_DENY_AND_ALLOW";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum RBAC_AuditLoggingOptions_AuditCondition",
      );
  }
}

export function rBAC_AuditLoggingOptions_AuditConditionToNumber(
  object: RBAC_AuditLoggingOptions_AuditCondition,
): number {
  switch (object) {
    case RBAC_AuditLoggingOptions_AuditCondition.NONE:
      return 0;
    case RBAC_AuditLoggingOptions_AuditCondition.ON_DENY:
      return 1;
    case RBAC_AuditLoggingOptions_AuditCondition.ON_ALLOW:
      return 2;
    case RBAC_AuditLoggingOptions_AuditCondition.ON_DENY_AND_ALLOW:
      return 3;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum RBAC_AuditLoggingOptions_AuditCondition",
      );
  }
}

/** [#not-implemented-hide:] */
export interface RBAC_AuditLoggingOptions_AuditLoggerConfig {
  $type: "envoy.config.rbac.v3.RBAC.AuditLoggingOptions.AuditLoggerConfig";
  /**
   * Typed logger configuration.
   *
   * [#extension-category: envoy.rbac.audit_loggers]
   */
  audit_logger?:
    | TypedExtensionConfig
    | undefined;
  /** If true, when the logger is not supported, the data plane will not NACK but simply ignore it. */
  is_optional?: boolean | undefined;
}

export interface RBAC_PoliciesEntry {
  $type: "envoy.config.rbac.v3.RBAC.PoliciesEntry";
  key: string;
  value?: Policy | undefined;
}

/**
 * Policy specifies a role and the principals that are assigned/denied the role.
 * A policy matches if and only if at least one of its permissions match the
 * action taking place AND at least one of its principals match the downstream
 * AND the condition is true if specified.
 */
export interface Policy {
  $type: "envoy.config.rbac.v3.Policy";
  /**
   * Required. The set of permissions that define a role. Each permission is
   * matched with OR semantics. To match all actions for this policy, a single
   * Permission with the ``any`` field set to true should be used.
   */
  permissions?:
    | Permission[]
    | undefined;
  /**
   * Required. The set of principals that are assigned/denied the role based on
   * “action”. Each principal is matched with OR semantics. To match all
   * downstreams for this policy, a single Principal with the ``any`` field set to
   * true should be used.
   */
  principals?:
    | Principal[]
    | undefined;
  /**
   * An optional symbolic expression specifying an access control
   * :ref:`condition <arch_overview_condition>`. The condition is combined
   * with the permissions and the principals as a clause with AND semantics.
   * Only be used when checked_condition is not used.
   */
  condition?:
    | Expr
    | undefined;
  /**
   * [#not-implemented-hide:]
   * An optional symbolic expression that has been successfully type checked.
   * Only be used when condition is not used.
   */
  checked_condition?: CheckedExpr | undefined;
}

/**
 * Permission defines an action (or actions) that a principal can take.
 * [#next-free-field: 14]
 */
export interface Permission {
  $type: "envoy.config.rbac.v3.Permission";
  rule?:
    | //
    /** A set of rules that all must match in order to define the action. */
    { $case: "and_rules"; and_rules: Permission_Set }
    | //
    /** A set of rules where at least one must match in order to define the action. */
    { $case: "or_rules"; or_rules: Permission_Set }
    | //
    /** When any is set, it matches any action. */
    { $case: "any"; any: boolean }
    | //
    /**
     * A header (or pseudo-header such as :path or :method) on the incoming HTTP request. Only
     * available for HTTP request.
     * Note: the pseudo-header :path includes the query and fragment string. Use the ``url_path``
     * field if you want to match the URL path without the query and fragment string.
     */
    { $case: "header"; header: HeaderMatcher }
    | //
    /** A URL path on the incoming HTTP request. Only available for HTTP. */
    { $case: "url_path"; url_path: PathMatcher }
    | //
    /** A CIDR block that describes the destination IP. */
    { $case: "destination_ip"; destination_ip: CidrRange }
    | //
    /** A port number that describes the destination port connecting to. */
    { $case: "destination_port"; destination_port: number }
    | //
    /** A port number range that describes a range of destination ports connecting to. */
    { $case: "destination_port_range"; destination_port_range: Int32Range }
    | //
    /** Metadata that describes additional information about the action. */
    { $case: "metadata"; metadata: MetadataMatcher }
    | //
    /**
     * Negates matching the provided permission. For instance, if the value of
     * ``not_rule`` would match, this permission would not match. Conversely, if
     * the value of ``not_rule`` would not match, this permission would match.
     */
    { $case: "not_rule"; not_rule: Permission }
    | //
    /**
     * The request server from the client's connection request. This is
     * typically TLS SNI.
     *
     * .. attention::
     *
     *   The behavior of this field may be affected by how Envoy is configured
     *   as explained below.
     *
     *   * If the :ref:`TLS Inspector <config_listener_filters_tls_inspector>`
     *     filter is not added, and if a ``FilterChainMatch`` is not defined for
     *     the :ref:`server name
     *     <envoy_v3_api_field_config.listener.v3.FilterChainMatch.server_names>`,
     *     a TLS connection's requested SNI server name will be treated as if it
     *     wasn't present.
     *
     *   * A :ref:`listener filter <arch_overview_listener_filters>` may
     *     overwrite a connection's requested server name within Envoy.
     *
     * Please refer to :ref:`this FAQ entry <faq_how_to_setup_sni>` to learn to
     * setup SNI.
     */
    { $case: "requested_server_name"; requested_server_name: StringMatcher }
    | //
    /**
     * Extension for configuring custom matchers for RBAC.
     * [#extension-category: envoy.rbac.matchers]
     */
    { $case: "matcher"; matcher: TypedExtensionConfig }
    | //
    /**
     * URI template path matching.
     * [#extension-category: envoy.path.match]
     */
    { $case: "uri_template"; uri_template: TypedExtensionConfig }
    | undefined;
}

/**
 * Used in the ``and_rules`` and ``or_rules`` fields in the ``rule`` oneof. Depending on the context,
 * each are applied with the associated behavior.
 */
export interface Permission_Set {
  $type: "envoy.config.rbac.v3.Permission.Set";
  rules?: Permission[] | undefined;
}

/**
 * Principal defines an identity or a group of identities for a downstream
 * subject.
 * [#next-free-field: 13]
 */
export interface Principal {
  $type: "envoy.config.rbac.v3.Principal";
  identifier?:
    | //
    /**
     * A set of identifiers that all must match in order to define the
     * downstream.
     */
    { $case: "and_ids"; and_ids: Principal_Set }
    | //
    /**
     * A set of identifiers at least one must match in order to define the
     * downstream.
     */
    { $case: "or_ids"; or_ids: Principal_Set }
    | //
    /** When any is set, it matches any downstream. */
    { $case: "any"; any: boolean }
    | //
    /** Authenticated attributes that identify the downstream. */
    { $case: "authenticated"; authenticated: Principal_Authenticated }
    | //
    /**
     * A CIDR block that describes the downstream IP.
     * This address will honor proxy protocol, but will not honor XFF.
     *
     * This field is deprecated; either use :ref:`remote_ip
     * <envoy_v3_api_field_config.rbac.v3.Principal.remote_ip>` for the same
     * behavior, or use
     * :ref:`direct_remote_ip <envoy_v3_api_field_config.rbac.v3.Principal.direct_remote_ip>`.
     */
    { $case: "source_ip"; source_ip: CidrRange }
    | //
    /**
     * A CIDR block that describes the downstream remote/origin address.
     * Note: This is always the physical peer even if the
     * :ref:`remote_ip <envoy_v3_api_field_config.rbac.v3.Principal.remote_ip>` is
     * inferred from for example the x-forwarder-for header, proxy protocol,
     * etc.
     */
    { $case: "direct_remote_ip"; direct_remote_ip: CidrRange }
    | //
    /**
     * A CIDR block that describes the downstream remote/origin address.
     * Note: This may not be the physical peer and could be different from the
     * :ref:`direct_remote_ip
     * <envoy_v3_api_field_config.rbac.v3.Principal.direct_remote_ip>`. E.g, if the
     * remote ip is inferred from for example the x-forwarder-for header, proxy
     * protocol, etc.
     */
    { $case: "remote_ip"; remote_ip: CidrRange }
    | //
    /**
     * A header (or pseudo-header such as :path or :method) on the incoming HTTP
     * request. Only available for HTTP request. Note: the pseudo-header :path
     * includes the query and fragment string. Use the ``url_path`` field if you
     * want to match the URL path without the query and fragment string.
     */
    { $case: "header"; header: HeaderMatcher }
    | //
    /** A URL path on the incoming HTTP request. Only available for HTTP. */
    { $case: "url_path"; url_path: PathMatcher }
    | //
    /** Metadata that describes additional information about the principal. */
    { $case: "metadata"; metadata: MetadataMatcher }
    | //
    /** Identifies the principal using a filter state object. */
    { $case: "filter_state"; filter_state: FilterStateMatcher }
    | //
    /**
     * Negates matching the provided principal. For instance, if the value of
     * ``not_id`` would match, this principal would not match. Conversely, if the
     * value of ``not_id`` would not match, this principal would match.
     */
    { $case: "not_id"; not_id: Principal }
    | undefined;
}

/**
 * Used in the ``and_ids`` and ``or_ids`` fields in the ``identifier`` oneof.
 * Depending on the context, each are applied with the associated behavior.
 */
export interface Principal_Set {
  $type: "envoy.config.rbac.v3.Principal.Set";
  ids?: Principal[] | undefined;
}

/** Authentication attributes for a downstream. */
export interface Principal_Authenticated {
  $type: "envoy.config.rbac.v3.Principal.Authenticated";
  /**
   * The name of the principal. If set, The URI SAN or DNS SAN in that order
   * is used from the certificate, otherwise the subject field is used. If
   * unset, it applies to any user that is authenticated.
   */
  principal_name?: StringMatcher | undefined;
}

/** Action defines the result of allowance or denial when a request matches the matcher. */
export interface Action {
  $type: "envoy.config.rbac.v3.Action";
  /** The name indicates the policy name. */
  name?:
    | string
    | undefined;
  /**
   * The action to take if the matcher matches. Every action either allows or denies a request,
   * and can also carry out action-specific operations.
   *
   * Actions:
   *
   *  * ``ALLOW``: If the request gets matched on ALLOW, it is permitted.
   *  * ``DENY``: If the request gets matched on DENY, it is not permitted.
   *  * ``LOG``: If the request gets matched on LOG, it is permitted. Besides, the
   *    dynamic metadata key ``access_log_hint`` under the shared key namespace
   *    ``envoy.common`` will be set to the value ``true``.
   *  * If the request cannot get matched, it will fallback to ``DENY``.
   *
   * Log behavior:
   *
   *  If the RBAC matcher contains at least one LOG action, the dynamic
   *  metadata key ``access_log_hint`` will be set based on if the request
   *  get matched on the LOG action.
   */
  action?: RBAC_Action | undefined;
}

function createBaseRBAC(): RBAC {
  return { $type: "envoy.config.rbac.v3.RBAC" };
}

export const RBAC: MessageFns<RBAC, "envoy.config.rbac.v3.RBAC"> = {
  $type: "envoy.config.rbac.v3.RBAC" as const,

  encode(message: RBAC, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.action !== undefined && message.action !== RBAC_Action.ALLOW) {
      writer.uint32(8).int32(rBAC_ActionToNumber(message.action));
    }
    (message.policies || new Map()).forEach((value, key) => {
      RBAC_PoliciesEntry.encode(
        { $type: "envoy.config.rbac.v3.RBAC.PoliciesEntry", key: key as any, value },
        writer.uint32(18).fork(),
      ).join();
    });
    if (message.audit_logging_options !== undefined) {
      RBAC_AuditLoggingOptions.encode(message.audit_logging_options, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RBAC {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRBAC();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.action = rBAC_ActionFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = RBAC_PoliciesEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            if (message.policies === undefined) {
              message.policies = new Map();
            }
            message.policies!.set(entry2.key, entry2.value);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.audit_logging_options = RBAC_AuditLoggingOptions.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RBAC {
    return {
      $type: RBAC.$type,
      action: isSet(object.action) ? rBAC_ActionFromJSON(object.action) : undefined,
      policies: isObject(object.policies)
        ? Object.entries(object.policies).reduce<Map<string, Policy>>((acc, [key, value]) => {
          acc.set(key, Policy.fromJSON(value));
          return acc;
        }, new Map())
        : undefined,
      audit_logging_options: isSet(object.audit_logging_options)
        ? RBAC_AuditLoggingOptions.fromJSON(object.audit_logging_options)
        : undefined,
    };
  },

  toJSON(message: RBAC): unknown {
    const obj: any = {};
    if (message.action !== undefined) {
      obj.action = rBAC_ActionToJSON(message.action);
    }
    if (message.policies?.size) {
      obj.policies = {};
      message.policies.forEach((v, k) => {
        obj.policies[k] = Policy.toJSON(v);
      });
    }
    if (message.audit_logging_options !== undefined) {
      obj.audit_logging_options = RBAC_AuditLoggingOptions.toJSON(message.audit_logging_options);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RBAC>, I>>(base?: I): RBAC {
    return RBAC.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RBAC>, I>>(object: I): RBAC {
    const message = createBaseRBAC();
    message.action = object.action ?? undefined;
    message.policies = (object.policies === undefined || object.policies === null) ? undefined : (() => {
      const m = new Map();
      (object.policies as Map<string, Policy> ?? new Map()).forEach((value, key) => {
        if (value !== undefined) {
          m.set(key, Policy.fromPartial(value));
        }
      });
      return m;
    })();
    message.audit_logging_options =
      (object.audit_logging_options !== undefined && object.audit_logging_options !== null)
        ? RBAC_AuditLoggingOptions.fromPartial(object.audit_logging_options)
        : undefined;
    return message;
  },
};

messageTypeRegistry.set(RBAC.$type, RBAC);

function createBaseRBAC_AuditLoggingOptions(): RBAC_AuditLoggingOptions {
  return { $type: "envoy.config.rbac.v3.RBAC.AuditLoggingOptions" };
}

export const RBAC_AuditLoggingOptions: MessageFns<
  RBAC_AuditLoggingOptions,
  "envoy.config.rbac.v3.RBAC.AuditLoggingOptions"
> = {
  $type: "envoy.config.rbac.v3.RBAC.AuditLoggingOptions" as const,

  encode(message: RBAC_AuditLoggingOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (
      message.audit_condition !== undefined && message.audit_condition !== RBAC_AuditLoggingOptions_AuditCondition.NONE
    ) {
      writer.uint32(8).int32(rBAC_AuditLoggingOptions_AuditConditionToNumber(message.audit_condition));
    }
    if (message.logger_configs !== undefined && message.logger_configs.length !== 0) {
      for (const v of message.logger_configs) {
        RBAC_AuditLoggingOptions_AuditLoggerConfig.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RBAC_AuditLoggingOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRBAC_AuditLoggingOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.audit_condition = rBAC_AuditLoggingOptions_AuditConditionFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.logger_configs === undefined) {
            message.logger_configs = [];
          }
          const el = RBAC_AuditLoggingOptions_AuditLoggerConfig.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.logger_configs!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RBAC_AuditLoggingOptions {
    return {
      $type: RBAC_AuditLoggingOptions.$type,
      audit_condition: isSet(object.audit_condition)
        ? rBAC_AuditLoggingOptions_AuditConditionFromJSON(object.audit_condition)
        : undefined,
      logger_configs: globalThis.Array.isArray(object?.logger_configs)
        ? object.logger_configs.map((e: any) => RBAC_AuditLoggingOptions_AuditLoggerConfig.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: RBAC_AuditLoggingOptions): unknown {
    const obj: any = {};
    if (message.audit_condition !== undefined) {
      obj.audit_condition = rBAC_AuditLoggingOptions_AuditConditionToJSON(message.audit_condition);
    }
    if (message.logger_configs?.length) {
      obj.logger_configs = message.logger_configs.map((e) => RBAC_AuditLoggingOptions_AuditLoggerConfig.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RBAC_AuditLoggingOptions>, I>>(base?: I): RBAC_AuditLoggingOptions {
    return RBAC_AuditLoggingOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RBAC_AuditLoggingOptions>, I>>(object: I): RBAC_AuditLoggingOptions {
    const message = createBaseRBAC_AuditLoggingOptions();
    message.audit_condition = object.audit_condition ?? undefined;
    message.logger_configs =
      object.logger_configs?.map((e) => RBAC_AuditLoggingOptions_AuditLoggerConfig.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(RBAC_AuditLoggingOptions.$type, RBAC_AuditLoggingOptions);

function createBaseRBAC_AuditLoggingOptions_AuditLoggerConfig(): RBAC_AuditLoggingOptions_AuditLoggerConfig {
  return { $type: "envoy.config.rbac.v3.RBAC.AuditLoggingOptions.AuditLoggerConfig" };
}

export const RBAC_AuditLoggingOptions_AuditLoggerConfig: MessageFns<
  RBAC_AuditLoggingOptions_AuditLoggerConfig,
  "envoy.config.rbac.v3.RBAC.AuditLoggingOptions.AuditLoggerConfig"
> = {
  $type: "envoy.config.rbac.v3.RBAC.AuditLoggingOptions.AuditLoggerConfig" as const,

  encode(message: RBAC_AuditLoggingOptions_AuditLoggerConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.audit_logger !== undefined) {
      TypedExtensionConfig.encode(message.audit_logger, writer.uint32(10).fork()).join();
    }
    if (message.is_optional !== undefined && message.is_optional !== false) {
      writer.uint32(16).bool(message.is_optional);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RBAC_AuditLoggingOptions_AuditLoggerConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRBAC_AuditLoggingOptions_AuditLoggerConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.audit_logger = TypedExtensionConfig.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.is_optional = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RBAC_AuditLoggingOptions_AuditLoggerConfig {
    return {
      $type: RBAC_AuditLoggingOptions_AuditLoggerConfig.$type,
      audit_logger: isSet(object.audit_logger) ? TypedExtensionConfig.fromJSON(object.audit_logger) : undefined,
      is_optional: isSet(object.is_optional) ? globalThis.Boolean(object.is_optional) : undefined,
    };
  },

  toJSON(message: RBAC_AuditLoggingOptions_AuditLoggerConfig): unknown {
    const obj: any = {};
    if (message.audit_logger !== undefined) {
      obj.audit_logger = TypedExtensionConfig.toJSON(message.audit_logger);
    }
    if (message.is_optional !== undefined) {
      obj.is_optional = message.is_optional;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RBAC_AuditLoggingOptions_AuditLoggerConfig>, I>>(
    base?: I,
  ): RBAC_AuditLoggingOptions_AuditLoggerConfig {
    return RBAC_AuditLoggingOptions_AuditLoggerConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RBAC_AuditLoggingOptions_AuditLoggerConfig>, I>>(
    object: I,
  ): RBAC_AuditLoggingOptions_AuditLoggerConfig {
    const message = createBaseRBAC_AuditLoggingOptions_AuditLoggerConfig();
    message.audit_logger = (object.audit_logger !== undefined && object.audit_logger !== null)
      ? TypedExtensionConfig.fromPartial(object.audit_logger)
      : undefined;
    message.is_optional = object.is_optional ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RBAC_AuditLoggingOptions_AuditLoggerConfig.$type, RBAC_AuditLoggingOptions_AuditLoggerConfig);

function createBaseRBAC_PoliciesEntry(): RBAC_PoliciesEntry {
  return { $type: "envoy.config.rbac.v3.RBAC.PoliciesEntry", key: "" };
}

export const RBAC_PoliciesEntry: MessageFns<RBAC_PoliciesEntry, "envoy.config.rbac.v3.RBAC.PoliciesEntry"> = {
  $type: "envoy.config.rbac.v3.RBAC.PoliciesEntry" as const,

  encode(message: RBAC_PoliciesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Policy.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RBAC_PoliciesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRBAC_PoliciesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Policy.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RBAC_PoliciesEntry {
    return {
      $type: RBAC_PoliciesEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Policy.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: RBAC_PoliciesEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Policy.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RBAC_PoliciesEntry>, I>>(base?: I): RBAC_PoliciesEntry {
    return RBAC_PoliciesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RBAC_PoliciesEntry>, I>>(object: I): RBAC_PoliciesEntry {
    const message = createBaseRBAC_PoliciesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Policy.fromPartial(object.value)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(RBAC_PoliciesEntry.$type, RBAC_PoliciesEntry);

function createBasePolicy(): Policy {
  return { $type: "envoy.config.rbac.v3.Policy" };
}

export const Policy: MessageFns<Policy, "envoy.config.rbac.v3.Policy"> = {
  $type: "envoy.config.rbac.v3.Policy" as const,

  encode(message: Policy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.permissions !== undefined && message.permissions.length !== 0) {
      for (const v of message.permissions) {
        Permission.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    if (message.principals !== undefined && message.principals.length !== 0) {
      for (const v of message.principals) {
        Principal.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.condition !== undefined) {
      Expr.encode(message.condition, writer.uint32(26).fork()).join();
    }
    if (message.checked_condition !== undefined) {
      CheckedExpr.encode(message.checked_condition, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Policy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.permissions === undefined) {
            message.permissions = [];
          }
          const el = Permission.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.permissions!.push(el);
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.principals === undefined) {
            message.principals = [];
          }
          const el = Principal.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.principals!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.condition = Expr.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.checked_condition = CheckedExpr.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Policy {
    return {
      $type: Policy.$type,
      permissions: globalThis.Array.isArray(object?.permissions)
        ? object.permissions.map((e: any) => Permission.fromJSON(e))
        : undefined,
      principals: globalThis.Array.isArray(object?.principals)
        ? object.principals.map((e: any) => Principal.fromJSON(e))
        : undefined,
      condition: isSet(object.condition) ? Expr.fromJSON(object.condition) : undefined,
      checked_condition: isSet(object.checked_condition) ? CheckedExpr.fromJSON(object.checked_condition) : undefined,
    };
  },

  toJSON(message: Policy): unknown {
    const obj: any = {};
    if (message.permissions?.length) {
      obj.permissions = message.permissions.map((e) => Permission.toJSON(e));
    }
    if (message.principals?.length) {
      obj.principals = message.principals.map((e) => Principal.toJSON(e));
    }
    if (message.condition !== undefined) {
      obj.condition = Expr.toJSON(message.condition);
    }
    if (message.checked_condition !== undefined) {
      obj.checked_condition = CheckedExpr.toJSON(message.checked_condition);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Policy>, I>>(base?: I): Policy {
    return Policy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Policy>, I>>(object: I): Policy {
    const message = createBasePolicy();
    message.permissions = object.permissions?.map((e) => Permission.fromPartial(e)) || undefined;
    message.principals = object.principals?.map((e) => Principal.fromPartial(e)) || undefined;
    message.condition = (object.condition !== undefined && object.condition !== null)
      ? Expr.fromPartial(object.condition)
      : undefined;
    message.checked_condition = (object.checked_condition !== undefined && object.checked_condition !== null)
      ? CheckedExpr.fromPartial(object.checked_condition)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Policy.$type, Policy);

function createBasePermission(): Permission {
  return { $type: "envoy.config.rbac.v3.Permission", rule: undefined };
}

export const Permission: MessageFns<Permission, "envoy.config.rbac.v3.Permission"> = {
  $type: "envoy.config.rbac.v3.Permission" as const,

  encode(message: Permission, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.rule?.$case) {
      case "and_rules":
        Permission_Set.encode(message.rule.and_rules, writer.uint32(10).fork()).join();
        break;
      case "or_rules":
        Permission_Set.encode(message.rule.or_rules, writer.uint32(18).fork()).join();
        break;
      case "any":
        writer.uint32(24).bool(message.rule.any);
        break;
      case "header":
        HeaderMatcher.encode(message.rule.header, writer.uint32(34).fork()).join();
        break;
      case "url_path":
        PathMatcher.encode(message.rule.url_path, writer.uint32(82).fork()).join();
        break;
      case "destination_ip":
        CidrRange.encode(message.rule.destination_ip, writer.uint32(42).fork()).join();
        break;
      case "destination_port":
        writer.uint32(48).uint32(message.rule.destination_port);
        break;
      case "destination_port_range":
        Int32Range.encode(message.rule.destination_port_range, writer.uint32(90).fork()).join();
        break;
      case "metadata":
        MetadataMatcher.encode(message.rule.metadata, writer.uint32(58).fork()).join();
        break;
      case "not_rule":
        Permission.encode(message.rule.not_rule, writer.uint32(66).fork()).join();
        break;
      case "requested_server_name":
        StringMatcher.encode(message.rule.requested_server_name, writer.uint32(74).fork()).join();
        break;
      case "matcher":
        TypedExtensionConfig.encode(message.rule.matcher, writer.uint32(98).fork()).join();
        break;
      case "uri_template":
        TypedExtensionConfig.encode(message.rule.uri_template, writer.uint32(106).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Permission {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePermission();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rule = { $case: "and_rules", and_rules: Permission_Set.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rule = { $case: "or_rules", or_rules: Permission_Set.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.rule = { $case: "any", any: reader.bool() };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.rule = { $case: "header", header: HeaderMatcher.decode(reader, reader.uint32()) };
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.rule = { $case: "url_path", url_path: PathMatcher.decode(reader, reader.uint32()) };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.rule = { $case: "destination_ip", destination_ip: CidrRange.decode(reader, reader.uint32()) };
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.rule = { $case: "destination_port", destination_port: reader.uint32() };
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.rule = {
            $case: "destination_port_range",
            destination_port_range: Int32Range.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.rule = { $case: "metadata", metadata: MetadataMatcher.decode(reader, reader.uint32()) };
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.rule = { $case: "not_rule", not_rule: Permission.decode(reader, reader.uint32()) };
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.rule = {
            $case: "requested_server_name",
            requested_server_name: StringMatcher.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.rule = { $case: "matcher", matcher: TypedExtensionConfig.decode(reader, reader.uint32()) };
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.rule = { $case: "uri_template", uri_template: TypedExtensionConfig.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Permission {
    return {
      $type: Permission.$type,
      rule: isSet(object.and_rules)
        ? { $case: "and_rules", and_rules: Permission_Set.fromJSON(object.and_rules) }
        : isSet(object.or_rules)
        ? { $case: "or_rules", or_rules: Permission_Set.fromJSON(object.or_rules) }
        : isSet(object.any)
        ? { $case: "any", any: globalThis.Boolean(object.any) }
        : isSet(object.header)
        ? { $case: "header", header: HeaderMatcher.fromJSON(object.header) }
        : isSet(object.url_path)
        ? { $case: "url_path", url_path: PathMatcher.fromJSON(object.url_path) }
        : isSet(object.destination_ip)
        ? { $case: "destination_ip", destination_ip: CidrRange.fromJSON(object.destination_ip) }
        : isSet(object.destination_port)
        ? { $case: "destination_port", destination_port: globalThis.Number(object.destination_port) }
        : isSet(object.destination_port_range)
        ? {
          $case: "destination_port_range",
          destination_port_range: Int32Range.fromJSON(object.destination_port_range),
        }
        : isSet(object.metadata)
        ? { $case: "metadata", metadata: MetadataMatcher.fromJSON(object.metadata) }
        : isSet(object.not_rule)
        ? { $case: "not_rule", not_rule: Permission.fromJSON(object.not_rule) }
        : isSet(object.requested_server_name)
        ? {
          $case: "requested_server_name",
          requested_server_name: StringMatcher.fromJSON(object.requested_server_name),
        }
        : isSet(object.matcher)
        ? { $case: "matcher", matcher: TypedExtensionConfig.fromJSON(object.matcher) }
        : isSet(object.uri_template)
        ? { $case: "uri_template", uri_template: TypedExtensionConfig.fromJSON(object.uri_template) }
        : undefined,
    };
  },

  toJSON(message: Permission): unknown {
    const obj: any = {};
    if (message.rule?.$case === "and_rules") {
      obj.and_rules = Permission_Set.toJSON(message.rule.and_rules);
    }
    if (message.rule?.$case === "or_rules") {
      obj.or_rules = Permission_Set.toJSON(message.rule.or_rules);
    }
    if (message.rule?.$case === "any") {
      obj.any = message.rule.any;
    }
    if (message.rule?.$case === "header") {
      obj.header = HeaderMatcher.toJSON(message.rule.header);
    }
    if (message.rule?.$case === "url_path") {
      obj.url_path = PathMatcher.toJSON(message.rule.url_path);
    }
    if (message.rule?.$case === "destination_ip") {
      obj.destination_ip = CidrRange.toJSON(message.rule.destination_ip);
    }
    if (message.rule?.$case === "destination_port") {
      obj.destination_port = Math.round(message.rule.destination_port);
    }
    if (message.rule?.$case === "destination_port_range") {
      obj.destination_port_range = Int32Range.toJSON(message.rule.destination_port_range);
    }
    if (message.rule?.$case === "metadata") {
      obj.metadata = MetadataMatcher.toJSON(message.rule.metadata);
    }
    if (message.rule?.$case === "not_rule") {
      obj.not_rule = Permission.toJSON(message.rule.not_rule);
    }
    if (message.rule?.$case === "requested_server_name") {
      obj.requested_server_name = StringMatcher.toJSON(message.rule.requested_server_name);
    }
    if (message.rule?.$case === "matcher") {
      obj.matcher = TypedExtensionConfig.toJSON(message.rule.matcher);
    }
    if (message.rule?.$case === "uri_template") {
      obj.uri_template = TypedExtensionConfig.toJSON(message.rule.uri_template);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Permission>, I>>(base?: I): Permission {
    return Permission.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Permission>, I>>(object: I): Permission {
    const message = createBasePermission();
    if (object.rule?.$case === "and_rules" && object.rule?.and_rules !== undefined && object.rule?.and_rules !== null) {
      message.rule = { $case: "and_rules", and_rules: Permission_Set.fromPartial(object.rule.and_rules) };
    }
    if (object.rule?.$case === "or_rules" && object.rule?.or_rules !== undefined && object.rule?.or_rules !== null) {
      message.rule = { $case: "or_rules", or_rules: Permission_Set.fromPartial(object.rule.or_rules) };
    }
    if (object.rule?.$case === "any" && object.rule?.any !== undefined && object.rule?.any !== null) {
      message.rule = { $case: "any", any: object.rule.any };
    }
    if (object.rule?.$case === "header" && object.rule?.header !== undefined && object.rule?.header !== null) {
      message.rule = { $case: "header", header: HeaderMatcher.fromPartial(object.rule.header) };
    }
    if (object.rule?.$case === "url_path" && object.rule?.url_path !== undefined && object.rule?.url_path !== null) {
      message.rule = { $case: "url_path", url_path: PathMatcher.fromPartial(object.rule.url_path) };
    }
    if (
      object.rule?.$case === "destination_ip" &&
      object.rule?.destination_ip !== undefined &&
      object.rule?.destination_ip !== null
    ) {
      message.rule = { $case: "destination_ip", destination_ip: CidrRange.fromPartial(object.rule.destination_ip) };
    }
    if (
      object.rule?.$case === "destination_port" &&
      object.rule?.destination_port !== undefined &&
      object.rule?.destination_port !== null
    ) {
      message.rule = { $case: "destination_port", destination_port: object.rule.destination_port };
    }
    if (
      object.rule?.$case === "destination_port_range" &&
      object.rule?.destination_port_range !== undefined &&
      object.rule?.destination_port_range !== null
    ) {
      message.rule = {
        $case: "destination_port_range",
        destination_port_range: Int32Range.fromPartial(object.rule.destination_port_range),
      };
    }
    if (object.rule?.$case === "metadata" && object.rule?.metadata !== undefined && object.rule?.metadata !== null) {
      message.rule = { $case: "metadata", metadata: MetadataMatcher.fromPartial(object.rule.metadata) };
    }
    if (object.rule?.$case === "not_rule" && object.rule?.not_rule !== undefined && object.rule?.not_rule !== null) {
      message.rule = { $case: "not_rule", not_rule: Permission.fromPartial(object.rule.not_rule) };
    }
    if (
      object.rule?.$case === "requested_server_name" &&
      object.rule?.requested_server_name !== undefined &&
      object.rule?.requested_server_name !== null
    ) {
      message.rule = {
        $case: "requested_server_name",
        requested_server_name: StringMatcher.fromPartial(object.rule.requested_server_name),
      };
    }
    if (object.rule?.$case === "matcher" && object.rule?.matcher !== undefined && object.rule?.matcher !== null) {
      message.rule = { $case: "matcher", matcher: TypedExtensionConfig.fromPartial(object.rule.matcher) };
    }
    if (
      object.rule?.$case === "uri_template" &&
      object.rule?.uri_template !== undefined &&
      object.rule?.uri_template !== null
    ) {
      message.rule = {
        $case: "uri_template",
        uri_template: TypedExtensionConfig.fromPartial(object.rule.uri_template),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(Permission.$type, Permission);

function createBasePermission_Set(): Permission_Set {
  return { $type: "envoy.config.rbac.v3.Permission.Set" };
}

export const Permission_Set: MessageFns<Permission_Set, "envoy.config.rbac.v3.Permission.Set"> = {
  $type: "envoy.config.rbac.v3.Permission.Set" as const,

  encode(message: Permission_Set, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rules !== undefined && message.rules.length !== 0) {
      for (const v of message.rules) {
        Permission.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Permission_Set {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePermission_Set();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.rules === undefined) {
            message.rules = [];
          }
          const el = Permission.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.rules!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Permission_Set {
    return {
      $type: Permission_Set.$type,
      rules: globalThis.Array.isArray(object?.rules) ? object.rules.map((e: any) => Permission.fromJSON(e)) : undefined,
    };
  },

  toJSON(message: Permission_Set): unknown {
    const obj: any = {};
    if (message.rules?.length) {
      obj.rules = message.rules.map((e) => Permission.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Permission_Set>, I>>(base?: I): Permission_Set {
    return Permission_Set.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Permission_Set>, I>>(object: I): Permission_Set {
    const message = createBasePermission_Set();
    message.rules = object.rules?.map((e) => Permission.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(Permission_Set.$type, Permission_Set);

function createBasePrincipal(): Principal {
  return { $type: "envoy.config.rbac.v3.Principal", identifier: undefined };
}

export const Principal: MessageFns<Principal, "envoy.config.rbac.v3.Principal"> = {
  $type: "envoy.config.rbac.v3.Principal" as const,

  encode(message: Principal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.identifier?.$case) {
      case "and_ids":
        Principal_Set.encode(message.identifier.and_ids, writer.uint32(10).fork()).join();
        break;
      case "or_ids":
        Principal_Set.encode(message.identifier.or_ids, writer.uint32(18).fork()).join();
        break;
      case "any":
        writer.uint32(24).bool(message.identifier.any);
        break;
      case "authenticated":
        Principal_Authenticated.encode(message.identifier.authenticated, writer.uint32(34).fork()).join();
        break;
      case "source_ip":
        CidrRange.encode(message.identifier.source_ip, writer.uint32(42).fork()).join();
        break;
      case "direct_remote_ip":
        CidrRange.encode(message.identifier.direct_remote_ip, writer.uint32(82).fork()).join();
        break;
      case "remote_ip":
        CidrRange.encode(message.identifier.remote_ip, writer.uint32(90).fork()).join();
        break;
      case "header":
        HeaderMatcher.encode(message.identifier.header, writer.uint32(50).fork()).join();
        break;
      case "url_path":
        PathMatcher.encode(message.identifier.url_path, writer.uint32(74).fork()).join();
        break;
      case "metadata":
        MetadataMatcher.encode(message.identifier.metadata, writer.uint32(58).fork()).join();
        break;
      case "filter_state":
        FilterStateMatcher.encode(message.identifier.filter_state, writer.uint32(98).fork()).join();
        break;
      case "not_id":
        Principal.encode(message.identifier.not_id, writer.uint32(66).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Principal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrincipal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.identifier = { $case: "and_ids", and_ids: Principal_Set.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.identifier = { $case: "or_ids", or_ids: Principal_Set.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.identifier = { $case: "any", any: reader.bool() };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.identifier = {
            $case: "authenticated",
            authenticated: Principal_Authenticated.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.identifier = { $case: "source_ip", source_ip: CidrRange.decode(reader, reader.uint32()) };
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.identifier = {
            $case: "direct_remote_ip",
            direct_remote_ip: CidrRange.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.identifier = { $case: "remote_ip", remote_ip: CidrRange.decode(reader, reader.uint32()) };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.identifier = { $case: "header", header: HeaderMatcher.decode(reader, reader.uint32()) };
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.identifier = { $case: "url_path", url_path: PathMatcher.decode(reader, reader.uint32()) };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.identifier = { $case: "metadata", metadata: MetadataMatcher.decode(reader, reader.uint32()) };
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.identifier = {
            $case: "filter_state",
            filter_state: FilterStateMatcher.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.identifier = { $case: "not_id", not_id: Principal.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Principal {
    return {
      $type: Principal.$type,
      identifier: isSet(object.and_ids)
        ? { $case: "and_ids", and_ids: Principal_Set.fromJSON(object.and_ids) }
        : isSet(object.or_ids)
        ? { $case: "or_ids", or_ids: Principal_Set.fromJSON(object.or_ids) }
        : isSet(object.any)
        ? { $case: "any", any: globalThis.Boolean(object.any) }
        : isSet(object.authenticated)
        ? { $case: "authenticated", authenticated: Principal_Authenticated.fromJSON(object.authenticated) }
        : isSet(object.source_ip)
        ? { $case: "source_ip", source_ip: CidrRange.fromJSON(object.source_ip) }
        : isSet(object.direct_remote_ip)
        ? { $case: "direct_remote_ip", direct_remote_ip: CidrRange.fromJSON(object.direct_remote_ip) }
        : isSet(object.remote_ip)
        ? { $case: "remote_ip", remote_ip: CidrRange.fromJSON(object.remote_ip) }
        : isSet(object.header)
        ? { $case: "header", header: HeaderMatcher.fromJSON(object.header) }
        : isSet(object.url_path)
        ? { $case: "url_path", url_path: PathMatcher.fromJSON(object.url_path) }
        : isSet(object.metadata)
        ? { $case: "metadata", metadata: MetadataMatcher.fromJSON(object.metadata) }
        : isSet(object.filter_state)
        ? { $case: "filter_state", filter_state: FilterStateMatcher.fromJSON(object.filter_state) }
        : isSet(object.not_id)
        ? { $case: "not_id", not_id: Principal.fromJSON(object.not_id) }
        : undefined,
    };
  },

  toJSON(message: Principal): unknown {
    const obj: any = {};
    if (message.identifier?.$case === "and_ids") {
      obj.and_ids = Principal_Set.toJSON(message.identifier.and_ids);
    }
    if (message.identifier?.$case === "or_ids") {
      obj.or_ids = Principal_Set.toJSON(message.identifier.or_ids);
    }
    if (message.identifier?.$case === "any") {
      obj.any = message.identifier.any;
    }
    if (message.identifier?.$case === "authenticated") {
      obj.authenticated = Principal_Authenticated.toJSON(message.identifier.authenticated);
    }
    if (message.identifier?.$case === "source_ip") {
      obj.source_ip = CidrRange.toJSON(message.identifier.source_ip);
    }
    if (message.identifier?.$case === "direct_remote_ip") {
      obj.direct_remote_ip = CidrRange.toJSON(message.identifier.direct_remote_ip);
    }
    if (message.identifier?.$case === "remote_ip") {
      obj.remote_ip = CidrRange.toJSON(message.identifier.remote_ip);
    }
    if (message.identifier?.$case === "header") {
      obj.header = HeaderMatcher.toJSON(message.identifier.header);
    }
    if (message.identifier?.$case === "url_path") {
      obj.url_path = PathMatcher.toJSON(message.identifier.url_path);
    }
    if (message.identifier?.$case === "metadata") {
      obj.metadata = MetadataMatcher.toJSON(message.identifier.metadata);
    }
    if (message.identifier?.$case === "filter_state") {
      obj.filter_state = FilterStateMatcher.toJSON(message.identifier.filter_state);
    }
    if (message.identifier?.$case === "not_id") {
      obj.not_id = Principal.toJSON(message.identifier.not_id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Principal>, I>>(base?: I): Principal {
    return Principal.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Principal>, I>>(object: I): Principal {
    const message = createBasePrincipal();
    if (
      object.identifier?.$case === "and_ids" &&
      object.identifier?.and_ids !== undefined &&
      object.identifier?.and_ids !== null
    ) {
      message.identifier = { $case: "and_ids", and_ids: Principal_Set.fromPartial(object.identifier.and_ids) };
    }
    if (
      object.identifier?.$case === "or_ids" &&
      object.identifier?.or_ids !== undefined &&
      object.identifier?.or_ids !== null
    ) {
      message.identifier = { $case: "or_ids", or_ids: Principal_Set.fromPartial(object.identifier.or_ids) };
    }
    if (object.identifier?.$case === "any" && object.identifier?.any !== undefined && object.identifier?.any !== null) {
      message.identifier = { $case: "any", any: object.identifier.any };
    }
    if (
      object.identifier?.$case === "authenticated" &&
      object.identifier?.authenticated !== undefined &&
      object.identifier?.authenticated !== null
    ) {
      message.identifier = {
        $case: "authenticated",
        authenticated: Principal_Authenticated.fromPartial(object.identifier.authenticated),
      };
    }
    if (
      object.identifier?.$case === "source_ip" &&
      object.identifier?.source_ip !== undefined &&
      object.identifier?.source_ip !== null
    ) {
      message.identifier = { $case: "source_ip", source_ip: CidrRange.fromPartial(object.identifier.source_ip) };
    }
    if (
      object.identifier?.$case === "direct_remote_ip" &&
      object.identifier?.direct_remote_ip !== undefined &&
      object.identifier?.direct_remote_ip !== null
    ) {
      message.identifier = {
        $case: "direct_remote_ip",
        direct_remote_ip: CidrRange.fromPartial(object.identifier.direct_remote_ip),
      };
    }
    if (
      object.identifier?.$case === "remote_ip" &&
      object.identifier?.remote_ip !== undefined &&
      object.identifier?.remote_ip !== null
    ) {
      message.identifier = { $case: "remote_ip", remote_ip: CidrRange.fromPartial(object.identifier.remote_ip) };
    }
    if (
      object.identifier?.$case === "header" &&
      object.identifier?.header !== undefined &&
      object.identifier?.header !== null
    ) {
      message.identifier = { $case: "header", header: HeaderMatcher.fromPartial(object.identifier.header) };
    }
    if (
      object.identifier?.$case === "url_path" &&
      object.identifier?.url_path !== undefined &&
      object.identifier?.url_path !== null
    ) {
      message.identifier = { $case: "url_path", url_path: PathMatcher.fromPartial(object.identifier.url_path) };
    }
    if (
      object.identifier?.$case === "metadata" &&
      object.identifier?.metadata !== undefined &&
      object.identifier?.metadata !== null
    ) {
      message.identifier = { $case: "metadata", metadata: MetadataMatcher.fromPartial(object.identifier.metadata) };
    }
    if (
      object.identifier?.$case === "filter_state" &&
      object.identifier?.filter_state !== undefined &&
      object.identifier?.filter_state !== null
    ) {
      message.identifier = {
        $case: "filter_state",
        filter_state: FilterStateMatcher.fromPartial(object.identifier.filter_state),
      };
    }
    if (
      object.identifier?.$case === "not_id" &&
      object.identifier?.not_id !== undefined &&
      object.identifier?.not_id !== null
    ) {
      message.identifier = { $case: "not_id", not_id: Principal.fromPartial(object.identifier.not_id) };
    }
    return message;
  },
};

messageTypeRegistry.set(Principal.$type, Principal);

function createBasePrincipal_Set(): Principal_Set {
  return { $type: "envoy.config.rbac.v3.Principal.Set" };
}

export const Principal_Set: MessageFns<Principal_Set, "envoy.config.rbac.v3.Principal.Set"> = {
  $type: "envoy.config.rbac.v3.Principal.Set" as const,

  encode(message: Principal_Set, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ids !== undefined && message.ids.length !== 0) {
      for (const v of message.ids) {
        Principal.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Principal_Set {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrincipal_Set();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.ids === undefined) {
            message.ids = [];
          }
          const el = Principal.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.ids!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Principal_Set {
    return {
      $type: Principal_Set.$type,
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => Principal.fromJSON(e)) : undefined,
    };
  },

  toJSON(message: Principal_Set): unknown {
    const obj: any = {};
    if (message.ids?.length) {
      obj.ids = message.ids.map((e) => Principal.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Principal_Set>, I>>(base?: I): Principal_Set {
    return Principal_Set.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Principal_Set>, I>>(object: I): Principal_Set {
    const message = createBasePrincipal_Set();
    message.ids = object.ids?.map((e) => Principal.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(Principal_Set.$type, Principal_Set);

function createBasePrincipal_Authenticated(): Principal_Authenticated {
  return { $type: "envoy.config.rbac.v3.Principal.Authenticated" };
}

export const Principal_Authenticated: MessageFns<
  Principal_Authenticated,
  "envoy.config.rbac.v3.Principal.Authenticated"
> = {
  $type: "envoy.config.rbac.v3.Principal.Authenticated" as const,

  encode(message: Principal_Authenticated, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.principal_name !== undefined) {
      StringMatcher.encode(message.principal_name, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Principal_Authenticated {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrincipal_Authenticated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.principal_name = StringMatcher.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Principal_Authenticated {
    return {
      $type: Principal_Authenticated.$type,
      principal_name: isSet(object.principal_name) ? StringMatcher.fromJSON(object.principal_name) : undefined,
    };
  },

  toJSON(message: Principal_Authenticated): unknown {
    const obj: any = {};
    if (message.principal_name !== undefined) {
      obj.principal_name = StringMatcher.toJSON(message.principal_name);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Principal_Authenticated>, I>>(base?: I): Principal_Authenticated {
    return Principal_Authenticated.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Principal_Authenticated>, I>>(object: I): Principal_Authenticated {
    const message = createBasePrincipal_Authenticated();
    message.principal_name = (object.principal_name !== undefined && object.principal_name !== null)
      ? StringMatcher.fromPartial(object.principal_name)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Principal_Authenticated.$type, Principal_Authenticated);

function createBaseAction(): Action {
  return { $type: "envoy.config.rbac.v3.Action" };
}

export const Action: MessageFns<Action, "envoy.config.rbac.v3.Action"> = {
  $type: "envoy.config.rbac.v3.Action" as const,

  encode(message: Action, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.action !== undefined && message.action !== RBAC_Action.ALLOW) {
      writer.uint32(16).int32(rBAC_ActionToNumber(message.action));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Action {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.action = rBAC_ActionFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Action {
    return {
      $type: Action.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      action: isSet(object.action) ? rBAC_ActionFromJSON(object.action) : undefined,
    };
  },

  toJSON(message: Action): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.action !== undefined) {
      obj.action = rBAC_ActionToJSON(message.action);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Action>, I>>(base?: I): Action {
    return Action.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Action>, I>>(object: I): Action {
    const message = createBaseAction();
    message.name = object.name ?? undefined;
    message.action = object.action ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Action.$type, Action);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
