// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/config/core/v3/health_check.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Any } from "../../../../google/protobuf/any";
import { Duration } from "../../../../google/protobuf/duration";
import { Struct } from "../../../../google/protobuf/struct";
import { BoolValue, UInt32Value, UInt64Value } from "../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../typeRegistry";
import { StringMatcher } from "../../../type/matcher/v3/string";
import {
  CodecClientType,
  codecClientTypeFromJSON,
  codecClientTypeToJSON,
  codecClientTypeToNumber,
} from "../../../type/v3/http";
import { Int64Range } from "../../../type/v3/range";
import {
  HeaderValueOption,
  RequestMethod,
  requestMethodFromJSON,
  requestMethodToJSON,
  requestMethodToNumber,
} from "./base";
import { EventServiceConfig } from "./event_service_config";
import { TypedExtensionConfig } from "./extension";
import { ProxyProtocolConfig } from "./proxy_protocol";

export const protobufPackage = "envoy.config.core.v3";

/** Endpoint health status. */
export enum HealthStatus {
  /** UNKNOWN - The health status is not known. This is interpreted by Envoy as ``HEALTHY``. */
  UNKNOWN = "UNKNOWN",
  /** HEALTHY - Healthy. */
  HEALTHY = "HEALTHY",
  /** UNHEALTHY - Unhealthy. */
  UNHEALTHY = "UNHEALTHY",
  /**
   * DRAINING - Connection draining in progress. E.g.,
   * `<https://aws.amazon.com/blogs/aws/elb-connection-draining-remove-instances-from-service-with-care/>`_
   * or
   * `<https://cloud.google.com/compute/docs/load-balancing/enabling-connection-draining>`_.
   * This is interpreted by Envoy as ``UNHEALTHY``.
   */
  DRAINING = "DRAINING",
  /**
   * TIMEOUT - Health check timed out. This is part of HDS and is interpreted by Envoy as
   * ``UNHEALTHY``.
   */
  TIMEOUT = "TIMEOUT",
  /** DEGRADED - Degraded. */
  DEGRADED = "DEGRADED",
}

export function healthStatusFromJSON(object: any): HealthStatus {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return HealthStatus.UNKNOWN;
    case 1:
    case "HEALTHY":
      return HealthStatus.HEALTHY;
    case 2:
    case "UNHEALTHY":
      return HealthStatus.UNHEALTHY;
    case 3:
    case "DRAINING":
      return HealthStatus.DRAINING;
    case 4:
    case "TIMEOUT":
      return HealthStatus.TIMEOUT;
    case 5:
    case "DEGRADED":
      return HealthStatus.DEGRADED;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum HealthStatus");
  }
}

export function healthStatusToJSON(object: HealthStatus): string {
  switch (object) {
    case HealthStatus.UNKNOWN:
      return "UNKNOWN";
    case HealthStatus.HEALTHY:
      return "HEALTHY";
    case HealthStatus.UNHEALTHY:
      return "UNHEALTHY";
    case HealthStatus.DRAINING:
      return "DRAINING";
    case HealthStatus.TIMEOUT:
      return "TIMEOUT";
    case HealthStatus.DEGRADED:
      return "DEGRADED";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum HealthStatus");
  }
}

export function healthStatusToNumber(object: HealthStatus): number {
  switch (object) {
    case HealthStatus.UNKNOWN:
      return 0;
    case HealthStatus.HEALTHY:
      return 1;
    case HealthStatus.UNHEALTHY:
      return 2;
    case HealthStatus.DRAINING:
      return 3;
    case HealthStatus.TIMEOUT:
      return 4;
    case HealthStatus.DEGRADED:
      return 5;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum HealthStatus");
  }
}

export interface HealthStatusSet {
  $type: "envoy.config.core.v3.HealthStatusSet";
  /** An order-independent set of health status. */
  statuses?: HealthStatus[] | undefined;
}

/** [#next-free-field: 27] */
export interface HealthCheck {
  $type: "envoy.config.core.v3.HealthCheck";
  /**
   * The time to wait for a health check response. If the timeout is reached the
   * health check attempt will be considered a failure.
   */
  timeout?:
    | Duration
    | undefined;
  /** The interval between health checks. */
  interval?:
    | Duration
    | undefined;
  /**
   * An optional jitter amount in milliseconds. If specified, Envoy will start health
   * checking after for a random time in ms between 0 and initial_jitter. This only
   * applies to the first health check.
   */
  initial_jitter?:
    | Duration
    | undefined;
  /**
   * An optional jitter amount in milliseconds. If specified, during every
   * interval Envoy will add interval_jitter to the wait time.
   */
  interval_jitter?:
    | Duration
    | undefined;
  /**
   * An optional jitter amount as a percentage of interval_ms. If specified,
   * during every interval Envoy will add ``interval_ms`` *
   * ``interval_jitter_percent`` / 100 to the wait time.
   *
   * If interval_jitter_ms and interval_jitter_percent are both set, both of
   * them will be used to increase the wait time.
   */
  interval_jitter_percent?:
    | number
    | undefined;
  /**
   * The number of unhealthy health checks required before a host is marked
   * unhealthy. Note that for ``http`` health checking if a host responds with a code not in
   * :ref:`expected_statuses <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses>`
   * or :ref:`retriable_statuses <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.retriable_statuses>`,
   * this threshold is ignored and the host is considered immediately unhealthy.
   */
  unhealthy_threshold?:
    | number
    | undefined;
  /**
   * The number of healthy health checks required before a host is marked
   * healthy. Note that during startup, only a single successful health check is
   * required to mark a host healthy.
   */
  healthy_threshold?:
    | number
    | undefined;
  /** [#not-implemented-hide:] Non-serving port for health checking. */
  alt_port?:
    | number
    | undefined;
  /** Reuse health check connection between health checks. Default is true. */
  reuse_connection?: boolean | undefined;
  health_checker?:
    | //
    /** HTTP health check. */
    { $case: "http_health_check"; http_health_check: HealthCheck_HttpHealthCheck }
    | //
    /** TCP health check. */
    { $case: "tcp_health_check"; tcp_health_check: HealthCheck_TcpHealthCheck }
    | //
    /** gRPC health check. */
    { $case: "grpc_health_check"; grpc_health_check: HealthCheck_GrpcHealthCheck }
    | //
    /** Custom health check. */
    { $case: "custom_health_check"; custom_health_check: HealthCheck_CustomHealthCheck }
    | undefined;
  /**
   * The "no traffic interval" is a special health check interval that is used when a cluster has
   * never had traffic routed to it. This lower interval allows cluster information to be kept up to
   * date, without sending a potentially large amount of active health checking traffic for no
   * reason. Once a cluster has been used for traffic routing, Envoy will shift back to using the
   * standard health check interval that is defined. Note that this interval takes precedence over
   * any other.
   *
   * The default value for "no traffic interval" is 60 seconds.
   */
  no_traffic_interval?:
    | Duration
    | undefined;
  /**
   * The "no traffic healthy interval" is a special health check interval that
   * is used for hosts that are currently passing active health checking
   * (including new hosts) when the cluster has received no traffic.
   *
   * This is useful for when we want to send frequent health checks with
   * ``no_traffic_interval`` but then revert to lower frequency ``no_traffic_healthy_interval`` once
   * a host in the cluster is marked as healthy.
   *
   * Once a cluster has been used for traffic routing, Envoy will shift back to using the
   * standard health check interval that is defined.
   *
   * If no_traffic_healthy_interval is not set, it will default to the
   * no traffic interval and send that interval regardless of health state.
   */
  no_traffic_healthy_interval?:
    | Duration
    | undefined;
  /**
   * The "unhealthy interval" is a health check interval that is used for hosts that are marked as
   * unhealthy. As soon as the host is marked as healthy, Envoy will shift back to using the
   * standard health check interval that is defined.
   *
   * The default value for "unhealthy interval" is the same as "interval".
   */
  unhealthy_interval?:
    | Duration
    | undefined;
  /**
   * The "unhealthy edge interval" is a special health check interval that is used for the first
   * health check right after a host is marked as unhealthy. For subsequent health checks
   * Envoy will shift back to using either "unhealthy interval" if present or the standard health
   * check interval that is defined.
   *
   * The default value for "unhealthy edge interval" is the same as "unhealthy interval".
   */
  unhealthy_edge_interval?:
    | Duration
    | undefined;
  /**
   * The "healthy edge interval" is a special health check interval that is used for the first
   * health check right after a host is marked as healthy. For subsequent health checks
   * Envoy will shift back to using the standard health check interval that is defined.
   *
   * The default value for "healthy edge interval" is the same as the default interval.
   */
  healthy_edge_interval?:
    | Duration
    | undefined;
  /**
   * .. attention::
   * This field is deprecated in favor of the extension
   * :ref:`event_logger <envoy_v3_api_field_config.core.v3.HealthCheck.event_logger>` and
   * :ref:`event_log_path <envoy_v3_api_field_extensions.health_check.event_sinks.file.v3.HealthCheckEventFileSink.event_log_path>`
   * in the file sink extension.
   *
   * Specifies the path to the :ref:`health check event log <arch_overview_health_check_logging>`.
   *
   * @deprecated
   */
  event_log_path?:
    | string
    | undefined;
  /**
   * A list of event log sinks to process the health check event.
   * [#extension-category: envoy.health_check.event_sinks]
   */
  event_logger?:
    | TypedExtensionConfig[]
    | undefined;
  /**
   * [#not-implemented-hide:]
   * The gRPC service for the health check event service.
   * If empty, health check events won't be sent to a remote endpoint.
   */
  event_service?:
    | EventServiceConfig
    | undefined;
  /**
   * If set to true, health check failure events will always be logged. If set to false, only the
   * initial health check failure event will be logged.
   * The default value is false.
   */
  always_log_health_check_failures?:
    | boolean
    | undefined;
  /**
   * If set to true, health check success events will always be logged. If set to false, only host addition event will be logged
   * if it is the first successful health check, or if the healthy threshold is reached.
   * The default value is false.
   */
  always_log_health_check_success?:
    | boolean
    | undefined;
  /** This allows overriding the cluster TLS settings, just for health check connections. */
  tls_options?:
    | HealthCheck_TlsOptions
    | undefined;
  /**
   * Optional key/value pairs that will be used to match a transport socket from those specified in the cluster's
   * :ref:`tranport socket matches <envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches>`.
   * For example, the following match criteria
   *
   * .. code-block:: yaml
   *
   *  transport_socket_match_criteria:
   *    useMTLS: true
   *
   * Will match the following :ref:`cluster socket match <envoy_v3_api_msg_config.cluster.v3.Cluster.TransportSocketMatch>`
   *
   * .. code-block:: yaml
   *
   *  transport_socket_matches:
   *  - name: "useMTLS"
   *    match:
   *      useMTLS: true
   *    transport_socket:
   *      name: envoy.transport_sockets.tls
   *      config: { ... } # tls socket configuration
   *
   * If this field is set, then for health checks it will supersede an entry of ``envoy.transport_socket`` in the
   * :ref:`LbEndpoint.Metadata <envoy_v3_api_field_config.endpoint.v3.LbEndpoint.metadata>`.
   * This allows using different transport socket capabilities for health checking versus proxying to the
   * endpoint.
   *
   * If the key/values pairs specified do not match any
   * :ref:`transport socket matches <envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches>`,
   * the cluster's :ref:`transport socket <envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket>`
   * will be used for health check socket configuration.
   */
  transport_socket_match_criteria?: { [key: string]: any } | undefined;
}

/** Describes the encoding of the payload bytes in the payload. */
export interface HealthCheck_Payload {
  $type: "envoy.config.core.v3.HealthCheck.Payload";
  payload?:
    | //
    /** Hex encoded payload. E.g., "000000FF". */
    { $case: "text"; text: string }
    | //
    /** Binary payload. */
    { $case: "binary"; binary: Uint8Array }
    | undefined;
}

/** [#next-free-field: 15] */
export interface HealthCheck_HttpHealthCheck {
  $type: "envoy.config.core.v3.HealthCheck.HttpHealthCheck";
  /**
   * The value of the host header in the HTTP health check request. If
   * left empty (default value), the name of the cluster this health check is associated
   * with will be used. The host header can be customized for a specific endpoint by setting the
   * :ref:`hostname <envoy_v3_api_field_config.endpoint.v3.Endpoint.HealthCheckConfig.hostname>` field.
   */
  host?:
    | string
    | undefined;
  /**
   * Specifies the HTTP path that will be requested during health checking. For example
   * ``/healthcheck``.
   */
  path?:
    | string
    | undefined;
  /** [#not-implemented-hide:] HTTP specific payload. */
  send?:
    | HealthCheck_Payload
    | undefined;
  /**
   * Specifies a list of HTTP expected responses to match in the first ``response_buffer_size`` bytes of the response body.
   * If it is set, both the expected response check and status code determine the health check.
   * When checking the response, “fuzzy” matching is performed such that each payload block must be found,
   * and in the order specified, but not necessarily contiguous.
   *
   * .. note::
   *
   *   It is recommended to set ``response_buffer_size`` based on the total Payload size for efficiency.
   *   The default buffer size is 1024 bytes when it is not set.
   */
  receive?:
    | HealthCheck_Payload[]
    | undefined;
  /**
   * Specifies the size of response buffer in bytes that is used to Payload match.
   * The default value is 1024. Setting to 0 implies that the Payload will be matched against the entire response.
   */
  response_buffer_size?:
    | number
    | undefined;
  /**
   * Specifies a list of HTTP headers that should be added to each request that is sent to the
   * health checked cluster. For more information, including details on header value syntax, see
   * the documentation on :ref:`custom request headers
   * <config_http_conn_man_headers_custom_request_headers>`.
   */
  request_headers_to_add?:
    | HeaderValueOption[]
    | undefined;
  /**
   * Specifies a list of HTTP headers that should be removed from each request that is sent to the
   * health checked cluster.
   */
  request_headers_to_remove?:
    | string[]
    | undefined;
  /**
   * Specifies a list of HTTP response statuses considered healthy. If provided, replaces default
   * 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open
   * semantics of :ref:`Int64Range <envoy_v3_api_msg_type.v3.Int64Range>`. The start and end of each
   * range are required. Only statuses in the range [100, 600) are allowed.
   */
  expected_statuses?:
    | Int64Range[]
    | undefined;
  /**
   * Specifies a list of HTTP response statuses considered retriable. If provided, responses in this range
   * will count towards the configured :ref:`unhealthy_threshold <envoy_v3_api_field_config.core.v3.HealthCheck.unhealthy_threshold>`,
   * but will not result in the host being considered immediately unhealthy. Ranges follow half-open semantics of
   * :ref:`Int64Range <envoy_v3_api_msg_type.v3.Int64Range>`. The start and end of each range are required.
   * Only statuses in the range [100, 600) are allowed. The :ref:`expected_statuses <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses>`
   * field takes precedence for any range overlaps with this field i.e. if status code 200 is both retriable and expected, a 200 response will
   * be considered a successful health check. By default all responses not in
   * :ref:`expected_statuses <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses>` will result in
   * the host being considered immediately unhealthy i.e. if status code 200 is expected and there are no configured retriable statuses, any
   * non-200 response will result in the host being marked unhealthy.
   */
  retriable_statuses?:
    | Int64Range[]
    | undefined;
  /** Use specified application protocol for health checks. */
  codec_client_type?:
    | CodecClientType
    | undefined;
  /**
   * An optional service name parameter which is used to validate the identity of
   * the health checked cluster using a :ref:`StringMatcher
   * <envoy_v3_api_msg_type.matcher.v3.StringMatcher>`. See the :ref:`architecture overview
   * <arch_overview_health_checking_identity>` for more information.
   */
  service_name_matcher?:
    | StringMatcher
    | undefined;
  /**
   * HTTP Method that will be used for health checking, default is "GET".
   * GET, HEAD, POST, PUT, DELETE, OPTIONS, TRACE, PATCH methods are supported, but making request body is not supported.
   * CONNECT method is disallowed because it is not appropriate for health check request.
   * If a non-200 response is expected by the method, it needs to be set in :ref:`expected_statuses <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses>`.
   */
  method?: RequestMethod | undefined;
}

export interface HealthCheck_TcpHealthCheck {
  $type: "envoy.config.core.v3.HealthCheck.TcpHealthCheck";
  /** Empty payloads imply a connect-only health check. */
  send?:
    | HealthCheck_Payload
    | undefined;
  /**
   * When checking the response, “fuzzy” matching is performed such that each
   * payload block must be found, and in the order specified, but not
   * necessarily contiguous.
   */
  receive?:
    | HealthCheck_Payload[]
    | undefined;
  /**
   * When setting this value, it tries to attempt health check request with ProxyProtocol.
   * When ``send`` is presented, they are sent after preceding ProxyProtocol header.
   * Only ProxyProtocol header is sent when ``send`` is not presented.
   * It allows to use both ProxyProtocol V1 and V2. In V1, it presents L3/L4. In V2, it includes
   * LOCAL command and doesn't include L3/L4.
   */
  proxy_protocol_config?: ProxyProtocolConfig | undefined;
}

export interface HealthCheck_RedisHealthCheck {
  $type: "envoy.config.core.v3.HealthCheck.RedisHealthCheck";
  /**
   * If set, optionally perform ``EXISTS <key>`` instead of ``PING``. A return value
   * from Redis of 0 (does not exist) is considered a passing healthcheck. A return value other
   * than 0 is considered a failure. This allows the user to mark a Redis instance for maintenance
   * by setting the specified key to any value and waiting for traffic to drain.
   */
  key?: string | undefined;
}

/**
 * `grpc.health.v1.Health
 * <https://github.com/grpc/grpc/blob/master/src/proto/grpc/health/v1/health.proto>`_-based
 * healthcheck. See `gRPC doc <https://github.com/grpc/grpc/blob/master/doc/health-checking.md>`_
 * for details.
 */
export interface HealthCheck_GrpcHealthCheck {
  $type: "envoy.config.core.v3.HealthCheck.GrpcHealthCheck";
  /**
   * An optional service name parameter which will be sent to gRPC service in
   * `grpc.health.v1.HealthCheckRequest
   * <https://github.com/grpc/grpc/blob/master/src/proto/grpc/health/v1/health.proto#L20>`_.
   * message. See `gRPC health-checking overview
   * <https://github.com/grpc/grpc/blob/master/doc/health-checking.md>`_ for more information.
   */
  service_name?:
    | string
    | undefined;
  /**
   * The value of the :authority header in the gRPC health check request. If
   * left empty (default value), the name of the cluster this health check is associated
   * with will be used. The authority header can be customized for a specific endpoint by setting
   * the :ref:`hostname <envoy_v3_api_field_config.endpoint.v3.Endpoint.HealthCheckConfig.hostname>` field.
   */
  authority?:
    | string
    | undefined;
  /**
   * Specifies a list of key-value pairs that should be added to the metadata of each GRPC call
   * that is sent to the health checked cluster. For more information, including details on header value syntax,
   * see the documentation on :ref:`custom request headers
   * <config_http_conn_man_headers_custom_request_headers>`.
   */
  initial_metadata?: HeaderValueOption[] | undefined;
}

/** Custom health check. */
export interface HealthCheck_CustomHealthCheck {
  $type: "envoy.config.core.v3.HealthCheck.CustomHealthCheck";
  /** The registered name of the custom health checker. */
  name?:
    | string
    | undefined;
  /**
   * A custom health checker specific configuration which depends on the custom health checker
   * being instantiated. See :api:`envoy/config/health_checker` for reference.
   * [#extension-category: envoy.health_checkers]
   */
  config_type?:
    | //
    { $case: "typed_config"; typed_config: Any }
    | undefined;
}

/**
 * Health checks occur over the transport socket specified for the cluster. This implies that if a
 * cluster is using a TLS-enabled transport socket, the health check will also occur over TLS.
 *
 * This allows overriding the cluster TLS settings, just for health check connections.
 */
export interface HealthCheck_TlsOptions {
  $type: "envoy.config.core.v3.HealthCheck.TlsOptions";
  /**
   * Specifies the ALPN protocols for health check connections. This is useful if the
   * corresponding upstream is using ALPN-based :ref:`FilterChainMatch
   * <envoy_v3_api_msg_config.listener.v3.FilterChainMatch>` along with different protocols for health checks
   * versus data connections. If empty, no ALPN protocols will be set on health check connections.
   */
  alpn_protocols?: string[] | undefined;
}

function createBaseHealthStatusSet(): HealthStatusSet {
  return { $type: "envoy.config.core.v3.HealthStatusSet" };
}

export const HealthStatusSet: MessageFns<HealthStatusSet, "envoy.config.core.v3.HealthStatusSet"> = {
  $type: "envoy.config.core.v3.HealthStatusSet" as const,

  encode(message: HealthStatusSet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.statuses !== undefined && message.statuses.length !== 0) {
      writer.uint32(10).fork();
      for (const v of message.statuses) {
        writer.int32(healthStatusToNumber(v));
      }
      writer.join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthStatusSet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthStatusSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            if (message.statuses === undefined) {
              message.statuses = [];
            }
            message.statuses!.push(healthStatusFromJSON(reader.int32()));

            continue;
          }

          if (tag === 10) {
            if (message.statuses === undefined) {
              message.statuses = [];
            }
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.statuses!.push(healthStatusFromJSON(reader.int32()));
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthStatusSet {
    return {
      $type: HealthStatusSet.$type,
      statuses: globalThis.Array.isArray(object?.statuses)
        ? object.statuses.map((e: any) => healthStatusFromJSON(e))
        : undefined,
    };
  },

  toJSON(message: HealthStatusSet): unknown {
    const obj: any = {};
    if (message.statuses?.length) {
      obj.statuses = message.statuses.map((e) => healthStatusToJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthStatusSet>, I>>(base?: I): HealthStatusSet {
    return HealthStatusSet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthStatusSet>, I>>(object: I): HealthStatusSet {
    const message = createBaseHealthStatusSet();
    message.statuses = object.statuses?.map((e) => e) || undefined;
    return message;
  },
};

messageTypeRegistry.set(HealthStatusSet.$type, HealthStatusSet);

function createBaseHealthCheck(): HealthCheck {
  return { $type: "envoy.config.core.v3.HealthCheck", health_checker: undefined };
}

export const HealthCheck: MessageFns<HealthCheck, "envoy.config.core.v3.HealthCheck"> = {
  $type: "envoy.config.core.v3.HealthCheck" as const,

  encode(message: HealthCheck, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timeout !== undefined) {
      Duration.encode(message.timeout, writer.uint32(10).fork()).join();
    }
    if (message.interval !== undefined) {
      Duration.encode(message.interval, writer.uint32(18).fork()).join();
    }
    if (message.initial_jitter !== undefined) {
      Duration.encode(message.initial_jitter, writer.uint32(162).fork()).join();
    }
    if (message.interval_jitter !== undefined) {
      Duration.encode(message.interval_jitter, writer.uint32(26).fork()).join();
    }
    if (message.interval_jitter_percent !== undefined && message.interval_jitter_percent !== 0) {
      writer.uint32(144).uint32(message.interval_jitter_percent);
    }
    if (message.unhealthy_threshold !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.unhealthy_threshold! },
        writer.uint32(34).fork(),
      ).join();
    }
    if (message.healthy_threshold !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.healthy_threshold! },
        writer.uint32(42).fork(),
      ).join();
    }
    if (message.alt_port !== undefined) {
      UInt32Value.encode({ $type: "google.protobuf.UInt32Value", value: message.alt_port! }, writer.uint32(50).fork())
        .join();
    }
    if (message.reuse_connection !== undefined) {
      BoolValue.encode(
        { $type: "google.protobuf.BoolValue", value: message.reuse_connection! },
        writer.uint32(58).fork(),
      ).join();
    }
    switch (message.health_checker?.$case) {
      case "http_health_check":
        HealthCheck_HttpHealthCheck.encode(message.health_checker.http_health_check, writer.uint32(66).fork()).join();
        break;
      case "tcp_health_check":
        HealthCheck_TcpHealthCheck.encode(message.health_checker.tcp_health_check, writer.uint32(74).fork()).join();
        break;
      case "grpc_health_check":
        HealthCheck_GrpcHealthCheck.encode(message.health_checker.grpc_health_check, writer.uint32(90).fork()).join();
        break;
      case "custom_health_check":
        HealthCheck_CustomHealthCheck.encode(message.health_checker.custom_health_check, writer.uint32(106).fork())
          .join();
        break;
    }
    if (message.no_traffic_interval !== undefined) {
      Duration.encode(message.no_traffic_interval, writer.uint32(98).fork()).join();
    }
    if (message.no_traffic_healthy_interval !== undefined) {
      Duration.encode(message.no_traffic_healthy_interval, writer.uint32(194).fork()).join();
    }
    if (message.unhealthy_interval !== undefined) {
      Duration.encode(message.unhealthy_interval, writer.uint32(114).fork()).join();
    }
    if (message.unhealthy_edge_interval !== undefined) {
      Duration.encode(message.unhealthy_edge_interval, writer.uint32(122).fork()).join();
    }
    if (message.healthy_edge_interval !== undefined) {
      Duration.encode(message.healthy_edge_interval, writer.uint32(130).fork()).join();
    }
    if (message.event_log_path !== undefined && message.event_log_path !== "") {
      writer.uint32(138).string(message.event_log_path);
    }
    if (message.event_logger !== undefined && message.event_logger.length !== 0) {
      for (const v of message.event_logger) {
        TypedExtensionConfig.encode(v!, writer.uint32(202).fork()).join();
      }
    }
    if (message.event_service !== undefined) {
      EventServiceConfig.encode(message.event_service, writer.uint32(178).fork()).join();
    }
    if (message.always_log_health_check_failures !== undefined && message.always_log_health_check_failures !== false) {
      writer.uint32(152).bool(message.always_log_health_check_failures);
    }
    if (message.always_log_health_check_success !== undefined && message.always_log_health_check_success !== false) {
      writer.uint32(208).bool(message.always_log_health_check_success);
    }
    if (message.tls_options !== undefined) {
      HealthCheck_TlsOptions.encode(message.tls_options, writer.uint32(170).fork()).join();
    }
    if (message.transport_socket_match_criteria !== undefined) {
      Struct.encode(Struct.wrap(message.transport_socket_match_criteria), writer.uint32(186).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheck {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.interval = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.initial_jitter = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.interval_jitter = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.interval_jitter_percent = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.unhealthy_threshold = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.healthy_threshold = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.alt_port = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.reuse_connection = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.health_checker = {
            $case: "http_health_check",
            http_health_check: HealthCheck_HttpHealthCheck.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.health_checker = {
            $case: "tcp_health_check",
            tcp_health_check: HealthCheck_TcpHealthCheck.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.health_checker = {
            $case: "grpc_health_check",
            grpc_health_check: HealthCheck_GrpcHealthCheck.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.health_checker = {
            $case: "custom_health_check",
            custom_health_check: HealthCheck_CustomHealthCheck.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.no_traffic_interval = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.no_traffic_healthy_interval = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.unhealthy_interval = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.unhealthy_edge_interval = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.healthy_edge_interval = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.event_log_path = reader.string();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          if (message.event_logger === undefined) {
            message.event_logger = [];
          }
          const el = TypedExtensionConfig.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.event_logger!.push(el);
          }
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.event_service = EventServiceConfig.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.always_log_health_check_failures = reader.bool();
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.always_log_health_check_success = reader.bool();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.tls_options = HealthCheck_TlsOptions.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.transport_socket_match_criteria = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheck {
    return {
      $type: HealthCheck.$type,
      timeout: isSet(object.timeout) ? Duration.fromJSON(object.timeout) : undefined,
      interval: isSet(object.interval) ? Duration.fromJSON(object.interval) : undefined,
      initial_jitter: isSet(object.initial_jitter) ? Duration.fromJSON(object.initial_jitter) : undefined,
      interval_jitter: isSet(object.interval_jitter) ? Duration.fromJSON(object.interval_jitter) : undefined,
      interval_jitter_percent: isSet(object.interval_jitter_percent)
        ? globalThis.Number(object.interval_jitter_percent)
        : undefined,
      unhealthy_threshold: isSet(object.unhealthy_threshold) ? Number(object.unhealthy_threshold) : undefined,
      healthy_threshold: isSet(object.healthy_threshold) ? Number(object.healthy_threshold) : undefined,
      alt_port: isSet(object.alt_port) ? Number(object.alt_port) : undefined,
      reuse_connection: isSet(object.reuse_connection) ? Boolean(object.reuse_connection) : undefined,
      health_checker: isSet(object.http_health_check)
        ? {
          $case: "http_health_check",
          http_health_check: HealthCheck_HttpHealthCheck.fromJSON(object.http_health_check),
        }
        : isSet(object.tcp_health_check)
        ? { $case: "tcp_health_check", tcp_health_check: HealthCheck_TcpHealthCheck.fromJSON(object.tcp_health_check) }
        : isSet(object.grpc_health_check)
        ? {
          $case: "grpc_health_check",
          grpc_health_check: HealthCheck_GrpcHealthCheck.fromJSON(object.grpc_health_check),
        }
        : isSet(object.custom_health_check)
        ? {
          $case: "custom_health_check",
          custom_health_check: HealthCheck_CustomHealthCheck.fromJSON(object.custom_health_check),
        }
        : undefined,
      no_traffic_interval: isSet(object.no_traffic_interval)
        ? Duration.fromJSON(object.no_traffic_interval)
        : undefined,
      no_traffic_healthy_interval: isSet(object.no_traffic_healthy_interval)
        ? Duration.fromJSON(object.no_traffic_healthy_interval)
        : undefined,
      unhealthy_interval: isSet(object.unhealthy_interval) ? Duration.fromJSON(object.unhealthy_interval) : undefined,
      unhealthy_edge_interval: isSet(object.unhealthy_edge_interval)
        ? Duration.fromJSON(object.unhealthy_edge_interval)
        : undefined,
      healthy_edge_interval: isSet(object.healthy_edge_interval)
        ? Duration.fromJSON(object.healthy_edge_interval)
        : undefined,
      event_log_path: isSet(object.event_log_path) ? globalThis.String(object.event_log_path) : undefined,
      event_logger: globalThis.Array.isArray(object?.event_logger)
        ? object.event_logger.map((e: any) => TypedExtensionConfig.fromJSON(e))
        : undefined,
      event_service: isSet(object.event_service) ? EventServiceConfig.fromJSON(object.event_service) : undefined,
      always_log_health_check_failures: isSet(object.always_log_health_check_failures)
        ? globalThis.Boolean(object.always_log_health_check_failures)
        : undefined,
      always_log_health_check_success: isSet(object.always_log_health_check_success)
        ? globalThis.Boolean(object.always_log_health_check_success)
        : undefined,
      tls_options: isSet(object.tls_options) ? HealthCheck_TlsOptions.fromJSON(object.tls_options) : undefined,
      transport_socket_match_criteria: isObject(object.transport_socket_match_criteria)
        ? object.transport_socket_match_criteria
        : undefined,
    };
  },

  toJSON(message: HealthCheck): unknown {
    const obj: any = {};
    if (message.timeout !== undefined) {
      obj.timeout = Duration.toJSON(message.timeout);
    }
    if (message.interval !== undefined) {
      obj.interval = Duration.toJSON(message.interval);
    }
    if (message.initial_jitter !== undefined) {
      obj.initial_jitter = Duration.toJSON(message.initial_jitter);
    }
    if (message.interval_jitter !== undefined) {
      obj.interval_jitter = Duration.toJSON(message.interval_jitter);
    }
    if (message.interval_jitter_percent !== undefined) {
      obj.interval_jitter_percent = Math.round(message.interval_jitter_percent);
    }
    if (message.unhealthy_threshold !== undefined) {
      obj.unhealthy_threshold = message.unhealthy_threshold;
    }
    if (message.healthy_threshold !== undefined) {
      obj.healthy_threshold = message.healthy_threshold;
    }
    if (message.alt_port !== undefined) {
      obj.alt_port = message.alt_port;
    }
    if (message.reuse_connection !== undefined) {
      obj.reuse_connection = message.reuse_connection;
    }
    if (message.health_checker?.$case === "http_health_check") {
      obj.http_health_check = HealthCheck_HttpHealthCheck.toJSON(message.health_checker.http_health_check);
    }
    if (message.health_checker?.$case === "tcp_health_check") {
      obj.tcp_health_check = HealthCheck_TcpHealthCheck.toJSON(message.health_checker.tcp_health_check);
    }
    if (message.health_checker?.$case === "grpc_health_check") {
      obj.grpc_health_check = HealthCheck_GrpcHealthCheck.toJSON(message.health_checker.grpc_health_check);
    }
    if (message.health_checker?.$case === "custom_health_check") {
      obj.custom_health_check = HealthCheck_CustomHealthCheck.toJSON(message.health_checker.custom_health_check);
    }
    if (message.no_traffic_interval !== undefined) {
      obj.no_traffic_interval = Duration.toJSON(message.no_traffic_interval);
    }
    if (message.no_traffic_healthy_interval !== undefined) {
      obj.no_traffic_healthy_interval = Duration.toJSON(message.no_traffic_healthy_interval);
    }
    if (message.unhealthy_interval !== undefined) {
      obj.unhealthy_interval = Duration.toJSON(message.unhealthy_interval);
    }
    if (message.unhealthy_edge_interval !== undefined) {
      obj.unhealthy_edge_interval = Duration.toJSON(message.unhealthy_edge_interval);
    }
    if (message.healthy_edge_interval !== undefined) {
      obj.healthy_edge_interval = Duration.toJSON(message.healthy_edge_interval);
    }
    if (message.event_log_path !== undefined) {
      obj.event_log_path = message.event_log_path;
    }
    if (message.event_logger?.length) {
      obj.event_logger = message.event_logger.map((e) => TypedExtensionConfig.toJSON(e));
    }
    if (message.event_service !== undefined) {
      obj.event_service = EventServiceConfig.toJSON(message.event_service);
    }
    if (message.always_log_health_check_failures !== undefined) {
      obj.always_log_health_check_failures = message.always_log_health_check_failures;
    }
    if (message.always_log_health_check_success !== undefined) {
      obj.always_log_health_check_success = message.always_log_health_check_success;
    }
    if (message.tls_options !== undefined) {
      obj.tls_options = HealthCheck_TlsOptions.toJSON(message.tls_options);
    }
    if (message.transport_socket_match_criteria !== undefined) {
      obj.transport_socket_match_criteria = message.transport_socket_match_criteria;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheck>, I>>(base?: I): HealthCheck {
    return HealthCheck.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheck>, I>>(object: I): HealthCheck {
    const message = createBaseHealthCheck();
    message.timeout = (object.timeout !== undefined && object.timeout !== null)
      ? Duration.fromPartial(object.timeout)
      : undefined;
    message.interval = (object.interval !== undefined && object.interval !== null)
      ? Duration.fromPartial(object.interval)
      : undefined;
    message.initial_jitter = (object.initial_jitter !== undefined && object.initial_jitter !== null)
      ? Duration.fromPartial(object.initial_jitter)
      : undefined;
    message.interval_jitter = (object.interval_jitter !== undefined && object.interval_jitter !== null)
      ? Duration.fromPartial(object.interval_jitter)
      : undefined;
    message.interval_jitter_percent = object.interval_jitter_percent ?? undefined;
    message.unhealthy_threshold = object.unhealthy_threshold ?? undefined;
    message.healthy_threshold = object.healthy_threshold ?? undefined;
    message.alt_port = object.alt_port ?? undefined;
    message.reuse_connection = object.reuse_connection ?? undefined;
    if (
      object.health_checker?.$case === "http_health_check" &&
      object.health_checker?.http_health_check !== undefined &&
      object.health_checker?.http_health_check !== null
    ) {
      message.health_checker = {
        $case: "http_health_check",
        http_health_check: HealthCheck_HttpHealthCheck.fromPartial(object.health_checker.http_health_check),
      };
    }
    if (
      object.health_checker?.$case === "tcp_health_check" &&
      object.health_checker?.tcp_health_check !== undefined &&
      object.health_checker?.tcp_health_check !== null
    ) {
      message.health_checker = {
        $case: "tcp_health_check",
        tcp_health_check: HealthCheck_TcpHealthCheck.fromPartial(object.health_checker.tcp_health_check),
      };
    }
    if (
      object.health_checker?.$case === "grpc_health_check" &&
      object.health_checker?.grpc_health_check !== undefined &&
      object.health_checker?.grpc_health_check !== null
    ) {
      message.health_checker = {
        $case: "grpc_health_check",
        grpc_health_check: HealthCheck_GrpcHealthCheck.fromPartial(object.health_checker.grpc_health_check),
      };
    }
    if (
      object.health_checker?.$case === "custom_health_check" &&
      object.health_checker?.custom_health_check !== undefined &&
      object.health_checker?.custom_health_check !== null
    ) {
      message.health_checker = {
        $case: "custom_health_check",
        custom_health_check: HealthCheck_CustomHealthCheck.fromPartial(object.health_checker.custom_health_check),
      };
    }
    message.no_traffic_interval = (object.no_traffic_interval !== undefined && object.no_traffic_interval !== null)
      ? Duration.fromPartial(object.no_traffic_interval)
      : undefined;
    message.no_traffic_healthy_interval =
      (object.no_traffic_healthy_interval !== undefined && object.no_traffic_healthy_interval !== null)
        ? Duration.fromPartial(object.no_traffic_healthy_interval)
        : undefined;
    message.unhealthy_interval = (object.unhealthy_interval !== undefined && object.unhealthy_interval !== null)
      ? Duration.fromPartial(object.unhealthy_interval)
      : undefined;
    message.unhealthy_edge_interval =
      (object.unhealthy_edge_interval !== undefined && object.unhealthy_edge_interval !== null)
        ? Duration.fromPartial(object.unhealthy_edge_interval)
        : undefined;
    message.healthy_edge_interval =
      (object.healthy_edge_interval !== undefined && object.healthy_edge_interval !== null)
        ? Duration.fromPartial(object.healthy_edge_interval)
        : undefined;
    message.event_log_path = object.event_log_path ?? undefined;
    message.event_logger = object.event_logger?.map((e) => TypedExtensionConfig.fromPartial(e)) || undefined;
    message.event_service = (object.event_service !== undefined && object.event_service !== null)
      ? EventServiceConfig.fromPartial(object.event_service)
      : undefined;
    message.always_log_health_check_failures = object.always_log_health_check_failures ?? undefined;
    message.always_log_health_check_success = object.always_log_health_check_success ?? undefined;
    message.tls_options = (object.tls_options !== undefined && object.tls_options !== null)
      ? HealthCheck_TlsOptions.fromPartial(object.tls_options)
      : undefined;
    message.transport_socket_match_criteria = object.transport_socket_match_criteria ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(HealthCheck.$type, HealthCheck);

function createBaseHealthCheck_Payload(): HealthCheck_Payload {
  return { $type: "envoy.config.core.v3.HealthCheck.Payload", payload: undefined };
}

export const HealthCheck_Payload: MessageFns<HealthCheck_Payload, "envoy.config.core.v3.HealthCheck.Payload"> = {
  $type: "envoy.config.core.v3.HealthCheck.Payload" as const,

  encode(message: HealthCheck_Payload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.payload?.$case) {
      case "text":
        writer.uint32(10).string(message.payload.text);
        break;
      case "binary":
        writer.uint32(18).bytes(message.payload.binary);
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheck_Payload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheck_Payload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = { $case: "text", text: reader.string() };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.payload = { $case: "binary", binary: reader.bytes() };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheck_Payload {
    return {
      $type: HealthCheck_Payload.$type,
      payload: isSet(object.text)
        ? { $case: "text", text: globalThis.String(object.text) }
        : isSet(object.binary)
        ? { $case: "binary", binary: bytesFromBase64(object.binary) }
        : undefined,
    };
  },

  toJSON(message: HealthCheck_Payload): unknown {
    const obj: any = {};
    if (message.payload?.$case === "text") {
      obj.text = message.payload.text;
    }
    if (message.payload?.$case === "binary") {
      obj.binary = base64FromBytes(message.payload.binary);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheck_Payload>, I>>(base?: I): HealthCheck_Payload {
    return HealthCheck_Payload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheck_Payload>, I>>(object: I): HealthCheck_Payload {
    const message = createBaseHealthCheck_Payload();
    if (object.payload?.$case === "text" && object.payload?.text !== undefined && object.payload?.text !== null) {
      message.payload = { $case: "text", text: object.payload.text };
    }
    if (object.payload?.$case === "binary" && object.payload?.binary !== undefined && object.payload?.binary !== null) {
      message.payload = { $case: "binary", binary: object.payload.binary };
    }
    return message;
  },
};

messageTypeRegistry.set(HealthCheck_Payload.$type, HealthCheck_Payload);

function createBaseHealthCheck_HttpHealthCheck(): HealthCheck_HttpHealthCheck {
  return { $type: "envoy.config.core.v3.HealthCheck.HttpHealthCheck" };
}

export const HealthCheck_HttpHealthCheck: MessageFns<
  HealthCheck_HttpHealthCheck,
  "envoy.config.core.v3.HealthCheck.HttpHealthCheck"
> = {
  $type: "envoy.config.core.v3.HealthCheck.HttpHealthCheck" as const,

  encode(message: HealthCheck_HttpHealthCheck, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.host !== undefined && message.host !== "") {
      writer.uint32(10).string(message.host);
    }
    if (message.path !== undefined && message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.send !== undefined) {
      HealthCheck_Payload.encode(message.send, writer.uint32(26).fork()).join();
    }
    if (message.receive !== undefined && message.receive.length !== 0) {
      for (const v of message.receive) {
        HealthCheck_Payload.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    if (message.response_buffer_size !== undefined) {
      UInt64Value.encode(
        { $type: "google.protobuf.UInt64Value", value: message.response_buffer_size! },
        writer.uint32(114).fork(),
      ).join();
    }
    if (message.request_headers_to_add !== undefined && message.request_headers_to_add.length !== 0) {
      for (const v of message.request_headers_to_add) {
        HeaderValueOption.encode(v!, writer.uint32(50).fork()).join();
      }
    }
    if (message.request_headers_to_remove !== undefined && message.request_headers_to_remove.length !== 0) {
      for (const v of message.request_headers_to_remove) {
        writer.uint32(66).string(v!);
      }
    }
    if (message.expected_statuses !== undefined && message.expected_statuses.length !== 0) {
      for (const v of message.expected_statuses) {
        Int64Range.encode(v!, writer.uint32(74).fork()).join();
      }
    }
    if (message.retriable_statuses !== undefined && message.retriable_statuses.length !== 0) {
      for (const v of message.retriable_statuses) {
        Int64Range.encode(v!, writer.uint32(98).fork()).join();
      }
    }
    if (message.codec_client_type !== undefined && message.codec_client_type !== CodecClientType.HTTP1) {
      writer.uint32(80).int32(codecClientTypeToNumber(message.codec_client_type));
    }
    if (message.service_name_matcher !== undefined) {
      StringMatcher.encode(message.service_name_matcher, writer.uint32(90).fork()).join();
    }
    if (message.method !== undefined && message.method !== RequestMethod.METHOD_UNSPECIFIED) {
      writer.uint32(104).int32(requestMethodToNumber(message.method));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheck_HttpHealthCheck {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheck_HttpHealthCheck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.host = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.send = HealthCheck_Payload.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          if (message.receive === undefined) {
            message.receive = [];
          }
          const el = HealthCheck_Payload.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.receive!.push(el);
          }
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.response_buffer_size = UInt64Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          if (message.request_headers_to_add === undefined) {
            message.request_headers_to_add = [];
          }
          const el = HeaderValueOption.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.request_headers_to_add!.push(el);
          }
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          if (message.request_headers_to_remove === undefined) {
            message.request_headers_to_remove = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.request_headers_to_remove!.push(el);
          }
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          if (message.expected_statuses === undefined) {
            message.expected_statuses = [];
          }
          const el = Int64Range.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.expected_statuses!.push(el);
          }
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          if (message.retriable_statuses === undefined) {
            message.retriable_statuses = [];
          }
          const el = Int64Range.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.retriable_statuses!.push(el);
          }
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.codec_client_type = codecClientTypeFromJSON(reader.int32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.service_name_matcher = StringMatcher.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.method = requestMethodFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheck_HttpHealthCheck {
    return {
      $type: HealthCheck_HttpHealthCheck.$type,
      host: isSet(object.host) ? globalThis.String(object.host) : undefined,
      path: isSet(object.path) ? globalThis.String(object.path) : undefined,
      send: isSet(object.send) ? HealthCheck_Payload.fromJSON(object.send) : undefined,
      receive: globalThis.Array.isArray(object?.receive)
        ? object.receive.map((e: any) => HealthCheck_Payload.fromJSON(e))
        : undefined,
      response_buffer_size: isSet(object.response_buffer_size) ? Number(object.response_buffer_size) : undefined,
      request_headers_to_add: globalThis.Array.isArray(object?.request_headers_to_add)
        ? object.request_headers_to_add.map((e: any) => HeaderValueOption.fromJSON(e))
        : undefined,
      request_headers_to_remove: globalThis.Array.isArray(object?.request_headers_to_remove)
        ? object.request_headers_to_remove.map((e: any) => globalThis.String(e))
        : undefined,
      expected_statuses: globalThis.Array.isArray(object?.expected_statuses)
        ? object.expected_statuses.map((e: any) => Int64Range.fromJSON(e))
        : undefined,
      retriable_statuses: globalThis.Array.isArray(object?.retriable_statuses)
        ? object.retriable_statuses.map((e: any) => Int64Range.fromJSON(e))
        : undefined,
      codec_client_type: isSet(object.codec_client_type)
        ? codecClientTypeFromJSON(object.codec_client_type)
        : undefined,
      service_name_matcher: isSet(object.service_name_matcher)
        ? StringMatcher.fromJSON(object.service_name_matcher)
        : undefined,
      method: isSet(object.method) ? requestMethodFromJSON(object.method) : undefined,
    };
  },

  toJSON(message: HealthCheck_HttpHealthCheck): unknown {
    const obj: any = {};
    if (message.host !== undefined) {
      obj.host = message.host;
    }
    if (message.path !== undefined) {
      obj.path = message.path;
    }
    if (message.send !== undefined) {
      obj.send = HealthCheck_Payload.toJSON(message.send);
    }
    if (message.receive?.length) {
      obj.receive = message.receive.map((e) => HealthCheck_Payload.toJSON(e));
    }
    if (message.response_buffer_size !== undefined) {
      obj.response_buffer_size = message.response_buffer_size;
    }
    if (message.request_headers_to_add?.length) {
      obj.request_headers_to_add = message.request_headers_to_add.map((e) => HeaderValueOption.toJSON(e));
    }
    if (message.request_headers_to_remove?.length) {
      obj.request_headers_to_remove = message.request_headers_to_remove;
    }
    if (message.expected_statuses?.length) {
      obj.expected_statuses = message.expected_statuses.map((e) => Int64Range.toJSON(e));
    }
    if (message.retriable_statuses?.length) {
      obj.retriable_statuses = message.retriable_statuses.map((e) => Int64Range.toJSON(e));
    }
    if (message.codec_client_type !== undefined) {
      obj.codec_client_type = codecClientTypeToJSON(message.codec_client_type);
    }
    if (message.service_name_matcher !== undefined) {
      obj.service_name_matcher = StringMatcher.toJSON(message.service_name_matcher);
    }
    if (message.method !== undefined) {
      obj.method = requestMethodToJSON(message.method);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheck_HttpHealthCheck>, I>>(base?: I): HealthCheck_HttpHealthCheck {
    return HealthCheck_HttpHealthCheck.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheck_HttpHealthCheck>, I>>(object: I): HealthCheck_HttpHealthCheck {
    const message = createBaseHealthCheck_HttpHealthCheck();
    message.host = object.host ?? undefined;
    message.path = object.path ?? undefined;
    message.send = (object.send !== undefined && object.send !== null)
      ? HealthCheck_Payload.fromPartial(object.send)
      : undefined;
    message.receive = object.receive?.map((e) => HealthCheck_Payload.fromPartial(e)) || undefined;
    message.response_buffer_size = object.response_buffer_size ?? undefined;
    message.request_headers_to_add = object.request_headers_to_add?.map((e) => HeaderValueOption.fromPartial(e)) ||
      undefined;
    message.request_headers_to_remove = object.request_headers_to_remove?.map((e) => e) || undefined;
    message.expected_statuses = object.expected_statuses?.map((e) => Int64Range.fromPartial(e)) || undefined;
    message.retriable_statuses = object.retriable_statuses?.map((e) => Int64Range.fromPartial(e)) || undefined;
    message.codec_client_type = object.codec_client_type ?? undefined;
    message.service_name_matcher = (object.service_name_matcher !== undefined && object.service_name_matcher !== null)
      ? StringMatcher.fromPartial(object.service_name_matcher)
      : undefined;
    message.method = object.method ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(HealthCheck_HttpHealthCheck.$type, HealthCheck_HttpHealthCheck);

function createBaseHealthCheck_TcpHealthCheck(): HealthCheck_TcpHealthCheck {
  return { $type: "envoy.config.core.v3.HealthCheck.TcpHealthCheck" };
}

export const HealthCheck_TcpHealthCheck: MessageFns<
  HealthCheck_TcpHealthCheck,
  "envoy.config.core.v3.HealthCheck.TcpHealthCheck"
> = {
  $type: "envoy.config.core.v3.HealthCheck.TcpHealthCheck" as const,

  encode(message: HealthCheck_TcpHealthCheck, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.send !== undefined) {
      HealthCheck_Payload.encode(message.send, writer.uint32(10).fork()).join();
    }
    if (message.receive !== undefined && message.receive.length !== 0) {
      for (const v of message.receive) {
        HealthCheck_Payload.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.proxy_protocol_config !== undefined) {
      ProxyProtocolConfig.encode(message.proxy_protocol_config, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheck_TcpHealthCheck {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheck_TcpHealthCheck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.send = HealthCheck_Payload.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.receive === undefined) {
            message.receive = [];
          }
          const el = HealthCheck_Payload.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.receive!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.proxy_protocol_config = ProxyProtocolConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheck_TcpHealthCheck {
    return {
      $type: HealthCheck_TcpHealthCheck.$type,
      send: isSet(object.send) ? HealthCheck_Payload.fromJSON(object.send) : undefined,
      receive: globalThis.Array.isArray(object?.receive)
        ? object.receive.map((e: any) => HealthCheck_Payload.fromJSON(e))
        : undefined,
      proxy_protocol_config: isSet(object.proxy_protocol_config)
        ? ProxyProtocolConfig.fromJSON(object.proxy_protocol_config)
        : undefined,
    };
  },

  toJSON(message: HealthCheck_TcpHealthCheck): unknown {
    const obj: any = {};
    if (message.send !== undefined) {
      obj.send = HealthCheck_Payload.toJSON(message.send);
    }
    if (message.receive?.length) {
      obj.receive = message.receive.map((e) => HealthCheck_Payload.toJSON(e));
    }
    if (message.proxy_protocol_config !== undefined) {
      obj.proxy_protocol_config = ProxyProtocolConfig.toJSON(message.proxy_protocol_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheck_TcpHealthCheck>, I>>(base?: I): HealthCheck_TcpHealthCheck {
    return HealthCheck_TcpHealthCheck.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheck_TcpHealthCheck>, I>>(object: I): HealthCheck_TcpHealthCheck {
    const message = createBaseHealthCheck_TcpHealthCheck();
    message.send = (object.send !== undefined && object.send !== null)
      ? HealthCheck_Payload.fromPartial(object.send)
      : undefined;
    message.receive = object.receive?.map((e) => HealthCheck_Payload.fromPartial(e)) || undefined;
    message.proxy_protocol_config =
      (object.proxy_protocol_config !== undefined && object.proxy_protocol_config !== null)
        ? ProxyProtocolConfig.fromPartial(object.proxy_protocol_config)
        : undefined;
    return message;
  },
};

messageTypeRegistry.set(HealthCheck_TcpHealthCheck.$type, HealthCheck_TcpHealthCheck);

function createBaseHealthCheck_RedisHealthCheck(): HealthCheck_RedisHealthCheck {
  return { $type: "envoy.config.core.v3.HealthCheck.RedisHealthCheck" };
}

export const HealthCheck_RedisHealthCheck: MessageFns<
  HealthCheck_RedisHealthCheck,
  "envoy.config.core.v3.HealthCheck.RedisHealthCheck"
> = {
  $type: "envoy.config.core.v3.HealthCheck.RedisHealthCheck" as const,

  encode(message: HealthCheck_RedisHealthCheck, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined && message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheck_RedisHealthCheck {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheck_RedisHealthCheck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheck_RedisHealthCheck {
    return {
      $type: HealthCheck_RedisHealthCheck.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : undefined,
    };
  },

  toJSON(message: HealthCheck_RedisHealthCheck): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheck_RedisHealthCheck>, I>>(base?: I): HealthCheck_RedisHealthCheck {
    return HealthCheck_RedisHealthCheck.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheck_RedisHealthCheck>, I>>(object: I): HealthCheck_RedisHealthCheck {
    const message = createBaseHealthCheck_RedisHealthCheck();
    message.key = object.key ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(HealthCheck_RedisHealthCheck.$type, HealthCheck_RedisHealthCheck);

function createBaseHealthCheck_GrpcHealthCheck(): HealthCheck_GrpcHealthCheck {
  return { $type: "envoy.config.core.v3.HealthCheck.GrpcHealthCheck" };
}

export const HealthCheck_GrpcHealthCheck: MessageFns<
  HealthCheck_GrpcHealthCheck,
  "envoy.config.core.v3.HealthCheck.GrpcHealthCheck"
> = {
  $type: "envoy.config.core.v3.HealthCheck.GrpcHealthCheck" as const,

  encode(message: HealthCheck_GrpcHealthCheck, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.service_name !== undefined && message.service_name !== "") {
      writer.uint32(10).string(message.service_name);
    }
    if (message.authority !== undefined && message.authority !== "") {
      writer.uint32(18).string(message.authority);
    }
    if (message.initial_metadata !== undefined && message.initial_metadata.length !== 0) {
      for (const v of message.initial_metadata) {
        HeaderValueOption.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheck_GrpcHealthCheck {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheck_GrpcHealthCheck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.service_name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.initial_metadata === undefined) {
            message.initial_metadata = [];
          }
          const el = HeaderValueOption.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.initial_metadata!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheck_GrpcHealthCheck {
    return {
      $type: HealthCheck_GrpcHealthCheck.$type,
      service_name: isSet(object.service_name) ? globalThis.String(object.service_name) : undefined,
      authority: isSet(object.authority) ? globalThis.String(object.authority) : undefined,
      initial_metadata: globalThis.Array.isArray(object?.initial_metadata)
        ? object.initial_metadata.map((e: any) => HeaderValueOption.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: HealthCheck_GrpcHealthCheck): unknown {
    const obj: any = {};
    if (message.service_name !== undefined) {
      obj.service_name = message.service_name;
    }
    if (message.authority !== undefined) {
      obj.authority = message.authority;
    }
    if (message.initial_metadata?.length) {
      obj.initial_metadata = message.initial_metadata.map((e) => HeaderValueOption.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheck_GrpcHealthCheck>, I>>(base?: I): HealthCheck_GrpcHealthCheck {
    return HealthCheck_GrpcHealthCheck.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheck_GrpcHealthCheck>, I>>(object: I): HealthCheck_GrpcHealthCheck {
    const message = createBaseHealthCheck_GrpcHealthCheck();
    message.service_name = object.service_name ?? undefined;
    message.authority = object.authority ?? undefined;
    message.initial_metadata = object.initial_metadata?.map((e) => HeaderValueOption.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(HealthCheck_GrpcHealthCheck.$type, HealthCheck_GrpcHealthCheck);

function createBaseHealthCheck_CustomHealthCheck(): HealthCheck_CustomHealthCheck {
  return { $type: "envoy.config.core.v3.HealthCheck.CustomHealthCheck", config_type: undefined };
}

export const HealthCheck_CustomHealthCheck: MessageFns<
  HealthCheck_CustomHealthCheck,
  "envoy.config.core.v3.HealthCheck.CustomHealthCheck"
> = {
  $type: "envoy.config.core.v3.HealthCheck.CustomHealthCheck" as const,

  encode(message: HealthCheck_CustomHealthCheck, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    switch (message.config_type?.$case) {
      case "typed_config":
        Any.encode(message.config_type.typed_config, writer.uint32(26).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheck_CustomHealthCheck {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheck_CustomHealthCheck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.config_type = { $case: "typed_config", typed_config: Any.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheck_CustomHealthCheck {
    return {
      $type: HealthCheck_CustomHealthCheck.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      config_type: isSet(object.typed_config)
        ? { $case: "typed_config", typed_config: Any.fromJSON(object.typed_config) }
        : undefined,
    };
  },

  toJSON(message: HealthCheck_CustomHealthCheck): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.config_type?.$case === "typed_config") {
      obj.typed_config = Any.toJSON(message.config_type.typed_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheck_CustomHealthCheck>, I>>(base?: I): HealthCheck_CustomHealthCheck {
    return HealthCheck_CustomHealthCheck.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheck_CustomHealthCheck>, I>>(
    object: I,
  ): HealthCheck_CustomHealthCheck {
    const message = createBaseHealthCheck_CustomHealthCheck();
    message.name = object.name ?? undefined;
    if (
      object.config_type?.$case === "typed_config" &&
      object.config_type?.typed_config !== undefined &&
      object.config_type?.typed_config !== null
    ) {
      message.config_type = { $case: "typed_config", typed_config: Any.fromPartial(object.config_type.typed_config) };
    }
    return message;
  },
};

messageTypeRegistry.set(HealthCheck_CustomHealthCheck.$type, HealthCheck_CustomHealthCheck);

function createBaseHealthCheck_TlsOptions(): HealthCheck_TlsOptions {
  return { $type: "envoy.config.core.v3.HealthCheck.TlsOptions" };
}

export const HealthCheck_TlsOptions: MessageFns<HealthCheck_TlsOptions, "envoy.config.core.v3.HealthCheck.TlsOptions"> =
  {
    $type: "envoy.config.core.v3.HealthCheck.TlsOptions" as const,

    encode(message: HealthCheck_TlsOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
      if (message.alpn_protocols !== undefined && message.alpn_protocols.length !== 0) {
        for (const v of message.alpn_protocols) {
          writer.uint32(10).string(v!);
        }
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): HealthCheck_TlsOptions {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseHealthCheck_TlsOptions();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            if (message.alpn_protocols === undefined) {
              message.alpn_protocols = [];
            }
            const el = reader.string();
            if (el !== undefined) {
              message.alpn_protocols!.push(el);
            }
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): HealthCheck_TlsOptions {
      return {
        $type: HealthCheck_TlsOptions.$type,
        alpn_protocols: globalThis.Array.isArray(object?.alpn_protocols)
          ? object.alpn_protocols.map((e: any) => globalThis.String(e))
          : undefined,
      };
    },

    toJSON(message: HealthCheck_TlsOptions): unknown {
      const obj: any = {};
      if (message.alpn_protocols?.length) {
        obj.alpn_protocols = message.alpn_protocols;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<HealthCheck_TlsOptions>, I>>(base?: I): HealthCheck_TlsOptions {
      return HealthCheck_TlsOptions.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<HealthCheck_TlsOptions>, I>>(object: I): HealthCheck_TlsOptions {
      const message = createBaseHealthCheck_TlsOptions();
      message.alpn_protocols = object.alpn_protocols?.map((e) => e) || undefined;
      return message;
    },
  };

messageTypeRegistry.set(HealthCheck_TlsOptions.$type, HealthCheck_TlsOptions);

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
