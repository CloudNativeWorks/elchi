// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/config/filter/network/kafka_broker/v2alpha1/kafka_broker.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { messageTypeRegistry } from "../../../../../../typeRegistry";

export const protobufPackage = "envoy.config.filter.network.kafka_broker.v2alpha1";

export interface KafkaBroker {
  $type: "envoy.config.filter.network.kafka_broker.v2alpha1.KafkaBroker";
  /** The prefix to use when emitting :ref:`statistics <config_network_filters_kafka_broker_stats>`. */
  stat_prefix?:
    | string
    | undefined;
  /**
   * Set to true if broker filter should attempt to serialize the received responses from the
   * upstream broker instead of passing received bytes as is.
   * Disabled by default.
   */
  force_response_rewrite?:
    | boolean
    | undefined;
  /**
   * Optional broker address rewrite specification.
   * Allows the broker filter to rewrite Kafka responses so that all connections established by
   * the Kafka clients point to Envoy.
   * This allows Kafka cluster not to configure its 'advertised.listeners' property
   * (as the necessary re-pointing will be done by this filter).
   * This collection of rules should cover all brokers in the cluster that is being proxied,
   * otherwise some nodes' addresses might leak to the downstream clients.
   */
  broker_address_rewrite_spec?:
    | //
    /** Broker address rewrite rules that match by broker ID. */
    { $case: "id_based_broker_address_rewrite_spec"; id_based_broker_address_rewrite_spec: IdBasedBrokerRewriteSpec }
    | undefined;
}

/** Collection of rules matching by broker ID. */
export interface IdBasedBrokerRewriteSpec {
  $type: "envoy.config.filter.network.kafka_broker.v2alpha1.IdBasedBrokerRewriteSpec";
  rules?: IdBasedBrokerRewriteRule[] | undefined;
}

/** Defines a rule to rewrite broker address data. */
export interface IdBasedBrokerRewriteRule {
  $type: "envoy.config.filter.network.kafka_broker.v2alpha1.IdBasedBrokerRewriteRule";
  /** Broker ID to match. */
  id?:
    | number
    | undefined;
  /**
   * The host value to use (resembling the host part of Kafka's advertised.listeners).
   * The value should point to the Envoy (not Kafka) listener, so that all client traffic goes
   * through Envoy.
   */
  host?:
    | string
    | undefined;
  /**
   * The port value to use (resembling the port part of Kafka's advertised.listeners).
   * The value should point to the Envoy (not Kafka) listener, so that all client traffic goes
   * through Envoy.
   */
  port?: number | undefined;
}

function createBaseKafkaBroker(): KafkaBroker {
  return {
    $type: "envoy.config.filter.network.kafka_broker.v2alpha1.KafkaBroker",
    broker_address_rewrite_spec: undefined,
  };
}

export const KafkaBroker: MessageFns<KafkaBroker, "envoy.config.filter.network.kafka_broker.v2alpha1.KafkaBroker"> = {
  $type: "envoy.config.filter.network.kafka_broker.v2alpha1.KafkaBroker" as const,

  encode(message: KafkaBroker, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stat_prefix !== undefined && message.stat_prefix !== "") {
      writer.uint32(10).string(message.stat_prefix);
    }
    if (message.force_response_rewrite !== undefined && message.force_response_rewrite !== false) {
      writer.uint32(16).bool(message.force_response_rewrite);
    }
    switch (message.broker_address_rewrite_spec?.$case) {
      case "id_based_broker_address_rewrite_spec":
        IdBasedBrokerRewriteSpec.encode(
          message.broker_address_rewrite_spec.id_based_broker_address_rewrite_spec,
          writer.uint32(26).fork(),
        ).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KafkaBroker {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKafkaBroker();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stat_prefix = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.force_response_rewrite = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.broker_address_rewrite_spec = {
            $case: "id_based_broker_address_rewrite_spec",
            id_based_broker_address_rewrite_spec: IdBasedBrokerRewriteSpec.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KafkaBroker {
    return {
      $type: KafkaBroker.$type,
      stat_prefix: isSet(object.stat_prefix) ? globalThis.String(object.stat_prefix) : undefined,
      force_response_rewrite: isSet(object.force_response_rewrite)
        ? globalThis.Boolean(object.force_response_rewrite)
        : undefined,
      broker_address_rewrite_spec: isSet(object.id_based_broker_address_rewrite_spec)
        ? {
          $case: "id_based_broker_address_rewrite_spec",
          id_based_broker_address_rewrite_spec: IdBasedBrokerRewriteSpec.fromJSON(
            object.id_based_broker_address_rewrite_spec,
          ),
        }
        : undefined,
    };
  },

  toJSON(message: KafkaBroker): unknown {
    const obj: any = {};
    if (message.stat_prefix !== undefined) {
      obj.stat_prefix = message.stat_prefix;
    }
    if (message.force_response_rewrite !== undefined) {
      obj.force_response_rewrite = message.force_response_rewrite;
    }
    if (message.broker_address_rewrite_spec?.$case === "id_based_broker_address_rewrite_spec") {
      obj.id_based_broker_address_rewrite_spec = IdBasedBrokerRewriteSpec.toJSON(
        message.broker_address_rewrite_spec.id_based_broker_address_rewrite_spec,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KafkaBroker>, I>>(base?: I): KafkaBroker {
    return KafkaBroker.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KafkaBroker>, I>>(object: I): KafkaBroker {
    const message = createBaseKafkaBroker();
    message.stat_prefix = object.stat_prefix ?? undefined;
    message.force_response_rewrite = object.force_response_rewrite ?? undefined;
    if (
      object.broker_address_rewrite_spec?.$case === "id_based_broker_address_rewrite_spec" &&
      object.broker_address_rewrite_spec?.id_based_broker_address_rewrite_spec !== undefined &&
      object.broker_address_rewrite_spec?.id_based_broker_address_rewrite_spec !== null
    ) {
      message.broker_address_rewrite_spec = {
        $case: "id_based_broker_address_rewrite_spec",
        id_based_broker_address_rewrite_spec: IdBasedBrokerRewriteSpec.fromPartial(
          object.broker_address_rewrite_spec.id_based_broker_address_rewrite_spec,
        ),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(KafkaBroker.$type, KafkaBroker);

function createBaseIdBasedBrokerRewriteSpec(): IdBasedBrokerRewriteSpec {
  return { $type: "envoy.config.filter.network.kafka_broker.v2alpha1.IdBasedBrokerRewriteSpec" };
}

export const IdBasedBrokerRewriteSpec: MessageFns<
  IdBasedBrokerRewriteSpec,
  "envoy.config.filter.network.kafka_broker.v2alpha1.IdBasedBrokerRewriteSpec"
> = {
  $type: "envoy.config.filter.network.kafka_broker.v2alpha1.IdBasedBrokerRewriteSpec" as const,

  encode(message: IdBasedBrokerRewriteSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rules !== undefined && message.rules.length !== 0) {
      for (const v of message.rules) {
        IdBasedBrokerRewriteRule.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IdBasedBrokerRewriteSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIdBasedBrokerRewriteSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.rules === undefined) {
            message.rules = [];
          }
          const el = IdBasedBrokerRewriteRule.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.rules!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IdBasedBrokerRewriteSpec {
    return {
      $type: IdBasedBrokerRewriteSpec.$type,
      rules: globalThis.Array.isArray(object?.rules)
        ? object.rules.map((e: any) => IdBasedBrokerRewriteRule.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: IdBasedBrokerRewriteSpec): unknown {
    const obj: any = {};
    if (message.rules?.length) {
      obj.rules = message.rules.map((e) => IdBasedBrokerRewriteRule.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IdBasedBrokerRewriteSpec>, I>>(base?: I): IdBasedBrokerRewriteSpec {
    return IdBasedBrokerRewriteSpec.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IdBasedBrokerRewriteSpec>, I>>(object: I): IdBasedBrokerRewriteSpec {
    const message = createBaseIdBasedBrokerRewriteSpec();
    message.rules = object.rules?.map((e) => IdBasedBrokerRewriteRule.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(IdBasedBrokerRewriteSpec.$type, IdBasedBrokerRewriteSpec);

function createBaseIdBasedBrokerRewriteRule(): IdBasedBrokerRewriteRule {
  return { $type: "envoy.config.filter.network.kafka_broker.v2alpha1.IdBasedBrokerRewriteRule" };
}

export const IdBasedBrokerRewriteRule: MessageFns<
  IdBasedBrokerRewriteRule,
  "envoy.config.filter.network.kafka_broker.v2alpha1.IdBasedBrokerRewriteRule"
> = {
  $type: "envoy.config.filter.network.kafka_broker.v2alpha1.IdBasedBrokerRewriteRule" as const,

  encode(message: IdBasedBrokerRewriteRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined && message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.host !== undefined && message.host !== "") {
      writer.uint32(18).string(message.host);
    }
    if (message.port !== undefined && message.port !== 0) {
      writer.uint32(24).uint32(message.port);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IdBasedBrokerRewriteRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIdBasedBrokerRewriteRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.host = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.port = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IdBasedBrokerRewriteRule {
    return {
      $type: IdBasedBrokerRewriteRule.$type,
      id: isSet(object.id) ? globalThis.Number(object.id) : undefined,
      host: isSet(object.host) ? globalThis.String(object.host) : undefined,
      port: isSet(object.port) ? globalThis.Number(object.port) : undefined,
    };
  },

  toJSON(message: IdBasedBrokerRewriteRule): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = Math.round(message.id);
    }
    if (message.host !== undefined) {
      obj.host = message.host;
    }
    if (message.port !== undefined) {
      obj.port = Math.round(message.port);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IdBasedBrokerRewriteRule>, I>>(base?: I): IdBasedBrokerRewriteRule {
    return IdBasedBrokerRewriteRule.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IdBasedBrokerRewriteRule>, I>>(object: I): IdBasedBrokerRewriteRule {
    const message = createBaseIdBasedBrokerRewriteRule();
    message.id = object.id ?? undefined;
    message.host = object.host ?? undefined;
    message.port = object.port ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(IdBasedBrokerRewriteRule.$type, IdBasedBrokerRewriteRule);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
