// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: opencensus/proto/trace/v1/trace.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "../../../../google/protobuf/timestamp";
import { BoolValue, UInt32Value } from "../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../typeRegistry";
import { Resource } from "../../resource/v1/resource";

export const protobufPackage = "opencensus.proto.trace.v1";

/**
 * A span represents a single operation within a trace. Spans can be
 * nested to form a trace tree. Spans may also be linked to other spans
 * from the same or different trace. And form graphs. Often, a trace
 * contains a root span that describes the end-to-end latency, and one
 * or more subspans for its sub-operations. A trace can also contain
 * multiple root spans, or none at all. Spans do not need to be
 * contiguous - there may be gaps or overlaps between spans in a trace.
 *
 * The next id is 17.
 * TODO(bdrutu): Add an example.
 */
export interface Span {
  $type: "opencensus.proto.trace.v1.Span";
  /**
   * A unique identifier for a trace. All spans from the same trace share
   * the same `trace_id`. The ID is a 16-byte array. An ID with all zeroes
   * is considered invalid.
   *
   * This field is semantically required. Receiver should generate new
   * random trace_id if empty or invalid trace_id was received.
   *
   * This field is required.
   */
  trace_id?:
    | Uint8Array
    | undefined;
  /**
   * A unique identifier for a span within a trace, assigned when the span
   * is created. The ID is an 8-byte array. An ID with all zeroes is considered
   * invalid.
   *
   * This field is semantically required. Receiver should generate new
   * random span_id if empty or invalid span_id was received.
   *
   * This field is required.
   */
  span_id?:
    | Uint8Array
    | undefined;
  /** The Tracestate on the span. */
  tracestate?:
    | Span_Tracestate
    | undefined;
  /**
   * The `span_id` of this span's parent span. If this is a root span, then this
   * field must be empty. The ID is an 8-byte array.
   */
  parent_span_id?:
    | Uint8Array
    | undefined;
  /**
   * A description of the span's operation.
   *
   * For example, the name can be a qualified method name or a file name
   * and a line number where the operation is called. A best practice is to use
   * the same display name at the same call point in an application.
   * This makes it easier to correlate spans in different traces.
   *
   * This field is semantically required to be set to non-empty string.
   * When null or empty string received - receiver may use string "name"
   * as a replacement. There might be smarted algorithms implemented by
   * receiver to fix the empty span name.
   *
   * This field is required.
   */
  name?:
    | TruncatableString
    | undefined;
  /**
   * Distinguishes between spans generated in a particular context. For example,
   * two spans with the same name may be distinguished using `CLIENT` (caller)
   * and `SERVER` (callee) to identify queueing latency associated with the span.
   */
  kind?:
    | Span_SpanKind
    | undefined;
  /**
   * The start time of the span. On the client side, this is the time kept by
   * the local machine where the span execution starts. On the server side, this
   * is the time when the server's application handler starts running.
   *
   * This field is semantically required. When not set on receive -
   * receiver should set it to the value of end_time field if it was
   * set. Or to the current time if neither was set. It is important to
   * keep end_time > start_time for consistency.
   *
   * This field is required.
   */
  start_time?:
    | Date
    | undefined;
  /**
   * The end time of the span. On the client side, this is the time kept by
   * the local machine where the span execution ends. On the server side, this
   * is the time when the server application handler stops running.
   *
   * This field is semantically required. When not set on receive -
   * receiver should set it to start_time value. It is important to
   * keep end_time > start_time for consistency.
   *
   * This field is required.
   */
  end_time?:
    | Date
    | undefined;
  /** A set of attributes on the span. */
  attributes?:
    | Span_Attributes
    | undefined;
  /** A stack trace captured at the start of the span. */
  stack_trace?:
    | StackTrace
    | undefined;
  /** The included time events. */
  time_events?:
    | Span_TimeEvents
    | undefined;
  /** The included links. */
  links?:
    | Span_Links
    | undefined;
  /**
   * An optional final status for this span. Semantically when Status
   * wasn't set it is means span ended without errors and assume
   * Status.Ok (code = 0).
   */
  status?:
    | Status
    | undefined;
  /**
   * An optional resource that is associated with this span. If not set, this span
   * should be part of a batch that does include the resource information, unless resource
   * information is unknown.
   */
  resource?:
    | Resource
    | undefined;
  /**
   * A highly recommended but not required flag that identifies when a
   * trace crosses a process boundary. True when the parent_span belongs
   * to the same process as the current span. This flag is most commonly
   * used to indicate the need to adjust time as clocks in different
   * processes may not be synchronized.
   */
  same_process_as_parent_span?:
    | boolean
    | undefined;
  /**
   * An optional number of child spans that were generated while this span
   * was active. If set, allows an implementation to detect missing child spans.
   */
  child_span_count?: number | undefined;
}

/**
 * Type of span. Can be used to specify additional relationships between spans
 * in addition to a parent/child relationship.
 */
export enum Span_SpanKind {
  /** SPAN_KIND_UNSPECIFIED - Unspecified. */
  SPAN_KIND_UNSPECIFIED = "SPAN_KIND_UNSPECIFIED",
  /**
   * SERVER - Indicates that the span covers server-side handling of an RPC or other
   * remote network request.
   */
  SERVER = "SERVER",
  /**
   * CLIENT - Indicates that the span covers the client-side wrapper around an RPC or
   * other remote request.
   */
  CLIENT = "CLIENT",
}

export function span_SpanKindFromJSON(object: any): Span_SpanKind {
  switch (object) {
    case 0:
    case "SPAN_KIND_UNSPECIFIED":
      return Span_SpanKind.SPAN_KIND_UNSPECIFIED;
    case 1:
    case "SERVER":
      return Span_SpanKind.SERVER;
    case 2:
    case "CLIENT":
      return Span_SpanKind.CLIENT;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Span_SpanKind");
  }
}

export function span_SpanKindToJSON(object: Span_SpanKind): string {
  switch (object) {
    case Span_SpanKind.SPAN_KIND_UNSPECIFIED:
      return "SPAN_KIND_UNSPECIFIED";
    case Span_SpanKind.SERVER:
      return "SERVER";
    case Span_SpanKind.CLIENT:
      return "CLIENT";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Span_SpanKind");
  }
}

export function span_SpanKindToNumber(object: Span_SpanKind): number {
  switch (object) {
    case Span_SpanKind.SPAN_KIND_UNSPECIFIED:
      return 0;
    case Span_SpanKind.SERVER:
      return 1;
    case Span_SpanKind.CLIENT:
      return 2;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Span_SpanKind");
  }
}

/**
 * This field conveys information about request position in multiple distributed tracing graphs.
 * It is a list of Tracestate.Entry with a maximum of 32 members in the list.
 *
 * See the https://github.com/w3c/distributed-tracing for more details about this field.
 */
export interface Span_Tracestate {
  $type: "opencensus.proto.trace.v1.Span.Tracestate";
  /** A list of entries that represent the Tracestate. */
  entries?: Span_Tracestate_Entry[] | undefined;
}

export interface Span_Tracestate_Entry {
  $type: "opencensus.proto.trace.v1.Span.Tracestate.Entry";
  /**
   * The key must begin with a lowercase letter, and can only contain
   * lowercase letters 'a'-'z', digits '0'-'9', underscores '_', dashes
   * '-', asterisks '*', and forward slashes '/'.
   */
  key?:
    | string
    | undefined;
  /**
   * The value is opaque string up to 256 characters printable ASCII
   * RFC0020 characters (i.e., the range 0x20 to 0x7E) except ',' and '='.
   * Note that this also excludes tabs, newlines, carriage returns, etc.
   */
  value?: string | undefined;
}

/** A set of attributes, each with a key and a value. */
export interface Span_Attributes {
  $type: "opencensus.proto.trace.v1.Span.Attributes";
  /**
   * The set of attributes. The value can be a string, an integer, a double
   * or the Boolean values `true` or `false`. Note, global attributes like
   * server name can be set as tags using resource API. Examples of attributes:
   *
   *     "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
   *     "/http/server_latency": 300
   *     "abc.com/myattribute": true
   *     "abc.com/score": 10.239
   */
  attribute_map?:
    | Map<string, AttributeValue>
    | undefined;
  /**
   * The number of attributes that were discarded. Attributes can be discarded
   * because their keys are too long or because there are too many attributes.
   * If this value is 0, then no attributes were dropped.
   */
  dropped_attributes_count?: number | undefined;
}

export interface Span_Attributes_AttributeMapEntry {
  $type: "opencensus.proto.trace.v1.Span.Attributes.AttributeMapEntry";
  key: string;
  value?: AttributeValue | undefined;
}

/** A time-stamped annotation or message event in the Span. */
export interface Span_TimeEvent {
  $type: "opencensus.proto.trace.v1.Span.TimeEvent";
  /** The time the event occurred. */
  time?:
    | Date
    | undefined;
  /**
   * A `TimeEvent` can contain either an `Annotation` object or a
   * `MessageEvent` object, but not both.
   */
  value?:
    | //
    /** A text annotation with a set of attributes. */
    { $case: "annotation"; annotation: Span_TimeEvent_Annotation }
    | //
    /** An event describing a message sent/received between Spans. */
    { $case: "message_event"; message_event: Span_TimeEvent_MessageEvent }
    | undefined;
}

/** A text annotation with a set of attributes. */
export interface Span_TimeEvent_Annotation {
  $type: "opencensus.proto.trace.v1.Span.TimeEvent.Annotation";
  /** A user-supplied message describing the event. */
  description?:
    | TruncatableString
    | undefined;
  /** A set of attributes on the annotation. */
  attributes?: Span_Attributes | undefined;
}

/** An event describing a message sent/received between Spans. */
export interface Span_TimeEvent_MessageEvent {
  $type: "opencensus.proto.trace.v1.Span.TimeEvent.MessageEvent";
  /**
   * The type of MessageEvent. Indicates whether the message was sent or
   * received.
   */
  type?:
    | Span_TimeEvent_MessageEvent_Type
    | undefined;
  /**
   * An identifier for the MessageEvent's message that can be used to match
   * SENT and RECEIVED MessageEvents. For example, this field could
   * represent a sequence ID for a streaming RPC. It is recommended to be
   * unique within a Span.
   */
  id?:
    | number
    | undefined;
  /** The number of uncompressed bytes sent or received. */
  uncompressed_size?:
    | number
    | undefined;
  /**
   * The number of compressed bytes sent or received. If zero, assumed to
   * be the same size as uncompressed.
   */
  compressed_size?: number | undefined;
}

/** Indicates whether the message was sent or received. */
export enum Span_TimeEvent_MessageEvent_Type {
  /** TYPE_UNSPECIFIED - Unknown event type. */
  TYPE_UNSPECIFIED = "TYPE_UNSPECIFIED",
  /** SENT - Indicates a sent message. */
  SENT = "SENT",
  /** RECEIVED - Indicates a received message. */
  RECEIVED = "RECEIVED",
}

export function span_TimeEvent_MessageEvent_TypeFromJSON(object: any): Span_TimeEvent_MessageEvent_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return Span_TimeEvent_MessageEvent_Type.TYPE_UNSPECIFIED;
    case 1:
    case "SENT":
      return Span_TimeEvent_MessageEvent_Type.SENT;
    case 2:
    case "RECEIVED":
      return Span_TimeEvent_MessageEvent_Type.RECEIVED;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Span_TimeEvent_MessageEvent_Type");
  }
}

export function span_TimeEvent_MessageEvent_TypeToJSON(object: Span_TimeEvent_MessageEvent_Type): string {
  switch (object) {
    case Span_TimeEvent_MessageEvent_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case Span_TimeEvent_MessageEvent_Type.SENT:
      return "SENT";
    case Span_TimeEvent_MessageEvent_Type.RECEIVED:
      return "RECEIVED";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Span_TimeEvent_MessageEvent_Type");
  }
}

export function span_TimeEvent_MessageEvent_TypeToNumber(object: Span_TimeEvent_MessageEvent_Type): number {
  switch (object) {
    case Span_TimeEvent_MessageEvent_Type.TYPE_UNSPECIFIED:
      return 0;
    case Span_TimeEvent_MessageEvent_Type.SENT:
      return 1;
    case Span_TimeEvent_MessageEvent_Type.RECEIVED:
      return 2;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Span_TimeEvent_MessageEvent_Type");
  }
}

/**
 * A collection of `TimeEvent`s. A `TimeEvent` is a time-stamped annotation
 * on the span, consisting of either user-supplied key-value pairs, or
 * details of a message sent/received between Spans.
 */
export interface Span_TimeEvents {
  $type: "opencensus.proto.trace.v1.Span.TimeEvents";
  /** A collection of `TimeEvent`s. */
  time_event?:
    | Span_TimeEvent[]
    | undefined;
  /**
   * The number of dropped annotations in all the included time events.
   * If the value is 0, then no annotations were dropped.
   */
  dropped_annotations_count?:
    | number
    | undefined;
  /**
   * The number of dropped message events in all the included time events.
   * If the value is 0, then no message events were dropped.
   */
  dropped_message_events_count?: number | undefined;
}

/**
 * A pointer from the current span to another span in the same trace or in a
 * different trace. For example, this can be used in batching operations,
 * where a single batch handler processes multiple requests from different
 * traces or when the handler receives a request from a different project.
 */
export interface Span_Link {
  $type: "opencensus.proto.trace.v1.Span.Link";
  /**
   * A unique identifier of a trace that this linked span is part of. The ID is a
   * 16-byte array.
   */
  trace_id?:
    | Uint8Array
    | undefined;
  /** A unique identifier for the linked span. The ID is an 8-byte array. */
  span_id?:
    | Uint8Array
    | undefined;
  /** The relationship of the current span relative to the linked span. */
  type?:
    | Span_Link_Type
    | undefined;
  /** A set of attributes on the link. */
  attributes?:
    | Span_Attributes
    | undefined;
  /** The Tracestate associated with the link. */
  tracestate?: Span_Tracestate | undefined;
}

/**
 * The relationship of the current span relative to the linked span: child,
 * parent, or unspecified.
 */
export enum Span_Link_Type {
  /**
   * TYPE_UNSPECIFIED - The relationship of the two spans is unknown, or known but other
   * than parent-child.
   */
  TYPE_UNSPECIFIED = "TYPE_UNSPECIFIED",
  /** CHILD_LINKED_SPAN - The linked span is a child of the current span. */
  CHILD_LINKED_SPAN = "CHILD_LINKED_SPAN",
  /** PARENT_LINKED_SPAN - The linked span is a parent of the current span. */
  PARENT_LINKED_SPAN = "PARENT_LINKED_SPAN",
}

export function span_Link_TypeFromJSON(object: any): Span_Link_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return Span_Link_Type.TYPE_UNSPECIFIED;
    case 1:
    case "CHILD_LINKED_SPAN":
      return Span_Link_Type.CHILD_LINKED_SPAN;
    case 2:
    case "PARENT_LINKED_SPAN":
      return Span_Link_Type.PARENT_LINKED_SPAN;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Span_Link_Type");
  }
}

export function span_Link_TypeToJSON(object: Span_Link_Type): string {
  switch (object) {
    case Span_Link_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case Span_Link_Type.CHILD_LINKED_SPAN:
      return "CHILD_LINKED_SPAN";
    case Span_Link_Type.PARENT_LINKED_SPAN:
      return "PARENT_LINKED_SPAN";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Span_Link_Type");
  }
}

export function span_Link_TypeToNumber(object: Span_Link_Type): number {
  switch (object) {
    case Span_Link_Type.TYPE_UNSPECIFIED:
      return 0;
    case Span_Link_Type.CHILD_LINKED_SPAN:
      return 1;
    case Span_Link_Type.PARENT_LINKED_SPAN:
      return 2;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Span_Link_Type");
  }
}

/**
 * A collection of links, which are references from this span to a span
 * in the same or different trace.
 */
export interface Span_Links {
  $type: "opencensus.proto.trace.v1.Span.Links";
  /** A collection of links. */
  link?:
    | Span_Link[]
    | undefined;
  /**
   * The number of dropped links after the maximum size was enforced. If
   * this value is 0, then no links were dropped.
   */
  dropped_links_count?: number | undefined;
}

/**
 * The `Status` type defines a logical error model that is suitable for different
 * programming environments, including REST APIs and RPC APIs. This proto's fields
 * are a subset of those of
 * [google.rpc.Status](https://github.com/googleapis/googleapis/blob/master/google/rpc/status.proto),
 * which is used by [gRPC](https://github.com/grpc).
 */
export interface Status {
  $type: "opencensus.proto.trace.v1.Status";
  /**
   * The status code. This is optional field. It is safe to assume 0 (OK)
   * when not set.
   */
  code?:
    | number
    | undefined;
  /** A developer-facing error message, which should be in English. */
  message?: string | undefined;
}

/** The value of an Attribute. */
export interface AttributeValue {
  $type: "opencensus.proto.trace.v1.AttributeValue";
  /** The type of the value. */
  value?:
    | //
    /** A string up to 256 bytes long. */
    { $case: "string_value"; string_value: TruncatableString }
    | //
    /** A 64-bit signed integer. */
    { $case: "int_value"; int_value: number }
    | //
    /** A Boolean value represented by `true` or `false`. */
    { $case: "bool_value"; bool_value: boolean }
    | //
    /** A double value. */
    { $case: "double_value"; double_value: number }
    | undefined;
}

/** The call stack which originated this span. */
export interface StackTrace {
  $type: "opencensus.proto.trace.v1.StackTrace";
  /** Stack frames in this stack trace. */
  stack_frames?:
    | StackTrace_StackFrames
    | undefined;
  /**
   * The hash ID is used to conserve network bandwidth for duplicate
   * stack traces within a single trace.
   *
   * Often multiple spans will have identical stack traces.
   * The first occurrence of a stack trace should contain both
   * `stack_frames` and a value in `stack_trace_hash_id`.
   *
   * Subsequent spans within the same request can refer
   * to that stack trace by setting only `stack_trace_hash_id`.
   *
   * TODO: describe how to deal with the case where stack_trace_hash_id is
   * zero because it was not set.
   */
  stack_trace_hash_id?: number | undefined;
}

/** A single stack frame in a stack trace. */
export interface StackTrace_StackFrame {
  $type: "opencensus.proto.trace.v1.StackTrace.StackFrame";
  /**
   * The fully-qualified name that uniquely identifies the function or
   * method that is active in this frame.
   */
  function_name?:
    | TruncatableString
    | undefined;
  /**
   * An un-mangled function name, if `function_name` is
   * [mangled](http://www.avabodh.com/cxxin/namemangling.html). The name can
   * be fully qualified.
   */
  original_function_name?:
    | TruncatableString
    | undefined;
  /** The name of the source file where the function call appears. */
  file_name?:
    | TruncatableString
    | undefined;
  /** The line number in `file_name` where the function call appears. */
  line_number?:
    | number
    | undefined;
  /**
   * The column number where the function call appears, if available.
   * This is important in JavaScript because of its anonymous functions.
   */
  column_number?:
    | number
    | undefined;
  /** The binary module from where the code was loaded. */
  load_module?:
    | Module
    | undefined;
  /** The version of the deployed source code. */
  source_version?: TruncatableString | undefined;
}

/** A collection of stack frames, which can be truncated. */
export interface StackTrace_StackFrames {
  $type: "opencensus.proto.trace.v1.StackTrace.StackFrames";
  /** Stack frames in this call stack. */
  frame?:
    | StackTrace_StackFrame[]
    | undefined;
  /**
   * The number of stack frames that were dropped because there
   * were too many stack frames.
   * If this value is 0, then no stack frames were dropped.
   */
  dropped_frames_count?: number | undefined;
}

/** A description of a binary module. */
export interface Module {
  $type: "opencensus.proto.trace.v1.Module";
  /**
   * TODO: document the meaning of this field.
   * For example: main binary, kernel modules, and dynamic libraries
   * such as libc.so, sharedlib.so.
   */
  module?:
    | TruncatableString
    | undefined;
  /**
   * A unique identifier for the module, usually a hash of its
   * contents.
   */
  build_id?: TruncatableString | undefined;
}

/** A string that might be shortened to a specified length. */
export interface TruncatableString {
  $type: "opencensus.proto.trace.v1.TruncatableString";
  /**
   * The shortened string. For example, if the original string was 500 bytes long and
   * the limit of the string was 128 bytes, then this value contains the first 128
   * bytes of the 500-byte string. Note that truncation always happens on a
   * character boundary, to ensure that a truncated string is still valid UTF-8.
   * Because it may contain multi-byte characters, the size of the truncated string
   * may be less than the truncation limit.
   */
  value?:
    | string
    | undefined;
  /**
   * The number of bytes removed from the original string. If this
   * value is 0, then the string was not shortened.
   */
  truncated_byte_count?: number | undefined;
}

function createBaseSpan(): Span {
  return { $type: "opencensus.proto.trace.v1.Span" };
}

export const Span: MessageFns<Span, "opencensus.proto.trace.v1.Span"> = {
  $type: "opencensus.proto.trace.v1.Span" as const,

  encode(message: Span, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trace_id !== undefined && message.trace_id.length !== 0) {
      writer.uint32(10).bytes(message.trace_id);
    }
    if (message.span_id !== undefined && message.span_id.length !== 0) {
      writer.uint32(18).bytes(message.span_id);
    }
    if (message.tracestate !== undefined) {
      Span_Tracestate.encode(message.tracestate, writer.uint32(122).fork()).join();
    }
    if (message.parent_span_id !== undefined && message.parent_span_id.length !== 0) {
      writer.uint32(26).bytes(message.parent_span_id);
    }
    if (message.name !== undefined) {
      TruncatableString.encode(message.name, writer.uint32(34).fork()).join();
    }
    if (message.kind !== undefined && message.kind !== Span_SpanKind.SPAN_KIND_UNSPECIFIED) {
      writer.uint32(112).int32(span_SpanKindToNumber(message.kind));
    }
    if (message.start_time !== undefined) {
      Timestamp.encode(toTimestamp(message.start_time), writer.uint32(42).fork()).join();
    }
    if (message.end_time !== undefined) {
      Timestamp.encode(toTimestamp(message.end_time), writer.uint32(50).fork()).join();
    }
    if (message.attributes !== undefined) {
      Span_Attributes.encode(message.attributes, writer.uint32(58).fork()).join();
    }
    if (message.stack_trace !== undefined) {
      StackTrace.encode(message.stack_trace, writer.uint32(66).fork()).join();
    }
    if (message.time_events !== undefined) {
      Span_TimeEvents.encode(message.time_events, writer.uint32(74).fork()).join();
    }
    if (message.links !== undefined) {
      Span_Links.encode(message.links, writer.uint32(82).fork()).join();
    }
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(90).fork()).join();
    }
    if (message.resource !== undefined) {
      Resource.encode(message.resource, writer.uint32(130).fork()).join();
    }
    if (message.same_process_as_parent_span !== undefined) {
      BoolValue.encode(
        { $type: "google.protobuf.BoolValue", value: message.same_process_as_parent_span! },
        writer.uint32(98).fork(),
      ).join();
    }
    if (message.child_span_count !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.child_span_count! },
        writer.uint32(106).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Span {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpan();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trace_id = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.span_id = reader.bytes();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.tracestate = Span_Tracestate.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.parent_span_id = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = TruncatableString.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.kind = span_SpanKindFromJSON(reader.int32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.start_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.end_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.attributes = Span_Attributes.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.stack_trace = StackTrace.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.time_events = Span_TimeEvents.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.links = Span_Links.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.resource = Resource.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.same_process_as_parent_span = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.child_span_count = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Span {
    return {
      $type: Span.$type,
      trace_id: isSet(object.trace_id) ? bytesFromBase64(object.trace_id) : undefined,
      span_id: isSet(object.span_id) ? bytesFromBase64(object.span_id) : undefined,
      tracestate: isSet(object.tracestate) ? Span_Tracestate.fromJSON(object.tracestate) : undefined,
      parent_span_id: isSet(object.parent_span_id) ? bytesFromBase64(object.parent_span_id) : undefined,
      name: isSet(object.name) ? TruncatableString.fromJSON(object.name) : undefined,
      kind: isSet(object.kind) ? span_SpanKindFromJSON(object.kind) : undefined,
      start_time: isSet(object.start_time) ? fromJsonTimestamp(object.start_time) : undefined,
      end_time: isSet(object.end_time) ? fromJsonTimestamp(object.end_time) : undefined,
      attributes: isSet(object.attributes) ? Span_Attributes.fromJSON(object.attributes) : undefined,
      stack_trace: isSet(object.stack_trace) ? StackTrace.fromJSON(object.stack_trace) : undefined,
      time_events: isSet(object.time_events) ? Span_TimeEvents.fromJSON(object.time_events) : undefined,
      links: isSet(object.links) ? Span_Links.fromJSON(object.links) : undefined,
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      resource: isSet(object.resource) ? Resource.fromJSON(object.resource) : undefined,
      same_process_as_parent_span: isSet(object.same_process_as_parent_span)
        ? Boolean(object.same_process_as_parent_span)
        : undefined,
      child_span_count: isSet(object.child_span_count) ? Number(object.child_span_count) : undefined,
    };
  },

  toJSON(message: Span): unknown {
    const obj: any = {};
    if (message.trace_id !== undefined) {
      obj.trace_id = base64FromBytes(message.trace_id);
    }
    if (message.span_id !== undefined) {
      obj.span_id = base64FromBytes(message.span_id);
    }
    if (message.tracestate !== undefined) {
      obj.tracestate = Span_Tracestate.toJSON(message.tracestate);
    }
    if (message.parent_span_id !== undefined) {
      obj.parent_span_id = base64FromBytes(message.parent_span_id);
    }
    if (message.name !== undefined) {
      obj.name = TruncatableString.toJSON(message.name);
    }
    if (message.kind !== undefined) {
      obj.kind = span_SpanKindToJSON(message.kind);
    }
    if (message.start_time !== undefined) {
      obj.start_time = message.start_time.toISOString();
    }
    if (message.end_time !== undefined) {
      obj.end_time = message.end_time.toISOString();
    }
    if (message.attributes !== undefined) {
      obj.attributes = Span_Attributes.toJSON(message.attributes);
    }
    if (message.stack_trace !== undefined) {
      obj.stack_trace = StackTrace.toJSON(message.stack_trace);
    }
    if (message.time_events !== undefined) {
      obj.time_events = Span_TimeEvents.toJSON(message.time_events);
    }
    if (message.links !== undefined) {
      obj.links = Span_Links.toJSON(message.links);
    }
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.resource !== undefined) {
      obj.resource = Resource.toJSON(message.resource);
    }
    if (message.same_process_as_parent_span !== undefined) {
      obj.same_process_as_parent_span = message.same_process_as_parent_span;
    }
    if (message.child_span_count !== undefined) {
      obj.child_span_count = message.child_span_count;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Span>, I>>(base?: I): Span {
    return Span.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Span>, I>>(object: I): Span {
    const message = createBaseSpan();
    message.trace_id = object.trace_id ?? undefined;
    message.span_id = object.span_id ?? undefined;
    message.tracestate = (object.tracestate !== undefined && object.tracestate !== null)
      ? Span_Tracestate.fromPartial(object.tracestate)
      : undefined;
    message.parent_span_id = object.parent_span_id ?? undefined;
    message.name = (object.name !== undefined && object.name !== null)
      ? TruncatableString.fromPartial(object.name)
      : undefined;
    message.kind = object.kind ?? undefined;
    message.start_time = object.start_time ?? undefined;
    message.end_time = object.end_time ?? undefined;
    message.attributes = (object.attributes !== undefined && object.attributes !== null)
      ? Span_Attributes.fromPartial(object.attributes)
      : undefined;
    message.stack_trace = (object.stack_trace !== undefined && object.stack_trace !== null)
      ? StackTrace.fromPartial(object.stack_trace)
      : undefined;
    message.time_events = (object.time_events !== undefined && object.time_events !== null)
      ? Span_TimeEvents.fromPartial(object.time_events)
      : undefined;
    message.links = (object.links !== undefined && object.links !== null)
      ? Span_Links.fromPartial(object.links)
      : undefined;
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.resource = (object.resource !== undefined && object.resource !== null)
      ? Resource.fromPartial(object.resource)
      : undefined;
    message.same_process_as_parent_span = object.same_process_as_parent_span ?? undefined;
    message.child_span_count = object.child_span_count ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Span.$type, Span);

function createBaseSpan_Tracestate(): Span_Tracestate {
  return { $type: "opencensus.proto.trace.v1.Span.Tracestate" };
}

export const Span_Tracestate: MessageFns<Span_Tracestate, "opencensus.proto.trace.v1.Span.Tracestate"> = {
  $type: "opencensus.proto.trace.v1.Span.Tracestate" as const,

  encode(message: Span_Tracestate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entries !== undefined && message.entries.length !== 0) {
      for (const v of message.entries) {
        Span_Tracestate_Entry.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Span_Tracestate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpan_Tracestate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.entries === undefined) {
            message.entries = [];
          }
          const el = Span_Tracestate_Entry.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.entries!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Span_Tracestate {
    return {
      $type: Span_Tracestate.$type,
      entries: globalThis.Array.isArray(object?.entries)
        ? object.entries.map((e: any) => Span_Tracestate_Entry.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: Span_Tracestate): unknown {
    const obj: any = {};
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => Span_Tracestate_Entry.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Span_Tracestate>, I>>(base?: I): Span_Tracestate {
    return Span_Tracestate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Span_Tracestate>, I>>(object: I): Span_Tracestate {
    const message = createBaseSpan_Tracestate();
    message.entries = object.entries?.map((e) => Span_Tracestate_Entry.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(Span_Tracestate.$type, Span_Tracestate);

function createBaseSpan_Tracestate_Entry(): Span_Tracestate_Entry {
  return { $type: "opencensus.proto.trace.v1.Span.Tracestate.Entry" };
}

export const Span_Tracestate_Entry: MessageFns<
  Span_Tracestate_Entry,
  "opencensus.proto.trace.v1.Span.Tracestate.Entry"
> = {
  $type: "opencensus.proto.trace.v1.Span.Tracestate.Entry" as const,

  encode(message: Span_Tracestate_Entry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined && message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined && message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Span_Tracestate_Entry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpan_Tracestate_Entry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Span_Tracestate_Entry {
    return {
      $type: Span_Tracestate_Entry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : undefined,
      value: isSet(object.value) ? globalThis.String(object.value) : undefined,
    };
  },

  toJSON(message: Span_Tracestate_Entry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Span_Tracestate_Entry>, I>>(base?: I): Span_Tracestate_Entry {
    return Span_Tracestate_Entry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Span_Tracestate_Entry>, I>>(object: I): Span_Tracestate_Entry {
    const message = createBaseSpan_Tracestate_Entry();
    message.key = object.key ?? undefined;
    message.value = object.value ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Span_Tracestate_Entry.$type, Span_Tracestate_Entry);

function createBaseSpan_Attributes(): Span_Attributes {
  return { $type: "opencensus.proto.trace.v1.Span.Attributes" };
}

export const Span_Attributes: MessageFns<Span_Attributes, "opencensus.proto.trace.v1.Span.Attributes"> = {
  $type: "opencensus.proto.trace.v1.Span.Attributes" as const,

  encode(message: Span_Attributes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    (message.attribute_map || new Map()).forEach((value, key) => {
      Span_Attributes_AttributeMapEntry.encode({
        $type: "opencensus.proto.trace.v1.Span.Attributes.AttributeMapEntry",
        key: key as any,
        value,
      }, writer.uint32(10).fork()).join();
    });
    if (message.dropped_attributes_count !== undefined && message.dropped_attributes_count !== 0) {
      writer.uint32(16).int32(message.dropped_attributes_count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Span_Attributes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpan_Attributes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = Span_Attributes_AttributeMapEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            if (message.attribute_map === undefined) {
              message.attribute_map = new Map();
            }
            message.attribute_map!.set(entry1.key, entry1.value);
          }
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.dropped_attributes_count = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Span_Attributes {
    return {
      $type: Span_Attributes.$type,
      attribute_map: isObject(object.attribute_map)
        ? Object.entries(object.attribute_map).reduce<Map<string, AttributeValue>>((acc, [key, value]) => {
          acc.set(key, AttributeValue.fromJSON(value));
          return acc;
        }, new Map())
        : undefined,
      dropped_attributes_count: isSet(object.dropped_attributes_count)
        ? globalThis.Number(object.dropped_attributes_count)
        : undefined,
    };
  },

  toJSON(message: Span_Attributes): unknown {
    const obj: any = {};
    if (message.attribute_map?.size) {
      obj.attribute_map = {};
      message.attribute_map.forEach((v, k) => {
        obj.attribute_map[k] = AttributeValue.toJSON(v);
      });
    }
    if (message.dropped_attributes_count !== undefined) {
      obj.dropped_attributes_count = Math.round(message.dropped_attributes_count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Span_Attributes>, I>>(base?: I): Span_Attributes {
    return Span_Attributes.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Span_Attributes>, I>>(object: I): Span_Attributes {
    const message = createBaseSpan_Attributes();
    message.attribute_map = (object.attribute_map === undefined || object.attribute_map === null) ? undefined : (() => {
      const m = new Map();
      (object.attribute_map as Map<string, AttributeValue> ?? new Map()).forEach((value, key) => {
        if (value !== undefined) {
          m.set(key, AttributeValue.fromPartial(value));
        }
      });
      return m;
    })();
    message.dropped_attributes_count = object.dropped_attributes_count ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Span_Attributes.$type, Span_Attributes);

function createBaseSpan_Attributes_AttributeMapEntry(): Span_Attributes_AttributeMapEntry {
  return { $type: "opencensus.proto.trace.v1.Span.Attributes.AttributeMapEntry", key: "" };
}

export const Span_Attributes_AttributeMapEntry: MessageFns<
  Span_Attributes_AttributeMapEntry,
  "opencensus.proto.trace.v1.Span.Attributes.AttributeMapEntry"
> = {
  $type: "opencensus.proto.trace.v1.Span.Attributes.AttributeMapEntry" as const,

  encode(message: Span_Attributes_AttributeMapEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AttributeValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Span_Attributes_AttributeMapEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpan_Attributes_AttributeMapEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = AttributeValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Span_Attributes_AttributeMapEntry {
    return {
      $type: Span_Attributes_AttributeMapEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AttributeValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Span_Attributes_AttributeMapEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AttributeValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Span_Attributes_AttributeMapEntry>, I>>(
    base?: I,
  ): Span_Attributes_AttributeMapEntry {
    return Span_Attributes_AttributeMapEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Span_Attributes_AttributeMapEntry>, I>>(
    object: I,
  ): Span_Attributes_AttributeMapEntry {
    const message = createBaseSpan_Attributes_AttributeMapEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AttributeValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Span_Attributes_AttributeMapEntry.$type, Span_Attributes_AttributeMapEntry);

function createBaseSpan_TimeEvent(): Span_TimeEvent {
  return { $type: "opencensus.proto.trace.v1.Span.TimeEvent", value: undefined };
}

export const Span_TimeEvent: MessageFns<Span_TimeEvent, "opencensus.proto.trace.v1.Span.TimeEvent"> = {
  $type: "opencensus.proto.trace.v1.Span.TimeEvent" as const,

  encode(message: Span_TimeEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.time !== undefined) {
      Timestamp.encode(toTimestamp(message.time), writer.uint32(10).fork()).join();
    }
    switch (message.value?.$case) {
      case "annotation":
        Span_TimeEvent_Annotation.encode(message.value.annotation, writer.uint32(18).fork()).join();
        break;
      case "message_event":
        Span_TimeEvent_MessageEvent.encode(message.value.message_event, writer.uint32(26).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Span_TimeEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpan_TimeEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = {
            $case: "annotation",
            annotation: Span_TimeEvent_Annotation.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.value = {
            $case: "message_event",
            message_event: Span_TimeEvent_MessageEvent.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Span_TimeEvent {
    return {
      $type: Span_TimeEvent.$type,
      time: isSet(object.time) ? fromJsonTimestamp(object.time) : undefined,
      value: isSet(object.annotation)
        ? { $case: "annotation", annotation: Span_TimeEvent_Annotation.fromJSON(object.annotation) }
        : isSet(object.message_event)
        ? { $case: "message_event", message_event: Span_TimeEvent_MessageEvent.fromJSON(object.message_event) }
        : undefined,
    };
  },

  toJSON(message: Span_TimeEvent): unknown {
    const obj: any = {};
    if (message.time !== undefined) {
      obj.time = message.time.toISOString();
    }
    if (message.value?.$case === "annotation") {
      obj.annotation = Span_TimeEvent_Annotation.toJSON(message.value.annotation);
    }
    if (message.value?.$case === "message_event") {
      obj.message_event = Span_TimeEvent_MessageEvent.toJSON(message.value.message_event);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Span_TimeEvent>, I>>(base?: I): Span_TimeEvent {
    return Span_TimeEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Span_TimeEvent>, I>>(object: I): Span_TimeEvent {
    const message = createBaseSpan_TimeEvent();
    message.time = object.time ?? undefined;
    if (
      object.value?.$case === "annotation" &&
      object.value?.annotation !== undefined &&
      object.value?.annotation !== null
    ) {
      message.value = {
        $case: "annotation",
        annotation: Span_TimeEvent_Annotation.fromPartial(object.value.annotation),
      };
    }
    if (
      object.value?.$case === "message_event" &&
      object.value?.message_event !== undefined &&
      object.value?.message_event !== null
    ) {
      message.value = {
        $case: "message_event",
        message_event: Span_TimeEvent_MessageEvent.fromPartial(object.value.message_event),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(Span_TimeEvent.$type, Span_TimeEvent);

function createBaseSpan_TimeEvent_Annotation(): Span_TimeEvent_Annotation {
  return { $type: "opencensus.proto.trace.v1.Span.TimeEvent.Annotation" };
}

export const Span_TimeEvent_Annotation: MessageFns<
  Span_TimeEvent_Annotation,
  "opencensus.proto.trace.v1.Span.TimeEvent.Annotation"
> = {
  $type: "opencensus.proto.trace.v1.Span.TimeEvent.Annotation" as const,

  encode(message: Span_TimeEvent_Annotation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.description !== undefined) {
      TruncatableString.encode(message.description, writer.uint32(10).fork()).join();
    }
    if (message.attributes !== undefined) {
      Span_Attributes.encode(message.attributes, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Span_TimeEvent_Annotation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpan_TimeEvent_Annotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.description = TruncatableString.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.attributes = Span_Attributes.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Span_TimeEvent_Annotation {
    return {
      $type: Span_TimeEvent_Annotation.$type,
      description: isSet(object.description) ? TruncatableString.fromJSON(object.description) : undefined,
      attributes: isSet(object.attributes) ? Span_Attributes.fromJSON(object.attributes) : undefined,
    };
  },

  toJSON(message: Span_TimeEvent_Annotation): unknown {
    const obj: any = {};
    if (message.description !== undefined) {
      obj.description = TruncatableString.toJSON(message.description);
    }
    if (message.attributes !== undefined) {
      obj.attributes = Span_Attributes.toJSON(message.attributes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Span_TimeEvent_Annotation>, I>>(base?: I): Span_TimeEvent_Annotation {
    return Span_TimeEvent_Annotation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Span_TimeEvent_Annotation>, I>>(object: I): Span_TimeEvent_Annotation {
    const message = createBaseSpan_TimeEvent_Annotation();
    message.description = (object.description !== undefined && object.description !== null)
      ? TruncatableString.fromPartial(object.description)
      : undefined;
    message.attributes = (object.attributes !== undefined && object.attributes !== null)
      ? Span_Attributes.fromPartial(object.attributes)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Span_TimeEvent_Annotation.$type, Span_TimeEvent_Annotation);

function createBaseSpan_TimeEvent_MessageEvent(): Span_TimeEvent_MessageEvent {
  return { $type: "opencensus.proto.trace.v1.Span.TimeEvent.MessageEvent" };
}

export const Span_TimeEvent_MessageEvent: MessageFns<
  Span_TimeEvent_MessageEvent,
  "opencensus.proto.trace.v1.Span.TimeEvent.MessageEvent"
> = {
  $type: "opencensus.proto.trace.v1.Span.TimeEvent.MessageEvent" as const,

  encode(message: Span_TimeEvent_MessageEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== undefined && message.type !== Span_TimeEvent_MessageEvent_Type.TYPE_UNSPECIFIED) {
      writer.uint32(8).int32(span_TimeEvent_MessageEvent_TypeToNumber(message.type));
    }
    if (message.id !== undefined && message.id !== 0) {
      writer.uint32(16).uint64(message.id);
    }
    if (message.uncompressed_size !== undefined && message.uncompressed_size !== 0) {
      writer.uint32(24).uint64(message.uncompressed_size);
    }
    if (message.compressed_size !== undefined && message.compressed_size !== 0) {
      writer.uint32(32).uint64(message.compressed_size);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Span_TimeEvent_MessageEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpan_TimeEvent_MessageEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = span_TimeEvent_MessageEvent_TypeFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.uncompressed_size = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.compressed_size = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Span_TimeEvent_MessageEvent {
    return {
      $type: Span_TimeEvent_MessageEvent.$type,
      type: isSet(object.type) ? span_TimeEvent_MessageEvent_TypeFromJSON(object.type) : undefined,
      id: isSet(object.id) ? globalThis.Number(object.id) : undefined,
      uncompressed_size: isSet(object.uncompressed_size) ? globalThis.Number(object.uncompressed_size) : undefined,
      compressed_size: isSet(object.compressed_size) ? globalThis.Number(object.compressed_size) : undefined,
    };
  },

  toJSON(message: Span_TimeEvent_MessageEvent): unknown {
    const obj: any = {};
    if (message.type !== undefined) {
      obj.type = span_TimeEvent_MessageEvent_TypeToJSON(message.type);
    }
    if (message.id !== undefined) {
      obj.id = Math.round(message.id);
    }
    if (message.uncompressed_size !== undefined) {
      obj.uncompressed_size = Math.round(message.uncompressed_size);
    }
    if (message.compressed_size !== undefined) {
      obj.compressed_size = Math.round(message.compressed_size);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Span_TimeEvent_MessageEvent>, I>>(base?: I): Span_TimeEvent_MessageEvent {
    return Span_TimeEvent_MessageEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Span_TimeEvent_MessageEvent>, I>>(object: I): Span_TimeEvent_MessageEvent {
    const message = createBaseSpan_TimeEvent_MessageEvent();
    message.type = object.type ?? undefined;
    message.id = object.id ?? undefined;
    message.uncompressed_size = object.uncompressed_size ?? undefined;
    message.compressed_size = object.compressed_size ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Span_TimeEvent_MessageEvent.$type, Span_TimeEvent_MessageEvent);

function createBaseSpan_TimeEvents(): Span_TimeEvents {
  return { $type: "opencensus.proto.trace.v1.Span.TimeEvents" };
}

export const Span_TimeEvents: MessageFns<Span_TimeEvents, "opencensus.proto.trace.v1.Span.TimeEvents"> = {
  $type: "opencensus.proto.trace.v1.Span.TimeEvents" as const,

  encode(message: Span_TimeEvents, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.time_event !== undefined && message.time_event.length !== 0) {
      for (const v of message.time_event) {
        Span_TimeEvent.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    if (message.dropped_annotations_count !== undefined && message.dropped_annotations_count !== 0) {
      writer.uint32(16).int32(message.dropped_annotations_count);
    }
    if (message.dropped_message_events_count !== undefined && message.dropped_message_events_count !== 0) {
      writer.uint32(24).int32(message.dropped_message_events_count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Span_TimeEvents {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpan_TimeEvents();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.time_event === undefined) {
            message.time_event = [];
          }
          const el = Span_TimeEvent.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.time_event!.push(el);
          }
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.dropped_annotations_count = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.dropped_message_events_count = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Span_TimeEvents {
    return {
      $type: Span_TimeEvents.$type,
      time_event: globalThis.Array.isArray(object?.time_event)
        ? object.time_event.map((e: any) => Span_TimeEvent.fromJSON(e))
        : undefined,
      dropped_annotations_count: isSet(object.dropped_annotations_count)
        ? globalThis.Number(object.dropped_annotations_count)
        : undefined,
      dropped_message_events_count: isSet(object.dropped_message_events_count)
        ? globalThis.Number(object.dropped_message_events_count)
        : undefined,
    };
  },

  toJSON(message: Span_TimeEvents): unknown {
    const obj: any = {};
    if (message.time_event?.length) {
      obj.time_event = message.time_event.map((e) => Span_TimeEvent.toJSON(e));
    }
    if (message.dropped_annotations_count !== undefined) {
      obj.dropped_annotations_count = Math.round(message.dropped_annotations_count);
    }
    if (message.dropped_message_events_count !== undefined) {
      obj.dropped_message_events_count = Math.round(message.dropped_message_events_count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Span_TimeEvents>, I>>(base?: I): Span_TimeEvents {
    return Span_TimeEvents.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Span_TimeEvents>, I>>(object: I): Span_TimeEvents {
    const message = createBaseSpan_TimeEvents();
    message.time_event = object.time_event?.map((e) => Span_TimeEvent.fromPartial(e)) || undefined;
    message.dropped_annotations_count = object.dropped_annotations_count ?? undefined;
    message.dropped_message_events_count = object.dropped_message_events_count ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Span_TimeEvents.$type, Span_TimeEvents);

function createBaseSpan_Link(): Span_Link {
  return { $type: "opencensus.proto.trace.v1.Span.Link" };
}

export const Span_Link: MessageFns<Span_Link, "opencensus.proto.trace.v1.Span.Link"> = {
  $type: "opencensus.proto.trace.v1.Span.Link" as const,

  encode(message: Span_Link, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trace_id !== undefined && message.trace_id.length !== 0) {
      writer.uint32(10).bytes(message.trace_id);
    }
    if (message.span_id !== undefined && message.span_id.length !== 0) {
      writer.uint32(18).bytes(message.span_id);
    }
    if (message.type !== undefined && message.type !== Span_Link_Type.TYPE_UNSPECIFIED) {
      writer.uint32(24).int32(span_Link_TypeToNumber(message.type));
    }
    if (message.attributes !== undefined) {
      Span_Attributes.encode(message.attributes, writer.uint32(34).fork()).join();
    }
    if (message.tracestate !== undefined) {
      Span_Tracestate.encode(message.tracestate, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Span_Link {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpan_Link();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trace_id = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.span_id = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = span_Link_TypeFromJSON(reader.int32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.attributes = Span_Attributes.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.tracestate = Span_Tracestate.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Span_Link {
    return {
      $type: Span_Link.$type,
      trace_id: isSet(object.trace_id) ? bytesFromBase64(object.trace_id) : undefined,
      span_id: isSet(object.span_id) ? bytesFromBase64(object.span_id) : undefined,
      type: isSet(object.type) ? span_Link_TypeFromJSON(object.type) : undefined,
      attributes: isSet(object.attributes) ? Span_Attributes.fromJSON(object.attributes) : undefined,
      tracestate: isSet(object.tracestate) ? Span_Tracestate.fromJSON(object.tracestate) : undefined,
    };
  },

  toJSON(message: Span_Link): unknown {
    const obj: any = {};
    if (message.trace_id !== undefined) {
      obj.trace_id = base64FromBytes(message.trace_id);
    }
    if (message.span_id !== undefined) {
      obj.span_id = base64FromBytes(message.span_id);
    }
    if (message.type !== undefined) {
      obj.type = span_Link_TypeToJSON(message.type);
    }
    if (message.attributes !== undefined) {
      obj.attributes = Span_Attributes.toJSON(message.attributes);
    }
    if (message.tracestate !== undefined) {
      obj.tracestate = Span_Tracestate.toJSON(message.tracestate);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Span_Link>, I>>(base?: I): Span_Link {
    return Span_Link.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Span_Link>, I>>(object: I): Span_Link {
    const message = createBaseSpan_Link();
    message.trace_id = object.trace_id ?? undefined;
    message.span_id = object.span_id ?? undefined;
    message.type = object.type ?? undefined;
    message.attributes = (object.attributes !== undefined && object.attributes !== null)
      ? Span_Attributes.fromPartial(object.attributes)
      : undefined;
    message.tracestate = (object.tracestate !== undefined && object.tracestate !== null)
      ? Span_Tracestate.fromPartial(object.tracestate)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Span_Link.$type, Span_Link);

function createBaseSpan_Links(): Span_Links {
  return { $type: "opencensus.proto.trace.v1.Span.Links" };
}

export const Span_Links: MessageFns<Span_Links, "opencensus.proto.trace.v1.Span.Links"> = {
  $type: "opencensus.proto.trace.v1.Span.Links" as const,

  encode(message: Span_Links, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.link !== undefined && message.link.length !== 0) {
      for (const v of message.link) {
        Span_Link.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    if (message.dropped_links_count !== undefined && message.dropped_links_count !== 0) {
      writer.uint32(16).int32(message.dropped_links_count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Span_Links {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpan_Links();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.link === undefined) {
            message.link = [];
          }
          const el = Span_Link.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.link!.push(el);
          }
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.dropped_links_count = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Span_Links {
    return {
      $type: Span_Links.$type,
      link: globalThis.Array.isArray(object?.link) ? object.link.map((e: any) => Span_Link.fromJSON(e)) : undefined,
      dropped_links_count: isSet(object.dropped_links_count)
        ? globalThis.Number(object.dropped_links_count)
        : undefined,
    };
  },

  toJSON(message: Span_Links): unknown {
    const obj: any = {};
    if (message.link?.length) {
      obj.link = message.link.map((e) => Span_Link.toJSON(e));
    }
    if (message.dropped_links_count !== undefined) {
      obj.dropped_links_count = Math.round(message.dropped_links_count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Span_Links>, I>>(base?: I): Span_Links {
    return Span_Links.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Span_Links>, I>>(object: I): Span_Links {
    const message = createBaseSpan_Links();
    message.link = object.link?.map((e) => Span_Link.fromPartial(e)) || undefined;
    message.dropped_links_count = object.dropped_links_count ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Span_Links.$type, Span_Links);

function createBaseStatus(): Status {
  return { $type: "opencensus.proto.trace.v1.Status" };
}

export const Status: MessageFns<Status, "opencensus.proto.trace.v1.Status"> = {
  $type: "opencensus.proto.trace.v1.Status" as const,

  encode(message: Status, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== undefined && message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.message !== undefined && message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Status {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Status {
    return {
      $type: Status.$type,
      code: isSet(object.code) ? globalThis.Number(object.code) : undefined,
      message: isSet(object.message) ? globalThis.String(object.message) : undefined,
    };
  },

  toJSON(message: Status): unknown {
    const obj: any = {};
    if (message.code !== undefined) {
      obj.code = Math.round(message.code);
    }
    if (message.message !== undefined) {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Status>, I>>(base?: I): Status {
    return Status.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Status>, I>>(object: I): Status {
    const message = createBaseStatus();
    message.code = object.code ?? undefined;
    message.message = object.message ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Status.$type, Status);

function createBaseAttributeValue(): AttributeValue {
  return { $type: "opencensus.proto.trace.v1.AttributeValue", value: undefined };
}

export const AttributeValue: MessageFns<AttributeValue, "opencensus.proto.trace.v1.AttributeValue"> = {
  $type: "opencensus.proto.trace.v1.AttributeValue" as const,

  encode(message: AttributeValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.value?.$case) {
      case "string_value":
        TruncatableString.encode(message.value.string_value, writer.uint32(10).fork()).join();
        break;
      case "int_value":
        writer.uint32(16).int64(message.value.int_value);
        break;
      case "bool_value":
        writer.uint32(24).bool(message.value.bool_value);
        break;
      case "double_value":
        writer.uint32(33).double(message.value.double_value);
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttributeValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttributeValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = { $case: "string_value", string_value: TruncatableString.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = { $case: "int_value", int_value: longToNumber(reader.int64()) };
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.value = { $case: "bool_value", bool_value: reader.bool() };
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.value = { $case: "double_value", double_value: reader.double() };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttributeValue {
    return {
      $type: AttributeValue.$type,
      value: isSet(object.string_value)
        ? { $case: "string_value", string_value: TruncatableString.fromJSON(object.string_value) }
        : isSet(object.int_value)
        ? { $case: "int_value", int_value: globalThis.Number(object.int_value) }
        : isSet(object.bool_value)
        ? { $case: "bool_value", bool_value: globalThis.Boolean(object.bool_value) }
        : isSet(object.double_value)
        ? { $case: "double_value", double_value: globalThis.Number(object.double_value) }
        : undefined,
    };
  },

  toJSON(message: AttributeValue): unknown {
    const obj: any = {};
    if (message.value?.$case === "string_value") {
      obj.string_value = TruncatableString.toJSON(message.value.string_value);
    }
    if (message.value?.$case === "int_value") {
      obj.int_value = Math.round(message.value.int_value);
    }
    if (message.value?.$case === "bool_value") {
      obj.bool_value = message.value.bool_value;
    }
    if (message.value?.$case === "double_value") {
      obj.double_value = message.value.double_value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AttributeValue>, I>>(base?: I): AttributeValue {
    return AttributeValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AttributeValue>, I>>(object: I): AttributeValue {
    const message = createBaseAttributeValue();
    if (
      object.value?.$case === "string_value" &&
      object.value?.string_value !== undefined &&
      object.value?.string_value !== null
    ) {
      message.value = { $case: "string_value", string_value: TruncatableString.fromPartial(object.value.string_value) };
    }
    if (
      object.value?.$case === "int_value" && object.value?.int_value !== undefined && object.value?.int_value !== null
    ) {
      message.value = { $case: "int_value", int_value: object.value.int_value };
    }
    if (
      object.value?.$case === "bool_value" &&
      object.value?.bool_value !== undefined &&
      object.value?.bool_value !== null
    ) {
      message.value = { $case: "bool_value", bool_value: object.value.bool_value };
    }
    if (
      object.value?.$case === "double_value" &&
      object.value?.double_value !== undefined &&
      object.value?.double_value !== null
    ) {
      message.value = { $case: "double_value", double_value: object.value.double_value };
    }
    return message;
  },
};

messageTypeRegistry.set(AttributeValue.$type, AttributeValue);

function createBaseStackTrace(): StackTrace {
  return { $type: "opencensus.proto.trace.v1.StackTrace" };
}

export const StackTrace: MessageFns<StackTrace, "opencensus.proto.trace.v1.StackTrace"> = {
  $type: "opencensus.proto.trace.v1.StackTrace" as const,

  encode(message: StackTrace, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stack_frames !== undefined) {
      StackTrace_StackFrames.encode(message.stack_frames, writer.uint32(10).fork()).join();
    }
    if (message.stack_trace_hash_id !== undefined && message.stack_trace_hash_id !== 0) {
      writer.uint32(16).uint64(message.stack_trace_hash_id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StackTrace {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStackTrace();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stack_frames = StackTrace_StackFrames.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.stack_trace_hash_id = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StackTrace {
    return {
      $type: StackTrace.$type,
      stack_frames: isSet(object.stack_frames) ? StackTrace_StackFrames.fromJSON(object.stack_frames) : undefined,
      stack_trace_hash_id: isSet(object.stack_trace_hash_id)
        ? globalThis.Number(object.stack_trace_hash_id)
        : undefined,
    };
  },

  toJSON(message: StackTrace): unknown {
    const obj: any = {};
    if (message.stack_frames !== undefined) {
      obj.stack_frames = StackTrace_StackFrames.toJSON(message.stack_frames);
    }
    if (message.stack_trace_hash_id !== undefined) {
      obj.stack_trace_hash_id = Math.round(message.stack_trace_hash_id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StackTrace>, I>>(base?: I): StackTrace {
    return StackTrace.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StackTrace>, I>>(object: I): StackTrace {
    const message = createBaseStackTrace();
    message.stack_frames = (object.stack_frames !== undefined && object.stack_frames !== null)
      ? StackTrace_StackFrames.fromPartial(object.stack_frames)
      : undefined;
    message.stack_trace_hash_id = object.stack_trace_hash_id ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(StackTrace.$type, StackTrace);

function createBaseStackTrace_StackFrame(): StackTrace_StackFrame {
  return { $type: "opencensus.proto.trace.v1.StackTrace.StackFrame" };
}

export const StackTrace_StackFrame: MessageFns<
  StackTrace_StackFrame,
  "opencensus.proto.trace.v1.StackTrace.StackFrame"
> = {
  $type: "opencensus.proto.trace.v1.StackTrace.StackFrame" as const,

  encode(message: StackTrace_StackFrame, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.function_name !== undefined) {
      TruncatableString.encode(message.function_name, writer.uint32(10).fork()).join();
    }
    if (message.original_function_name !== undefined) {
      TruncatableString.encode(message.original_function_name, writer.uint32(18).fork()).join();
    }
    if (message.file_name !== undefined) {
      TruncatableString.encode(message.file_name, writer.uint32(26).fork()).join();
    }
    if (message.line_number !== undefined && message.line_number !== 0) {
      writer.uint32(32).int64(message.line_number);
    }
    if (message.column_number !== undefined && message.column_number !== 0) {
      writer.uint32(40).int64(message.column_number);
    }
    if (message.load_module !== undefined) {
      Module.encode(message.load_module, writer.uint32(50).fork()).join();
    }
    if (message.source_version !== undefined) {
      TruncatableString.encode(message.source_version, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StackTrace_StackFrame {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStackTrace_StackFrame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.function_name = TruncatableString.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.original_function_name = TruncatableString.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.file_name = TruncatableString.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.line_number = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.column_number = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.load_module = Module.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.source_version = TruncatableString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StackTrace_StackFrame {
    return {
      $type: StackTrace_StackFrame.$type,
      function_name: isSet(object.function_name) ? TruncatableString.fromJSON(object.function_name) : undefined,
      original_function_name: isSet(object.original_function_name)
        ? TruncatableString.fromJSON(object.original_function_name)
        : undefined,
      file_name: isSet(object.file_name) ? TruncatableString.fromJSON(object.file_name) : undefined,
      line_number: isSet(object.line_number) ? globalThis.Number(object.line_number) : undefined,
      column_number: isSet(object.column_number) ? globalThis.Number(object.column_number) : undefined,
      load_module: isSet(object.load_module) ? Module.fromJSON(object.load_module) : undefined,
      source_version: isSet(object.source_version) ? TruncatableString.fromJSON(object.source_version) : undefined,
    };
  },

  toJSON(message: StackTrace_StackFrame): unknown {
    const obj: any = {};
    if (message.function_name !== undefined) {
      obj.function_name = TruncatableString.toJSON(message.function_name);
    }
    if (message.original_function_name !== undefined) {
      obj.original_function_name = TruncatableString.toJSON(message.original_function_name);
    }
    if (message.file_name !== undefined) {
      obj.file_name = TruncatableString.toJSON(message.file_name);
    }
    if (message.line_number !== undefined) {
      obj.line_number = Math.round(message.line_number);
    }
    if (message.column_number !== undefined) {
      obj.column_number = Math.round(message.column_number);
    }
    if (message.load_module !== undefined) {
      obj.load_module = Module.toJSON(message.load_module);
    }
    if (message.source_version !== undefined) {
      obj.source_version = TruncatableString.toJSON(message.source_version);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StackTrace_StackFrame>, I>>(base?: I): StackTrace_StackFrame {
    return StackTrace_StackFrame.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StackTrace_StackFrame>, I>>(object: I): StackTrace_StackFrame {
    const message = createBaseStackTrace_StackFrame();
    message.function_name = (object.function_name !== undefined && object.function_name !== null)
      ? TruncatableString.fromPartial(object.function_name)
      : undefined;
    message.original_function_name =
      (object.original_function_name !== undefined && object.original_function_name !== null)
        ? TruncatableString.fromPartial(object.original_function_name)
        : undefined;
    message.file_name = (object.file_name !== undefined && object.file_name !== null)
      ? TruncatableString.fromPartial(object.file_name)
      : undefined;
    message.line_number = object.line_number ?? undefined;
    message.column_number = object.column_number ?? undefined;
    message.load_module = (object.load_module !== undefined && object.load_module !== null)
      ? Module.fromPartial(object.load_module)
      : undefined;
    message.source_version = (object.source_version !== undefined && object.source_version !== null)
      ? TruncatableString.fromPartial(object.source_version)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(StackTrace_StackFrame.$type, StackTrace_StackFrame);

function createBaseStackTrace_StackFrames(): StackTrace_StackFrames {
  return { $type: "opencensus.proto.trace.v1.StackTrace.StackFrames" };
}

export const StackTrace_StackFrames: MessageFns<
  StackTrace_StackFrames,
  "opencensus.proto.trace.v1.StackTrace.StackFrames"
> = {
  $type: "opencensus.proto.trace.v1.StackTrace.StackFrames" as const,

  encode(message: StackTrace_StackFrames, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.frame !== undefined && message.frame.length !== 0) {
      for (const v of message.frame) {
        StackTrace_StackFrame.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    if (message.dropped_frames_count !== undefined && message.dropped_frames_count !== 0) {
      writer.uint32(16).int32(message.dropped_frames_count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StackTrace_StackFrames {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStackTrace_StackFrames();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.frame === undefined) {
            message.frame = [];
          }
          const el = StackTrace_StackFrame.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.frame!.push(el);
          }
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.dropped_frames_count = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StackTrace_StackFrames {
    return {
      $type: StackTrace_StackFrames.$type,
      frame: globalThis.Array.isArray(object?.frame)
        ? object.frame.map((e: any) => StackTrace_StackFrame.fromJSON(e))
        : undefined,
      dropped_frames_count: isSet(object.dropped_frames_count)
        ? globalThis.Number(object.dropped_frames_count)
        : undefined,
    };
  },

  toJSON(message: StackTrace_StackFrames): unknown {
    const obj: any = {};
    if (message.frame?.length) {
      obj.frame = message.frame.map((e) => StackTrace_StackFrame.toJSON(e));
    }
    if (message.dropped_frames_count !== undefined) {
      obj.dropped_frames_count = Math.round(message.dropped_frames_count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StackTrace_StackFrames>, I>>(base?: I): StackTrace_StackFrames {
    return StackTrace_StackFrames.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StackTrace_StackFrames>, I>>(object: I): StackTrace_StackFrames {
    const message = createBaseStackTrace_StackFrames();
    message.frame = object.frame?.map((e) => StackTrace_StackFrame.fromPartial(e)) || undefined;
    message.dropped_frames_count = object.dropped_frames_count ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(StackTrace_StackFrames.$type, StackTrace_StackFrames);

function createBaseModule(): Module {
  return { $type: "opencensus.proto.trace.v1.Module" };
}

export const Module: MessageFns<Module, "opencensus.proto.trace.v1.Module"> = {
  $type: "opencensus.proto.trace.v1.Module" as const,

  encode(message: Module, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.module !== undefined) {
      TruncatableString.encode(message.module, writer.uint32(10).fork()).join();
    }
    if (message.build_id !== undefined) {
      TruncatableString.encode(message.build_id, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Module {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.module = TruncatableString.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.build_id = TruncatableString.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Module {
    return {
      $type: Module.$type,
      module: isSet(object.module) ? TruncatableString.fromJSON(object.module) : undefined,
      build_id: isSet(object.build_id) ? TruncatableString.fromJSON(object.build_id) : undefined,
    };
  },

  toJSON(message: Module): unknown {
    const obj: any = {};
    if (message.module !== undefined) {
      obj.module = TruncatableString.toJSON(message.module);
    }
    if (message.build_id !== undefined) {
      obj.build_id = TruncatableString.toJSON(message.build_id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Module>, I>>(base?: I): Module {
    return Module.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Module>, I>>(object: I): Module {
    const message = createBaseModule();
    message.module = (object.module !== undefined && object.module !== null)
      ? TruncatableString.fromPartial(object.module)
      : undefined;
    message.build_id = (object.build_id !== undefined && object.build_id !== null)
      ? TruncatableString.fromPartial(object.build_id)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Module.$type, Module);

function createBaseTruncatableString(): TruncatableString {
  return { $type: "opencensus.proto.trace.v1.TruncatableString" };
}

export const TruncatableString: MessageFns<TruncatableString, "opencensus.proto.trace.v1.TruncatableString"> = {
  $type: "opencensus.proto.trace.v1.TruncatableString" as const,

  encode(message: TruncatableString, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined && message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    if (message.truncated_byte_count !== undefined && message.truncated_byte_count !== 0) {
      writer.uint32(16).int32(message.truncated_byte_count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TruncatableString {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTruncatableString();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.truncated_byte_count = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TruncatableString {
    return {
      $type: TruncatableString.$type,
      value: isSet(object.value) ? globalThis.String(object.value) : undefined,
      truncated_byte_count: isSet(object.truncated_byte_count)
        ? globalThis.Number(object.truncated_byte_count)
        : undefined,
    };
  },

  toJSON(message: TruncatableString): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    if (message.truncated_byte_count !== undefined) {
      obj.truncated_byte_count = Math.round(message.truncated_byte_count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TruncatableString>, I>>(base?: I): TruncatableString {
    return TruncatableString.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TruncatableString>, I>>(object: I): TruncatableString {
    const message = createBaseTruncatableString();
    message.value = object.value ?? undefined;
    message.truncated_byte_count = object.truncated_byte_count ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(TruncatableString.$type, TruncatableString);

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { $type: "google.protobuf.Timestamp", seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
