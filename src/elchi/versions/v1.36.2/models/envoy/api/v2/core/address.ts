// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/api/v2/core/address.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { BoolValue, UInt32Value } from "../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../typeRegistry";
import { SocketOption } from "./socket_option";

export const protobufPackage = "envoy.api.v2.core";

export interface Pipe {
  $type: "envoy.api.v2.core.Pipe";
  /**
   * Unix Domain Socket path. On Linux, paths starting with '@' will use the
   * abstract namespace. The starting '@' is replaced by a null byte by Envoy.
   * Paths starting with '@' will result in an error in environments other than
   * Linux.
   */
  path?:
    | string
    | undefined;
  /** The mode for the Pipe. Not applicable for abstract sockets. */
  mode?: number | undefined;
}

/** [#next-free-field: 7] */
export interface SocketAddress {
  $type: "envoy.api.v2.core.SocketAddress";
  protocol?:
    | SocketAddress_Protocol
    | undefined;
  /**
   * The address for this socket. :ref:`Listeners <config_listeners>` will bind
   * to the address. An empty address is not allowed. Specify ``0.0.0.0`` or ``::``
   * to bind to any address. [#comment:TODO(zuercher) reinstate when implemented:
   * It is possible to distinguish a Listener address via the prefix/suffix matching
   * in :ref:`FilterChainMatch <envoy_api_msg_listener.FilterChainMatch>`.] When used
   * within an upstream :ref:`BindConfig <envoy_api_msg_core.BindConfig>`, the address
   * controls the source address of outbound connections. For :ref:`clusters
   * <envoy_api_msg_Cluster>`, the cluster type determines whether the
   * address must be an IP (*STATIC* or *EDS* clusters) or a hostname resolved by DNS
   * (*STRICT_DNS* or *LOGICAL_DNS* clusters). Address resolution can be customized
   * via :ref:`resolver_name <envoy_api_field_core.SocketAddress.resolver_name>`.
   */
  address?: string | undefined;
  port_specifier?:
    | //
    { $case: "port_value"; port_value: number }
    | //
    /**
     * This is only valid if :ref:`resolver_name
     * <envoy_api_field_core.SocketAddress.resolver_name>` is specified below and the
     * named resolver is capable of named port resolution.
     */
    { $case: "named_port"; named_port: string }
    | undefined;
  /**
   * The name of the custom resolver. This must have been registered with Envoy. If
   * this is empty, a context dependent default applies. If the address is a concrete
   * IP address, no resolution will occur. If address is a hostname this
   * should be set for resolution other than DNS. Specifying a custom resolver with
   * *STRICT_DNS* or *LOGICAL_DNS* will generate an error at runtime.
   */
  resolver_name?:
    | string
    | undefined;
  /**
   * When binding to an IPv6 address above, this enables `IPv4 compatibility
   * <https://tools.ietf.org/html/rfc3493#page-11>`_. Binding to ``::`` will
   * allow both IPv4 and IPv6 connections, with peer IPv4 addresses mapped into
   * IPv6 space as ``::FFFF:<IPv4-address>``.
   */
  ipv4_compat?: boolean | undefined;
}

export enum SocketAddress_Protocol {
  TCP = "TCP",
  UDP = "UDP",
}

export function socketAddress_ProtocolFromJSON(object: any): SocketAddress_Protocol {
  switch (object) {
    case 0:
    case "TCP":
      return SocketAddress_Protocol.TCP;
    case 1:
    case "UDP":
      return SocketAddress_Protocol.UDP;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum SocketAddress_Protocol");
  }
}

export function socketAddress_ProtocolToJSON(object: SocketAddress_Protocol): string {
  switch (object) {
    case SocketAddress_Protocol.TCP:
      return "TCP";
    case SocketAddress_Protocol.UDP:
      return "UDP";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum SocketAddress_Protocol");
  }
}

export function socketAddress_ProtocolToNumber(object: SocketAddress_Protocol): number {
  switch (object) {
    case SocketAddress_Protocol.TCP:
      return 0;
    case SocketAddress_Protocol.UDP:
      return 1;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum SocketAddress_Protocol");
  }
}

export interface TcpKeepalive {
  $type: "envoy.api.v2.core.TcpKeepalive";
  /**
   * Maximum number of keepalive probes to send without response before deciding
   * the connection is dead. Default is to use the OS level configuration (unless
   * overridden, Linux defaults to 9.)
   */
  keepalive_probes?:
    | number
    | undefined;
  /**
   * The number of seconds a connection needs to be idle before keep-alive probes
   * start being sent. Default is to use the OS level configuration (unless
   * overridden, Linux defaults to 7200s (i.e., 2 hours.)
   */
  keepalive_time?:
    | number
    | undefined;
  /**
   * The number of seconds between keep-alive probes. Default is to use the OS
   * level configuration (unless overridden, Linux defaults to 75s.)
   */
  keepalive_interval?: number | undefined;
}

export interface BindConfig {
  $type: "envoy.api.v2.core.BindConfig";
  /** The address to bind to when creating a socket. */
  source_address?:
    | SocketAddress
    | undefined;
  /**
   * Whether to set the *IP_FREEBIND* option when creating the socket. When this
   * flag is set to true, allows the :ref:`source_address
   * <envoy_api_field_UpstreamBindConfig.source_address>` to be an IP address
   * that is not configured on the system running Envoy. When this flag is set
   * to false, the option *IP_FREEBIND* is disabled on the socket. When this
   * flag is not set (default), the socket is not modified, i.e. the option is
   * neither enabled nor disabled.
   */
  freebind?:
    | boolean
    | undefined;
  /**
   * Additional socket options that may not be present in Envoy source code or
   * precompiled binaries.
   */
  socket_options?: SocketOption[] | undefined;
}

/**
 * Addresses specify either a logical or physical address and port, which are
 * used to tell Envoy where to bind/listen, connect to upstream and find
 * management servers.
 */
export interface Address {
  $type: "envoy.api.v2.core.Address";
  address?:
    | //
    { $case: "socket_address"; socket_address: SocketAddress }
    | //
    { $case: "pipe"; pipe: Pipe }
    | undefined;
}

/**
 * CidrRange specifies an IP Address and a prefix length to construct
 * the subnet mask for a `CIDR <https://tools.ietf.org/html/rfc4632>`_ range.
 */
export interface CidrRange {
  $type: "envoy.api.v2.core.CidrRange";
  /** IPv4 or IPv6 address, e.g. ``192.0.0.0`` or ``2001:db8::``. */
  address_prefix?:
    | string
    | undefined;
  /** Length of prefix, e.g. 0, 32. Defaults to 0 when unset. */
  prefix_len?: number | undefined;
}

function createBasePipe(): Pipe {
  return { $type: "envoy.api.v2.core.Pipe" };
}

export const Pipe: MessageFns<Pipe, "envoy.api.v2.core.Pipe"> = {
  $type: "envoy.api.v2.core.Pipe" as const,

  encode(message: Pipe, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== undefined && message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.mode !== undefined && message.mode !== 0) {
      writer.uint32(16).uint32(message.mode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Pipe {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePipe();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.mode = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Pipe {
    return {
      $type: Pipe.$type,
      path: isSet(object.path) ? globalThis.String(object.path) : undefined,
      mode: isSet(object.mode) ? globalThis.Number(object.mode) : undefined,
    };
  },

  toJSON(message: Pipe): unknown {
    const obj: any = {};
    if (message.path !== undefined) {
      obj.path = message.path;
    }
    if (message.mode !== undefined) {
      obj.mode = Math.round(message.mode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Pipe>, I>>(base?: I): Pipe {
    return Pipe.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Pipe>, I>>(object: I): Pipe {
    const message = createBasePipe();
    message.path = object.path ?? undefined;
    message.mode = object.mode ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Pipe.$type, Pipe);

function createBaseSocketAddress(): SocketAddress {
  return { $type: "envoy.api.v2.core.SocketAddress", port_specifier: undefined };
}

export const SocketAddress: MessageFns<SocketAddress, "envoy.api.v2.core.SocketAddress"> = {
  $type: "envoy.api.v2.core.SocketAddress" as const,

  encode(message: SocketAddress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.protocol !== undefined && message.protocol !== SocketAddress_Protocol.TCP) {
      writer.uint32(8).int32(socketAddress_ProtocolToNumber(message.protocol));
    }
    if (message.address !== undefined && message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    switch (message.port_specifier?.$case) {
      case "port_value":
        writer.uint32(24).uint32(message.port_specifier.port_value);
        break;
      case "named_port":
        writer.uint32(34).string(message.port_specifier.named_port);
        break;
    }
    if (message.resolver_name !== undefined && message.resolver_name !== "") {
      writer.uint32(42).string(message.resolver_name);
    }
    if (message.ipv4_compat !== undefined && message.ipv4_compat !== false) {
      writer.uint32(48).bool(message.ipv4_compat);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SocketAddress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSocketAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.protocol = socketAddress_ProtocolFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.port_specifier = { $case: "port_value", port_value: reader.uint32() };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.port_specifier = { $case: "named_port", named_port: reader.string() };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.resolver_name = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.ipv4_compat = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SocketAddress {
    return {
      $type: SocketAddress.$type,
      protocol: isSet(object.protocol) ? socketAddress_ProtocolFromJSON(object.protocol) : undefined,
      address: isSet(object.address) ? globalThis.String(object.address) : undefined,
      port_specifier: isSet(object.port_value)
        ? { $case: "port_value", port_value: globalThis.Number(object.port_value) }
        : isSet(object.named_port)
        ? { $case: "named_port", named_port: globalThis.String(object.named_port) }
        : undefined,
      resolver_name: isSet(object.resolver_name) ? globalThis.String(object.resolver_name) : undefined,
      ipv4_compat: isSet(object.ipv4_compat) ? globalThis.Boolean(object.ipv4_compat) : undefined,
    };
  },

  toJSON(message: SocketAddress): unknown {
    const obj: any = {};
    if (message.protocol !== undefined) {
      obj.protocol = socketAddress_ProtocolToJSON(message.protocol);
    }
    if (message.address !== undefined) {
      obj.address = message.address;
    }
    if (message.port_specifier?.$case === "port_value") {
      obj.port_value = Math.round(message.port_specifier.port_value);
    }
    if (message.port_specifier?.$case === "named_port") {
      obj.named_port = message.port_specifier.named_port;
    }
    if (message.resolver_name !== undefined) {
      obj.resolver_name = message.resolver_name;
    }
    if (message.ipv4_compat !== undefined) {
      obj.ipv4_compat = message.ipv4_compat;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SocketAddress>, I>>(base?: I): SocketAddress {
    return SocketAddress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SocketAddress>, I>>(object: I): SocketAddress {
    const message = createBaseSocketAddress();
    message.protocol = object.protocol ?? undefined;
    message.address = object.address ?? undefined;
    if (
      object.port_specifier?.$case === "port_value" &&
      object.port_specifier?.port_value !== undefined &&
      object.port_specifier?.port_value !== null
    ) {
      message.port_specifier = { $case: "port_value", port_value: object.port_specifier.port_value };
    }
    if (
      object.port_specifier?.$case === "named_port" &&
      object.port_specifier?.named_port !== undefined &&
      object.port_specifier?.named_port !== null
    ) {
      message.port_specifier = { $case: "named_port", named_port: object.port_specifier.named_port };
    }
    message.resolver_name = object.resolver_name ?? undefined;
    message.ipv4_compat = object.ipv4_compat ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(SocketAddress.$type, SocketAddress);

function createBaseTcpKeepalive(): TcpKeepalive {
  return { $type: "envoy.api.v2.core.TcpKeepalive" };
}

export const TcpKeepalive: MessageFns<TcpKeepalive, "envoy.api.v2.core.TcpKeepalive"> = {
  $type: "envoy.api.v2.core.TcpKeepalive" as const,

  encode(message: TcpKeepalive, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keepalive_probes !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.keepalive_probes! },
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.keepalive_time !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.keepalive_time! },
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.keepalive_interval !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.keepalive_interval! },
        writer.uint32(26).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TcpKeepalive {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTcpKeepalive();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keepalive_probes = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keepalive_time = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.keepalive_interval = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TcpKeepalive {
    return {
      $type: TcpKeepalive.$type,
      keepalive_probes: isSet(object.keepalive_probes) ? Number(object.keepalive_probes) : undefined,
      keepalive_time: isSet(object.keepalive_time) ? Number(object.keepalive_time) : undefined,
      keepalive_interval: isSet(object.keepalive_interval) ? Number(object.keepalive_interval) : undefined,
    };
  },

  toJSON(message: TcpKeepalive): unknown {
    const obj: any = {};
    if (message.keepalive_probes !== undefined) {
      obj.keepalive_probes = message.keepalive_probes;
    }
    if (message.keepalive_time !== undefined) {
      obj.keepalive_time = message.keepalive_time;
    }
    if (message.keepalive_interval !== undefined) {
      obj.keepalive_interval = message.keepalive_interval;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TcpKeepalive>, I>>(base?: I): TcpKeepalive {
    return TcpKeepalive.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TcpKeepalive>, I>>(object: I): TcpKeepalive {
    const message = createBaseTcpKeepalive();
    message.keepalive_probes = object.keepalive_probes ?? undefined;
    message.keepalive_time = object.keepalive_time ?? undefined;
    message.keepalive_interval = object.keepalive_interval ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(TcpKeepalive.$type, TcpKeepalive);

function createBaseBindConfig(): BindConfig {
  return { $type: "envoy.api.v2.core.BindConfig" };
}

export const BindConfig: MessageFns<BindConfig, "envoy.api.v2.core.BindConfig"> = {
  $type: "envoy.api.v2.core.BindConfig" as const,

  encode(message: BindConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source_address !== undefined) {
      SocketAddress.encode(message.source_address, writer.uint32(10).fork()).join();
    }
    if (message.freebind !== undefined) {
      BoolValue.encode({ $type: "google.protobuf.BoolValue", value: message.freebind! }, writer.uint32(18).fork())
        .join();
    }
    if (message.socket_options !== undefined && message.socket_options.length !== 0) {
      for (const v of message.socket_options) {
        SocketOption.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BindConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBindConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.source_address = SocketAddress.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.freebind = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.socket_options === undefined) {
            message.socket_options = [];
          }
          const el = SocketOption.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.socket_options!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BindConfig {
    return {
      $type: BindConfig.$type,
      source_address: isSet(object.source_address) ? SocketAddress.fromJSON(object.source_address) : undefined,
      freebind: isSet(object.freebind) ? Boolean(object.freebind) : undefined,
      socket_options: globalThis.Array.isArray(object?.socket_options)
        ? object.socket_options.map((e: any) => SocketOption.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: BindConfig): unknown {
    const obj: any = {};
    if (message.source_address !== undefined) {
      obj.source_address = SocketAddress.toJSON(message.source_address);
    }
    if (message.freebind !== undefined) {
      obj.freebind = message.freebind;
    }
    if (message.socket_options?.length) {
      obj.socket_options = message.socket_options.map((e) => SocketOption.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BindConfig>, I>>(base?: I): BindConfig {
    return BindConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BindConfig>, I>>(object: I): BindConfig {
    const message = createBaseBindConfig();
    message.source_address = (object.source_address !== undefined && object.source_address !== null)
      ? SocketAddress.fromPartial(object.source_address)
      : undefined;
    message.freebind = object.freebind ?? undefined;
    message.socket_options = object.socket_options?.map((e) => SocketOption.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(BindConfig.$type, BindConfig);

function createBaseAddress(): Address {
  return { $type: "envoy.api.v2.core.Address", address: undefined };
}

export const Address: MessageFns<Address, "envoy.api.v2.core.Address"> = {
  $type: "envoy.api.v2.core.Address" as const,

  encode(message: Address, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.address?.$case) {
      case "socket_address":
        SocketAddress.encode(message.address.socket_address, writer.uint32(10).fork()).join();
        break;
      case "pipe":
        Pipe.encode(message.address.pipe, writer.uint32(18).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Address {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = { $case: "socket_address", socket_address: SocketAddress.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = { $case: "pipe", pipe: Pipe.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Address {
    return {
      $type: Address.$type,
      address: isSet(object.socket_address)
        ? { $case: "socket_address", socket_address: SocketAddress.fromJSON(object.socket_address) }
        : isSet(object.pipe)
        ? { $case: "pipe", pipe: Pipe.fromJSON(object.pipe) }
        : undefined,
    };
  },

  toJSON(message: Address): unknown {
    const obj: any = {};
    if (message.address?.$case === "socket_address") {
      obj.socket_address = SocketAddress.toJSON(message.address.socket_address);
    }
    if (message.address?.$case === "pipe") {
      obj.pipe = Pipe.toJSON(message.address.pipe);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Address>, I>>(base?: I): Address {
    return Address.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Address>, I>>(object: I): Address {
    const message = createBaseAddress();
    if (
      object.address?.$case === "socket_address" &&
      object.address?.socket_address !== undefined &&
      object.address?.socket_address !== null
    ) {
      message.address = {
        $case: "socket_address",
        socket_address: SocketAddress.fromPartial(object.address.socket_address),
      };
    }
    if (object.address?.$case === "pipe" && object.address?.pipe !== undefined && object.address?.pipe !== null) {
      message.address = { $case: "pipe", pipe: Pipe.fromPartial(object.address.pipe) };
    }
    return message;
  },
};

messageTypeRegistry.set(Address.$type, Address);

function createBaseCidrRange(): CidrRange {
  return { $type: "envoy.api.v2.core.CidrRange" };
}

export const CidrRange: MessageFns<CidrRange, "envoy.api.v2.core.CidrRange"> = {
  $type: "envoy.api.v2.core.CidrRange" as const,

  encode(message: CidrRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address_prefix !== undefined && message.address_prefix !== "") {
      writer.uint32(10).string(message.address_prefix);
    }
    if (message.prefix_len !== undefined) {
      UInt32Value.encode({ $type: "google.protobuf.UInt32Value", value: message.prefix_len! }, writer.uint32(18).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CidrRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCidrRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address_prefix = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.prefix_len = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CidrRange {
    return {
      $type: CidrRange.$type,
      address_prefix: isSet(object.address_prefix) ? globalThis.String(object.address_prefix) : undefined,
      prefix_len: isSet(object.prefix_len) ? Number(object.prefix_len) : undefined,
    };
  },

  toJSON(message: CidrRange): unknown {
    const obj: any = {};
    if (message.address_prefix !== undefined) {
      obj.address_prefix = message.address_prefix;
    }
    if (message.prefix_len !== undefined) {
      obj.prefix_len = message.prefix_len;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CidrRange>, I>>(base?: I): CidrRange {
    return CidrRange.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CidrRange>, I>>(object: I): CidrRange {
    const message = createBaseCidrRange();
    message.address_prefix = object.address_prefix ?? undefined;
    message.prefix_len = object.prefix_len ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(CidrRange.$type, CidrRange);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
