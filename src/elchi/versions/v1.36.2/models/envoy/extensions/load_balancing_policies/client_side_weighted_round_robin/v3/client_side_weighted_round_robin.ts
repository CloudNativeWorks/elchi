// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/load_balancing_policies/client_side_weighted_round_robin/v3/client_side_weighted_round_robin.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../../../google/protobuf/duration";
import { BoolValue, FloatValue } from "../../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../../typeRegistry";
import { SlowStartConfig } from "../../common/v3/common";

export const protobufPackage = "envoy.extensions.load_balancing_policies.client_side_weighted_round_robin.v3";

/**
 * Configuration for the client_side_weighted_round_robin LB policy.
 *
 * This policy differs from the built-in ROUND_ROBIN policy in terms of
 * how the endpoint weights are determined. In the ROUND_ROBIN policy,
 * the endpoint weights are sent by the control plane via EDS. However,
 * in this policy, the endpoint weights are instead determined via qps (queries
 * per second), eps (errors per second), and utilization metrics sent by the
 * endpoint using the Open Request Cost Aggregation (ORCA) protocol. Utilization
 * is determined by using the ORCA application_utilization field, if set, or
 * else falling back to the cpu_utilization field. All queries count toward qps,
 * regardless of result. Only failed queries count toward eps. A config
 * parameter error_utilization_penalty controls the penalty to adjust endpoint
 * weights using eps and qps. The weight of a given endpoint is computed as:
 * ``qps / (utilization + eps/qps * error_utilization_penalty)``.
 *
 * Note that Envoy will forward the ORCA response headers/trailers from the upstream
 * cluster to the downstream client. This means that if the downstream client is also
 * configured to use ``client_side_weighted_round_robin`` it will load balance against
 * Envoy based on upstream weights. This can happen when Envoy is used as a reverse proxy.
 * To avoid this issue you can configure the :ref:`header_mutation filter  <envoy_v3_api_msg_extensions.filters.http.header_mutation.v3.HeaderMutation>` to remove
 * the ORCA payload from the response headers/trailers.
 *
 * See the :ref:`load balancing architecture
 * overview<arch_overview_load_balancing_types>` for more information.
 *
 * [#next-free-field: 9]
 */
export interface ClientSideWeightedRoundRobin {
  $type: "envoy.extensions.load_balancing_policies.client_side_weighted_round_robin.v3.ClientSideWeightedRoundRobin";
  /**
   * Whether to enable out-of-band utilization reporting collection from
   * the endpoints. By default, per-request utilization reporting is used.
   */
  enable_oob_load_report?:
    | boolean
    | undefined;
  /**
   * Load reporting interval to request from the server. Note that the
   * server may not provide reports as frequently as the client requests.
   * Used only when enable_oob_load_report is true. Default is 10 seconds.
   */
  oob_reporting_period?:
    | Duration
    | undefined;
  /**
   * A given endpoint must report load metrics continuously for at least
   * this long before the endpoint weight will be used. This avoids
   * churn when the set of endpoint addresses changes. Takes effect
   * both immediately after we establish a connection to an endpoint and
   * after weight_expiration_period has caused us to stop using the most
   * recent load metrics. Default is 10 seconds.
   */
  blackout_period?:
    | Duration
    | undefined;
  /**
   * If a given endpoint has not reported load metrics in this long,
   * then we stop using the reported weight. This ensures that we do
   * not continue to use very stale weights. Once we stop using a stale
   * value, if we later start seeing fresh reports again, the
   * blackout_period applies. Defaults to 3 minutes.
   */
  weight_expiration_period?:
    | Duration
    | undefined;
  /**
   * How often endpoint weights are recalculated. Values less than 100ms are
   * capped at 100ms. Default is 1 second.
   */
  weight_update_period?:
    | Duration
    | undefined;
  /**
   * The multiplier used to adjust endpoint weights with the error rate
   * calculated as eps/qps. Configuration is rejected if this value is negative.
   * Default is 1.0.
   */
  error_utilization_penalty?:
    | number
    | undefined;
  /**
   * By default, endpoint weight is computed based on the :ref:`application_utilization <envoy_v3_api_field_.xds.data.orca.v3.OrcaLoadReport.application_utilization>` field reported by the endpoint.
   * If that field is not set, then utilization will instead be computed by taking the max of the values of the metrics specified here.
   * For map fields in the ORCA proto, the string will be of the form ``<map_field_name>.<map_key>``. For example, the string ``named_metrics.foo`` will mean to look for the key ``foo`` in the ORCA :ref:`named_metrics <envoy_v3_api_field_.xds.data.orca.v3.OrcaLoadReport.named_metrics>` field.
   * If none of the specified metrics are present in the load report, then :ref:`cpu_utilization <envoy_v3_api_field_.xds.data.orca.v3.OrcaLoadReport.cpu_utilization>` is used instead.
   */
  metric_names_for_computing_utilization?:
    | string[]
    | undefined;
  /**
   * Configuration for slow start mode.
   * If this configuration is not set, slow start will not be not enabled.
   * [#not-implemented-hide:]
   */
  slow_start_config?: SlowStartConfig | undefined;
}

function createBaseClientSideWeightedRoundRobin(): ClientSideWeightedRoundRobin {
  return {
    $type: "envoy.extensions.load_balancing_policies.client_side_weighted_round_robin.v3.ClientSideWeightedRoundRobin",
  };
}

export const ClientSideWeightedRoundRobin: MessageFns<
  ClientSideWeightedRoundRobin,
  "envoy.extensions.load_balancing_policies.client_side_weighted_round_robin.v3.ClientSideWeightedRoundRobin"
> = {
  $type:
    "envoy.extensions.load_balancing_policies.client_side_weighted_round_robin.v3.ClientSideWeightedRoundRobin" as const,

  encode(message: ClientSideWeightedRoundRobin, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enable_oob_load_report !== undefined) {
      BoolValue.encode(
        { $type: "google.protobuf.BoolValue", value: message.enable_oob_load_report! },
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.oob_reporting_period !== undefined) {
      Duration.encode(message.oob_reporting_period, writer.uint32(18).fork()).join();
    }
    if (message.blackout_period !== undefined) {
      Duration.encode(message.blackout_period, writer.uint32(26).fork()).join();
    }
    if (message.weight_expiration_period !== undefined) {
      Duration.encode(message.weight_expiration_period, writer.uint32(34).fork()).join();
    }
    if (message.weight_update_period !== undefined) {
      Duration.encode(message.weight_update_period, writer.uint32(42).fork()).join();
    }
    if (message.error_utilization_penalty !== undefined) {
      FloatValue.encode(
        { $type: "google.protobuf.FloatValue", value: message.error_utilization_penalty! },
        writer.uint32(50).fork(),
      ).join();
    }
    if (
      message.metric_names_for_computing_utilization !== undefined &&
      message.metric_names_for_computing_utilization.length !== 0
    ) {
      for (const v of message.metric_names_for_computing_utilization) {
        writer.uint32(58).string(v!);
      }
    }
    if (message.slow_start_config !== undefined) {
      SlowStartConfig.encode(message.slow_start_config, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientSideWeightedRoundRobin {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientSideWeightedRoundRobin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.enable_oob_load_report = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.oob_reporting_period = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.blackout_period = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.weight_expiration_period = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.weight_update_period = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.error_utilization_penalty = FloatValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          if (message.metric_names_for_computing_utilization === undefined) {
            message.metric_names_for_computing_utilization = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.metric_names_for_computing_utilization!.push(el);
          }
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.slow_start_config = SlowStartConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientSideWeightedRoundRobin {
    return {
      $type: ClientSideWeightedRoundRobin.$type,
      enable_oob_load_report: isSet(object.enable_oob_load_report) ? Boolean(object.enable_oob_load_report) : undefined,
      oob_reporting_period: isSet(object.oob_reporting_period)
        ? Duration.fromJSON(object.oob_reporting_period)
        : undefined,
      blackout_period: isSet(object.blackout_period) ? Duration.fromJSON(object.blackout_period) : undefined,
      weight_expiration_period: isSet(object.weight_expiration_period)
        ? Duration.fromJSON(object.weight_expiration_period)
        : undefined,
      weight_update_period: isSet(object.weight_update_period)
        ? Duration.fromJSON(object.weight_update_period)
        : undefined,
      error_utilization_penalty: isSet(object.error_utilization_penalty)
        ? Number(object.error_utilization_penalty)
        : undefined,
      metric_names_for_computing_utilization: globalThis.Array.isArray(object?.metric_names_for_computing_utilization)
        ? object.metric_names_for_computing_utilization.map((e: any) => globalThis.String(e))
        : undefined,
      slow_start_config: isSet(object.slow_start_config)
        ? SlowStartConfig.fromJSON(object.slow_start_config)
        : undefined,
    };
  },

  toJSON(message: ClientSideWeightedRoundRobin): unknown {
    const obj: any = {};
    if (message.enable_oob_load_report !== undefined) {
      obj.enable_oob_load_report = message.enable_oob_load_report;
    }
    if (message.oob_reporting_period !== undefined) {
      obj.oob_reporting_period = Duration.toJSON(message.oob_reporting_period);
    }
    if (message.blackout_period !== undefined) {
      obj.blackout_period = Duration.toJSON(message.blackout_period);
    }
    if (message.weight_expiration_period !== undefined) {
      obj.weight_expiration_period = Duration.toJSON(message.weight_expiration_period);
    }
    if (message.weight_update_period !== undefined) {
      obj.weight_update_period = Duration.toJSON(message.weight_update_period);
    }
    if (message.error_utilization_penalty !== undefined) {
      obj.error_utilization_penalty = message.error_utilization_penalty;
    }
    if (message.metric_names_for_computing_utilization?.length) {
      obj.metric_names_for_computing_utilization = message.metric_names_for_computing_utilization;
    }
    if (message.slow_start_config !== undefined) {
      obj.slow_start_config = SlowStartConfig.toJSON(message.slow_start_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientSideWeightedRoundRobin>, I>>(base?: I): ClientSideWeightedRoundRobin {
    return ClientSideWeightedRoundRobin.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientSideWeightedRoundRobin>, I>>(object: I): ClientSideWeightedRoundRobin {
    const message = createBaseClientSideWeightedRoundRobin();
    message.enable_oob_load_report = object.enable_oob_load_report ?? undefined;
    message.oob_reporting_period = (object.oob_reporting_period !== undefined && object.oob_reporting_period !== null)
      ? Duration.fromPartial(object.oob_reporting_period)
      : undefined;
    message.blackout_period = (object.blackout_period !== undefined && object.blackout_period !== null)
      ? Duration.fromPartial(object.blackout_period)
      : undefined;
    message.weight_expiration_period =
      (object.weight_expiration_period !== undefined && object.weight_expiration_period !== null)
        ? Duration.fromPartial(object.weight_expiration_period)
        : undefined;
    message.weight_update_period = (object.weight_update_period !== undefined && object.weight_update_period !== null)
      ? Duration.fromPartial(object.weight_update_period)
      : undefined;
    message.error_utilization_penalty = object.error_utilization_penalty ?? undefined;
    message.metric_names_for_computing_utilization = object.metric_names_for_computing_utilization?.map((e) => e) ||
      undefined;
    message.slow_start_config = (object.slow_start_config !== undefined && object.slow_start_config !== null)
      ? SlowStartConfig.fromPartial(object.slow_start_config)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(ClientSideWeightedRoundRobin.$type, ClientSideWeightedRoundRobin);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
