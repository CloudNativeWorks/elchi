// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/service/status/v2/csds.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Observable } from "rxjs";
import { map } from "rxjs/operators";
import { messageTypeRegistry } from "../../../../typeRegistry";
import {
  ClustersConfigDump,
  ListenersConfigDump,
  RoutesConfigDump,
  ScopedRoutesConfigDump,
} from "../../../admin/v2alpha/config_dump";
import { Node } from "../../../api/v2/core/base";
import { NodeMatcher } from "../../../type/matcher/node";

export const protobufPackage = "envoy.service.status.v2";

/** Status of a config. */
export enum ConfigStatus {
  /** UNKNOWN - Status info is not available/unknown. */
  UNKNOWN = "UNKNOWN",
  /** SYNCED - Management server has sent the config to client and received ACK. */
  SYNCED = "SYNCED",
  /** NOT_SENT - Config is not sent. */
  NOT_SENT = "NOT_SENT",
  /**
   * STALE - Management server has sent the config to client but hasnâ€™t received
   * ACK/NACK.
   */
  STALE = "STALE",
  /** ERROR - Management server has sent the config to client but received NACK. */
  ERROR = "ERROR",
}

export function configStatusFromJSON(object: any): ConfigStatus {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return ConfigStatus.UNKNOWN;
    case 1:
    case "SYNCED":
      return ConfigStatus.SYNCED;
    case 2:
    case "NOT_SENT":
      return ConfigStatus.NOT_SENT;
    case 3:
    case "STALE":
      return ConfigStatus.STALE;
    case 4:
    case "ERROR":
      return ConfigStatus.ERROR;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ConfigStatus");
  }
}

export function configStatusToJSON(object: ConfigStatus): string {
  switch (object) {
    case ConfigStatus.UNKNOWN:
      return "UNKNOWN";
    case ConfigStatus.SYNCED:
      return "SYNCED";
    case ConfigStatus.NOT_SENT:
      return "NOT_SENT";
    case ConfigStatus.STALE:
      return "STALE";
    case ConfigStatus.ERROR:
      return "ERROR";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ConfigStatus");
  }
}

export function configStatusToNumber(object: ConfigStatus): number {
  switch (object) {
    case ConfigStatus.UNKNOWN:
      return 0;
    case ConfigStatus.SYNCED:
      return 1;
    case ConfigStatus.NOT_SENT:
      return 2;
    case ConfigStatus.STALE:
      return 3;
    case ConfigStatus.ERROR:
      return 4;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ConfigStatus");
  }
}

/** Request for client status of clients identified by a list of NodeMatchers. */
export interface ClientStatusRequest {
  $type: "envoy.service.status.v2.ClientStatusRequest";
  /**
   * Management server can use these match criteria to identify clients.
   * The match follows OR semantics.
   */
  node_matchers?: NodeMatcher[] | undefined;
}

/**
 * Detailed config (per xDS) with status.
 * [#next-free-field: 6]
 */
export interface PerXdsConfig {
  $type: "envoy.service.status.v2.PerXdsConfig";
  status?: ConfigStatus | undefined;
  per_xds_config?:
    | //
    { $case: "listener_config"; listener_config: ListenersConfigDump }
    | //
    { $case: "cluster_config"; cluster_config: ClustersConfigDump }
    | //
    { $case: "route_config"; route_config: RoutesConfigDump }
    | //
    { $case: "scoped_route_config"; scoped_route_config: ScopedRoutesConfigDump }
    | undefined;
}

/** All xds configs for a particular client. */
export interface ClientConfig {
  $type: "envoy.service.status.v2.ClientConfig";
  /** Node for a particular client. */
  node?: Node | undefined;
  xds_config?: PerXdsConfig[] | undefined;
}

export interface ClientStatusResponse {
  $type: "envoy.service.status.v2.ClientStatusResponse";
  /** Client configs for the clients specified in the ClientStatusRequest. */
  config?: ClientConfig[] | undefined;
}

function createBaseClientStatusRequest(): ClientStatusRequest {
  return { $type: "envoy.service.status.v2.ClientStatusRequest" };
}

export const ClientStatusRequest: MessageFns<ClientStatusRequest, "envoy.service.status.v2.ClientStatusRequest"> = {
  $type: "envoy.service.status.v2.ClientStatusRequest" as const,

  encode(message: ClientStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.node_matchers !== undefined && message.node_matchers.length !== 0) {
      for (const v of message.node_matchers) {
        NodeMatcher.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.node_matchers === undefined) {
            message.node_matchers = [];
          }
          const el = NodeMatcher.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.node_matchers!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientStatusRequest {
    return {
      $type: ClientStatusRequest.$type,
      node_matchers: globalThis.Array.isArray(object?.node_matchers)
        ? object.node_matchers.map((e: any) => NodeMatcher.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: ClientStatusRequest): unknown {
    const obj: any = {};
    if (message.node_matchers?.length) {
      obj.node_matchers = message.node_matchers.map((e) => NodeMatcher.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientStatusRequest>, I>>(base?: I): ClientStatusRequest {
    return ClientStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientStatusRequest>, I>>(object: I): ClientStatusRequest {
    const message = createBaseClientStatusRequest();
    message.node_matchers = object.node_matchers?.map((e) => NodeMatcher.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(ClientStatusRequest.$type, ClientStatusRequest);

function createBasePerXdsConfig(): PerXdsConfig {
  return { $type: "envoy.service.status.v2.PerXdsConfig", per_xds_config: undefined };
}

export const PerXdsConfig: MessageFns<PerXdsConfig, "envoy.service.status.v2.PerXdsConfig"> = {
  $type: "envoy.service.status.v2.PerXdsConfig" as const,

  encode(message: PerXdsConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined && message.status !== ConfigStatus.UNKNOWN) {
      writer.uint32(8).int32(configStatusToNumber(message.status));
    }
    switch (message.per_xds_config?.$case) {
      case "listener_config":
        ListenersConfigDump.encode(message.per_xds_config.listener_config, writer.uint32(18).fork()).join();
        break;
      case "cluster_config":
        ClustersConfigDump.encode(message.per_xds_config.cluster_config, writer.uint32(26).fork()).join();
        break;
      case "route_config":
        RoutesConfigDump.encode(message.per_xds_config.route_config, writer.uint32(34).fork()).join();
        break;
      case "scoped_route_config":
        ScopedRoutesConfigDump.encode(message.per_xds_config.scoped_route_config, writer.uint32(42).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PerXdsConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePerXdsConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = configStatusFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.per_xds_config = {
            $case: "listener_config",
            listener_config: ListenersConfigDump.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.per_xds_config = {
            $case: "cluster_config",
            cluster_config: ClustersConfigDump.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.per_xds_config = {
            $case: "route_config",
            route_config: RoutesConfigDump.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.per_xds_config = {
            $case: "scoped_route_config",
            scoped_route_config: ScopedRoutesConfigDump.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PerXdsConfig {
    return {
      $type: PerXdsConfig.$type,
      status: isSet(object.status) ? configStatusFromJSON(object.status) : undefined,
      per_xds_config: isSet(object.listener_config)
        ? { $case: "listener_config", listener_config: ListenersConfigDump.fromJSON(object.listener_config) }
        : isSet(object.cluster_config)
        ? { $case: "cluster_config", cluster_config: ClustersConfigDump.fromJSON(object.cluster_config) }
        : isSet(object.route_config)
        ? { $case: "route_config", route_config: RoutesConfigDump.fromJSON(object.route_config) }
        : isSet(object.scoped_route_config)
        ? {
          $case: "scoped_route_config",
          scoped_route_config: ScopedRoutesConfigDump.fromJSON(object.scoped_route_config),
        }
        : undefined,
    };
  },

  toJSON(message: PerXdsConfig): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = configStatusToJSON(message.status);
    }
    if (message.per_xds_config?.$case === "listener_config") {
      obj.listener_config = ListenersConfigDump.toJSON(message.per_xds_config.listener_config);
    }
    if (message.per_xds_config?.$case === "cluster_config") {
      obj.cluster_config = ClustersConfigDump.toJSON(message.per_xds_config.cluster_config);
    }
    if (message.per_xds_config?.$case === "route_config") {
      obj.route_config = RoutesConfigDump.toJSON(message.per_xds_config.route_config);
    }
    if (message.per_xds_config?.$case === "scoped_route_config") {
      obj.scoped_route_config = ScopedRoutesConfigDump.toJSON(message.per_xds_config.scoped_route_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PerXdsConfig>, I>>(base?: I): PerXdsConfig {
    return PerXdsConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PerXdsConfig>, I>>(object: I): PerXdsConfig {
    const message = createBasePerXdsConfig();
    message.status = object.status ?? undefined;
    if (
      object.per_xds_config?.$case === "listener_config" &&
      object.per_xds_config?.listener_config !== undefined &&
      object.per_xds_config?.listener_config !== null
    ) {
      message.per_xds_config = {
        $case: "listener_config",
        listener_config: ListenersConfigDump.fromPartial(object.per_xds_config.listener_config),
      };
    }
    if (
      object.per_xds_config?.$case === "cluster_config" &&
      object.per_xds_config?.cluster_config !== undefined &&
      object.per_xds_config?.cluster_config !== null
    ) {
      message.per_xds_config = {
        $case: "cluster_config",
        cluster_config: ClustersConfigDump.fromPartial(object.per_xds_config.cluster_config),
      };
    }
    if (
      object.per_xds_config?.$case === "route_config" &&
      object.per_xds_config?.route_config !== undefined &&
      object.per_xds_config?.route_config !== null
    ) {
      message.per_xds_config = {
        $case: "route_config",
        route_config: RoutesConfigDump.fromPartial(object.per_xds_config.route_config),
      };
    }
    if (
      object.per_xds_config?.$case === "scoped_route_config" &&
      object.per_xds_config?.scoped_route_config !== undefined &&
      object.per_xds_config?.scoped_route_config !== null
    ) {
      message.per_xds_config = {
        $case: "scoped_route_config",
        scoped_route_config: ScopedRoutesConfigDump.fromPartial(object.per_xds_config.scoped_route_config),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(PerXdsConfig.$type, PerXdsConfig);

function createBaseClientConfig(): ClientConfig {
  return { $type: "envoy.service.status.v2.ClientConfig" };
}

export const ClientConfig: MessageFns<ClientConfig, "envoy.service.status.v2.ClientConfig"> = {
  $type: "envoy.service.status.v2.ClientConfig" as const,

  encode(message: ClientConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.node !== undefined) {
      Node.encode(message.node, writer.uint32(10).fork()).join();
    }
    if (message.xds_config !== undefined && message.xds_config.length !== 0) {
      for (const v of message.xds_config) {
        PerXdsConfig.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.node = Node.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.xds_config === undefined) {
            message.xds_config = [];
          }
          const el = PerXdsConfig.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.xds_config!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientConfig {
    return {
      $type: ClientConfig.$type,
      node: isSet(object.node) ? Node.fromJSON(object.node) : undefined,
      xds_config: globalThis.Array.isArray(object?.xds_config)
        ? object.xds_config.map((e: any) => PerXdsConfig.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: ClientConfig): unknown {
    const obj: any = {};
    if (message.node !== undefined) {
      obj.node = Node.toJSON(message.node);
    }
    if (message.xds_config?.length) {
      obj.xds_config = message.xds_config.map((e) => PerXdsConfig.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientConfig>, I>>(base?: I): ClientConfig {
    return ClientConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientConfig>, I>>(object: I): ClientConfig {
    const message = createBaseClientConfig();
    message.node = (object.node !== undefined && object.node !== null) ? Node.fromPartial(object.node) : undefined;
    message.xds_config = object.xds_config?.map((e) => PerXdsConfig.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(ClientConfig.$type, ClientConfig);

function createBaseClientStatusResponse(): ClientStatusResponse {
  return { $type: "envoy.service.status.v2.ClientStatusResponse" };
}

export const ClientStatusResponse: MessageFns<ClientStatusResponse, "envoy.service.status.v2.ClientStatusResponse"> = {
  $type: "envoy.service.status.v2.ClientStatusResponse" as const,

  encode(message: ClientStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.config !== undefined && message.config.length !== 0) {
      for (const v of message.config) {
        ClientConfig.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.config === undefined) {
            message.config = [];
          }
          const el = ClientConfig.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.config!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientStatusResponse {
    return {
      $type: ClientStatusResponse.$type,
      config: globalThis.Array.isArray(object?.config)
        ? object.config.map((e: any) => ClientConfig.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: ClientStatusResponse): unknown {
    const obj: any = {};
    if (message.config?.length) {
      obj.config = message.config.map((e) => ClientConfig.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientStatusResponse>, I>>(base?: I): ClientStatusResponse {
    return ClientStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientStatusResponse>, I>>(object: I): ClientStatusResponse {
    const message = createBaseClientStatusResponse();
    message.config = object.config?.map((e) => ClientConfig.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(ClientStatusResponse.$type, ClientStatusResponse);

/**
 * CSDS is Client Status Discovery Service. It can be used to get the status of
 * an xDS-compliant client from the management server's point of view. In the
 * future, it can potentially be used as an interface to get the current
 * state directly from the client.
 */
export interface ClientStatusDiscoveryService {
  StreamClientStatus(request: Observable<ClientStatusRequest>): Observable<ClientStatusResponse>;
  FetchClientStatus(request: ClientStatusRequest): Promise<ClientStatusResponse>;
}

export const ClientStatusDiscoveryServiceServiceName = "envoy.service.status.v2.ClientStatusDiscoveryService";
export class ClientStatusDiscoveryServiceClientImpl implements ClientStatusDiscoveryService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || ClientStatusDiscoveryServiceServiceName;
    this.rpc = rpc;
    this.StreamClientStatus = this.StreamClientStatus.bind(this);
    this.FetchClientStatus = this.FetchClientStatus.bind(this);
  }
  StreamClientStatus(request: Observable<ClientStatusRequest>): Observable<ClientStatusResponse> {
    const data = request.pipe(map((request) => ClientStatusRequest.encode(request).finish()));
    const result = this.rpc.bidirectionalStreamingRequest(this.service, "StreamClientStatus", data);
    return result.pipe(map((data) => ClientStatusResponse.decode(new BinaryReader(data))));
  }

  FetchClientStatus(request: ClientStatusRequest): Promise<ClientStatusResponse> {
    const data = ClientStatusRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "FetchClientStatus", data);
    return promise.then((data) => ClientStatusResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
  clientStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Promise<Uint8Array>;
  serverStreamingRequest(service: string, method: string, data: Uint8Array): Observable<Uint8Array>;
  bidirectionalStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Observable<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
