// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/type/v3/ratelimit_strategy.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { messageTypeRegistry } from "../../../typeRegistry";
import { RateLimitUnit, rateLimitUnitFromJSON, rateLimitUnitToJSON, rateLimitUnitToNumber } from "./ratelimit_unit";
import { TokenBucket } from "./token_bucket";

export const protobufPackage = "envoy.type.v3";

export interface RateLimitStrategy {
  $type: "envoy.type.v3.RateLimitStrategy";
  strategy?:
    | //
    /**
     * Allow or Deny the requests.
     * If unset, allow all.
     */
    { $case: "blanket_rule"; blanket_rule: RateLimitStrategy_BlanketRule }
    | //
    /**
     * Best-effort limit of the number of requests per time unit, f.e. requests per second.
     * Does not prescribe any specific rate limiting algorithm, see :ref:`RequestsPerTimeUnit
     * <envoy_v3_api_msg_type.v3.RateLimitStrategy.RequestsPerTimeUnit>` for details.
     */
    { $case: "requests_per_time_unit"; requests_per_time_unit: RateLimitStrategy_RequestsPerTimeUnit }
    | //
    /**
     * Limit the requests by consuming tokens from the Token Bucket.
     * Allow the same number of requests as the number of tokens available in
     * the token bucket.
     */
    { $case: "token_bucket"; token_bucket: TokenBucket }
    | undefined;
}

/** Choose between allow all and deny all. */
export enum RateLimitStrategy_BlanketRule {
  ALLOW_ALL = "ALLOW_ALL",
  DENY_ALL = "DENY_ALL",
}

export function rateLimitStrategy_BlanketRuleFromJSON(object: any): RateLimitStrategy_BlanketRule {
  switch (object) {
    case 0:
    case "ALLOW_ALL":
      return RateLimitStrategy_BlanketRule.ALLOW_ALL;
    case 1:
    case "DENY_ALL":
      return RateLimitStrategy_BlanketRule.DENY_ALL;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RateLimitStrategy_BlanketRule");
  }
}

export function rateLimitStrategy_BlanketRuleToJSON(object: RateLimitStrategy_BlanketRule): string {
  switch (object) {
    case RateLimitStrategy_BlanketRule.ALLOW_ALL:
      return "ALLOW_ALL";
    case RateLimitStrategy_BlanketRule.DENY_ALL:
      return "DENY_ALL";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RateLimitStrategy_BlanketRule");
  }
}

export function rateLimitStrategy_BlanketRuleToNumber(object: RateLimitStrategy_BlanketRule): number {
  switch (object) {
    case RateLimitStrategy_BlanketRule.ALLOW_ALL:
      return 0;
    case RateLimitStrategy_BlanketRule.DENY_ALL:
      return 1;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RateLimitStrategy_BlanketRule");
  }
}

/**
 * Best-effort limit of the number of requests per time unit.
 *
 * Allows to specify the desired requests per second (RPS, QPS), requests per minute (QPM, RPM),
 * etc., without specifying a rate limiting algorithm implementation.
 *
 * ``RequestsPerTimeUnit`` strategy does not demand any specific rate limiting algorithm to be
 * used (in contrast to the :ref:`TokenBucket <envoy_v3_api_msg_type.v3.TokenBucket>`,
 * for example). It implies that the implementation details of rate limiting algorithm are
 * irrelevant as long as the configured number of "requests per time unit" is achieved.
 *
 * Note that the ``TokenBucket`` is still a valid implementation of the ``RequestsPerTimeUnit``
 * strategy, and may be chosen to enforce the rate limit. However, there's no guarantee it will be
 * the ``TokenBucket`` in particular, and not the Leaky Bucket, the Sliding Window, or any other
 * rate limiting algorithm that fulfills the requirements.
 */
export interface RateLimitStrategy_RequestsPerTimeUnit {
  $type: "envoy.type.v3.RateLimitStrategy.RequestsPerTimeUnit";
  /**
   * The desired number of requests per :ref:`time_unit
   * <envoy_v3_api_field_type.v3.RateLimitStrategy.RequestsPerTimeUnit.time_unit>` to allow.
   * If set to ``0``, deny all (equivalent to ``BlanketRule.DENY_ALL``).
   *
   * .. note::
   *   Note that the algorithm implementation determines the course of action for the requests
   *   over the limit. As long as the ``requests_per_time_unit`` converges on the desired value,
   *   it's allowed to treat this field as a soft-limit: allow bursts, redistribute the allowance
   *   over time, etc.
   */
  requests_per_time_unit?:
    | number
    | undefined;
  /**
   * The unit of time. Ignored when :ref:`requests_per_time_unit
   * <envoy_v3_api_field_type.v3.RateLimitStrategy.RequestsPerTimeUnit.requests_per_time_unit>`
   * is ``0`` (deny all).
   */
  time_unit?: RateLimitUnit | undefined;
}

function createBaseRateLimitStrategy(): RateLimitStrategy {
  return { $type: "envoy.type.v3.RateLimitStrategy", strategy: undefined };
}

export const RateLimitStrategy: MessageFns<RateLimitStrategy, "envoy.type.v3.RateLimitStrategy"> = {
  $type: "envoy.type.v3.RateLimitStrategy" as const,

  encode(message: RateLimitStrategy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.strategy?.$case) {
      case "blanket_rule":
        writer.uint32(8).int32(rateLimitStrategy_BlanketRuleToNumber(message.strategy.blanket_rule));
        break;
      case "requests_per_time_unit":
        RateLimitStrategy_RequestsPerTimeUnit.encode(message.strategy.requests_per_time_unit, writer.uint32(18).fork())
          .join();
        break;
      case "token_bucket":
        TokenBucket.encode(message.strategy.token_bucket, writer.uint32(26).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimitStrategy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimitStrategy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.strategy = {
            $case: "blanket_rule",
            blanket_rule: rateLimitStrategy_BlanketRuleFromJSON(reader.int32()),
          };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.strategy = {
            $case: "requests_per_time_unit",
            requests_per_time_unit: RateLimitStrategy_RequestsPerTimeUnit.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.strategy = { $case: "token_bucket", token_bucket: TokenBucket.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimitStrategy {
    return {
      $type: RateLimitStrategy.$type,
      strategy: isSet(object.blanket_rule)
        ? { $case: "blanket_rule", blanket_rule: rateLimitStrategy_BlanketRuleFromJSON(object.blanket_rule) }
        : isSet(object.requests_per_time_unit)
        ? {
          $case: "requests_per_time_unit",
          requests_per_time_unit: RateLimitStrategy_RequestsPerTimeUnit.fromJSON(object.requests_per_time_unit),
        }
        : isSet(object.token_bucket)
        ? { $case: "token_bucket", token_bucket: TokenBucket.fromJSON(object.token_bucket) }
        : undefined,
    };
  },

  toJSON(message: RateLimitStrategy): unknown {
    const obj: any = {};
    if (message.strategy?.$case === "blanket_rule") {
      obj.blanket_rule = rateLimitStrategy_BlanketRuleToJSON(message.strategy.blanket_rule);
    }
    if (message.strategy?.$case === "requests_per_time_unit") {
      obj.requests_per_time_unit = RateLimitStrategy_RequestsPerTimeUnit.toJSON(
        message.strategy.requests_per_time_unit,
      );
    }
    if (message.strategy?.$case === "token_bucket") {
      obj.token_bucket = TokenBucket.toJSON(message.strategy.token_bucket);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimitStrategy>, I>>(base?: I): RateLimitStrategy {
    return RateLimitStrategy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimitStrategy>, I>>(object: I): RateLimitStrategy {
    const message = createBaseRateLimitStrategy();
    if (
      object.strategy?.$case === "blanket_rule" &&
      object.strategy?.blanket_rule !== undefined &&
      object.strategy?.blanket_rule !== null
    ) {
      message.strategy = { $case: "blanket_rule", blanket_rule: object.strategy.blanket_rule };
    }
    if (
      object.strategy?.$case === "requests_per_time_unit" &&
      object.strategy?.requests_per_time_unit !== undefined &&
      object.strategy?.requests_per_time_unit !== null
    ) {
      message.strategy = {
        $case: "requests_per_time_unit",
        requests_per_time_unit: RateLimitStrategy_RequestsPerTimeUnit.fromPartial(
          object.strategy.requests_per_time_unit,
        ),
      };
    }
    if (
      object.strategy?.$case === "token_bucket" &&
      object.strategy?.token_bucket !== undefined &&
      object.strategy?.token_bucket !== null
    ) {
      message.strategy = { $case: "token_bucket", token_bucket: TokenBucket.fromPartial(object.strategy.token_bucket) };
    }
    return message;
  },
};

messageTypeRegistry.set(RateLimitStrategy.$type, RateLimitStrategy);

function createBaseRateLimitStrategy_RequestsPerTimeUnit(): RateLimitStrategy_RequestsPerTimeUnit {
  return { $type: "envoy.type.v3.RateLimitStrategy.RequestsPerTimeUnit" };
}

export const RateLimitStrategy_RequestsPerTimeUnit: MessageFns<
  RateLimitStrategy_RequestsPerTimeUnit,
  "envoy.type.v3.RateLimitStrategy.RequestsPerTimeUnit"
> = {
  $type: "envoy.type.v3.RateLimitStrategy.RequestsPerTimeUnit" as const,

  encode(message: RateLimitStrategy_RequestsPerTimeUnit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requests_per_time_unit !== undefined && message.requests_per_time_unit !== 0) {
      writer.uint32(8).uint64(message.requests_per_time_unit);
    }
    if (message.time_unit !== undefined && message.time_unit !== RateLimitUnit.UNKNOWN) {
      writer.uint32(16).int32(rateLimitUnitToNumber(message.time_unit));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimitStrategy_RequestsPerTimeUnit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimitStrategy_RequestsPerTimeUnit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.requests_per_time_unit = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.time_unit = rateLimitUnitFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimitStrategy_RequestsPerTimeUnit {
    return {
      $type: RateLimitStrategy_RequestsPerTimeUnit.$type,
      requests_per_time_unit: isSet(object.requests_per_time_unit)
        ? globalThis.Number(object.requests_per_time_unit)
        : undefined,
      time_unit: isSet(object.time_unit) ? rateLimitUnitFromJSON(object.time_unit) : undefined,
    };
  },

  toJSON(message: RateLimitStrategy_RequestsPerTimeUnit): unknown {
    const obj: any = {};
    if (message.requests_per_time_unit !== undefined) {
      obj.requests_per_time_unit = Math.round(message.requests_per_time_unit);
    }
    if (message.time_unit !== undefined) {
      obj.time_unit = rateLimitUnitToJSON(message.time_unit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimitStrategy_RequestsPerTimeUnit>, I>>(
    base?: I,
  ): RateLimitStrategy_RequestsPerTimeUnit {
    return RateLimitStrategy_RequestsPerTimeUnit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimitStrategy_RequestsPerTimeUnit>, I>>(
    object: I,
  ): RateLimitStrategy_RequestsPerTimeUnit {
    const message = createBaseRateLimitStrategy_RequestsPerTimeUnit();
    message.requests_per_time_unit = object.requests_per_time_unit ?? undefined;
    message.time_unit = object.time_unit ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RateLimitStrategy_RequestsPerTimeUnit.$type, RateLimitStrategy_RequestsPerTimeUnit);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
