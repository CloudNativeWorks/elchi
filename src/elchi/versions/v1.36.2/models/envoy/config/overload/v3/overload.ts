// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/config/overload/v3/overload.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Any } from "../../../../google/protobuf/any";
import { Duration } from "../../../../google/protobuf/duration";
import { messageTypeRegistry } from "../../../../typeRegistry";
import { Percent } from "../../../type/v3/percent";

export const protobufPackage = "envoy.config.overload.v3";

export interface ResourceMonitor {
  $type: "envoy.config.overload.v3.ResourceMonitor";
  /**
   * The name of the resource monitor to instantiate. Must match a registered
   * resource monitor type.
   * See the :ref:`extensions listed in typed_config below <extension_category_envoy.resource_monitors>` for the default list of available resource monitor.
   */
  name?:
    | string
    | undefined;
  /**
   * Configuration for the resource monitor being instantiated.
   * [#extension-category: envoy.resource_monitors]
   */
  config_type?:
    | //
    { $case: "typed_config"; typed_config: Any }
    | undefined;
}

export interface ThresholdTrigger {
  $type: "envoy.config.overload.v3.ThresholdTrigger";
  /**
   * If the resource pressure is greater than or equal to this value, the trigger
   * will enter saturation.
   */
  value?: number | undefined;
}

export interface ScaledTrigger {
  $type: "envoy.config.overload.v3.ScaledTrigger";
  /**
   * If the resource pressure is greater than this value, the trigger will be in the
   * :ref:`scaling <arch_overview_overload_manager-triggers-state>` state with value
   * ``(pressure - scaling_threshold) / (saturation_threshold - scaling_threshold)``.
   */
  scaling_threshold?:
    | number
    | undefined;
  /** If the resource pressure is greater than this value, the trigger will enter saturation. */
  saturation_threshold?: number | undefined;
}

export interface Trigger {
  $type: "envoy.config.overload.v3.Trigger";
  /** The name of the resource this is a trigger for. */
  name?: string | undefined;
  trigger_oneof?:
    | //
    { $case: "threshold"; threshold: ThresholdTrigger }
    | //
    { $case: "scaled"; scaled: ScaledTrigger }
    | undefined;
}

/**
 * Typed configuration for the "envoy.overload_actions.reduce_timeouts" action. See
 * :ref:`the docs <config_overload_manager_reducing_timeouts>` for an example of how to configure
 * the action with different timeouts and minimum values.
 */
export interface ScaleTimersOverloadActionConfig {
  $type: "envoy.config.overload.v3.ScaleTimersOverloadActionConfig";
  /** A set of timer scaling rules to be applied. */
  timer_scale_factors?: ScaleTimersOverloadActionConfig_ScaleTimer[] | undefined;
}

export enum ScaleTimersOverloadActionConfig_TimerType {
  /** UNSPECIFIED - Unsupported value; users must explicitly specify the timer they want scaled. */
  UNSPECIFIED = "UNSPECIFIED",
  /**
   * HTTP_DOWNSTREAM_CONNECTION_IDLE - Adjusts the idle timer for downstream HTTP connections that takes effect when there are no active streams.
   * This affects the value of :ref:`HttpConnectionManager.common_http_protocol_options.idle_timeout
   * <envoy_v3_api_field_config.core.v3.HttpProtocolOptions.idle_timeout>`
   */
  HTTP_DOWNSTREAM_CONNECTION_IDLE = "HTTP_DOWNSTREAM_CONNECTION_IDLE",
  /**
   * HTTP_DOWNSTREAM_STREAM_IDLE - Adjusts the idle timer for HTTP streams initiated by downstream clients.
   * This affects the value of :ref:`RouteAction.idle_timeout <envoy_v3_api_field_config.route.v3.RouteAction.idle_timeout>` and
   * :ref:`HttpConnectionManager.stream_idle_timeout
   * <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout>`
   */
  HTTP_DOWNSTREAM_STREAM_IDLE = "HTTP_DOWNSTREAM_STREAM_IDLE",
  /**
   * TRANSPORT_SOCKET_CONNECT - Adjusts the timer for how long downstream clients have to finish transport-level negotiations
   * before the connection is closed.
   * This affects the value of
   * :ref:`FilterChain.transport_socket_connect_timeout <envoy_v3_api_field_config.listener.v3.FilterChain.transport_socket_connect_timeout>`.
   */
  TRANSPORT_SOCKET_CONNECT = "TRANSPORT_SOCKET_CONNECT",
  /**
   * HTTP_DOWNSTREAM_CONNECTION_MAX - Adjusts the max connection duration timer for downstream HTTP connections.
   * This affects the value of
   * :ref:`HttpConnectionManager.common_http_protocol_options.max_connection_duration
   * <envoy_v3_api_field_config.core.v3.HttpProtocolOptions.max_connection_duration>`.
   */
  HTTP_DOWNSTREAM_CONNECTION_MAX = "HTTP_DOWNSTREAM_CONNECTION_MAX",
  /**
   * HTTP_DOWNSTREAM_STREAM_FLUSH - Adjusts the timeout for the downstream codec to flush an ended stream.
   * This affects the value of :ref:`RouteAction.flush_timeout
   * <envoy_v3_api_field_config.route.v3.RouteAction.flush_timeout>` and
   * :ref:`HttpConnectionManager.stream_flush_timeout
   * <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_flush_timeout>`
   */
  HTTP_DOWNSTREAM_STREAM_FLUSH = "HTTP_DOWNSTREAM_STREAM_FLUSH",
}

export function scaleTimersOverloadActionConfig_TimerTypeFromJSON(
  object: any,
): ScaleTimersOverloadActionConfig_TimerType {
  switch (object) {
    case 0:
    case "UNSPECIFIED":
      return ScaleTimersOverloadActionConfig_TimerType.UNSPECIFIED;
    case 1:
    case "HTTP_DOWNSTREAM_CONNECTION_IDLE":
      return ScaleTimersOverloadActionConfig_TimerType.HTTP_DOWNSTREAM_CONNECTION_IDLE;
    case 2:
    case "HTTP_DOWNSTREAM_STREAM_IDLE":
      return ScaleTimersOverloadActionConfig_TimerType.HTTP_DOWNSTREAM_STREAM_IDLE;
    case 3:
    case "TRANSPORT_SOCKET_CONNECT":
      return ScaleTimersOverloadActionConfig_TimerType.TRANSPORT_SOCKET_CONNECT;
    case 4:
    case "HTTP_DOWNSTREAM_CONNECTION_MAX":
      return ScaleTimersOverloadActionConfig_TimerType.HTTP_DOWNSTREAM_CONNECTION_MAX;
    case 5:
    case "HTTP_DOWNSTREAM_STREAM_FLUSH":
      return ScaleTimersOverloadActionConfig_TimerType.HTTP_DOWNSTREAM_STREAM_FLUSH;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum ScaleTimersOverloadActionConfig_TimerType",
      );
  }
}

export function scaleTimersOverloadActionConfig_TimerTypeToJSON(
  object: ScaleTimersOverloadActionConfig_TimerType,
): string {
  switch (object) {
    case ScaleTimersOverloadActionConfig_TimerType.UNSPECIFIED:
      return "UNSPECIFIED";
    case ScaleTimersOverloadActionConfig_TimerType.HTTP_DOWNSTREAM_CONNECTION_IDLE:
      return "HTTP_DOWNSTREAM_CONNECTION_IDLE";
    case ScaleTimersOverloadActionConfig_TimerType.HTTP_DOWNSTREAM_STREAM_IDLE:
      return "HTTP_DOWNSTREAM_STREAM_IDLE";
    case ScaleTimersOverloadActionConfig_TimerType.TRANSPORT_SOCKET_CONNECT:
      return "TRANSPORT_SOCKET_CONNECT";
    case ScaleTimersOverloadActionConfig_TimerType.HTTP_DOWNSTREAM_CONNECTION_MAX:
      return "HTTP_DOWNSTREAM_CONNECTION_MAX";
    case ScaleTimersOverloadActionConfig_TimerType.HTTP_DOWNSTREAM_STREAM_FLUSH:
      return "HTTP_DOWNSTREAM_STREAM_FLUSH";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum ScaleTimersOverloadActionConfig_TimerType",
      );
  }
}

export function scaleTimersOverloadActionConfig_TimerTypeToNumber(
  object: ScaleTimersOverloadActionConfig_TimerType,
): number {
  switch (object) {
    case ScaleTimersOverloadActionConfig_TimerType.UNSPECIFIED:
      return 0;
    case ScaleTimersOverloadActionConfig_TimerType.HTTP_DOWNSTREAM_CONNECTION_IDLE:
      return 1;
    case ScaleTimersOverloadActionConfig_TimerType.HTTP_DOWNSTREAM_STREAM_IDLE:
      return 2;
    case ScaleTimersOverloadActionConfig_TimerType.TRANSPORT_SOCKET_CONNECT:
      return 3;
    case ScaleTimersOverloadActionConfig_TimerType.HTTP_DOWNSTREAM_CONNECTION_MAX:
      return 4;
    case ScaleTimersOverloadActionConfig_TimerType.HTTP_DOWNSTREAM_STREAM_FLUSH:
      return 5;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum ScaleTimersOverloadActionConfig_TimerType",
      );
  }
}

export interface ScaleTimersOverloadActionConfig_ScaleTimer {
  $type: "envoy.config.overload.v3.ScaleTimersOverloadActionConfig.ScaleTimer";
  /** The type of timer this minimum applies to. */
  timer?: ScaleTimersOverloadActionConfig_TimerType | undefined;
  overload_adjust?:
    | //
    /** Sets the minimum duration as an absolute value. */
    { $case: "min_timeout"; min_timeout: Duration }
    | //
    /** Sets the minimum duration as a percentage of the maximum value. */
    { $case: "min_scale"; min_scale: Percent }
    | undefined;
}

export interface OverloadAction {
  $type: "envoy.config.overload.v3.OverloadAction";
  /**
   * The name of the overload action. This is just a well-known string that
   * listeners can use for registering callbacks.
   * Valid known overload actions include:
   * - envoy.overload_actions.stop_accepting_requests
   * - envoy.overload_actions.disable_http_keepalive
   * - envoy.overload_actions.stop_accepting_connections
   * - envoy.overload_actions.reject_incoming_connections
   * - envoy.overload_actions.shrink_heap
   * - envoy.overload_actions.reduce_timeouts
   * - envoy.overload_actions.reset_high_memory_stream
   */
  name?:
    | string
    | undefined;
  /**
   * A set of triggers for this action. The state of the action is the maximum
   * state of all triggers, which can be scalar values between 0 and 1 or
   * saturated. Listeners are notified when the overload action changes state.
   * An overload manager action can only have one trigger for a given resource
   * e.g. :ref:`Trigger.name
   * <envoy_v3_api_field_config.overload.v3.Trigger.name>` must be unique
   * in this list.
   */
  triggers?:
    | Trigger[]
    | undefined;
  /** Configuration for the action being instantiated if applicable. */
  typed_config?: Any | undefined;
}

/**
 * A point within the connection or request lifecycle that provides context on
 * whether to shed load at that given stage for the current entity at the
 * point.
 */
export interface LoadShedPoint {
  $type: "envoy.config.overload.v3.LoadShedPoint";
  /**
   * This is just a well-known string for the LoadShedPoint.
   * Deployment specific LoadShedPoints e.g. within a custom extension should
   * be prefixed by the company / deployment name to avoid colliding with any
   * open source LoadShedPoints.
   */
  name?:
    | string
    | undefined;
  /**
   * A set of triggers for this LoadShedPoint. The LoadShedPoint will use the
   * the maximum state of all triggers, which can be scalar values between 0 and
   * 1 or saturated. A LoadShedPoint can only have one trigger for a given
   * resource e.g. :ref:`Trigger.name
   * <envoy_v3_api_field_config.overload.v3.Trigger.name>` must be unique in
   * this list.
   */
  triggers?: Trigger[] | undefined;
}

/**
 * Configuration for which accounts the WatermarkBuffer Factories should
 * track.
 */
export interface BufferFactoryConfig {
  $type: "envoy.config.overload.v3.BufferFactoryConfig";
  /**
   * The minimum power of two at which Envoy starts tracking an account.
   *
   * Envoy has 8 power of two buckets starting with the provided exponent below.
   * Concretely the 1st bucket contains accounts for streams that use
   * [2^minimum_account_to_track_power_of_two,
   * 2^(minimum_account_to_track_power_of_two + 1)) bytes.
   * With the 8th bucket tracking accounts
   * >= 128 * 2^minimum_account_to_track_power_of_two.
   *
   * The maximum value is 56, since we're using uint64_t for bytes counting,
   * and that's the last value that would use the 8 buckets. In practice,
   * we don't expect the proxy to be holding 2^56 bytes.
   *
   * If omitted, Envoy should not do any tracking.
   */
  minimum_account_to_track_power_of_two?: number | undefined;
}

/** [#next-free-field: 6] */
export interface OverloadManager {
  $type: "envoy.config.overload.v3.OverloadManager";
  /** The interval for refreshing resource usage. */
  refresh_interval?:
    | Duration
    | undefined;
  /** The set of resources to monitor. */
  resource_monitors?:
    | ResourceMonitor[]
    | undefined;
  /** The set of overload actions. */
  actions?:
    | OverloadAction[]
    | undefined;
  /** The set of load shed points. */
  loadshed_points?:
    | LoadShedPoint[]
    | undefined;
  /** Configuration for buffer factory. */
  buffer_factory_config?: BufferFactoryConfig | undefined;
}

function createBaseResourceMonitor(): ResourceMonitor {
  return { $type: "envoy.config.overload.v3.ResourceMonitor", config_type: undefined };
}

export const ResourceMonitor: MessageFns<ResourceMonitor, "envoy.config.overload.v3.ResourceMonitor"> = {
  $type: "envoy.config.overload.v3.ResourceMonitor" as const,

  encode(message: ResourceMonitor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    switch (message.config_type?.$case) {
      case "typed_config":
        Any.encode(message.config_type.typed_config, writer.uint32(26).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceMonitor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceMonitor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.config_type = { $case: "typed_config", typed_config: Any.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceMonitor {
    return {
      $type: ResourceMonitor.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      config_type: isSet(object.typed_config)
        ? { $case: "typed_config", typed_config: Any.fromJSON(object.typed_config) }
        : undefined,
    };
  },

  toJSON(message: ResourceMonitor): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.config_type?.$case === "typed_config") {
      obj.typed_config = Any.toJSON(message.config_type.typed_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResourceMonitor>, I>>(base?: I): ResourceMonitor {
    return ResourceMonitor.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResourceMonitor>, I>>(object: I): ResourceMonitor {
    const message = createBaseResourceMonitor();
    message.name = object.name ?? undefined;
    if (
      object.config_type?.$case === "typed_config" &&
      object.config_type?.typed_config !== undefined &&
      object.config_type?.typed_config !== null
    ) {
      message.config_type = { $case: "typed_config", typed_config: Any.fromPartial(object.config_type.typed_config) };
    }
    return message;
  },
};

messageTypeRegistry.set(ResourceMonitor.$type, ResourceMonitor);

function createBaseThresholdTrigger(): ThresholdTrigger {
  return { $type: "envoy.config.overload.v3.ThresholdTrigger" };
}

export const ThresholdTrigger: MessageFns<ThresholdTrigger, "envoy.config.overload.v3.ThresholdTrigger"> = {
  $type: "envoy.config.overload.v3.ThresholdTrigger" as const,

  encode(message: ThresholdTrigger, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined && message.value !== 0) {
      writer.uint32(9).double(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ThresholdTrigger {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseThresholdTrigger();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.value = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ThresholdTrigger {
    return { $type: ThresholdTrigger.$type, value: isSet(object.value) ? globalThis.Number(object.value) : undefined };
  },

  toJSON(message: ThresholdTrigger): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ThresholdTrigger>, I>>(base?: I): ThresholdTrigger {
    return ThresholdTrigger.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ThresholdTrigger>, I>>(object: I): ThresholdTrigger {
    const message = createBaseThresholdTrigger();
    message.value = object.value ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ThresholdTrigger.$type, ThresholdTrigger);

function createBaseScaledTrigger(): ScaledTrigger {
  return { $type: "envoy.config.overload.v3.ScaledTrigger" };
}

export const ScaledTrigger: MessageFns<ScaledTrigger, "envoy.config.overload.v3.ScaledTrigger"> = {
  $type: "envoy.config.overload.v3.ScaledTrigger" as const,

  encode(message: ScaledTrigger, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scaling_threshold !== undefined && message.scaling_threshold !== 0) {
      writer.uint32(9).double(message.scaling_threshold);
    }
    if (message.saturation_threshold !== undefined && message.saturation_threshold !== 0) {
      writer.uint32(17).double(message.saturation_threshold);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScaledTrigger {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScaledTrigger();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.scaling_threshold = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.saturation_threshold = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScaledTrigger {
    return {
      $type: ScaledTrigger.$type,
      scaling_threshold: isSet(object.scaling_threshold) ? globalThis.Number(object.scaling_threshold) : undefined,
      saturation_threshold: isSet(object.saturation_threshold)
        ? globalThis.Number(object.saturation_threshold)
        : undefined,
    };
  },

  toJSON(message: ScaledTrigger): unknown {
    const obj: any = {};
    if (message.scaling_threshold !== undefined) {
      obj.scaling_threshold = message.scaling_threshold;
    }
    if (message.saturation_threshold !== undefined) {
      obj.saturation_threshold = message.saturation_threshold;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScaledTrigger>, I>>(base?: I): ScaledTrigger {
    return ScaledTrigger.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScaledTrigger>, I>>(object: I): ScaledTrigger {
    const message = createBaseScaledTrigger();
    message.scaling_threshold = object.scaling_threshold ?? undefined;
    message.saturation_threshold = object.saturation_threshold ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ScaledTrigger.$type, ScaledTrigger);

function createBaseTrigger(): Trigger {
  return { $type: "envoy.config.overload.v3.Trigger", trigger_oneof: undefined };
}

export const Trigger: MessageFns<Trigger, "envoy.config.overload.v3.Trigger"> = {
  $type: "envoy.config.overload.v3.Trigger" as const,

  encode(message: Trigger, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    switch (message.trigger_oneof?.$case) {
      case "threshold":
        ThresholdTrigger.encode(message.trigger_oneof.threshold, writer.uint32(18).fork()).join();
        break;
      case "scaled":
        ScaledTrigger.encode(message.trigger_oneof.scaled, writer.uint32(26).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Trigger {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrigger();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.trigger_oneof = { $case: "threshold", threshold: ThresholdTrigger.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.trigger_oneof = { $case: "scaled", scaled: ScaledTrigger.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Trigger {
    return {
      $type: Trigger.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      trigger_oneof: isSet(object.threshold)
        ? { $case: "threshold", threshold: ThresholdTrigger.fromJSON(object.threshold) }
        : isSet(object.scaled)
        ? { $case: "scaled", scaled: ScaledTrigger.fromJSON(object.scaled) }
        : undefined,
    };
  },

  toJSON(message: Trigger): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.trigger_oneof?.$case === "threshold") {
      obj.threshold = ThresholdTrigger.toJSON(message.trigger_oneof.threshold);
    }
    if (message.trigger_oneof?.$case === "scaled") {
      obj.scaled = ScaledTrigger.toJSON(message.trigger_oneof.scaled);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Trigger>, I>>(base?: I): Trigger {
    return Trigger.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Trigger>, I>>(object: I): Trigger {
    const message = createBaseTrigger();
    message.name = object.name ?? undefined;
    if (
      object.trigger_oneof?.$case === "threshold" &&
      object.trigger_oneof?.threshold !== undefined &&
      object.trigger_oneof?.threshold !== null
    ) {
      message.trigger_oneof = {
        $case: "threshold",
        threshold: ThresholdTrigger.fromPartial(object.trigger_oneof.threshold),
      };
    }
    if (
      object.trigger_oneof?.$case === "scaled" &&
      object.trigger_oneof?.scaled !== undefined &&
      object.trigger_oneof?.scaled !== null
    ) {
      message.trigger_oneof = { $case: "scaled", scaled: ScaledTrigger.fromPartial(object.trigger_oneof.scaled) };
    }
    return message;
  },
};

messageTypeRegistry.set(Trigger.$type, Trigger);

function createBaseScaleTimersOverloadActionConfig(): ScaleTimersOverloadActionConfig {
  return { $type: "envoy.config.overload.v3.ScaleTimersOverloadActionConfig" };
}

export const ScaleTimersOverloadActionConfig: MessageFns<
  ScaleTimersOverloadActionConfig,
  "envoy.config.overload.v3.ScaleTimersOverloadActionConfig"
> = {
  $type: "envoy.config.overload.v3.ScaleTimersOverloadActionConfig" as const,

  encode(message: ScaleTimersOverloadActionConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timer_scale_factors !== undefined && message.timer_scale_factors.length !== 0) {
      for (const v of message.timer_scale_factors) {
        ScaleTimersOverloadActionConfig_ScaleTimer.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScaleTimersOverloadActionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScaleTimersOverloadActionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.timer_scale_factors === undefined) {
            message.timer_scale_factors = [];
          }
          const el = ScaleTimersOverloadActionConfig_ScaleTimer.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.timer_scale_factors!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScaleTimersOverloadActionConfig {
    return {
      $type: ScaleTimersOverloadActionConfig.$type,
      timer_scale_factors: globalThis.Array.isArray(object?.timer_scale_factors)
        ? object.timer_scale_factors.map((e: any) => ScaleTimersOverloadActionConfig_ScaleTimer.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: ScaleTimersOverloadActionConfig): unknown {
    const obj: any = {};
    if (message.timer_scale_factors?.length) {
      obj.timer_scale_factors = message.timer_scale_factors.map((e) =>
        ScaleTimersOverloadActionConfig_ScaleTimer.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScaleTimersOverloadActionConfig>, I>>(base?: I): ScaleTimersOverloadActionConfig {
    return ScaleTimersOverloadActionConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScaleTimersOverloadActionConfig>, I>>(
    object: I,
  ): ScaleTimersOverloadActionConfig {
    const message = createBaseScaleTimersOverloadActionConfig();
    message.timer_scale_factors =
      object.timer_scale_factors?.map((e) => ScaleTimersOverloadActionConfig_ScaleTimer.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(ScaleTimersOverloadActionConfig.$type, ScaleTimersOverloadActionConfig);

function createBaseScaleTimersOverloadActionConfig_ScaleTimer(): ScaleTimersOverloadActionConfig_ScaleTimer {
  return { $type: "envoy.config.overload.v3.ScaleTimersOverloadActionConfig.ScaleTimer", overload_adjust: undefined };
}

export const ScaleTimersOverloadActionConfig_ScaleTimer: MessageFns<
  ScaleTimersOverloadActionConfig_ScaleTimer,
  "envoy.config.overload.v3.ScaleTimersOverloadActionConfig.ScaleTimer"
> = {
  $type: "envoy.config.overload.v3.ScaleTimersOverloadActionConfig.ScaleTimer" as const,

  encode(message: ScaleTimersOverloadActionConfig_ScaleTimer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timer !== undefined && message.timer !== ScaleTimersOverloadActionConfig_TimerType.UNSPECIFIED) {
      writer.uint32(8).int32(scaleTimersOverloadActionConfig_TimerTypeToNumber(message.timer));
    }
    switch (message.overload_adjust?.$case) {
      case "min_timeout":
        Duration.encode(message.overload_adjust.min_timeout, writer.uint32(18).fork()).join();
        break;
      case "min_scale":
        Percent.encode(message.overload_adjust.min_scale, writer.uint32(26).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScaleTimersOverloadActionConfig_ScaleTimer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScaleTimersOverloadActionConfig_ScaleTimer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.timer = scaleTimersOverloadActionConfig_TimerTypeFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.overload_adjust = { $case: "min_timeout", min_timeout: Duration.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.overload_adjust = { $case: "min_scale", min_scale: Percent.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScaleTimersOverloadActionConfig_ScaleTimer {
    return {
      $type: ScaleTimersOverloadActionConfig_ScaleTimer.$type,
      timer: isSet(object.timer) ? scaleTimersOverloadActionConfig_TimerTypeFromJSON(object.timer) : undefined,
      overload_adjust: isSet(object.min_timeout)
        ? { $case: "min_timeout", min_timeout: Duration.fromJSON(object.min_timeout) }
        : isSet(object.min_scale)
        ? { $case: "min_scale", min_scale: Percent.fromJSON(object.min_scale) }
        : undefined,
    };
  },

  toJSON(message: ScaleTimersOverloadActionConfig_ScaleTimer): unknown {
    const obj: any = {};
    if (message.timer !== undefined) {
      obj.timer = scaleTimersOverloadActionConfig_TimerTypeToJSON(message.timer);
    }
    if (message.overload_adjust?.$case === "min_timeout") {
      obj.min_timeout = Duration.toJSON(message.overload_adjust.min_timeout);
    }
    if (message.overload_adjust?.$case === "min_scale") {
      obj.min_scale = Percent.toJSON(message.overload_adjust.min_scale);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScaleTimersOverloadActionConfig_ScaleTimer>, I>>(
    base?: I,
  ): ScaleTimersOverloadActionConfig_ScaleTimer {
    return ScaleTimersOverloadActionConfig_ScaleTimer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScaleTimersOverloadActionConfig_ScaleTimer>, I>>(
    object: I,
  ): ScaleTimersOverloadActionConfig_ScaleTimer {
    const message = createBaseScaleTimersOverloadActionConfig_ScaleTimer();
    message.timer = object.timer ?? undefined;
    if (
      object.overload_adjust?.$case === "min_timeout" &&
      object.overload_adjust?.min_timeout !== undefined &&
      object.overload_adjust?.min_timeout !== null
    ) {
      message.overload_adjust = {
        $case: "min_timeout",
        min_timeout: Duration.fromPartial(object.overload_adjust.min_timeout),
      };
    }
    if (
      object.overload_adjust?.$case === "min_scale" &&
      object.overload_adjust?.min_scale !== undefined &&
      object.overload_adjust?.min_scale !== null
    ) {
      message.overload_adjust = {
        $case: "min_scale",
        min_scale: Percent.fromPartial(object.overload_adjust.min_scale),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(ScaleTimersOverloadActionConfig_ScaleTimer.$type, ScaleTimersOverloadActionConfig_ScaleTimer);

function createBaseOverloadAction(): OverloadAction {
  return { $type: "envoy.config.overload.v3.OverloadAction" };
}

export const OverloadAction: MessageFns<OverloadAction, "envoy.config.overload.v3.OverloadAction"> = {
  $type: "envoy.config.overload.v3.OverloadAction" as const,

  encode(message: OverloadAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.triggers !== undefined && message.triggers.length !== 0) {
      for (const v of message.triggers) {
        Trigger.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.typed_config !== undefined) {
      Any.encode(message.typed_config, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OverloadAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOverloadAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.triggers === undefined) {
            message.triggers = [];
          }
          const el = Trigger.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.triggers!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.typed_config = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OverloadAction {
    return {
      $type: OverloadAction.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      triggers: globalThis.Array.isArray(object?.triggers)
        ? object.triggers.map((e: any) => Trigger.fromJSON(e))
        : undefined,
      typed_config: isSet(object.typed_config) ? Any.fromJSON(object.typed_config) : undefined,
    };
  },

  toJSON(message: OverloadAction): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.triggers?.length) {
      obj.triggers = message.triggers.map((e) => Trigger.toJSON(e));
    }
    if (message.typed_config !== undefined) {
      obj.typed_config = Any.toJSON(message.typed_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OverloadAction>, I>>(base?: I): OverloadAction {
    return OverloadAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OverloadAction>, I>>(object: I): OverloadAction {
    const message = createBaseOverloadAction();
    message.name = object.name ?? undefined;
    message.triggers = object.triggers?.map((e) => Trigger.fromPartial(e)) || undefined;
    message.typed_config = (object.typed_config !== undefined && object.typed_config !== null)
      ? Any.fromPartial(object.typed_config)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(OverloadAction.$type, OverloadAction);

function createBaseLoadShedPoint(): LoadShedPoint {
  return { $type: "envoy.config.overload.v3.LoadShedPoint" };
}

export const LoadShedPoint: MessageFns<LoadShedPoint, "envoy.config.overload.v3.LoadShedPoint"> = {
  $type: "envoy.config.overload.v3.LoadShedPoint" as const,

  encode(message: LoadShedPoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.triggers !== undefined && message.triggers.length !== 0) {
      for (const v of message.triggers) {
        Trigger.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoadShedPoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoadShedPoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.triggers === undefined) {
            message.triggers = [];
          }
          const el = Trigger.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.triggers!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoadShedPoint {
    return {
      $type: LoadShedPoint.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      triggers: globalThis.Array.isArray(object?.triggers)
        ? object.triggers.map((e: any) => Trigger.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: LoadShedPoint): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.triggers?.length) {
      obj.triggers = message.triggers.map((e) => Trigger.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoadShedPoint>, I>>(base?: I): LoadShedPoint {
    return LoadShedPoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoadShedPoint>, I>>(object: I): LoadShedPoint {
    const message = createBaseLoadShedPoint();
    message.name = object.name ?? undefined;
    message.triggers = object.triggers?.map((e) => Trigger.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(LoadShedPoint.$type, LoadShedPoint);

function createBaseBufferFactoryConfig(): BufferFactoryConfig {
  return { $type: "envoy.config.overload.v3.BufferFactoryConfig" };
}

export const BufferFactoryConfig: MessageFns<BufferFactoryConfig, "envoy.config.overload.v3.BufferFactoryConfig"> = {
  $type: "envoy.config.overload.v3.BufferFactoryConfig" as const,

  encode(message: BufferFactoryConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (
      message.minimum_account_to_track_power_of_two !== undefined && message.minimum_account_to_track_power_of_two !== 0
    ) {
      writer.uint32(8).uint32(message.minimum_account_to_track_power_of_two);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BufferFactoryConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBufferFactoryConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.minimum_account_to_track_power_of_two = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BufferFactoryConfig {
    return {
      $type: BufferFactoryConfig.$type,
      minimum_account_to_track_power_of_two: isSet(object.minimum_account_to_track_power_of_two)
        ? globalThis.Number(object.minimum_account_to_track_power_of_two)
        : undefined,
    };
  },

  toJSON(message: BufferFactoryConfig): unknown {
    const obj: any = {};
    if (message.minimum_account_to_track_power_of_two !== undefined) {
      obj.minimum_account_to_track_power_of_two = Math.round(message.minimum_account_to_track_power_of_two);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BufferFactoryConfig>, I>>(base?: I): BufferFactoryConfig {
    return BufferFactoryConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BufferFactoryConfig>, I>>(object: I): BufferFactoryConfig {
    const message = createBaseBufferFactoryConfig();
    message.minimum_account_to_track_power_of_two = object.minimum_account_to_track_power_of_two ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(BufferFactoryConfig.$type, BufferFactoryConfig);

function createBaseOverloadManager(): OverloadManager {
  return { $type: "envoy.config.overload.v3.OverloadManager" };
}

export const OverloadManager: MessageFns<OverloadManager, "envoy.config.overload.v3.OverloadManager"> = {
  $type: "envoy.config.overload.v3.OverloadManager" as const,

  encode(message: OverloadManager, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.refresh_interval !== undefined) {
      Duration.encode(message.refresh_interval, writer.uint32(10).fork()).join();
    }
    if (message.resource_monitors !== undefined && message.resource_monitors.length !== 0) {
      for (const v of message.resource_monitors) {
        ResourceMonitor.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.actions !== undefined && message.actions.length !== 0) {
      for (const v of message.actions) {
        OverloadAction.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    if (message.loadshed_points !== undefined && message.loadshed_points.length !== 0) {
      for (const v of message.loadshed_points) {
        LoadShedPoint.encode(v!, writer.uint32(42).fork()).join();
      }
    }
    if (message.buffer_factory_config !== undefined) {
      BufferFactoryConfig.encode(message.buffer_factory_config, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OverloadManager {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOverloadManager();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.refresh_interval = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.resource_monitors === undefined) {
            message.resource_monitors = [];
          }
          const el = ResourceMonitor.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.resource_monitors!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.actions === undefined) {
            message.actions = [];
          }
          const el = OverloadAction.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.actions!.push(el);
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          if (message.loadshed_points === undefined) {
            message.loadshed_points = [];
          }
          const el = LoadShedPoint.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.loadshed_points!.push(el);
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.buffer_factory_config = BufferFactoryConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OverloadManager {
    return {
      $type: OverloadManager.$type,
      refresh_interval: isSet(object.refresh_interval) ? Duration.fromJSON(object.refresh_interval) : undefined,
      resource_monitors: globalThis.Array.isArray(object?.resource_monitors)
        ? object.resource_monitors.map((e: any) => ResourceMonitor.fromJSON(e))
        : undefined,
      actions: globalThis.Array.isArray(object?.actions)
        ? object.actions.map((e: any) => OverloadAction.fromJSON(e))
        : undefined,
      loadshed_points: globalThis.Array.isArray(object?.loadshed_points)
        ? object.loadshed_points.map((e: any) => LoadShedPoint.fromJSON(e))
        : undefined,
      buffer_factory_config: isSet(object.buffer_factory_config)
        ? BufferFactoryConfig.fromJSON(object.buffer_factory_config)
        : undefined,
    };
  },

  toJSON(message: OverloadManager): unknown {
    const obj: any = {};
    if (message.refresh_interval !== undefined) {
      obj.refresh_interval = Duration.toJSON(message.refresh_interval);
    }
    if (message.resource_monitors?.length) {
      obj.resource_monitors = message.resource_monitors.map((e) => ResourceMonitor.toJSON(e));
    }
    if (message.actions?.length) {
      obj.actions = message.actions.map((e) => OverloadAction.toJSON(e));
    }
    if (message.loadshed_points?.length) {
      obj.loadshed_points = message.loadshed_points.map((e) => LoadShedPoint.toJSON(e));
    }
    if (message.buffer_factory_config !== undefined) {
      obj.buffer_factory_config = BufferFactoryConfig.toJSON(message.buffer_factory_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OverloadManager>, I>>(base?: I): OverloadManager {
    return OverloadManager.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OverloadManager>, I>>(object: I): OverloadManager {
    const message = createBaseOverloadManager();
    message.refresh_interval = (object.refresh_interval !== undefined && object.refresh_interval !== null)
      ? Duration.fromPartial(object.refresh_interval)
      : undefined;
    message.resource_monitors = object.resource_monitors?.map((e) => ResourceMonitor.fromPartial(e)) || undefined;
    message.actions = object.actions?.map((e) => OverloadAction.fromPartial(e)) || undefined;
    message.loadshed_points = object.loadshed_points?.map((e) => LoadShedPoint.fromPartial(e)) || undefined;
    message.buffer_factory_config =
      (object.buffer_factory_config !== undefined && object.buffer_factory_config !== null)
        ? BufferFactoryConfig.fromPartial(object.buffer_factory_config)
        : undefined;
    return message;
  },
};

messageTypeRegistry.set(OverloadManager.$type, OverloadManager);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
