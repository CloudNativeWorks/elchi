// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/config/metrics/v3/stats.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Any } from "../../../../google/protobuf/any";
import { BoolValue, UInt32Value, UInt64Value } from "../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../typeRegistry";
import { ListStringMatcher, StringMatcher } from "../../../type/matcher/v3/string";
import { Address } from "../../core/v3/address";

export const protobufPackage = "envoy.config.metrics.v3";

/** Configuration for pluggable stats sinks. */
export interface StatsSink {
  $type: "envoy.config.metrics.v3.StatsSink";
  /**
   * The name of the stats sink to instantiate. The name must match a supported
   * stats sink.
   * See the :ref:`extensions listed in typed_config below <extension_category_envoy.stats_sinks>` for the default list of available stats sink.
   * Sinks optionally support tagged/multiple dimensional metrics.
   */
  name?:
    | string
    | undefined;
  /**
   * Stats sink specific configuration which depends on the sink being instantiated. See
   * :ref:`StatsdSink <envoy_v3_api_msg_config.metrics.v3.StatsdSink>` for an example.
   * [#extension-category: envoy.stats_sinks]
   */
  config_type?:
    | //
    { $case: "typed_config"; typed_config: Any }
    | undefined;
}

/** Statistics configuration such as tagging. */
export interface StatsConfig {
  $type: "envoy.config.metrics.v3.StatsConfig";
  /**
   * Each stat name is independently processed through these tag specifiers. When a tag is
   * matched, the first capture group is not immediately removed from the name, so later
   * :ref:`TagSpecifiers <envoy_v3_api_msg_config.metrics.v3.TagSpecifier>` can also match that
   * same portion of the match. After all tag matching is complete, a tag-extracted version of
   * the name is produced and is used in stats sinks that represent tags, such as Prometheus.
   */
  stats_tags?:
    | TagSpecifier[]
    | undefined;
  /**
   * Use all default tag regexes specified in Envoy. These can be combined with
   * custom tags specified in :ref:`stats_tags
   * <envoy_v3_api_field_config.metrics.v3.StatsConfig.stats_tags>`. They will be processed before
   * the custom tags.
   *
   * .. note::
   *
   *   If any default tags are specified twice, the config will be considered
   *   invalid.
   *
   * See :repo:`well_known_names.h <source/common/config/well_known_names.h>` for a list of the
   * default tags in Envoy.
   *
   * If not provided, the value is assumed to be true.
   */
  use_all_default_tags?:
    | boolean
    | undefined;
  /**
   * Inclusion/exclusion matcher for stat name creation. If not provided, all stats are instantiated
   * as normal. Preventing the instantiation of certain families of stats can improve memory
   * performance for Envoys running especially large configs.
   *
   * .. warning::
   *   Excluding stats may affect Envoy's behavior in undocumented ways. See
   *   `issue #8771 <https://github.com/envoyproxy/envoy/issues/8771>`_ for more information.
   *   If any unexpected behavior changes are observed, please open a new issue immediately.
   */
  stats_matcher?:
    | StatsMatcher
    | undefined;
  /**
   * Defines rules for setting the histogram buckets. Rules are evaluated in order, and the first
   * match is applied. If no match is found (or if no rules are set), the following default buckets
   * are used:
   *
   *   .. code-block:: json
   *
   *     [
   *       0.5,
   *       1,
   *       5,
   *       10,
   *       25,
   *       50,
   *       100,
   *       250,
   *       500,
   *       1000,
   *       2500,
   *       5000,
   *       10000,
   *       30000,
   *       60000,
   *       300000,
   *       600000,
   *       1800000,
   *       3600000
   *     ]
   */
  histogram_bucket_settings?: HistogramBucketSettings[] | undefined;
}

/** Configuration for disabling stat instantiation. */
export interface StatsMatcher {
  $type: "envoy.config.metrics.v3.StatsMatcher";
  stats_matcher?:
    | //
    /**
     * If ``reject_all`` is true, then all stats are disabled. If ``reject_all`` is false, then all
     * stats are enabled.
     */
    { $case: "reject_all"; reject_all: boolean }
    | //
    /**
     * Exclusive match. All stats are enabled except for those matching one of the supplied
     * StringMatcher protos.
     */
    { $case: "exclusion_list"; exclusion_list: ListStringMatcher }
    | //
    /**
     * Inclusive match. No stats are enabled except for those matching one of the supplied
     * StringMatcher protos.
     */
    { $case: "inclusion_list"; inclusion_list: ListStringMatcher }
    | undefined;
}

/**
 * Designates a tag name and value pair. The value may be either a fixed value
 * or a regex providing the value via capture groups. The specified tag will be
 * unconditionally set if a fixed value, otherwise it will only be set if one
 * or more capture groups in the regex match.
 */
export interface TagSpecifier {
  $type: "envoy.config.metrics.v3.TagSpecifier";
  /**
   * Attaches an identifier to the tag values to identify the tag being in the
   * sink. Envoy has a set of default names and regexes to extract dynamic
   * portions of existing stats, which can be found in :repo:`well_known_names.h
   * <source/common/config/well_known_names.h>` in the Envoy repository. If a :ref:`tag_name
   * <envoy_v3_api_field_config.metrics.v3.TagSpecifier.tag_name>` is provided in the config and
   * neither :ref:`regex <envoy_v3_api_field_config.metrics.v3.TagSpecifier.regex>` or
   * :ref:`fixed_value <envoy_v3_api_field_config.metrics.v3.TagSpecifier.fixed_value>` were specified,
   * Envoy will attempt to find that name in its set of defaults and use the accompanying regex.
   *
   * .. note::
   *
   *   A stat name may be spelled in such a way that it matches two different
   *   tag extractors for the same tag name. In that case, all but one of the
   *   tag values will be dropped. It is not specified which tag value will be
   *   retained. The extraction will only occur for one of the extractors, and
   *   only the matched extraction will be removed from the tag name.
   */
  tag_name?: string | undefined;
  tag_value?:
    | //
    /**
     * Designates a tag to strip from the tag extracted name and provide as a named
     * tag value for all statistics. This will only occur if any part of the name
     * matches the regex provided with one or more capture groups.
     *
     * The first capture group identifies the portion of the name to remove. The
     * second capture group (which will normally be nested inside the first) will
     * designate the value of the tag for the statistic. If no second capture
     * group is provided, the first will also be used to set the value of the tag.
     * All other capture groups will be ignored.
     *
     * Example 1. a stat name ``cluster.foo_cluster.upstream_rq_timeout`` and
     * one tag specifier:
     *
     * .. code-block:: json
     *
     *   {
     *     "tag_name": "envoy.cluster_name",
     *     "regex": "^cluster\\.((.+?)\\.)"
     *   }
     *
     * Note that the regex will remove ``foo_cluster.`` making the tag extracted
     * name ``cluster.upstream_rq_timeout`` and the tag value for
     * ``envoy.cluster_name`` will be ``foo_cluster`` (note: there will be no
     * ``.`` character because of the second capture group).
     *
     * Example 2. a stat name
     * ``http.connection_manager_1.user_agent.ios.downstream_cx_total`` and two
     * tag specifiers:
     *
     * .. code-block:: json
     *
     *   [
     *     {
     *       "tag_name": "envoy.http_user_agent",
     *       "regex": "^http(?=\\.).*?\\.user_agent\\.((.+?)\\.)\\w+?$"
     *     },
     *     {
     *       "tag_name": "envoy.http_conn_manager_prefix",
     *       "regex": "^http\\.((.*?)\\.)"
     *     }
     *   ]
     *
     * The two regexes of the specifiers will be processed from the elaborated
     * stat name.
     *
     * The first regex will save ``ios.`` as the tag value for ``envoy.http_user_agent``. It will
     * leave it in the name for potential matching with additional tag specifiers. After all tag
     * specifiers are processed the tags will be removed from the name.
     *
     * The second regex will populate tag ``envoy.http_conn_manager_prefix`` with value
     * ``connection_manager_1.``, based on the original stat name.
     *
     * As a final step, the matched tags are removed, leaving
     * ``http.user_agent.downstream_cx_total`` as the tag extracted name.
     */
    { $case: "regex"; regex: string }
    | //
    /** Specifies a fixed tag value for the ``tag_name``. */
    { $case: "fixed_value"; fixed_value: string }
    | undefined;
}

/** Specifies a matcher for stats and the buckets that matching stats should use. */
export interface HistogramBucketSettings {
  $type: "envoy.config.metrics.v3.HistogramBucketSettings";
  /**
   * The stats that this rule applies to. The match is applied to the original stat name
   * before tag-extraction, for example ``cluster.exampleclustername.upstream_cx_length_ms``.
   */
  match?:
    | StringMatcher
    | undefined;
  /**
   * Each value is the upper bound of a bucket. Each bucket must be greater than 0 and unique.
   * The order of the buckets does not matter.
   */
  buckets?:
    | number[]
    | undefined;
  /** Initial number of bins for the ``circllhist`` thread local histogram per time series. Default value is 100. */
  bins?: number | undefined;
}

/**
 * Stats configuration proto schema for built-in ``envoy.stat_sinks.statsd`` sink. This sink does not support
 * tagged metrics.
 * [#extension: envoy.stat_sinks.statsd]
 */
export interface StatsdSink {
  $type: "envoy.config.metrics.v3.StatsdSink";
  statsd_specifier?:
    | //
    /**
     * The UDP address of a running `statsd <https://github.com/etsy/statsd>`_
     * compliant listener. If specified, statistics will be flushed to this
     * address.
     */
    { $case: "address"; address: Address }
    | //
    /**
     * The name of a cluster that is running a TCP `statsd
     * <https://github.com/etsy/statsd>`_ compliant listener. If specified,
     * Envoy will connect to this cluster to flush statistics.
     */
    { $case: "tcp_cluster_name"; tcp_cluster_name: string }
    | undefined;
  /**
   * Optional custom prefix for StatsdSink. If
   * specified, this will override the default prefix.
   * For example:
   *
   * .. code-block:: json
   *
   *   {
   *     "prefix" : "envoy-prod"
   *   }
   *
   * will change emitted stats to
   *
   * .. code-block:: cpp
   *
   *   envoy-prod.test_counter:1|c
   *   envoy-prod.test_timer:5|ms
   *
   * Note that the default prefix, "envoy", will be used if a prefix is not
   * specified.
   *
   * Stats with default prefix:
   *
   * .. code-block:: cpp
   *
   *   envoy.test_counter:1|c
   *   envoy.test_timer:5|ms
   */
  prefix?: string | undefined;
}

/**
 * Stats configuration proto schema for built-in ``envoy.stat_sinks.dog_statsd`` sink.
 * The sink emits stats with `DogStatsD <https://docs.datadoghq.com/guides/dogstatsd/>`_
 * compatible tags. Tags are configurable via :ref:`StatsConfig
 * <envoy_v3_api_msg_config.metrics.v3.StatsConfig>`.
 * [#extension: envoy.stat_sinks.dog_statsd]
 */
export interface DogStatsdSink {
  $type: "envoy.config.metrics.v3.DogStatsdSink";
  dog_statsd_specifier?:
    | //
    /**
     * The UDP address of a running DogStatsD compliant listener. If specified,
     * statistics will be flushed to this address.
     */
    { $case: "address"; address: Address }
    | undefined;
  /**
   * Optional custom metric name prefix. See :ref:`StatsdSink's prefix field
   * <envoy_v3_api_field_config.metrics.v3.StatsdSink.prefix>` for more details.
   */
  prefix?:
    | string
    | undefined;
  /**
   * Optional max datagram size to use when sending UDP messages. By default Envoy
   * will emit one metric per datagram. By specifying a max-size larger than a single
   * metric, Envoy will emit multiple, new-line separated metrics. The max datagram
   * size should not exceed your network's MTU.
   *
   * Note that this value may not be respected if smaller than a single metric.
   */
  max_bytes_per_datagram?: number | undefined;
}

/**
 * Stats configuration proto schema for built-in ``envoy.stat_sinks.hystrix`` sink.
 * The sink emits stats in `text/event-stream
 * <https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events>`_
 * formatted stream for use by `Hystrix dashboard
 * <https://github.com/Netflix-Skunkworks/hystrix-dashboard/wiki>`_.
 *
 * Note that only a single HystrixSink should be configured.
 *
 * Streaming is started through an admin endpoint :http:get:`/hystrix_event_stream`.
 * [#extension: envoy.stat_sinks.hystrix]
 */
export interface HystrixSink {
  $type: "envoy.config.metrics.v3.HystrixSink";
  /**
   * The number of buckets the rolling statistical window is divided into.
   *
   * Each time the sink is flushed, all relevant Envoy statistics are sampled and
   * added to the rolling window (removing the oldest samples in the window
   * in the process). The sink then outputs the aggregate statistics across the
   * current rolling window to the event stream(s).
   *
   * ``rolling_window(ms)`` = ``stats_flush_interval(ms)`` * ``num_of_buckets``
   *
   * More detailed explanation can be found in `Hystrix wiki
   * <https://github.com/Netflix/Hystrix/wiki/Metrics-and-Monitoring#hystrixrollingnumber>`_.
   */
  num_buckets?: number | undefined;
}

function createBaseStatsSink(): StatsSink {
  return { $type: "envoy.config.metrics.v3.StatsSink", config_type: undefined };
}

export const StatsSink: MessageFns<StatsSink, "envoy.config.metrics.v3.StatsSink"> = {
  $type: "envoy.config.metrics.v3.StatsSink" as const,

  encode(message: StatsSink, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    switch (message.config_type?.$case) {
      case "typed_config":
        Any.encode(message.config_type.typed_config, writer.uint32(26).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StatsSink {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatsSink();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.config_type = { $case: "typed_config", typed_config: Any.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatsSink {
    return {
      $type: StatsSink.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      config_type: isSet(object.typed_config)
        ? { $case: "typed_config", typed_config: Any.fromJSON(object.typed_config) }
        : undefined,
    };
  },

  toJSON(message: StatsSink): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.config_type?.$case === "typed_config") {
      obj.typed_config = Any.toJSON(message.config_type.typed_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StatsSink>, I>>(base?: I): StatsSink {
    return StatsSink.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StatsSink>, I>>(object: I): StatsSink {
    const message = createBaseStatsSink();
    message.name = object.name ?? undefined;
    if (
      object.config_type?.$case === "typed_config" &&
      object.config_type?.typed_config !== undefined &&
      object.config_type?.typed_config !== null
    ) {
      message.config_type = { $case: "typed_config", typed_config: Any.fromPartial(object.config_type.typed_config) };
    }
    return message;
  },
};

messageTypeRegistry.set(StatsSink.$type, StatsSink);

function createBaseStatsConfig(): StatsConfig {
  return { $type: "envoy.config.metrics.v3.StatsConfig" };
}

export const StatsConfig: MessageFns<StatsConfig, "envoy.config.metrics.v3.StatsConfig"> = {
  $type: "envoy.config.metrics.v3.StatsConfig" as const,

  encode(message: StatsConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stats_tags !== undefined && message.stats_tags.length !== 0) {
      for (const v of message.stats_tags) {
        TagSpecifier.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    if (message.use_all_default_tags !== undefined) {
      BoolValue.encode(
        { $type: "google.protobuf.BoolValue", value: message.use_all_default_tags! },
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.stats_matcher !== undefined) {
      StatsMatcher.encode(message.stats_matcher, writer.uint32(26).fork()).join();
    }
    if (message.histogram_bucket_settings !== undefined && message.histogram_bucket_settings.length !== 0) {
      for (const v of message.histogram_bucket_settings) {
        HistogramBucketSettings.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StatsConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatsConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.stats_tags === undefined) {
            message.stats_tags = [];
          }
          const el = TagSpecifier.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.stats_tags!.push(el);
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.use_all_default_tags = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.stats_matcher = StatsMatcher.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          if (message.histogram_bucket_settings === undefined) {
            message.histogram_bucket_settings = [];
          }
          const el = HistogramBucketSettings.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.histogram_bucket_settings!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatsConfig {
    return {
      $type: StatsConfig.$type,
      stats_tags: globalThis.Array.isArray(object?.stats_tags)
        ? object.stats_tags.map((e: any) => TagSpecifier.fromJSON(e))
        : undefined,
      use_all_default_tags: isSet(object.use_all_default_tags) ? Boolean(object.use_all_default_tags) : undefined,
      stats_matcher: isSet(object.stats_matcher) ? StatsMatcher.fromJSON(object.stats_matcher) : undefined,
      histogram_bucket_settings: globalThis.Array.isArray(object?.histogram_bucket_settings)
        ? object.histogram_bucket_settings.map((e: any) => HistogramBucketSettings.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: StatsConfig): unknown {
    const obj: any = {};
    if (message.stats_tags?.length) {
      obj.stats_tags = message.stats_tags.map((e) => TagSpecifier.toJSON(e));
    }
    if (message.use_all_default_tags !== undefined) {
      obj.use_all_default_tags = message.use_all_default_tags;
    }
    if (message.stats_matcher !== undefined) {
      obj.stats_matcher = StatsMatcher.toJSON(message.stats_matcher);
    }
    if (message.histogram_bucket_settings?.length) {
      obj.histogram_bucket_settings = message.histogram_bucket_settings.map((e) => HistogramBucketSettings.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StatsConfig>, I>>(base?: I): StatsConfig {
    return StatsConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StatsConfig>, I>>(object: I): StatsConfig {
    const message = createBaseStatsConfig();
    message.stats_tags = object.stats_tags?.map((e) => TagSpecifier.fromPartial(e)) || undefined;
    message.use_all_default_tags = object.use_all_default_tags ?? undefined;
    message.stats_matcher = (object.stats_matcher !== undefined && object.stats_matcher !== null)
      ? StatsMatcher.fromPartial(object.stats_matcher)
      : undefined;
    message.histogram_bucket_settings =
      object.histogram_bucket_settings?.map((e) => HistogramBucketSettings.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(StatsConfig.$type, StatsConfig);

function createBaseStatsMatcher(): StatsMatcher {
  return { $type: "envoy.config.metrics.v3.StatsMatcher", stats_matcher: undefined };
}

export const StatsMatcher: MessageFns<StatsMatcher, "envoy.config.metrics.v3.StatsMatcher"> = {
  $type: "envoy.config.metrics.v3.StatsMatcher" as const,

  encode(message: StatsMatcher, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.stats_matcher?.$case) {
      case "reject_all":
        writer.uint32(8).bool(message.stats_matcher.reject_all);
        break;
      case "exclusion_list":
        ListStringMatcher.encode(message.stats_matcher.exclusion_list, writer.uint32(18).fork()).join();
        break;
      case "inclusion_list":
        ListStringMatcher.encode(message.stats_matcher.inclusion_list, writer.uint32(26).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StatsMatcher {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatsMatcher();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.stats_matcher = { $case: "reject_all", reject_all: reader.bool() };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stats_matcher = {
            $case: "exclusion_list",
            exclusion_list: ListStringMatcher.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.stats_matcher = {
            $case: "inclusion_list",
            inclusion_list: ListStringMatcher.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatsMatcher {
    return {
      $type: StatsMatcher.$type,
      stats_matcher: isSet(object.reject_all)
        ? { $case: "reject_all", reject_all: globalThis.Boolean(object.reject_all) }
        : isSet(object.exclusion_list)
        ? { $case: "exclusion_list", exclusion_list: ListStringMatcher.fromJSON(object.exclusion_list) }
        : isSet(object.inclusion_list)
        ? { $case: "inclusion_list", inclusion_list: ListStringMatcher.fromJSON(object.inclusion_list) }
        : undefined,
    };
  },

  toJSON(message: StatsMatcher): unknown {
    const obj: any = {};
    if (message.stats_matcher?.$case === "reject_all") {
      obj.reject_all = message.stats_matcher.reject_all;
    }
    if (message.stats_matcher?.$case === "exclusion_list") {
      obj.exclusion_list = ListStringMatcher.toJSON(message.stats_matcher.exclusion_list);
    }
    if (message.stats_matcher?.$case === "inclusion_list") {
      obj.inclusion_list = ListStringMatcher.toJSON(message.stats_matcher.inclusion_list);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StatsMatcher>, I>>(base?: I): StatsMatcher {
    return StatsMatcher.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StatsMatcher>, I>>(object: I): StatsMatcher {
    const message = createBaseStatsMatcher();
    if (
      object.stats_matcher?.$case === "reject_all" &&
      object.stats_matcher?.reject_all !== undefined &&
      object.stats_matcher?.reject_all !== null
    ) {
      message.stats_matcher = { $case: "reject_all", reject_all: object.stats_matcher.reject_all };
    }
    if (
      object.stats_matcher?.$case === "exclusion_list" &&
      object.stats_matcher?.exclusion_list !== undefined &&
      object.stats_matcher?.exclusion_list !== null
    ) {
      message.stats_matcher = {
        $case: "exclusion_list",
        exclusion_list: ListStringMatcher.fromPartial(object.stats_matcher.exclusion_list),
      };
    }
    if (
      object.stats_matcher?.$case === "inclusion_list" &&
      object.stats_matcher?.inclusion_list !== undefined &&
      object.stats_matcher?.inclusion_list !== null
    ) {
      message.stats_matcher = {
        $case: "inclusion_list",
        inclusion_list: ListStringMatcher.fromPartial(object.stats_matcher.inclusion_list),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(StatsMatcher.$type, StatsMatcher);

function createBaseTagSpecifier(): TagSpecifier {
  return { $type: "envoy.config.metrics.v3.TagSpecifier", tag_value: undefined };
}

export const TagSpecifier: MessageFns<TagSpecifier, "envoy.config.metrics.v3.TagSpecifier"> = {
  $type: "envoy.config.metrics.v3.TagSpecifier" as const,

  encode(message: TagSpecifier, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tag_name !== undefined && message.tag_name !== "") {
      writer.uint32(10).string(message.tag_name);
    }
    switch (message.tag_value?.$case) {
      case "regex":
        writer.uint32(18).string(message.tag_value.regex);
        break;
      case "fixed_value":
        writer.uint32(26).string(message.tag_value.fixed_value);
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TagSpecifier {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTagSpecifier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tag_name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tag_value = { $case: "regex", regex: reader.string() };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tag_value = { $case: "fixed_value", fixed_value: reader.string() };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TagSpecifier {
    return {
      $type: TagSpecifier.$type,
      tag_name: isSet(object.tag_name) ? globalThis.String(object.tag_name) : undefined,
      tag_value: isSet(object.regex)
        ? { $case: "regex", regex: globalThis.String(object.regex) }
        : isSet(object.fixed_value)
        ? { $case: "fixed_value", fixed_value: globalThis.String(object.fixed_value) }
        : undefined,
    };
  },

  toJSON(message: TagSpecifier): unknown {
    const obj: any = {};
    if (message.tag_name !== undefined) {
      obj.tag_name = message.tag_name;
    }
    if (message.tag_value?.$case === "regex") {
      obj.regex = message.tag_value.regex;
    }
    if (message.tag_value?.$case === "fixed_value") {
      obj.fixed_value = message.tag_value.fixed_value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TagSpecifier>, I>>(base?: I): TagSpecifier {
    return TagSpecifier.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TagSpecifier>, I>>(object: I): TagSpecifier {
    const message = createBaseTagSpecifier();
    message.tag_name = object.tag_name ?? undefined;
    if (
      object.tag_value?.$case === "regex" && object.tag_value?.regex !== undefined && object.tag_value?.regex !== null
    ) {
      message.tag_value = { $case: "regex", regex: object.tag_value.regex };
    }
    if (
      object.tag_value?.$case === "fixed_value" &&
      object.tag_value?.fixed_value !== undefined &&
      object.tag_value?.fixed_value !== null
    ) {
      message.tag_value = { $case: "fixed_value", fixed_value: object.tag_value.fixed_value };
    }
    return message;
  },
};

messageTypeRegistry.set(TagSpecifier.$type, TagSpecifier);

function createBaseHistogramBucketSettings(): HistogramBucketSettings {
  return { $type: "envoy.config.metrics.v3.HistogramBucketSettings" };
}

export const HistogramBucketSettings: MessageFns<
  HistogramBucketSettings,
  "envoy.config.metrics.v3.HistogramBucketSettings"
> = {
  $type: "envoy.config.metrics.v3.HistogramBucketSettings" as const,

  encode(message: HistogramBucketSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.match !== undefined) {
      StringMatcher.encode(message.match, writer.uint32(10).fork()).join();
    }
    if (message.buckets !== undefined && message.buckets.length !== 0) {
      writer.uint32(18).fork();
      for (const v of message.buckets) {
        writer.double(v);
      }
      writer.join();
    }
    if (message.bins !== undefined) {
      UInt32Value.encode({ $type: "google.protobuf.UInt32Value", value: message.bins! }, writer.uint32(26).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HistogramBucketSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHistogramBucketSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.match = StringMatcher.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag === 17) {
            if (message.buckets === undefined) {
              message.buckets = [];
            }
            message.buckets!.push(reader.double());

            continue;
          }

          if (tag === 18) {
            if (message.buckets === undefined) {
              message.buckets = [];
            }
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.buckets!.push(reader.double());
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bins = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HistogramBucketSettings {
    return {
      $type: HistogramBucketSettings.$type,
      match: isSet(object.match) ? StringMatcher.fromJSON(object.match) : undefined,
      buckets: globalThis.Array.isArray(object?.buckets)
        ? object.buckets.map((e: any) => globalThis.Number(e))
        : undefined,
      bins: isSet(object.bins) ? Number(object.bins) : undefined,
    };
  },

  toJSON(message: HistogramBucketSettings): unknown {
    const obj: any = {};
    if (message.match !== undefined) {
      obj.match = StringMatcher.toJSON(message.match);
    }
    if (message.buckets?.length) {
      obj.buckets = message.buckets;
    }
    if (message.bins !== undefined) {
      obj.bins = message.bins;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HistogramBucketSettings>, I>>(base?: I): HistogramBucketSettings {
    return HistogramBucketSettings.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HistogramBucketSettings>, I>>(object: I): HistogramBucketSettings {
    const message = createBaseHistogramBucketSettings();
    message.match = (object.match !== undefined && object.match !== null)
      ? StringMatcher.fromPartial(object.match)
      : undefined;
    message.buckets = object.buckets?.map((e) => e) || undefined;
    message.bins = object.bins ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(HistogramBucketSettings.$type, HistogramBucketSettings);

function createBaseStatsdSink(): StatsdSink {
  return { $type: "envoy.config.metrics.v3.StatsdSink", statsd_specifier: undefined };
}

export const StatsdSink: MessageFns<StatsdSink, "envoy.config.metrics.v3.StatsdSink"> = {
  $type: "envoy.config.metrics.v3.StatsdSink" as const,

  encode(message: StatsdSink, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.statsd_specifier?.$case) {
      case "address":
        Address.encode(message.statsd_specifier.address, writer.uint32(10).fork()).join();
        break;
      case "tcp_cluster_name":
        writer.uint32(18).string(message.statsd_specifier.tcp_cluster_name);
        break;
    }
    if (message.prefix !== undefined && message.prefix !== "") {
      writer.uint32(26).string(message.prefix);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StatsdSink {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatsdSink();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.statsd_specifier = { $case: "address", address: Address.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.statsd_specifier = { $case: "tcp_cluster_name", tcp_cluster_name: reader.string() };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.prefix = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatsdSink {
    return {
      $type: StatsdSink.$type,
      statsd_specifier: isSet(object.address)
        ? { $case: "address", address: Address.fromJSON(object.address) }
        : isSet(object.tcp_cluster_name)
        ? { $case: "tcp_cluster_name", tcp_cluster_name: globalThis.String(object.tcp_cluster_name) }
        : undefined,
      prefix: isSet(object.prefix) ? globalThis.String(object.prefix) : undefined,
    };
  },

  toJSON(message: StatsdSink): unknown {
    const obj: any = {};
    if (message.statsd_specifier?.$case === "address") {
      obj.address = Address.toJSON(message.statsd_specifier.address);
    }
    if (message.statsd_specifier?.$case === "tcp_cluster_name") {
      obj.tcp_cluster_name = message.statsd_specifier.tcp_cluster_name;
    }
    if (message.prefix !== undefined) {
      obj.prefix = message.prefix;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StatsdSink>, I>>(base?: I): StatsdSink {
    return StatsdSink.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StatsdSink>, I>>(object: I): StatsdSink {
    const message = createBaseStatsdSink();
    if (
      object.statsd_specifier?.$case === "address" &&
      object.statsd_specifier?.address !== undefined &&
      object.statsd_specifier?.address !== null
    ) {
      message.statsd_specifier = { $case: "address", address: Address.fromPartial(object.statsd_specifier.address) };
    }
    if (
      object.statsd_specifier?.$case === "tcp_cluster_name" &&
      object.statsd_specifier?.tcp_cluster_name !== undefined &&
      object.statsd_specifier?.tcp_cluster_name !== null
    ) {
      message.statsd_specifier = {
        $case: "tcp_cluster_name",
        tcp_cluster_name: object.statsd_specifier.tcp_cluster_name,
      };
    }
    message.prefix = object.prefix ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(StatsdSink.$type, StatsdSink);

function createBaseDogStatsdSink(): DogStatsdSink {
  return { $type: "envoy.config.metrics.v3.DogStatsdSink", dog_statsd_specifier: undefined };
}

export const DogStatsdSink: MessageFns<DogStatsdSink, "envoy.config.metrics.v3.DogStatsdSink"> = {
  $type: "envoy.config.metrics.v3.DogStatsdSink" as const,

  encode(message: DogStatsdSink, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.dog_statsd_specifier?.$case) {
      case "address":
        Address.encode(message.dog_statsd_specifier.address, writer.uint32(10).fork()).join();
        break;
    }
    if (message.prefix !== undefined && message.prefix !== "") {
      writer.uint32(26).string(message.prefix);
    }
    if (message.max_bytes_per_datagram !== undefined) {
      UInt64Value.encode(
        { $type: "google.protobuf.UInt64Value", value: message.max_bytes_per_datagram! },
        writer.uint32(34).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DogStatsdSink {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDogStatsdSink();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.dog_statsd_specifier = { $case: "address", address: Address.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.prefix = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.max_bytes_per_datagram = UInt64Value.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DogStatsdSink {
    return {
      $type: DogStatsdSink.$type,
      dog_statsd_specifier: isSet(object.address)
        ? { $case: "address", address: Address.fromJSON(object.address) }
        : undefined,
      prefix: isSet(object.prefix) ? globalThis.String(object.prefix) : undefined,
      max_bytes_per_datagram: isSet(object.max_bytes_per_datagram) ? Number(object.max_bytes_per_datagram) : undefined,
    };
  },

  toJSON(message: DogStatsdSink): unknown {
    const obj: any = {};
    if (message.dog_statsd_specifier?.$case === "address") {
      obj.address = Address.toJSON(message.dog_statsd_specifier.address);
    }
    if (message.prefix !== undefined) {
      obj.prefix = message.prefix;
    }
    if (message.max_bytes_per_datagram !== undefined) {
      obj.max_bytes_per_datagram = message.max_bytes_per_datagram;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DogStatsdSink>, I>>(base?: I): DogStatsdSink {
    return DogStatsdSink.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DogStatsdSink>, I>>(object: I): DogStatsdSink {
    const message = createBaseDogStatsdSink();
    if (
      object.dog_statsd_specifier?.$case === "address" &&
      object.dog_statsd_specifier?.address !== undefined &&
      object.dog_statsd_specifier?.address !== null
    ) {
      message.dog_statsd_specifier = {
        $case: "address",
        address: Address.fromPartial(object.dog_statsd_specifier.address),
      };
    }
    message.prefix = object.prefix ?? undefined;
    message.max_bytes_per_datagram = object.max_bytes_per_datagram ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(DogStatsdSink.$type, DogStatsdSink);

function createBaseHystrixSink(): HystrixSink {
  return { $type: "envoy.config.metrics.v3.HystrixSink" };
}

export const HystrixSink: MessageFns<HystrixSink, "envoy.config.metrics.v3.HystrixSink"> = {
  $type: "envoy.config.metrics.v3.HystrixSink" as const,

  encode(message: HystrixSink, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.num_buckets !== undefined && message.num_buckets !== 0) {
      writer.uint32(8).int64(message.num_buckets);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HystrixSink {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHystrixSink();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.num_buckets = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HystrixSink {
    return {
      $type: HystrixSink.$type,
      num_buckets: isSet(object.num_buckets) ? globalThis.Number(object.num_buckets) : undefined,
    };
  },

  toJSON(message: HystrixSink): unknown {
    const obj: any = {};
    if (message.num_buckets !== undefined) {
      obj.num_buckets = Math.round(message.num_buckets);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HystrixSink>, I>>(base?: I): HystrixSink {
    return HystrixSink.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HystrixSink>, I>>(object: I): HystrixSink {
    const message = createBaseHystrixSink();
    message.num_buckets = object.num_buckets ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(HystrixSink.$type, HystrixSink);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
