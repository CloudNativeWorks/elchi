// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: google/api/expr/v1alpha1/syntax.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { messageTypeRegistry } from "../../../../typeRegistry";
import { Duration } from "../../../protobuf/duration";
import { NullValue, nullValueFromJSON, nullValueToJSON, nullValueToNumber } from "../../../protobuf/struct";
import { Timestamp } from "../../../protobuf/timestamp";

export const protobufPackage = "google.api.expr.v1alpha1";

/** An expression together with source information as returned by the parser. */
export interface ParsedExpr {
  $type: "google.api.expr.v1alpha1.ParsedExpr";
  /** The parsed expression. */
  expr?:
    | Expr
    | undefined;
  /** The source info derived from input that generated the parsed `expr`. */
  source_info?: SourceInfo | undefined;
}

/**
 * An abstract representation of a common expression.
 *
 * Expressions are abstractly represented as a collection of identifiers,
 * select statements, function calls, literals, and comprehensions. All
 * operators with the exception of the '.' operator are modelled as function
 * calls. This makes it easy to represent new operators into the existing AST.
 *
 * All references within expressions must resolve to a [Decl][google.api.expr.v1alpha1.Decl] provided at
 * type-check for an expression to be valid. A reference may either be a bare
 * identifier `name` or a qualified identifier `google.api.name`. References
 * may either refer to a value or a function declaration.
 *
 * For example, the expression `google.api.name.startsWith('expr')` references
 * the declaration `google.api.name` within a [Expr.Select][google.api.expr.v1alpha1.Expr.Select] expression, and
 * the function declaration `startsWith`.
 */
export interface Expr {
  $type: "google.api.expr.v1alpha1.Expr";
  /**
   * Required. An id assigned to this node by the parser which is unique in a
   * given expression tree. This is used to associate type information and other
   * attributes to a node in the parse tree.
   */
  id?:
    | number
    | undefined;
  /** Required. Variants of expressions. */
  expr_kind?:
    | //
    /** A literal expression. */
    { $case: "const_expr"; const_expr: Constant }
    | //
    /** An identifier expression. */
    { $case: "ident_expr"; ident_expr: Expr_Ident }
    | //
    /** A field selection expression, e.g. `request.auth`. */
    { $case: "select_expr"; select_expr: Expr_Select }
    | //
    /** A call expression, including calls to predefined functions and operators. */
    { $case: "call_expr"; call_expr: Expr_Call }
    | //
    /** A list creation expression. */
    { $case: "list_expr"; list_expr: Expr_CreateList }
    | //
    /** A map or message creation expression. */
    { $case: "struct_expr"; struct_expr: Expr_CreateStruct }
    | //
    /** A comprehension expression. */
    { $case: "comprehension_expr"; comprehension_expr: Expr_Comprehension }
    | undefined;
}

/** An identifier expression. e.g. `request`. */
export interface Expr_Ident {
  $type: "google.api.expr.v1alpha1.Expr.Ident";
  /**
   * Required. Holds a single, unqualified identifier, possibly preceded by a
   * '.'.
   *
   * Qualified names are represented by the [Expr.Select][google.api.expr.v1alpha1.Expr.Select] expression.
   */
  name?: string | undefined;
}

/** A field selection expression. e.g. `request.auth`. */
export interface Expr_Select {
  $type: "google.api.expr.v1alpha1.Expr.Select";
  /**
   * Required. The target of the selection expression.
   *
   * For example, in the select expression `request.auth`, the `request`
   * portion of the expression is the `operand`.
   */
  operand?:
    | Expr
    | undefined;
  /**
   * Required. The name of the field to select.
   *
   * For example, in the select expression `request.auth`, the `auth` portion
   * of the expression would be the `field`.
   */
  field?:
    | string
    | undefined;
  /**
   * Whether the select is to be interpreted as a field presence test.
   *
   * This results from the macro `has(request.auth)`.
   */
  test_only?: boolean | undefined;
}

/**
 * A call expression, including calls to predefined functions and operators.
 *
 * For example, `value == 10`, `size(map_value)`.
 */
export interface Expr_Call {
  $type: "google.api.expr.v1alpha1.Expr.Call";
  /**
   * The target of an method call-style expression. For example, `x` in
   * `x.f()`.
   */
  target?:
    | Expr
    | undefined;
  /** Required. The name of the function or method being called. */
  function?:
    | string
    | undefined;
  /** The arguments. */
  args?: Expr[] | undefined;
}

/**
 * A list creation expression.
 *
 * Lists may either be homogenous, e.g. `[1, 2, 3]`, or heterogeneous, e.g.
 * `dyn([1, 'hello', 2.0])`
 */
export interface Expr_CreateList {
  $type: "google.api.expr.v1alpha1.Expr.CreateList";
  /** The elements part of the list. */
  elements?: Expr[] | undefined;
}

/**
 * A map or message creation expression.
 *
 * Maps are constructed as `{'key_name': 'value'}`. Message construction is
 * similar, but prefixed with a type name and composed of field ids:
 * `types.MyType{field_id: 'value'}`.
 */
export interface Expr_CreateStruct {
  $type: "google.api.expr.v1alpha1.Expr.CreateStruct";
  /**
   * The type name of the message to be created, empty when creating map
   * literals.
   */
  message_name?:
    | string
    | undefined;
  /** The entries in the creation expression. */
  entries?: Expr_CreateStruct_Entry[] | undefined;
}

/** Represents an entry. */
export interface Expr_CreateStruct_Entry {
  $type: "google.api.expr.v1alpha1.Expr.CreateStruct.Entry";
  /**
   * Required. An id assigned to this node by the parser which is unique
   * in a given expression tree. This is used to associate type
   * information and other attributes to the node.
   */
  id?:
    | number
    | undefined;
  /** The `Entry` key kinds. */
  key_kind?:
    | //
    /** The field key for a message creator statement. */
    { $case: "field_key"; field_key: string }
    | //
    /** The key expression for a map creation statement. */
    { $case: "map_key"; map_key: Expr }
    | undefined;
  /** Required. The value assigned to the key. */
  value?: Expr | undefined;
}

/**
 * A comprehension expression applied to a list or map.
 *
 * Comprehensions are not part of the core syntax, but enabled with macros.
 * A macro matches a specific call signature within a parsed AST and replaces
 * the call with an alternate AST block. Macro expansion happens at parse
 * time.
 *
 * The following macros are supported within CEL:
 *
 * Aggregate type macros may be applied to all elements in a list or all keys
 * in a map:
 *
 * *  `all`, `exists`, `exists_one` -  test a predicate expression against
 *    the inputs and return `true` if the predicate is satisfied for all,
 *    any, or only one value `list.all(x, x < 10)`.
 * *  `filter` - test a predicate expression against the inputs and return
 *    the subset of elements which satisfy the predicate:
 *    `payments.filter(p, p > 1000)`.
 * *  `map` - apply an expression to all elements in the input and return the
 *    output aggregate type: `[1, 2, 3].map(i, i * i)`.
 *
 * The `has(m.x)` macro tests whether the property `x` is present in struct
 * `m`. The semantics of this macro depend on the type of `m`. For proto2
 * messages `has(m.x)` is defined as 'defined, but not set`. For proto3, the
 * macro tests whether the property is set to its default. For map and struct
 * types, the macro tests whether the property `x` is defined on `m`.
 */
export interface Expr_Comprehension {
  $type: "google.api.expr.v1alpha1.Expr.Comprehension";
  /** The name of the iteration variable. */
  iter_var?:
    | string
    | undefined;
  /** The range over which var iterates. */
  iter_range?:
    | Expr
    | undefined;
  /** The name of the variable used for accumulation of the result. */
  accu_var?:
    | string
    | undefined;
  /** The initial value of the accumulator. */
  accu_init?:
    | Expr
    | undefined;
  /**
   * An expression which can contain iter_var and accu_var.
   *
   * Returns false when the result has been computed and may be used as
   * a hint to short-circuit the remainder of the comprehension.
   */
  loop_condition?:
    | Expr
    | undefined;
  /**
   * An expression which can contain iter_var and accu_var.
   *
   * Computes the next value of accu_var.
   */
  loop_step?:
    | Expr
    | undefined;
  /**
   * An expression which can contain accu_var.
   *
   * Computes the result.
   */
  result?: Expr | undefined;
}

/**
 * Represents a primitive literal.
 *
 * Named 'Constant' here for backwards compatibility.
 *
 * This is similar as the primitives supported in the well-known type
 * `google.protobuf.Value`, but richer so it can represent CEL's full range of
 * primitives.
 *
 * Lists and structs are not included as constants as these aggregate types may
 * contain [Expr][google.api.expr.v1alpha1.Expr] elements which require evaluation and are thus not constant.
 *
 * Examples of literals include: `"hello"`, `b'bytes'`, `1u`, `4.2`, `-2`,
 * `true`, `null`.
 */
export interface Constant {
  $type: "google.api.expr.v1alpha1.Constant";
  /** Required. The valid constant kinds. */
  constant_kind?:
    | //
    /** null value. */
    { $case: "null_value"; null_value: NullValue }
    | //
    /** boolean value. */
    { $case: "bool_value"; bool_value: boolean }
    | //
    /** int64 value. */
    { $case: "int64_value"; int64_value: number }
    | //
    /** uint64 value. */
    { $case: "uint64_value"; uint64_value: number }
    | //
    /** double value. */
    { $case: "double_value"; double_value: number }
    | //
    /** string value. */
    { $case: "string_value"; string_value: string }
    | //
    /** bytes value. */
    { $case: "bytes_value"; bytes_value: Uint8Array }
    | //
    /**
     * protobuf.Duration value.
     *
     * Deprecated: duration is no longer considered a builtin cel type.
     */
    { $case: "duration_value"; duration_value: Duration }
    | //
    /**
     * protobuf.Timestamp value.
     *
     * Deprecated: timestamp is no longer considered a builtin cel type.
     */
    { $case: "timestamp_value"; timestamp_value: Date }
    | undefined;
}

/** Source information collected at parse time. */
export interface SourceInfo {
  $type: "google.api.expr.v1alpha1.SourceInfo";
  /** The syntax version of the source, e.g. `cel1`. */
  syntax_version?:
    | string
    | undefined;
  /**
   * The location name. All position information attached to an expression is
   * relative to this location.
   *
   * The location could be a file, UI element, or similar. For example,
   * `acme/app/AnvilPolicy.cel`.
   */
  location?:
    | string
    | undefined;
  /**
   * Monotonically increasing list of code point offsets where newlines
   * `\n` appear.
   *
   * The line number of a given position is the index `i` where for a given
   * `id` the `line_offsets[i] < id_positions[id] < line_offsets[i+1]`. The
   * column may be derivd from `id_positions[id] - line_offsets[i]`.
   */
  line_offsets?:
    | number[]
    | undefined;
  /**
   * A map from the parse node id (e.g. `Expr.id`) to the code point offset
   * within the source.
   */
  positions?:
    | Map<number, number>
    | undefined;
  /**
   * A map from the parse node id where a macro replacement was made to the
   * call `Expr` that resulted in a macro expansion.
   *
   * For example, `has(value.field)` is a function call that is replaced by a
   * `test_only` field selection in the AST. Likewise, the call
   * `list.exists(e, e > 10)` translates to a comprehension expression. The key
   * in the map corresponds to the expression id of the expanded macro, and the
   * value is the call `Expr` that was replaced.
   */
  macro_calls?: Map<number, Expr> | undefined;
}

export interface SourceInfo_PositionsEntry {
  $type: "google.api.expr.v1alpha1.SourceInfo.PositionsEntry";
  key: number;
  value: number;
}

export interface SourceInfo_MacroCallsEntry {
  $type: "google.api.expr.v1alpha1.SourceInfo.MacroCallsEntry";
  key: number;
  value?: Expr | undefined;
}

/** A specific position in source. */
export interface SourcePosition {
  $type: "google.api.expr.v1alpha1.SourcePosition";
  /** The soucre location name (e.g. file name). */
  location?:
    | string
    | undefined;
  /** The UTF-8 code unit offset. */
  offset?:
    | number
    | undefined;
  /**
   * The 1-based index of the starting line in the source text
   * where the issue occurs, or 0 if unknown.
   */
  line?:
    | number
    | undefined;
  /**
   * The 0-based index of the starting position within the line of source text
   * where the issue occurs.  Only meaningful if line is nonzero.
   */
  column?: number | undefined;
}

function createBaseParsedExpr(): ParsedExpr {
  return { $type: "google.api.expr.v1alpha1.ParsedExpr" };
}

export const ParsedExpr: MessageFns<ParsedExpr, "google.api.expr.v1alpha1.ParsedExpr"> = {
  $type: "google.api.expr.v1alpha1.ParsedExpr" as const,

  encode(message: ParsedExpr, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expr !== undefined) {
      Expr.encode(message.expr, writer.uint32(18).fork()).join();
    }
    if (message.source_info !== undefined) {
      SourceInfo.encode(message.source_info, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParsedExpr {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParsedExpr();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.expr = Expr.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.source_info = SourceInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParsedExpr {
    return {
      $type: ParsedExpr.$type,
      expr: isSet(object.expr) ? Expr.fromJSON(object.expr) : undefined,
      source_info: isSet(object.source_info) ? SourceInfo.fromJSON(object.source_info) : undefined,
    };
  },

  toJSON(message: ParsedExpr): unknown {
    const obj: any = {};
    if (message.expr !== undefined) {
      obj.expr = Expr.toJSON(message.expr);
    }
    if (message.source_info !== undefined) {
      obj.source_info = SourceInfo.toJSON(message.source_info);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParsedExpr>, I>>(base?: I): ParsedExpr {
    return ParsedExpr.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParsedExpr>, I>>(object: I): ParsedExpr {
    const message = createBaseParsedExpr();
    message.expr = (object.expr !== undefined && object.expr !== null) ? Expr.fromPartial(object.expr) : undefined;
    message.source_info = (object.source_info !== undefined && object.source_info !== null)
      ? SourceInfo.fromPartial(object.source_info)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(ParsedExpr.$type, ParsedExpr);

function createBaseExpr(): Expr {
  return { $type: "google.api.expr.v1alpha1.Expr", expr_kind: undefined };
}

export const Expr: MessageFns<Expr, "google.api.expr.v1alpha1.Expr"> = {
  $type: "google.api.expr.v1alpha1.Expr" as const,

  encode(message: Expr, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined && message.id !== 0) {
      writer.uint32(16).int64(message.id);
    }
    switch (message.expr_kind?.$case) {
      case "const_expr":
        Constant.encode(message.expr_kind.const_expr, writer.uint32(26).fork()).join();
        break;
      case "ident_expr":
        Expr_Ident.encode(message.expr_kind.ident_expr, writer.uint32(34).fork()).join();
        break;
      case "select_expr":
        Expr_Select.encode(message.expr_kind.select_expr, writer.uint32(42).fork()).join();
        break;
      case "call_expr":
        Expr_Call.encode(message.expr_kind.call_expr, writer.uint32(50).fork()).join();
        break;
      case "list_expr":
        Expr_CreateList.encode(message.expr_kind.list_expr, writer.uint32(58).fork()).join();
        break;
      case "struct_expr":
        Expr_CreateStruct.encode(message.expr_kind.struct_expr, writer.uint32(66).fork()).join();
        break;
      case "comprehension_expr":
        Expr_Comprehension.encode(message.expr_kind.comprehension_expr, writer.uint32(74).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Expr {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExpr();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.id = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.expr_kind = { $case: "const_expr", const_expr: Constant.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.expr_kind = { $case: "ident_expr", ident_expr: Expr_Ident.decode(reader, reader.uint32()) };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.expr_kind = { $case: "select_expr", select_expr: Expr_Select.decode(reader, reader.uint32()) };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.expr_kind = { $case: "call_expr", call_expr: Expr_Call.decode(reader, reader.uint32()) };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.expr_kind = { $case: "list_expr", list_expr: Expr_CreateList.decode(reader, reader.uint32()) };
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.expr_kind = { $case: "struct_expr", struct_expr: Expr_CreateStruct.decode(reader, reader.uint32()) };
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.expr_kind = {
            $case: "comprehension_expr",
            comprehension_expr: Expr_Comprehension.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Expr {
    return {
      $type: Expr.$type,
      id: isSet(object.id) ? globalThis.Number(object.id) : undefined,
      expr_kind: isSet(object.const_expr)
        ? { $case: "const_expr", const_expr: Constant.fromJSON(object.const_expr) }
        : isSet(object.ident_expr)
        ? { $case: "ident_expr", ident_expr: Expr_Ident.fromJSON(object.ident_expr) }
        : isSet(object.select_expr)
        ? { $case: "select_expr", select_expr: Expr_Select.fromJSON(object.select_expr) }
        : isSet(object.call_expr)
        ? { $case: "call_expr", call_expr: Expr_Call.fromJSON(object.call_expr) }
        : isSet(object.list_expr)
        ? { $case: "list_expr", list_expr: Expr_CreateList.fromJSON(object.list_expr) }
        : isSet(object.struct_expr)
        ? { $case: "struct_expr", struct_expr: Expr_CreateStruct.fromJSON(object.struct_expr) }
        : isSet(object.comprehension_expr)
        ? { $case: "comprehension_expr", comprehension_expr: Expr_Comprehension.fromJSON(object.comprehension_expr) }
        : undefined,
    };
  },

  toJSON(message: Expr): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = Math.round(message.id);
    }
    if (message.expr_kind?.$case === "const_expr") {
      obj.const_expr = Constant.toJSON(message.expr_kind.const_expr);
    }
    if (message.expr_kind?.$case === "ident_expr") {
      obj.ident_expr = Expr_Ident.toJSON(message.expr_kind.ident_expr);
    }
    if (message.expr_kind?.$case === "select_expr") {
      obj.select_expr = Expr_Select.toJSON(message.expr_kind.select_expr);
    }
    if (message.expr_kind?.$case === "call_expr") {
      obj.call_expr = Expr_Call.toJSON(message.expr_kind.call_expr);
    }
    if (message.expr_kind?.$case === "list_expr") {
      obj.list_expr = Expr_CreateList.toJSON(message.expr_kind.list_expr);
    }
    if (message.expr_kind?.$case === "struct_expr") {
      obj.struct_expr = Expr_CreateStruct.toJSON(message.expr_kind.struct_expr);
    }
    if (message.expr_kind?.$case === "comprehension_expr") {
      obj.comprehension_expr = Expr_Comprehension.toJSON(message.expr_kind.comprehension_expr);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Expr>, I>>(base?: I): Expr {
    return Expr.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Expr>, I>>(object: I): Expr {
    const message = createBaseExpr();
    message.id = object.id ?? undefined;
    if (
      object.expr_kind?.$case === "const_expr" &&
      object.expr_kind?.const_expr !== undefined &&
      object.expr_kind?.const_expr !== null
    ) {
      message.expr_kind = { $case: "const_expr", const_expr: Constant.fromPartial(object.expr_kind.const_expr) };
    }
    if (
      object.expr_kind?.$case === "ident_expr" &&
      object.expr_kind?.ident_expr !== undefined &&
      object.expr_kind?.ident_expr !== null
    ) {
      message.expr_kind = { $case: "ident_expr", ident_expr: Expr_Ident.fromPartial(object.expr_kind.ident_expr) };
    }
    if (
      object.expr_kind?.$case === "select_expr" &&
      object.expr_kind?.select_expr !== undefined &&
      object.expr_kind?.select_expr !== null
    ) {
      message.expr_kind = { $case: "select_expr", select_expr: Expr_Select.fromPartial(object.expr_kind.select_expr) };
    }
    if (
      object.expr_kind?.$case === "call_expr" &&
      object.expr_kind?.call_expr !== undefined &&
      object.expr_kind?.call_expr !== null
    ) {
      message.expr_kind = { $case: "call_expr", call_expr: Expr_Call.fromPartial(object.expr_kind.call_expr) };
    }
    if (
      object.expr_kind?.$case === "list_expr" &&
      object.expr_kind?.list_expr !== undefined &&
      object.expr_kind?.list_expr !== null
    ) {
      message.expr_kind = { $case: "list_expr", list_expr: Expr_CreateList.fromPartial(object.expr_kind.list_expr) };
    }
    if (
      object.expr_kind?.$case === "struct_expr" &&
      object.expr_kind?.struct_expr !== undefined &&
      object.expr_kind?.struct_expr !== null
    ) {
      message.expr_kind = {
        $case: "struct_expr",
        struct_expr: Expr_CreateStruct.fromPartial(object.expr_kind.struct_expr),
      };
    }
    if (
      object.expr_kind?.$case === "comprehension_expr" &&
      object.expr_kind?.comprehension_expr !== undefined &&
      object.expr_kind?.comprehension_expr !== null
    ) {
      message.expr_kind = {
        $case: "comprehension_expr",
        comprehension_expr: Expr_Comprehension.fromPartial(object.expr_kind.comprehension_expr),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(Expr.$type, Expr);

function createBaseExpr_Ident(): Expr_Ident {
  return { $type: "google.api.expr.v1alpha1.Expr.Ident" };
}

export const Expr_Ident: MessageFns<Expr_Ident, "google.api.expr.v1alpha1.Expr.Ident"> = {
  $type: "google.api.expr.v1alpha1.Expr.Ident" as const,

  encode(message: Expr_Ident, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Expr_Ident {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExpr_Ident();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Expr_Ident {
    return { $type: Expr_Ident.$type, name: isSet(object.name) ? globalThis.String(object.name) : undefined };
  },

  toJSON(message: Expr_Ident): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Expr_Ident>, I>>(base?: I): Expr_Ident {
    return Expr_Ident.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Expr_Ident>, I>>(object: I): Expr_Ident {
    const message = createBaseExpr_Ident();
    message.name = object.name ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Expr_Ident.$type, Expr_Ident);

function createBaseExpr_Select(): Expr_Select {
  return { $type: "google.api.expr.v1alpha1.Expr.Select" };
}

export const Expr_Select: MessageFns<Expr_Select, "google.api.expr.v1alpha1.Expr.Select"> = {
  $type: "google.api.expr.v1alpha1.Expr.Select" as const,

  encode(message: Expr_Select, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operand !== undefined) {
      Expr.encode(message.operand, writer.uint32(10).fork()).join();
    }
    if (message.field !== undefined && message.field !== "") {
      writer.uint32(18).string(message.field);
    }
    if (message.test_only !== undefined && message.test_only !== false) {
      writer.uint32(24).bool(message.test_only);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Expr_Select {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExpr_Select();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.operand = Expr.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.field = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.test_only = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Expr_Select {
    return {
      $type: Expr_Select.$type,
      operand: isSet(object.operand) ? Expr.fromJSON(object.operand) : undefined,
      field: isSet(object.field) ? globalThis.String(object.field) : undefined,
      test_only: isSet(object.test_only) ? globalThis.Boolean(object.test_only) : undefined,
    };
  },

  toJSON(message: Expr_Select): unknown {
    const obj: any = {};
    if (message.operand !== undefined) {
      obj.operand = Expr.toJSON(message.operand);
    }
    if (message.field !== undefined) {
      obj.field = message.field;
    }
    if (message.test_only !== undefined) {
      obj.test_only = message.test_only;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Expr_Select>, I>>(base?: I): Expr_Select {
    return Expr_Select.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Expr_Select>, I>>(object: I): Expr_Select {
    const message = createBaseExpr_Select();
    message.operand = (object.operand !== undefined && object.operand !== null)
      ? Expr.fromPartial(object.operand)
      : undefined;
    message.field = object.field ?? undefined;
    message.test_only = object.test_only ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Expr_Select.$type, Expr_Select);

function createBaseExpr_Call(): Expr_Call {
  return { $type: "google.api.expr.v1alpha1.Expr.Call" };
}

export const Expr_Call: MessageFns<Expr_Call, "google.api.expr.v1alpha1.Expr.Call"> = {
  $type: "google.api.expr.v1alpha1.Expr.Call" as const,

  encode(message: Expr_Call, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.target !== undefined) {
      Expr.encode(message.target, writer.uint32(10).fork()).join();
    }
    if (message.function !== undefined && message.function !== "") {
      writer.uint32(18).string(message.function);
    }
    if (message.args !== undefined && message.args.length !== 0) {
      for (const v of message.args) {
        Expr.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Expr_Call {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExpr_Call();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.target = Expr.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.function = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.args === undefined) {
            message.args = [];
          }
          const el = Expr.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.args!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Expr_Call {
    return {
      $type: Expr_Call.$type,
      target: isSet(object.target) ? Expr.fromJSON(object.target) : undefined,
      function: isSet(object.function) ? globalThis.String(object.function) : undefined,
      args: globalThis.Array.isArray(object?.args) ? object.args.map((e: any) => Expr.fromJSON(e)) : undefined,
    };
  },

  toJSON(message: Expr_Call): unknown {
    const obj: any = {};
    if (message.target !== undefined) {
      obj.target = Expr.toJSON(message.target);
    }
    if (message.function !== undefined) {
      obj.function = message.function;
    }
    if (message.args?.length) {
      obj.args = message.args.map((e) => Expr.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Expr_Call>, I>>(base?: I): Expr_Call {
    return Expr_Call.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Expr_Call>, I>>(object: I): Expr_Call {
    const message = createBaseExpr_Call();
    message.target = (object.target !== undefined && object.target !== null)
      ? Expr.fromPartial(object.target)
      : undefined;
    message.function = object.function ?? undefined;
    message.args = object.args?.map((e) => Expr.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(Expr_Call.$type, Expr_Call);

function createBaseExpr_CreateList(): Expr_CreateList {
  return { $type: "google.api.expr.v1alpha1.Expr.CreateList" };
}

export const Expr_CreateList: MessageFns<Expr_CreateList, "google.api.expr.v1alpha1.Expr.CreateList"> = {
  $type: "google.api.expr.v1alpha1.Expr.CreateList" as const,

  encode(message: Expr_CreateList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.elements !== undefined && message.elements.length !== 0) {
      for (const v of message.elements) {
        Expr.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Expr_CreateList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExpr_CreateList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.elements === undefined) {
            message.elements = [];
          }
          const el = Expr.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.elements!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Expr_CreateList {
    return {
      $type: Expr_CreateList.$type,
      elements: globalThis.Array.isArray(object?.elements)
        ? object.elements.map((e: any) => Expr.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: Expr_CreateList): unknown {
    const obj: any = {};
    if (message.elements?.length) {
      obj.elements = message.elements.map((e) => Expr.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Expr_CreateList>, I>>(base?: I): Expr_CreateList {
    return Expr_CreateList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Expr_CreateList>, I>>(object: I): Expr_CreateList {
    const message = createBaseExpr_CreateList();
    message.elements = object.elements?.map((e) => Expr.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(Expr_CreateList.$type, Expr_CreateList);

function createBaseExpr_CreateStruct(): Expr_CreateStruct {
  return { $type: "google.api.expr.v1alpha1.Expr.CreateStruct" };
}

export const Expr_CreateStruct: MessageFns<Expr_CreateStruct, "google.api.expr.v1alpha1.Expr.CreateStruct"> = {
  $type: "google.api.expr.v1alpha1.Expr.CreateStruct" as const,

  encode(message: Expr_CreateStruct, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message_name !== undefined && message.message_name !== "") {
      writer.uint32(10).string(message.message_name);
    }
    if (message.entries !== undefined && message.entries.length !== 0) {
      for (const v of message.entries) {
        Expr_CreateStruct_Entry.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Expr_CreateStruct {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExpr_CreateStruct();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message_name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.entries === undefined) {
            message.entries = [];
          }
          const el = Expr_CreateStruct_Entry.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.entries!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Expr_CreateStruct {
    return {
      $type: Expr_CreateStruct.$type,
      message_name: isSet(object.message_name) ? globalThis.String(object.message_name) : undefined,
      entries: globalThis.Array.isArray(object?.entries)
        ? object.entries.map((e: any) => Expr_CreateStruct_Entry.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: Expr_CreateStruct): unknown {
    const obj: any = {};
    if (message.message_name !== undefined) {
      obj.message_name = message.message_name;
    }
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => Expr_CreateStruct_Entry.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Expr_CreateStruct>, I>>(base?: I): Expr_CreateStruct {
    return Expr_CreateStruct.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Expr_CreateStruct>, I>>(object: I): Expr_CreateStruct {
    const message = createBaseExpr_CreateStruct();
    message.message_name = object.message_name ?? undefined;
    message.entries = object.entries?.map((e) => Expr_CreateStruct_Entry.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(Expr_CreateStruct.$type, Expr_CreateStruct);

function createBaseExpr_CreateStruct_Entry(): Expr_CreateStruct_Entry {
  return { $type: "google.api.expr.v1alpha1.Expr.CreateStruct.Entry", key_kind: undefined };
}

export const Expr_CreateStruct_Entry: MessageFns<
  Expr_CreateStruct_Entry,
  "google.api.expr.v1alpha1.Expr.CreateStruct.Entry"
> = {
  $type: "google.api.expr.v1alpha1.Expr.CreateStruct.Entry" as const,

  encode(message: Expr_CreateStruct_Entry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined && message.id !== 0) {
      writer.uint32(8).int64(message.id);
    }
    switch (message.key_kind?.$case) {
      case "field_key":
        writer.uint32(18).string(message.key_kind.field_key);
        break;
      case "map_key":
        Expr.encode(message.key_kind.map_key, writer.uint32(26).fork()).join();
        break;
    }
    if (message.value !== undefined) {
      Expr.encode(message.value, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Expr_CreateStruct_Entry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExpr_CreateStruct_Entry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.key_kind = { $case: "field_key", field_key: reader.string() };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.key_kind = { $case: "map_key", map_key: Expr.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.value = Expr.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Expr_CreateStruct_Entry {
    return {
      $type: Expr_CreateStruct_Entry.$type,
      id: isSet(object.id) ? globalThis.Number(object.id) : undefined,
      key_kind: isSet(object.field_key)
        ? { $case: "field_key", field_key: globalThis.String(object.field_key) }
        : isSet(object.map_key)
        ? { $case: "map_key", map_key: Expr.fromJSON(object.map_key) }
        : undefined,
      value: isSet(object.value) ? Expr.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Expr_CreateStruct_Entry): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = Math.round(message.id);
    }
    if (message.key_kind?.$case === "field_key") {
      obj.field_key = message.key_kind.field_key;
    }
    if (message.key_kind?.$case === "map_key") {
      obj.map_key = Expr.toJSON(message.key_kind.map_key);
    }
    if (message.value !== undefined) {
      obj.value = Expr.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Expr_CreateStruct_Entry>, I>>(base?: I): Expr_CreateStruct_Entry {
    return Expr_CreateStruct_Entry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Expr_CreateStruct_Entry>, I>>(object: I): Expr_CreateStruct_Entry {
    const message = createBaseExpr_CreateStruct_Entry();
    message.id = object.id ?? undefined;
    if (
      object.key_kind?.$case === "field_key" &&
      object.key_kind?.field_key !== undefined &&
      object.key_kind?.field_key !== null
    ) {
      message.key_kind = { $case: "field_key", field_key: object.key_kind.field_key };
    }
    if (
      object.key_kind?.$case === "map_key" &&
      object.key_kind?.map_key !== undefined &&
      object.key_kind?.map_key !== null
    ) {
      message.key_kind = { $case: "map_key", map_key: Expr.fromPartial(object.key_kind.map_key) };
    }
    message.value = (object.value !== undefined && object.value !== null) ? Expr.fromPartial(object.value) : undefined;
    return message;
  },
};

messageTypeRegistry.set(Expr_CreateStruct_Entry.$type, Expr_CreateStruct_Entry);

function createBaseExpr_Comprehension(): Expr_Comprehension {
  return { $type: "google.api.expr.v1alpha1.Expr.Comprehension" };
}

export const Expr_Comprehension: MessageFns<Expr_Comprehension, "google.api.expr.v1alpha1.Expr.Comprehension"> = {
  $type: "google.api.expr.v1alpha1.Expr.Comprehension" as const,

  encode(message: Expr_Comprehension, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.iter_var !== undefined && message.iter_var !== "") {
      writer.uint32(10).string(message.iter_var);
    }
    if (message.iter_range !== undefined) {
      Expr.encode(message.iter_range, writer.uint32(18).fork()).join();
    }
    if (message.accu_var !== undefined && message.accu_var !== "") {
      writer.uint32(26).string(message.accu_var);
    }
    if (message.accu_init !== undefined) {
      Expr.encode(message.accu_init, writer.uint32(34).fork()).join();
    }
    if (message.loop_condition !== undefined) {
      Expr.encode(message.loop_condition, writer.uint32(42).fork()).join();
    }
    if (message.loop_step !== undefined) {
      Expr.encode(message.loop_step, writer.uint32(50).fork()).join();
    }
    if (message.result !== undefined) {
      Expr.encode(message.result, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Expr_Comprehension {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExpr_Comprehension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.iter_var = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.iter_range = Expr.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.accu_var = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.accu_init = Expr.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.loop_condition = Expr.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.loop_step = Expr.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.result = Expr.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Expr_Comprehension {
    return {
      $type: Expr_Comprehension.$type,
      iter_var: isSet(object.iter_var) ? globalThis.String(object.iter_var) : undefined,
      iter_range: isSet(object.iter_range) ? Expr.fromJSON(object.iter_range) : undefined,
      accu_var: isSet(object.accu_var) ? globalThis.String(object.accu_var) : undefined,
      accu_init: isSet(object.accu_init) ? Expr.fromJSON(object.accu_init) : undefined,
      loop_condition: isSet(object.loop_condition) ? Expr.fromJSON(object.loop_condition) : undefined,
      loop_step: isSet(object.loop_step) ? Expr.fromJSON(object.loop_step) : undefined,
      result: isSet(object.result) ? Expr.fromJSON(object.result) : undefined,
    };
  },

  toJSON(message: Expr_Comprehension): unknown {
    const obj: any = {};
    if (message.iter_var !== undefined) {
      obj.iter_var = message.iter_var;
    }
    if (message.iter_range !== undefined) {
      obj.iter_range = Expr.toJSON(message.iter_range);
    }
    if (message.accu_var !== undefined) {
      obj.accu_var = message.accu_var;
    }
    if (message.accu_init !== undefined) {
      obj.accu_init = Expr.toJSON(message.accu_init);
    }
    if (message.loop_condition !== undefined) {
      obj.loop_condition = Expr.toJSON(message.loop_condition);
    }
    if (message.loop_step !== undefined) {
      obj.loop_step = Expr.toJSON(message.loop_step);
    }
    if (message.result !== undefined) {
      obj.result = Expr.toJSON(message.result);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Expr_Comprehension>, I>>(base?: I): Expr_Comprehension {
    return Expr_Comprehension.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Expr_Comprehension>, I>>(object: I): Expr_Comprehension {
    const message = createBaseExpr_Comprehension();
    message.iter_var = object.iter_var ?? undefined;
    message.iter_range = (object.iter_range !== undefined && object.iter_range !== null)
      ? Expr.fromPartial(object.iter_range)
      : undefined;
    message.accu_var = object.accu_var ?? undefined;
    message.accu_init = (object.accu_init !== undefined && object.accu_init !== null)
      ? Expr.fromPartial(object.accu_init)
      : undefined;
    message.loop_condition = (object.loop_condition !== undefined && object.loop_condition !== null)
      ? Expr.fromPartial(object.loop_condition)
      : undefined;
    message.loop_step = (object.loop_step !== undefined && object.loop_step !== null)
      ? Expr.fromPartial(object.loop_step)
      : undefined;
    message.result = (object.result !== undefined && object.result !== null)
      ? Expr.fromPartial(object.result)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Expr_Comprehension.$type, Expr_Comprehension);

function createBaseConstant(): Constant {
  return { $type: "google.api.expr.v1alpha1.Constant", constant_kind: undefined };
}

export const Constant: MessageFns<Constant, "google.api.expr.v1alpha1.Constant"> = {
  $type: "google.api.expr.v1alpha1.Constant" as const,

  encode(message: Constant, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.constant_kind?.$case) {
      case "null_value":
        writer.uint32(8).int32(nullValueToNumber(message.constant_kind.null_value));
        break;
      case "bool_value":
        writer.uint32(16).bool(message.constant_kind.bool_value);
        break;
      case "int64_value":
        writer.uint32(24).int64(message.constant_kind.int64_value);
        break;
      case "uint64_value":
        writer.uint32(32).uint64(message.constant_kind.uint64_value);
        break;
      case "double_value":
        writer.uint32(41).double(message.constant_kind.double_value);
        break;
      case "string_value":
        writer.uint32(50).string(message.constant_kind.string_value);
        break;
      case "bytes_value":
        writer.uint32(58).bytes(message.constant_kind.bytes_value);
        break;
      case "duration_value":
        Duration.encode(message.constant_kind.duration_value, writer.uint32(66).fork()).join();
        break;
      case "timestamp_value":
        Timestamp.encode(toTimestamp(message.constant_kind.timestamp_value), writer.uint32(74).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Constant {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConstant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.constant_kind = { $case: "null_value", null_value: nullValueFromJSON(reader.int32()) };
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.constant_kind = { $case: "bool_value", bool_value: reader.bool() };
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.constant_kind = { $case: "int64_value", int64_value: longToNumber(reader.int64()) };
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.constant_kind = { $case: "uint64_value", uint64_value: longToNumber(reader.uint64()) };
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.constant_kind = { $case: "double_value", double_value: reader.double() };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.constant_kind = { $case: "string_value", string_value: reader.string() };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.constant_kind = { $case: "bytes_value", bytes_value: reader.bytes() };
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.constant_kind = { $case: "duration_value", duration_value: Duration.decode(reader, reader.uint32()) };
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.constant_kind = {
            $case: "timestamp_value",
            timestamp_value: fromTimestamp(Timestamp.decode(reader, reader.uint32())),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Constant {
    return {
      $type: Constant.$type,
      constant_kind: isSet(object.null_value)
        ? { $case: "null_value", null_value: nullValueFromJSON(object.null_value) }
        : isSet(object.bool_value)
        ? { $case: "bool_value", bool_value: globalThis.Boolean(object.bool_value) }
        : isSet(object.int64_value)
        ? { $case: "int64_value", int64_value: globalThis.Number(object.int64_value) }
        : isSet(object.uint64_value)
        ? { $case: "uint64_value", uint64_value: globalThis.Number(object.uint64_value) }
        : isSet(object.double_value)
        ? { $case: "double_value", double_value: globalThis.Number(object.double_value) }
        : isSet(object.string_value)
        ? { $case: "string_value", string_value: globalThis.String(object.string_value) }
        : isSet(object.bytes_value)
        ? { $case: "bytes_value", bytes_value: bytesFromBase64(object.bytes_value) }
        : isSet(object.duration_value)
        ? { $case: "duration_value", duration_value: Duration.fromJSON(object.duration_value) }
        : isSet(object.timestamp_value)
        ? { $case: "timestamp_value", timestamp_value: fromJsonTimestamp(object.timestamp_value) }
        : undefined,
    };
  },

  toJSON(message: Constant): unknown {
    const obj: any = {};
    if (message.constant_kind?.$case === "null_value") {
      obj.null_value = nullValueToJSON(message.constant_kind.null_value);
    }
    if (message.constant_kind?.$case === "bool_value") {
      obj.bool_value = message.constant_kind.bool_value;
    }
    if (message.constant_kind?.$case === "int64_value") {
      obj.int64_value = Math.round(message.constant_kind.int64_value);
    }
    if (message.constant_kind?.$case === "uint64_value") {
      obj.uint64_value = Math.round(message.constant_kind.uint64_value);
    }
    if (message.constant_kind?.$case === "double_value") {
      obj.double_value = message.constant_kind.double_value;
    }
    if (message.constant_kind?.$case === "string_value") {
      obj.string_value = message.constant_kind.string_value;
    }
    if (message.constant_kind?.$case === "bytes_value") {
      obj.bytes_value = base64FromBytes(message.constant_kind.bytes_value);
    }
    if (message.constant_kind?.$case === "duration_value") {
      obj.duration_value = Duration.toJSON(message.constant_kind.duration_value);
    }
    if (message.constant_kind?.$case === "timestamp_value") {
      obj.timestamp_value = message.constant_kind.timestamp_value.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Constant>, I>>(base?: I): Constant {
    return Constant.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Constant>, I>>(object: I): Constant {
    const message = createBaseConstant();
    if (
      object.constant_kind?.$case === "null_value" &&
      object.constant_kind?.null_value !== undefined &&
      object.constant_kind?.null_value !== null
    ) {
      message.constant_kind = { $case: "null_value", null_value: object.constant_kind.null_value };
    }
    if (
      object.constant_kind?.$case === "bool_value" &&
      object.constant_kind?.bool_value !== undefined &&
      object.constant_kind?.bool_value !== null
    ) {
      message.constant_kind = { $case: "bool_value", bool_value: object.constant_kind.bool_value };
    }
    if (
      object.constant_kind?.$case === "int64_value" &&
      object.constant_kind?.int64_value !== undefined &&
      object.constant_kind?.int64_value !== null
    ) {
      message.constant_kind = { $case: "int64_value", int64_value: object.constant_kind.int64_value };
    }
    if (
      object.constant_kind?.$case === "uint64_value" &&
      object.constant_kind?.uint64_value !== undefined &&
      object.constant_kind?.uint64_value !== null
    ) {
      message.constant_kind = { $case: "uint64_value", uint64_value: object.constant_kind.uint64_value };
    }
    if (
      object.constant_kind?.$case === "double_value" &&
      object.constant_kind?.double_value !== undefined &&
      object.constant_kind?.double_value !== null
    ) {
      message.constant_kind = { $case: "double_value", double_value: object.constant_kind.double_value };
    }
    if (
      object.constant_kind?.$case === "string_value" &&
      object.constant_kind?.string_value !== undefined &&
      object.constant_kind?.string_value !== null
    ) {
      message.constant_kind = { $case: "string_value", string_value: object.constant_kind.string_value };
    }
    if (
      object.constant_kind?.$case === "bytes_value" &&
      object.constant_kind?.bytes_value !== undefined &&
      object.constant_kind?.bytes_value !== null
    ) {
      message.constant_kind = { $case: "bytes_value", bytes_value: object.constant_kind.bytes_value };
    }
    if (
      object.constant_kind?.$case === "duration_value" &&
      object.constant_kind?.duration_value !== undefined &&
      object.constant_kind?.duration_value !== null
    ) {
      message.constant_kind = {
        $case: "duration_value",
        duration_value: Duration.fromPartial(object.constant_kind.duration_value),
      };
    }
    if (
      object.constant_kind?.$case === "timestamp_value" &&
      object.constant_kind?.timestamp_value !== undefined &&
      object.constant_kind?.timestamp_value !== null
    ) {
      message.constant_kind = { $case: "timestamp_value", timestamp_value: object.constant_kind.timestamp_value };
    }
    return message;
  },
};

messageTypeRegistry.set(Constant.$type, Constant);

function createBaseSourceInfo(): SourceInfo {
  return { $type: "google.api.expr.v1alpha1.SourceInfo" };
}

export const SourceInfo: MessageFns<SourceInfo, "google.api.expr.v1alpha1.SourceInfo"> = {
  $type: "google.api.expr.v1alpha1.SourceInfo" as const,

  encode(message: SourceInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.syntax_version !== undefined && message.syntax_version !== "") {
      writer.uint32(10).string(message.syntax_version);
    }
    if (message.location !== undefined && message.location !== "") {
      writer.uint32(18).string(message.location);
    }
    if (message.line_offsets !== undefined && message.line_offsets.length !== 0) {
      writer.uint32(26).fork();
      for (const v of message.line_offsets) {
        writer.int32(v);
      }
      writer.join();
    }
    (message.positions || new Map()).forEach((value, key) => {
      SourceInfo_PositionsEntry.encode({
        $type: "google.api.expr.v1alpha1.SourceInfo.PositionsEntry",
        key: key as any,
        value,
      }, writer.uint32(34).fork()).join();
    });
    (message.macro_calls || new Map()).forEach((value, key) => {
      SourceInfo_MacroCallsEntry.encode({
        $type: "google.api.expr.v1alpha1.SourceInfo.MacroCallsEntry",
        key: key as any,
        value,
      }, writer.uint32(42).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SourceInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSourceInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.syntax_version = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.location = reader.string();
          continue;
        }
        case 3: {
          if (tag === 24) {
            if (message.line_offsets === undefined) {
              message.line_offsets = [];
            }
            message.line_offsets!.push(reader.int32());

            continue;
          }

          if (tag === 26) {
            if (message.line_offsets === undefined) {
              message.line_offsets = [];
            }
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.line_offsets!.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = SourceInfo_PositionsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            if (message.positions === undefined) {
              message.positions = new Map();
            }
            message.positions!.set(entry4.key, entry4.value);
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = SourceInfo_MacroCallsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            if (message.macro_calls === undefined) {
              message.macro_calls = new Map();
            }
            message.macro_calls!.set(entry5.key, entry5.value);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SourceInfo {
    return {
      $type: SourceInfo.$type,
      syntax_version: isSet(object.syntax_version) ? globalThis.String(object.syntax_version) : undefined,
      location: isSet(object.location) ? globalThis.String(object.location) : undefined,
      line_offsets: globalThis.Array.isArray(object?.line_offsets)
        ? object.line_offsets.map((e: any) => globalThis.Number(e))
        : undefined,
      positions: isObject(object.positions)
        ? Object.entries(object.positions).reduce<Map<number, number>>((acc, [key, value]) => {
          acc.set(globalThis.Number(key), Number(value));
          return acc;
        }, new Map())
        : undefined,
      macro_calls: isObject(object.macro_calls)
        ? Object.entries(object.macro_calls).reduce<Map<number, Expr>>((acc, [key, value]) => {
          acc.set(globalThis.Number(key), Expr.fromJSON(value));
          return acc;
        }, new Map())
        : undefined,
    };
  },

  toJSON(message: SourceInfo): unknown {
    const obj: any = {};
    if (message.syntax_version !== undefined) {
      obj.syntax_version = message.syntax_version;
    }
    if (message.location !== undefined) {
      obj.location = message.location;
    }
    if (message.line_offsets?.length) {
      obj.line_offsets = message.line_offsets.map((e) => Math.round(e));
    }
    if (message.positions?.size) {
      obj.positions = {};
      message.positions.forEach((v, k) => {
        obj.positions[k] = Math.round(v);
      });
    }
    if (message.macro_calls?.size) {
      obj.macro_calls = {};
      message.macro_calls.forEach((v, k) => {
        obj.macro_calls[k] = Expr.toJSON(v);
      });
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SourceInfo>, I>>(base?: I): SourceInfo {
    return SourceInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SourceInfo>, I>>(object: I): SourceInfo {
    const message = createBaseSourceInfo();
    message.syntax_version = object.syntax_version ?? undefined;
    message.location = object.location ?? undefined;
    message.line_offsets = object.line_offsets?.map((e) => e) || undefined;
    message.positions = (object.positions === undefined || object.positions === null) ? undefined : (() => {
      const m = new Map();
      (object.positions as Map<number, number> ?? new Map()).forEach((value, key) => {
        if (value !== undefined) {
          m.set(key, globalThis.Number(value));
        }
      });
      return m;
    })();
    message.macro_calls = (object.macro_calls === undefined || object.macro_calls === null) ? undefined : (() => {
      const m = new Map();
      (object.macro_calls as Map<number, Expr> ?? new Map()).forEach((value, key) => {
        if (value !== undefined) {
          m.set(key, Expr.fromPartial(value));
        }
      });
      return m;
    })();
    return message;
  },
};

messageTypeRegistry.set(SourceInfo.$type, SourceInfo);

function createBaseSourceInfo_PositionsEntry(): SourceInfo_PositionsEntry {
  return { $type: "google.api.expr.v1alpha1.SourceInfo.PositionsEntry", key: 0, value: 0 };
}

export const SourceInfo_PositionsEntry: MessageFns<
  SourceInfo_PositionsEntry,
  "google.api.expr.v1alpha1.SourceInfo.PositionsEntry"
> = {
  $type: "google.api.expr.v1alpha1.SourceInfo.PositionsEntry" as const,

  encode(message: SourceInfo_PositionsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== 0) {
      writer.uint32(8).int64(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SourceInfo_PositionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSourceInfo_PositionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SourceInfo_PositionsEntry {
    return {
      $type: SourceInfo_PositionsEntry.$type,
      key: isSet(object.key) ? globalThis.Number(object.key) : 0,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: SourceInfo_PositionsEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = Math.round(message.key);
    }
    if (message.value !== undefined) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SourceInfo_PositionsEntry>, I>>(base?: I): SourceInfo_PositionsEntry {
    return SourceInfo_PositionsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SourceInfo_PositionsEntry>, I>>(object: I): SourceInfo_PositionsEntry {
    const message = createBaseSourceInfo_PositionsEntry();
    message.key = object.key ?? 0;
    message.value = object.value ?? 0;
    return message;
  },
};

messageTypeRegistry.set(SourceInfo_PositionsEntry.$type, SourceInfo_PositionsEntry);

function createBaseSourceInfo_MacroCallsEntry(): SourceInfo_MacroCallsEntry {
  return { $type: "google.api.expr.v1alpha1.SourceInfo.MacroCallsEntry", key: 0 };
}

export const SourceInfo_MacroCallsEntry: MessageFns<
  SourceInfo_MacroCallsEntry,
  "google.api.expr.v1alpha1.SourceInfo.MacroCallsEntry"
> = {
  $type: "google.api.expr.v1alpha1.SourceInfo.MacroCallsEntry" as const,

  encode(message: SourceInfo_MacroCallsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== 0) {
      writer.uint32(8).int64(message.key);
    }
    if (message.value !== undefined) {
      Expr.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SourceInfo_MacroCallsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSourceInfo_MacroCallsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Expr.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SourceInfo_MacroCallsEntry {
    return {
      $type: SourceInfo_MacroCallsEntry.$type,
      key: isSet(object.key) ? globalThis.Number(object.key) : 0,
      value: isSet(object.value) ? Expr.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: SourceInfo_MacroCallsEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = Math.round(message.key);
    }
    if (message.value !== undefined) {
      obj.value = Expr.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SourceInfo_MacroCallsEntry>, I>>(base?: I): SourceInfo_MacroCallsEntry {
    return SourceInfo_MacroCallsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SourceInfo_MacroCallsEntry>, I>>(object: I): SourceInfo_MacroCallsEntry {
    const message = createBaseSourceInfo_MacroCallsEntry();
    message.key = object.key ?? 0;
    message.value = (object.value !== undefined && object.value !== null) ? Expr.fromPartial(object.value) : undefined;
    return message;
  },
};

messageTypeRegistry.set(SourceInfo_MacroCallsEntry.$type, SourceInfo_MacroCallsEntry);

function createBaseSourcePosition(): SourcePosition {
  return { $type: "google.api.expr.v1alpha1.SourcePosition" };
}

export const SourcePosition: MessageFns<SourcePosition, "google.api.expr.v1alpha1.SourcePosition"> = {
  $type: "google.api.expr.v1alpha1.SourcePosition" as const,

  encode(message: SourcePosition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.location !== undefined && message.location !== "") {
      writer.uint32(10).string(message.location);
    }
    if (message.offset !== undefined && message.offset !== 0) {
      writer.uint32(16).int32(message.offset);
    }
    if (message.line !== undefined && message.line !== 0) {
      writer.uint32(24).int32(message.line);
    }
    if (message.column !== undefined && message.column !== 0) {
      writer.uint32(32).int32(message.column);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SourcePosition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSourcePosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.location = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.line = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.column = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SourcePosition {
    return {
      $type: SourcePosition.$type,
      location: isSet(object.location) ? globalThis.String(object.location) : undefined,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : undefined,
      line: isSet(object.line) ? globalThis.Number(object.line) : undefined,
      column: isSet(object.column) ? globalThis.Number(object.column) : undefined,
    };
  },

  toJSON(message: SourcePosition): unknown {
    const obj: any = {};
    if (message.location !== undefined) {
      obj.location = message.location;
    }
    if (message.offset !== undefined) {
      obj.offset = Math.round(message.offset);
    }
    if (message.line !== undefined) {
      obj.line = Math.round(message.line);
    }
    if (message.column !== undefined) {
      obj.column = Math.round(message.column);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SourcePosition>, I>>(base?: I): SourcePosition {
    return SourcePosition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SourcePosition>, I>>(object: I): SourcePosition {
    const message = createBaseSourcePosition();
    message.location = object.location ?? undefined;
    message.offset = object.offset ?? undefined;
    message.line = object.line ?? undefined;
    message.column = object.column ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(SourcePosition.$type, SourcePosition);

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { $type: "google.protobuf.Timestamp", seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
