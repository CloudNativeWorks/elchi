// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: validate/validate.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../google/protobuf/duration";
import { Timestamp } from "../google/protobuf/timestamp";
import { messageTypeRegistry } from "../typeRegistry";

export const protobufPackage = "validate";

/** WellKnownRegex contain some well-known patterns. */
export enum KnownRegex {
  UNKNOWN = "UNKNOWN",
  /** HTTP_HEADER_NAME - HTTP header name as defined by RFC 7230. */
  HTTP_HEADER_NAME = "HTTP_HEADER_NAME",
  /** HTTP_HEADER_VALUE - HTTP header value as defined by RFC 7230. */
  HTTP_HEADER_VALUE = "HTTP_HEADER_VALUE",
}

export function knownRegexFromJSON(object: any): KnownRegex {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return KnownRegex.UNKNOWN;
    case 1:
    case "HTTP_HEADER_NAME":
      return KnownRegex.HTTP_HEADER_NAME;
    case 2:
    case "HTTP_HEADER_VALUE":
      return KnownRegex.HTTP_HEADER_VALUE;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum KnownRegex");
  }
}

export function knownRegexToJSON(object: KnownRegex): string {
  switch (object) {
    case KnownRegex.UNKNOWN:
      return "UNKNOWN";
    case KnownRegex.HTTP_HEADER_NAME:
      return "HTTP_HEADER_NAME";
    case KnownRegex.HTTP_HEADER_VALUE:
      return "HTTP_HEADER_VALUE";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum KnownRegex");
  }
}

export function knownRegexToNumber(object: KnownRegex): number {
  switch (object) {
    case KnownRegex.UNKNOWN:
      return 0;
    case KnownRegex.HTTP_HEADER_NAME:
      return 1;
    case KnownRegex.HTTP_HEADER_VALUE:
      return 2;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum KnownRegex");
  }
}

/**
 * FieldRules encapsulates the rules for each type of field. Depending on the
 * field, the correct set should be used to ensure proper validations.
 */
export interface FieldRules {
  $type: "validate.FieldRules";
  message?: MessageRules | undefined;
  type?:
    | //
    /** Scalar Field Types */
    { $case: "float"; float: FloatRules }
    | //
    { $case: "double"; double: DoubleRules }
    | //
    { $case: "int32"; int32: Int32Rules }
    | //
    { $case: "int64"; int64: Int64Rules }
    | //
    { $case: "uint32"; uint32: UInt32Rules }
    | //
    { $case: "uint64"; uint64: UInt64Rules }
    | //
    { $case: "sint32"; sint32: SInt32Rules }
    | //
    { $case: "sint64"; sint64: SInt64Rules }
    | //
    { $case: "fixed32"; fixed32: Fixed32Rules }
    | //
    { $case: "fixed64"; fixed64: Fixed64Rules }
    | //
    { $case: "sfixed32"; sfixed32: SFixed32Rules }
    | //
    { $case: "sfixed64"; sfixed64: SFixed64Rules }
    | //
    { $case: "bool"; bool: BoolRules }
    | //
    { $case: "string"; string: StringRules }
    | //
    { $case: "bytes"; bytes: BytesRules }
    | //
    /** Complex Field Types */
    { $case: "enum"; enum: EnumRules }
    | //
    { $case: "repeated"; repeated: RepeatedRules }
    | //
    { $case: "map"; map: MapRules }
    | //
    /** Well-Known Field Types */
    { $case: "any"; any: AnyRules }
    | //
    { $case: "duration"; duration: DurationRules }
    | //
    { $case: "timestamp"; timestamp: TimestampRules }
    | undefined;
}

/** FloatRules describes the constraints applied to `float` values */
export interface FloatRules {
  $type: "validate.FloatRules";
  /** Const specifies that this field must be exactly the specified value */
  const?:
    | number
    | undefined;
  /**
   * Lt specifies that this field must be less than the specified value,
   * exclusive
   */
  lt?:
    | number
    | undefined;
  /**
   * Lte specifies that this field must be less than or equal to the
   * specified value, inclusive
   */
  lte?:
    | number
    | undefined;
  /**
   * Gt specifies that this field must be greater than the specified value,
   * exclusive. If the value of Gt is larger than a specified Lt or Lte, the
   * range is reversed.
   */
  gt?:
    | number
    | undefined;
  /**
   * Gte specifies that this field must be greater than or equal to the
   * specified value, inclusive. If the value of Gte is larger than a
   * specified Lt or Lte, the range is reversed.
   */
  gte?:
    | number
    | undefined;
  /**
   * In specifies that this field must be equal to one of the specified
   * values
   */
  in?:
    | number[]
    | undefined;
  /**
   * NotIn specifies that this field cannot be equal to one of the specified
   * values
   */
  not_in?:
    | number[]
    | undefined;
  /**
   * IgnoreEmpty specifies that the validation rules of this field should be
   * evaluated only if the field is not empty
   */
  ignore_empty?: boolean | undefined;
}

/** DoubleRules describes the constraints applied to `double` values */
export interface DoubleRules {
  $type: "validate.DoubleRules";
  /** Const specifies that this field must be exactly the specified value */
  const?:
    | number
    | undefined;
  /**
   * Lt specifies that this field must be less than the specified value,
   * exclusive
   */
  lt?:
    | number
    | undefined;
  /**
   * Lte specifies that this field must be less than or equal to the
   * specified value, inclusive
   */
  lte?:
    | number
    | undefined;
  /**
   * Gt specifies that this field must be greater than the specified value,
   * exclusive. If the value of Gt is larger than a specified Lt or Lte, the
   * range is reversed.
   */
  gt?:
    | number
    | undefined;
  /**
   * Gte specifies that this field must be greater than or equal to the
   * specified value, inclusive. If the value of Gte is larger than a
   * specified Lt or Lte, the range is reversed.
   */
  gte?:
    | number
    | undefined;
  /**
   * In specifies that this field must be equal to one of the specified
   * values
   */
  in?:
    | number[]
    | undefined;
  /**
   * NotIn specifies that this field cannot be equal to one of the specified
   * values
   */
  not_in?:
    | number[]
    | undefined;
  /**
   * IgnoreEmpty specifies that the validation rules of this field should be
   * evaluated only if the field is not empty
   */
  ignore_empty?: boolean | undefined;
}

/** Int32Rules describes the constraints applied to `int32` values */
export interface Int32Rules {
  $type: "validate.Int32Rules";
  /** Const specifies that this field must be exactly the specified value */
  const?:
    | number
    | undefined;
  /**
   * Lt specifies that this field must be less than the specified value,
   * exclusive
   */
  lt?:
    | number
    | undefined;
  /**
   * Lte specifies that this field must be less than or equal to the
   * specified value, inclusive
   */
  lte?:
    | number
    | undefined;
  /**
   * Gt specifies that this field must be greater than the specified value,
   * exclusive. If the value of Gt is larger than a specified Lt or Lte, the
   * range is reversed.
   */
  gt?:
    | number
    | undefined;
  /**
   * Gte specifies that this field must be greater than or equal to the
   * specified value, inclusive. If the value of Gte is larger than a
   * specified Lt or Lte, the range is reversed.
   */
  gte?:
    | number
    | undefined;
  /**
   * In specifies that this field must be equal to one of the specified
   * values
   */
  in?:
    | number[]
    | undefined;
  /**
   * NotIn specifies that this field cannot be equal to one of the specified
   * values
   */
  not_in?:
    | number[]
    | undefined;
  /**
   * IgnoreEmpty specifies that the validation rules of this field should be
   * evaluated only if the field is not empty
   */
  ignore_empty?: boolean | undefined;
}

/** Int64Rules describes the constraints applied to `int64` values */
export interface Int64Rules {
  $type: "validate.Int64Rules";
  /** Const specifies that this field must be exactly the specified value */
  const?:
    | number
    | undefined;
  /**
   * Lt specifies that this field must be less than the specified value,
   * exclusive
   */
  lt?:
    | number
    | undefined;
  /**
   * Lte specifies that this field must be less than or equal to the
   * specified value, inclusive
   */
  lte?:
    | number
    | undefined;
  /**
   * Gt specifies that this field must be greater than the specified value,
   * exclusive. If the value of Gt is larger than a specified Lt or Lte, the
   * range is reversed.
   */
  gt?:
    | number
    | undefined;
  /**
   * Gte specifies that this field must be greater than or equal to the
   * specified value, inclusive. If the value of Gte is larger than a
   * specified Lt or Lte, the range is reversed.
   */
  gte?:
    | number
    | undefined;
  /**
   * In specifies that this field must be equal to one of the specified
   * values
   */
  in?:
    | number[]
    | undefined;
  /**
   * NotIn specifies that this field cannot be equal to one of the specified
   * values
   */
  not_in?:
    | number[]
    | undefined;
  /**
   * IgnoreEmpty specifies that the validation rules of this field should be
   * evaluated only if the field is not empty
   */
  ignore_empty?: boolean | undefined;
}

/** UInt32Rules describes the constraints applied to `uint32` values */
export interface UInt32Rules {
  $type: "validate.UInt32Rules";
  /** Const specifies that this field must be exactly the specified value */
  const?:
    | number
    | undefined;
  /**
   * Lt specifies that this field must be less than the specified value,
   * exclusive
   */
  lt?:
    | number
    | undefined;
  /**
   * Lte specifies that this field must be less than or equal to the
   * specified value, inclusive
   */
  lte?:
    | number
    | undefined;
  /**
   * Gt specifies that this field must be greater than the specified value,
   * exclusive. If the value of Gt is larger than a specified Lt or Lte, the
   * range is reversed.
   */
  gt?:
    | number
    | undefined;
  /**
   * Gte specifies that this field must be greater than or equal to the
   * specified value, inclusive. If the value of Gte is larger than a
   * specified Lt or Lte, the range is reversed.
   */
  gte?:
    | number
    | undefined;
  /**
   * In specifies that this field must be equal to one of the specified
   * values
   */
  in?:
    | number[]
    | undefined;
  /**
   * NotIn specifies that this field cannot be equal to one of the specified
   * values
   */
  not_in?:
    | number[]
    | undefined;
  /**
   * IgnoreEmpty specifies that the validation rules of this field should be
   * evaluated only if the field is not empty
   */
  ignore_empty?: boolean | undefined;
}

/** UInt64Rules describes the constraints applied to `uint64` values */
export interface UInt64Rules {
  $type: "validate.UInt64Rules";
  /** Const specifies that this field must be exactly the specified value */
  const?:
    | number
    | undefined;
  /**
   * Lt specifies that this field must be less than the specified value,
   * exclusive
   */
  lt?:
    | number
    | undefined;
  /**
   * Lte specifies that this field must be less than or equal to the
   * specified value, inclusive
   */
  lte?:
    | number
    | undefined;
  /**
   * Gt specifies that this field must be greater than the specified value,
   * exclusive. If the value of Gt is larger than a specified Lt or Lte, the
   * range is reversed.
   */
  gt?:
    | number
    | undefined;
  /**
   * Gte specifies that this field must be greater than or equal to the
   * specified value, inclusive. If the value of Gte is larger than a
   * specified Lt or Lte, the range is reversed.
   */
  gte?:
    | number
    | undefined;
  /**
   * In specifies that this field must be equal to one of the specified
   * values
   */
  in?:
    | number[]
    | undefined;
  /**
   * NotIn specifies that this field cannot be equal to one of the specified
   * values
   */
  not_in?:
    | number[]
    | undefined;
  /**
   * IgnoreEmpty specifies that the validation rules of this field should be
   * evaluated only if the field is not empty
   */
  ignore_empty?: boolean | undefined;
}

/** SInt32Rules describes the constraints applied to `sint32` values */
export interface SInt32Rules {
  $type: "validate.SInt32Rules";
  /** Const specifies that this field must be exactly the specified value */
  const?:
    | number
    | undefined;
  /**
   * Lt specifies that this field must be less than the specified value,
   * exclusive
   */
  lt?:
    | number
    | undefined;
  /**
   * Lte specifies that this field must be less than or equal to the
   * specified value, inclusive
   */
  lte?:
    | number
    | undefined;
  /**
   * Gt specifies that this field must be greater than the specified value,
   * exclusive. If the value of Gt is larger than a specified Lt or Lte, the
   * range is reversed.
   */
  gt?:
    | number
    | undefined;
  /**
   * Gte specifies that this field must be greater than or equal to the
   * specified value, inclusive. If the value of Gte is larger than a
   * specified Lt or Lte, the range is reversed.
   */
  gte?:
    | number
    | undefined;
  /**
   * In specifies that this field must be equal to one of the specified
   * values
   */
  in?:
    | number[]
    | undefined;
  /**
   * NotIn specifies that this field cannot be equal to one of the specified
   * values
   */
  not_in?:
    | number[]
    | undefined;
  /**
   * IgnoreEmpty specifies that the validation rules of this field should be
   * evaluated only if the field is not empty
   */
  ignore_empty?: boolean | undefined;
}

/** SInt64Rules describes the constraints applied to `sint64` values */
export interface SInt64Rules {
  $type: "validate.SInt64Rules";
  /** Const specifies that this field must be exactly the specified value */
  const?:
    | number
    | undefined;
  /**
   * Lt specifies that this field must be less than the specified value,
   * exclusive
   */
  lt?:
    | number
    | undefined;
  /**
   * Lte specifies that this field must be less than or equal to the
   * specified value, inclusive
   */
  lte?:
    | number
    | undefined;
  /**
   * Gt specifies that this field must be greater than the specified value,
   * exclusive. If the value of Gt is larger than a specified Lt or Lte, the
   * range is reversed.
   */
  gt?:
    | number
    | undefined;
  /**
   * Gte specifies that this field must be greater than or equal to the
   * specified value, inclusive. If the value of Gte is larger than a
   * specified Lt or Lte, the range is reversed.
   */
  gte?:
    | number
    | undefined;
  /**
   * In specifies that this field must be equal to one of the specified
   * values
   */
  in?:
    | number[]
    | undefined;
  /**
   * NotIn specifies that this field cannot be equal to one of the specified
   * values
   */
  not_in?:
    | number[]
    | undefined;
  /**
   * IgnoreEmpty specifies that the validation rules of this field should be
   * evaluated only if the field is not empty
   */
  ignore_empty?: boolean | undefined;
}

/** Fixed32Rules describes the constraints applied to `fixed32` values */
export interface Fixed32Rules {
  $type: "validate.Fixed32Rules";
  /** Const specifies that this field must be exactly the specified value */
  const?:
    | number
    | undefined;
  /**
   * Lt specifies that this field must be less than the specified value,
   * exclusive
   */
  lt?:
    | number
    | undefined;
  /**
   * Lte specifies that this field must be less than or equal to the
   * specified value, inclusive
   */
  lte?:
    | number
    | undefined;
  /**
   * Gt specifies that this field must be greater than the specified value,
   * exclusive. If the value of Gt is larger than a specified Lt or Lte, the
   * range is reversed.
   */
  gt?:
    | number
    | undefined;
  /**
   * Gte specifies that this field must be greater than or equal to the
   * specified value, inclusive. If the value of Gte is larger than a
   * specified Lt or Lte, the range is reversed.
   */
  gte?:
    | number
    | undefined;
  /**
   * In specifies that this field must be equal to one of the specified
   * values
   */
  in?:
    | number[]
    | undefined;
  /**
   * NotIn specifies that this field cannot be equal to one of the specified
   * values
   */
  not_in?:
    | number[]
    | undefined;
  /**
   * IgnoreEmpty specifies that the validation rules of this field should be
   * evaluated only if the field is not empty
   */
  ignore_empty?: boolean | undefined;
}

/** Fixed64Rules describes the constraints applied to `fixed64` values */
export interface Fixed64Rules {
  $type: "validate.Fixed64Rules";
  /** Const specifies that this field must be exactly the specified value */
  const?:
    | number
    | undefined;
  /**
   * Lt specifies that this field must be less than the specified value,
   * exclusive
   */
  lt?:
    | number
    | undefined;
  /**
   * Lte specifies that this field must be less than or equal to the
   * specified value, inclusive
   */
  lte?:
    | number
    | undefined;
  /**
   * Gt specifies that this field must be greater than the specified value,
   * exclusive. If the value of Gt is larger than a specified Lt or Lte, the
   * range is reversed.
   */
  gt?:
    | number
    | undefined;
  /**
   * Gte specifies that this field must be greater than or equal to the
   * specified value, inclusive. If the value of Gte is larger than a
   * specified Lt or Lte, the range is reversed.
   */
  gte?:
    | number
    | undefined;
  /**
   * In specifies that this field must be equal to one of the specified
   * values
   */
  in?:
    | number[]
    | undefined;
  /**
   * NotIn specifies that this field cannot be equal to one of the specified
   * values
   */
  not_in?:
    | number[]
    | undefined;
  /**
   * IgnoreEmpty specifies that the validation rules of this field should be
   * evaluated only if the field is not empty
   */
  ignore_empty?: boolean | undefined;
}

/** SFixed32Rules describes the constraints applied to `sfixed32` values */
export interface SFixed32Rules {
  $type: "validate.SFixed32Rules";
  /** Const specifies that this field must be exactly the specified value */
  const?:
    | number
    | undefined;
  /**
   * Lt specifies that this field must be less than the specified value,
   * exclusive
   */
  lt?:
    | number
    | undefined;
  /**
   * Lte specifies that this field must be less than or equal to the
   * specified value, inclusive
   */
  lte?:
    | number
    | undefined;
  /**
   * Gt specifies that this field must be greater than the specified value,
   * exclusive. If the value of Gt is larger than a specified Lt or Lte, the
   * range is reversed.
   */
  gt?:
    | number
    | undefined;
  /**
   * Gte specifies that this field must be greater than or equal to the
   * specified value, inclusive. If the value of Gte is larger than a
   * specified Lt or Lte, the range is reversed.
   */
  gte?:
    | number
    | undefined;
  /**
   * In specifies that this field must be equal to one of the specified
   * values
   */
  in?:
    | number[]
    | undefined;
  /**
   * NotIn specifies that this field cannot be equal to one of the specified
   * values
   */
  not_in?:
    | number[]
    | undefined;
  /**
   * IgnoreEmpty specifies that the validation rules of this field should be
   * evaluated only if the field is not empty
   */
  ignore_empty?: boolean | undefined;
}

/** SFixed64Rules describes the constraints applied to `sfixed64` values */
export interface SFixed64Rules {
  $type: "validate.SFixed64Rules";
  /** Const specifies that this field must be exactly the specified value */
  const?:
    | number
    | undefined;
  /**
   * Lt specifies that this field must be less than the specified value,
   * exclusive
   */
  lt?:
    | number
    | undefined;
  /**
   * Lte specifies that this field must be less than or equal to the
   * specified value, inclusive
   */
  lte?:
    | number
    | undefined;
  /**
   * Gt specifies that this field must be greater than the specified value,
   * exclusive. If the value of Gt is larger than a specified Lt or Lte, the
   * range is reversed.
   */
  gt?:
    | number
    | undefined;
  /**
   * Gte specifies that this field must be greater than or equal to the
   * specified value, inclusive. If the value of Gte is larger than a
   * specified Lt or Lte, the range is reversed.
   */
  gte?:
    | number
    | undefined;
  /**
   * In specifies that this field must be equal to one of the specified
   * values
   */
  in?:
    | number[]
    | undefined;
  /**
   * NotIn specifies that this field cannot be equal to one of the specified
   * values
   */
  not_in?:
    | number[]
    | undefined;
  /**
   * IgnoreEmpty specifies that the validation rules of this field should be
   * evaluated only if the field is not empty
   */
  ignore_empty?: boolean | undefined;
}

/** BoolRules describes the constraints applied to `bool` values */
export interface BoolRules {
  $type: "validate.BoolRules";
  /** Const specifies that this field must be exactly the specified value */
  const?: boolean | undefined;
}

/** StringRules describe the constraints applied to `string` values */
export interface StringRules {
  $type: "validate.StringRules";
  /** Const specifies that this field must be exactly the specified value */
  const?:
    | string
    | undefined;
  /**
   * Len specifies that this field must be the specified number of
   * characters (Unicode code points). Note that the number of
   * characters may differ from the number of bytes in the string.
   */
  len?:
    | number
    | undefined;
  /**
   * MinLen specifies that this field must be the specified number of
   * characters (Unicode code points) at a minimum. Note that the number of
   * characters may differ from the number of bytes in the string.
   */
  min_len?:
    | number
    | undefined;
  /**
   * MaxLen specifies that this field must be the specified number of
   * characters (Unicode code points) at a maximum. Note that the number of
   * characters may differ from the number of bytes in the string.
   */
  max_len?:
    | number
    | undefined;
  /** LenBytes specifies that this field must be the specified number of bytes */
  len_bytes?:
    | number
    | undefined;
  /**
   * MinBytes specifies that this field must be the specified number of bytes
   * at a minimum
   */
  min_bytes?:
    | number
    | undefined;
  /**
   * MaxBytes specifies that this field must be the specified number of bytes
   * at a maximum
   */
  max_bytes?:
    | number
    | undefined;
  /**
   * Pattern specifes that this field must match against the specified
   * regular expression (RE2 syntax). The included expression should elide
   * any delimiters.
   */
  pattern?:
    | string
    | undefined;
  /**
   * Prefix specifies that this field must have the specified substring at
   * the beginning of the string.
   */
  prefix?:
    | string
    | undefined;
  /**
   * Suffix specifies that this field must have the specified substring at
   * the end of the string.
   */
  suffix?:
    | string
    | undefined;
  /**
   * Contains specifies that this field must have the specified substring
   * anywhere in the string.
   */
  contains?:
    | string
    | undefined;
  /**
   * NotContains specifies that this field cannot have the specified substring
   * anywhere in the string.
   */
  not_contains?:
    | string
    | undefined;
  /**
   * In specifies that this field must be equal to one of the specified
   * values
   */
  in?:
    | string[]
    | undefined;
  /**
   * NotIn specifies that this field cannot be equal to one of the specified
   * values
   */
  not_in?:
    | string[]
    | undefined;
  /**
   * WellKnown rules provide advanced constraints against common string
   * patterns
   */
  well_known?:
    | //
    /**
     * Email specifies that the field must be a valid email address as
     * defined by RFC 5322
     */
    { $case: "email"; email: boolean }
    | //
    /**
     * Hostname specifies that the field must be a valid hostname as
     * defined by RFC 1034. This constraint does not support
     * internationalized domain names (IDNs).
     */
    { $case: "hostname"; hostname: boolean }
    | //
    /**
     * Ip specifies that the field must be a valid IP (v4 or v6) address.
     * Valid IPv6 addresses should not include surrounding square brackets.
     */
    { $case: "ip"; ip: boolean }
    | //
    /** Ipv4 specifies that the field must be a valid IPv4 address. */
    { $case: "ipv4"; ipv4: boolean }
    | //
    /**
     * Ipv6 specifies that the field must be a valid IPv6 address. Valid
     * IPv6 addresses should not include surrounding square brackets.
     */
    { $case: "ipv6"; ipv6: boolean }
    | //
    /**
     * Uri specifies that the field must be a valid, absolute URI as defined
     * by RFC 3986
     */
    { $case: "uri"; uri: boolean }
    | //
    /**
     * UriRef specifies that the field must be a valid URI as defined by RFC
     * 3986 and may be relative or absolute.
     */
    { $case: "uri_ref"; uri_ref: boolean }
    | //
    /**
     * Address specifies that the field must be either a valid hostname as
     * defined by RFC 1034 (which does not support internationalized domain
     * names or IDNs), or it can be a valid IP (v4 or v6).
     */
    { $case: "address"; address: boolean }
    | //
    /**
     * Uuid specifies that the field must be a valid UUID as defined by
     * RFC 4122
     */
    { $case: "uuid"; uuid: boolean }
    | //
    /** WellKnownRegex specifies a common well known pattern defined as a regex. */
    { $case: "well_known_regex"; well_known_regex: KnownRegex }
    | undefined;
  /**
   * This applies to regexes HTTP_HEADER_NAME and HTTP_HEADER_VALUE to enable
   * strict header validation.
   * By default, this is true, and HTTP header validations are RFC-compliant.
   * Setting to false will enable a looser validations that only disallows
   * \r\n\0 characters, which can be used to bypass header matching rules.
   */
  strict?:
    | boolean
    | undefined;
  /**
   * IgnoreEmpty specifies that the validation rules of this field should be
   * evaluated only if the field is not empty
   */
  ignore_empty?: boolean | undefined;
}

/** BytesRules describe the constraints applied to `bytes` values */
export interface BytesRules {
  $type: "validate.BytesRules";
  /** Const specifies that this field must be exactly the specified value */
  const?:
    | Uint8Array
    | undefined;
  /** Len specifies that this field must be the specified number of bytes */
  len?:
    | number
    | undefined;
  /**
   * MinLen specifies that this field must be the specified number of bytes
   * at a minimum
   */
  min_len?:
    | number
    | undefined;
  /**
   * MaxLen specifies that this field must be the specified number of bytes
   * at a maximum
   */
  max_len?:
    | number
    | undefined;
  /**
   * Pattern specifes that this field must match against the specified
   * regular expression (RE2 syntax). The included expression should elide
   * any delimiters.
   */
  pattern?:
    | string
    | undefined;
  /**
   * Prefix specifies that this field must have the specified bytes at the
   * beginning of the string.
   */
  prefix?:
    | Uint8Array
    | undefined;
  /**
   * Suffix specifies that this field must have the specified bytes at the
   * end of the string.
   */
  suffix?:
    | Uint8Array
    | undefined;
  /**
   * Contains specifies that this field must have the specified bytes
   * anywhere in the string.
   */
  contains?:
    | Uint8Array
    | undefined;
  /**
   * In specifies that this field must be equal to one of the specified
   * values
   */
  in?:
    | Uint8Array[]
    | undefined;
  /**
   * NotIn specifies that this field cannot be equal to one of the specified
   * values
   */
  not_in?:
    | Uint8Array[]
    | undefined;
  /**
   * WellKnown rules provide advanced constraints against common byte
   * patterns
   */
  well_known?:
    | //
    /**
     * Ip specifies that the field must be a valid IP (v4 or v6) address in
     * byte format
     */
    { $case: "ip"; ip: boolean }
    | //
    /**
     * Ipv4 specifies that the field must be a valid IPv4 address in byte
     * format
     */
    { $case: "ipv4"; ipv4: boolean }
    | //
    /**
     * Ipv6 specifies that the field must be a valid IPv6 address in byte
     * format
     */
    { $case: "ipv6"; ipv6: boolean }
    | undefined;
  /**
   * IgnoreEmpty specifies that the validation rules of this field should be
   * evaluated only if the field is not empty
   */
  ignore_empty?: boolean | undefined;
}

/** EnumRules describe the constraints applied to enum values */
export interface EnumRules {
  $type: "validate.EnumRules";
  /** Const specifies that this field must be exactly the specified value */
  const?:
    | number
    | undefined;
  /**
   * DefinedOnly specifies that this field must be only one of the defined
   * values for this enum, failing on any undefined value.
   */
  defined_only?:
    | boolean
    | undefined;
  /**
   * In specifies that this field must be equal to one of the specified
   * values
   */
  in?:
    | number[]
    | undefined;
  /**
   * NotIn specifies that this field cannot be equal to one of the specified
   * values
   */
  not_in?: number[] | undefined;
}

/**
 * MessageRules describe the constraints applied to embedded message values.
 * For message-type fields, validation is performed recursively.
 */
export interface MessageRules {
  $type: "validate.MessageRules";
  /**
   * Skip specifies that the validation rules of this field should not be
   * evaluated
   */
  skip?:
    | boolean
    | undefined;
  /** Required specifies that this field must be set */
  required?: boolean | undefined;
}

/** RepeatedRules describe the constraints applied to `repeated` values */
export interface RepeatedRules {
  $type: "validate.RepeatedRules";
  /**
   * MinItems specifies that this field must have the specified number of
   * items at a minimum
   */
  min_items?:
    | number
    | undefined;
  /**
   * MaxItems specifies that this field must have the specified number of
   * items at a maximum
   */
  max_items?:
    | number
    | undefined;
  /**
   * Unique specifies that all elements in this field must be unique. This
   * contraint is only applicable to scalar and enum types (messages are not
   * supported).
   */
  unique?:
    | boolean
    | undefined;
  /**
   * Items specifies the contraints to be applied to each item in the field.
   * Repeated message fields will still execute validation against each item
   * unless skip is specified here.
   */
  items?:
    | FieldRules
    | undefined;
  /**
   * IgnoreEmpty specifies that the validation rules of this field should be
   * evaluated only if the field is not empty
   */
  ignore_empty?: boolean | undefined;
}

/** MapRules describe the constraints applied to `map` values */
export interface MapRules {
  $type: "validate.MapRules";
  /**
   * MinPairs specifies that this field must have the specified number of
   * KVs at a minimum
   */
  min_pairs?:
    | number
    | undefined;
  /**
   * MaxPairs specifies that this field must have the specified number of
   * KVs at a maximum
   */
  max_pairs?:
    | number
    | undefined;
  /**
   * NoSparse specifies values in this field cannot be unset. This only
   * applies to map's with message value types.
   */
  no_sparse?:
    | boolean
    | undefined;
  /** Keys specifies the constraints to be applied to each key in the field. */
  keys?:
    | FieldRules
    | undefined;
  /**
   * Values specifies the constraints to be applied to the value of each key
   * in the field. Message values will still have their validations evaluated
   * unless skip is specified here.
   */
  values?:
    | FieldRules
    | undefined;
  /**
   * IgnoreEmpty specifies that the validation rules of this field should be
   * evaluated only if the field is not empty
   */
  ignore_empty?: boolean | undefined;
}

/**
 * AnyRules describe constraints applied exclusively to the
 * `google.protobuf.Any` well-known type
 */
export interface AnyRules {
  $type: "validate.AnyRules";
  /** Required specifies that this field must be set */
  required?:
    | boolean
    | undefined;
  /**
   * In specifies that this field's `type_url` must be equal to one of the
   * specified values.
   */
  in?:
    | string[]
    | undefined;
  /**
   * NotIn specifies that this field's `type_url` must not be equal to any of
   * the specified values.
   */
  not_in?: string[] | undefined;
}

/**
 * DurationRules describe the constraints applied exclusively to the
 * `google.protobuf.Duration` well-known type
 */
export interface DurationRules {
  $type: "validate.DurationRules";
  /** Required specifies that this field must be set */
  required?:
    | boolean
    | undefined;
  /** Const specifies that this field must be exactly the specified value */
  const?:
    | Duration
    | undefined;
  /**
   * Lt specifies that this field must be less than the specified value,
   * exclusive
   */
  lt?:
    | Duration
    | undefined;
  /**
   * Lt specifies that this field must be less than the specified value,
   * inclusive
   */
  lte?:
    | Duration
    | undefined;
  /**
   * Gt specifies that this field must be greater than the specified value,
   * exclusive
   */
  gt?:
    | Duration
    | undefined;
  /**
   * Gte specifies that this field must be greater than the specified value,
   * inclusive
   */
  gte?:
    | Duration
    | undefined;
  /**
   * In specifies that this field must be equal to one of the specified
   * values
   */
  in?:
    | Duration[]
    | undefined;
  /**
   * NotIn specifies that this field cannot be equal to one of the specified
   * values
   */
  not_in?: Duration[] | undefined;
}

/**
 * TimestampRules describe the constraints applied exclusively to the
 * `google.protobuf.Timestamp` well-known type
 */
export interface TimestampRules {
  $type: "validate.TimestampRules";
  /** Required specifies that this field must be set */
  required?:
    | boolean
    | undefined;
  /** Const specifies that this field must be exactly the specified value */
  const?:
    | Date
    | undefined;
  /**
   * Lt specifies that this field must be less than the specified value,
   * exclusive
   */
  lt?:
    | Date
    | undefined;
  /**
   * Lte specifies that this field must be less than the specified value,
   * inclusive
   */
  lte?:
    | Date
    | undefined;
  /**
   * Gt specifies that this field must be greater than the specified value,
   * exclusive
   */
  gt?:
    | Date
    | undefined;
  /**
   * Gte specifies that this field must be greater than the specified value,
   * inclusive
   */
  gte?:
    | Date
    | undefined;
  /**
   * LtNow specifies that this must be less than the current time. LtNow
   * can only be used with the Within rule.
   */
  lt_now?:
    | boolean
    | undefined;
  /**
   * GtNow specifies that this must be greater than the current time. GtNow
   * can only be used with the Within rule.
   */
  gt_now?:
    | boolean
    | undefined;
  /**
   * Within specifies that this field must be within this duration of the
   * current time. This constraint can be used alone or with the LtNow and
   * GtNow rules.
   */
  within?: Duration | undefined;
}

function createBaseFieldRules(): FieldRules {
  return { $type: "validate.FieldRules", type: undefined };
}

export const FieldRules: MessageFns<FieldRules, "validate.FieldRules"> = {
  $type: "validate.FieldRules" as const,

  encode(message: FieldRules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== undefined) {
      MessageRules.encode(message.message, writer.uint32(138).fork()).join();
    }
    switch (message.type?.$case) {
      case "float":
        FloatRules.encode(message.type.float, writer.uint32(10).fork()).join();
        break;
      case "double":
        DoubleRules.encode(message.type.double, writer.uint32(18).fork()).join();
        break;
      case "int32":
        Int32Rules.encode(message.type.int32, writer.uint32(26).fork()).join();
        break;
      case "int64":
        Int64Rules.encode(message.type.int64, writer.uint32(34).fork()).join();
        break;
      case "uint32":
        UInt32Rules.encode(message.type.uint32, writer.uint32(42).fork()).join();
        break;
      case "uint64":
        UInt64Rules.encode(message.type.uint64, writer.uint32(50).fork()).join();
        break;
      case "sint32":
        SInt32Rules.encode(message.type.sint32, writer.uint32(58).fork()).join();
        break;
      case "sint64":
        SInt64Rules.encode(message.type.sint64, writer.uint32(66).fork()).join();
        break;
      case "fixed32":
        Fixed32Rules.encode(message.type.fixed32, writer.uint32(74).fork()).join();
        break;
      case "fixed64":
        Fixed64Rules.encode(message.type.fixed64, writer.uint32(82).fork()).join();
        break;
      case "sfixed32":
        SFixed32Rules.encode(message.type.sfixed32, writer.uint32(90).fork()).join();
        break;
      case "sfixed64":
        SFixed64Rules.encode(message.type.sfixed64, writer.uint32(98).fork()).join();
        break;
      case "bool":
        BoolRules.encode(message.type.bool, writer.uint32(106).fork()).join();
        break;
      case "string":
        StringRules.encode(message.type.string, writer.uint32(114).fork()).join();
        break;
      case "bytes":
        BytesRules.encode(message.type.bytes, writer.uint32(122).fork()).join();
        break;
      case "enum":
        EnumRules.encode(message.type.enum, writer.uint32(130).fork()).join();
        break;
      case "repeated":
        RepeatedRules.encode(message.type.repeated, writer.uint32(146).fork()).join();
        break;
      case "map":
        MapRules.encode(message.type.map, writer.uint32(154).fork()).join();
        break;
      case "any":
        AnyRules.encode(message.type.any, writer.uint32(162).fork()).join();
        break;
      case "duration":
        DurationRules.encode(message.type.duration, writer.uint32(170).fork()).join();
        break;
      case "timestamp":
        TimestampRules.encode(message.type.timestamp, writer.uint32(178).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FieldRules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFieldRules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.message = MessageRules.decode(reader, reader.uint32());
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = { $case: "float", float: FloatRules.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type = { $case: "double", double: DoubleRules.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.type = { $case: "int32", int32: Int32Rules.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.type = { $case: "int64", int64: Int64Rules.decode(reader, reader.uint32()) };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.type = { $case: "uint32", uint32: UInt32Rules.decode(reader, reader.uint32()) };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.type = { $case: "uint64", uint64: UInt64Rules.decode(reader, reader.uint32()) };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.type = { $case: "sint32", sint32: SInt32Rules.decode(reader, reader.uint32()) };
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.type = { $case: "sint64", sint64: SInt64Rules.decode(reader, reader.uint32()) };
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.type = { $case: "fixed32", fixed32: Fixed32Rules.decode(reader, reader.uint32()) };
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.type = { $case: "fixed64", fixed64: Fixed64Rules.decode(reader, reader.uint32()) };
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.type = { $case: "sfixed32", sfixed32: SFixed32Rules.decode(reader, reader.uint32()) };
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.type = { $case: "sfixed64", sfixed64: SFixed64Rules.decode(reader, reader.uint32()) };
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.type = { $case: "bool", bool: BoolRules.decode(reader, reader.uint32()) };
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.type = { $case: "string", string: StringRules.decode(reader, reader.uint32()) };
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.type = { $case: "bytes", bytes: BytesRules.decode(reader, reader.uint32()) };
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.type = { $case: "enum", enum: EnumRules.decode(reader, reader.uint32()) };
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.type = { $case: "repeated", repeated: RepeatedRules.decode(reader, reader.uint32()) };
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.type = { $case: "map", map: MapRules.decode(reader, reader.uint32()) };
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.type = { $case: "any", any: AnyRules.decode(reader, reader.uint32()) };
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.type = { $case: "duration", duration: DurationRules.decode(reader, reader.uint32()) };
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.type = { $case: "timestamp", timestamp: TimestampRules.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FieldRules {
    return {
      $type: FieldRules.$type,
      message: isSet(object.message) ? MessageRules.fromJSON(object.message) : undefined,
      type: isSet(object.float)
        ? { $case: "float", float: FloatRules.fromJSON(object.float) }
        : isSet(object.double)
        ? { $case: "double", double: DoubleRules.fromJSON(object.double) }
        : isSet(object.int32)
        ? { $case: "int32", int32: Int32Rules.fromJSON(object.int32) }
        : isSet(object.int64)
        ? { $case: "int64", int64: Int64Rules.fromJSON(object.int64) }
        : isSet(object.uint32)
        ? { $case: "uint32", uint32: UInt32Rules.fromJSON(object.uint32) }
        : isSet(object.uint64)
        ? { $case: "uint64", uint64: UInt64Rules.fromJSON(object.uint64) }
        : isSet(object.sint32)
        ? { $case: "sint32", sint32: SInt32Rules.fromJSON(object.sint32) }
        : isSet(object.sint64)
        ? { $case: "sint64", sint64: SInt64Rules.fromJSON(object.sint64) }
        : isSet(object.fixed32)
        ? { $case: "fixed32", fixed32: Fixed32Rules.fromJSON(object.fixed32) }
        : isSet(object.fixed64)
        ? { $case: "fixed64", fixed64: Fixed64Rules.fromJSON(object.fixed64) }
        : isSet(object.sfixed32)
        ? { $case: "sfixed32", sfixed32: SFixed32Rules.fromJSON(object.sfixed32) }
        : isSet(object.sfixed64)
        ? { $case: "sfixed64", sfixed64: SFixed64Rules.fromJSON(object.sfixed64) }
        : isSet(object.bool)
        ? { $case: "bool", bool: BoolRules.fromJSON(object.bool) }
        : isSet(object.string)
        ? { $case: "string", string: StringRules.fromJSON(object.string) }
        : isSet(object.bytes)
        ? { $case: "bytes", bytes: BytesRules.fromJSON(object.bytes) }
        : isSet(object.enum)
        ? { $case: "enum", enum: EnumRules.fromJSON(object.enum) }
        : isSet(object.repeated)
        ? { $case: "repeated", repeated: RepeatedRules.fromJSON(object.repeated) }
        : isSet(object.map)
        ? { $case: "map", map: MapRules.fromJSON(object.map) }
        : isSet(object.any)
        ? { $case: "any", any: AnyRules.fromJSON(object.any) }
        : isSet(object.duration)
        ? { $case: "duration", duration: DurationRules.fromJSON(object.duration) }
        : isSet(object.timestamp)
        ? { $case: "timestamp", timestamp: TimestampRules.fromJSON(object.timestamp) }
        : undefined,
    };
  },

  toJSON(message: FieldRules): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = MessageRules.toJSON(message.message);
    }
    if (message.type?.$case === "float") {
      obj.float = FloatRules.toJSON(message.type.float);
    }
    if (message.type?.$case === "double") {
      obj.double = DoubleRules.toJSON(message.type.double);
    }
    if (message.type?.$case === "int32") {
      obj.int32 = Int32Rules.toJSON(message.type.int32);
    }
    if (message.type?.$case === "int64") {
      obj.int64 = Int64Rules.toJSON(message.type.int64);
    }
    if (message.type?.$case === "uint32") {
      obj.uint32 = UInt32Rules.toJSON(message.type.uint32);
    }
    if (message.type?.$case === "uint64") {
      obj.uint64 = UInt64Rules.toJSON(message.type.uint64);
    }
    if (message.type?.$case === "sint32") {
      obj.sint32 = SInt32Rules.toJSON(message.type.sint32);
    }
    if (message.type?.$case === "sint64") {
      obj.sint64 = SInt64Rules.toJSON(message.type.sint64);
    }
    if (message.type?.$case === "fixed32") {
      obj.fixed32 = Fixed32Rules.toJSON(message.type.fixed32);
    }
    if (message.type?.$case === "fixed64") {
      obj.fixed64 = Fixed64Rules.toJSON(message.type.fixed64);
    }
    if (message.type?.$case === "sfixed32") {
      obj.sfixed32 = SFixed32Rules.toJSON(message.type.sfixed32);
    }
    if (message.type?.$case === "sfixed64") {
      obj.sfixed64 = SFixed64Rules.toJSON(message.type.sfixed64);
    }
    if (message.type?.$case === "bool") {
      obj.bool = BoolRules.toJSON(message.type.bool);
    }
    if (message.type?.$case === "string") {
      obj.string = StringRules.toJSON(message.type.string);
    }
    if (message.type?.$case === "bytes") {
      obj.bytes = BytesRules.toJSON(message.type.bytes);
    }
    if (message.type?.$case === "enum") {
      obj.enum = EnumRules.toJSON(message.type.enum);
    }
    if (message.type?.$case === "repeated") {
      obj.repeated = RepeatedRules.toJSON(message.type.repeated);
    }
    if (message.type?.$case === "map") {
      obj.map = MapRules.toJSON(message.type.map);
    }
    if (message.type?.$case === "any") {
      obj.any = AnyRules.toJSON(message.type.any);
    }
    if (message.type?.$case === "duration") {
      obj.duration = DurationRules.toJSON(message.type.duration);
    }
    if (message.type?.$case === "timestamp") {
      obj.timestamp = TimestampRules.toJSON(message.type.timestamp);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FieldRules>, I>>(base?: I): FieldRules {
    return FieldRules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FieldRules>, I>>(object: I): FieldRules {
    const message = createBaseFieldRules();
    message.message = (object.message !== undefined && object.message !== null)
      ? MessageRules.fromPartial(object.message)
      : undefined;
    if (object.type?.$case === "float" && object.type?.float !== undefined && object.type?.float !== null) {
      message.type = { $case: "float", float: FloatRules.fromPartial(object.type.float) };
    }
    if (object.type?.$case === "double" && object.type?.double !== undefined && object.type?.double !== null) {
      message.type = { $case: "double", double: DoubleRules.fromPartial(object.type.double) };
    }
    if (object.type?.$case === "int32" && object.type?.int32 !== undefined && object.type?.int32 !== null) {
      message.type = { $case: "int32", int32: Int32Rules.fromPartial(object.type.int32) };
    }
    if (object.type?.$case === "int64" && object.type?.int64 !== undefined && object.type?.int64 !== null) {
      message.type = { $case: "int64", int64: Int64Rules.fromPartial(object.type.int64) };
    }
    if (object.type?.$case === "uint32" && object.type?.uint32 !== undefined && object.type?.uint32 !== null) {
      message.type = { $case: "uint32", uint32: UInt32Rules.fromPartial(object.type.uint32) };
    }
    if (object.type?.$case === "uint64" && object.type?.uint64 !== undefined && object.type?.uint64 !== null) {
      message.type = { $case: "uint64", uint64: UInt64Rules.fromPartial(object.type.uint64) };
    }
    if (object.type?.$case === "sint32" && object.type?.sint32 !== undefined && object.type?.sint32 !== null) {
      message.type = { $case: "sint32", sint32: SInt32Rules.fromPartial(object.type.sint32) };
    }
    if (object.type?.$case === "sint64" && object.type?.sint64 !== undefined && object.type?.sint64 !== null) {
      message.type = { $case: "sint64", sint64: SInt64Rules.fromPartial(object.type.sint64) };
    }
    if (object.type?.$case === "fixed32" && object.type?.fixed32 !== undefined && object.type?.fixed32 !== null) {
      message.type = { $case: "fixed32", fixed32: Fixed32Rules.fromPartial(object.type.fixed32) };
    }
    if (object.type?.$case === "fixed64" && object.type?.fixed64 !== undefined && object.type?.fixed64 !== null) {
      message.type = { $case: "fixed64", fixed64: Fixed64Rules.fromPartial(object.type.fixed64) };
    }
    if (object.type?.$case === "sfixed32" && object.type?.sfixed32 !== undefined && object.type?.sfixed32 !== null) {
      message.type = { $case: "sfixed32", sfixed32: SFixed32Rules.fromPartial(object.type.sfixed32) };
    }
    if (object.type?.$case === "sfixed64" && object.type?.sfixed64 !== undefined && object.type?.sfixed64 !== null) {
      message.type = { $case: "sfixed64", sfixed64: SFixed64Rules.fromPartial(object.type.sfixed64) };
    }
    if (object.type?.$case === "bool" && object.type?.bool !== undefined && object.type?.bool !== null) {
      message.type = { $case: "bool", bool: BoolRules.fromPartial(object.type.bool) };
    }
    if (object.type?.$case === "string" && object.type?.string !== undefined && object.type?.string !== null) {
      message.type = { $case: "string", string: StringRules.fromPartial(object.type.string) };
    }
    if (object.type?.$case === "bytes" && object.type?.bytes !== undefined && object.type?.bytes !== null) {
      message.type = { $case: "bytes", bytes: BytesRules.fromPartial(object.type.bytes) };
    }
    if (object.type?.$case === "enum" && object.type?.enum !== undefined && object.type?.enum !== null) {
      message.type = { $case: "enum", enum: EnumRules.fromPartial(object.type.enum) };
    }
    if (object.type?.$case === "repeated" && object.type?.repeated !== undefined && object.type?.repeated !== null) {
      message.type = { $case: "repeated", repeated: RepeatedRules.fromPartial(object.type.repeated) };
    }
    if (object.type?.$case === "map" && object.type?.map !== undefined && object.type?.map !== null) {
      message.type = { $case: "map", map: MapRules.fromPartial(object.type.map) };
    }
    if (object.type?.$case === "any" && object.type?.any !== undefined && object.type?.any !== null) {
      message.type = { $case: "any", any: AnyRules.fromPartial(object.type.any) };
    }
    if (object.type?.$case === "duration" && object.type?.duration !== undefined && object.type?.duration !== null) {
      message.type = { $case: "duration", duration: DurationRules.fromPartial(object.type.duration) };
    }
    if (object.type?.$case === "timestamp" && object.type?.timestamp !== undefined && object.type?.timestamp !== null) {
      message.type = { $case: "timestamp", timestamp: TimestampRules.fromPartial(object.type.timestamp) };
    }
    return message;
  },
};

messageTypeRegistry.set(FieldRules.$type, FieldRules);

function createBaseFloatRules(): FloatRules {
  return { $type: "validate.FloatRules" };
}

export const FloatRules: MessageFns<FloatRules, "validate.FloatRules"> = {
  $type: "validate.FloatRules" as const,

  encode(message: FloatRules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.const !== undefined && message.const !== 0) {
      writer.uint32(13).float(message.const);
    }
    if (message.lt !== undefined && message.lt !== 0) {
      writer.uint32(21).float(message.lt);
    }
    if (message.lte !== undefined && message.lte !== 0) {
      writer.uint32(29).float(message.lte);
    }
    if (message.gt !== undefined && message.gt !== 0) {
      writer.uint32(37).float(message.gt);
    }
    if (message.gte !== undefined && message.gte !== 0) {
      writer.uint32(45).float(message.gte);
    }
    if (message.in !== undefined && message.in.length !== 0) {
      writer.uint32(50).fork();
      for (const v of message.in) {
        writer.float(v);
      }
      writer.join();
    }
    if (message.not_in !== undefined && message.not_in.length !== 0) {
      writer.uint32(58).fork();
      for (const v of message.not_in) {
        writer.float(v);
      }
      writer.join();
    }
    if (message.ignore_empty !== undefined && message.ignore_empty !== false) {
      writer.uint32(64).bool(message.ignore_empty);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FloatRules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFloatRules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.const = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.lt = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.lte = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.gt = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.gte = reader.float();
          continue;
        }
        case 6: {
          if (tag === 53) {
            if (message.in === undefined) {
              message.in = [];
            }
            message.in!.push(reader.float());

            continue;
          }

          if (tag === 50) {
            if (message.in === undefined) {
              message.in = [];
            }
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.in!.push(reader.float());
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag === 61) {
            if (message.not_in === undefined) {
              message.not_in = [];
            }
            message.not_in!.push(reader.float());

            continue;
          }

          if (tag === 58) {
            if (message.not_in === undefined) {
              message.not_in = [];
            }
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.not_in!.push(reader.float());
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.ignore_empty = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FloatRules {
    return {
      $type: FloatRules.$type,
      const: isSet(object.const) ? globalThis.Number(object.const) : undefined,
      lt: isSet(object.lt) ? globalThis.Number(object.lt) : undefined,
      lte: isSet(object.lte) ? globalThis.Number(object.lte) : undefined,
      gt: isSet(object.gt) ? globalThis.Number(object.gt) : undefined,
      gte: isSet(object.gte) ? globalThis.Number(object.gte) : undefined,
      in: globalThis.Array.isArray(object?.in) ? object.in.map((e: any) => globalThis.Number(e)) : undefined,
      not_in: globalThis.Array.isArray(object?.not_in)
        ? object.not_in.map((e: any) => globalThis.Number(e))
        : undefined,
      ignore_empty: isSet(object.ignore_empty) ? globalThis.Boolean(object.ignore_empty) : undefined,
    };
  },

  toJSON(message: FloatRules): unknown {
    const obj: any = {};
    if (message.const !== undefined) {
      obj.const = message.const;
    }
    if (message.lt !== undefined) {
      obj.lt = message.lt;
    }
    if (message.lte !== undefined) {
      obj.lte = message.lte;
    }
    if (message.gt !== undefined) {
      obj.gt = message.gt;
    }
    if (message.gte !== undefined) {
      obj.gte = message.gte;
    }
    if (message.in?.length) {
      obj.in = message.in;
    }
    if (message.not_in?.length) {
      obj.not_in = message.not_in;
    }
    if (message.ignore_empty !== undefined) {
      obj.ignore_empty = message.ignore_empty;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FloatRules>, I>>(base?: I): FloatRules {
    return FloatRules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FloatRules>, I>>(object: I): FloatRules {
    const message = createBaseFloatRules();
    message.const = object.const ?? undefined;
    message.lt = object.lt ?? undefined;
    message.lte = object.lte ?? undefined;
    message.gt = object.gt ?? undefined;
    message.gte = object.gte ?? undefined;
    message.in = object.in?.map((e) => e) || undefined;
    message.not_in = object.not_in?.map((e) => e) || undefined;
    message.ignore_empty = object.ignore_empty ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(FloatRules.$type, FloatRules);

function createBaseDoubleRules(): DoubleRules {
  return { $type: "validate.DoubleRules" };
}

export const DoubleRules: MessageFns<DoubleRules, "validate.DoubleRules"> = {
  $type: "validate.DoubleRules" as const,

  encode(message: DoubleRules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.const !== undefined && message.const !== 0) {
      writer.uint32(9).double(message.const);
    }
    if (message.lt !== undefined && message.lt !== 0) {
      writer.uint32(17).double(message.lt);
    }
    if (message.lte !== undefined && message.lte !== 0) {
      writer.uint32(25).double(message.lte);
    }
    if (message.gt !== undefined && message.gt !== 0) {
      writer.uint32(33).double(message.gt);
    }
    if (message.gte !== undefined && message.gte !== 0) {
      writer.uint32(41).double(message.gte);
    }
    if (message.in !== undefined && message.in.length !== 0) {
      writer.uint32(50).fork();
      for (const v of message.in) {
        writer.double(v);
      }
      writer.join();
    }
    if (message.not_in !== undefined && message.not_in.length !== 0) {
      writer.uint32(58).fork();
      for (const v of message.not_in) {
        writer.double(v);
      }
      writer.join();
    }
    if (message.ignore_empty !== undefined && message.ignore_empty !== false) {
      writer.uint32(64).bool(message.ignore_empty);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DoubleRules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDoubleRules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.const = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.lt = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.lte = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.gt = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.gte = reader.double();
          continue;
        }
        case 6: {
          if (tag === 49) {
            if (message.in === undefined) {
              message.in = [];
            }
            message.in!.push(reader.double());

            continue;
          }

          if (tag === 50) {
            if (message.in === undefined) {
              message.in = [];
            }
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.in!.push(reader.double());
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag === 57) {
            if (message.not_in === undefined) {
              message.not_in = [];
            }
            message.not_in!.push(reader.double());

            continue;
          }

          if (tag === 58) {
            if (message.not_in === undefined) {
              message.not_in = [];
            }
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.not_in!.push(reader.double());
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.ignore_empty = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DoubleRules {
    return {
      $type: DoubleRules.$type,
      const: isSet(object.const) ? globalThis.Number(object.const) : undefined,
      lt: isSet(object.lt) ? globalThis.Number(object.lt) : undefined,
      lte: isSet(object.lte) ? globalThis.Number(object.lte) : undefined,
      gt: isSet(object.gt) ? globalThis.Number(object.gt) : undefined,
      gte: isSet(object.gte) ? globalThis.Number(object.gte) : undefined,
      in: globalThis.Array.isArray(object?.in) ? object.in.map((e: any) => globalThis.Number(e)) : undefined,
      not_in: globalThis.Array.isArray(object?.not_in)
        ? object.not_in.map((e: any) => globalThis.Number(e))
        : undefined,
      ignore_empty: isSet(object.ignore_empty) ? globalThis.Boolean(object.ignore_empty) : undefined,
    };
  },

  toJSON(message: DoubleRules): unknown {
    const obj: any = {};
    if (message.const !== undefined) {
      obj.const = message.const;
    }
    if (message.lt !== undefined) {
      obj.lt = message.lt;
    }
    if (message.lte !== undefined) {
      obj.lte = message.lte;
    }
    if (message.gt !== undefined) {
      obj.gt = message.gt;
    }
    if (message.gte !== undefined) {
      obj.gte = message.gte;
    }
    if (message.in?.length) {
      obj.in = message.in;
    }
    if (message.not_in?.length) {
      obj.not_in = message.not_in;
    }
    if (message.ignore_empty !== undefined) {
      obj.ignore_empty = message.ignore_empty;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DoubleRules>, I>>(base?: I): DoubleRules {
    return DoubleRules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DoubleRules>, I>>(object: I): DoubleRules {
    const message = createBaseDoubleRules();
    message.const = object.const ?? undefined;
    message.lt = object.lt ?? undefined;
    message.lte = object.lte ?? undefined;
    message.gt = object.gt ?? undefined;
    message.gte = object.gte ?? undefined;
    message.in = object.in?.map((e) => e) || undefined;
    message.not_in = object.not_in?.map((e) => e) || undefined;
    message.ignore_empty = object.ignore_empty ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(DoubleRules.$type, DoubleRules);

function createBaseInt32Rules(): Int32Rules {
  return { $type: "validate.Int32Rules" };
}

export const Int32Rules: MessageFns<Int32Rules, "validate.Int32Rules"> = {
  $type: "validate.Int32Rules" as const,

  encode(message: Int32Rules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.const !== undefined && message.const !== 0) {
      writer.uint32(8).int32(message.const);
    }
    if (message.lt !== undefined && message.lt !== 0) {
      writer.uint32(16).int32(message.lt);
    }
    if (message.lte !== undefined && message.lte !== 0) {
      writer.uint32(24).int32(message.lte);
    }
    if (message.gt !== undefined && message.gt !== 0) {
      writer.uint32(32).int32(message.gt);
    }
    if (message.gte !== undefined && message.gte !== 0) {
      writer.uint32(40).int32(message.gte);
    }
    if (message.in !== undefined && message.in.length !== 0) {
      writer.uint32(50).fork();
      for (const v of message.in) {
        writer.int32(v);
      }
      writer.join();
    }
    if (message.not_in !== undefined && message.not_in.length !== 0) {
      writer.uint32(58).fork();
      for (const v of message.not_in) {
        writer.int32(v);
      }
      writer.join();
    }
    if (message.ignore_empty !== undefined && message.ignore_empty !== false) {
      writer.uint32(64).bool(message.ignore_empty);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Int32Rules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInt32Rules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.const = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.lt = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.lte = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.gt = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.gte = reader.int32();
          continue;
        }
        case 6: {
          if (tag === 48) {
            if (message.in === undefined) {
              message.in = [];
            }
            message.in!.push(reader.int32());

            continue;
          }

          if (tag === 50) {
            if (message.in === undefined) {
              message.in = [];
            }
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.in!.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag === 56) {
            if (message.not_in === undefined) {
              message.not_in = [];
            }
            message.not_in!.push(reader.int32());

            continue;
          }

          if (tag === 58) {
            if (message.not_in === undefined) {
              message.not_in = [];
            }
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.not_in!.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.ignore_empty = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Int32Rules {
    return {
      $type: Int32Rules.$type,
      const: isSet(object.const) ? globalThis.Number(object.const) : undefined,
      lt: isSet(object.lt) ? globalThis.Number(object.lt) : undefined,
      lte: isSet(object.lte) ? globalThis.Number(object.lte) : undefined,
      gt: isSet(object.gt) ? globalThis.Number(object.gt) : undefined,
      gte: isSet(object.gte) ? globalThis.Number(object.gte) : undefined,
      in: globalThis.Array.isArray(object?.in) ? object.in.map((e: any) => globalThis.Number(e)) : undefined,
      not_in: globalThis.Array.isArray(object?.not_in)
        ? object.not_in.map((e: any) => globalThis.Number(e))
        : undefined,
      ignore_empty: isSet(object.ignore_empty) ? globalThis.Boolean(object.ignore_empty) : undefined,
    };
  },

  toJSON(message: Int32Rules): unknown {
    const obj: any = {};
    if (message.const !== undefined) {
      obj.const = Math.round(message.const);
    }
    if (message.lt !== undefined) {
      obj.lt = Math.round(message.lt);
    }
    if (message.lte !== undefined) {
      obj.lte = Math.round(message.lte);
    }
    if (message.gt !== undefined) {
      obj.gt = Math.round(message.gt);
    }
    if (message.gte !== undefined) {
      obj.gte = Math.round(message.gte);
    }
    if (message.in?.length) {
      obj.in = message.in.map((e) => Math.round(e));
    }
    if (message.not_in?.length) {
      obj.not_in = message.not_in.map((e) => Math.round(e));
    }
    if (message.ignore_empty !== undefined) {
      obj.ignore_empty = message.ignore_empty;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Int32Rules>, I>>(base?: I): Int32Rules {
    return Int32Rules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Int32Rules>, I>>(object: I): Int32Rules {
    const message = createBaseInt32Rules();
    message.const = object.const ?? undefined;
    message.lt = object.lt ?? undefined;
    message.lte = object.lte ?? undefined;
    message.gt = object.gt ?? undefined;
    message.gte = object.gte ?? undefined;
    message.in = object.in?.map((e) => e) || undefined;
    message.not_in = object.not_in?.map((e) => e) || undefined;
    message.ignore_empty = object.ignore_empty ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Int32Rules.$type, Int32Rules);

function createBaseInt64Rules(): Int64Rules {
  return { $type: "validate.Int64Rules" };
}

export const Int64Rules: MessageFns<Int64Rules, "validate.Int64Rules"> = {
  $type: "validate.Int64Rules" as const,

  encode(message: Int64Rules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.const !== undefined && message.const !== 0) {
      writer.uint32(8).int64(message.const);
    }
    if (message.lt !== undefined && message.lt !== 0) {
      writer.uint32(16).int64(message.lt);
    }
    if (message.lte !== undefined && message.lte !== 0) {
      writer.uint32(24).int64(message.lte);
    }
    if (message.gt !== undefined && message.gt !== 0) {
      writer.uint32(32).int64(message.gt);
    }
    if (message.gte !== undefined && message.gte !== 0) {
      writer.uint32(40).int64(message.gte);
    }
    if (message.in !== undefined && message.in.length !== 0) {
      writer.uint32(50).fork();
      for (const v of message.in) {
        writer.int64(v);
      }
      writer.join();
    }
    if (message.not_in !== undefined && message.not_in.length !== 0) {
      writer.uint32(58).fork();
      for (const v of message.not_in) {
        writer.int64(v);
      }
      writer.join();
    }
    if (message.ignore_empty !== undefined && message.ignore_empty !== false) {
      writer.uint32(64).bool(message.ignore_empty);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Int64Rules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInt64Rules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.const = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.lt = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.lte = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.gt = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.gte = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag === 48) {
            if (message.in === undefined) {
              message.in = [];
            }
            message.in!.push(longToNumber(reader.int64()));

            continue;
          }

          if (tag === 50) {
            if (message.in === undefined) {
              message.in = [];
            }
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.in!.push(longToNumber(reader.int64()));
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag === 56) {
            if (message.not_in === undefined) {
              message.not_in = [];
            }
            message.not_in!.push(longToNumber(reader.int64()));

            continue;
          }

          if (tag === 58) {
            if (message.not_in === undefined) {
              message.not_in = [];
            }
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.not_in!.push(longToNumber(reader.int64()));
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.ignore_empty = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Int64Rules {
    return {
      $type: Int64Rules.$type,
      const: isSet(object.const) ? globalThis.Number(object.const) : undefined,
      lt: isSet(object.lt) ? globalThis.Number(object.lt) : undefined,
      lte: isSet(object.lte) ? globalThis.Number(object.lte) : undefined,
      gt: isSet(object.gt) ? globalThis.Number(object.gt) : undefined,
      gte: isSet(object.gte) ? globalThis.Number(object.gte) : undefined,
      in: globalThis.Array.isArray(object?.in) ? object.in.map((e: any) => globalThis.Number(e)) : undefined,
      not_in: globalThis.Array.isArray(object?.not_in)
        ? object.not_in.map((e: any) => globalThis.Number(e))
        : undefined,
      ignore_empty: isSet(object.ignore_empty) ? globalThis.Boolean(object.ignore_empty) : undefined,
    };
  },

  toJSON(message: Int64Rules): unknown {
    const obj: any = {};
    if (message.const !== undefined) {
      obj.const = Math.round(message.const);
    }
    if (message.lt !== undefined) {
      obj.lt = Math.round(message.lt);
    }
    if (message.lte !== undefined) {
      obj.lte = Math.round(message.lte);
    }
    if (message.gt !== undefined) {
      obj.gt = Math.round(message.gt);
    }
    if (message.gte !== undefined) {
      obj.gte = Math.round(message.gte);
    }
    if (message.in?.length) {
      obj.in = message.in.map((e) => Math.round(e));
    }
    if (message.not_in?.length) {
      obj.not_in = message.not_in.map((e) => Math.round(e));
    }
    if (message.ignore_empty !== undefined) {
      obj.ignore_empty = message.ignore_empty;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Int64Rules>, I>>(base?: I): Int64Rules {
    return Int64Rules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Int64Rules>, I>>(object: I): Int64Rules {
    const message = createBaseInt64Rules();
    message.const = object.const ?? undefined;
    message.lt = object.lt ?? undefined;
    message.lte = object.lte ?? undefined;
    message.gt = object.gt ?? undefined;
    message.gte = object.gte ?? undefined;
    message.in = object.in?.map((e) => e) || undefined;
    message.not_in = object.not_in?.map((e) => e) || undefined;
    message.ignore_empty = object.ignore_empty ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Int64Rules.$type, Int64Rules);

function createBaseUInt32Rules(): UInt32Rules {
  return { $type: "validate.UInt32Rules" };
}

export const UInt32Rules: MessageFns<UInt32Rules, "validate.UInt32Rules"> = {
  $type: "validate.UInt32Rules" as const,

  encode(message: UInt32Rules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.const !== undefined && message.const !== 0) {
      writer.uint32(8).uint32(message.const);
    }
    if (message.lt !== undefined && message.lt !== 0) {
      writer.uint32(16).uint32(message.lt);
    }
    if (message.lte !== undefined && message.lte !== 0) {
      writer.uint32(24).uint32(message.lte);
    }
    if (message.gt !== undefined && message.gt !== 0) {
      writer.uint32(32).uint32(message.gt);
    }
    if (message.gte !== undefined && message.gte !== 0) {
      writer.uint32(40).uint32(message.gte);
    }
    if (message.in !== undefined && message.in.length !== 0) {
      writer.uint32(50).fork();
      for (const v of message.in) {
        writer.uint32(v);
      }
      writer.join();
    }
    if (message.not_in !== undefined && message.not_in.length !== 0) {
      writer.uint32(58).fork();
      for (const v of message.not_in) {
        writer.uint32(v);
      }
      writer.join();
    }
    if (message.ignore_empty !== undefined && message.ignore_empty !== false) {
      writer.uint32(64).bool(message.ignore_empty);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UInt32Rules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUInt32Rules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.const = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.lt = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.lte = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.gt = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.gte = reader.uint32();
          continue;
        }
        case 6: {
          if (tag === 48) {
            if (message.in === undefined) {
              message.in = [];
            }
            message.in!.push(reader.uint32());

            continue;
          }

          if (tag === 50) {
            if (message.in === undefined) {
              message.in = [];
            }
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.in!.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag === 56) {
            if (message.not_in === undefined) {
              message.not_in = [];
            }
            message.not_in!.push(reader.uint32());

            continue;
          }

          if (tag === 58) {
            if (message.not_in === undefined) {
              message.not_in = [];
            }
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.not_in!.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.ignore_empty = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UInt32Rules {
    return {
      $type: UInt32Rules.$type,
      const: isSet(object.const) ? globalThis.Number(object.const) : undefined,
      lt: isSet(object.lt) ? globalThis.Number(object.lt) : undefined,
      lte: isSet(object.lte) ? globalThis.Number(object.lte) : undefined,
      gt: isSet(object.gt) ? globalThis.Number(object.gt) : undefined,
      gte: isSet(object.gte) ? globalThis.Number(object.gte) : undefined,
      in: globalThis.Array.isArray(object?.in) ? object.in.map((e: any) => globalThis.Number(e)) : undefined,
      not_in: globalThis.Array.isArray(object?.not_in)
        ? object.not_in.map((e: any) => globalThis.Number(e))
        : undefined,
      ignore_empty: isSet(object.ignore_empty) ? globalThis.Boolean(object.ignore_empty) : undefined,
    };
  },

  toJSON(message: UInt32Rules): unknown {
    const obj: any = {};
    if (message.const !== undefined) {
      obj.const = Math.round(message.const);
    }
    if (message.lt !== undefined) {
      obj.lt = Math.round(message.lt);
    }
    if (message.lte !== undefined) {
      obj.lte = Math.round(message.lte);
    }
    if (message.gt !== undefined) {
      obj.gt = Math.round(message.gt);
    }
    if (message.gte !== undefined) {
      obj.gte = Math.round(message.gte);
    }
    if (message.in?.length) {
      obj.in = message.in.map((e) => Math.round(e));
    }
    if (message.not_in?.length) {
      obj.not_in = message.not_in.map((e) => Math.round(e));
    }
    if (message.ignore_empty !== undefined) {
      obj.ignore_empty = message.ignore_empty;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UInt32Rules>, I>>(base?: I): UInt32Rules {
    return UInt32Rules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UInt32Rules>, I>>(object: I): UInt32Rules {
    const message = createBaseUInt32Rules();
    message.const = object.const ?? undefined;
    message.lt = object.lt ?? undefined;
    message.lte = object.lte ?? undefined;
    message.gt = object.gt ?? undefined;
    message.gte = object.gte ?? undefined;
    message.in = object.in?.map((e) => e) || undefined;
    message.not_in = object.not_in?.map((e) => e) || undefined;
    message.ignore_empty = object.ignore_empty ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(UInt32Rules.$type, UInt32Rules);

function createBaseUInt64Rules(): UInt64Rules {
  return { $type: "validate.UInt64Rules" };
}

export const UInt64Rules: MessageFns<UInt64Rules, "validate.UInt64Rules"> = {
  $type: "validate.UInt64Rules" as const,

  encode(message: UInt64Rules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.const !== undefined && message.const !== 0) {
      writer.uint32(8).uint64(message.const);
    }
    if (message.lt !== undefined && message.lt !== 0) {
      writer.uint32(16).uint64(message.lt);
    }
    if (message.lte !== undefined && message.lte !== 0) {
      writer.uint32(24).uint64(message.lte);
    }
    if (message.gt !== undefined && message.gt !== 0) {
      writer.uint32(32).uint64(message.gt);
    }
    if (message.gte !== undefined && message.gte !== 0) {
      writer.uint32(40).uint64(message.gte);
    }
    if (message.in !== undefined && message.in.length !== 0) {
      writer.uint32(50).fork();
      for (const v of message.in) {
        writer.uint64(v);
      }
      writer.join();
    }
    if (message.not_in !== undefined && message.not_in.length !== 0) {
      writer.uint32(58).fork();
      for (const v of message.not_in) {
        writer.uint64(v);
      }
      writer.join();
    }
    if (message.ignore_empty !== undefined && message.ignore_empty !== false) {
      writer.uint32(64).bool(message.ignore_empty);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UInt64Rules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUInt64Rules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.const = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.lt = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.lte = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.gt = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.gte = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag === 48) {
            if (message.in === undefined) {
              message.in = [];
            }
            message.in!.push(longToNumber(reader.uint64()));

            continue;
          }

          if (tag === 50) {
            if (message.in === undefined) {
              message.in = [];
            }
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.in!.push(longToNumber(reader.uint64()));
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag === 56) {
            if (message.not_in === undefined) {
              message.not_in = [];
            }
            message.not_in!.push(longToNumber(reader.uint64()));

            continue;
          }

          if (tag === 58) {
            if (message.not_in === undefined) {
              message.not_in = [];
            }
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.not_in!.push(longToNumber(reader.uint64()));
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.ignore_empty = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UInt64Rules {
    return {
      $type: UInt64Rules.$type,
      const: isSet(object.const) ? globalThis.Number(object.const) : undefined,
      lt: isSet(object.lt) ? globalThis.Number(object.lt) : undefined,
      lte: isSet(object.lte) ? globalThis.Number(object.lte) : undefined,
      gt: isSet(object.gt) ? globalThis.Number(object.gt) : undefined,
      gte: isSet(object.gte) ? globalThis.Number(object.gte) : undefined,
      in: globalThis.Array.isArray(object?.in) ? object.in.map((e: any) => globalThis.Number(e)) : undefined,
      not_in: globalThis.Array.isArray(object?.not_in)
        ? object.not_in.map((e: any) => globalThis.Number(e))
        : undefined,
      ignore_empty: isSet(object.ignore_empty) ? globalThis.Boolean(object.ignore_empty) : undefined,
    };
  },

  toJSON(message: UInt64Rules): unknown {
    const obj: any = {};
    if (message.const !== undefined) {
      obj.const = Math.round(message.const);
    }
    if (message.lt !== undefined) {
      obj.lt = Math.round(message.lt);
    }
    if (message.lte !== undefined) {
      obj.lte = Math.round(message.lte);
    }
    if (message.gt !== undefined) {
      obj.gt = Math.round(message.gt);
    }
    if (message.gte !== undefined) {
      obj.gte = Math.round(message.gte);
    }
    if (message.in?.length) {
      obj.in = message.in.map((e) => Math.round(e));
    }
    if (message.not_in?.length) {
      obj.not_in = message.not_in.map((e) => Math.round(e));
    }
    if (message.ignore_empty !== undefined) {
      obj.ignore_empty = message.ignore_empty;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UInt64Rules>, I>>(base?: I): UInt64Rules {
    return UInt64Rules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UInt64Rules>, I>>(object: I): UInt64Rules {
    const message = createBaseUInt64Rules();
    message.const = object.const ?? undefined;
    message.lt = object.lt ?? undefined;
    message.lte = object.lte ?? undefined;
    message.gt = object.gt ?? undefined;
    message.gte = object.gte ?? undefined;
    message.in = object.in?.map((e) => e) || undefined;
    message.not_in = object.not_in?.map((e) => e) || undefined;
    message.ignore_empty = object.ignore_empty ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(UInt64Rules.$type, UInt64Rules);

function createBaseSInt32Rules(): SInt32Rules {
  return { $type: "validate.SInt32Rules" };
}

export const SInt32Rules: MessageFns<SInt32Rules, "validate.SInt32Rules"> = {
  $type: "validate.SInt32Rules" as const,

  encode(message: SInt32Rules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.const !== undefined && message.const !== 0) {
      writer.uint32(8).sint32(message.const);
    }
    if (message.lt !== undefined && message.lt !== 0) {
      writer.uint32(16).sint32(message.lt);
    }
    if (message.lte !== undefined && message.lte !== 0) {
      writer.uint32(24).sint32(message.lte);
    }
    if (message.gt !== undefined && message.gt !== 0) {
      writer.uint32(32).sint32(message.gt);
    }
    if (message.gte !== undefined && message.gte !== 0) {
      writer.uint32(40).sint32(message.gte);
    }
    if (message.in !== undefined && message.in.length !== 0) {
      writer.uint32(50).fork();
      for (const v of message.in) {
        writer.sint32(v);
      }
      writer.join();
    }
    if (message.not_in !== undefined && message.not_in.length !== 0) {
      writer.uint32(58).fork();
      for (const v of message.not_in) {
        writer.sint32(v);
      }
      writer.join();
    }
    if (message.ignore_empty !== undefined && message.ignore_empty !== false) {
      writer.uint32(64).bool(message.ignore_empty);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SInt32Rules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSInt32Rules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.const = reader.sint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.lt = reader.sint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.lte = reader.sint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.gt = reader.sint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.gte = reader.sint32();
          continue;
        }
        case 6: {
          if (tag === 48) {
            if (message.in === undefined) {
              message.in = [];
            }
            message.in!.push(reader.sint32());

            continue;
          }

          if (tag === 50) {
            if (message.in === undefined) {
              message.in = [];
            }
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.in!.push(reader.sint32());
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag === 56) {
            if (message.not_in === undefined) {
              message.not_in = [];
            }
            message.not_in!.push(reader.sint32());

            continue;
          }

          if (tag === 58) {
            if (message.not_in === undefined) {
              message.not_in = [];
            }
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.not_in!.push(reader.sint32());
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.ignore_empty = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SInt32Rules {
    return {
      $type: SInt32Rules.$type,
      const: isSet(object.const) ? globalThis.Number(object.const) : undefined,
      lt: isSet(object.lt) ? globalThis.Number(object.lt) : undefined,
      lte: isSet(object.lte) ? globalThis.Number(object.lte) : undefined,
      gt: isSet(object.gt) ? globalThis.Number(object.gt) : undefined,
      gte: isSet(object.gte) ? globalThis.Number(object.gte) : undefined,
      in: globalThis.Array.isArray(object?.in) ? object.in.map((e: any) => globalThis.Number(e)) : undefined,
      not_in: globalThis.Array.isArray(object?.not_in)
        ? object.not_in.map((e: any) => globalThis.Number(e))
        : undefined,
      ignore_empty: isSet(object.ignore_empty) ? globalThis.Boolean(object.ignore_empty) : undefined,
    };
  },

  toJSON(message: SInt32Rules): unknown {
    const obj: any = {};
    if (message.const !== undefined) {
      obj.const = Math.round(message.const);
    }
    if (message.lt !== undefined) {
      obj.lt = Math.round(message.lt);
    }
    if (message.lte !== undefined) {
      obj.lte = Math.round(message.lte);
    }
    if (message.gt !== undefined) {
      obj.gt = Math.round(message.gt);
    }
    if (message.gte !== undefined) {
      obj.gte = Math.round(message.gte);
    }
    if (message.in?.length) {
      obj.in = message.in.map((e) => Math.round(e));
    }
    if (message.not_in?.length) {
      obj.not_in = message.not_in.map((e) => Math.round(e));
    }
    if (message.ignore_empty !== undefined) {
      obj.ignore_empty = message.ignore_empty;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SInt32Rules>, I>>(base?: I): SInt32Rules {
    return SInt32Rules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SInt32Rules>, I>>(object: I): SInt32Rules {
    const message = createBaseSInt32Rules();
    message.const = object.const ?? undefined;
    message.lt = object.lt ?? undefined;
    message.lte = object.lte ?? undefined;
    message.gt = object.gt ?? undefined;
    message.gte = object.gte ?? undefined;
    message.in = object.in?.map((e) => e) || undefined;
    message.not_in = object.not_in?.map((e) => e) || undefined;
    message.ignore_empty = object.ignore_empty ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(SInt32Rules.$type, SInt32Rules);

function createBaseSInt64Rules(): SInt64Rules {
  return { $type: "validate.SInt64Rules" };
}

export const SInt64Rules: MessageFns<SInt64Rules, "validate.SInt64Rules"> = {
  $type: "validate.SInt64Rules" as const,

  encode(message: SInt64Rules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.const !== undefined && message.const !== 0) {
      writer.uint32(8).sint64(message.const);
    }
    if (message.lt !== undefined && message.lt !== 0) {
      writer.uint32(16).sint64(message.lt);
    }
    if (message.lte !== undefined && message.lte !== 0) {
      writer.uint32(24).sint64(message.lte);
    }
    if (message.gt !== undefined && message.gt !== 0) {
      writer.uint32(32).sint64(message.gt);
    }
    if (message.gte !== undefined && message.gte !== 0) {
      writer.uint32(40).sint64(message.gte);
    }
    if (message.in !== undefined && message.in.length !== 0) {
      writer.uint32(50).fork();
      for (const v of message.in) {
        writer.sint64(v);
      }
      writer.join();
    }
    if (message.not_in !== undefined && message.not_in.length !== 0) {
      writer.uint32(58).fork();
      for (const v of message.not_in) {
        writer.sint64(v);
      }
      writer.join();
    }
    if (message.ignore_empty !== undefined && message.ignore_empty !== false) {
      writer.uint32(64).bool(message.ignore_empty);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SInt64Rules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSInt64Rules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.const = longToNumber(reader.sint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.lt = longToNumber(reader.sint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.lte = longToNumber(reader.sint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.gt = longToNumber(reader.sint64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.gte = longToNumber(reader.sint64());
          continue;
        }
        case 6: {
          if (tag === 48) {
            if (message.in === undefined) {
              message.in = [];
            }
            message.in!.push(longToNumber(reader.sint64()));

            continue;
          }

          if (tag === 50) {
            if (message.in === undefined) {
              message.in = [];
            }
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.in!.push(longToNumber(reader.sint64()));
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag === 56) {
            if (message.not_in === undefined) {
              message.not_in = [];
            }
            message.not_in!.push(longToNumber(reader.sint64()));

            continue;
          }

          if (tag === 58) {
            if (message.not_in === undefined) {
              message.not_in = [];
            }
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.not_in!.push(longToNumber(reader.sint64()));
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.ignore_empty = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SInt64Rules {
    return {
      $type: SInt64Rules.$type,
      const: isSet(object.const) ? globalThis.Number(object.const) : undefined,
      lt: isSet(object.lt) ? globalThis.Number(object.lt) : undefined,
      lte: isSet(object.lte) ? globalThis.Number(object.lte) : undefined,
      gt: isSet(object.gt) ? globalThis.Number(object.gt) : undefined,
      gte: isSet(object.gte) ? globalThis.Number(object.gte) : undefined,
      in: globalThis.Array.isArray(object?.in) ? object.in.map((e: any) => globalThis.Number(e)) : undefined,
      not_in: globalThis.Array.isArray(object?.not_in)
        ? object.not_in.map((e: any) => globalThis.Number(e))
        : undefined,
      ignore_empty: isSet(object.ignore_empty) ? globalThis.Boolean(object.ignore_empty) : undefined,
    };
  },

  toJSON(message: SInt64Rules): unknown {
    const obj: any = {};
    if (message.const !== undefined) {
      obj.const = Math.round(message.const);
    }
    if (message.lt !== undefined) {
      obj.lt = Math.round(message.lt);
    }
    if (message.lte !== undefined) {
      obj.lte = Math.round(message.lte);
    }
    if (message.gt !== undefined) {
      obj.gt = Math.round(message.gt);
    }
    if (message.gte !== undefined) {
      obj.gte = Math.round(message.gte);
    }
    if (message.in?.length) {
      obj.in = message.in.map((e) => Math.round(e));
    }
    if (message.not_in?.length) {
      obj.not_in = message.not_in.map((e) => Math.round(e));
    }
    if (message.ignore_empty !== undefined) {
      obj.ignore_empty = message.ignore_empty;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SInt64Rules>, I>>(base?: I): SInt64Rules {
    return SInt64Rules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SInt64Rules>, I>>(object: I): SInt64Rules {
    const message = createBaseSInt64Rules();
    message.const = object.const ?? undefined;
    message.lt = object.lt ?? undefined;
    message.lte = object.lte ?? undefined;
    message.gt = object.gt ?? undefined;
    message.gte = object.gte ?? undefined;
    message.in = object.in?.map((e) => e) || undefined;
    message.not_in = object.not_in?.map((e) => e) || undefined;
    message.ignore_empty = object.ignore_empty ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(SInt64Rules.$type, SInt64Rules);

function createBaseFixed32Rules(): Fixed32Rules {
  return { $type: "validate.Fixed32Rules" };
}

export const Fixed32Rules: MessageFns<Fixed32Rules, "validate.Fixed32Rules"> = {
  $type: "validate.Fixed32Rules" as const,

  encode(message: Fixed32Rules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.const !== undefined && message.const !== 0) {
      writer.uint32(13).fixed32(message.const);
    }
    if (message.lt !== undefined && message.lt !== 0) {
      writer.uint32(21).fixed32(message.lt);
    }
    if (message.lte !== undefined && message.lte !== 0) {
      writer.uint32(29).fixed32(message.lte);
    }
    if (message.gt !== undefined && message.gt !== 0) {
      writer.uint32(37).fixed32(message.gt);
    }
    if (message.gte !== undefined && message.gte !== 0) {
      writer.uint32(45).fixed32(message.gte);
    }
    if (message.in !== undefined && message.in.length !== 0) {
      writer.uint32(50).fork();
      for (const v of message.in) {
        writer.fixed32(v);
      }
      writer.join();
    }
    if (message.not_in !== undefined && message.not_in.length !== 0) {
      writer.uint32(58).fork();
      for (const v of message.not_in) {
        writer.fixed32(v);
      }
      writer.join();
    }
    if (message.ignore_empty !== undefined && message.ignore_empty !== false) {
      writer.uint32(64).bool(message.ignore_empty);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fixed32Rules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFixed32Rules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.const = reader.fixed32();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.lt = reader.fixed32();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.lte = reader.fixed32();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.gt = reader.fixed32();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.gte = reader.fixed32();
          continue;
        }
        case 6: {
          if (tag === 53) {
            if (message.in === undefined) {
              message.in = [];
            }
            message.in!.push(reader.fixed32());

            continue;
          }

          if (tag === 50) {
            if (message.in === undefined) {
              message.in = [];
            }
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.in!.push(reader.fixed32());
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag === 61) {
            if (message.not_in === undefined) {
              message.not_in = [];
            }
            message.not_in!.push(reader.fixed32());

            continue;
          }

          if (tag === 58) {
            if (message.not_in === undefined) {
              message.not_in = [];
            }
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.not_in!.push(reader.fixed32());
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.ignore_empty = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fixed32Rules {
    return {
      $type: Fixed32Rules.$type,
      const: isSet(object.const) ? globalThis.Number(object.const) : undefined,
      lt: isSet(object.lt) ? globalThis.Number(object.lt) : undefined,
      lte: isSet(object.lte) ? globalThis.Number(object.lte) : undefined,
      gt: isSet(object.gt) ? globalThis.Number(object.gt) : undefined,
      gte: isSet(object.gte) ? globalThis.Number(object.gte) : undefined,
      in: globalThis.Array.isArray(object?.in) ? object.in.map((e: any) => globalThis.Number(e)) : undefined,
      not_in: globalThis.Array.isArray(object?.not_in)
        ? object.not_in.map((e: any) => globalThis.Number(e))
        : undefined,
      ignore_empty: isSet(object.ignore_empty) ? globalThis.Boolean(object.ignore_empty) : undefined,
    };
  },

  toJSON(message: Fixed32Rules): unknown {
    const obj: any = {};
    if (message.const !== undefined) {
      obj.const = Math.round(message.const);
    }
    if (message.lt !== undefined) {
      obj.lt = Math.round(message.lt);
    }
    if (message.lte !== undefined) {
      obj.lte = Math.round(message.lte);
    }
    if (message.gt !== undefined) {
      obj.gt = Math.round(message.gt);
    }
    if (message.gte !== undefined) {
      obj.gte = Math.round(message.gte);
    }
    if (message.in?.length) {
      obj.in = message.in.map((e) => Math.round(e));
    }
    if (message.not_in?.length) {
      obj.not_in = message.not_in.map((e) => Math.round(e));
    }
    if (message.ignore_empty !== undefined) {
      obj.ignore_empty = message.ignore_empty;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Fixed32Rules>, I>>(base?: I): Fixed32Rules {
    return Fixed32Rules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Fixed32Rules>, I>>(object: I): Fixed32Rules {
    const message = createBaseFixed32Rules();
    message.const = object.const ?? undefined;
    message.lt = object.lt ?? undefined;
    message.lte = object.lte ?? undefined;
    message.gt = object.gt ?? undefined;
    message.gte = object.gte ?? undefined;
    message.in = object.in?.map((e) => e) || undefined;
    message.not_in = object.not_in?.map((e) => e) || undefined;
    message.ignore_empty = object.ignore_empty ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Fixed32Rules.$type, Fixed32Rules);

function createBaseFixed64Rules(): Fixed64Rules {
  return { $type: "validate.Fixed64Rules" };
}

export const Fixed64Rules: MessageFns<Fixed64Rules, "validate.Fixed64Rules"> = {
  $type: "validate.Fixed64Rules" as const,

  encode(message: Fixed64Rules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.const !== undefined && message.const !== 0) {
      writer.uint32(9).fixed64(message.const);
    }
    if (message.lt !== undefined && message.lt !== 0) {
      writer.uint32(17).fixed64(message.lt);
    }
    if (message.lte !== undefined && message.lte !== 0) {
      writer.uint32(25).fixed64(message.lte);
    }
    if (message.gt !== undefined && message.gt !== 0) {
      writer.uint32(33).fixed64(message.gt);
    }
    if (message.gte !== undefined && message.gte !== 0) {
      writer.uint32(41).fixed64(message.gte);
    }
    if (message.in !== undefined && message.in.length !== 0) {
      writer.uint32(50).fork();
      for (const v of message.in) {
        writer.fixed64(v);
      }
      writer.join();
    }
    if (message.not_in !== undefined && message.not_in.length !== 0) {
      writer.uint32(58).fork();
      for (const v of message.not_in) {
        writer.fixed64(v);
      }
      writer.join();
    }
    if (message.ignore_empty !== undefined && message.ignore_empty !== false) {
      writer.uint32(64).bool(message.ignore_empty);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fixed64Rules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFixed64Rules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.const = longToNumber(reader.fixed64());
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.lt = longToNumber(reader.fixed64());
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.lte = longToNumber(reader.fixed64());
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.gt = longToNumber(reader.fixed64());
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.gte = longToNumber(reader.fixed64());
          continue;
        }
        case 6: {
          if (tag === 49) {
            if (message.in === undefined) {
              message.in = [];
            }
            message.in!.push(longToNumber(reader.fixed64()));

            continue;
          }

          if (tag === 50) {
            if (message.in === undefined) {
              message.in = [];
            }
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.in!.push(longToNumber(reader.fixed64()));
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag === 57) {
            if (message.not_in === undefined) {
              message.not_in = [];
            }
            message.not_in!.push(longToNumber(reader.fixed64()));

            continue;
          }

          if (tag === 58) {
            if (message.not_in === undefined) {
              message.not_in = [];
            }
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.not_in!.push(longToNumber(reader.fixed64()));
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.ignore_empty = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fixed64Rules {
    return {
      $type: Fixed64Rules.$type,
      const: isSet(object.const) ? globalThis.Number(object.const) : undefined,
      lt: isSet(object.lt) ? globalThis.Number(object.lt) : undefined,
      lte: isSet(object.lte) ? globalThis.Number(object.lte) : undefined,
      gt: isSet(object.gt) ? globalThis.Number(object.gt) : undefined,
      gte: isSet(object.gte) ? globalThis.Number(object.gte) : undefined,
      in: globalThis.Array.isArray(object?.in) ? object.in.map((e: any) => globalThis.Number(e)) : undefined,
      not_in: globalThis.Array.isArray(object?.not_in)
        ? object.not_in.map((e: any) => globalThis.Number(e))
        : undefined,
      ignore_empty: isSet(object.ignore_empty) ? globalThis.Boolean(object.ignore_empty) : undefined,
    };
  },

  toJSON(message: Fixed64Rules): unknown {
    const obj: any = {};
    if (message.const !== undefined) {
      obj.const = Math.round(message.const);
    }
    if (message.lt !== undefined) {
      obj.lt = Math.round(message.lt);
    }
    if (message.lte !== undefined) {
      obj.lte = Math.round(message.lte);
    }
    if (message.gt !== undefined) {
      obj.gt = Math.round(message.gt);
    }
    if (message.gte !== undefined) {
      obj.gte = Math.round(message.gte);
    }
    if (message.in?.length) {
      obj.in = message.in.map((e) => Math.round(e));
    }
    if (message.not_in?.length) {
      obj.not_in = message.not_in.map((e) => Math.round(e));
    }
    if (message.ignore_empty !== undefined) {
      obj.ignore_empty = message.ignore_empty;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Fixed64Rules>, I>>(base?: I): Fixed64Rules {
    return Fixed64Rules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Fixed64Rules>, I>>(object: I): Fixed64Rules {
    const message = createBaseFixed64Rules();
    message.const = object.const ?? undefined;
    message.lt = object.lt ?? undefined;
    message.lte = object.lte ?? undefined;
    message.gt = object.gt ?? undefined;
    message.gte = object.gte ?? undefined;
    message.in = object.in?.map((e) => e) || undefined;
    message.not_in = object.not_in?.map((e) => e) || undefined;
    message.ignore_empty = object.ignore_empty ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Fixed64Rules.$type, Fixed64Rules);

function createBaseSFixed32Rules(): SFixed32Rules {
  return { $type: "validate.SFixed32Rules" };
}

export const SFixed32Rules: MessageFns<SFixed32Rules, "validate.SFixed32Rules"> = {
  $type: "validate.SFixed32Rules" as const,

  encode(message: SFixed32Rules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.const !== undefined && message.const !== 0) {
      writer.uint32(13).sfixed32(message.const);
    }
    if (message.lt !== undefined && message.lt !== 0) {
      writer.uint32(21).sfixed32(message.lt);
    }
    if (message.lte !== undefined && message.lte !== 0) {
      writer.uint32(29).sfixed32(message.lte);
    }
    if (message.gt !== undefined && message.gt !== 0) {
      writer.uint32(37).sfixed32(message.gt);
    }
    if (message.gte !== undefined && message.gte !== 0) {
      writer.uint32(45).sfixed32(message.gte);
    }
    if (message.in !== undefined && message.in.length !== 0) {
      writer.uint32(50).fork();
      for (const v of message.in) {
        writer.sfixed32(v);
      }
      writer.join();
    }
    if (message.not_in !== undefined && message.not_in.length !== 0) {
      writer.uint32(58).fork();
      for (const v of message.not_in) {
        writer.sfixed32(v);
      }
      writer.join();
    }
    if (message.ignore_empty !== undefined && message.ignore_empty !== false) {
      writer.uint32(64).bool(message.ignore_empty);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SFixed32Rules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSFixed32Rules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.const = reader.sfixed32();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.lt = reader.sfixed32();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.lte = reader.sfixed32();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.gt = reader.sfixed32();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.gte = reader.sfixed32();
          continue;
        }
        case 6: {
          if (tag === 53) {
            if (message.in === undefined) {
              message.in = [];
            }
            message.in!.push(reader.sfixed32());

            continue;
          }

          if (tag === 50) {
            if (message.in === undefined) {
              message.in = [];
            }
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.in!.push(reader.sfixed32());
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag === 61) {
            if (message.not_in === undefined) {
              message.not_in = [];
            }
            message.not_in!.push(reader.sfixed32());

            continue;
          }

          if (tag === 58) {
            if (message.not_in === undefined) {
              message.not_in = [];
            }
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.not_in!.push(reader.sfixed32());
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.ignore_empty = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SFixed32Rules {
    return {
      $type: SFixed32Rules.$type,
      const: isSet(object.const) ? globalThis.Number(object.const) : undefined,
      lt: isSet(object.lt) ? globalThis.Number(object.lt) : undefined,
      lte: isSet(object.lte) ? globalThis.Number(object.lte) : undefined,
      gt: isSet(object.gt) ? globalThis.Number(object.gt) : undefined,
      gte: isSet(object.gte) ? globalThis.Number(object.gte) : undefined,
      in: globalThis.Array.isArray(object?.in) ? object.in.map((e: any) => globalThis.Number(e)) : undefined,
      not_in: globalThis.Array.isArray(object?.not_in)
        ? object.not_in.map((e: any) => globalThis.Number(e))
        : undefined,
      ignore_empty: isSet(object.ignore_empty) ? globalThis.Boolean(object.ignore_empty) : undefined,
    };
  },

  toJSON(message: SFixed32Rules): unknown {
    const obj: any = {};
    if (message.const !== undefined) {
      obj.const = Math.round(message.const);
    }
    if (message.lt !== undefined) {
      obj.lt = Math.round(message.lt);
    }
    if (message.lte !== undefined) {
      obj.lte = Math.round(message.lte);
    }
    if (message.gt !== undefined) {
      obj.gt = Math.round(message.gt);
    }
    if (message.gte !== undefined) {
      obj.gte = Math.round(message.gte);
    }
    if (message.in?.length) {
      obj.in = message.in.map((e) => Math.round(e));
    }
    if (message.not_in?.length) {
      obj.not_in = message.not_in.map((e) => Math.round(e));
    }
    if (message.ignore_empty !== undefined) {
      obj.ignore_empty = message.ignore_empty;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SFixed32Rules>, I>>(base?: I): SFixed32Rules {
    return SFixed32Rules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SFixed32Rules>, I>>(object: I): SFixed32Rules {
    const message = createBaseSFixed32Rules();
    message.const = object.const ?? undefined;
    message.lt = object.lt ?? undefined;
    message.lte = object.lte ?? undefined;
    message.gt = object.gt ?? undefined;
    message.gte = object.gte ?? undefined;
    message.in = object.in?.map((e) => e) || undefined;
    message.not_in = object.not_in?.map((e) => e) || undefined;
    message.ignore_empty = object.ignore_empty ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(SFixed32Rules.$type, SFixed32Rules);

function createBaseSFixed64Rules(): SFixed64Rules {
  return { $type: "validate.SFixed64Rules" };
}

export const SFixed64Rules: MessageFns<SFixed64Rules, "validate.SFixed64Rules"> = {
  $type: "validate.SFixed64Rules" as const,

  encode(message: SFixed64Rules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.const !== undefined && message.const !== 0) {
      writer.uint32(9).sfixed64(message.const);
    }
    if (message.lt !== undefined && message.lt !== 0) {
      writer.uint32(17).sfixed64(message.lt);
    }
    if (message.lte !== undefined && message.lte !== 0) {
      writer.uint32(25).sfixed64(message.lte);
    }
    if (message.gt !== undefined && message.gt !== 0) {
      writer.uint32(33).sfixed64(message.gt);
    }
    if (message.gte !== undefined && message.gte !== 0) {
      writer.uint32(41).sfixed64(message.gte);
    }
    if (message.in !== undefined && message.in.length !== 0) {
      writer.uint32(50).fork();
      for (const v of message.in) {
        writer.sfixed64(v);
      }
      writer.join();
    }
    if (message.not_in !== undefined && message.not_in.length !== 0) {
      writer.uint32(58).fork();
      for (const v of message.not_in) {
        writer.sfixed64(v);
      }
      writer.join();
    }
    if (message.ignore_empty !== undefined && message.ignore_empty !== false) {
      writer.uint32(64).bool(message.ignore_empty);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SFixed64Rules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSFixed64Rules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.const = longToNumber(reader.sfixed64());
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.lt = longToNumber(reader.sfixed64());
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.lte = longToNumber(reader.sfixed64());
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.gt = longToNumber(reader.sfixed64());
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.gte = longToNumber(reader.sfixed64());
          continue;
        }
        case 6: {
          if (tag === 49) {
            if (message.in === undefined) {
              message.in = [];
            }
            message.in!.push(longToNumber(reader.sfixed64()));

            continue;
          }

          if (tag === 50) {
            if (message.in === undefined) {
              message.in = [];
            }
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.in!.push(longToNumber(reader.sfixed64()));
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag === 57) {
            if (message.not_in === undefined) {
              message.not_in = [];
            }
            message.not_in!.push(longToNumber(reader.sfixed64()));

            continue;
          }

          if (tag === 58) {
            if (message.not_in === undefined) {
              message.not_in = [];
            }
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.not_in!.push(longToNumber(reader.sfixed64()));
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.ignore_empty = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SFixed64Rules {
    return {
      $type: SFixed64Rules.$type,
      const: isSet(object.const) ? globalThis.Number(object.const) : undefined,
      lt: isSet(object.lt) ? globalThis.Number(object.lt) : undefined,
      lte: isSet(object.lte) ? globalThis.Number(object.lte) : undefined,
      gt: isSet(object.gt) ? globalThis.Number(object.gt) : undefined,
      gte: isSet(object.gte) ? globalThis.Number(object.gte) : undefined,
      in: globalThis.Array.isArray(object?.in) ? object.in.map((e: any) => globalThis.Number(e)) : undefined,
      not_in: globalThis.Array.isArray(object?.not_in)
        ? object.not_in.map((e: any) => globalThis.Number(e))
        : undefined,
      ignore_empty: isSet(object.ignore_empty) ? globalThis.Boolean(object.ignore_empty) : undefined,
    };
  },

  toJSON(message: SFixed64Rules): unknown {
    const obj: any = {};
    if (message.const !== undefined) {
      obj.const = Math.round(message.const);
    }
    if (message.lt !== undefined) {
      obj.lt = Math.round(message.lt);
    }
    if (message.lte !== undefined) {
      obj.lte = Math.round(message.lte);
    }
    if (message.gt !== undefined) {
      obj.gt = Math.round(message.gt);
    }
    if (message.gte !== undefined) {
      obj.gte = Math.round(message.gte);
    }
    if (message.in?.length) {
      obj.in = message.in.map((e) => Math.round(e));
    }
    if (message.not_in?.length) {
      obj.not_in = message.not_in.map((e) => Math.round(e));
    }
    if (message.ignore_empty !== undefined) {
      obj.ignore_empty = message.ignore_empty;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SFixed64Rules>, I>>(base?: I): SFixed64Rules {
    return SFixed64Rules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SFixed64Rules>, I>>(object: I): SFixed64Rules {
    const message = createBaseSFixed64Rules();
    message.const = object.const ?? undefined;
    message.lt = object.lt ?? undefined;
    message.lte = object.lte ?? undefined;
    message.gt = object.gt ?? undefined;
    message.gte = object.gte ?? undefined;
    message.in = object.in?.map((e) => e) || undefined;
    message.not_in = object.not_in?.map((e) => e) || undefined;
    message.ignore_empty = object.ignore_empty ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(SFixed64Rules.$type, SFixed64Rules);

function createBaseBoolRules(): BoolRules {
  return { $type: "validate.BoolRules" };
}

export const BoolRules: MessageFns<BoolRules, "validate.BoolRules"> = {
  $type: "validate.BoolRules" as const,

  encode(message: BoolRules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.const !== undefined && message.const !== false) {
      writer.uint32(8).bool(message.const);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BoolRules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBoolRules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.const = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BoolRules {
    return { $type: BoolRules.$type, const: isSet(object.const) ? globalThis.Boolean(object.const) : undefined };
  },

  toJSON(message: BoolRules): unknown {
    const obj: any = {};
    if (message.const !== undefined) {
      obj.const = message.const;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BoolRules>, I>>(base?: I): BoolRules {
    return BoolRules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BoolRules>, I>>(object: I): BoolRules {
    const message = createBaseBoolRules();
    message.const = object.const ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(BoolRules.$type, BoolRules);

function createBaseStringRules(): StringRules {
  return { $type: "validate.StringRules", well_known: undefined };
}

export const StringRules: MessageFns<StringRules, "validate.StringRules"> = {
  $type: "validate.StringRules" as const,

  encode(message: StringRules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.const !== undefined && message.const !== "") {
      writer.uint32(10).string(message.const);
    }
    if (message.len !== undefined && message.len !== 0) {
      writer.uint32(152).uint64(message.len);
    }
    if (message.min_len !== undefined && message.min_len !== 0) {
      writer.uint32(16).uint64(message.min_len);
    }
    if (message.max_len !== undefined && message.max_len !== 0) {
      writer.uint32(24).uint64(message.max_len);
    }
    if (message.len_bytes !== undefined && message.len_bytes !== 0) {
      writer.uint32(160).uint64(message.len_bytes);
    }
    if (message.min_bytes !== undefined && message.min_bytes !== 0) {
      writer.uint32(32).uint64(message.min_bytes);
    }
    if (message.max_bytes !== undefined && message.max_bytes !== 0) {
      writer.uint32(40).uint64(message.max_bytes);
    }
    if (message.pattern !== undefined && message.pattern !== "") {
      writer.uint32(50).string(message.pattern);
    }
    if (message.prefix !== undefined && message.prefix !== "") {
      writer.uint32(58).string(message.prefix);
    }
    if (message.suffix !== undefined && message.suffix !== "") {
      writer.uint32(66).string(message.suffix);
    }
    if (message.contains !== undefined && message.contains !== "") {
      writer.uint32(74).string(message.contains);
    }
    if (message.not_contains !== undefined && message.not_contains !== "") {
      writer.uint32(186).string(message.not_contains);
    }
    if (message.in !== undefined && message.in.length !== 0) {
      for (const v of message.in) {
        writer.uint32(82).string(v!);
      }
    }
    if (message.not_in !== undefined && message.not_in.length !== 0) {
      for (const v of message.not_in) {
        writer.uint32(90).string(v!);
      }
    }
    switch (message.well_known?.$case) {
      case "email":
        writer.uint32(96).bool(message.well_known.email);
        break;
      case "hostname":
        writer.uint32(104).bool(message.well_known.hostname);
        break;
      case "ip":
        writer.uint32(112).bool(message.well_known.ip);
        break;
      case "ipv4":
        writer.uint32(120).bool(message.well_known.ipv4);
        break;
      case "ipv6":
        writer.uint32(128).bool(message.well_known.ipv6);
        break;
      case "uri":
        writer.uint32(136).bool(message.well_known.uri);
        break;
      case "uri_ref":
        writer.uint32(144).bool(message.well_known.uri_ref);
        break;
      case "address":
        writer.uint32(168).bool(message.well_known.address);
        break;
      case "uuid":
        writer.uint32(176).bool(message.well_known.uuid);
        break;
      case "well_known_regex":
        writer.uint32(192).int32(knownRegexToNumber(message.well_known.well_known_regex));
        break;
    }
    if (message.strict !== undefined && message.strict !== true) {
      writer.uint32(200).bool(message.strict);
    }
    if (message.ignore_empty !== undefined && message.ignore_empty !== false) {
      writer.uint32(208).bool(message.ignore_empty);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringRules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringRules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.const = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.len = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.min_len = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.max_len = longToNumber(reader.uint64());
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.len_bytes = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.min_bytes = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.max_bytes = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.pattern = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.prefix = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.suffix = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.contains = reader.string();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.not_contains = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          if (message.in === undefined) {
            message.in = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.in!.push(el);
          }
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          if (message.not_in === undefined) {
            message.not_in = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.not_in!.push(el);
          }
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.well_known = { $case: "email", email: reader.bool() };
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.well_known = { $case: "hostname", hostname: reader.bool() };
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.well_known = { $case: "ip", ip: reader.bool() };
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.well_known = { $case: "ipv4", ipv4: reader.bool() };
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.well_known = { $case: "ipv6", ipv6: reader.bool() };
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.well_known = { $case: "uri", uri: reader.bool() };
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.well_known = { $case: "uri_ref", uri_ref: reader.bool() };
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.well_known = { $case: "address", address: reader.bool() };
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.well_known = { $case: "uuid", uuid: reader.bool() };
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.well_known = { $case: "well_known_regex", well_known_regex: knownRegexFromJSON(reader.int32()) };
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.strict = reader.bool();
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.ignore_empty = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringRules {
    return {
      $type: StringRules.$type,
      const: isSet(object.const) ? globalThis.String(object.const) : undefined,
      len: isSet(object.len) ? globalThis.Number(object.len) : undefined,
      min_len: isSet(object.min_len) ? globalThis.Number(object.min_len) : undefined,
      max_len: isSet(object.max_len) ? globalThis.Number(object.max_len) : undefined,
      len_bytes: isSet(object.len_bytes) ? globalThis.Number(object.len_bytes) : undefined,
      min_bytes: isSet(object.min_bytes) ? globalThis.Number(object.min_bytes) : undefined,
      max_bytes: isSet(object.max_bytes) ? globalThis.Number(object.max_bytes) : undefined,
      pattern: isSet(object.pattern) ? globalThis.String(object.pattern) : undefined,
      prefix: isSet(object.prefix) ? globalThis.String(object.prefix) : undefined,
      suffix: isSet(object.suffix) ? globalThis.String(object.suffix) : undefined,
      contains: isSet(object.contains) ? globalThis.String(object.contains) : undefined,
      not_contains: isSet(object.not_contains) ? globalThis.String(object.not_contains) : undefined,
      in: globalThis.Array.isArray(object?.in) ? object.in.map((e: any) => globalThis.String(e)) : undefined,
      not_in: globalThis.Array.isArray(object?.not_in)
        ? object.not_in.map((e: any) => globalThis.String(e))
        : undefined,
      well_known: isSet(object.email)
        ? { $case: "email", email: globalThis.Boolean(object.email) }
        : isSet(object.hostname)
        ? { $case: "hostname", hostname: globalThis.Boolean(object.hostname) }
        : isSet(object.ip)
        ? { $case: "ip", ip: globalThis.Boolean(object.ip) }
        : isSet(object.ipv4)
        ? { $case: "ipv4", ipv4: globalThis.Boolean(object.ipv4) }
        : isSet(object.ipv6)
        ? { $case: "ipv6", ipv6: globalThis.Boolean(object.ipv6) }
        : isSet(object.uri)
        ? { $case: "uri", uri: globalThis.Boolean(object.uri) }
        : isSet(object.uri_ref)
        ? { $case: "uri_ref", uri_ref: globalThis.Boolean(object.uri_ref) }
        : isSet(object.address)
        ? { $case: "address", address: globalThis.Boolean(object.address) }
        : isSet(object.uuid)
        ? { $case: "uuid", uuid: globalThis.Boolean(object.uuid) }
        : isSet(object.well_known_regex)
        ? { $case: "well_known_regex", well_known_regex: knownRegexFromJSON(object.well_known_regex) }
        : undefined,
      strict: isSet(object.strict) ? globalThis.Boolean(object.strict) : undefined,
      ignore_empty: isSet(object.ignore_empty) ? globalThis.Boolean(object.ignore_empty) : undefined,
    };
  },

  toJSON(message: StringRules): unknown {
    const obj: any = {};
    if (message.const !== undefined) {
      obj.const = message.const;
    }
    if (message.len !== undefined) {
      obj.len = Math.round(message.len);
    }
    if (message.min_len !== undefined) {
      obj.min_len = Math.round(message.min_len);
    }
    if (message.max_len !== undefined) {
      obj.max_len = Math.round(message.max_len);
    }
    if (message.len_bytes !== undefined) {
      obj.len_bytes = Math.round(message.len_bytes);
    }
    if (message.min_bytes !== undefined) {
      obj.min_bytes = Math.round(message.min_bytes);
    }
    if (message.max_bytes !== undefined) {
      obj.max_bytes = Math.round(message.max_bytes);
    }
    if (message.pattern !== undefined) {
      obj.pattern = message.pattern;
    }
    if (message.prefix !== undefined) {
      obj.prefix = message.prefix;
    }
    if (message.suffix !== undefined) {
      obj.suffix = message.suffix;
    }
    if (message.contains !== undefined) {
      obj.contains = message.contains;
    }
    if (message.not_contains !== undefined) {
      obj.not_contains = message.not_contains;
    }
    if (message.in?.length) {
      obj.in = message.in;
    }
    if (message.not_in?.length) {
      obj.not_in = message.not_in;
    }
    if (message.well_known?.$case === "email") {
      obj.email = message.well_known.email;
    }
    if (message.well_known?.$case === "hostname") {
      obj.hostname = message.well_known.hostname;
    }
    if (message.well_known?.$case === "ip") {
      obj.ip = message.well_known.ip;
    }
    if (message.well_known?.$case === "ipv4") {
      obj.ipv4 = message.well_known.ipv4;
    }
    if (message.well_known?.$case === "ipv6") {
      obj.ipv6 = message.well_known.ipv6;
    }
    if (message.well_known?.$case === "uri") {
      obj.uri = message.well_known.uri;
    }
    if (message.well_known?.$case === "uri_ref") {
      obj.uri_ref = message.well_known.uri_ref;
    }
    if (message.well_known?.$case === "address") {
      obj.address = message.well_known.address;
    }
    if (message.well_known?.$case === "uuid") {
      obj.uuid = message.well_known.uuid;
    }
    if (message.well_known?.$case === "well_known_regex") {
      obj.well_known_regex = knownRegexToJSON(message.well_known.well_known_regex);
    }
    if (message.strict !== undefined) {
      obj.strict = message.strict;
    }
    if (message.ignore_empty !== undefined) {
      obj.ignore_empty = message.ignore_empty;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StringRules>, I>>(base?: I): StringRules {
    return StringRules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StringRules>, I>>(object: I): StringRules {
    const message = createBaseStringRules();
    message.const = object.const ?? undefined;
    message.len = object.len ?? undefined;
    message.min_len = object.min_len ?? undefined;
    message.max_len = object.max_len ?? undefined;
    message.len_bytes = object.len_bytes ?? undefined;
    message.min_bytes = object.min_bytes ?? undefined;
    message.max_bytes = object.max_bytes ?? undefined;
    message.pattern = object.pattern ?? undefined;
    message.prefix = object.prefix ?? undefined;
    message.suffix = object.suffix ?? undefined;
    message.contains = object.contains ?? undefined;
    message.not_contains = object.not_contains ?? undefined;
    message.in = object.in?.map((e) => e) || undefined;
    message.not_in = object.not_in?.map((e) => e) || undefined;
    if (
      object.well_known?.$case === "email" &&
      object.well_known?.email !== undefined &&
      object.well_known?.email !== null
    ) {
      message.well_known = { $case: "email", email: object.well_known.email };
    }
    if (
      object.well_known?.$case === "hostname" &&
      object.well_known?.hostname !== undefined &&
      object.well_known?.hostname !== null
    ) {
      message.well_known = { $case: "hostname", hostname: object.well_known.hostname };
    }
    if (object.well_known?.$case === "ip" && object.well_known?.ip !== undefined && object.well_known?.ip !== null) {
      message.well_known = { $case: "ip", ip: object.well_known.ip };
    }
    if (
      object.well_known?.$case === "ipv4" && object.well_known?.ipv4 !== undefined && object.well_known?.ipv4 !== null
    ) {
      message.well_known = { $case: "ipv4", ipv4: object.well_known.ipv4 };
    }
    if (
      object.well_known?.$case === "ipv6" && object.well_known?.ipv6 !== undefined && object.well_known?.ipv6 !== null
    ) {
      message.well_known = { $case: "ipv6", ipv6: object.well_known.ipv6 };
    }
    if (object.well_known?.$case === "uri" && object.well_known?.uri !== undefined && object.well_known?.uri !== null) {
      message.well_known = { $case: "uri", uri: object.well_known.uri };
    }
    if (
      object.well_known?.$case === "uri_ref" &&
      object.well_known?.uri_ref !== undefined &&
      object.well_known?.uri_ref !== null
    ) {
      message.well_known = { $case: "uri_ref", uri_ref: object.well_known.uri_ref };
    }
    if (
      object.well_known?.$case === "address" &&
      object.well_known?.address !== undefined &&
      object.well_known?.address !== null
    ) {
      message.well_known = { $case: "address", address: object.well_known.address };
    }
    if (
      object.well_known?.$case === "uuid" && object.well_known?.uuid !== undefined && object.well_known?.uuid !== null
    ) {
      message.well_known = { $case: "uuid", uuid: object.well_known.uuid };
    }
    if (
      object.well_known?.$case === "well_known_regex" &&
      object.well_known?.well_known_regex !== undefined &&
      object.well_known?.well_known_regex !== null
    ) {
      message.well_known = { $case: "well_known_regex", well_known_regex: object.well_known.well_known_regex };
    }
    message.strict = object.strict ?? undefined;
    message.ignore_empty = object.ignore_empty ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(StringRules.$type, StringRules);

function createBaseBytesRules(): BytesRules {
  return { $type: "validate.BytesRules", well_known: undefined };
}

export const BytesRules: MessageFns<BytesRules, "validate.BytesRules"> = {
  $type: "validate.BytesRules" as const,

  encode(message: BytesRules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.const !== undefined && message.const.length !== 0) {
      writer.uint32(10).bytes(message.const);
    }
    if (message.len !== undefined && message.len !== 0) {
      writer.uint32(104).uint64(message.len);
    }
    if (message.min_len !== undefined && message.min_len !== 0) {
      writer.uint32(16).uint64(message.min_len);
    }
    if (message.max_len !== undefined && message.max_len !== 0) {
      writer.uint32(24).uint64(message.max_len);
    }
    if (message.pattern !== undefined && message.pattern !== "") {
      writer.uint32(34).string(message.pattern);
    }
    if (message.prefix !== undefined && message.prefix.length !== 0) {
      writer.uint32(42).bytes(message.prefix);
    }
    if (message.suffix !== undefined && message.suffix.length !== 0) {
      writer.uint32(50).bytes(message.suffix);
    }
    if (message.contains !== undefined && message.contains.length !== 0) {
      writer.uint32(58).bytes(message.contains);
    }
    if (message.in !== undefined && message.in.length !== 0) {
      for (const v of message.in) {
        writer.uint32(66).bytes(v!);
      }
    }
    if (message.not_in !== undefined && message.not_in.length !== 0) {
      for (const v of message.not_in) {
        writer.uint32(74).bytes(v!);
      }
    }
    switch (message.well_known?.$case) {
      case "ip":
        writer.uint32(80).bool(message.well_known.ip);
        break;
      case "ipv4":
        writer.uint32(88).bool(message.well_known.ipv4);
        break;
      case "ipv6":
        writer.uint32(96).bool(message.well_known.ipv6);
        break;
    }
    if (message.ignore_empty !== undefined && message.ignore_empty !== false) {
      writer.uint32(112).bool(message.ignore_empty);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BytesRules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBytesRules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.const = reader.bytes();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.len = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.min_len = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.max_len = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pattern = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.prefix = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.suffix = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.contains = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          if (message.in === undefined) {
            message.in = [];
          }
          const el = reader.bytes();
          if (el !== undefined) {
            message.in!.push(el);
          }
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          if (message.not_in === undefined) {
            message.not_in = [];
          }
          const el = reader.bytes();
          if (el !== undefined) {
            message.not_in!.push(el);
          }
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.well_known = { $case: "ip", ip: reader.bool() };
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.well_known = { $case: "ipv4", ipv4: reader.bool() };
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.well_known = { $case: "ipv6", ipv6: reader.bool() };
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.ignore_empty = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BytesRules {
    return {
      $type: BytesRules.$type,
      const: isSet(object.const) ? bytesFromBase64(object.const) : undefined,
      len: isSet(object.len) ? globalThis.Number(object.len) : undefined,
      min_len: isSet(object.min_len) ? globalThis.Number(object.min_len) : undefined,
      max_len: isSet(object.max_len) ? globalThis.Number(object.max_len) : undefined,
      pattern: isSet(object.pattern) ? globalThis.String(object.pattern) : undefined,
      prefix: isSet(object.prefix) ? bytesFromBase64(object.prefix) : undefined,
      suffix: isSet(object.suffix) ? bytesFromBase64(object.suffix) : undefined,
      contains: isSet(object.contains) ? bytesFromBase64(object.contains) : undefined,
      in: globalThis.Array.isArray(object?.in) ? object.in.map((e: any) => bytesFromBase64(e)) : undefined,
      not_in: globalThis.Array.isArray(object?.not_in) ? object.not_in.map((e: any) => bytesFromBase64(e)) : undefined,
      well_known: isSet(object.ip)
        ? { $case: "ip", ip: globalThis.Boolean(object.ip) }
        : isSet(object.ipv4)
        ? { $case: "ipv4", ipv4: globalThis.Boolean(object.ipv4) }
        : isSet(object.ipv6)
        ? { $case: "ipv6", ipv6: globalThis.Boolean(object.ipv6) }
        : undefined,
      ignore_empty: isSet(object.ignore_empty) ? globalThis.Boolean(object.ignore_empty) : undefined,
    };
  },

  toJSON(message: BytesRules): unknown {
    const obj: any = {};
    if (message.const !== undefined) {
      obj.const = base64FromBytes(message.const);
    }
    if (message.len !== undefined) {
      obj.len = Math.round(message.len);
    }
    if (message.min_len !== undefined) {
      obj.min_len = Math.round(message.min_len);
    }
    if (message.max_len !== undefined) {
      obj.max_len = Math.round(message.max_len);
    }
    if (message.pattern !== undefined) {
      obj.pattern = message.pattern;
    }
    if (message.prefix !== undefined) {
      obj.prefix = base64FromBytes(message.prefix);
    }
    if (message.suffix !== undefined) {
      obj.suffix = base64FromBytes(message.suffix);
    }
    if (message.contains !== undefined) {
      obj.contains = base64FromBytes(message.contains);
    }
    if (message.in?.length) {
      obj.in = message.in.map((e) => base64FromBytes(e));
    }
    if (message.not_in?.length) {
      obj.not_in = message.not_in.map((e) => base64FromBytes(e));
    }
    if (message.well_known?.$case === "ip") {
      obj.ip = message.well_known.ip;
    }
    if (message.well_known?.$case === "ipv4") {
      obj.ipv4 = message.well_known.ipv4;
    }
    if (message.well_known?.$case === "ipv6") {
      obj.ipv6 = message.well_known.ipv6;
    }
    if (message.ignore_empty !== undefined) {
      obj.ignore_empty = message.ignore_empty;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BytesRules>, I>>(base?: I): BytesRules {
    return BytesRules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BytesRules>, I>>(object: I): BytesRules {
    const message = createBaseBytesRules();
    message.const = object.const ?? undefined;
    message.len = object.len ?? undefined;
    message.min_len = object.min_len ?? undefined;
    message.max_len = object.max_len ?? undefined;
    message.pattern = object.pattern ?? undefined;
    message.prefix = object.prefix ?? undefined;
    message.suffix = object.suffix ?? undefined;
    message.contains = object.contains ?? undefined;
    message.in = object.in?.map((e) => e) || undefined;
    message.not_in = object.not_in?.map((e) => e) || undefined;
    if (object.well_known?.$case === "ip" && object.well_known?.ip !== undefined && object.well_known?.ip !== null) {
      message.well_known = { $case: "ip", ip: object.well_known.ip };
    }
    if (
      object.well_known?.$case === "ipv4" && object.well_known?.ipv4 !== undefined && object.well_known?.ipv4 !== null
    ) {
      message.well_known = { $case: "ipv4", ipv4: object.well_known.ipv4 };
    }
    if (
      object.well_known?.$case === "ipv6" && object.well_known?.ipv6 !== undefined && object.well_known?.ipv6 !== null
    ) {
      message.well_known = { $case: "ipv6", ipv6: object.well_known.ipv6 };
    }
    message.ignore_empty = object.ignore_empty ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(BytesRules.$type, BytesRules);

function createBaseEnumRules(): EnumRules {
  return { $type: "validate.EnumRules" };
}

export const EnumRules: MessageFns<EnumRules, "validate.EnumRules"> = {
  $type: "validate.EnumRules" as const,

  encode(message: EnumRules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.const !== undefined && message.const !== 0) {
      writer.uint32(8).int32(message.const);
    }
    if (message.defined_only !== undefined && message.defined_only !== false) {
      writer.uint32(16).bool(message.defined_only);
    }
    if (message.in !== undefined && message.in.length !== 0) {
      writer.uint32(26).fork();
      for (const v of message.in) {
        writer.int32(v);
      }
      writer.join();
    }
    if (message.not_in !== undefined && message.not_in.length !== 0) {
      writer.uint32(34).fork();
      for (const v of message.not_in) {
        writer.int32(v);
      }
      writer.join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnumRules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnumRules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.const = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.defined_only = reader.bool();
          continue;
        }
        case 3: {
          if (tag === 24) {
            if (message.in === undefined) {
              message.in = [];
            }
            message.in!.push(reader.int32());

            continue;
          }

          if (tag === 26) {
            if (message.in === undefined) {
              message.in = [];
            }
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.in!.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 4: {
          if (tag === 32) {
            if (message.not_in === undefined) {
              message.not_in = [];
            }
            message.not_in!.push(reader.int32());

            continue;
          }

          if (tag === 34) {
            if (message.not_in === undefined) {
              message.not_in = [];
            }
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.not_in!.push(reader.int32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnumRules {
    return {
      $type: EnumRules.$type,
      const: isSet(object.const) ? globalThis.Number(object.const) : undefined,
      defined_only: isSet(object.defined_only) ? globalThis.Boolean(object.defined_only) : undefined,
      in: globalThis.Array.isArray(object?.in) ? object.in.map((e: any) => globalThis.Number(e)) : undefined,
      not_in: globalThis.Array.isArray(object?.not_in)
        ? object.not_in.map((e: any) => globalThis.Number(e))
        : undefined,
    };
  },

  toJSON(message: EnumRules): unknown {
    const obj: any = {};
    if (message.const !== undefined) {
      obj.const = Math.round(message.const);
    }
    if (message.defined_only !== undefined) {
      obj.defined_only = message.defined_only;
    }
    if (message.in?.length) {
      obj.in = message.in.map((e) => Math.round(e));
    }
    if (message.not_in?.length) {
      obj.not_in = message.not_in.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EnumRules>, I>>(base?: I): EnumRules {
    return EnumRules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EnumRules>, I>>(object: I): EnumRules {
    const message = createBaseEnumRules();
    message.const = object.const ?? undefined;
    message.defined_only = object.defined_only ?? undefined;
    message.in = object.in?.map((e) => e) || undefined;
    message.not_in = object.not_in?.map((e) => e) || undefined;
    return message;
  },
};

messageTypeRegistry.set(EnumRules.$type, EnumRules);

function createBaseMessageRules(): MessageRules {
  return { $type: "validate.MessageRules" };
}

export const MessageRules: MessageFns<MessageRules, "validate.MessageRules"> = {
  $type: "validate.MessageRules" as const,

  encode(message: MessageRules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.skip !== undefined && message.skip !== false) {
      writer.uint32(8).bool(message.skip);
    }
    if (message.required !== undefined && message.required !== false) {
      writer.uint32(16).bool(message.required);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageRules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageRules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.skip = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.required = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageRules {
    return {
      $type: MessageRules.$type,
      skip: isSet(object.skip) ? globalThis.Boolean(object.skip) : undefined,
      required: isSet(object.required) ? globalThis.Boolean(object.required) : undefined,
    };
  },

  toJSON(message: MessageRules): unknown {
    const obj: any = {};
    if (message.skip !== undefined) {
      obj.skip = message.skip;
    }
    if (message.required !== undefined) {
      obj.required = message.required;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageRules>, I>>(base?: I): MessageRules {
    return MessageRules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageRules>, I>>(object: I): MessageRules {
    const message = createBaseMessageRules();
    message.skip = object.skip ?? undefined;
    message.required = object.required ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(MessageRules.$type, MessageRules);

function createBaseRepeatedRules(): RepeatedRules {
  return { $type: "validate.RepeatedRules" };
}

export const RepeatedRules: MessageFns<RepeatedRules, "validate.RepeatedRules"> = {
  $type: "validate.RepeatedRules" as const,

  encode(message: RepeatedRules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.min_items !== undefined && message.min_items !== 0) {
      writer.uint32(8).uint64(message.min_items);
    }
    if (message.max_items !== undefined && message.max_items !== 0) {
      writer.uint32(16).uint64(message.max_items);
    }
    if (message.unique !== undefined && message.unique !== false) {
      writer.uint32(24).bool(message.unique);
    }
    if (message.items !== undefined) {
      FieldRules.encode(message.items, writer.uint32(34).fork()).join();
    }
    if (message.ignore_empty !== undefined && message.ignore_empty !== false) {
      writer.uint32(40).bool(message.ignore_empty);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RepeatedRules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRepeatedRules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.min_items = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.max_items = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.unique = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.items = FieldRules.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.ignore_empty = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RepeatedRules {
    return {
      $type: RepeatedRules.$type,
      min_items: isSet(object.min_items) ? globalThis.Number(object.min_items) : undefined,
      max_items: isSet(object.max_items) ? globalThis.Number(object.max_items) : undefined,
      unique: isSet(object.unique) ? globalThis.Boolean(object.unique) : undefined,
      items: isSet(object.items) ? FieldRules.fromJSON(object.items) : undefined,
      ignore_empty: isSet(object.ignore_empty) ? globalThis.Boolean(object.ignore_empty) : undefined,
    };
  },

  toJSON(message: RepeatedRules): unknown {
    const obj: any = {};
    if (message.min_items !== undefined) {
      obj.min_items = Math.round(message.min_items);
    }
    if (message.max_items !== undefined) {
      obj.max_items = Math.round(message.max_items);
    }
    if (message.unique !== undefined) {
      obj.unique = message.unique;
    }
    if (message.items !== undefined) {
      obj.items = FieldRules.toJSON(message.items);
    }
    if (message.ignore_empty !== undefined) {
      obj.ignore_empty = message.ignore_empty;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RepeatedRules>, I>>(base?: I): RepeatedRules {
    return RepeatedRules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RepeatedRules>, I>>(object: I): RepeatedRules {
    const message = createBaseRepeatedRules();
    message.min_items = object.min_items ?? undefined;
    message.max_items = object.max_items ?? undefined;
    message.unique = object.unique ?? undefined;
    message.items = (object.items !== undefined && object.items !== null)
      ? FieldRules.fromPartial(object.items)
      : undefined;
    message.ignore_empty = object.ignore_empty ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RepeatedRules.$type, RepeatedRules);

function createBaseMapRules(): MapRules {
  return { $type: "validate.MapRules" };
}

export const MapRules: MessageFns<MapRules, "validate.MapRules"> = {
  $type: "validate.MapRules" as const,

  encode(message: MapRules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.min_pairs !== undefined && message.min_pairs !== 0) {
      writer.uint32(8).uint64(message.min_pairs);
    }
    if (message.max_pairs !== undefined && message.max_pairs !== 0) {
      writer.uint32(16).uint64(message.max_pairs);
    }
    if (message.no_sparse !== undefined && message.no_sparse !== false) {
      writer.uint32(24).bool(message.no_sparse);
    }
    if (message.keys !== undefined) {
      FieldRules.encode(message.keys, writer.uint32(34).fork()).join();
    }
    if (message.values !== undefined) {
      FieldRules.encode(message.values, writer.uint32(42).fork()).join();
    }
    if (message.ignore_empty !== undefined && message.ignore_empty !== false) {
      writer.uint32(48).bool(message.ignore_empty);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapRules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapRules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.min_pairs = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.max_pairs = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.no_sparse = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.keys = FieldRules.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.values = FieldRules.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.ignore_empty = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapRules {
    return {
      $type: MapRules.$type,
      min_pairs: isSet(object.min_pairs) ? globalThis.Number(object.min_pairs) : undefined,
      max_pairs: isSet(object.max_pairs) ? globalThis.Number(object.max_pairs) : undefined,
      no_sparse: isSet(object.no_sparse) ? globalThis.Boolean(object.no_sparse) : undefined,
      keys: isSet(object.keys) ? FieldRules.fromJSON(object.keys) : undefined,
      values: isSet(object.values) ? FieldRules.fromJSON(object.values) : undefined,
      ignore_empty: isSet(object.ignore_empty) ? globalThis.Boolean(object.ignore_empty) : undefined,
    };
  },

  toJSON(message: MapRules): unknown {
    const obj: any = {};
    if (message.min_pairs !== undefined) {
      obj.min_pairs = Math.round(message.min_pairs);
    }
    if (message.max_pairs !== undefined) {
      obj.max_pairs = Math.round(message.max_pairs);
    }
    if (message.no_sparse !== undefined) {
      obj.no_sparse = message.no_sparse;
    }
    if (message.keys !== undefined) {
      obj.keys = FieldRules.toJSON(message.keys);
    }
    if (message.values !== undefined) {
      obj.values = FieldRules.toJSON(message.values);
    }
    if (message.ignore_empty !== undefined) {
      obj.ignore_empty = message.ignore_empty;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MapRules>, I>>(base?: I): MapRules {
    return MapRules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MapRules>, I>>(object: I): MapRules {
    const message = createBaseMapRules();
    message.min_pairs = object.min_pairs ?? undefined;
    message.max_pairs = object.max_pairs ?? undefined;
    message.no_sparse = object.no_sparse ?? undefined;
    message.keys = (object.keys !== undefined && object.keys !== null)
      ? FieldRules.fromPartial(object.keys)
      : undefined;
    message.values = (object.values !== undefined && object.values !== null)
      ? FieldRules.fromPartial(object.values)
      : undefined;
    message.ignore_empty = object.ignore_empty ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(MapRules.$type, MapRules);

function createBaseAnyRules(): AnyRules {
  return { $type: "validate.AnyRules" };
}

export const AnyRules: MessageFns<AnyRules, "validate.AnyRules"> = {
  $type: "validate.AnyRules" as const,

  encode(message: AnyRules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.required !== undefined && message.required !== false) {
      writer.uint32(8).bool(message.required);
    }
    if (message.in !== undefined && message.in.length !== 0) {
      for (const v of message.in) {
        writer.uint32(18).string(v!);
      }
    }
    if (message.not_in !== undefined && message.not_in.length !== 0) {
      for (const v of message.not_in) {
        writer.uint32(26).string(v!);
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnyRules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnyRules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.required = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.in === undefined) {
            message.in = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.in!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.not_in === undefined) {
            message.not_in = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.not_in!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnyRules {
    return {
      $type: AnyRules.$type,
      required: isSet(object.required) ? globalThis.Boolean(object.required) : undefined,
      in: globalThis.Array.isArray(object?.in) ? object.in.map((e: any) => globalThis.String(e)) : undefined,
      not_in: globalThis.Array.isArray(object?.not_in)
        ? object.not_in.map((e: any) => globalThis.String(e))
        : undefined,
    };
  },

  toJSON(message: AnyRules): unknown {
    const obj: any = {};
    if (message.required !== undefined) {
      obj.required = message.required;
    }
    if (message.in?.length) {
      obj.in = message.in;
    }
    if (message.not_in?.length) {
      obj.not_in = message.not_in;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnyRules>, I>>(base?: I): AnyRules {
    return AnyRules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnyRules>, I>>(object: I): AnyRules {
    const message = createBaseAnyRules();
    message.required = object.required ?? undefined;
    message.in = object.in?.map((e) => e) || undefined;
    message.not_in = object.not_in?.map((e) => e) || undefined;
    return message;
  },
};

messageTypeRegistry.set(AnyRules.$type, AnyRules);

function createBaseDurationRules(): DurationRules {
  return { $type: "validate.DurationRules" };
}

export const DurationRules: MessageFns<DurationRules, "validate.DurationRules"> = {
  $type: "validate.DurationRules" as const,

  encode(message: DurationRules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.required !== undefined && message.required !== false) {
      writer.uint32(8).bool(message.required);
    }
    if (message.const !== undefined) {
      Duration.encode(message.const, writer.uint32(18).fork()).join();
    }
    if (message.lt !== undefined) {
      Duration.encode(message.lt, writer.uint32(26).fork()).join();
    }
    if (message.lte !== undefined) {
      Duration.encode(message.lte, writer.uint32(34).fork()).join();
    }
    if (message.gt !== undefined) {
      Duration.encode(message.gt, writer.uint32(42).fork()).join();
    }
    if (message.gte !== undefined) {
      Duration.encode(message.gte, writer.uint32(50).fork()).join();
    }
    if (message.in !== undefined && message.in.length !== 0) {
      for (const v of message.in) {
        Duration.encode(v!, writer.uint32(58).fork()).join();
      }
    }
    if (message.not_in !== undefined && message.not_in.length !== 0) {
      for (const v of message.not_in) {
        Duration.encode(v!, writer.uint32(66).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DurationRules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDurationRules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.required = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.const = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.lt = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.lte = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.gt = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.gte = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          if (message.in === undefined) {
            message.in = [];
          }
          const el = Duration.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.in!.push(el);
          }
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          if (message.not_in === undefined) {
            message.not_in = [];
          }
          const el = Duration.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.not_in!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DurationRules {
    return {
      $type: DurationRules.$type,
      required: isSet(object.required) ? globalThis.Boolean(object.required) : undefined,
      const: isSet(object.const) ? Duration.fromJSON(object.const) : undefined,
      lt: isSet(object.lt) ? Duration.fromJSON(object.lt) : undefined,
      lte: isSet(object.lte) ? Duration.fromJSON(object.lte) : undefined,
      gt: isSet(object.gt) ? Duration.fromJSON(object.gt) : undefined,
      gte: isSet(object.gte) ? Duration.fromJSON(object.gte) : undefined,
      in: globalThis.Array.isArray(object?.in) ? object.in.map((e: any) => Duration.fromJSON(e)) : undefined,
      not_in: globalThis.Array.isArray(object?.not_in)
        ? object.not_in.map((e: any) => Duration.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: DurationRules): unknown {
    const obj: any = {};
    if (message.required !== undefined) {
      obj.required = message.required;
    }
    if (message.const !== undefined) {
      obj.const = Duration.toJSON(message.const);
    }
    if (message.lt !== undefined) {
      obj.lt = Duration.toJSON(message.lt);
    }
    if (message.lte !== undefined) {
      obj.lte = Duration.toJSON(message.lte);
    }
    if (message.gt !== undefined) {
      obj.gt = Duration.toJSON(message.gt);
    }
    if (message.gte !== undefined) {
      obj.gte = Duration.toJSON(message.gte);
    }
    if (message.in?.length) {
      obj.in = message.in.map((e) => Duration.toJSON(e));
    }
    if (message.not_in?.length) {
      obj.not_in = message.not_in.map((e) => Duration.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DurationRules>, I>>(base?: I): DurationRules {
    return DurationRules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DurationRules>, I>>(object: I): DurationRules {
    const message = createBaseDurationRules();
    message.required = object.required ?? undefined;
    message.const = (object.const !== undefined && object.const !== null)
      ? Duration.fromPartial(object.const)
      : undefined;
    message.lt = (object.lt !== undefined && object.lt !== null) ? Duration.fromPartial(object.lt) : undefined;
    message.lte = (object.lte !== undefined && object.lte !== null) ? Duration.fromPartial(object.lte) : undefined;
    message.gt = (object.gt !== undefined && object.gt !== null) ? Duration.fromPartial(object.gt) : undefined;
    message.gte = (object.gte !== undefined && object.gte !== null) ? Duration.fromPartial(object.gte) : undefined;
    message.in = object.in?.map((e) => Duration.fromPartial(e)) || undefined;
    message.not_in = object.not_in?.map((e) => Duration.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(DurationRules.$type, DurationRules);

function createBaseTimestampRules(): TimestampRules {
  return { $type: "validate.TimestampRules" };
}

export const TimestampRules: MessageFns<TimestampRules, "validate.TimestampRules"> = {
  $type: "validate.TimestampRules" as const,

  encode(message: TimestampRules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.required !== undefined && message.required !== false) {
      writer.uint32(8).bool(message.required);
    }
    if (message.const !== undefined) {
      Timestamp.encode(toTimestamp(message.const), writer.uint32(18).fork()).join();
    }
    if (message.lt !== undefined) {
      Timestamp.encode(toTimestamp(message.lt), writer.uint32(26).fork()).join();
    }
    if (message.lte !== undefined) {
      Timestamp.encode(toTimestamp(message.lte), writer.uint32(34).fork()).join();
    }
    if (message.gt !== undefined) {
      Timestamp.encode(toTimestamp(message.gt), writer.uint32(42).fork()).join();
    }
    if (message.gte !== undefined) {
      Timestamp.encode(toTimestamp(message.gte), writer.uint32(50).fork()).join();
    }
    if (message.lt_now !== undefined && message.lt_now !== false) {
      writer.uint32(56).bool(message.lt_now);
    }
    if (message.gt_now !== undefined && message.gt_now !== false) {
      writer.uint32(64).bool(message.gt_now);
    }
    if (message.within !== undefined) {
      Duration.encode(message.within, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimestampRules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimestampRules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.required = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.const = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.lt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.lte = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.gt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.gte = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.lt_now = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.gt_now = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.within = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimestampRules {
    return {
      $type: TimestampRules.$type,
      required: isSet(object.required) ? globalThis.Boolean(object.required) : undefined,
      const: isSet(object.const) ? fromJsonTimestamp(object.const) : undefined,
      lt: isSet(object.lt) ? fromJsonTimestamp(object.lt) : undefined,
      lte: isSet(object.lte) ? fromJsonTimestamp(object.lte) : undefined,
      gt: isSet(object.gt) ? fromJsonTimestamp(object.gt) : undefined,
      gte: isSet(object.gte) ? fromJsonTimestamp(object.gte) : undefined,
      lt_now: isSet(object.lt_now) ? globalThis.Boolean(object.lt_now) : undefined,
      gt_now: isSet(object.gt_now) ? globalThis.Boolean(object.gt_now) : undefined,
      within: isSet(object.within) ? Duration.fromJSON(object.within) : undefined,
    };
  },

  toJSON(message: TimestampRules): unknown {
    const obj: any = {};
    if (message.required !== undefined) {
      obj.required = message.required;
    }
    if (message.const !== undefined) {
      obj.const = message.const.toISOString();
    }
    if (message.lt !== undefined) {
      obj.lt = message.lt.toISOString();
    }
    if (message.lte !== undefined) {
      obj.lte = message.lte.toISOString();
    }
    if (message.gt !== undefined) {
      obj.gt = message.gt.toISOString();
    }
    if (message.gte !== undefined) {
      obj.gte = message.gte.toISOString();
    }
    if (message.lt_now !== undefined) {
      obj.lt_now = message.lt_now;
    }
    if (message.gt_now !== undefined) {
      obj.gt_now = message.gt_now;
    }
    if (message.within !== undefined) {
      obj.within = Duration.toJSON(message.within);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TimestampRules>, I>>(base?: I): TimestampRules {
    return TimestampRules.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TimestampRules>, I>>(object: I): TimestampRules {
    const message = createBaseTimestampRules();
    message.required = object.required ?? undefined;
    message.const = object.const ?? undefined;
    message.lt = object.lt ?? undefined;
    message.lte = object.lte ?? undefined;
    message.gt = object.gt ?? undefined;
    message.gte = object.gte ?? undefined;
    message.lt_now = object.lt_now ?? undefined;
    message.gt_now = object.gt_now ?? undefined;
    message.within = (object.within !== undefined && object.within !== null)
      ? Duration.fromPartial(object.within)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(TimestampRules.$type, TimestampRules);

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { $type: "google.protobuf.Timestamp", seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
