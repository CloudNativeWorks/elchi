// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/api/v2/scoped_route.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { messageTypeRegistry } from "../../../typeRegistry";

export const protobufPackage = "envoy.api.v2";

/**
 * Specifies a routing scope, which associates a
 * :ref:`Key<envoy_api_msg_ScopedRouteConfiguration.Key>` to a
 * :ref:`envoy_api_msg_RouteConfiguration` (identified by its resource name).
 *
 * The HTTP connection manager builds up a table consisting of these Key to
 * RouteConfiguration mappings, and looks up the RouteConfiguration to use per
 * request according to the algorithm specified in the
 * :ref:`scope_key_builder<envoy_api_field_config.filter.network.http_connection_manager.v2.ScopedRoutes.scope_key_builder>`
 * assigned to the HttpConnectionManager.
 *
 * For example, with the following configurations (in YAML):
 *
 * HttpConnectionManager config:
 *
 * .. code::
 *
 *   ...
 *   scoped_routes:
 *     name: foo-scoped-routes
 *     scope_key_builder:
 *       fragments:
 *         - header_value_extractor:
 *             name: X-Route-Selector
 *             element_separator: ","
 *             element:
 *               separator: =
 *               key: vip
 *
 * ScopedRouteConfiguration resources (specified statically via
 * :ref:`scoped_route_configurations_list<envoy_api_field_config.filter.network.http_connection_manager.v2.ScopedRoutes.scoped_route_configurations_list>`
 * or obtained dynamically via SRDS):
 *
 * .. code::
 *
 *  (1)
 *   name: route-scope1
 *   route_configuration_name: route-config1
 *   key:
 *      fragments:
 *        - string_key: 172.10.10.20
 *
 *  (2)
 *   name: route-scope2
 *   route_configuration_name: route-config2
 *   key:
 *     fragments:
 *       - string_key: 172.20.20.30
 *
 * A request from a client such as:
 *
 * .. code::
 *
 *     GET / HTTP/1.1
 *     Host: foo.com
 *     X-Route-Selector: vip=172.10.10.20
 *
 * would result in the routing table defined by the `route-config1`
 * RouteConfiguration being assigned to the HTTP request/stream.
 */
export interface ScopedRouteConfiguration {
  $type: "envoy.api.v2.ScopedRouteConfiguration";
  /** The name assigned to the routing scope. */
  name?:
    | string
    | undefined;
  /**
   * The resource name to use for a :ref:`envoy_api_msg_DiscoveryRequest` to an
   * RDS server to fetch the :ref:`envoy_api_msg_RouteConfiguration` associated
   * with this scope.
   */
  route_configuration_name?:
    | string
    | undefined;
  /** The key to match against. */
  key?: ScopedRouteConfiguration_Key | undefined;
}

/**
 * Specifies a key which is matched against the output of the
 * :ref:`scope_key_builder<envoy_api_field_config.filter.network.http_connection_manager.v2.ScopedRoutes.scope_key_builder>`
 * specified in the HttpConnectionManager. The matching is done per HTTP
 * request and is dependent on the order of the fragments contained in the
 * Key.
 */
export interface ScopedRouteConfiguration_Key {
  $type: "envoy.api.v2.ScopedRouteConfiguration.Key";
  /**
   * The ordered set of fragments to match against. The order must match the
   * fragments in the corresponding
   * :ref:`scope_key_builder<envoy_api_field_config.filter.network.http_connection_manager.v2.ScopedRoutes.scope_key_builder>`.
   */
  fragments?: ScopedRouteConfiguration_Key_Fragment[] | undefined;
}

export interface ScopedRouteConfiguration_Key_Fragment {
  $type: "envoy.api.v2.ScopedRouteConfiguration.Key.Fragment";
  type?:
    | //
    /** A string to match against. */
    { $case: "string_key"; string_key: string }
    | undefined;
}

function createBaseScopedRouteConfiguration(): ScopedRouteConfiguration {
  return { $type: "envoy.api.v2.ScopedRouteConfiguration" };
}

export const ScopedRouteConfiguration: MessageFns<ScopedRouteConfiguration, "envoy.api.v2.ScopedRouteConfiguration"> = {
  $type: "envoy.api.v2.ScopedRouteConfiguration" as const,

  encode(message: ScopedRouteConfiguration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.route_configuration_name !== undefined && message.route_configuration_name !== "") {
      writer.uint32(18).string(message.route_configuration_name);
    }
    if (message.key !== undefined) {
      ScopedRouteConfiguration_Key.encode(message.key, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScopedRouteConfiguration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScopedRouteConfiguration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.route_configuration_name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.key = ScopedRouteConfiguration_Key.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScopedRouteConfiguration {
    return {
      $type: ScopedRouteConfiguration.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      route_configuration_name: isSet(object.route_configuration_name)
        ? globalThis.String(object.route_configuration_name)
        : undefined,
      key: isSet(object.key) ? ScopedRouteConfiguration_Key.fromJSON(object.key) : undefined,
    };
  },

  toJSON(message: ScopedRouteConfiguration): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.route_configuration_name !== undefined) {
      obj.route_configuration_name = message.route_configuration_name;
    }
    if (message.key !== undefined) {
      obj.key = ScopedRouteConfiguration_Key.toJSON(message.key);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScopedRouteConfiguration>, I>>(base?: I): ScopedRouteConfiguration {
    return ScopedRouteConfiguration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScopedRouteConfiguration>, I>>(object: I): ScopedRouteConfiguration {
    const message = createBaseScopedRouteConfiguration();
    message.name = object.name ?? undefined;
    message.route_configuration_name = object.route_configuration_name ?? undefined;
    message.key = (object.key !== undefined && object.key !== null)
      ? ScopedRouteConfiguration_Key.fromPartial(object.key)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(ScopedRouteConfiguration.$type, ScopedRouteConfiguration);

function createBaseScopedRouteConfiguration_Key(): ScopedRouteConfiguration_Key {
  return { $type: "envoy.api.v2.ScopedRouteConfiguration.Key" };
}

export const ScopedRouteConfiguration_Key: MessageFns<
  ScopedRouteConfiguration_Key,
  "envoy.api.v2.ScopedRouteConfiguration.Key"
> = {
  $type: "envoy.api.v2.ScopedRouteConfiguration.Key" as const,

  encode(message: ScopedRouteConfiguration_Key, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fragments !== undefined && message.fragments.length !== 0) {
      for (const v of message.fragments) {
        ScopedRouteConfiguration_Key_Fragment.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScopedRouteConfiguration_Key {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScopedRouteConfiguration_Key();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.fragments === undefined) {
            message.fragments = [];
          }
          const el = ScopedRouteConfiguration_Key_Fragment.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.fragments!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScopedRouteConfiguration_Key {
    return {
      $type: ScopedRouteConfiguration_Key.$type,
      fragments: globalThis.Array.isArray(object?.fragments)
        ? object.fragments.map((e: any) => ScopedRouteConfiguration_Key_Fragment.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: ScopedRouteConfiguration_Key): unknown {
    const obj: any = {};
    if (message.fragments?.length) {
      obj.fragments = message.fragments.map((e) => ScopedRouteConfiguration_Key_Fragment.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScopedRouteConfiguration_Key>, I>>(base?: I): ScopedRouteConfiguration_Key {
    return ScopedRouteConfiguration_Key.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScopedRouteConfiguration_Key>, I>>(object: I): ScopedRouteConfiguration_Key {
    const message = createBaseScopedRouteConfiguration_Key();
    message.fragments = object.fragments?.map((e) => ScopedRouteConfiguration_Key_Fragment.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(ScopedRouteConfiguration_Key.$type, ScopedRouteConfiguration_Key);

function createBaseScopedRouteConfiguration_Key_Fragment(): ScopedRouteConfiguration_Key_Fragment {
  return { $type: "envoy.api.v2.ScopedRouteConfiguration.Key.Fragment", type: undefined };
}

export const ScopedRouteConfiguration_Key_Fragment: MessageFns<
  ScopedRouteConfiguration_Key_Fragment,
  "envoy.api.v2.ScopedRouteConfiguration.Key.Fragment"
> = {
  $type: "envoy.api.v2.ScopedRouteConfiguration.Key.Fragment" as const,

  encode(message: ScopedRouteConfiguration_Key_Fragment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.type?.$case) {
      case "string_key":
        writer.uint32(10).string(message.type.string_key);
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScopedRouteConfiguration_Key_Fragment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScopedRouteConfiguration_Key_Fragment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = { $case: "string_key", string_key: reader.string() };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScopedRouteConfiguration_Key_Fragment {
    return {
      $type: ScopedRouteConfiguration_Key_Fragment.$type,
      type: isSet(object.string_key)
        ? { $case: "string_key", string_key: globalThis.String(object.string_key) }
        : undefined,
    };
  },

  toJSON(message: ScopedRouteConfiguration_Key_Fragment): unknown {
    const obj: any = {};
    if (message.type?.$case === "string_key") {
      obj.string_key = message.type.string_key;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScopedRouteConfiguration_Key_Fragment>, I>>(
    base?: I,
  ): ScopedRouteConfiguration_Key_Fragment {
    return ScopedRouteConfiguration_Key_Fragment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScopedRouteConfiguration_Key_Fragment>, I>>(
    object: I,
  ): ScopedRouteConfiguration_Key_Fragment {
    const message = createBaseScopedRouteConfiguration_Key_Fragment();
    if (
      object.type?.$case === "string_key" && object.type?.string_key !== undefined && object.type?.string_key !== null
    ) {
      message.type = { $case: "string_key", string_key: object.type.string_key };
    }
    return message;
  },
};

messageTypeRegistry.set(ScopedRouteConfiguration_Key_Fragment.$type, ScopedRouteConfiguration_Key_Fragment);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
