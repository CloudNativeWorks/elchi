// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/api/v2/core/protocol.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../../google/protobuf/duration";
import { BoolValue, UInt32Value } from "../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../typeRegistry";

export const protobufPackage = "envoy.api.v2.core";

/** [#not-implemented-hide:] */
export interface TcpProtocolOptions {
  $type: "envoy.api.v2.core.TcpProtocolOptions";
}

export interface UpstreamHttpProtocolOptions {
  $type: "envoy.api.v2.core.UpstreamHttpProtocolOptions";
  /**
   * Set transport socket `SNI <https://en.wikipedia.org/wiki/Server_Name_Indication>`_ for new
   * upstream connections based on the downstream HTTP host/authority header, as seen by the
   * :ref:`router filter <config_http_filters_router>`.
   */
  auto_sni?:
    | boolean
    | undefined;
  /**
   * Automatic validate upstream presented certificate for new upstream connections based on the
   * downstream HTTP host/authority header, as seen by the
   * :ref:`router filter <config_http_filters_router>`.
   * This field is intended to set with `auto_sni` field.
   */
  auto_san_validation?: boolean | undefined;
}

/** [#next-free-field: 6] */
export interface HttpProtocolOptions {
  $type: "envoy.api.v2.core.HttpProtocolOptions";
  /**
   * The idle timeout for connections. The idle timeout is defined as the
   * period in which there are no active requests. When the
   * idle timeout is reached the connection will be closed. If the connection is an HTTP/2
   * downstream connection a drain sequence will occur prior to closing the connection, see
   * :ref:`drain_timeout
   * <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.drain_timeout>`.
   * Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive.
   * If not specified, this defaults to 1 hour. To disable idle timeouts explicitly set this to 0.
   *
   * .. warning::
   *   Disabling this timeout has a highly likelihood of yielding connection leaks due to lost TCP
   *   FIN packets, etc.
   */
  idle_timeout?:
    | Duration
    | undefined;
  /**
   * The maximum duration of a connection. The duration is defined as a period since a connection
   * was established. If not set, there is no max duration. When max_connection_duration is reached
   * the connection will be closed. Drain sequence will occur prior to closing the connection if
   * if's applicable. See :ref:`drain_timeout
   * <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.drain_timeout>`.
   * Note: not implemented for upstream connections.
   */
  max_connection_duration?:
    | Duration
    | undefined;
  /**
   * The maximum number of headers. If unconfigured, the default
   * maximum number of request headers allowed is 100. Requests that exceed this limit will receive
   * a 431 response for HTTP/1.x and cause a stream reset for HTTP/2.
   */
  max_headers_count?:
    | number
    | undefined;
  /**
   * Total duration to keep alive an HTTP request/response stream. If the time limit is reached the stream will be
   * reset independent of any other timeouts. If not specified, this value is not set.
   */
  max_stream_duration?:
    | Duration
    | undefined;
  /**
   * Action to take when a client request with a header name containing underscore characters is received.
   * If this setting is not specified, the value defaults to ALLOW.
   * Note: upstream responses are not affected by this setting.
   */
  headers_with_underscores_action?: HttpProtocolOptions_HeadersWithUnderscoresAction | undefined;
}

/**
 * Action to take when Envoy receives client request with header names containing underscore
 * characters.
 * Underscore character is allowed in header names by the RFC-7230 and this behavior is implemented
 * as a security measure due to systems that treat '_' and '-' as interchangeable. Envoy by default allows client request headers with underscore
 * characters.
 */
export enum HttpProtocolOptions_HeadersWithUnderscoresAction {
  /** ALLOW - Allow headers with underscores. This is the default behavior. */
  ALLOW = "ALLOW",
  /**
   * REJECT_REQUEST - Reject client request. HTTP/1 requests are rejected with the 400 status. HTTP/2 requests
   * end with the stream reset. The "httpN.requests_rejected_with_underscores_in_headers" counter
   * is incremented for each rejected request.
   */
  REJECT_REQUEST = "REJECT_REQUEST",
  /**
   * DROP_HEADER - Drop the header with name containing underscores. The header is dropped before the filter chain is
   * invoked and as such filters will not see dropped headers. The
   * "httpN.dropped_headers_with_underscores" is incremented for each dropped header.
   */
  DROP_HEADER = "DROP_HEADER",
}

export function httpProtocolOptions_HeadersWithUnderscoresActionFromJSON(
  object: any,
): HttpProtocolOptions_HeadersWithUnderscoresAction {
  switch (object) {
    case 0:
    case "ALLOW":
      return HttpProtocolOptions_HeadersWithUnderscoresAction.ALLOW;
    case 1:
    case "REJECT_REQUEST":
      return HttpProtocolOptions_HeadersWithUnderscoresAction.REJECT_REQUEST;
    case 2:
    case "DROP_HEADER":
      return HttpProtocolOptions_HeadersWithUnderscoresAction.DROP_HEADER;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum HttpProtocolOptions_HeadersWithUnderscoresAction",
      );
  }
}

export function httpProtocolOptions_HeadersWithUnderscoresActionToJSON(
  object: HttpProtocolOptions_HeadersWithUnderscoresAction,
): string {
  switch (object) {
    case HttpProtocolOptions_HeadersWithUnderscoresAction.ALLOW:
      return "ALLOW";
    case HttpProtocolOptions_HeadersWithUnderscoresAction.REJECT_REQUEST:
      return "REJECT_REQUEST";
    case HttpProtocolOptions_HeadersWithUnderscoresAction.DROP_HEADER:
      return "DROP_HEADER";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum HttpProtocolOptions_HeadersWithUnderscoresAction",
      );
  }
}

export function httpProtocolOptions_HeadersWithUnderscoresActionToNumber(
  object: HttpProtocolOptions_HeadersWithUnderscoresAction,
): number {
  switch (object) {
    case HttpProtocolOptions_HeadersWithUnderscoresAction.ALLOW:
      return 0;
    case HttpProtocolOptions_HeadersWithUnderscoresAction.REJECT_REQUEST:
      return 1;
    case HttpProtocolOptions_HeadersWithUnderscoresAction.DROP_HEADER:
      return 2;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum HttpProtocolOptions_HeadersWithUnderscoresAction",
      );
  }
}

/** [#next-free-field: 6] */
export interface Http1ProtocolOptions {
  $type: "envoy.api.v2.core.Http1ProtocolOptions";
  /**
   * Handle HTTP requests with absolute URLs in the requests. These requests
   * are generally sent by clients to forward/explicit proxies. This allows clients to configure
   * envoy as their HTTP proxy. In Unix, for example, this is typically done by setting the
   * *http_proxy* environment variable.
   */
  allow_absolute_url?:
    | boolean
    | undefined;
  /**
   * Handle incoming HTTP/1.0 and HTTP 0.9 requests.
   * This is off by default, and not fully standards compliant. There is support for pre-HTTP/1.1
   * style connect logic, dechunking, and handling lack of client host iff
   * *default_host_for_http_10* is configured.
   */
  accept_http_10?:
    | boolean
    | undefined;
  /**
   * A default host for HTTP/1.0 requests. This is highly suggested if *accept_http_10* is true as
   * Envoy does not otherwise support HTTP/1.0 without a Host header.
   * This is a no-op if *accept_http_10* is not true.
   */
  default_host_for_http_10?:
    | string
    | undefined;
  /**
   * Describes how the keys for response headers should be formatted. By default, all header keys
   * are lower cased.
   */
  header_key_format?:
    | Http1ProtocolOptions_HeaderKeyFormat
    | undefined;
  /**
   * Enables trailers for HTTP/1. By default the HTTP/1 codec drops proxied trailers.
   *
   * .. attention::
   *
   *   Note that this only happens when Envoy is chunk encoding which occurs when:
   *   - The request is HTTP/1.1.
   *   - Is neither a HEAD only request nor a HTTP Upgrade.
   *   - Not a response to a HEAD request.
   *   - The content length header is not present.
   */
  enable_trailers?: boolean | undefined;
}

export interface Http1ProtocolOptions_HeaderKeyFormat {
  $type: "envoy.api.v2.core.Http1ProtocolOptions.HeaderKeyFormat";
  header_format?:
    | //
    /**
     * Formats the header by proper casing words: the first character and any character following
     * a special character will be capitalized if it's an alpha character. For example,
     * "content-type" becomes "Content-Type", and "foo$b#$are" becomes "Foo$B#$Are".
     * Note that while this results in most headers following conventional casing, certain headers
     * are not covered. For example, the "TE" header will be formatted as "Te".
     */
    { $case: "proper_case_words"; proper_case_words: Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords }
    | undefined;
}

export interface Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords {
  $type: "envoy.api.v2.core.Http1ProtocolOptions.HeaderKeyFormat.ProperCaseWords";
}

/** [#next-free-field: 14] */
export interface Http2ProtocolOptions {
  $type: "envoy.api.v2.core.Http2ProtocolOptions";
  /**
   * `Maximum table size <https://httpwg.org/specs/rfc7541.html#rfc.section.4.2>`_
   * (in octets) that the encoder is permitted to use for the dynamic HPACK table. Valid values
   * range from 0 to 4294967295 (2^32 - 1) and defaults to 4096. 0 effectively disables header
   * compression.
   */
  hpack_table_size?:
    | number
    | undefined;
  /**
   * `Maximum concurrent streams <https://httpwg.org/specs/rfc7540.html#rfc.section.5.1.2>`_
   * allowed for peer on one HTTP/2 connection. Valid values range from 1 to 2147483647 (2^31 - 1)
   * and defaults to 2147483647.
   *
   * For upstream connections, this also limits how many streams Envoy will initiate concurrently
   * on a single connection. If the limit is reached, Envoy may queue requests or establish
   * additional connections (as allowed per circuit breaker limits).
   */
  max_concurrent_streams?:
    | number
    | undefined;
  /**
   * `Initial stream-level flow-control window
   * <https://httpwg.org/specs/rfc7540.html#rfc.section.6.9.2>`_ size. Valid values range from 65535
   * (2^16 - 1, HTTP/2 default) to 2147483647 (2^31 - 1, HTTP/2 maximum) and defaults to 268435456
   * (256 * 1024 * 1024).
   *
   * NOTE: 65535 is the initial window size from HTTP/2 spec. We only support increasing the default
   * window size now, so it's also the minimum.
   *
   * This field also acts as a soft limit on the number of bytes Envoy will buffer per-stream in the
   * HTTP/2 codec buffers. Once the buffer reaches this pointer, watermark callbacks will fire to
   * stop the flow of data to the codec buffers.
   */
  initial_stream_window_size?:
    | number
    | undefined;
  /**
   * Similar to *initial_stream_window_size*, but for connection-level flow-control
   * window. Currently, this has the same minimum/maximum/default as *initial_stream_window_size*.
   */
  initial_connection_window_size?:
    | number
    | undefined;
  /** Allows proxying Websocket and other upgrades over H2 connect. */
  allow_connect?:
    | boolean
    | undefined;
  /**
   * [#not-implemented-hide:] Hiding until envoy has full metadata support.
   * Still under implementation. DO NOT USE.
   *
   * Allows metadata. See [metadata
   * docs](https://github.com/envoyproxy/envoy/blob/main/source/docs/h2_metadata.md) for more
   * information.
   */
  allow_metadata?:
    | boolean
    | undefined;
  /**
   * Limit the number of pending outbound downstream frames of all types (frames that are waiting to
   * be written into the socket). Exceeding this limit triggers flood mitigation and connection is
   * terminated. The ``http2.outbound_flood`` stat tracks the number of terminated connections due
   * to flood mitigation. The default limit is 10000.
   * [#comment:TODO: implement same limits for upstream outbound frames as well.]
   */
  max_outbound_frames?:
    | number
    | undefined;
  /**
   * Limit the number of pending outbound downstream frames of types PING, SETTINGS and RST_STREAM,
   * preventing high memory utilization when receiving continuous stream of these frames. Exceeding
   * this limit triggers flood mitigation and connection is terminated. The
   * ``http2.outbound_control_flood`` stat tracks the number of terminated connections due to flood
   * mitigation. The default limit is 1000.
   * [#comment:TODO: implement same limits for upstream outbound frames as well.]
   */
  max_outbound_control_frames?:
    | number
    | undefined;
  /**
   * Limit the number of consecutive inbound frames of types HEADERS, CONTINUATION and DATA with an
   * empty payload and no end stream flag. Those frames have no legitimate use and are abusive, but
   * might be a result of a broken HTTP/2 implementation. The `http2.inbound_empty_frames_flood``
   * stat tracks the number of connections terminated due to flood mitigation.
   * Setting this to 0 will terminate connection upon receiving first frame with an empty payload
   * and no end stream flag. The default limit is 1.
   * [#comment:TODO: implement same limits for upstream inbound frames as well.]
   */
  max_consecutive_inbound_frames_with_empty_payload?:
    | number
    | undefined;
  /**
   * Limit the number of inbound PRIORITY frames allowed per each opened stream. If the number
   * of PRIORITY frames received over the lifetime of connection exceeds the value calculated
   * using this formula::
   *
   *     max_inbound_priority_frames_per_stream * (1 + inbound_streams)
   *
   * the connection is terminated. The ``http2.inbound_priority_frames_flood`` stat tracks
   * the number of connections terminated due to flood mitigation. The default limit is 100.
   * [#comment:TODO: implement same limits for upstream inbound frames as well.]
   */
  max_inbound_priority_frames_per_stream?:
    | number
    | undefined;
  /**
   * Limit the number of inbound WINDOW_UPDATE frames allowed per DATA frame sent. If the number
   * of WINDOW_UPDATE frames received over the lifetime of connection exceeds the value calculated
   * using this formula::
   *
   *     1 + 2 * (inbound_streams +
   *              max_inbound_window_update_frames_per_data_frame_sent * outbound_data_frames)
   *
   * the connection is terminated. The ``http2.inbound_priority_frames_flood`` stat tracks
   * the number of connections terminated due to flood mitigation. The default limit is 10.
   * Setting this to 1 should be enough to support HTTP/2 implementations with basic flow control,
   * but more complex implementations that try to estimate available bandwidth require at least 2.
   * [#comment:TODO: implement same limits for upstream inbound frames as well.]
   */
  max_inbound_window_update_frames_per_data_frame_sent?:
    | number
    | undefined;
  /**
   * Allows invalid HTTP messaging and headers. When this option is disabled (default), then
   * the whole HTTP/2 connection is terminated upon receiving invalid HEADERS frame. However,
   * when this option is enabled, only the offending stream is terminated.
   *
   * See `RFC7540, sec. 8.1 <https://tools.ietf.org/html/rfc7540#section-8.1>`_ for details.
   */
  stream_error_on_invalid_http_messaging?:
    | boolean
    | undefined;
  /**
   * [#not-implemented-hide:]
   * Specifies SETTINGS frame parameters to be sent to the peer, with two exceptions:
   *
   * 1. SETTINGS_ENABLE_PUSH (0x2) is not configurable as HTTP/2 server push is not supported by
   * Envoy.
   *
   * 2. SETTINGS_ENABLE_CONNECT_PROTOCOL (0x8) is only configurable through the named field
   * 'allow_connect'.
   *
   * Note that custom parameters specified through this field can not also be set in the
   * corresponding named parameters:
   *
   * .. code-block:: text
   *
   *   ID    Field Name
   *   ----------------
   *   0x1   hpack_table_size
   *   0x3   max_concurrent_streams
   *   0x4   initial_stream_window_size
   *
   * Collisions will trigger config validation failure on load/update. Likewise, inconsistencies
   * between custom parameters with the same identifier will trigger a failure.
   *
   * See `IANA HTTP/2 Settings
   * <https://www.iana.org/assignments/http2-parameters/http2-parameters.xhtml#settings>`_ for
   * standardized identifiers.
   */
  custom_settings_parameters?: Http2ProtocolOptions_SettingsParameter[] | undefined;
}

/**
 * Defines a parameter to be sent in the SETTINGS frame.
 * See `RFC7540, sec. 6.5.1 <https://tools.ietf.org/html/rfc7540#section-6.5.1>`_ for details.
 */
export interface Http2ProtocolOptions_SettingsParameter {
  $type: "envoy.api.v2.core.Http2ProtocolOptions.SettingsParameter";
  /** The 16 bit parameter identifier. */
  identifier?:
    | number
    | undefined;
  /** The 32 bit parameter value. */
  value?: number | undefined;
}

/** [#not-implemented-hide:] */
export interface GrpcProtocolOptions {
  $type: "envoy.api.v2.core.GrpcProtocolOptions";
  http2_protocol_options?: Http2ProtocolOptions | undefined;
}

function createBaseTcpProtocolOptions(): TcpProtocolOptions {
  return { $type: "envoy.api.v2.core.TcpProtocolOptions" };
}

export const TcpProtocolOptions: MessageFns<TcpProtocolOptions, "envoy.api.v2.core.TcpProtocolOptions"> = {
  $type: "envoy.api.v2.core.TcpProtocolOptions" as const,

  encode(_: TcpProtocolOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TcpProtocolOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTcpProtocolOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): TcpProtocolOptions {
    return { $type: TcpProtocolOptions.$type };
  },

  toJSON(_: TcpProtocolOptions): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<TcpProtocolOptions>, I>>(base?: I): TcpProtocolOptions {
    return TcpProtocolOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TcpProtocolOptions>, I>>(_: I): TcpProtocolOptions {
    const message = createBaseTcpProtocolOptions();
    return message;
  },
};

messageTypeRegistry.set(TcpProtocolOptions.$type, TcpProtocolOptions);

function createBaseUpstreamHttpProtocolOptions(): UpstreamHttpProtocolOptions {
  return { $type: "envoy.api.v2.core.UpstreamHttpProtocolOptions" };
}

export const UpstreamHttpProtocolOptions: MessageFns<
  UpstreamHttpProtocolOptions,
  "envoy.api.v2.core.UpstreamHttpProtocolOptions"
> = {
  $type: "envoy.api.v2.core.UpstreamHttpProtocolOptions" as const,

  encode(message: UpstreamHttpProtocolOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.auto_sni !== undefined && message.auto_sni !== false) {
      writer.uint32(8).bool(message.auto_sni);
    }
    if (message.auto_san_validation !== undefined && message.auto_san_validation !== false) {
      writer.uint32(16).bool(message.auto_san_validation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpstreamHttpProtocolOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpstreamHttpProtocolOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.auto_sni = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.auto_san_validation = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpstreamHttpProtocolOptions {
    return {
      $type: UpstreamHttpProtocolOptions.$type,
      auto_sni: isSet(object.auto_sni) ? globalThis.Boolean(object.auto_sni) : undefined,
      auto_san_validation: isSet(object.auto_san_validation)
        ? globalThis.Boolean(object.auto_san_validation)
        : undefined,
    };
  },

  toJSON(message: UpstreamHttpProtocolOptions): unknown {
    const obj: any = {};
    if (message.auto_sni !== undefined) {
      obj.auto_sni = message.auto_sni;
    }
    if (message.auto_san_validation !== undefined) {
      obj.auto_san_validation = message.auto_san_validation;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpstreamHttpProtocolOptions>, I>>(base?: I): UpstreamHttpProtocolOptions {
    return UpstreamHttpProtocolOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpstreamHttpProtocolOptions>, I>>(object: I): UpstreamHttpProtocolOptions {
    const message = createBaseUpstreamHttpProtocolOptions();
    message.auto_sni = object.auto_sni ?? undefined;
    message.auto_san_validation = object.auto_san_validation ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(UpstreamHttpProtocolOptions.$type, UpstreamHttpProtocolOptions);

function createBaseHttpProtocolOptions(): HttpProtocolOptions {
  return { $type: "envoy.api.v2.core.HttpProtocolOptions" };
}

export const HttpProtocolOptions: MessageFns<HttpProtocolOptions, "envoy.api.v2.core.HttpProtocolOptions"> = {
  $type: "envoy.api.v2.core.HttpProtocolOptions" as const,

  encode(message: HttpProtocolOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.idle_timeout !== undefined) {
      Duration.encode(message.idle_timeout, writer.uint32(10).fork()).join();
    }
    if (message.max_connection_duration !== undefined) {
      Duration.encode(message.max_connection_duration, writer.uint32(26).fork()).join();
    }
    if (message.max_headers_count !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.max_headers_count! },
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.max_stream_duration !== undefined) {
      Duration.encode(message.max_stream_duration, writer.uint32(34).fork()).join();
    }
    if (
      message.headers_with_underscores_action !== undefined &&
      message.headers_with_underscores_action !== HttpProtocolOptions_HeadersWithUnderscoresAction.ALLOW
    ) {
      writer.uint32(40).int32(
        httpProtocolOptions_HeadersWithUnderscoresActionToNumber(message.headers_with_underscores_action),
      );
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpProtocolOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpProtocolOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.idle_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.max_connection_duration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.max_headers_count = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.max_stream_duration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.headers_with_underscores_action = httpProtocolOptions_HeadersWithUnderscoresActionFromJSON(
            reader.int32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpProtocolOptions {
    return {
      $type: HttpProtocolOptions.$type,
      idle_timeout: isSet(object.idle_timeout) ? Duration.fromJSON(object.idle_timeout) : undefined,
      max_connection_duration: isSet(object.max_connection_duration)
        ? Duration.fromJSON(object.max_connection_duration)
        : undefined,
      max_headers_count: isSet(object.max_headers_count) ? Number(object.max_headers_count) : undefined,
      max_stream_duration: isSet(object.max_stream_duration)
        ? Duration.fromJSON(object.max_stream_duration)
        : undefined,
      headers_with_underscores_action: isSet(object.headers_with_underscores_action)
        ? httpProtocolOptions_HeadersWithUnderscoresActionFromJSON(object.headers_with_underscores_action)
        : undefined,
    };
  },

  toJSON(message: HttpProtocolOptions): unknown {
    const obj: any = {};
    if (message.idle_timeout !== undefined) {
      obj.idle_timeout = Duration.toJSON(message.idle_timeout);
    }
    if (message.max_connection_duration !== undefined) {
      obj.max_connection_duration = Duration.toJSON(message.max_connection_duration);
    }
    if (message.max_headers_count !== undefined) {
      obj.max_headers_count = message.max_headers_count;
    }
    if (message.max_stream_duration !== undefined) {
      obj.max_stream_duration = Duration.toJSON(message.max_stream_duration);
    }
    if (message.headers_with_underscores_action !== undefined) {
      obj.headers_with_underscores_action = httpProtocolOptions_HeadersWithUnderscoresActionToJSON(
        message.headers_with_underscores_action,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpProtocolOptions>, I>>(base?: I): HttpProtocolOptions {
    return HttpProtocolOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpProtocolOptions>, I>>(object: I): HttpProtocolOptions {
    const message = createBaseHttpProtocolOptions();
    message.idle_timeout = (object.idle_timeout !== undefined && object.idle_timeout !== null)
      ? Duration.fromPartial(object.idle_timeout)
      : undefined;
    message.max_connection_duration =
      (object.max_connection_duration !== undefined && object.max_connection_duration !== null)
        ? Duration.fromPartial(object.max_connection_duration)
        : undefined;
    message.max_headers_count = object.max_headers_count ?? undefined;
    message.max_stream_duration = (object.max_stream_duration !== undefined && object.max_stream_duration !== null)
      ? Duration.fromPartial(object.max_stream_duration)
      : undefined;
    message.headers_with_underscores_action = object.headers_with_underscores_action ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(HttpProtocolOptions.$type, HttpProtocolOptions);

function createBaseHttp1ProtocolOptions(): Http1ProtocolOptions {
  return { $type: "envoy.api.v2.core.Http1ProtocolOptions" };
}

export const Http1ProtocolOptions: MessageFns<Http1ProtocolOptions, "envoy.api.v2.core.Http1ProtocolOptions"> = {
  $type: "envoy.api.v2.core.Http1ProtocolOptions" as const,

  encode(message: Http1ProtocolOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.allow_absolute_url !== undefined) {
      BoolValue.encode(
        { $type: "google.protobuf.BoolValue", value: message.allow_absolute_url! },
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.accept_http_10 !== undefined && message.accept_http_10 !== false) {
      writer.uint32(16).bool(message.accept_http_10);
    }
    if (message.default_host_for_http_10 !== undefined && message.default_host_for_http_10 !== "") {
      writer.uint32(26).string(message.default_host_for_http_10);
    }
    if (message.header_key_format !== undefined) {
      Http1ProtocolOptions_HeaderKeyFormat.encode(message.header_key_format, writer.uint32(34).fork()).join();
    }
    if (message.enable_trailers !== undefined && message.enable_trailers !== false) {
      writer.uint32(40).bool(message.enable_trailers);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Http1ProtocolOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttp1ProtocolOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.allow_absolute_url = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.accept_http_10 = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.default_host_for_http_10 = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.header_key_format = Http1ProtocolOptions_HeaderKeyFormat.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.enable_trailers = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Http1ProtocolOptions {
    return {
      $type: Http1ProtocolOptions.$type,
      allow_absolute_url: isSet(object.allow_absolute_url) ? Boolean(object.allow_absolute_url) : undefined,
      accept_http_10: isSet(object.accept_http_10) ? globalThis.Boolean(object.accept_http_10) : undefined,
      default_host_for_http_10: isSet(object.default_host_for_http_10)
        ? globalThis.String(object.default_host_for_http_10)
        : undefined,
      header_key_format: isSet(object.header_key_format)
        ? Http1ProtocolOptions_HeaderKeyFormat.fromJSON(object.header_key_format)
        : undefined,
      enable_trailers: isSet(object.enable_trailers) ? globalThis.Boolean(object.enable_trailers) : undefined,
    };
  },

  toJSON(message: Http1ProtocolOptions): unknown {
    const obj: any = {};
    if (message.allow_absolute_url !== undefined) {
      obj.allow_absolute_url = message.allow_absolute_url;
    }
    if (message.accept_http_10 !== undefined) {
      obj.accept_http_10 = message.accept_http_10;
    }
    if (message.default_host_for_http_10 !== undefined) {
      obj.default_host_for_http_10 = message.default_host_for_http_10;
    }
    if (message.header_key_format !== undefined) {
      obj.header_key_format = Http1ProtocolOptions_HeaderKeyFormat.toJSON(message.header_key_format);
    }
    if (message.enable_trailers !== undefined) {
      obj.enable_trailers = message.enable_trailers;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Http1ProtocolOptions>, I>>(base?: I): Http1ProtocolOptions {
    return Http1ProtocolOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Http1ProtocolOptions>, I>>(object: I): Http1ProtocolOptions {
    const message = createBaseHttp1ProtocolOptions();
    message.allow_absolute_url = object.allow_absolute_url ?? undefined;
    message.accept_http_10 = object.accept_http_10 ?? undefined;
    message.default_host_for_http_10 = object.default_host_for_http_10 ?? undefined;
    message.header_key_format = (object.header_key_format !== undefined && object.header_key_format !== null)
      ? Http1ProtocolOptions_HeaderKeyFormat.fromPartial(object.header_key_format)
      : undefined;
    message.enable_trailers = object.enable_trailers ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Http1ProtocolOptions.$type, Http1ProtocolOptions);

function createBaseHttp1ProtocolOptions_HeaderKeyFormat(): Http1ProtocolOptions_HeaderKeyFormat {
  return { $type: "envoy.api.v2.core.Http1ProtocolOptions.HeaderKeyFormat", header_format: undefined };
}

export const Http1ProtocolOptions_HeaderKeyFormat: MessageFns<
  Http1ProtocolOptions_HeaderKeyFormat,
  "envoy.api.v2.core.Http1ProtocolOptions.HeaderKeyFormat"
> = {
  $type: "envoy.api.v2.core.Http1ProtocolOptions.HeaderKeyFormat" as const,

  encode(message: Http1ProtocolOptions_HeaderKeyFormat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.header_format?.$case) {
      case "proper_case_words":
        Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords.encode(
          message.header_format.proper_case_words,
          writer.uint32(10).fork(),
        ).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Http1ProtocolOptions_HeaderKeyFormat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttp1ProtocolOptions_HeaderKeyFormat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header_format = {
            $case: "proper_case_words",
            proper_case_words: Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Http1ProtocolOptions_HeaderKeyFormat {
    return {
      $type: Http1ProtocolOptions_HeaderKeyFormat.$type,
      header_format: isSet(object.proper_case_words)
        ? {
          $case: "proper_case_words",
          proper_case_words: Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords.fromJSON(object.proper_case_words),
        }
        : undefined,
    };
  },

  toJSON(message: Http1ProtocolOptions_HeaderKeyFormat): unknown {
    const obj: any = {};
    if (message.header_format?.$case === "proper_case_words") {
      obj.proper_case_words = Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords.toJSON(
        message.header_format.proper_case_words,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Http1ProtocolOptions_HeaderKeyFormat>, I>>(
    base?: I,
  ): Http1ProtocolOptions_HeaderKeyFormat {
    return Http1ProtocolOptions_HeaderKeyFormat.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Http1ProtocolOptions_HeaderKeyFormat>, I>>(
    object: I,
  ): Http1ProtocolOptions_HeaderKeyFormat {
    const message = createBaseHttp1ProtocolOptions_HeaderKeyFormat();
    if (
      object.header_format?.$case === "proper_case_words" &&
      object.header_format?.proper_case_words !== undefined &&
      object.header_format?.proper_case_words !== null
    ) {
      message.header_format = {
        $case: "proper_case_words",
        proper_case_words: Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords.fromPartial(
          object.header_format.proper_case_words,
        ),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(Http1ProtocolOptions_HeaderKeyFormat.$type, Http1ProtocolOptions_HeaderKeyFormat);

function createBaseHttp1ProtocolOptions_HeaderKeyFormat_ProperCaseWords(): Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords {
  return { $type: "envoy.api.v2.core.Http1ProtocolOptions.HeaderKeyFormat.ProperCaseWords" };
}

export const Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords: MessageFns<
  Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords,
  "envoy.api.v2.core.Http1ProtocolOptions.HeaderKeyFormat.ProperCaseWords"
> = {
  $type: "envoy.api.v2.core.Http1ProtocolOptions.HeaderKeyFormat.ProperCaseWords" as const,

  encode(
    _: Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttp1ProtocolOptions_HeaderKeyFormat_ProperCaseWords();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords {
    return { $type: Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords.$type };
  },

  toJSON(_: Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords>, I>>(
    base?: I,
  ): Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords {
    return Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords>, I>>(
    _: I,
  ): Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords {
    const message = createBaseHttp1ProtocolOptions_HeaderKeyFormat_ProperCaseWords();
    return message;
  },
};

messageTypeRegistry.set(
  Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords.$type,
  Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords,
);

function createBaseHttp2ProtocolOptions(): Http2ProtocolOptions {
  return { $type: "envoy.api.v2.core.Http2ProtocolOptions" };
}

export const Http2ProtocolOptions: MessageFns<Http2ProtocolOptions, "envoy.api.v2.core.Http2ProtocolOptions"> = {
  $type: "envoy.api.v2.core.Http2ProtocolOptions" as const,

  encode(message: Http2ProtocolOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hpack_table_size !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.hpack_table_size! },
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.max_concurrent_streams !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.max_concurrent_streams! },
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.initial_stream_window_size !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.initial_stream_window_size! },
        writer.uint32(26).fork(),
      ).join();
    }
    if (message.initial_connection_window_size !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.initial_connection_window_size! },
        writer.uint32(34).fork(),
      ).join();
    }
    if (message.allow_connect !== undefined && message.allow_connect !== false) {
      writer.uint32(40).bool(message.allow_connect);
    }
    if (message.allow_metadata !== undefined && message.allow_metadata !== false) {
      writer.uint32(48).bool(message.allow_metadata);
    }
    if (message.max_outbound_frames !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.max_outbound_frames! },
        writer.uint32(58).fork(),
      ).join();
    }
    if (message.max_outbound_control_frames !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.max_outbound_control_frames! },
        writer.uint32(66).fork(),
      ).join();
    }
    if (message.max_consecutive_inbound_frames_with_empty_payload !== undefined) {
      UInt32Value.encode({
        $type: "google.protobuf.UInt32Value",
        value: message.max_consecutive_inbound_frames_with_empty_payload!,
      }, writer.uint32(74).fork()).join();
    }
    if (message.max_inbound_priority_frames_per_stream !== undefined) {
      UInt32Value.encode({
        $type: "google.protobuf.UInt32Value",
        value: message.max_inbound_priority_frames_per_stream!,
      }, writer.uint32(82).fork()).join();
    }
    if (message.max_inbound_window_update_frames_per_data_frame_sent !== undefined) {
      UInt32Value.encode({
        $type: "google.protobuf.UInt32Value",
        value: message.max_inbound_window_update_frames_per_data_frame_sent!,
      }, writer.uint32(90).fork()).join();
    }
    if (
      message.stream_error_on_invalid_http_messaging !== undefined &&
      message.stream_error_on_invalid_http_messaging !== false
    ) {
      writer.uint32(96).bool(message.stream_error_on_invalid_http_messaging);
    }
    if (message.custom_settings_parameters !== undefined && message.custom_settings_parameters.length !== 0) {
      for (const v of message.custom_settings_parameters) {
        Http2ProtocolOptions_SettingsParameter.encode(v!, writer.uint32(106).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Http2ProtocolOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttp2ProtocolOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hpack_table_size = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.max_concurrent_streams = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.initial_stream_window_size = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.initial_connection_window_size = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.allow_connect = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.allow_metadata = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.max_outbound_frames = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.max_outbound_control_frames = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.max_consecutive_inbound_frames_with_empty_payload = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.max_inbound_priority_frames_per_stream = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.max_inbound_window_update_frames_per_data_frame_sent =
            UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.stream_error_on_invalid_http_messaging = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          if (message.custom_settings_parameters === undefined) {
            message.custom_settings_parameters = [];
          }
          const el = Http2ProtocolOptions_SettingsParameter.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.custom_settings_parameters!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Http2ProtocolOptions {
    return {
      $type: Http2ProtocolOptions.$type,
      hpack_table_size: isSet(object.hpack_table_size) ? Number(object.hpack_table_size) : undefined,
      max_concurrent_streams: isSet(object.max_concurrent_streams) ? Number(object.max_concurrent_streams) : undefined,
      initial_stream_window_size: isSet(object.initial_stream_window_size)
        ? Number(object.initial_stream_window_size)
        : undefined,
      initial_connection_window_size: isSet(object.initial_connection_window_size)
        ? Number(object.initial_connection_window_size)
        : undefined,
      allow_connect: isSet(object.allow_connect) ? globalThis.Boolean(object.allow_connect) : undefined,
      allow_metadata: isSet(object.allow_metadata) ? globalThis.Boolean(object.allow_metadata) : undefined,
      max_outbound_frames: isSet(object.max_outbound_frames) ? Number(object.max_outbound_frames) : undefined,
      max_outbound_control_frames: isSet(object.max_outbound_control_frames)
        ? Number(object.max_outbound_control_frames)
        : undefined,
      max_consecutive_inbound_frames_with_empty_payload: isSet(object.max_consecutive_inbound_frames_with_empty_payload)
        ? Number(object.max_consecutive_inbound_frames_with_empty_payload)
        : undefined,
      max_inbound_priority_frames_per_stream: isSet(object.max_inbound_priority_frames_per_stream)
        ? Number(object.max_inbound_priority_frames_per_stream)
        : undefined,
      max_inbound_window_update_frames_per_data_frame_sent:
        isSet(object.max_inbound_window_update_frames_per_data_frame_sent)
          ? Number(object.max_inbound_window_update_frames_per_data_frame_sent)
          : undefined,
      stream_error_on_invalid_http_messaging: isSet(object.stream_error_on_invalid_http_messaging)
        ? globalThis.Boolean(object.stream_error_on_invalid_http_messaging)
        : undefined,
      custom_settings_parameters: globalThis.Array.isArray(object?.custom_settings_parameters)
        ? object.custom_settings_parameters.map((e: any) => Http2ProtocolOptions_SettingsParameter.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: Http2ProtocolOptions): unknown {
    const obj: any = {};
    if (message.hpack_table_size !== undefined) {
      obj.hpack_table_size = message.hpack_table_size;
    }
    if (message.max_concurrent_streams !== undefined) {
      obj.max_concurrent_streams = message.max_concurrent_streams;
    }
    if (message.initial_stream_window_size !== undefined) {
      obj.initial_stream_window_size = message.initial_stream_window_size;
    }
    if (message.initial_connection_window_size !== undefined) {
      obj.initial_connection_window_size = message.initial_connection_window_size;
    }
    if (message.allow_connect !== undefined) {
      obj.allow_connect = message.allow_connect;
    }
    if (message.allow_metadata !== undefined) {
      obj.allow_metadata = message.allow_metadata;
    }
    if (message.max_outbound_frames !== undefined) {
      obj.max_outbound_frames = message.max_outbound_frames;
    }
    if (message.max_outbound_control_frames !== undefined) {
      obj.max_outbound_control_frames = message.max_outbound_control_frames;
    }
    if (message.max_consecutive_inbound_frames_with_empty_payload !== undefined) {
      obj.max_consecutive_inbound_frames_with_empty_payload = message.max_consecutive_inbound_frames_with_empty_payload;
    }
    if (message.max_inbound_priority_frames_per_stream !== undefined) {
      obj.max_inbound_priority_frames_per_stream = message.max_inbound_priority_frames_per_stream;
    }
    if (message.max_inbound_window_update_frames_per_data_frame_sent !== undefined) {
      obj.max_inbound_window_update_frames_per_data_frame_sent =
        message.max_inbound_window_update_frames_per_data_frame_sent;
    }
    if (message.stream_error_on_invalid_http_messaging !== undefined) {
      obj.stream_error_on_invalid_http_messaging = message.stream_error_on_invalid_http_messaging;
    }
    if (message.custom_settings_parameters?.length) {
      obj.custom_settings_parameters = message.custom_settings_parameters.map((e) =>
        Http2ProtocolOptions_SettingsParameter.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Http2ProtocolOptions>, I>>(base?: I): Http2ProtocolOptions {
    return Http2ProtocolOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Http2ProtocolOptions>, I>>(object: I): Http2ProtocolOptions {
    const message = createBaseHttp2ProtocolOptions();
    message.hpack_table_size = object.hpack_table_size ?? undefined;
    message.max_concurrent_streams = object.max_concurrent_streams ?? undefined;
    message.initial_stream_window_size = object.initial_stream_window_size ?? undefined;
    message.initial_connection_window_size = object.initial_connection_window_size ?? undefined;
    message.allow_connect = object.allow_connect ?? undefined;
    message.allow_metadata = object.allow_metadata ?? undefined;
    message.max_outbound_frames = object.max_outbound_frames ?? undefined;
    message.max_outbound_control_frames = object.max_outbound_control_frames ?? undefined;
    message.max_consecutive_inbound_frames_with_empty_payload =
      object.max_consecutive_inbound_frames_with_empty_payload ?? undefined;
    message.max_inbound_priority_frames_per_stream = object.max_inbound_priority_frames_per_stream ?? undefined;
    message.max_inbound_window_update_frames_per_data_frame_sent =
      object.max_inbound_window_update_frames_per_data_frame_sent ?? undefined;
    message.stream_error_on_invalid_http_messaging = object.stream_error_on_invalid_http_messaging ?? undefined;
    message.custom_settings_parameters =
      object.custom_settings_parameters?.map((e) => Http2ProtocolOptions_SettingsParameter.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(Http2ProtocolOptions.$type, Http2ProtocolOptions);

function createBaseHttp2ProtocolOptions_SettingsParameter(): Http2ProtocolOptions_SettingsParameter {
  return { $type: "envoy.api.v2.core.Http2ProtocolOptions.SettingsParameter" };
}

export const Http2ProtocolOptions_SettingsParameter: MessageFns<
  Http2ProtocolOptions_SettingsParameter,
  "envoy.api.v2.core.Http2ProtocolOptions.SettingsParameter"
> = {
  $type: "envoy.api.v2.core.Http2ProtocolOptions.SettingsParameter" as const,

  encode(message: Http2ProtocolOptions_SettingsParameter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.identifier !== undefined) {
      UInt32Value.encode({ $type: "google.protobuf.UInt32Value", value: message.identifier! }, writer.uint32(10).fork())
        .join();
    }
    if (message.value !== undefined) {
      UInt32Value.encode({ $type: "google.protobuf.UInt32Value", value: message.value! }, writer.uint32(18).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Http2ProtocolOptions_SettingsParameter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttp2ProtocolOptions_SettingsParameter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.identifier = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Http2ProtocolOptions_SettingsParameter {
    return {
      $type: Http2ProtocolOptions_SettingsParameter.$type,
      identifier: isSet(object.identifier) ? Number(object.identifier) : undefined,
      value: isSet(object.value) ? Number(object.value) : undefined,
    };
  },

  toJSON(message: Http2ProtocolOptions_SettingsParameter): unknown {
    const obj: any = {};
    if (message.identifier !== undefined) {
      obj.identifier = message.identifier;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Http2ProtocolOptions_SettingsParameter>, I>>(
    base?: I,
  ): Http2ProtocolOptions_SettingsParameter {
    return Http2ProtocolOptions_SettingsParameter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Http2ProtocolOptions_SettingsParameter>, I>>(
    object: I,
  ): Http2ProtocolOptions_SettingsParameter {
    const message = createBaseHttp2ProtocolOptions_SettingsParameter();
    message.identifier = object.identifier ?? undefined;
    message.value = object.value ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Http2ProtocolOptions_SettingsParameter.$type, Http2ProtocolOptions_SettingsParameter);

function createBaseGrpcProtocolOptions(): GrpcProtocolOptions {
  return { $type: "envoy.api.v2.core.GrpcProtocolOptions" };
}

export const GrpcProtocolOptions: MessageFns<GrpcProtocolOptions, "envoy.api.v2.core.GrpcProtocolOptions"> = {
  $type: "envoy.api.v2.core.GrpcProtocolOptions" as const,

  encode(message: GrpcProtocolOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.http2_protocol_options !== undefined) {
      Http2ProtocolOptions.encode(message.http2_protocol_options, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrpcProtocolOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrpcProtocolOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.http2_protocol_options = Http2ProtocolOptions.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrpcProtocolOptions {
    return {
      $type: GrpcProtocolOptions.$type,
      http2_protocol_options: isSet(object.http2_protocol_options)
        ? Http2ProtocolOptions.fromJSON(object.http2_protocol_options)
        : undefined,
    };
  },

  toJSON(message: GrpcProtocolOptions): unknown {
    const obj: any = {};
    if (message.http2_protocol_options !== undefined) {
      obj.http2_protocol_options = Http2ProtocolOptions.toJSON(message.http2_protocol_options);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GrpcProtocolOptions>, I>>(base?: I): GrpcProtocolOptions {
    return GrpcProtocolOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GrpcProtocolOptions>, I>>(object: I): GrpcProtocolOptions {
    const message = createBaseGrpcProtocolOptions();
    message.http2_protocol_options =
      (object.http2_protocol_options !== undefined && object.http2_protocol_options !== null)
        ? Http2ProtocolOptions.fromPartial(object.http2_protocol_options)
        : undefined;
    return message;
  },
};

messageTypeRegistry.set(GrpcProtocolOptions.$type, GrpcProtocolOptions);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
