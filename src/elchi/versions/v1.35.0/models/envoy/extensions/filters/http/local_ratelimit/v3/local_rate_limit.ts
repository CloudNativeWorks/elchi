// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/filters/http/local_ratelimit/v3/local_rate_limit.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { BoolValue, UInt32Value } from "../../../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../../../typeRegistry";
import { HeaderValueOption, RuntimeFractionalPercent } from "../../../../../config/core/v3/base";
import { RateLimit } from "../../../../../config/route/v3/route_components";
import { HttpStatus } from "../../../../../type/v3/http_status";
import { TokenBucket } from "../../../../../type/v3/token_bucket";
import {
  LocalClusterRateLimit,
  LocalRateLimitDescriptor,
  VhRateLimitsOptions,
  vhRateLimitsOptionsFromJSON,
  vhRateLimitsOptionsToJSON,
  vhRateLimitsOptionsToNumber,
  XRateLimitHeadersRFCVersion,
  xRateLimitHeadersRFCVersionFromJSON,
  xRateLimitHeadersRFCVersionToJSON,
  xRateLimitHeadersRFCVersionToNumber,
} from "../../../../common/ratelimit/v3/ratelimit";

export const protobufPackage = "envoy.extensions.filters.http.local_ratelimit.v3";

/** [#next-free-field: 19] */
export interface LocalRateLimit {
  $type: "envoy.extensions.filters.http.local_ratelimit.v3.LocalRateLimit";
  /** The human readable prefix to use when emitting stats. */
  stat_prefix?:
    | string
    | undefined;
  /**
   * This field allows for a custom HTTP response status code to the downstream client when
   * the request has been rate limited.
   * Defaults to 429 (TooManyRequests).
   *
   * .. note::
   *   If this is set to < 400, 429 will be used instead.
   */
  status?:
    | HttpStatus
    | undefined;
  /**
   * The token bucket configuration to use for rate limiting requests that are processed by this
   * filter. Each request processed by the filter consumes a single token. If the token is available,
   * the request will be allowed. If no tokens are available, the request will receive the configured
   * rate limit status.
   *
   * .. note::
   *   It's fine for the token bucket to be unset for the global configuration since the rate limit
   *   can be applied at a the virtual host or route level. Thus, the token bucket must be set
   *   for the per route configuration otherwise the config will be rejected.
   *
   * .. note::
   *   When using per route configuration, the bucket becomes unique to that route.
   *
   * .. note::
   *   In the current implementation the token bucket's :ref:`fill_interval
   *   <envoy_v3_api_field_type.v3.TokenBucket.fill_interval>` must be >= 50ms to avoid too aggressive
   *   refills.
   */
  token_bucket?:
    | TokenBucket
    | undefined;
  /**
   * If set, this will enable -- but not necessarily enforce -- the rate limit for the given
   * fraction of requests.
   * Defaults to 0% of requests for safety.
   */
  filter_enabled?:
    | RuntimeFractionalPercent
    | undefined;
  /**
   * If set, this will enforce the rate limit decisions for the given fraction of requests.
   *
   * Note: this only applies to the fraction of enabled requests.
   *
   * Defaults to 0% of requests for safety.
   */
  filter_enforced?:
    | RuntimeFractionalPercent
    | undefined;
  /**
   * Specifies a list of HTTP headers that should be added to each request that
   * has been rate limited and is also forwarded upstream. This can only occur when the
   * filter is enabled but not enforced.
   */
  request_headers_to_add_when_not_enforced?:
    | HeaderValueOption[]
    | undefined;
  /**
   * Specifies a list of HTTP headers that should be added to each response for requests that
   * have been rate limited. This occurs when the filter is enabled and fully enforced.
   */
  response_headers_to_add?:
    | HeaderValueOption[]
    | undefined;
  /**
   * The rate limit descriptor list to use in the local rate limit to override
   * on. The rate limit descriptor is selected by the first full match from the
   * request descriptors.
   *
   * Example on how to use :ref:`this <config_http_filters_local_rate_limit_descriptors>`.
   *
   * .. note::
   *
   *   In the current implementation the descriptor's token bucket :ref:`fill_interval
   *   <envoy_v3_api_field_type.v3.TokenBucket.fill_interval>` must be a multiple
   *   global :ref:`token bucket's<envoy_v3_api_field_extensions.filters.http.local_ratelimit.v3.LocalRateLimit.token_bucket>` fill interval.
   *
   *   The descriptors must match verbatim for rate limiting to apply. There is no partial
   *   match by a subset of descriptor entries in the current implementation.
   */
  descriptors?:
    | LocalRateLimitDescriptor[]
    | undefined;
  /**
   * Specifies the rate limit configurations to be applied with the same
   * stage number. If not set, the default stage number is 0.
   *
   * .. note::
   *
   *  The filter supports a range of 0 - 10 inclusively for stage numbers.
   */
  stage?:
    | number
    | undefined;
  /**
   * Specifies the scope of the rate limiter's token bucket.
   * If set to false, the token bucket is shared across all worker threads,
   * thus the rate limits are applied per Envoy process.
   * If set to true, a token bucket is allocated for each connection.
   * Thus the rate limits are applied per connection thereby allowing
   * one to rate limit requests on a per connection basis.
   * If unspecified, the default value is false.
   */
  local_rate_limit_per_downstream_connection?:
    | boolean
    | undefined;
  /**
   * Enables the local cluster level rate limiting, iff this is set explicitly. For example,
   * given an Envoy gateway that contains N Envoy instances and a rate limit rule X tokens
   * per second. If this is set, the total rate limit of whole gateway will always be X tokens
   * per second regardless of how N changes. If this is not set, the total rate limit of whole
   * gateway will be N * X tokens per second.
   *
   * .. note::
   *   This should never be set if the ``local_rate_limit_per_downstream_connection`` is set to
   *   true. Because if per connection rate limiting is enabled, we assume that the token buckets
   *   should never be shared across Envoy instances.
   *
   * .. note::
   *   This only works when the :ref:`local cluster name
   *   <envoy_v3_api_field_config.bootstrap.v3.ClusterManager.local_cluster_name>` is set and
   *   the related cluster is defined in the bootstrap configuration.
   */
  local_cluster_rate_limit?:
    | LocalClusterRateLimit
    | undefined;
  /**
   * Defines the standard version to use for X-RateLimit headers emitted by the filter.
   *
   * * ``X-RateLimit-Limit`` - indicates the request-quota associated to the
   *   client in the current time-window followed by the description of the
   *   quota policy.
   * * ``X-RateLimit-Remaining`` - indicates the remaining requests in the
   *   current time-window.
   * * ``X-RateLimit-Reset`` - indicates the number of seconds until reset of
   *   the current time-window.
   *
   * In case rate limiting policy specifies more then one time window, the values
   * above represent the window that is closest to reaching its limit.
   *
   * For more information about the headers specification see selected version of
   * the `draft RFC <https://tools.ietf.org/id/draft-polli-ratelimit-headers-03.html>`_.
   *
   * Disabled by default.
   */
  enable_x_ratelimit_headers?:
    | XRateLimitHeadersRFCVersion
    | undefined;
  /** Specifies if the local rate limit filter should include the virtual host rate limits. */
  vh_rate_limits?:
    | VhRateLimitsOptions
    | undefined;
  /**
   * Specifies if default token bucket should be always consumed.
   * If set to false, default token bucket will only be consumed when there is
   * no matching descriptor. If set to true, default token bucket will always
   * be consumed. Default is true.
   */
  always_consume_default_token_bucket?:
    | boolean
    | undefined;
  /**
   * Specifies whether a ``RESOURCE_EXHAUSTED`` gRPC code must be returned instead
   * of the default ``UNAVAILABLE`` gRPC code for a rate limited gRPC call. The
   * HTTP code will be 200 for a gRPC response.
   */
  rate_limited_as_resource_exhausted?:
    | boolean
    | undefined;
  /**
   * Rate limit configuration that is used to generate a list of descriptor entries based on
   * the request context. The generated entries will be used to find one or multiple matched rate
   * limit rule from the ``descriptors``.
   * If this is set, then
   * :ref:`VirtualHost.rate_limits<envoy_v3_api_field_config.route.v3.VirtualHost.rate_limits>` or
   * :ref:`RouteAction.rate_limits<envoy_v3_api_field_config.route.v3.RouteAction.rate_limits>` fields
   * will be ignored.
   *
   * .. note::
   *   Not all configuration fields of
   *   :ref:`rate limit config <envoy_v3_api_msg_config.route.v3.RateLimit>` is supported at here.
   *   Following fields are not supported:
   *
   *   1. :ref:`rate limit stage <envoy_v3_api_field_config.route.v3.RateLimit.stage>`.
   *   2. :ref:`dynamic metadata <envoy_v3_api_field_config.route.v3.RateLimit.Action.dynamic_metadata>`.
   *   3. :ref:`disable_key <envoy_v3_api_field_config.route.v3.RateLimit.disable_key>`.
   *   4. :ref:`override limit <envoy_v3_api_field_config.route.v3.RateLimit.limit>`.
   */
  rate_limits?:
    | RateLimit[]
    | undefined;
  /**
   * Specifies the max dynamic descriptors kept in the cache for a particular wildcard descriptor
   * configured in the global :ref:`descriptors<envoy_v3_api_field_extensions.filters.http.local_ratelimit.v3.LocalRateLimit.descriptors>`.
   * Wildcard descriptor means descriptor has one or more entries with just key and value omitted. For example if user has configured two descriptors
   * with blank value entries, then max dynamic descriptors stored in the LRU cache will be 2 * max_dynamic_descriptors.
   * Actual number of dynamic descriptors will depend on the cardinality of unique values received from the http request for the omitted
   * values.
   * Minimum is 1. Default is 20.
   */
  max_dynamic_descriptors?: number | undefined;
}

function createBaseLocalRateLimit(): LocalRateLimit {
  return { $type: "envoy.extensions.filters.http.local_ratelimit.v3.LocalRateLimit" };
}

export const LocalRateLimit: MessageFns<
  LocalRateLimit,
  "envoy.extensions.filters.http.local_ratelimit.v3.LocalRateLimit"
> = {
  $type: "envoy.extensions.filters.http.local_ratelimit.v3.LocalRateLimit" as const,

  encode(message: LocalRateLimit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stat_prefix !== undefined && message.stat_prefix !== "") {
      writer.uint32(10).string(message.stat_prefix);
    }
    if (message.status !== undefined) {
      HttpStatus.encode(message.status, writer.uint32(18).fork()).join();
    }
    if (message.token_bucket !== undefined) {
      TokenBucket.encode(message.token_bucket, writer.uint32(26).fork()).join();
    }
    if (message.filter_enabled !== undefined) {
      RuntimeFractionalPercent.encode(message.filter_enabled, writer.uint32(34).fork()).join();
    }
    if (message.filter_enforced !== undefined) {
      RuntimeFractionalPercent.encode(message.filter_enforced, writer.uint32(42).fork()).join();
    }
    if (
      message.request_headers_to_add_when_not_enforced !== undefined &&
      message.request_headers_to_add_when_not_enforced.length !== 0
    ) {
      for (const v of message.request_headers_to_add_when_not_enforced) {
        HeaderValueOption.encode(v!, writer.uint32(82).fork()).join();
      }
    }
    if (message.response_headers_to_add !== undefined && message.response_headers_to_add.length !== 0) {
      for (const v of message.response_headers_to_add) {
        HeaderValueOption.encode(v!, writer.uint32(50).fork()).join();
      }
    }
    if (message.descriptors !== undefined && message.descriptors.length !== 0) {
      for (const v of message.descriptors) {
        LocalRateLimitDescriptor.encode(v!, writer.uint32(66).fork()).join();
      }
    }
    if (message.stage !== undefined && message.stage !== 0) {
      writer.uint32(72).uint32(message.stage);
    }
    if (
      message.local_rate_limit_per_downstream_connection !== undefined &&
      message.local_rate_limit_per_downstream_connection !== false
    ) {
      writer.uint32(88).bool(message.local_rate_limit_per_downstream_connection);
    }
    if (message.local_cluster_rate_limit !== undefined) {
      LocalClusterRateLimit.encode(message.local_cluster_rate_limit, writer.uint32(130).fork()).join();
    }
    if (
      message.enable_x_ratelimit_headers !== undefined &&
      message.enable_x_ratelimit_headers !== XRateLimitHeadersRFCVersion.OFF
    ) {
      writer.uint32(96).int32(xRateLimitHeadersRFCVersionToNumber(message.enable_x_ratelimit_headers));
    }
    if (message.vh_rate_limits !== undefined && message.vh_rate_limits !== VhRateLimitsOptions.OVERRIDE) {
      writer.uint32(104).int32(vhRateLimitsOptionsToNumber(message.vh_rate_limits));
    }
    if (message.always_consume_default_token_bucket !== undefined) {
      BoolValue.encode(
        { $type: "google.protobuf.BoolValue", value: message.always_consume_default_token_bucket! },
        writer.uint32(114).fork(),
      ).join();
    }
    if (
      message.rate_limited_as_resource_exhausted !== undefined && message.rate_limited_as_resource_exhausted !== false
    ) {
      writer.uint32(120).bool(message.rate_limited_as_resource_exhausted);
    }
    if (message.rate_limits !== undefined && message.rate_limits.length !== 0) {
      for (const v of message.rate_limits) {
        RateLimit.encode(v!, writer.uint32(138).fork()).join();
      }
    }
    if (message.max_dynamic_descriptors !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.max_dynamic_descriptors! },
        writer.uint32(146).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocalRateLimit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocalRateLimit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stat_prefix = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = HttpStatus.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.token_bucket = TokenBucket.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.filter_enabled = RuntimeFractionalPercent.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.filter_enforced = RuntimeFractionalPercent.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          if (message.request_headers_to_add_when_not_enforced === undefined) {
            message.request_headers_to_add_when_not_enforced = [];
          }
          const el = HeaderValueOption.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.request_headers_to_add_when_not_enforced!.push(el);
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          if (message.response_headers_to_add === undefined) {
            message.response_headers_to_add = [];
          }
          const el = HeaderValueOption.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.response_headers_to_add!.push(el);
          }
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          if (message.descriptors === undefined) {
            message.descriptors = [];
          }
          const el = LocalRateLimitDescriptor.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.descriptors!.push(el);
          }
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.stage = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.local_rate_limit_per_downstream_connection = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.local_cluster_rate_limit = LocalClusterRateLimit.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.enable_x_ratelimit_headers = xRateLimitHeadersRFCVersionFromJSON(reader.int32());
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.vh_rate_limits = vhRateLimitsOptionsFromJSON(reader.int32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.always_consume_default_token_bucket = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.rate_limited_as_resource_exhausted = reader.bool();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          if (message.rate_limits === undefined) {
            message.rate_limits = [];
          }
          const el = RateLimit.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.rate_limits!.push(el);
          }
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.max_dynamic_descriptors = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocalRateLimit {
    return {
      $type: LocalRateLimit.$type,
      stat_prefix: isSet(object.stat_prefix) ? globalThis.String(object.stat_prefix) : undefined,
      status: isSet(object.status) ? HttpStatus.fromJSON(object.status) : undefined,
      token_bucket: isSet(object.token_bucket) ? TokenBucket.fromJSON(object.token_bucket) : undefined,
      filter_enabled: isSet(object.filter_enabled)
        ? RuntimeFractionalPercent.fromJSON(object.filter_enabled)
        : undefined,
      filter_enforced: isSet(object.filter_enforced)
        ? RuntimeFractionalPercent.fromJSON(object.filter_enforced)
        : undefined,
      request_headers_to_add_when_not_enforced:
        globalThis.Array.isArray(object?.request_headers_to_add_when_not_enforced)
          ? object.request_headers_to_add_when_not_enforced.map((e: any) => HeaderValueOption.fromJSON(e))
          : undefined,
      response_headers_to_add: globalThis.Array.isArray(object?.response_headers_to_add)
        ? object.response_headers_to_add.map((e: any) => HeaderValueOption.fromJSON(e))
        : undefined,
      descriptors: globalThis.Array.isArray(object?.descriptors)
        ? object.descriptors.map((e: any) => LocalRateLimitDescriptor.fromJSON(e))
        : undefined,
      stage: isSet(object.stage) ? globalThis.Number(object.stage) : undefined,
      local_rate_limit_per_downstream_connection: isSet(object.local_rate_limit_per_downstream_connection)
        ? globalThis.Boolean(object.local_rate_limit_per_downstream_connection)
        : undefined,
      local_cluster_rate_limit: isSet(object.local_cluster_rate_limit)
        ? LocalClusterRateLimit.fromJSON(object.local_cluster_rate_limit)
        : undefined,
      enable_x_ratelimit_headers: isSet(object.enable_x_ratelimit_headers)
        ? xRateLimitHeadersRFCVersionFromJSON(object.enable_x_ratelimit_headers)
        : undefined,
      vh_rate_limits: isSet(object.vh_rate_limits) ? vhRateLimitsOptionsFromJSON(object.vh_rate_limits) : undefined,
      always_consume_default_token_bucket: isSet(object.always_consume_default_token_bucket)
        ? Boolean(object.always_consume_default_token_bucket)
        : undefined,
      rate_limited_as_resource_exhausted: isSet(object.rate_limited_as_resource_exhausted)
        ? globalThis.Boolean(object.rate_limited_as_resource_exhausted)
        : undefined,
      rate_limits: globalThis.Array.isArray(object?.rate_limits)
        ? object.rate_limits.map((e: any) => RateLimit.fromJSON(e))
        : undefined,
      max_dynamic_descriptors: isSet(object.max_dynamic_descriptors)
        ? Number(object.max_dynamic_descriptors)
        : undefined,
    };
  },

  toJSON(message: LocalRateLimit): unknown {
    const obj: any = {};
    if (message.stat_prefix !== undefined) {
      obj.stat_prefix = message.stat_prefix;
    }
    if (message.status !== undefined) {
      obj.status = HttpStatus.toJSON(message.status);
    }
    if (message.token_bucket !== undefined) {
      obj.token_bucket = TokenBucket.toJSON(message.token_bucket);
    }
    if (message.filter_enabled !== undefined) {
      obj.filter_enabled = RuntimeFractionalPercent.toJSON(message.filter_enabled);
    }
    if (message.filter_enforced !== undefined) {
      obj.filter_enforced = RuntimeFractionalPercent.toJSON(message.filter_enforced);
    }
    if (message.request_headers_to_add_when_not_enforced?.length) {
      obj.request_headers_to_add_when_not_enforced = message.request_headers_to_add_when_not_enforced.map((e) =>
        HeaderValueOption.toJSON(e)
      );
    }
    if (message.response_headers_to_add?.length) {
      obj.response_headers_to_add = message.response_headers_to_add.map((e) => HeaderValueOption.toJSON(e));
    }
    if (message.descriptors?.length) {
      obj.descriptors = message.descriptors.map((e) => LocalRateLimitDescriptor.toJSON(e));
    }
    if (message.stage !== undefined) {
      obj.stage = Math.round(message.stage);
    }
    if (message.local_rate_limit_per_downstream_connection !== undefined) {
      obj.local_rate_limit_per_downstream_connection = message.local_rate_limit_per_downstream_connection;
    }
    if (message.local_cluster_rate_limit !== undefined) {
      obj.local_cluster_rate_limit = LocalClusterRateLimit.toJSON(message.local_cluster_rate_limit);
    }
    if (message.enable_x_ratelimit_headers !== undefined) {
      obj.enable_x_ratelimit_headers = xRateLimitHeadersRFCVersionToJSON(message.enable_x_ratelimit_headers);
    }
    if (message.vh_rate_limits !== undefined) {
      obj.vh_rate_limits = vhRateLimitsOptionsToJSON(message.vh_rate_limits);
    }
    if (message.always_consume_default_token_bucket !== undefined) {
      obj.always_consume_default_token_bucket = message.always_consume_default_token_bucket;
    }
    if (message.rate_limited_as_resource_exhausted !== undefined) {
      obj.rate_limited_as_resource_exhausted = message.rate_limited_as_resource_exhausted;
    }
    if (message.rate_limits?.length) {
      obj.rate_limits = message.rate_limits.map((e) => RateLimit.toJSON(e));
    }
    if (message.max_dynamic_descriptors !== undefined) {
      obj.max_dynamic_descriptors = message.max_dynamic_descriptors;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LocalRateLimit>, I>>(base?: I): LocalRateLimit {
    return LocalRateLimit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LocalRateLimit>, I>>(object: I): LocalRateLimit {
    const message = createBaseLocalRateLimit();
    message.stat_prefix = object.stat_prefix ?? undefined;
    message.status = (object.status !== undefined && object.status !== null)
      ? HttpStatus.fromPartial(object.status)
      : undefined;
    message.token_bucket = (object.token_bucket !== undefined && object.token_bucket !== null)
      ? TokenBucket.fromPartial(object.token_bucket)
      : undefined;
    message.filter_enabled = (object.filter_enabled !== undefined && object.filter_enabled !== null)
      ? RuntimeFractionalPercent.fromPartial(object.filter_enabled)
      : undefined;
    message.filter_enforced = (object.filter_enforced !== undefined && object.filter_enforced !== null)
      ? RuntimeFractionalPercent.fromPartial(object.filter_enforced)
      : undefined;
    message.request_headers_to_add_when_not_enforced =
      object.request_headers_to_add_when_not_enforced?.map((e) => HeaderValueOption.fromPartial(e)) || undefined;
    message.response_headers_to_add = object.response_headers_to_add?.map((e) => HeaderValueOption.fromPartial(e)) ||
      undefined;
    message.descriptors = object.descriptors?.map((e) => LocalRateLimitDescriptor.fromPartial(e)) || undefined;
    message.stage = object.stage ?? undefined;
    message.local_rate_limit_per_downstream_connection = object.local_rate_limit_per_downstream_connection ?? undefined;
    message.local_cluster_rate_limit =
      (object.local_cluster_rate_limit !== undefined && object.local_cluster_rate_limit !== null)
        ? LocalClusterRateLimit.fromPartial(object.local_cluster_rate_limit)
        : undefined;
    message.enable_x_ratelimit_headers = object.enable_x_ratelimit_headers ?? undefined;
    message.vh_rate_limits = object.vh_rate_limits ?? undefined;
    message.always_consume_default_token_bucket = object.always_consume_default_token_bucket ?? undefined;
    message.rate_limited_as_resource_exhausted = object.rate_limited_as_resource_exhausted ?? undefined;
    message.rate_limits = object.rate_limits?.map((e) => RateLimit.fromPartial(e)) || undefined;
    message.max_dynamic_descriptors = object.max_dynamic_descriptors ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(LocalRateLimit.$type, LocalRateLimit);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
