// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/config/bootstrap/v2/bootstrap.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../../google/protobuf/duration";
import { Struct } from "../../../../google/protobuf/struct";
import { UInt64Value } from "../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../typeRegistry";
import { Secret } from "../../../api/v2/auth/secret";
import { Cluster } from "../../../api/v2/cluster";
import { Address, BindConfig } from "../../../api/v2/core/address";
import { Node } from "../../../api/v2/core/base";
import { ApiConfigSource, ConfigSource } from "../../../api/v2/core/config_source";
import { EventServiceConfig } from "../../../api/v2/core/event_service_config";
import { SocketOption } from "../../../api/v2/core/socket_option";
import { Listener } from "../../../api/v2/listener";
import { StatsConfig, StatsSink } from "../../metrics/v2/stats";
import { OverloadManager } from "../../overload/v2alpha/overload";
import { Tracing } from "../../trace/v2/http_tracer";

export const protobufPackage = "envoy.config.bootstrap.v2";

/**
 * Bootstrap :ref:`configuration overview <config_overview_bootstrap>`.
 * [#next-free-field: 21]
 */
export interface Bootstrap {
  $type: "envoy.config.bootstrap.v2.Bootstrap";
  /**
   * Node identity to present to the management server and for instance
   * identification purposes (e.g. in generated headers).
   */
  node?:
    | Node
    | undefined;
  /** Statically specified resources. */
  static_resources?:
    | Bootstrap_StaticResources
    | undefined;
  /** xDS configuration sources. */
  dynamic_resources?:
    | Bootstrap_DynamicResources
    | undefined;
  /**
   * Configuration for the cluster manager which owns all upstream clusters
   * within the server.
   */
  cluster_manager?:
    | ClusterManager
    | undefined;
  /**
   * Health discovery service config option.
   * (:ref:`core.ApiConfigSource <envoy_api_msg_core.ApiConfigSource>`)
   */
  hds_config?:
    | ApiConfigSource
    | undefined;
  /** Optional file system path to search for startup flag files. */
  flags_path?:
    | string
    | undefined;
  /** Optional set of stats sinks. */
  stats_sinks?:
    | StatsSink[]
    | undefined;
  /** Configuration for internal processing of stats. */
  stats_config?:
    | StatsConfig
    | undefined;
  /**
   * Optional duration between flushes to configured stats sinks. For
   * performance reasons Envoy latches counters and only flushes counters and
   * gauges at a periodic interval. If not specified the default is 5000ms (5
   * seconds).
   * Duration must be at least 1ms and at most 5 min.
   */
  stats_flush_interval?:
    | Duration
    | undefined;
  /** Optional watchdog configuration. */
  watchdog?:
    | Watchdog
    | undefined;
  /**
   * Configuration for an external tracing provider.
   *
   * .. attention::
   *  This field has been deprecated in favor of :ref:`HttpConnectionManager.Tracing.provider
   *  <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.Tracing.provider>`.
   */
  tracing?:
    | Tracing
    | undefined;
  /**
   * Configuration for the runtime configuration provider (deprecated). If not
   * specified, a “null” provider will be used which will result in all defaults
   * being used.
   *
   * @deprecated
   */
  runtime?:
    | Runtime
    | undefined;
  /**
   * Configuration for the runtime configuration provider. If not
   * specified, a “null” provider will be used which will result in all defaults
   * being used.
   */
  layered_runtime?:
    | LayeredRuntime
    | undefined;
  /** Configuration for the local administration HTTP server. */
  admin?:
    | Admin
    | undefined;
  /** Optional overload manager configuration. */
  overload_manager?:
    | OverloadManager
    | undefined;
  /**
   * Enable :ref:`stats for event dispatcher <operations_performance>`, defaults to false.
   * Note that this records a value for each iteration of the event loop on every thread. This
   * should normally be minimal overhead, but when using
   * :ref:`statsd <envoy_api_msg_config.metrics.v2.StatsdSink>`, it will send each observed value
   * over the wire individually because the statsd protocol doesn't have any way to represent a
   * histogram summary. Be aware that this can be a very large volume of data.
   */
  enable_dispatcher_stats?:
    | boolean
    | undefined;
  /**
   * Optional string which will be used in lieu of x-envoy in prefixing headers.
   *
   * For example, if this string is present and set to X-Foo, then x-envoy-retry-on will be
   * transformed into x-foo-retry-on etc.
   *
   * Note this applies to the headers Envoy will generate, the headers Envoy will sanitize, and the
   * headers Envoy will trust for core code and core extensions only. Be VERY careful making
   * changes to this string, especially in multi-layer Envoy deployments or deployments using
   * extensions which are not upstream.
   */
  header_prefix?:
    | string
    | undefined;
  /**
   * Optional proxy version which will be used to set the value of :ref:`server.version statistic
   * <server_statistics>` if specified. Envoy will not process this value, it will be sent as is to
   * :ref:`stats sinks <envoy_api_msg_config.metrics.v2.StatsSink>`.
   */
  stats_server_version_override?:
    | number
    | undefined;
  /**
   * Always use TCP queries instead of UDP queries for DNS lookups.
   * This may be overridden on a per-cluster basis in cds_config,
   * when :ref:`dns_resolvers <envoy_api_field_Cluster.dns_resolvers>` and
   * :ref:`use_tcp_for_dns_lookups <envoy_api_field_Cluster.use_tcp_for_dns_lookups>` are
   * specified.
   * Setting this value causes failure if the
   * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
   * server startup. Apple' API only uses UDP for DNS resolution.
   */
  use_tcp_for_dns_lookups?: boolean | undefined;
}

export interface Bootstrap_StaticResources {
  $type: "envoy.config.bootstrap.v2.Bootstrap.StaticResources";
  /**
   * Static :ref:`Listeners <envoy_api_msg_Listener>`. These listeners are
   * available regardless of LDS configuration.
   */
  listeners?:
    | Listener[]
    | undefined;
  /**
   * If a network based configuration source is specified for :ref:`cds_config
   * <envoy_api_field_config.bootstrap.v2.Bootstrap.DynamicResources.cds_config>`, it's necessary
   * to have some initial cluster definitions available to allow Envoy to know
   * how to speak to the management server. These cluster definitions may not
   * use :ref:`EDS <arch_overview_dynamic_config_eds>` (i.e. they should be static
   * IP or DNS-based).
   */
  clusters?:
    | Cluster[]
    | undefined;
  /**
   * These static secrets can be used by :ref:`SdsSecretConfig
   * <envoy_api_msg_auth.SdsSecretConfig>`
   */
  secrets?: Secret[] | undefined;
}

export interface Bootstrap_DynamicResources {
  $type: "envoy.config.bootstrap.v2.Bootstrap.DynamicResources";
  /**
   * All :ref:`Listeners <envoy_api_msg_Listener>` are provided by a single
   * :ref:`LDS <arch_overview_dynamic_config_lds>` configuration source.
   */
  lds_config?:
    | ConfigSource
    | undefined;
  /**
   * All post-bootstrap :ref:`Cluster <envoy_api_msg_Cluster>` definitions are
   * provided by a single :ref:`CDS <arch_overview_dynamic_config_cds>`
   * configuration source.
   */
  cds_config?:
    | ConfigSource
    | undefined;
  /**
   * A single :ref:`ADS <config_overview_ads>` source may be optionally
   * specified. This must have :ref:`api_type
   * <envoy_api_field_core.ApiConfigSource.api_type>` :ref:`GRPC
   * <envoy_api_enum_value_core.ApiConfigSource.ApiType.GRPC>`. Only
   * :ref:`ConfigSources <envoy_api_msg_core.ConfigSource>` that have
   * the :ref:`ads <envoy_api_field_core.ConfigSource.ads>` field set will be
   * streamed on the ADS channel.
   */
  ads_config?: ApiConfigSource | undefined;
}

/**
 * Administration interface :ref:`operations documentation
 * <operations_admin_interface>`.
 */
export interface Admin {
  $type: "envoy.config.bootstrap.v2.Admin";
  /**
   * The path to write the access log for the administration server. If no
   * access log is desired specify ‘/dev/null’. This is only required if
   * :ref:`address <envoy_api_field_config.bootstrap.v2.Admin.address>` is set.
   */
  access_log_path?:
    | string
    | undefined;
  /**
   * The cpu profiler output path for the administration server. If no profile
   * path is specified, the default is ‘/var/log/envoy/envoy.prof’.
   */
  profile_path?:
    | string
    | undefined;
  /**
   * The TCP address that the administration server will listen on.
   * If not specified, Envoy will not start an administration server.
   */
  address?:
    | Address
    | undefined;
  /**
   * Additional socket options that may not be present in Envoy source code or
   * precompiled binaries.
   */
  socket_options?: SocketOption[] | undefined;
}

/** Cluster manager :ref:`architecture overview <arch_overview_cluster_manager>`. */
export interface ClusterManager {
  $type: "envoy.config.bootstrap.v2.ClusterManager";
  /**
   * Name of the local cluster (i.e., the cluster that owns the Envoy running
   * this configuration). In order to enable :ref:`zone aware routing
   * <arch_overview_load_balancing_zone_aware_routing>` this option must be set.
   * If *local_cluster_name* is defined then :ref:`clusters
   * <envoy_api_msg_Cluster>` must be defined in the :ref:`Bootstrap
   * static cluster resources
   * <envoy_api_field_config.bootstrap.v2.Bootstrap.StaticResources.clusters>`. This is unrelated to
   * the :option:`--service-cluster` option which does not `affect zone aware
   * routing <https://github.com/envoyproxy/envoy/issues/774>`_.
   */
  local_cluster_name?:
    | string
    | undefined;
  /** Optional global configuration for outlier detection. */
  outlier_detection?:
    | ClusterManager_OutlierDetection
    | undefined;
  /**
   * Optional configuration used to bind newly established upstream connections.
   * This may be overridden on a per-cluster basis by upstream_bind_config in the cds_config.
   */
  upstream_bind_config?:
    | BindConfig
    | undefined;
  /**
   * A management server endpoint to stream load stats to via
   * *StreamLoadStats*. This must have :ref:`api_type
   * <envoy_api_field_core.ApiConfigSource.api_type>` :ref:`GRPC
   * <envoy_api_enum_value_core.ApiConfigSource.ApiType.GRPC>`.
   */
  load_stats_config?: ApiConfigSource | undefined;
}

export interface ClusterManager_OutlierDetection {
  $type: "envoy.config.bootstrap.v2.ClusterManager.OutlierDetection";
  /** Specifies the path to the outlier event log. */
  event_log_path?:
    | string
    | undefined;
  /**
   * [#not-implemented-hide:]
   * The gRPC service for the outlier detection event service.
   * If empty, outlier detection events won't be sent to a remote endpoint.
   */
  event_service?: EventServiceConfig | undefined;
}

/**
 * Envoy process watchdog configuration. When configured, this monitors for
 * nonresponsive threads and kills the process after the configured thresholds.
 * See the :ref:`watchdog documentation <operations_performance_watchdog>` for more information.
 */
export interface Watchdog {
  $type: "envoy.config.bootstrap.v2.Watchdog";
  /**
   * The duration after which Envoy counts a nonresponsive thread in the
   * *watchdog_miss* statistic. If not specified the default is 200ms.
   */
  miss_timeout?:
    | Duration
    | undefined;
  /**
   * The duration after which Envoy counts a nonresponsive thread in the
   * *watchdog_mega_miss* statistic. If not specified the default is
   * 1000ms.
   */
  megamiss_timeout?:
    | Duration
    | undefined;
  /**
   * If a watched thread has been nonresponsive for this duration, assume a
   * programming error and kill the entire Envoy process. Set to 0 to disable
   * kill behavior. If not specified the default is 0 (disabled).
   */
  kill_timeout?:
    | Duration
    | undefined;
  /**
   * If at least two watched threads have been nonresponsive for at least this
   * duration assume a true deadlock and kill the entire Envoy process. Set to 0
   * to disable this behavior. If not specified the default is 0 (disabled).
   */
  multikill_timeout?: Duration | undefined;
}

/** Runtime :ref:`configuration overview <config_runtime>` (deprecated). */
export interface Runtime {
  $type: "envoy.config.bootstrap.v2.Runtime";
  /**
   * The implementation assumes that the file system tree is accessed via a
   * symbolic link. An atomic link swap is used when a new tree should be
   * switched to. This parameter specifies the path to the symbolic link. Envoy
   * will watch the location for changes and reload the file system tree when
   * they happen. If this parameter is not set, there will be no disk based
   * runtime.
   */
  symlink_root?:
    | string
    | undefined;
  /**
   * Specifies the subdirectory to load within the root directory. This is
   * useful if multiple systems share the same delivery mechanism. Envoy
   * configuration elements can be contained in a dedicated subdirectory.
   */
  subdirectory?:
    | string
    | undefined;
  /**
   * Specifies an optional subdirectory to load within the root directory. If
   * specified and the directory exists, configuration values within this
   * directory will override those found in the primary subdirectory. This is
   * useful when Envoy is deployed across many different types of servers.
   * Sometimes it is useful to have a per service cluster directory for runtime
   * configuration. See below for exactly how the override directory is used.
   */
  override_subdirectory?:
    | string
    | undefined;
  /**
   * Static base runtime. This will be :ref:`overridden
   * <config_runtime_layering>` by other runtime layers, e.g.
   * disk or admin. This follows the :ref:`runtime protobuf JSON representation
   * encoding <config_runtime_proto_json>`.
   */
  base?: { [key: string]: any } | undefined;
}

/** [#next-free-field: 6] */
export interface RuntimeLayer {
  $type: "envoy.config.bootstrap.v2.RuntimeLayer";
  /**
   * Descriptive name for the runtime layer. This is only used for the runtime
   * :http:get:`/runtime` output.
   */
  name?: string | undefined;
  layer_specifier?:
    | //
    /**
     * :ref:`Static runtime <config_runtime_bootstrap>` layer.
     * This follows the :ref:`runtime protobuf JSON representation encoding
     * <config_runtime_proto_json>`. Unlike static xDS resources, this static
     * layer is overridable by later layers in the runtime virtual filesystem.
     */
    { $case: "static_layer"; static_layer: { [key: string]: any } | undefined }
    | //
    { $case: "disk_layer"; disk_layer: RuntimeLayer_DiskLayer }
    | //
    { $case: "admin_layer"; admin_layer: RuntimeLayer_AdminLayer }
    | //
    { $case: "rtds_layer"; rtds_layer: RuntimeLayer_RtdsLayer }
    | undefined;
}

/** :ref:`Disk runtime <config_runtime_local_disk>` layer. */
export interface RuntimeLayer_DiskLayer {
  $type: "envoy.config.bootstrap.v2.RuntimeLayer.DiskLayer";
  /**
   * The implementation assumes that the file system tree is accessed via a
   * symbolic link. An atomic link swap is used when a new tree should be
   * switched to. This parameter specifies the path to the symbolic link.
   * Envoy will watch the location for changes and reload the file system tree
   * when they happen. See documentation on runtime :ref:`atomicity
   * <config_runtime_atomicity>` for further details on how reloads are
   * treated.
   */
  symlink_root?:
    | string
    | undefined;
  /**
   * Specifies the subdirectory to load within the root directory. This is
   * useful if multiple systems share the same delivery mechanism. Envoy
   * configuration elements can be contained in a dedicated subdirectory.
   */
  subdirectory?:
    | string
    | undefined;
  /**
   * :ref:`Append <config_runtime_local_disk_service_cluster_subdirs>` the
   * service cluster to the path under symlink root.
   */
  append_service_cluster?: boolean | undefined;
}

/** :ref:`Admin console runtime <config_runtime_admin>` layer. */
export interface RuntimeLayer_AdminLayer {
  $type: "envoy.config.bootstrap.v2.RuntimeLayer.AdminLayer";
}

/** :ref:`Runtime Discovery Service (RTDS) <config_runtime_rtds>` layer. */
export interface RuntimeLayer_RtdsLayer {
  $type: "envoy.config.bootstrap.v2.RuntimeLayer.RtdsLayer";
  /** Resource to subscribe to at *rtds_config* for the RTDS layer. */
  name?:
    | string
    | undefined;
  /** RTDS configuration source. */
  rtds_config?: ConfigSource | undefined;
}

/** Runtime :ref:`configuration overview <config_runtime>`. */
export interface LayeredRuntime {
  $type: "envoy.config.bootstrap.v2.LayeredRuntime";
  /**
   * The :ref:`layers <config_runtime_layering>` of the runtime. This is ordered
   * such that later layers in the list overlay earlier entries.
   */
  layers?: RuntimeLayer[] | undefined;
}

function createBaseBootstrap(): Bootstrap {
  return { $type: "envoy.config.bootstrap.v2.Bootstrap" };
}

export const Bootstrap: MessageFns<Bootstrap, "envoy.config.bootstrap.v2.Bootstrap"> = {
  $type: "envoy.config.bootstrap.v2.Bootstrap" as const,

  encode(message: Bootstrap, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.node !== undefined) {
      Node.encode(message.node, writer.uint32(10).fork()).join();
    }
    if (message.static_resources !== undefined) {
      Bootstrap_StaticResources.encode(message.static_resources, writer.uint32(18).fork()).join();
    }
    if (message.dynamic_resources !== undefined) {
      Bootstrap_DynamicResources.encode(message.dynamic_resources, writer.uint32(26).fork()).join();
    }
    if (message.cluster_manager !== undefined) {
      ClusterManager.encode(message.cluster_manager, writer.uint32(34).fork()).join();
    }
    if (message.hds_config !== undefined) {
      ApiConfigSource.encode(message.hds_config, writer.uint32(114).fork()).join();
    }
    if (message.flags_path !== undefined && message.flags_path !== "") {
      writer.uint32(42).string(message.flags_path);
    }
    if (message.stats_sinks !== undefined && message.stats_sinks.length !== 0) {
      for (const v of message.stats_sinks) {
        StatsSink.encode(v!, writer.uint32(50).fork()).join();
      }
    }
    if (message.stats_config !== undefined) {
      StatsConfig.encode(message.stats_config, writer.uint32(106).fork()).join();
    }
    if (message.stats_flush_interval !== undefined) {
      Duration.encode(message.stats_flush_interval, writer.uint32(58).fork()).join();
    }
    if (message.watchdog !== undefined) {
      Watchdog.encode(message.watchdog, writer.uint32(66).fork()).join();
    }
    if (message.tracing !== undefined) {
      Tracing.encode(message.tracing, writer.uint32(74).fork()).join();
    }
    if (message.runtime !== undefined) {
      Runtime.encode(message.runtime, writer.uint32(90).fork()).join();
    }
    if (message.layered_runtime !== undefined) {
      LayeredRuntime.encode(message.layered_runtime, writer.uint32(138).fork()).join();
    }
    if (message.admin !== undefined) {
      Admin.encode(message.admin, writer.uint32(98).fork()).join();
    }
    if (message.overload_manager !== undefined) {
      OverloadManager.encode(message.overload_manager, writer.uint32(122).fork()).join();
    }
    if (message.enable_dispatcher_stats !== undefined && message.enable_dispatcher_stats !== false) {
      writer.uint32(128).bool(message.enable_dispatcher_stats);
    }
    if (message.header_prefix !== undefined && message.header_prefix !== "") {
      writer.uint32(146).string(message.header_prefix);
    }
    if (message.stats_server_version_override !== undefined) {
      UInt64Value.encode(
        { $type: "google.protobuf.UInt64Value", value: message.stats_server_version_override! },
        writer.uint32(154).fork(),
      ).join();
    }
    if (message.use_tcp_for_dns_lookups !== undefined && message.use_tcp_for_dns_lookups !== false) {
      writer.uint32(160).bool(message.use_tcp_for_dns_lookups);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Bootstrap {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBootstrap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.node = Node.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.static_resources = Bootstrap_StaticResources.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.dynamic_resources = Bootstrap_DynamicResources.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.cluster_manager = ClusterManager.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.hds_config = ApiConfigSource.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.flags_path = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          if (message.stats_sinks === undefined) {
            message.stats_sinks = [];
          }
          const el = StatsSink.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.stats_sinks!.push(el);
          }
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.stats_config = StatsConfig.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.stats_flush_interval = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.watchdog = Watchdog.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.tracing = Tracing.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.runtime = Runtime.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.layered_runtime = LayeredRuntime.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.admin = Admin.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.overload_manager = OverloadManager.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.enable_dispatcher_stats = reader.bool();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.header_prefix = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.stats_server_version_override = UInt64Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.use_tcp_for_dns_lookups = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bootstrap {
    return {
      $type: Bootstrap.$type,
      node: isSet(object.node) ? Node.fromJSON(object.node) : undefined,
      static_resources: isSet(object.static_resources)
        ? Bootstrap_StaticResources.fromJSON(object.static_resources)
        : undefined,
      dynamic_resources: isSet(object.dynamic_resources)
        ? Bootstrap_DynamicResources.fromJSON(object.dynamic_resources)
        : undefined,
      cluster_manager: isSet(object.cluster_manager) ? ClusterManager.fromJSON(object.cluster_manager) : undefined,
      hds_config: isSet(object.hds_config) ? ApiConfigSource.fromJSON(object.hds_config) : undefined,
      flags_path: isSet(object.flags_path) ? globalThis.String(object.flags_path) : undefined,
      stats_sinks: globalThis.Array.isArray(object?.stats_sinks)
        ? object.stats_sinks.map((e: any) => StatsSink.fromJSON(e))
        : undefined,
      stats_config: isSet(object.stats_config) ? StatsConfig.fromJSON(object.stats_config) : undefined,
      stats_flush_interval: isSet(object.stats_flush_interval)
        ? Duration.fromJSON(object.stats_flush_interval)
        : undefined,
      watchdog: isSet(object.watchdog) ? Watchdog.fromJSON(object.watchdog) : undefined,
      tracing: isSet(object.tracing) ? Tracing.fromJSON(object.tracing) : undefined,
      runtime: isSet(object.runtime) ? Runtime.fromJSON(object.runtime) : undefined,
      layered_runtime: isSet(object.layered_runtime) ? LayeredRuntime.fromJSON(object.layered_runtime) : undefined,
      admin: isSet(object.admin) ? Admin.fromJSON(object.admin) : undefined,
      overload_manager: isSet(object.overload_manager) ? OverloadManager.fromJSON(object.overload_manager) : undefined,
      enable_dispatcher_stats: isSet(object.enable_dispatcher_stats)
        ? globalThis.Boolean(object.enable_dispatcher_stats)
        : undefined,
      header_prefix: isSet(object.header_prefix) ? globalThis.String(object.header_prefix) : undefined,
      stats_server_version_override: isSet(object.stats_server_version_override)
        ? Number(object.stats_server_version_override)
        : undefined,
      use_tcp_for_dns_lookups: isSet(object.use_tcp_for_dns_lookups)
        ? globalThis.Boolean(object.use_tcp_for_dns_lookups)
        : undefined,
    };
  },

  toJSON(message: Bootstrap): unknown {
    const obj: any = {};
    if (message.node !== undefined) {
      obj.node = Node.toJSON(message.node);
    }
    if (message.static_resources !== undefined) {
      obj.static_resources = Bootstrap_StaticResources.toJSON(message.static_resources);
    }
    if (message.dynamic_resources !== undefined) {
      obj.dynamic_resources = Bootstrap_DynamicResources.toJSON(message.dynamic_resources);
    }
    if (message.cluster_manager !== undefined) {
      obj.cluster_manager = ClusterManager.toJSON(message.cluster_manager);
    }
    if (message.hds_config !== undefined) {
      obj.hds_config = ApiConfigSource.toJSON(message.hds_config);
    }
    if (message.flags_path !== undefined) {
      obj.flags_path = message.flags_path;
    }
    if (message.stats_sinks?.length) {
      obj.stats_sinks = message.stats_sinks.map((e) => StatsSink.toJSON(e));
    }
    if (message.stats_config !== undefined) {
      obj.stats_config = StatsConfig.toJSON(message.stats_config);
    }
    if (message.stats_flush_interval !== undefined) {
      obj.stats_flush_interval = Duration.toJSON(message.stats_flush_interval);
    }
    if (message.watchdog !== undefined) {
      obj.watchdog = Watchdog.toJSON(message.watchdog);
    }
    if (message.tracing !== undefined) {
      obj.tracing = Tracing.toJSON(message.tracing);
    }
    if (message.runtime !== undefined) {
      obj.runtime = Runtime.toJSON(message.runtime);
    }
    if (message.layered_runtime !== undefined) {
      obj.layered_runtime = LayeredRuntime.toJSON(message.layered_runtime);
    }
    if (message.admin !== undefined) {
      obj.admin = Admin.toJSON(message.admin);
    }
    if (message.overload_manager !== undefined) {
      obj.overload_manager = OverloadManager.toJSON(message.overload_manager);
    }
    if (message.enable_dispatcher_stats !== undefined) {
      obj.enable_dispatcher_stats = message.enable_dispatcher_stats;
    }
    if (message.header_prefix !== undefined) {
      obj.header_prefix = message.header_prefix;
    }
    if (message.stats_server_version_override !== undefined) {
      obj.stats_server_version_override = message.stats_server_version_override;
    }
    if (message.use_tcp_for_dns_lookups !== undefined) {
      obj.use_tcp_for_dns_lookups = message.use_tcp_for_dns_lookups;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Bootstrap>, I>>(base?: I): Bootstrap {
    return Bootstrap.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Bootstrap>, I>>(object: I): Bootstrap {
    const message = createBaseBootstrap();
    message.node = (object.node !== undefined && object.node !== null) ? Node.fromPartial(object.node) : undefined;
    message.static_resources = (object.static_resources !== undefined && object.static_resources !== null)
      ? Bootstrap_StaticResources.fromPartial(object.static_resources)
      : undefined;
    message.dynamic_resources = (object.dynamic_resources !== undefined && object.dynamic_resources !== null)
      ? Bootstrap_DynamicResources.fromPartial(object.dynamic_resources)
      : undefined;
    message.cluster_manager = (object.cluster_manager !== undefined && object.cluster_manager !== null)
      ? ClusterManager.fromPartial(object.cluster_manager)
      : undefined;
    message.hds_config = (object.hds_config !== undefined && object.hds_config !== null)
      ? ApiConfigSource.fromPartial(object.hds_config)
      : undefined;
    message.flags_path = object.flags_path ?? undefined;
    message.stats_sinks = object.stats_sinks?.map((e) => StatsSink.fromPartial(e)) || undefined;
    message.stats_config = (object.stats_config !== undefined && object.stats_config !== null)
      ? StatsConfig.fromPartial(object.stats_config)
      : undefined;
    message.stats_flush_interval = (object.stats_flush_interval !== undefined && object.stats_flush_interval !== null)
      ? Duration.fromPartial(object.stats_flush_interval)
      : undefined;
    message.watchdog = (object.watchdog !== undefined && object.watchdog !== null)
      ? Watchdog.fromPartial(object.watchdog)
      : undefined;
    message.tracing = (object.tracing !== undefined && object.tracing !== null)
      ? Tracing.fromPartial(object.tracing)
      : undefined;
    message.runtime = (object.runtime !== undefined && object.runtime !== null)
      ? Runtime.fromPartial(object.runtime)
      : undefined;
    message.layered_runtime = (object.layered_runtime !== undefined && object.layered_runtime !== null)
      ? LayeredRuntime.fromPartial(object.layered_runtime)
      : undefined;
    message.admin = (object.admin !== undefined && object.admin !== null) ? Admin.fromPartial(object.admin) : undefined;
    message.overload_manager = (object.overload_manager !== undefined && object.overload_manager !== null)
      ? OverloadManager.fromPartial(object.overload_manager)
      : undefined;
    message.enable_dispatcher_stats = object.enable_dispatcher_stats ?? undefined;
    message.header_prefix = object.header_prefix ?? undefined;
    message.stats_server_version_override = object.stats_server_version_override ?? undefined;
    message.use_tcp_for_dns_lookups = object.use_tcp_for_dns_lookups ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Bootstrap.$type, Bootstrap);

function createBaseBootstrap_StaticResources(): Bootstrap_StaticResources {
  return { $type: "envoy.config.bootstrap.v2.Bootstrap.StaticResources" };
}

export const Bootstrap_StaticResources: MessageFns<
  Bootstrap_StaticResources,
  "envoy.config.bootstrap.v2.Bootstrap.StaticResources"
> = {
  $type: "envoy.config.bootstrap.v2.Bootstrap.StaticResources" as const,

  encode(message: Bootstrap_StaticResources, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.listeners !== undefined && message.listeners.length !== 0) {
      for (const v of message.listeners) {
        Listener.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    if (message.clusters !== undefined && message.clusters.length !== 0) {
      for (const v of message.clusters) {
        Cluster.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.secrets !== undefined && message.secrets.length !== 0) {
      for (const v of message.secrets) {
        Secret.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Bootstrap_StaticResources {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBootstrap_StaticResources();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.listeners === undefined) {
            message.listeners = [];
          }
          const el = Listener.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.listeners!.push(el);
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.clusters === undefined) {
            message.clusters = [];
          }
          const el = Cluster.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.clusters!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.secrets === undefined) {
            message.secrets = [];
          }
          const el = Secret.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.secrets!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bootstrap_StaticResources {
    return {
      $type: Bootstrap_StaticResources.$type,
      listeners: globalThis.Array.isArray(object?.listeners)
        ? object.listeners.map((e: any) => Listener.fromJSON(e))
        : undefined,
      clusters: globalThis.Array.isArray(object?.clusters)
        ? object.clusters.map((e: any) => Cluster.fromJSON(e))
        : undefined,
      secrets: globalThis.Array.isArray(object?.secrets)
        ? object.secrets.map((e: any) => Secret.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: Bootstrap_StaticResources): unknown {
    const obj: any = {};
    if (message.listeners?.length) {
      obj.listeners = message.listeners.map((e) => Listener.toJSON(e));
    }
    if (message.clusters?.length) {
      obj.clusters = message.clusters.map((e) => Cluster.toJSON(e));
    }
    if (message.secrets?.length) {
      obj.secrets = message.secrets.map((e) => Secret.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Bootstrap_StaticResources>, I>>(base?: I): Bootstrap_StaticResources {
    return Bootstrap_StaticResources.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Bootstrap_StaticResources>, I>>(object: I): Bootstrap_StaticResources {
    const message = createBaseBootstrap_StaticResources();
    message.listeners = object.listeners?.map((e) => Listener.fromPartial(e)) || undefined;
    message.clusters = object.clusters?.map((e) => Cluster.fromPartial(e)) || undefined;
    message.secrets = object.secrets?.map((e) => Secret.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(Bootstrap_StaticResources.$type, Bootstrap_StaticResources);

function createBaseBootstrap_DynamicResources(): Bootstrap_DynamicResources {
  return { $type: "envoy.config.bootstrap.v2.Bootstrap.DynamicResources" };
}

export const Bootstrap_DynamicResources: MessageFns<
  Bootstrap_DynamicResources,
  "envoy.config.bootstrap.v2.Bootstrap.DynamicResources"
> = {
  $type: "envoy.config.bootstrap.v2.Bootstrap.DynamicResources" as const,

  encode(message: Bootstrap_DynamicResources, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lds_config !== undefined) {
      ConfigSource.encode(message.lds_config, writer.uint32(10).fork()).join();
    }
    if (message.cds_config !== undefined) {
      ConfigSource.encode(message.cds_config, writer.uint32(18).fork()).join();
    }
    if (message.ads_config !== undefined) {
      ApiConfigSource.encode(message.ads_config, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Bootstrap_DynamicResources {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBootstrap_DynamicResources();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.lds_config = ConfigSource.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cds_config = ConfigSource.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ads_config = ApiConfigSource.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bootstrap_DynamicResources {
    return {
      $type: Bootstrap_DynamicResources.$type,
      lds_config: isSet(object.lds_config) ? ConfigSource.fromJSON(object.lds_config) : undefined,
      cds_config: isSet(object.cds_config) ? ConfigSource.fromJSON(object.cds_config) : undefined,
      ads_config: isSet(object.ads_config) ? ApiConfigSource.fromJSON(object.ads_config) : undefined,
    };
  },

  toJSON(message: Bootstrap_DynamicResources): unknown {
    const obj: any = {};
    if (message.lds_config !== undefined) {
      obj.lds_config = ConfigSource.toJSON(message.lds_config);
    }
    if (message.cds_config !== undefined) {
      obj.cds_config = ConfigSource.toJSON(message.cds_config);
    }
    if (message.ads_config !== undefined) {
      obj.ads_config = ApiConfigSource.toJSON(message.ads_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Bootstrap_DynamicResources>, I>>(base?: I): Bootstrap_DynamicResources {
    return Bootstrap_DynamicResources.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Bootstrap_DynamicResources>, I>>(object: I): Bootstrap_DynamicResources {
    const message = createBaseBootstrap_DynamicResources();
    message.lds_config = (object.lds_config !== undefined && object.lds_config !== null)
      ? ConfigSource.fromPartial(object.lds_config)
      : undefined;
    message.cds_config = (object.cds_config !== undefined && object.cds_config !== null)
      ? ConfigSource.fromPartial(object.cds_config)
      : undefined;
    message.ads_config = (object.ads_config !== undefined && object.ads_config !== null)
      ? ApiConfigSource.fromPartial(object.ads_config)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Bootstrap_DynamicResources.$type, Bootstrap_DynamicResources);

function createBaseAdmin(): Admin {
  return { $type: "envoy.config.bootstrap.v2.Admin" };
}

export const Admin: MessageFns<Admin, "envoy.config.bootstrap.v2.Admin"> = {
  $type: "envoy.config.bootstrap.v2.Admin" as const,

  encode(message: Admin, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.access_log_path !== undefined && message.access_log_path !== "") {
      writer.uint32(10).string(message.access_log_path);
    }
    if (message.profile_path !== undefined && message.profile_path !== "") {
      writer.uint32(18).string(message.profile_path);
    }
    if (message.address !== undefined) {
      Address.encode(message.address, writer.uint32(26).fork()).join();
    }
    if (message.socket_options !== undefined && message.socket_options.length !== 0) {
      for (const v of message.socket_options) {
        SocketOption.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Admin {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdmin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.access_log_path = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.profile_path = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.address = Address.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          if (message.socket_options === undefined) {
            message.socket_options = [];
          }
          const el = SocketOption.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.socket_options!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Admin {
    return {
      $type: Admin.$type,
      access_log_path: isSet(object.access_log_path) ? globalThis.String(object.access_log_path) : undefined,
      profile_path: isSet(object.profile_path) ? globalThis.String(object.profile_path) : undefined,
      address: isSet(object.address) ? Address.fromJSON(object.address) : undefined,
      socket_options: globalThis.Array.isArray(object?.socket_options)
        ? object.socket_options.map((e: any) => SocketOption.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: Admin): unknown {
    const obj: any = {};
    if (message.access_log_path !== undefined) {
      obj.access_log_path = message.access_log_path;
    }
    if (message.profile_path !== undefined) {
      obj.profile_path = message.profile_path;
    }
    if (message.address !== undefined) {
      obj.address = Address.toJSON(message.address);
    }
    if (message.socket_options?.length) {
      obj.socket_options = message.socket_options.map((e) => SocketOption.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Admin>, I>>(base?: I): Admin {
    return Admin.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Admin>, I>>(object: I): Admin {
    const message = createBaseAdmin();
    message.access_log_path = object.access_log_path ?? undefined;
    message.profile_path = object.profile_path ?? undefined;
    message.address = (object.address !== undefined && object.address !== null)
      ? Address.fromPartial(object.address)
      : undefined;
    message.socket_options = object.socket_options?.map((e) => SocketOption.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(Admin.$type, Admin);

function createBaseClusterManager(): ClusterManager {
  return { $type: "envoy.config.bootstrap.v2.ClusterManager" };
}

export const ClusterManager: MessageFns<ClusterManager, "envoy.config.bootstrap.v2.ClusterManager"> = {
  $type: "envoy.config.bootstrap.v2.ClusterManager" as const,

  encode(message: ClusterManager, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.local_cluster_name !== undefined && message.local_cluster_name !== "") {
      writer.uint32(10).string(message.local_cluster_name);
    }
    if (message.outlier_detection !== undefined) {
      ClusterManager_OutlierDetection.encode(message.outlier_detection, writer.uint32(18).fork()).join();
    }
    if (message.upstream_bind_config !== undefined) {
      BindConfig.encode(message.upstream_bind_config, writer.uint32(26).fork()).join();
    }
    if (message.load_stats_config !== undefined) {
      ApiConfigSource.encode(message.load_stats_config, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClusterManager {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClusterManager();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.local_cluster_name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.outlier_detection = ClusterManager_OutlierDetection.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.upstream_bind_config = BindConfig.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.load_stats_config = ApiConfigSource.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClusterManager {
    return {
      $type: ClusterManager.$type,
      local_cluster_name: isSet(object.local_cluster_name) ? globalThis.String(object.local_cluster_name) : undefined,
      outlier_detection: isSet(object.outlier_detection)
        ? ClusterManager_OutlierDetection.fromJSON(object.outlier_detection)
        : undefined,
      upstream_bind_config: isSet(object.upstream_bind_config)
        ? BindConfig.fromJSON(object.upstream_bind_config)
        : undefined,
      load_stats_config: isSet(object.load_stats_config)
        ? ApiConfigSource.fromJSON(object.load_stats_config)
        : undefined,
    };
  },

  toJSON(message: ClusterManager): unknown {
    const obj: any = {};
    if (message.local_cluster_name !== undefined) {
      obj.local_cluster_name = message.local_cluster_name;
    }
    if (message.outlier_detection !== undefined) {
      obj.outlier_detection = ClusterManager_OutlierDetection.toJSON(message.outlier_detection);
    }
    if (message.upstream_bind_config !== undefined) {
      obj.upstream_bind_config = BindConfig.toJSON(message.upstream_bind_config);
    }
    if (message.load_stats_config !== undefined) {
      obj.load_stats_config = ApiConfigSource.toJSON(message.load_stats_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClusterManager>, I>>(base?: I): ClusterManager {
    return ClusterManager.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClusterManager>, I>>(object: I): ClusterManager {
    const message = createBaseClusterManager();
    message.local_cluster_name = object.local_cluster_name ?? undefined;
    message.outlier_detection = (object.outlier_detection !== undefined && object.outlier_detection !== null)
      ? ClusterManager_OutlierDetection.fromPartial(object.outlier_detection)
      : undefined;
    message.upstream_bind_config = (object.upstream_bind_config !== undefined && object.upstream_bind_config !== null)
      ? BindConfig.fromPartial(object.upstream_bind_config)
      : undefined;
    message.load_stats_config = (object.load_stats_config !== undefined && object.load_stats_config !== null)
      ? ApiConfigSource.fromPartial(object.load_stats_config)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(ClusterManager.$type, ClusterManager);

function createBaseClusterManager_OutlierDetection(): ClusterManager_OutlierDetection {
  return { $type: "envoy.config.bootstrap.v2.ClusterManager.OutlierDetection" };
}

export const ClusterManager_OutlierDetection: MessageFns<
  ClusterManager_OutlierDetection,
  "envoy.config.bootstrap.v2.ClusterManager.OutlierDetection"
> = {
  $type: "envoy.config.bootstrap.v2.ClusterManager.OutlierDetection" as const,

  encode(message: ClusterManager_OutlierDetection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.event_log_path !== undefined && message.event_log_path !== "") {
      writer.uint32(10).string(message.event_log_path);
    }
    if (message.event_service !== undefined) {
      EventServiceConfig.encode(message.event_service, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClusterManager_OutlierDetection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClusterManager_OutlierDetection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.event_log_path = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.event_service = EventServiceConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClusterManager_OutlierDetection {
    return {
      $type: ClusterManager_OutlierDetection.$type,
      event_log_path: isSet(object.event_log_path) ? globalThis.String(object.event_log_path) : undefined,
      event_service: isSet(object.event_service) ? EventServiceConfig.fromJSON(object.event_service) : undefined,
    };
  },

  toJSON(message: ClusterManager_OutlierDetection): unknown {
    const obj: any = {};
    if (message.event_log_path !== undefined) {
      obj.event_log_path = message.event_log_path;
    }
    if (message.event_service !== undefined) {
      obj.event_service = EventServiceConfig.toJSON(message.event_service);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClusterManager_OutlierDetection>, I>>(base?: I): ClusterManager_OutlierDetection {
    return ClusterManager_OutlierDetection.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClusterManager_OutlierDetection>, I>>(
    object: I,
  ): ClusterManager_OutlierDetection {
    const message = createBaseClusterManager_OutlierDetection();
    message.event_log_path = object.event_log_path ?? undefined;
    message.event_service = (object.event_service !== undefined && object.event_service !== null)
      ? EventServiceConfig.fromPartial(object.event_service)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(ClusterManager_OutlierDetection.$type, ClusterManager_OutlierDetection);

function createBaseWatchdog(): Watchdog {
  return { $type: "envoy.config.bootstrap.v2.Watchdog" };
}

export const Watchdog: MessageFns<Watchdog, "envoy.config.bootstrap.v2.Watchdog"> = {
  $type: "envoy.config.bootstrap.v2.Watchdog" as const,

  encode(message: Watchdog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.miss_timeout !== undefined) {
      Duration.encode(message.miss_timeout, writer.uint32(10).fork()).join();
    }
    if (message.megamiss_timeout !== undefined) {
      Duration.encode(message.megamiss_timeout, writer.uint32(18).fork()).join();
    }
    if (message.kill_timeout !== undefined) {
      Duration.encode(message.kill_timeout, writer.uint32(26).fork()).join();
    }
    if (message.multikill_timeout !== undefined) {
      Duration.encode(message.multikill_timeout, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Watchdog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWatchdog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.miss_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.megamiss_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.kill_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.multikill_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Watchdog {
    return {
      $type: Watchdog.$type,
      miss_timeout: isSet(object.miss_timeout) ? Duration.fromJSON(object.miss_timeout) : undefined,
      megamiss_timeout: isSet(object.megamiss_timeout) ? Duration.fromJSON(object.megamiss_timeout) : undefined,
      kill_timeout: isSet(object.kill_timeout) ? Duration.fromJSON(object.kill_timeout) : undefined,
      multikill_timeout: isSet(object.multikill_timeout) ? Duration.fromJSON(object.multikill_timeout) : undefined,
    };
  },

  toJSON(message: Watchdog): unknown {
    const obj: any = {};
    if (message.miss_timeout !== undefined) {
      obj.miss_timeout = Duration.toJSON(message.miss_timeout);
    }
    if (message.megamiss_timeout !== undefined) {
      obj.megamiss_timeout = Duration.toJSON(message.megamiss_timeout);
    }
    if (message.kill_timeout !== undefined) {
      obj.kill_timeout = Duration.toJSON(message.kill_timeout);
    }
    if (message.multikill_timeout !== undefined) {
      obj.multikill_timeout = Duration.toJSON(message.multikill_timeout);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Watchdog>, I>>(base?: I): Watchdog {
    return Watchdog.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Watchdog>, I>>(object: I): Watchdog {
    const message = createBaseWatchdog();
    message.miss_timeout = (object.miss_timeout !== undefined && object.miss_timeout !== null)
      ? Duration.fromPartial(object.miss_timeout)
      : undefined;
    message.megamiss_timeout = (object.megamiss_timeout !== undefined && object.megamiss_timeout !== null)
      ? Duration.fromPartial(object.megamiss_timeout)
      : undefined;
    message.kill_timeout = (object.kill_timeout !== undefined && object.kill_timeout !== null)
      ? Duration.fromPartial(object.kill_timeout)
      : undefined;
    message.multikill_timeout = (object.multikill_timeout !== undefined && object.multikill_timeout !== null)
      ? Duration.fromPartial(object.multikill_timeout)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Watchdog.$type, Watchdog);

function createBaseRuntime(): Runtime {
  return { $type: "envoy.config.bootstrap.v2.Runtime" };
}

export const Runtime: MessageFns<Runtime, "envoy.config.bootstrap.v2.Runtime"> = {
  $type: "envoy.config.bootstrap.v2.Runtime" as const,

  encode(message: Runtime, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.symlink_root !== undefined && message.symlink_root !== "") {
      writer.uint32(10).string(message.symlink_root);
    }
    if (message.subdirectory !== undefined && message.subdirectory !== "") {
      writer.uint32(18).string(message.subdirectory);
    }
    if (message.override_subdirectory !== undefined && message.override_subdirectory !== "") {
      writer.uint32(26).string(message.override_subdirectory);
    }
    if (message.base !== undefined) {
      Struct.encode(Struct.wrap(message.base), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Runtime {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuntime();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.symlink_root = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.subdirectory = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.override_subdirectory = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.base = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Runtime {
    return {
      $type: Runtime.$type,
      symlink_root: isSet(object.symlink_root) ? globalThis.String(object.symlink_root) : undefined,
      subdirectory: isSet(object.subdirectory) ? globalThis.String(object.subdirectory) : undefined,
      override_subdirectory: isSet(object.override_subdirectory)
        ? globalThis.String(object.override_subdirectory)
        : undefined,
      base: isObject(object.base) ? object.base : undefined,
    };
  },

  toJSON(message: Runtime): unknown {
    const obj: any = {};
    if (message.symlink_root !== undefined) {
      obj.symlink_root = message.symlink_root;
    }
    if (message.subdirectory !== undefined) {
      obj.subdirectory = message.subdirectory;
    }
    if (message.override_subdirectory !== undefined) {
      obj.override_subdirectory = message.override_subdirectory;
    }
    if (message.base !== undefined) {
      obj.base = message.base;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Runtime>, I>>(base?: I): Runtime {
    return Runtime.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Runtime>, I>>(object: I): Runtime {
    const message = createBaseRuntime();
    message.symlink_root = object.symlink_root ?? undefined;
    message.subdirectory = object.subdirectory ?? undefined;
    message.override_subdirectory = object.override_subdirectory ?? undefined;
    message.base = object.base ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Runtime.$type, Runtime);

function createBaseRuntimeLayer(): RuntimeLayer {
  return { $type: "envoy.config.bootstrap.v2.RuntimeLayer", layer_specifier: undefined };
}

export const RuntimeLayer: MessageFns<RuntimeLayer, "envoy.config.bootstrap.v2.RuntimeLayer"> = {
  $type: "envoy.config.bootstrap.v2.RuntimeLayer" as const,

  encode(message: RuntimeLayer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    switch (message.layer_specifier?.$case) {
      case "static_layer":
        Struct.encode(Struct.wrap(message.layer_specifier.static_layer), writer.uint32(18).fork()).join();
        break;
      case "disk_layer":
        RuntimeLayer_DiskLayer.encode(message.layer_specifier.disk_layer, writer.uint32(26).fork()).join();
        break;
      case "admin_layer":
        RuntimeLayer_AdminLayer.encode(message.layer_specifier.admin_layer, writer.uint32(34).fork()).join();
        break;
      case "rtds_layer":
        RuntimeLayer_RtdsLayer.encode(message.layer_specifier.rtds_layer, writer.uint32(42).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuntimeLayer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuntimeLayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.layer_specifier = {
            $case: "static_layer",
            static_layer: Struct.unwrap(Struct.decode(reader, reader.uint32())),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.layer_specifier = {
            $case: "disk_layer",
            disk_layer: RuntimeLayer_DiskLayer.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.layer_specifier = {
            $case: "admin_layer",
            admin_layer: RuntimeLayer_AdminLayer.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.layer_specifier = {
            $case: "rtds_layer",
            rtds_layer: RuntimeLayer_RtdsLayer.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuntimeLayer {
    return {
      $type: RuntimeLayer.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      layer_specifier: isSet(object.static_layer)
        ? { $case: "static_layer", static_layer: object.static_layer }
        : isSet(object.disk_layer)
        ? { $case: "disk_layer", disk_layer: RuntimeLayer_DiskLayer.fromJSON(object.disk_layer) }
        : isSet(object.admin_layer)
        ? { $case: "admin_layer", admin_layer: RuntimeLayer_AdminLayer.fromJSON(object.admin_layer) }
        : isSet(object.rtds_layer)
        ? { $case: "rtds_layer", rtds_layer: RuntimeLayer_RtdsLayer.fromJSON(object.rtds_layer) }
        : undefined,
    };
  },

  toJSON(message: RuntimeLayer): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.layer_specifier?.$case === "static_layer") {
      obj.static_layer = message.layer_specifier.static_layer;
    }
    if (message.layer_specifier?.$case === "disk_layer") {
      obj.disk_layer = RuntimeLayer_DiskLayer.toJSON(message.layer_specifier.disk_layer);
    }
    if (message.layer_specifier?.$case === "admin_layer") {
      obj.admin_layer = RuntimeLayer_AdminLayer.toJSON(message.layer_specifier.admin_layer);
    }
    if (message.layer_specifier?.$case === "rtds_layer") {
      obj.rtds_layer = RuntimeLayer_RtdsLayer.toJSON(message.layer_specifier.rtds_layer);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RuntimeLayer>, I>>(base?: I): RuntimeLayer {
    return RuntimeLayer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RuntimeLayer>, I>>(object: I): RuntimeLayer {
    const message = createBaseRuntimeLayer();
    message.name = object.name ?? undefined;
    if (
      object.layer_specifier?.$case === "static_layer" &&
      object.layer_specifier?.static_layer !== undefined &&
      object.layer_specifier?.static_layer !== null
    ) {
      message.layer_specifier = { $case: "static_layer", static_layer: object.layer_specifier.static_layer };
    }
    if (
      object.layer_specifier?.$case === "disk_layer" &&
      object.layer_specifier?.disk_layer !== undefined &&
      object.layer_specifier?.disk_layer !== null
    ) {
      message.layer_specifier = {
        $case: "disk_layer",
        disk_layer: RuntimeLayer_DiskLayer.fromPartial(object.layer_specifier.disk_layer),
      };
    }
    if (
      object.layer_specifier?.$case === "admin_layer" &&
      object.layer_specifier?.admin_layer !== undefined &&
      object.layer_specifier?.admin_layer !== null
    ) {
      message.layer_specifier = {
        $case: "admin_layer",
        admin_layer: RuntimeLayer_AdminLayer.fromPartial(object.layer_specifier.admin_layer),
      };
    }
    if (
      object.layer_specifier?.$case === "rtds_layer" &&
      object.layer_specifier?.rtds_layer !== undefined &&
      object.layer_specifier?.rtds_layer !== null
    ) {
      message.layer_specifier = {
        $case: "rtds_layer",
        rtds_layer: RuntimeLayer_RtdsLayer.fromPartial(object.layer_specifier.rtds_layer),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(RuntimeLayer.$type, RuntimeLayer);

function createBaseRuntimeLayer_DiskLayer(): RuntimeLayer_DiskLayer {
  return { $type: "envoy.config.bootstrap.v2.RuntimeLayer.DiskLayer" };
}

export const RuntimeLayer_DiskLayer: MessageFns<
  RuntimeLayer_DiskLayer,
  "envoy.config.bootstrap.v2.RuntimeLayer.DiskLayer"
> = {
  $type: "envoy.config.bootstrap.v2.RuntimeLayer.DiskLayer" as const,

  encode(message: RuntimeLayer_DiskLayer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.symlink_root !== undefined && message.symlink_root !== "") {
      writer.uint32(10).string(message.symlink_root);
    }
    if (message.subdirectory !== undefined && message.subdirectory !== "") {
      writer.uint32(26).string(message.subdirectory);
    }
    if (message.append_service_cluster !== undefined && message.append_service_cluster !== false) {
      writer.uint32(16).bool(message.append_service_cluster);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuntimeLayer_DiskLayer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuntimeLayer_DiskLayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.symlink_root = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.subdirectory = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.append_service_cluster = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuntimeLayer_DiskLayer {
    return {
      $type: RuntimeLayer_DiskLayer.$type,
      symlink_root: isSet(object.symlink_root) ? globalThis.String(object.symlink_root) : undefined,
      subdirectory: isSet(object.subdirectory) ? globalThis.String(object.subdirectory) : undefined,
      append_service_cluster: isSet(object.append_service_cluster)
        ? globalThis.Boolean(object.append_service_cluster)
        : undefined,
    };
  },

  toJSON(message: RuntimeLayer_DiskLayer): unknown {
    const obj: any = {};
    if (message.symlink_root !== undefined) {
      obj.symlink_root = message.symlink_root;
    }
    if (message.subdirectory !== undefined) {
      obj.subdirectory = message.subdirectory;
    }
    if (message.append_service_cluster !== undefined) {
      obj.append_service_cluster = message.append_service_cluster;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RuntimeLayer_DiskLayer>, I>>(base?: I): RuntimeLayer_DiskLayer {
    return RuntimeLayer_DiskLayer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RuntimeLayer_DiskLayer>, I>>(object: I): RuntimeLayer_DiskLayer {
    const message = createBaseRuntimeLayer_DiskLayer();
    message.symlink_root = object.symlink_root ?? undefined;
    message.subdirectory = object.subdirectory ?? undefined;
    message.append_service_cluster = object.append_service_cluster ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RuntimeLayer_DiskLayer.$type, RuntimeLayer_DiskLayer);

function createBaseRuntimeLayer_AdminLayer(): RuntimeLayer_AdminLayer {
  return { $type: "envoy.config.bootstrap.v2.RuntimeLayer.AdminLayer" };
}

export const RuntimeLayer_AdminLayer: MessageFns<
  RuntimeLayer_AdminLayer,
  "envoy.config.bootstrap.v2.RuntimeLayer.AdminLayer"
> = {
  $type: "envoy.config.bootstrap.v2.RuntimeLayer.AdminLayer" as const,

  encode(_: RuntimeLayer_AdminLayer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuntimeLayer_AdminLayer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuntimeLayer_AdminLayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RuntimeLayer_AdminLayer {
    return { $type: RuntimeLayer_AdminLayer.$type };
  },

  toJSON(_: RuntimeLayer_AdminLayer): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RuntimeLayer_AdminLayer>, I>>(base?: I): RuntimeLayer_AdminLayer {
    return RuntimeLayer_AdminLayer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RuntimeLayer_AdminLayer>, I>>(_: I): RuntimeLayer_AdminLayer {
    const message = createBaseRuntimeLayer_AdminLayer();
    return message;
  },
};

messageTypeRegistry.set(RuntimeLayer_AdminLayer.$type, RuntimeLayer_AdminLayer);

function createBaseRuntimeLayer_RtdsLayer(): RuntimeLayer_RtdsLayer {
  return { $type: "envoy.config.bootstrap.v2.RuntimeLayer.RtdsLayer" };
}

export const RuntimeLayer_RtdsLayer: MessageFns<
  RuntimeLayer_RtdsLayer,
  "envoy.config.bootstrap.v2.RuntimeLayer.RtdsLayer"
> = {
  $type: "envoy.config.bootstrap.v2.RuntimeLayer.RtdsLayer" as const,

  encode(message: RuntimeLayer_RtdsLayer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.rtds_config !== undefined) {
      ConfigSource.encode(message.rtds_config, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuntimeLayer_RtdsLayer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuntimeLayer_RtdsLayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rtds_config = ConfigSource.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuntimeLayer_RtdsLayer {
    return {
      $type: RuntimeLayer_RtdsLayer.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      rtds_config: isSet(object.rtds_config) ? ConfigSource.fromJSON(object.rtds_config) : undefined,
    };
  },

  toJSON(message: RuntimeLayer_RtdsLayer): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.rtds_config !== undefined) {
      obj.rtds_config = ConfigSource.toJSON(message.rtds_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RuntimeLayer_RtdsLayer>, I>>(base?: I): RuntimeLayer_RtdsLayer {
    return RuntimeLayer_RtdsLayer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RuntimeLayer_RtdsLayer>, I>>(object: I): RuntimeLayer_RtdsLayer {
    const message = createBaseRuntimeLayer_RtdsLayer();
    message.name = object.name ?? undefined;
    message.rtds_config = (object.rtds_config !== undefined && object.rtds_config !== null)
      ? ConfigSource.fromPartial(object.rtds_config)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(RuntimeLayer_RtdsLayer.$type, RuntimeLayer_RtdsLayer);

function createBaseLayeredRuntime(): LayeredRuntime {
  return { $type: "envoy.config.bootstrap.v2.LayeredRuntime" };
}

export const LayeredRuntime: MessageFns<LayeredRuntime, "envoy.config.bootstrap.v2.LayeredRuntime"> = {
  $type: "envoy.config.bootstrap.v2.LayeredRuntime" as const,

  encode(message: LayeredRuntime, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.layers !== undefined && message.layers.length !== 0) {
      for (const v of message.layers) {
        RuntimeLayer.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LayeredRuntime {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLayeredRuntime();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.layers === undefined) {
            message.layers = [];
          }
          const el = RuntimeLayer.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.layers!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LayeredRuntime {
    return {
      $type: LayeredRuntime.$type,
      layers: globalThis.Array.isArray(object?.layers)
        ? object.layers.map((e: any) => RuntimeLayer.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: LayeredRuntime): unknown {
    const obj: any = {};
    if (message.layers?.length) {
      obj.layers = message.layers.map((e) => RuntimeLayer.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LayeredRuntime>, I>>(base?: I): LayeredRuntime {
    return LayeredRuntime.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LayeredRuntime>, I>>(object: I): LayeredRuntime {
    const message = createBaseLayeredRuntime();
    message.layers = object.layers?.map((e) => RuntimeLayer.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(LayeredRuntime.$type, LayeredRuntime);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
