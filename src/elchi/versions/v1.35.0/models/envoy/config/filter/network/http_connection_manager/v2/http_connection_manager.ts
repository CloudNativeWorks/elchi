// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/config/filter/network/http_connection_manager/v2/http_connection_manager.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Any } from "../../../../../../google/protobuf/any";
import { Duration } from "../../../../../../google/protobuf/duration";
import { Struct } from "../../../../../../google/protobuf/struct";
import { BoolValue, UInt32Value } from "../../../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../../../typeRegistry";
import { ConfigSource } from "../../../../../api/v2/core/config_source";
import { Http1ProtocolOptions, Http2ProtocolOptions, HttpProtocolOptions } from "../../../../../api/v2/core/protocol";
import { RouteConfiguration } from "../../../../../api/v2/route";
import { ScopedRouteConfiguration } from "../../../../../api/v2/scoped_route";
import { Percent } from "../../../../../type/percent";
import { CustomTag } from "../../../../../type/tracing/v2/custom_tag";
import { Tracing_Http } from "../../../../trace/v2/http_tracer";
import { AccessLog } from "../../../accesslog/v2/accesslog";

export const protobufPackage = "envoy.config.filter.network.http_connection_manager.v2";

/** [#next-free-field: 37] */
export interface HttpConnectionManager {
  $type: "envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager";
  /** Supplies the type of codec that the connection manager should use. */
  codec_type?:
    | HttpConnectionManager_CodecType
    | undefined;
  /**
   * The human readable prefix to use when emitting statistics for the
   * connection manager. See the :ref:`statistics documentation <config_http_conn_man_stats>` for
   * more information.
   */
  stat_prefix?: string | undefined;
  route_specifier?:
    | //
    /** The connection manager’s route table will be dynamically loaded via the RDS API. */
    { $case: "rds"; rds: Rds }
    | //
    /** The route table for the connection manager is static and is specified in this property. */
    { $case: "route_config"; route_config: RouteConfiguration }
    | //
    /**
     * A route table will be dynamically assigned to each request based on request attributes
     * (e.g., the value of a header). The "routing scopes" (i.e., route tables) and "scope keys" are
     * specified in this message.
     */
    { $case: "scoped_routes"; scoped_routes: ScopedRoutes }
    | undefined;
  /**
   * A list of individual HTTP filters that make up the filter chain for
   * requests made to the connection manager. :ref:`Order matters <arch_overview_http_filters_ordering>`
   * as the filters are processed sequentially as request events happen.
   */
  http_filters?:
    | HttpFilter[]
    | undefined;
  /**
   * Whether the connection manager manipulates the :ref:`config_http_conn_man_headers_user-agent`
   * and :ref:`config_http_conn_man_headers_downstream-service-cluster` headers. See the linked
   * documentation for more information. Defaults to false.
   */
  add_user_agent?:
    | boolean
    | undefined;
  /**
   * Presence of the object defines whether the connection manager
   * emits :ref:`tracing <arch_overview_tracing>` data to the :ref:`configured tracing provider
   * <envoy_api_msg_config.trace.v2.Tracing>`.
   */
  tracing?:
    | HttpConnectionManager_Tracing
    | undefined;
  /**
   * Additional settings for HTTP requests handled by the connection manager. These will be
   * applicable to both HTTP1 and HTTP2 requests.
   */
  common_http_protocol_options?:
    | HttpProtocolOptions
    | undefined;
  /** Additional HTTP/1 settings that are passed to the HTTP/1 codec. */
  http_protocol_options?:
    | Http1ProtocolOptions
    | undefined;
  /** Additional HTTP/2 settings that are passed directly to the HTTP/2 codec. */
  http2_protocol_options?:
    | Http2ProtocolOptions
    | undefined;
  /**
   * An optional override that the connection manager will write to the server
   * header in responses. If not set, the default is *envoy*.
   */
  server_name?:
    | string
    | undefined;
  /**
   * Defines the action to be applied to the Server header on the response path.
   * By default, Envoy will overwrite the header with the value specified in
   * server_name.
   */
  server_header_transformation?:
    | HttpConnectionManager_ServerHeaderTransformation
    | undefined;
  /**
   * The maximum request headers size for incoming connections.
   * If unconfigured, the default max request headers allowed is 60 KiB.
   * Requests that exceed this limit will receive a 431 response.
   */
  max_request_headers_kb?:
    | number
    | undefined;
  /**
   * The idle timeout for connections managed by the connection manager. The
   * idle timeout is defined as the period in which there are no active
   * requests. If not set, there is no idle timeout. When the idle timeout is
   * reached the connection will be closed. If the connection is an HTTP/2
   * connection a drain sequence will occur prior to closing the connection.
   * This field is deprecated. Use :ref:`idle_timeout
   * <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.common_http_protocol_options>`
   * instead.
   *
   * @deprecated
   */
  idle_timeout?:
    | Duration
    | undefined;
  /**
   * The stream idle timeout for connections managed by the connection manager.
   * If not specified, this defaults to 5 minutes. The default value was selected
   * so as not to interfere with any smaller configured timeouts that may have
   * existed in configurations prior to the introduction of this feature, while
   * introducing robustness to TCP connections that terminate without a FIN.
   *
   * This idle timeout applies to new streams and is overridable by the
   * :ref:`route-level idle_timeout
   * <envoy_api_field_route.RouteAction.idle_timeout>`. Even on a stream in
   * which the override applies, prior to receipt of the initial request
   * headers, the :ref:`stream_idle_timeout
   * <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.stream_idle_timeout>`
   * applies. Each time an encode/decode event for headers or data is processed
   * for the stream, the timer will be reset. If the timeout fires, the stream
   * is terminated with a 408 Request Timeout error code if no upstream response
   * header has been received, otherwise a stream reset occurs.
   *
   * This timeout also specifies the amount of time that Envoy will wait for the peer to open enough
   * window to write any remaining stream data once the entirety of stream data (local end stream is
   * true) has been buffered pending available window. In other words, this timeout defends against
   * a peer that does not release enough window to completely write the stream, even though all
   * data has been proxied within available flow control windows. If the timeout is hit in this
   * case, the :ref:`tx_flush_timeout <config_http_conn_man_stats_per_codec>` counter will be
   * incremented. Note that :ref:`max_stream_duration
   * <envoy_api_field_core.HttpProtocolOptions.max_stream_duration>` does not apply to this corner
   * case.
   *
   * Note that it is possible to idle timeout even if the wire traffic for a stream is non-idle, due
   * to the granularity of events presented to the connection manager. For example, while receiving
   * very large request headers, it may be the case that there is traffic regularly arriving on the
   * wire while the connection manage is only able to observe the end-of-headers event, hence the
   * stream may still idle timeout.
   *
   * A value of 0 will completely disable the connection manager stream idle
   * timeout, although per-route idle timeout overrides will continue to apply.
   */
  stream_idle_timeout?:
    | Duration
    | undefined;
  /**
   * The amount of time that Envoy will wait for the entire request to be received.
   * The timer is activated when the request is initiated, and is disarmed when the last byte of the
   * request is sent upstream (i.e. all decoding filters have processed the request), OR when the
   * response is initiated. If not specified or set to 0, this timeout is disabled.
   */
  request_timeout?:
    | Duration
    | undefined;
  /**
   * The time that Envoy will wait between sending an HTTP/2 “shutdown
   * notification” (GOAWAY frame with max stream ID) and a final GOAWAY frame.
   * This is used so that Envoy provides a grace period for new streams that
   * race with the final GOAWAY frame. During this grace period, Envoy will
   * continue to accept new streams. After the grace period, a final GOAWAY
   * frame is sent and Envoy will start refusing new streams. Draining occurs
   * both when a connection hits the idle timeout or during general server
   * draining. The default grace period is 5000 milliseconds (5 seconds) if this
   * option is not specified.
   */
  drain_timeout?:
    | Duration
    | undefined;
  /**
   * The delayed close timeout is for downstream connections managed by the HTTP connection manager.
   * It is defined as a grace period after connection close processing has been locally initiated
   * during which Envoy will wait for the peer to close (i.e., a TCP FIN/RST is received by Envoy
   * from the downstream connection) prior to Envoy closing the socket associated with that
   * connection.
   * NOTE: This timeout is enforced even when the socket associated with the downstream connection
   * is pending a flush of the write buffer. However, any progress made writing data to the socket
   * will restart the timer associated with this timeout. This means that the total grace period for
   * a socket in this state will be
   * <total_time_waiting_for_write_buffer_flushes>+<delayed_close_timeout>.
   *
   * Delaying Envoy's connection close and giving the peer the opportunity to initiate the close
   * sequence mitigates a race condition that exists when downstream clients do not drain/process
   * data in a connection's receive buffer after a remote close has been detected via a socket
   * write(). This race leads to such clients failing to process the response code sent by Envoy,
   * which could result in erroneous downstream processing.
   *
   * If the timeout triggers, Envoy will close the connection's socket.
   *
   * The default timeout is 1000 ms if this option is not specified.
   *
   * .. NOTE::
   *    To be useful in avoiding the race condition described above, this timeout must be set
   *    to *at least* <max round trip time expected between clients and Envoy>+<100ms to account for
   *    a reasonable "worst" case processing time for a full iteration of Envoy's event loop>.
   *
   * .. WARNING::
   *    A value of 0 will completely disable delayed close processing. When disabled, the downstream
   *    connection's socket will be closed immediately after the write flush is completed or will
   *    never close if the write flush does not complete.
   */
  delayed_close_timeout?:
    | Duration
    | undefined;
  /**
   * Configuration for :ref:`HTTP access logs <arch_overview_access_logs>`
   * emitted by the connection manager.
   */
  access_log?:
    | AccessLog[]
    | undefined;
  /**
   * If set to true, the connection manager will use the real remote address
   * of the client connection when determining internal versus external origin and manipulating
   * various headers. If set to false or absent, the connection manager will use the
   * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. See the documentation for
   * :ref:`config_http_conn_man_headers_x-forwarded-for`,
   * :ref:`config_http_conn_man_headers_x-envoy-internal`, and
   * :ref:`config_http_conn_man_headers_x-envoy-external-address` for more information.
   */
  use_remote_address?:
    | boolean
    | undefined;
  /**
   * The number of additional ingress proxy hops from the right side of the
   * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header to trust when
   * determining the origin client's IP address. The default is zero if this option
   * is not specified. See the documentation for
   * :ref:`config_http_conn_man_headers_x-forwarded-for` for more information.
   */
  xff_num_trusted_hops?:
    | number
    | undefined;
  /**
   * Configures what network addresses are considered internal for stats and header sanitation
   * purposes. If unspecified, only RFC1918 IP addresses will be considered internal.
   * See the documentation for :ref:`config_http_conn_man_headers_x-envoy-internal` for more
   * information about internal/external addresses.
   */
  internal_address_config?:
    | HttpConnectionManager_InternalAddressConfig
    | undefined;
  /**
   * If set, Envoy will not append the remote address to the
   * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. This may be used in
   * conjunction with HTTP filters that explicitly manipulate XFF after the HTTP connection manager
   * has mutated the request headers. While :ref:`use_remote_address
   * <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.use_remote_address>`
   * will also suppress XFF addition, it has consequences for logging and other
   * Envoy uses of the remote address, so *skip_xff_append* should be used
   * when only an elision of XFF addition is intended.
   */
  skip_xff_append?:
    | boolean
    | undefined;
  /**
   * Via header value to append to request and response headers. If this is
   * empty, no via header will be appended.
   */
  via?:
    | string
    | undefined;
  /**
   * Whether the connection manager will generate the :ref:`x-request-id
   * <config_http_conn_man_headers_x-request-id>` header if it does not exist. This defaults to
   * true. Generating a random UUID4 is expensive so in high throughput scenarios where this feature
   * is not desired it can be disabled.
   */
  generate_request_id?:
    | boolean
    | undefined;
  /**
   * Whether the connection manager will keep the :ref:`x-request-id
   * <config_http_conn_man_headers_x-request-id>` header if passed for a request that is edge
   * (Edge request is the request from external clients to front Envoy) and not reset it, which
   * is the current Envoy behaviour. This defaults to false.
   */
  preserve_external_request_id?:
    | boolean
    | undefined;
  /**
   * How to handle the :ref:`config_http_conn_man_headers_x-forwarded-client-cert` (XFCC) HTTP
   * header.
   */
  forward_client_cert_details?:
    | HttpConnectionManager_ForwardClientCertDetails
    | undefined;
  /**
   * This field is valid only when :ref:`forward_client_cert_details
   * <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.forward_client_cert_details>`
   * is APPEND_FORWARD or SANITIZE_SET and the client connection is mTLS. It specifies the fields in
   * the client certificate to be forwarded. Note that in the
   * :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header, *Hash* is always set, and
   * *By* is always set when the client certificate presents the URI type Subject Alternative Name
   * value.
   */
  set_current_client_cert_details?:
    | HttpConnectionManager_SetCurrentClientCertDetails
    | undefined;
  /**
   * If proxy_100_continue is true, Envoy will proxy incoming "Expect:
   * 100-continue" headers upstream, and forward "100 Continue" responses
   * downstream. If this is false or not set, Envoy will instead strip the
   * "Expect: 100-continue" header, and send a "100 Continue" response itself.
   */
  proxy_100_continue?:
    | boolean
    | undefined;
  /**
   * If
   * :ref:`use_remote_address
   * <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.use_remote_address>`
   * is true and represent_ipv4_remote_address_as_ipv4_mapped_ipv6 is true and the remote address is
   * an IPv4 address, the address will be mapped to IPv6 before it is appended to *x-forwarded-for*.
   * This is useful for testing compatibility of upstream services that parse the header value. For
   * example, 50.0.0.1 is represented as ::FFFF:50.0.0.1. See `IPv4-Mapped IPv6 Addresses
   * <https://tools.ietf.org/html/rfc4291#section-2.5.5.2>`_ for details. This will also affect the
   * :ref:`config_http_conn_man_headers_x-envoy-external-address` header. See
   * :ref:`http_connection_manager.represent_ipv4_remote_address_as_ipv4_mapped_ipv6
   * <config_http_conn_man_runtime_represent_ipv4_remote_address_as_ipv4_mapped_ipv6>` for runtime
   * control.
   * [#not-implemented-hide:]
   */
  represent_ipv4_remote_address_as_ipv4_mapped_ipv6?: boolean | undefined;
  upgrade_configs?:
    | HttpConnectionManager_UpgradeConfig[]
    | undefined;
  /**
   * Should paths be normalized according to RFC 3986 before any processing of
   * requests by HTTP filters or routing? This affects the upstream *:path* header
   * as well. For paths that fail this check, Envoy will respond with 400 to
   * paths that are malformed. This defaults to false currently but will default
   * true in the future. When not specified, this value may be overridden by the
   * runtime variable
   * :ref:`http_connection_manager.normalize_path<config_http_conn_man_runtime_normalize_path>`.
   * See `Normalization and Comparison <https://tools.ietf.org/html/rfc3986#section-6>`_
   * for details of normalization.
   * Note that Envoy does not perform
   * `case normalization <https://tools.ietf.org/html/rfc3986#section-6.2.2.1>`_
   */
  normalize_path?:
    | boolean
    | undefined;
  /**
   * Determines if adjacent slashes in the path are merged into one before any processing of
   * requests by HTTP filters or routing. This affects the upstream *:path* header as well. Without
   * setting this option, incoming requests with path `//dir///file` will not match against route
   * with `prefix` match set to `/dir`. Defaults to `false`. Note that slash merging is not part of
   * `HTTP spec <https://tools.ietf.org/html/rfc3986>`_ and is provided for convenience.
   */
  merge_slashes?:
    | boolean
    | undefined;
  /**
   * The configuration of the request ID extension. This includes operations such as
   * generation, validation, and associated tracing operations.
   *
   * If not set, Envoy uses the default UUID-based behavior:
   *
   * 1. Request ID is propagated using *x-request-id* header.
   *
   * 2. Request ID is a universally unique identifier (UUID).
   *
   * 3. Tracing decision (sampled, forced, etc) is set in 14th byte of the UUID.
   */
  request_id_extension?: RequestIDExtension | undefined;
}

export enum HttpConnectionManager_CodecType {
  /**
   * AUTO - For every new connection, the connection manager will determine which
   * codec to use. This mode supports both ALPN for TLS listeners as well as
   * protocol inference for plaintext listeners. If ALPN data is available, it
   * is preferred, otherwise protocol inference is used. In almost all cases,
   * this is the right option to choose for this setting.
   */
  AUTO = "AUTO",
  /** HTTP1 - The connection manager will assume that the client is speaking HTTP/1.1. */
  HTTP1 = "HTTP1",
  /**
   * HTTP2 - The connection manager will assume that the client is speaking HTTP/2
   * (Envoy does not require HTTP/2 to take place over TLS or to use ALPN.
   * Prior knowledge is allowed).
   */
  HTTP2 = "HTTP2",
  /**
   * HTTP3 - [#not-implemented-hide:] QUIC implementation is not production ready yet. Use this enum with
   * caution to prevent accidental execution of QUIC code. I.e. `!= HTTP2` is no longer sufficient
   * to distinguish HTTP1 and HTTP2 traffic.
   */
  HTTP3 = "HTTP3",
}

export function httpConnectionManager_CodecTypeFromJSON(object: any): HttpConnectionManager_CodecType {
  switch (object) {
    case 0:
    case "AUTO":
      return HttpConnectionManager_CodecType.AUTO;
    case 1:
    case "HTTP1":
      return HttpConnectionManager_CodecType.HTTP1;
    case 2:
    case "HTTP2":
      return HttpConnectionManager_CodecType.HTTP2;
    case 3:
    case "HTTP3":
      return HttpConnectionManager_CodecType.HTTP3;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum HttpConnectionManager_CodecType");
  }
}

export function httpConnectionManager_CodecTypeToJSON(object: HttpConnectionManager_CodecType): string {
  switch (object) {
    case HttpConnectionManager_CodecType.AUTO:
      return "AUTO";
    case HttpConnectionManager_CodecType.HTTP1:
      return "HTTP1";
    case HttpConnectionManager_CodecType.HTTP2:
      return "HTTP2";
    case HttpConnectionManager_CodecType.HTTP3:
      return "HTTP3";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum HttpConnectionManager_CodecType");
  }
}

export function httpConnectionManager_CodecTypeToNumber(object: HttpConnectionManager_CodecType): number {
  switch (object) {
    case HttpConnectionManager_CodecType.AUTO:
      return 0;
    case HttpConnectionManager_CodecType.HTTP1:
      return 1;
    case HttpConnectionManager_CodecType.HTTP2:
      return 2;
    case HttpConnectionManager_CodecType.HTTP3:
      return 3;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum HttpConnectionManager_CodecType");
  }
}

export enum HttpConnectionManager_ServerHeaderTransformation {
  /** OVERWRITE - Overwrite any Server header with the contents of server_name. */
  OVERWRITE = "OVERWRITE",
  /**
   * APPEND_IF_ABSENT - If no Server header is present, append Server server_name
   * If a Server header is present, pass it through.
   */
  APPEND_IF_ABSENT = "APPEND_IF_ABSENT",
  /**
   * PASS_THROUGH - Pass through the value of the server header, and do not append a header
   * if none is present.
   */
  PASS_THROUGH = "PASS_THROUGH",
}

export function httpConnectionManager_ServerHeaderTransformationFromJSON(
  object: any,
): HttpConnectionManager_ServerHeaderTransformation {
  switch (object) {
    case 0:
    case "OVERWRITE":
      return HttpConnectionManager_ServerHeaderTransformation.OVERWRITE;
    case 1:
    case "APPEND_IF_ABSENT":
      return HttpConnectionManager_ServerHeaderTransformation.APPEND_IF_ABSENT;
    case 2:
    case "PASS_THROUGH":
      return HttpConnectionManager_ServerHeaderTransformation.PASS_THROUGH;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum HttpConnectionManager_ServerHeaderTransformation",
      );
  }
}

export function httpConnectionManager_ServerHeaderTransformationToJSON(
  object: HttpConnectionManager_ServerHeaderTransformation,
): string {
  switch (object) {
    case HttpConnectionManager_ServerHeaderTransformation.OVERWRITE:
      return "OVERWRITE";
    case HttpConnectionManager_ServerHeaderTransformation.APPEND_IF_ABSENT:
      return "APPEND_IF_ABSENT";
    case HttpConnectionManager_ServerHeaderTransformation.PASS_THROUGH:
      return "PASS_THROUGH";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum HttpConnectionManager_ServerHeaderTransformation",
      );
  }
}

export function httpConnectionManager_ServerHeaderTransformationToNumber(
  object: HttpConnectionManager_ServerHeaderTransformation,
): number {
  switch (object) {
    case HttpConnectionManager_ServerHeaderTransformation.OVERWRITE:
      return 0;
    case HttpConnectionManager_ServerHeaderTransformation.APPEND_IF_ABSENT:
      return 1;
    case HttpConnectionManager_ServerHeaderTransformation.PASS_THROUGH:
      return 2;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum HttpConnectionManager_ServerHeaderTransformation",
      );
  }
}

/**
 * How to handle the :ref:`config_http_conn_man_headers_x-forwarded-client-cert` (XFCC) HTTP
 * header.
 */
export enum HttpConnectionManager_ForwardClientCertDetails {
  /** SANITIZE - Do not send the XFCC header to the next hop. This is the default value. */
  SANITIZE = "SANITIZE",
  /**
   * FORWARD_ONLY - When the client connection is mTLS (Mutual TLS), forward the XFCC header
   * in the request.
   */
  FORWARD_ONLY = "FORWARD_ONLY",
  /**
   * APPEND_FORWARD - When the client connection is mTLS, append the client certificate
   * information to the request’s XFCC header and forward it.
   */
  APPEND_FORWARD = "APPEND_FORWARD",
  /**
   * SANITIZE_SET - When the client connection is mTLS, reset the XFCC header with the client
   * certificate information and send it to the next hop.
   */
  SANITIZE_SET = "SANITIZE_SET",
  /**
   * ALWAYS_FORWARD_ONLY - Always forward the XFCC header in the request, regardless of whether the
   * client connection is mTLS.
   */
  ALWAYS_FORWARD_ONLY = "ALWAYS_FORWARD_ONLY",
}

export function httpConnectionManager_ForwardClientCertDetailsFromJSON(
  object: any,
): HttpConnectionManager_ForwardClientCertDetails {
  switch (object) {
    case 0:
    case "SANITIZE":
      return HttpConnectionManager_ForwardClientCertDetails.SANITIZE;
    case 1:
    case "FORWARD_ONLY":
      return HttpConnectionManager_ForwardClientCertDetails.FORWARD_ONLY;
    case 2:
    case "APPEND_FORWARD":
      return HttpConnectionManager_ForwardClientCertDetails.APPEND_FORWARD;
    case 3:
    case "SANITIZE_SET":
      return HttpConnectionManager_ForwardClientCertDetails.SANITIZE_SET;
    case 4:
    case "ALWAYS_FORWARD_ONLY":
      return HttpConnectionManager_ForwardClientCertDetails.ALWAYS_FORWARD_ONLY;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum HttpConnectionManager_ForwardClientCertDetails",
      );
  }
}

export function httpConnectionManager_ForwardClientCertDetailsToJSON(
  object: HttpConnectionManager_ForwardClientCertDetails,
): string {
  switch (object) {
    case HttpConnectionManager_ForwardClientCertDetails.SANITIZE:
      return "SANITIZE";
    case HttpConnectionManager_ForwardClientCertDetails.FORWARD_ONLY:
      return "FORWARD_ONLY";
    case HttpConnectionManager_ForwardClientCertDetails.APPEND_FORWARD:
      return "APPEND_FORWARD";
    case HttpConnectionManager_ForwardClientCertDetails.SANITIZE_SET:
      return "SANITIZE_SET";
    case HttpConnectionManager_ForwardClientCertDetails.ALWAYS_FORWARD_ONLY:
      return "ALWAYS_FORWARD_ONLY";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum HttpConnectionManager_ForwardClientCertDetails",
      );
  }
}

export function httpConnectionManager_ForwardClientCertDetailsToNumber(
  object: HttpConnectionManager_ForwardClientCertDetails,
): number {
  switch (object) {
    case HttpConnectionManager_ForwardClientCertDetails.SANITIZE:
      return 0;
    case HttpConnectionManager_ForwardClientCertDetails.FORWARD_ONLY:
      return 1;
    case HttpConnectionManager_ForwardClientCertDetails.APPEND_FORWARD:
      return 2;
    case HttpConnectionManager_ForwardClientCertDetails.SANITIZE_SET:
      return 3;
    case HttpConnectionManager_ForwardClientCertDetails.ALWAYS_FORWARD_ONLY:
      return 4;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum HttpConnectionManager_ForwardClientCertDetails",
      );
  }
}

/** [#next-free-field: 10] */
export interface HttpConnectionManager_Tracing {
  $type: "envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager.Tracing";
  /**
   * The span name will be derived from this field. If
   * :ref:`traffic_direction <envoy_api_field_Listener.traffic_direction>` is
   * specified on the parent listener, then it is used instead of this field.
   *
   * .. attention::
   *  This field has been deprecated in favor of `traffic_direction`.
   *
   * @deprecated
   */
  operation_name?:
    | HttpConnectionManager_Tracing_OperationName
    | undefined;
  /**
   * A list of header names used to create tags for the active span. The header name is used to
   * populate the tag name, and the header value is used to populate the tag value. The tag is
   * created if the specified header name is present in the request's headers.
   *
   * .. attention::
   *  This field has been deprecated in favor of :ref:`custom_tags
   *  <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.tracing.custom_tags>`.
   *
   * @deprecated
   */
  request_headers_for_tags?:
    | string[]
    | undefined;
  /**
   * Target percentage of requests managed by this HTTP connection manager that will be force
   * traced if the :ref:`x-client-trace-id <config_http_conn_man_headers_x-client-trace-id>`
   * header is set. This field is a direct analog for the runtime variable
   * 'tracing.client_enabled' in the :ref:`HTTP Connection Manager
   * <config_http_conn_man_runtime>`.
   * Default: 100%
   */
  client_sampling?:
    | Percent
    | undefined;
  /**
   * Target percentage of requests managed by this HTTP connection manager that will be randomly
   * selected for trace generation, if not requested by the client or not forced. This field is
   * a direct analog for the runtime variable 'tracing.random_sampling' in the
   * :ref:`HTTP Connection Manager <config_http_conn_man_runtime>`.
   * Default: 100%
   */
  random_sampling?:
    | Percent
    | undefined;
  /**
   * Target percentage of requests managed by this HTTP connection manager that will be traced
   * after all other sampling checks have been applied (client-directed, force tracing, random
   * sampling). This field functions as an upper limit on the total configured sampling rate. For
   * instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
   * of client requests with the appropriate headers to be force traced. This field is a direct
   * analog for the runtime variable 'tracing.global_enabled' in the
   * :ref:`HTTP Connection Manager <config_http_conn_man_runtime>`.
   * Default: 100%
   */
  overall_sampling?:
    | Percent
    | undefined;
  /**
   * Whether to annotate spans with additional data. If true, spans will include logs for stream
   * events.
   */
  verbose?:
    | boolean
    | undefined;
  /**
   * Maximum length of the request path to extract and include in the HttpUrl tag. Used to
   * truncate lengthy request paths to meet the needs of a tracing backend.
   * Default: 256
   */
  max_path_tag_length?:
    | number
    | undefined;
  /** A list of custom tags with unique tag name to create tags for the active span. */
  custom_tags?:
    | CustomTag[]
    | undefined;
  /**
   * Configuration for an external tracing provider.
   * If not specified, no tracing will be performed.
   */
  provider?: Tracing_Http | undefined;
}

export enum HttpConnectionManager_Tracing_OperationName {
  /** INGRESS - The HTTP listener is used for ingress/incoming requests. */
  INGRESS = "INGRESS",
  /** EGRESS - The HTTP listener is used for egress/outgoing requests. */
  EGRESS = "EGRESS",
}

export function httpConnectionManager_Tracing_OperationNameFromJSON(
  object: any,
): HttpConnectionManager_Tracing_OperationName {
  switch (object) {
    case 0:
    case "INGRESS":
      return HttpConnectionManager_Tracing_OperationName.INGRESS;
    case 1:
    case "EGRESS":
      return HttpConnectionManager_Tracing_OperationName.EGRESS;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum HttpConnectionManager_Tracing_OperationName",
      );
  }
}

export function httpConnectionManager_Tracing_OperationNameToJSON(
  object: HttpConnectionManager_Tracing_OperationName,
): string {
  switch (object) {
    case HttpConnectionManager_Tracing_OperationName.INGRESS:
      return "INGRESS";
    case HttpConnectionManager_Tracing_OperationName.EGRESS:
      return "EGRESS";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum HttpConnectionManager_Tracing_OperationName",
      );
  }
}

export function httpConnectionManager_Tracing_OperationNameToNumber(
  object: HttpConnectionManager_Tracing_OperationName,
): number {
  switch (object) {
    case HttpConnectionManager_Tracing_OperationName.INGRESS:
      return 0;
    case HttpConnectionManager_Tracing_OperationName.EGRESS:
      return 1;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum HttpConnectionManager_Tracing_OperationName",
      );
  }
}

export interface HttpConnectionManager_InternalAddressConfig {
  $type: "envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager.InternalAddressConfig";
  /** Whether unix socket addresses should be considered internal. */
  unix_sockets?: boolean | undefined;
}

/** [#next-free-field: 7] */
export interface HttpConnectionManager_SetCurrentClientCertDetails {
  $type: "envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager.SetCurrentClientCertDetails";
  /** Whether to forward the subject of the client cert. Defaults to false. */
  subject?:
    | boolean
    | undefined;
  /**
   * Whether to forward the entire client cert in URL encoded PEM format. This will appear in the
   * XFCC header comma separated from other values with the value Cert="PEM".
   * Defaults to false.
   */
  cert?:
    | boolean
    | undefined;
  /**
   * Whether to forward the entire client cert chain (including the leaf cert) in URL encoded PEM
   * format. This will appear in the XFCC header comma separated from other values with the value
   * Chain="PEM".
   * Defaults to false.
   */
  chain?:
    | boolean
    | undefined;
  /**
   * Whether to forward the DNS type Subject Alternative Names of the client cert.
   * Defaults to false.
   */
  dns?:
    | boolean
    | undefined;
  /**
   * Whether to forward the URI type Subject Alternative Name of the client cert. Defaults to
   * false.
   */
  uri?: boolean | undefined;
}

/**
 * The configuration for HTTP upgrades.
 * For each upgrade type desired, an UpgradeConfig must be added.
 *
 * .. warning::
 *
 *    The current implementation of upgrade headers does not handle
 *    multi-valued upgrade headers. Support for multi-valued headers may be
 *    added in the future if needed.
 *
 * .. warning::
 *    The current implementation of upgrade headers does not work with HTTP/2
 *    upstreams.
 */
export interface HttpConnectionManager_UpgradeConfig {
  $type: "envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager.UpgradeConfig";
  /**
   * The case-insensitive name of this upgrade, e.g. "websocket".
   * For each upgrade type present in upgrade_configs, requests with
   * Upgrade: [upgrade_type]
   * will be proxied upstream.
   */
  upgrade_type?:
    | string
    | undefined;
  /**
   * If present, this represents the filter chain which will be created for
   * this type of upgrade. If no filters are present, the filter chain for
   * HTTP connections will be used for this upgrade type.
   */
  filters?:
    | HttpFilter[]
    | undefined;
  /**
   * Determines if upgrades are enabled or disabled by default. Defaults to true.
   * This can be overridden on a per-route basis with :ref:`cluster
   * <envoy_api_field_route.RouteAction.upgrade_configs>` as documented in the
   * :ref:`upgrade documentation <arch_overview_upgrades>`.
   */
  enabled?: boolean | undefined;
}

export interface Rds {
  $type: "envoy.config.filter.network.http_connection_manager.v2.Rds";
  /** Configuration source specifier for RDS. */
  config_source?:
    | ConfigSource
    | undefined;
  /**
   * The name of the route configuration. This name will be passed to the RDS
   * API. This allows an Envoy configuration with multiple HTTP listeners (and
   * associated HTTP connection manager filters) to use different route
   * configurations.
   */
  route_config_name?: string | undefined;
}

/** This message is used to work around the limitations with 'oneof' and repeated fields. */
export interface ScopedRouteConfigurationsList {
  $type: "envoy.config.filter.network.http_connection_manager.v2.ScopedRouteConfigurationsList";
  scoped_route_configurations?: ScopedRouteConfiguration[] | undefined;
}

/** [#next-free-field: 6] */
export interface ScopedRoutes {
  $type: "envoy.config.filter.network.http_connection_manager.v2.ScopedRoutes";
  /** The name assigned to the scoped routing configuration. */
  name?:
    | string
    | undefined;
  /** The algorithm to use for constructing a scope key for each request. */
  scope_key_builder?:
    | ScopedRoutes_ScopeKeyBuilder
    | undefined;
  /**
   * Configuration source specifier for RDS.
   * This config source is used to subscribe to RouteConfiguration resources specified in
   * ScopedRouteConfiguration messages.
   */
  rds_config_source?: ConfigSource | undefined;
  config_specifier?:
    | //
    /**
     * The set of routing scopes corresponding to the HCM. A scope is assigned to a request by
     * matching a key constructed from the request's attributes according to the algorithm specified
     * by the
     * :ref:`ScopeKeyBuilder<envoy_api_msg_config.filter.network.http_connection_manager.v2.ScopedRoutes.ScopeKeyBuilder>`
     * in this message.
     */
    { $case: "scoped_route_configurations_list"; scoped_route_configurations_list: ScopedRouteConfigurationsList }
    | //
    /**
     * The set of routing scopes associated with the HCM will be dynamically loaded via the SRDS
     * API. A scope is assigned to a request by matching a key constructed from the request's
     * attributes according to the algorithm specified by the
     * :ref:`ScopeKeyBuilder<envoy_api_msg_config.filter.network.http_connection_manager.v2.ScopedRoutes.ScopeKeyBuilder>`
     * in this message.
     */
    { $case: "scoped_rds"; scoped_rds: ScopedRds }
    | undefined;
}

/**
 * Specifies the mechanism for constructing "scope keys" based on HTTP request attributes. These
 * keys are matched against a set of :ref:`Key<envoy_api_msg_ScopedRouteConfiguration.Key>`
 * objects assembled from :ref:`ScopedRouteConfiguration<envoy_api_msg_ScopedRouteConfiguration>`
 * messages distributed via SRDS (the Scoped Route Discovery Service) or assigned statically via
 * :ref:`scoped_route_configurations_list<envoy_api_field_config.filter.network.http_connection_manager.v2.ScopedRoutes.scoped_route_configurations_list>`.
 *
 * Upon receiving a request's headers, the Router will build a key using the algorithm specified
 * by this message. This key will be used to look up the routing table (i.e., the
 * :ref:`RouteConfiguration<envoy_api_msg_RouteConfiguration>`) to use for the request.
 */
export interface ScopedRoutes_ScopeKeyBuilder {
  $type: "envoy.config.filter.network.http_connection_manager.v2.ScopedRoutes.ScopeKeyBuilder";
  /**
   * The final(built) scope key consists of the ordered union of these fragments, which are compared in order with the
   * fragments of a :ref:`ScopedRouteConfiguration<envoy_api_msg_ScopedRouteConfiguration>`.
   * A missing fragment during comparison will make the key invalid, i.e., the computed key doesn't match any key.
   */
  fragments?: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder[] | undefined;
}

/** Specifies the mechanism for constructing key fragments which are composed into scope keys. */
export interface ScopedRoutes_ScopeKeyBuilder_FragmentBuilder {
  $type: "envoy.config.filter.network.http_connection_manager.v2.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder";
  type?:
    | //
    /** Specifies how a header field's value should be extracted. */
    {
      $case: "header_value_extractor";
      header_value_extractor: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor;
    }
    | undefined;
}

/**
 * Specifies how the value of a header should be extracted.
 * The following example maps the structure of a header to the fields in this message.
 *
 * .. code::
 *
 *              <0> <1>   <-- index
 *    X-Header: a=b;c=d
 *    |         || |
 *    |         || \----> <element_separator>
 *    |         ||
 *    |         |\----> <element.separator>
 *    |         |
 *    |         \----> <element.key>
 *    |
 *    \----> <name>
 *
 *    Each 'a=b' key-value pair constitutes an 'element' of the header field.
 */
export interface ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor {
  $type:
    "envoy.config.filter.network.http_connection_manager.v2.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor";
  /**
   * The name of the header field to extract the value from.
   *
   * .. note::
   *
   *   If the header appears multiple times only the first value is used.
   */
  name?:
    | string
    | undefined;
  /**
   * The element separator (e.g., ';' separates 'a;b;c;d').
   * Default: empty string. This causes the entirety of the header field to be extracted.
   * If this field is set to an empty string and 'index' is used in the oneof below, 'index'
   * must be set to 0.
   */
  element_separator?: string | undefined;
  extract_type?:
    | //
    /**
     * Specifies the zero based index of the element to extract.
     * Note Envoy concatenates multiple values of the same header key into a comma separated
     * string, the splitting always happens after the concatenation.
     */
    { $case: "index"; index: number }
    | //
    /** Specifies the key value pair to extract the value from. */
    { $case: "element"; element: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement }
    | undefined;
}

/** Specifies a header field's key value pair to match on. */
export interface ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement {
  $type:
    "envoy.config.filter.network.http_connection_manager.v2.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor.KvElement";
  /**
   * The separator between key and value (e.g., '=' separates 'k=v;...').
   * If an element is an empty string, the element is ignored.
   * If an element contains no separator, the whole element is parsed as key and the
   * fragment value is an empty string.
   * If there are multiple values for a matched key, the first value is returned.
   */
  separator?:
    | string
    | undefined;
  /** The key to match on. */
  key?: string | undefined;
}

export interface ScopedRds {
  $type: "envoy.config.filter.network.http_connection_manager.v2.ScopedRds";
  /** Configuration source specifier for scoped RDS. */
  scoped_rds_config_source?: ConfigSource | undefined;
}

export interface HttpFilter {
  $type: "envoy.config.filter.network.http_connection_manager.v2.HttpFilter";
  /**
   * The name of the filter to instantiate. The name must match a
   * :ref:`supported filter <config_http_filters>`.
   */
  name?:
    | string
    | undefined;
  /**
   * Filter specific configuration which depends on the filter being instantiated. See the supported
   * filters for further documentation.
   */
  config_type?:
    | //
    { $case: "config"; config: { [key: string]: any } | undefined }
    | //
    { $case: "typed_config"; typed_config: Any }
    | undefined;
}

export interface RequestIDExtension {
  $type: "envoy.config.filter.network.http_connection_manager.v2.RequestIDExtension";
  /** Request ID extension specific configuration. */
  typed_config?: Any | undefined;
}

function createBaseHttpConnectionManager(): HttpConnectionManager {
  return {
    $type: "envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager",
    route_specifier: undefined,
  };
}

export const HttpConnectionManager: MessageFns<
  HttpConnectionManager,
  "envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager"
> = {
  $type: "envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager" as const,

  encode(message: HttpConnectionManager, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.codec_type !== undefined && message.codec_type !== HttpConnectionManager_CodecType.AUTO) {
      writer.uint32(8).int32(httpConnectionManager_CodecTypeToNumber(message.codec_type));
    }
    if (message.stat_prefix !== undefined && message.stat_prefix !== "") {
      writer.uint32(18).string(message.stat_prefix);
    }
    switch (message.route_specifier?.$case) {
      case "rds":
        Rds.encode(message.route_specifier.rds, writer.uint32(26).fork()).join();
        break;
      case "route_config":
        RouteConfiguration.encode(message.route_specifier.route_config, writer.uint32(34).fork()).join();
        break;
      case "scoped_routes":
        ScopedRoutes.encode(message.route_specifier.scoped_routes, writer.uint32(250).fork()).join();
        break;
    }
    if (message.http_filters !== undefined && message.http_filters.length !== 0) {
      for (const v of message.http_filters) {
        HttpFilter.encode(v!, writer.uint32(42).fork()).join();
      }
    }
    if (message.add_user_agent !== undefined) {
      BoolValue.encode({ $type: "google.protobuf.BoolValue", value: message.add_user_agent! }, writer.uint32(50).fork())
        .join();
    }
    if (message.tracing !== undefined) {
      HttpConnectionManager_Tracing.encode(message.tracing, writer.uint32(58).fork()).join();
    }
    if (message.common_http_protocol_options !== undefined) {
      HttpProtocolOptions.encode(message.common_http_protocol_options, writer.uint32(282).fork()).join();
    }
    if (message.http_protocol_options !== undefined) {
      Http1ProtocolOptions.encode(message.http_protocol_options, writer.uint32(66).fork()).join();
    }
    if (message.http2_protocol_options !== undefined) {
      Http2ProtocolOptions.encode(message.http2_protocol_options, writer.uint32(74).fork()).join();
    }
    if (message.server_name !== undefined && message.server_name !== "") {
      writer.uint32(82).string(message.server_name);
    }
    if (
      message.server_header_transformation !== undefined &&
      message.server_header_transformation !== HttpConnectionManager_ServerHeaderTransformation.OVERWRITE
    ) {
      writer.uint32(272).int32(
        httpConnectionManager_ServerHeaderTransformationToNumber(message.server_header_transformation),
      );
    }
    if (message.max_request_headers_kb !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.max_request_headers_kb! },
        writer.uint32(234).fork(),
      ).join();
    }
    if (message.idle_timeout !== undefined) {
      Duration.encode(message.idle_timeout, writer.uint32(90).fork()).join();
    }
    if (message.stream_idle_timeout !== undefined) {
      Duration.encode(message.stream_idle_timeout, writer.uint32(194).fork()).join();
    }
    if (message.request_timeout !== undefined) {
      Duration.encode(message.request_timeout, writer.uint32(226).fork()).join();
    }
    if (message.drain_timeout !== undefined) {
      Duration.encode(message.drain_timeout, writer.uint32(98).fork()).join();
    }
    if (message.delayed_close_timeout !== undefined) {
      Duration.encode(message.delayed_close_timeout, writer.uint32(210).fork()).join();
    }
    if (message.access_log !== undefined && message.access_log.length !== 0) {
      for (const v of message.access_log) {
        AccessLog.encode(v!, writer.uint32(106).fork()).join();
      }
    }
    if (message.use_remote_address !== undefined) {
      BoolValue.encode(
        { $type: "google.protobuf.BoolValue", value: message.use_remote_address! },
        writer.uint32(114).fork(),
      ).join();
    }
    if (message.xff_num_trusted_hops !== undefined && message.xff_num_trusted_hops !== 0) {
      writer.uint32(152).uint32(message.xff_num_trusted_hops);
    }
    if (message.internal_address_config !== undefined) {
      HttpConnectionManager_InternalAddressConfig.encode(message.internal_address_config, writer.uint32(202).fork())
        .join();
    }
    if (message.skip_xff_append !== undefined && message.skip_xff_append !== false) {
      writer.uint32(168).bool(message.skip_xff_append);
    }
    if (message.via !== undefined && message.via !== "") {
      writer.uint32(178).string(message.via);
    }
    if (message.generate_request_id !== undefined) {
      BoolValue.encode(
        { $type: "google.protobuf.BoolValue", value: message.generate_request_id! },
        writer.uint32(122).fork(),
      ).join();
    }
    if (message.preserve_external_request_id !== undefined && message.preserve_external_request_id !== false) {
      writer.uint32(256).bool(message.preserve_external_request_id);
    }
    if (
      message.forward_client_cert_details !== undefined &&
      message.forward_client_cert_details !== HttpConnectionManager_ForwardClientCertDetails.SANITIZE
    ) {
      writer.uint32(128).int32(
        httpConnectionManager_ForwardClientCertDetailsToNumber(message.forward_client_cert_details),
      );
    }
    if (message.set_current_client_cert_details !== undefined) {
      HttpConnectionManager_SetCurrentClientCertDetails.encode(
        message.set_current_client_cert_details,
        writer.uint32(138).fork(),
      ).join();
    }
    if (message.proxy_100_continue !== undefined && message.proxy_100_continue !== false) {
      writer.uint32(144).bool(message.proxy_100_continue);
    }
    if (
      message.represent_ipv4_remote_address_as_ipv4_mapped_ipv6 !== undefined &&
      message.represent_ipv4_remote_address_as_ipv4_mapped_ipv6 !== false
    ) {
      writer.uint32(160).bool(message.represent_ipv4_remote_address_as_ipv4_mapped_ipv6);
    }
    if (message.upgrade_configs !== undefined && message.upgrade_configs.length !== 0) {
      for (const v of message.upgrade_configs) {
        HttpConnectionManager_UpgradeConfig.encode(v!, writer.uint32(186).fork()).join();
      }
    }
    if (message.normalize_path !== undefined) {
      BoolValue.encode(
        { $type: "google.protobuf.BoolValue", value: message.normalize_path! },
        writer.uint32(242).fork(),
      ).join();
    }
    if (message.merge_slashes !== undefined && message.merge_slashes !== false) {
      writer.uint32(264).bool(message.merge_slashes);
    }
    if (message.request_id_extension !== undefined) {
      RequestIDExtension.encode(message.request_id_extension, writer.uint32(290).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpConnectionManager {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpConnectionManager();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.codec_type = httpConnectionManager_CodecTypeFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stat_prefix = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.route_specifier = { $case: "rds", rds: Rds.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.route_specifier = {
            $case: "route_config",
            route_config: RouteConfiguration.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.route_specifier = {
            $case: "scoped_routes",
            scoped_routes: ScopedRoutes.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          if (message.http_filters === undefined) {
            message.http_filters = [];
          }
          const el = HttpFilter.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.http_filters!.push(el);
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.add_user_agent = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.tracing = HttpConnectionManager_Tracing.decode(reader, reader.uint32());
          continue;
        }
        case 35: {
          if (tag !== 282) {
            break;
          }

          message.common_http_protocol_options = HttpProtocolOptions.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.http_protocol_options = Http1ProtocolOptions.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.http2_protocol_options = Http2ProtocolOptions.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.server_name = reader.string();
          continue;
        }
        case 34: {
          if (tag !== 272) {
            break;
          }

          message.server_header_transformation = httpConnectionManager_ServerHeaderTransformationFromJSON(
            reader.int32(),
          );
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.max_request_headers_kb = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.idle_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.stream_idle_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.request_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.drain_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.delayed_close_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          if (message.access_log === undefined) {
            message.access_log = [];
          }
          const el = AccessLog.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.access_log!.push(el);
          }
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.use_remote_address = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.xff_num_trusted_hops = reader.uint32();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.internal_address_config = HttpConnectionManager_InternalAddressConfig.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.skip_xff_append = reader.bool();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.via = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.generate_request_id = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 32: {
          if (tag !== 256) {
            break;
          }

          message.preserve_external_request_id = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.forward_client_cert_details = httpConnectionManager_ForwardClientCertDetailsFromJSON(reader.int32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.set_current_client_cert_details = HttpConnectionManager_SetCurrentClientCertDetails.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.proxy_100_continue = reader.bool();
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.represent_ipv4_remote_address_as_ipv4_mapped_ipv6 = reader.bool();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          if (message.upgrade_configs === undefined) {
            message.upgrade_configs = [];
          }
          const el = HttpConnectionManager_UpgradeConfig.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.upgrade_configs!.push(el);
          }
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.normalize_path = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 33: {
          if (tag !== 264) {
            break;
          }

          message.merge_slashes = reader.bool();
          continue;
        }
        case 36: {
          if (tag !== 290) {
            break;
          }

          message.request_id_extension = RequestIDExtension.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpConnectionManager {
    return {
      $type: HttpConnectionManager.$type,
      codec_type: isSet(object.codec_type) ? httpConnectionManager_CodecTypeFromJSON(object.codec_type) : undefined,
      stat_prefix: isSet(object.stat_prefix) ? globalThis.String(object.stat_prefix) : undefined,
      route_specifier: isSet(object.rds)
        ? { $case: "rds", rds: Rds.fromJSON(object.rds) }
        : isSet(object.route_config)
        ? { $case: "route_config", route_config: RouteConfiguration.fromJSON(object.route_config) }
        : isSet(object.scoped_routes)
        ? { $case: "scoped_routes", scoped_routes: ScopedRoutes.fromJSON(object.scoped_routes) }
        : undefined,
      http_filters: globalThis.Array.isArray(object?.http_filters)
        ? object.http_filters.map((e: any) => HttpFilter.fromJSON(e))
        : undefined,
      add_user_agent: isSet(object.add_user_agent) ? Boolean(object.add_user_agent) : undefined,
      tracing: isSet(object.tracing) ? HttpConnectionManager_Tracing.fromJSON(object.tracing) : undefined,
      common_http_protocol_options: isSet(object.common_http_protocol_options)
        ? HttpProtocolOptions.fromJSON(object.common_http_protocol_options)
        : undefined,
      http_protocol_options: isSet(object.http_protocol_options)
        ? Http1ProtocolOptions.fromJSON(object.http_protocol_options)
        : undefined,
      http2_protocol_options: isSet(object.http2_protocol_options)
        ? Http2ProtocolOptions.fromJSON(object.http2_protocol_options)
        : undefined,
      server_name: isSet(object.server_name) ? globalThis.String(object.server_name) : undefined,
      server_header_transformation: isSet(object.server_header_transformation)
        ? httpConnectionManager_ServerHeaderTransformationFromJSON(object.server_header_transformation)
        : undefined,
      max_request_headers_kb: isSet(object.max_request_headers_kb) ? Number(object.max_request_headers_kb) : undefined,
      idle_timeout: isSet(object.idle_timeout) ? Duration.fromJSON(object.idle_timeout) : undefined,
      stream_idle_timeout: isSet(object.stream_idle_timeout)
        ? Duration.fromJSON(object.stream_idle_timeout)
        : undefined,
      request_timeout: isSet(object.request_timeout) ? Duration.fromJSON(object.request_timeout) : undefined,
      drain_timeout: isSet(object.drain_timeout) ? Duration.fromJSON(object.drain_timeout) : undefined,
      delayed_close_timeout: isSet(object.delayed_close_timeout)
        ? Duration.fromJSON(object.delayed_close_timeout)
        : undefined,
      access_log: globalThis.Array.isArray(object?.access_log)
        ? object.access_log.map((e: any) => AccessLog.fromJSON(e))
        : undefined,
      use_remote_address: isSet(object.use_remote_address) ? Boolean(object.use_remote_address) : undefined,
      xff_num_trusted_hops: isSet(object.xff_num_trusted_hops)
        ? globalThis.Number(object.xff_num_trusted_hops)
        : undefined,
      internal_address_config: isSet(object.internal_address_config)
        ? HttpConnectionManager_InternalAddressConfig.fromJSON(object.internal_address_config)
        : undefined,
      skip_xff_append: isSet(object.skip_xff_append) ? globalThis.Boolean(object.skip_xff_append) : undefined,
      via: isSet(object.via) ? globalThis.String(object.via) : undefined,
      generate_request_id: isSet(object.generate_request_id) ? Boolean(object.generate_request_id) : undefined,
      preserve_external_request_id: isSet(object.preserve_external_request_id)
        ? globalThis.Boolean(object.preserve_external_request_id)
        : undefined,
      forward_client_cert_details: isSet(object.forward_client_cert_details)
        ? httpConnectionManager_ForwardClientCertDetailsFromJSON(object.forward_client_cert_details)
        : undefined,
      set_current_client_cert_details: isSet(object.set_current_client_cert_details)
        ? HttpConnectionManager_SetCurrentClientCertDetails.fromJSON(object.set_current_client_cert_details)
        : undefined,
      proxy_100_continue: isSet(object.proxy_100_continue) ? globalThis.Boolean(object.proxy_100_continue) : undefined,
      represent_ipv4_remote_address_as_ipv4_mapped_ipv6: isSet(object.represent_ipv4_remote_address_as_ipv4_mapped_ipv6)
        ? globalThis.Boolean(object.represent_ipv4_remote_address_as_ipv4_mapped_ipv6)
        : undefined,
      upgrade_configs: globalThis.Array.isArray(object?.upgrade_configs)
        ? object.upgrade_configs.map((e: any) => HttpConnectionManager_UpgradeConfig.fromJSON(e))
        : undefined,
      normalize_path: isSet(object.normalize_path) ? Boolean(object.normalize_path) : undefined,
      merge_slashes: isSet(object.merge_slashes) ? globalThis.Boolean(object.merge_slashes) : undefined,
      request_id_extension: isSet(object.request_id_extension)
        ? RequestIDExtension.fromJSON(object.request_id_extension)
        : undefined,
    };
  },

  toJSON(message: HttpConnectionManager): unknown {
    const obj: any = {};
    if (message.codec_type !== undefined) {
      obj.codec_type = httpConnectionManager_CodecTypeToJSON(message.codec_type);
    }
    if (message.stat_prefix !== undefined) {
      obj.stat_prefix = message.stat_prefix;
    }
    if (message.route_specifier?.$case === "rds") {
      obj.rds = Rds.toJSON(message.route_specifier.rds);
    }
    if (message.route_specifier?.$case === "route_config") {
      obj.route_config = RouteConfiguration.toJSON(message.route_specifier.route_config);
    }
    if (message.route_specifier?.$case === "scoped_routes") {
      obj.scoped_routes = ScopedRoutes.toJSON(message.route_specifier.scoped_routes);
    }
    if (message.http_filters?.length) {
      obj.http_filters = message.http_filters.map((e) => HttpFilter.toJSON(e));
    }
    if (message.add_user_agent !== undefined) {
      obj.add_user_agent = message.add_user_agent;
    }
    if (message.tracing !== undefined) {
      obj.tracing = HttpConnectionManager_Tracing.toJSON(message.tracing);
    }
    if (message.common_http_protocol_options !== undefined) {
      obj.common_http_protocol_options = HttpProtocolOptions.toJSON(message.common_http_protocol_options);
    }
    if (message.http_protocol_options !== undefined) {
      obj.http_protocol_options = Http1ProtocolOptions.toJSON(message.http_protocol_options);
    }
    if (message.http2_protocol_options !== undefined) {
      obj.http2_protocol_options = Http2ProtocolOptions.toJSON(message.http2_protocol_options);
    }
    if (message.server_name !== undefined) {
      obj.server_name = message.server_name;
    }
    if (message.server_header_transformation !== undefined) {
      obj.server_header_transformation = httpConnectionManager_ServerHeaderTransformationToJSON(
        message.server_header_transformation,
      );
    }
    if (message.max_request_headers_kb !== undefined) {
      obj.max_request_headers_kb = message.max_request_headers_kb;
    }
    if (message.idle_timeout !== undefined) {
      obj.idle_timeout = Duration.toJSON(message.idle_timeout);
    }
    if (message.stream_idle_timeout !== undefined) {
      obj.stream_idle_timeout = Duration.toJSON(message.stream_idle_timeout);
    }
    if (message.request_timeout !== undefined) {
      obj.request_timeout = Duration.toJSON(message.request_timeout);
    }
    if (message.drain_timeout !== undefined) {
      obj.drain_timeout = Duration.toJSON(message.drain_timeout);
    }
    if (message.delayed_close_timeout !== undefined) {
      obj.delayed_close_timeout = Duration.toJSON(message.delayed_close_timeout);
    }
    if (message.access_log?.length) {
      obj.access_log = message.access_log.map((e) => AccessLog.toJSON(e));
    }
    if (message.use_remote_address !== undefined) {
      obj.use_remote_address = message.use_remote_address;
    }
    if (message.xff_num_trusted_hops !== undefined) {
      obj.xff_num_trusted_hops = Math.round(message.xff_num_trusted_hops);
    }
    if (message.internal_address_config !== undefined) {
      obj.internal_address_config = HttpConnectionManager_InternalAddressConfig.toJSON(message.internal_address_config);
    }
    if (message.skip_xff_append !== undefined) {
      obj.skip_xff_append = message.skip_xff_append;
    }
    if (message.via !== undefined) {
      obj.via = message.via;
    }
    if (message.generate_request_id !== undefined) {
      obj.generate_request_id = message.generate_request_id;
    }
    if (message.preserve_external_request_id !== undefined) {
      obj.preserve_external_request_id = message.preserve_external_request_id;
    }
    if (message.forward_client_cert_details !== undefined) {
      obj.forward_client_cert_details = httpConnectionManager_ForwardClientCertDetailsToJSON(
        message.forward_client_cert_details,
      );
    }
    if (message.set_current_client_cert_details !== undefined) {
      obj.set_current_client_cert_details = HttpConnectionManager_SetCurrentClientCertDetails.toJSON(
        message.set_current_client_cert_details,
      );
    }
    if (message.proxy_100_continue !== undefined) {
      obj.proxy_100_continue = message.proxy_100_continue;
    }
    if (message.represent_ipv4_remote_address_as_ipv4_mapped_ipv6 !== undefined) {
      obj.represent_ipv4_remote_address_as_ipv4_mapped_ipv6 = message.represent_ipv4_remote_address_as_ipv4_mapped_ipv6;
    }
    if (message.upgrade_configs?.length) {
      obj.upgrade_configs = message.upgrade_configs.map((e) => HttpConnectionManager_UpgradeConfig.toJSON(e));
    }
    if (message.normalize_path !== undefined) {
      obj.normalize_path = message.normalize_path;
    }
    if (message.merge_slashes !== undefined) {
      obj.merge_slashes = message.merge_slashes;
    }
    if (message.request_id_extension !== undefined) {
      obj.request_id_extension = RequestIDExtension.toJSON(message.request_id_extension);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpConnectionManager>, I>>(base?: I): HttpConnectionManager {
    return HttpConnectionManager.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpConnectionManager>, I>>(object: I): HttpConnectionManager {
    const message = createBaseHttpConnectionManager();
    message.codec_type = object.codec_type ?? undefined;
    message.stat_prefix = object.stat_prefix ?? undefined;
    if (
      object.route_specifier?.$case === "rds" &&
      object.route_specifier?.rds !== undefined &&
      object.route_specifier?.rds !== null
    ) {
      message.route_specifier = { $case: "rds", rds: Rds.fromPartial(object.route_specifier.rds) };
    }
    if (
      object.route_specifier?.$case === "route_config" &&
      object.route_specifier?.route_config !== undefined &&
      object.route_specifier?.route_config !== null
    ) {
      message.route_specifier = {
        $case: "route_config",
        route_config: RouteConfiguration.fromPartial(object.route_specifier.route_config),
      };
    }
    if (
      object.route_specifier?.$case === "scoped_routes" &&
      object.route_specifier?.scoped_routes !== undefined &&
      object.route_specifier?.scoped_routes !== null
    ) {
      message.route_specifier = {
        $case: "scoped_routes",
        scoped_routes: ScopedRoutes.fromPartial(object.route_specifier.scoped_routes),
      };
    }
    message.http_filters = object.http_filters?.map((e) => HttpFilter.fromPartial(e)) || undefined;
    message.add_user_agent = object.add_user_agent ?? undefined;
    message.tracing = (object.tracing !== undefined && object.tracing !== null)
      ? HttpConnectionManager_Tracing.fromPartial(object.tracing)
      : undefined;
    message.common_http_protocol_options =
      (object.common_http_protocol_options !== undefined && object.common_http_protocol_options !== null)
        ? HttpProtocolOptions.fromPartial(object.common_http_protocol_options)
        : undefined;
    message.http_protocol_options =
      (object.http_protocol_options !== undefined && object.http_protocol_options !== null)
        ? Http1ProtocolOptions.fromPartial(object.http_protocol_options)
        : undefined;
    message.http2_protocol_options =
      (object.http2_protocol_options !== undefined && object.http2_protocol_options !== null)
        ? Http2ProtocolOptions.fromPartial(object.http2_protocol_options)
        : undefined;
    message.server_name = object.server_name ?? undefined;
    message.server_header_transformation = object.server_header_transformation ?? undefined;
    message.max_request_headers_kb = object.max_request_headers_kb ?? undefined;
    message.idle_timeout = (object.idle_timeout !== undefined && object.idle_timeout !== null)
      ? Duration.fromPartial(object.idle_timeout)
      : undefined;
    message.stream_idle_timeout = (object.stream_idle_timeout !== undefined && object.stream_idle_timeout !== null)
      ? Duration.fromPartial(object.stream_idle_timeout)
      : undefined;
    message.request_timeout = (object.request_timeout !== undefined && object.request_timeout !== null)
      ? Duration.fromPartial(object.request_timeout)
      : undefined;
    message.drain_timeout = (object.drain_timeout !== undefined && object.drain_timeout !== null)
      ? Duration.fromPartial(object.drain_timeout)
      : undefined;
    message.delayed_close_timeout =
      (object.delayed_close_timeout !== undefined && object.delayed_close_timeout !== null)
        ? Duration.fromPartial(object.delayed_close_timeout)
        : undefined;
    message.access_log = object.access_log?.map((e) => AccessLog.fromPartial(e)) || undefined;
    message.use_remote_address = object.use_remote_address ?? undefined;
    message.xff_num_trusted_hops = object.xff_num_trusted_hops ?? undefined;
    message.internal_address_config =
      (object.internal_address_config !== undefined && object.internal_address_config !== null)
        ? HttpConnectionManager_InternalAddressConfig.fromPartial(object.internal_address_config)
        : undefined;
    message.skip_xff_append = object.skip_xff_append ?? undefined;
    message.via = object.via ?? undefined;
    message.generate_request_id = object.generate_request_id ?? undefined;
    message.preserve_external_request_id = object.preserve_external_request_id ?? undefined;
    message.forward_client_cert_details = object.forward_client_cert_details ?? undefined;
    message.set_current_client_cert_details =
      (object.set_current_client_cert_details !== undefined && object.set_current_client_cert_details !== null)
        ? HttpConnectionManager_SetCurrentClientCertDetails.fromPartial(object.set_current_client_cert_details)
        : undefined;
    message.proxy_100_continue = object.proxy_100_continue ?? undefined;
    message.represent_ipv4_remote_address_as_ipv4_mapped_ipv6 =
      object.represent_ipv4_remote_address_as_ipv4_mapped_ipv6 ?? undefined;
    message.upgrade_configs = object.upgrade_configs?.map((e) => HttpConnectionManager_UpgradeConfig.fromPartial(e)) ||
      undefined;
    message.normalize_path = object.normalize_path ?? undefined;
    message.merge_slashes = object.merge_slashes ?? undefined;
    message.request_id_extension = (object.request_id_extension !== undefined && object.request_id_extension !== null)
      ? RequestIDExtension.fromPartial(object.request_id_extension)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(HttpConnectionManager.$type, HttpConnectionManager);

function createBaseHttpConnectionManager_Tracing(): HttpConnectionManager_Tracing {
  return { $type: "envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager.Tracing" };
}

export const HttpConnectionManager_Tracing: MessageFns<
  HttpConnectionManager_Tracing,
  "envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager.Tracing"
> = {
  $type: "envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager.Tracing" as const,

  encode(message: HttpConnectionManager_Tracing, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (
      message.operation_name !== undefined &&
      message.operation_name !== HttpConnectionManager_Tracing_OperationName.INGRESS
    ) {
      writer.uint32(8).int32(httpConnectionManager_Tracing_OperationNameToNumber(message.operation_name));
    }
    if (message.request_headers_for_tags !== undefined && message.request_headers_for_tags.length !== 0) {
      for (const v of message.request_headers_for_tags) {
        writer.uint32(18).string(v!);
      }
    }
    if (message.client_sampling !== undefined) {
      Percent.encode(message.client_sampling, writer.uint32(26).fork()).join();
    }
    if (message.random_sampling !== undefined) {
      Percent.encode(message.random_sampling, writer.uint32(34).fork()).join();
    }
    if (message.overall_sampling !== undefined) {
      Percent.encode(message.overall_sampling, writer.uint32(42).fork()).join();
    }
    if (message.verbose !== undefined && message.verbose !== false) {
      writer.uint32(48).bool(message.verbose);
    }
    if (message.max_path_tag_length !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.max_path_tag_length! },
        writer.uint32(58).fork(),
      ).join();
    }
    if (message.custom_tags !== undefined && message.custom_tags.length !== 0) {
      for (const v of message.custom_tags) {
        CustomTag.encode(v!, writer.uint32(66).fork()).join();
      }
    }
    if (message.provider !== undefined) {
      Tracing_Http.encode(message.provider, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpConnectionManager_Tracing {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpConnectionManager_Tracing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.operation_name = httpConnectionManager_Tracing_OperationNameFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.request_headers_for_tags === undefined) {
            message.request_headers_for_tags = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.request_headers_for_tags!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.client_sampling = Percent.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.random_sampling = Percent.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.overall_sampling = Percent.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.verbose = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.max_path_tag_length = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          if (message.custom_tags === undefined) {
            message.custom_tags = [];
          }
          const el = CustomTag.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.custom_tags!.push(el);
          }
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.provider = Tracing_Http.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpConnectionManager_Tracing {
    return {
      $type: HttpConnectionManager_Tracing.$type,
      operation_name: isSet(object.operation_name)
        ? httpConnectionManager_Tracing_OperationNameFromJSON(object.operation_name)
        : undefined,
      request_headers_for_tags: globalThis.Array.isArray(object?.request_headers_for_tags)
        ? object.request_headers_for_tags.map((e: any) => globalThis.String(e))
        : undefined,
      client_sampling: isSet(object.client_sampling) ? Percent.fromJSON(object.client_sampling) : undefined,
      random_sampling: isSet(object.random_sampling) ? Percent.fromJSON(object.random_sampling) : undefined,
      overall_sampling: isSet(object.overall_sampling) ? Percent.fromJSON(object.overall_sampling) : undefined,
      verbose: isSet(object.verbose) ? globalThis.Boolean(object.verbose) : undefined,
      max_path_tag_length: isSet(object.max_path_tag_length) ? Number(object.max_path_tag_length) : undefined,
      custom_tags: globalThis.Array.isArray(object?.custom_tags)
        ? object.custom_tags.map((e: any) => CustomTag.fromJSON(e))
        : undefined,
      provider: isSet(object.provider) ? Tracing_Http.fromJSON(object.provider) : undefined,
    };
  },

  toJSON(message: HttpConnectionManager_Tracing): unknown {
    const obj: any = {};
    if (message.operation_name !== undefined) {
      obj.operation_name = httpConnectionManager_Tracing_OperationNameToJSON(message.operation_name);
    }
    if (message.request_headers_for_tags?.length) {
      obj.request_headers_for_tags = message.request_headers_for_tags;
    }
    if (message.client_sampling !== undefined) {
      obj.client_sampling = Percent.toJSON(message.client_sampling);
    }
    if (message.random_sampling !== undefined) {
      obj.random_sampling = Percent.toJSON(message.random_sampling);
    }
    if (message.overall_sampling !== undefined) {
      obj.overall_sampling = Percent.toJSON(message.overall_sampling);
    }
    if (message.verbose !== undefined) {
      obj.verbose = message.verbose;
    }
    if (message.max_path_tag_length !== undefined) {
      obj.max_path_tag_length = message.max_path_tag_length;
    }
    if (message.custom_tags?.length) {
      obj.custom_tags = message.custom_tags.map((e) => CustomTag.toJSON(e));
    }
    if (message.provider !== undefined) {
      obj.provider = Tracing_Http.toJSON(message.provider);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpConnectionManager_Tracing>, I>>(base?: I): HttpConnectionManager_Tracing {
    return HttpConnectionManager_Tracing.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpConnectionManager_Tracing>, I>>(
    object: I,
  ): HttpConnectionManager_Tracing {
    const message = createBaseHttpConnectionManager_Tracing();
    message.operation_name = object.operation_name ?? undefined;
    message.request_headers_for_tags = object.request_headers_for_tags?.map((e) => e) || undefined;
    message.client_sampling = (object.client_sampling !== undefined && object.client_sampling !== null)
      ? Percent.fromPartial(object.client_sampling)
      : undefined;
    message.random_sampling = (object.random_sampling !== undefined && object.random_sampling !== null)
      ? Percent.fromPartial(object.random_sampling)
      : undefined;
    message.overall_sampling = (object.overall_sampling !== undefined && object.overall_sampling !== null)
      ? Percent.fromPartial(object.overall_sampling)
      : undefined;
    message.verbose = object.verbose ?? undefined;
    message.max_path_tag_length = object.max_path_tag_length ?? undefined;
    message.custom_tags = object.custom_tags?.map((e) => CustomTag.fromPartial(e)) || undefined;
    message.provider = (object.provider !== undefined && object.provider !== null)
      ? Tracing_Http.fromPartial(object.provider)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(HttpConnectionManager_Tracing.$type, HttpConnectionManager_Tracing);

function createBaseHttpConnectionManager_InternalAddressConfig(): HttpConnectionManager_InternalAddressConfig {
  return {
    $type: "envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager.InternalAddressConfig",
  };
}

export const HttpConnectionManager_InternalAddressConfig: MessageFns<
  HttpConnectionManager_InternalAddressConfig,
  "envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager.InternalAddressConfig"
> = {
  $type: "envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager.InternalAddressConfig" as const,

  encode(
    message: HttpConnectionManager_InternalAddressConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.unix_sockets !== undefined && message.unix_sockets !== false) {
      writer.uint32(8).bool(message.unix_sockets);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpConnectionManager_InternalAddressConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpConnectionManager_InternalAddressConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.unix_sockets = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpConnectionManager_InternalAddressConfig {
    return {
      $type: HttpConnectionManager_InternalAddressConfig.$type,
      unix_sockets: isSet(object.unix_sockets) ? globalThis.Boolean(object.unix_sockets) : undefined,
    };
  },

  toJSON(message: HttpConnectionManager_InternalAddressConfig): unknown {
    const obj: any = {};
    if (message.unix_sockets !== undefined) {
      obj.unix_sockets = message.unix_sockets;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpConnectionManager_InternalAddressConfig>, I>>(
    base?: I,
  ): HttpConnectionManager_InternalAddressConfig {
    return HttpConnectionManager_InternalAddressConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpConnectionManager_InternalAddressConfig>, I>>(
    object: I,
  ): HttpConnectionManager_InternalAddressConfig {
    const message = createBaseHttpConnectionManager_InternalAddressConfig();
    message.unix_sockets = object.unix_sockets ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(HttpConnectionManager_InternalAddressConfig.$type, HttpConnectionManager_InternalAddressConfig);

function createBaseHttpConnectionManager_SetCurrentClientCertDetails(): HttpConnectionManager_SetCurrentClientCertDetails {
  return {
    $type: "envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager.SetCurrentClientCertDetails",
  };
}

export const HttpConnectionManager_SetCurrentClientCertDetails: MessageFns<
  HttpConnectionManager_SetCurrentClientCertDetails,
  "envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager.SetCurrentClientCertDetails"
> = {
  $type:
    "envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager.SetCurrentClientCertDetails" as const,

  encode(
    message: HttpConnectionManager_SetCurrentClientCertDetails,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.subject !== undefined) {
      BoolValue.encode({ $type: "google.protobuf.BoolValue", value: message.subject! }, writer.uint32(10).fork())
        .join();
    }
    if (message.cert !== undefined && message.cert !== false) {
      writer.uint32(24).bool(message.cert);
    }
    if (message.chain !== undefined && message.chain !== false) {
      writer.uint32(48).bool(message.chain);
    }
    if (message.dns !== undefined && message.dns !== false) {
      writer.uint32(32).bool(message.dns);
    }
    if (message.uri !== undefined && message.uri !== false) {
      writer.uint32(40).bool(message.uri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpConnectionManager_SetCurrentClientCertDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpConnectionManager_SetCurrentClientCertDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subject = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.cert = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.chain = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.dns = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.uri = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpConnectionManager_SetCurrentClientCertDetails {
    return {
      $type: HttpConnectionManager_SetCurrentClientCertDetails.$type,
      subject: isSet(object.subject) ? Boolean(object.subject) : undefined,
      cert: isSet(object.cert) ? globalThis.Boolean(object.cert) : undefined,
      chain: isSet(object.chain) ? globalThis.Boolean(object.chain) : undefined,
      dns: isSet(object.dns) ? globalThis.Boolean(object.dns) : undefined,
      uri: isSet(object.uri) ? globalThis.Boolean(object.uri) : undefined,
    };
  },

  toJSON(message: HttpConnectionManager_SetCurrentClientCertDetails): unknown {
    const obj: any = {};
    if (message.subject !== undefined) {
      obj.subject = message.subject;
    }
    if (message.cert !== undefined) {
      obj.cert = message.cert;
    }
    if (message.chain !== undefined) {
      obj.chain = message.chain;
    }
    if (message.dns !== undefined) {
      obj.dns = message.dns;
    }
    if (message.uri !== undefined) {
      obj.uri = message.uri;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpConnectionManager_SetCurrentClientCertDetails>, I>>(
    base?: I,
  ): HttpConnectionManager_SetCurrentClientCertDetails {
    return HttpConnectionManager_SetCurrentClientCertDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpConnectionManager_SetCurrentClientCertDetails>, I>>(
    object: I,
  ): HttpConnectionManager_SetCurrentClientCertDetails {
    const message = createBaseHttpConnectionManager_SetCurrentClientCertDetails();
    message.subject = object.subject ?? undefined;
    message.cert = object.cert ?? undefined;
    message.chain = object.chain ?? undefined;
    message.dns = object.dns ?? undefined;
    message.uri = object.uri ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(
  HttpConnectionManager_SetCurrentClientCertDetails.$type,
  HttpConnectionManager_SetCurrentClientCertDetails,
);

function createBaseHttpConnectionManager_UpgradeConfig(): HttpConnectionManager_UpgradeConfig {
  return { $type: "envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager.UpgradeConfig" };
}

export const HttpConnectionManager_UpgradeConfig: MessageFns<
  HttpConnectionManager_UpgradeConfig,
  "envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager.UpgradeConfig"
> = {
  $type: "envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager.UpgradeConfig" as const,

  encode(message: HttpConnectionManager_UpgradeConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.upgrade_type !== undefined && message.upgrade_type !== "") {
      writer.uint32(10).string(message.upgrade_type);
    }
    if (message.filters !== undefined && message.filters.length !== 0) {
      for (const v of message.filters) {
        HttpFilter.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.enabled !== undefined) {
      BoolValue.encode({ $type: "google.protobuf.BoolValue", value: message.enabled! }, writer.uint32(26).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpConnectionManager_UpgradeConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpConnectionManager_UpgradeConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.upgrade_type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.filters === undefined) {
            message.filters = [];
          }
          const el = HttpFilter.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.filters!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.enabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpConnectionManager_UpgradeConfig {
    return {
      $type: HttpConnectionManager_UpgradeConfig.$type,
      upgrade_type: isSet(object.upgrade_type) ? globalThis.String(object.upgrade_type) : undefined,
      filters: globalThis.Array.isArray(object?.filters)
        ? object.filters.map((e: any) => HttpFilter.fromJSON(e))
        : undefined,
      enabled: isSet(object.enabled) ? Boolean(object.enabled) : undefined,
    };
  },

  toJSON(message: HttpConnectionManager_UpgradeConfig): unknown {
    const obj: any = {};
    if (message.upgrade_type !== undefined) {
      obj.upgrade_type = message.upgrade_type;
    }
    if (message.filters?.length) {
      obj.filters = message.filters.map((e) => HttpFilter.toJSON(e));
    }
    if (message.enabled !== undefined) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpConnectionManager_UpgradeConfig>, I>>(
    base?: I,
  ): HttpConnectionManager_UpgradeConfig {
    return HttpConnectionManager_UpgradeConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpConnectionManager_UpgradeConfig>, I>>(
    object: I,
  ): HttpConnectionManager_UpgradeConfig {
    const message = createBaseHttpConnectionManager_UpgradeConfig();
    message.upgrade_type = object.upgrade_type ?? undefined;
    message.filters = object.filters?.map((e) => HttpFilter.fromPartial(e)) || undefined;
    message.enabled = object.enabled ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(HttpConnectionManager_UpgradeConfig.$type, HttpConnectionManager_UpgradeConfig);

function createBaseRds(): Rds {
  return { $type: "envoy.config.filter.network.http_connection_manager.v2.Rds" };
}

export const Rds: MessageFns<Rds, "envoy.config.filter.network.http_connection_manager.v2.Rds"> = {
  $type: "envoy.config.filter.network.http_connection_manager.v2.Rds" as const,

  encode(message: Rds, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.config_source !== undefined) {
      ConfigSource.encode(message.config_source, writer.uint32(10).fork()).join();
    }
    if (message.route_config_name !== undefined && message.route_config_name !== "") {
      writer.uint32(18).string(message.route_config_name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Rds {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRds();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.config_source = ConfigSource.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.route_config_name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Rds {
    return {
      $type: Rds.$type,
      config_source: isSet(object.config_source) ? ConfigSource.fromJSON(object.config_source) : undefined,
      route_config_name: isSet(object.route_config_name) ? globalThis.String(object.route_config_name) : undefined,
    };
  },

  toJSON(message: Rds): unknown {
    const obj: any = {};
    if (message.config_source !== undefined) {
      obj.config_source = ConfigSource.toJSON(message.config_source);
    }
    if (message.route_config_name !== undefined) {
      obj.route_config_name = message.route_config_name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Rds>, I>>(base?: I): Rds {
    return Rds.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Rds>, I>>(object: I): Rds {
    const message = createBaseRds();
    message.config_source = (object.config_source !== undefined && object.config_source !== null)
      ? ConfigSource.fromPartial(object.config_source)
      : undefined;
    message.route_config_name = object.route_config_name ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Rds.$type, Rds);

function createBaseScopedRouteConfigurationsList(): ScopedRouteConfigurationsList {
  return { $type: "envoy.config.filter.network.http_connection_manager.v2.ScopedRouteConfigurationsList" };
}

export const ScopedRouteConfigurationsList: MessageFns<
  ScopedRouteConfigurationsList,
  "envoy.config.filter.network.http_connection_manager.v2.ScopedRouteConfigurationsList"
> = {
  $type: "envoy.config.filter.network.http_connection_manager.v2.ScopedRouteConfigurationsList" as const,

  encode(message: ScopedRouteConfigurationsList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scoped_route_configurations !== undefined && message.scoped_route_configurations.length !== 0) {
      for (const v of message.scoped_route_configurations) {
        ScopedRouteConfiguration.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScopedRouteConfigurationsList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScopedRouteConfigurationsList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.scoped_route_configurations === undefined) {
            message.scoped_route_configurations = [];
          }
          const el = ScopedRouteConfiguration.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.scoped_route_configurations!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScopedRouteConfigurationsList {
    return {
      $type: ScopedRouteConfigurationsList.$type,
      scoped_route_configurations: globalThis.Array.isArray(object?.scoped_route_configurations)
        ? object.scoped_route_configurations.map((e: any) => ScopedRouteConfiguration.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: ScopedRouteConfigurationsList): unknown {
    const obj: any = {};
    if (message.scoped_route_configurations?.length) {
      obj.scoped_route_configurations = message.scoped_route_configurations.map((e) =>
        ScopedRouteConfiguration.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScopedRouteConfigurationsList>, I>>(base?: I): ScopedRouteConfigurationsList {
    return ScopedRouteConfigurationsList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScopedRouteConfigurationsList>, I>>(
    object: I,
  ): ScopedRouteConfigurationsList {
    const message = createBaseScopedRouteConfigurationsList();
    message.scoped_route_configurations =
      object.scoped_route_configurations?.map((e) => ScopedRouteConfiguration.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(ScopedRouteConfigurationsList.$type, ScopedRouteConfigurationsList);

function createBaseScopedRoutes(): ScopedRoutes {
  return { $type: "envoy.config.filter.network.http_connection_manager.v2.ScopedRoutes", config_specifier: undefined };
}

export const ScopedRoutes: MessageFns<
  ScopedRoutes,
  "envoy.config.filter.network.http_connection_manager.v2.ScopedRoutes"
> = {
  $type: "envoy.config.filter.network.http_connection_manager.v2.ScopedRoutes" as const,

  encode(message: ScopedRoutes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.scope_key_builder !== undefined) {
      ScopedRoutes_ScopeKeyBuilder.encode(message.scope_key_builder, writer.uint32(18).fork()).join();
    }
    if (message.rds_config_source !== undefined) {
      ConfigSource.encode(message.rds_config_source, writer.uint32(26).fork()).join();
    }
    switch (message.config_specifier?.$case) {
      case "scoped_route_configurations_list":
        ScopedRouteConfigurationsList.encode(
          message.config_specifier.scoped_route_configurations_list,
          writer.uint32(34).fork(),
        ).join();
        break;
      case "scoped_rds":
        ScopedRds.encode(message.config_specifier.scoped_rds, writer.uint32(42).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScopedRoutes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScopedRoutes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.scope_key_builder = ScopedRoutes_ScopeKeyBuilder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rds_config_source = ConfigSource.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.config_specifier = {
            $case: "scoped_route_configurations_list",
            scoped_route_configurations_list: ScopedRouteConfigurationsList.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.config_specifier = { $case: "scoped_rds", scoped_rds: ScopedRds.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScopedRoutes {
    return {
      $type: ScopedRoutes.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      scope_key_builder: isSet(object.scope_key_builder)
        ? ScopedRoutes_ScopeKeyBuilder.fromJSON(object.scope_key_builder)
        : undefined,
      rds_config_source: isSet(object.rds_config_source) ? ConfigSource.fromJSON(object.rds_config_source) : undefined,
      config_specifier: isSet(object.scoped_route_configurations_list)
        ? {
          $case: "scoped_route_configurations_list",
          scoped_route_configurations_list: ScopedRouteConfigurationsList.fromJSON(
            object.scoped_route_configurations_list,
          ),
        }
        : isSet(object.scoped_rds)
        ? { $case: "scoped_rds", scoped_rds: ScopedRds.fromJSON(object.scoped_rds) }
        : undefined,
    };
  },

  toJSON(message: ScopedRoutes): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.scope_key_builder !== undefined) {
      obj.scope_key_builder = ScopedRoutes_ScopeKeyBuilder.toJSON(message.scope_key_builder);
    }
    if (message.rds_config_source !== undefined) {
      obj.rds_config_source = ConfigSource.toJSON(message.rds_config_source);
    }
    if (message.config_specifier?.$case === "scoped_route_configurations_list") {
      obj.scoped_route_configurations_list = ScopedRouteConfigurationsList.toJSON(
        message.config_specifier.scoped_route_configurations_list,
      );
    }
    if (message.config_specifier?.$case === "scoped_rds") {
      obj.scoped_rds = ScopedRds.toJSON(message.config_specifier.scoped_rds);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScopedRoutes>, I>>(base?: I): ScopedRoutes {
    return ScopedRoutes.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScopedRoutes>, I>>(object: I): ScopedRoutes {
    const message = createBaseScopedRoutes();
    message.name = object.name ?? undefined;
    message.scope_key_builder = (object.scope_key_builder !== undefined && object.scope_key_builder !== null)
      ? ScopedRoutes_ScopeKeyBuilder.fromPartial(object.scope_key_builder)
      : undefined;
    message.rds_config_source = (object.rds_config_source !== undefined && object.rds_config_source !== null)
      ? ConfigSource.fromPartial(object.rds_config_source)
      : undefined;
    if (
      object.config_specifier?.$case === "scoped_route_configurations_list" &&
      object.config_specifier?.scoped_route_configurations_list !== undefined &&
      object.config_specifier?.scoped_route_configurations_list !== null
    ) {
      message.config_specifier = {
        $case: "scoped_route_configurations_list",
        scoped_route_configurations_list: ScopedRouteConfigurationsList.fromPartial(
          object.config_specifier.scoped_route_configurations_list,
        ),
      };
    }
    if (
      object.config_specifier?.$case === "scoped_rds" &&
      object.config_specifier?.scoped_rds !== undefined &&
      object.config_specifier?.scoped_rds !== null
    ) {
      message.config_specifier = {
        $case: "scoped_rds",
        scoped_rds: ScopedRds.fromPartial(object.config_specifier.scoped_rds),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(ScopedRoutes.$type, ScopedRoutes);

function createBaseScopedRoutes_ScopeKeyBuilder(): ScopedRoutes_ScopeKeyBuilder {
  return { $type: "envoy.config.filter.network.http_connection_manager.v2.ScopedRoutes.ScopeKeyBuilder" };
}

export const ScopedRoutes_ScopeKeyBuilder: MessageFns<
  ScopedRoutes_ScopeKeyBuilder,
  "envoy.config.filter.network.http_connection_manager.v2.ScopedRoutes.ScopeKeyBuilder"
> = {
  $type: "envoy.config.filter.network.http_connection_manager.v2.ScopedRoutes.ScopeKeyBuilder" as const,

  encode(message: ScopedRoutes_ScopeKeyBuilder, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fragments !== undefined && message.fragments.length !== 0) {
      for (const v of message.fragments) {
        ScopedRoutes_ScopeKeyBuilder_FragmentBuilder.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScopedRoutes_ScopeKeyBuilder {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScopedRoutes_ScopeKeyBuilder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.fragments === undefined) {
            message.fragments = [];
          }
          const el = ScopedRoutes_ScopeKeyBuilder_FragmentBuilder.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.fragments!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScopedRoutes_ScopeKeyBuilder {
    return {
      $type: ScopedRoutes_ScopeKeyBuilder.$type,
      fragments: globalThis.Array.isArray(object?.fragments)
        ? object.fragments.map((e: any) => ScopedRoutes_ScopeKeyBuilder_FragmentBuilder.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: ScopedRoutes_ScopeKeyBuilder): unknown {
    const obj: any = {};
    if (message.fragments?.length) {
      obj.fragments = message.fragments.map((e) => ScopedRoutes_ScopeKeyBuilder_FragmentBuilder.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScopedRoutes_ScopeKeyBuilder>, I>>(base?: I): ScopedRoutes_ScopeKeyBuilder {
    return ScopedRoutes_ScopeKeyBuilder.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScopedRoutes_ScopeKeyBuilder>, I>>(object: I): ScopedRoutes_ScopeKeyBuilder {
    const message = createBaseScopedRoutes_ScopeKeyBuilder();
    message.fragments = object.fragments?.map((e) => ScopedRoutes_ScopeKeyBuilder_FragmentBuilder.fromPartial(e)) ||
      undefined;
    return message;
  },
};

messageTypeRegistry.set(ScopedRoutes_ScopeKeyBuilder.$type, ScopedRoutes_ScopeKeyBuilder);

function createBaseScopedRoutes_ScopeKeyBuilder_FragmentBuilder(): ScopedRoutes_ScopeKeyBuilder_FragmentBuilder {
  return {
    $type: "envoy.config.filter.network.http_connection_manager.v2.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder",
    type: undefined,
  };
}

export const ScopedRoutes_ScopeKeyBuilder_FragmentBuilder: MessageFns<
  ScopedRoutes_ScopeKeyBuilder_FragmentBuilder,
  "envoy.config.filter.network.http_connection_manager.v2.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder"
> = {
  $type: "envoy.config.filter.network.http_connection_manager.v2.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder" as const,

  encode(
    message: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    switch (message.type?.$case) {
      case "header_value_extractor":
        ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor.encode(
          message.type.header_value_extractor,
          writer.uint32(10).fork(),
        ).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScopedRoutes_ScopeKeyBuilder_FragmentBuilder {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScopedRoutes_ScopeKeyBuilder_FragmentBuilder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = {
            $case: "header_value_extractor",
            header_value_extractor: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor.decode(
              reader,
              reader.uint32(),
            ),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScopedRoutes_ScopeKeyBuilder_FragmentBuilder {
    return {
      $type: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder.$type,
      type: isSet(object.header_value_extractor)
        ? {
          $case: "header_value_extractor",
          header_value_extractor: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor.fromJSON(
            object.header_value_extractor,
          ),
        }
        : undefined,
    };
  },

  toJSON(message: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder): unknown {
    const obj: any = {};
    if (message.type?.$case === "header_value_extractor") {
      obj.header_value_extractor = ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor.toJSON(
        message.type.header_value_extractor,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScopedRoutes_ScopeKeyBuilder_FragmentBuilder>, I>>(
    base?: I,
  ): ScopedRoutes_ScopeKeyBuilder_FragmentBuilder {
    return ScopedRoutes_ScopeKeyBuilder_FragmentBuilder.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScopedRoutes_ScopeKeyBuilder_FragmentBuilder>, I>>(
    object: I,
  ): ScopedRoutes_ScopeKeyBuilder_FragmentBuilder {
    const message = createBaseScopedRoutes_ScopeKeyBuilder_FragmentBuilder();
    if (
      object.type?.$case === "header_value_extractor" &&
      object.type?.header_value_extractor !== undefined &&
      object.type?.header_value_extractor !== null
    ) {
      message.type = {
        $case: "header_value_extractor",
        header_value_extractor: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor.fromPartial(
          object.type.header_value_extractor,
        ),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(
  ScopedRoutes_ScopeKeyBuilder_FragmentBuilder.$type,
  ScopedRoutes_ScopeKeyBuilder_FragmentBuilder,
);

function createBaseScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor(): ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor {
  return {
    $type:
      "envoy.config.filter.network.http_connection_manager.v2.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor",
    extract_type: undefined,
  };
}

export const ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor: MessageFns<
  ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor,
  "envoy.config.filter.network.http_connection_manager.v2.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor"
> = {
  $type:
    "envoy.config.filter.network.http_connection_manager.v2.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor" as const,

  encode(
    message: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.element_separator !== undefined && message.element_separator !== "") {
      writer.uint32(18).string(message.element_separator);
    }
    switch (message.extract_type?.$case) {
      case "index":
        writer.uint32(24).uint32(message.extract_type.index);
        break;
      case "element":
        ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement.encode(
          message.extract_type.element,
          writer.uint32(34).fork(),
        ).join();
        break;
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.element_separator = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.extract_type = { $case: "index", index: reader.uint32() };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.extract_type = {
            $case: "element",
            element: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement.decode(
              reader,
              reader.uint32(),
            ),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor {
    return {
      $type: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      element_separator: isSet(object.element_separator) ? globalThis.String(object.element_separator) : undefined,
      extract_type: isSet(object.index)
        ? { $case: "index", index: globalThis.Number(object.index) }
        : isSet(object.element)
        ? {
          $case: "element",
          element: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement.fromJSON(object.element),
        }
        : undefined,
    };
  },

  toJSON(message: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.element_separator !== undefined) {
      obj.element_separator = message.element_separator;
    }
    if (message.extract_type?.$case === "index") {
      obj.index = Math.round(message.extract_type.index);
    }
    if (message.extract_type?.$case === "element") {
      obj.element = ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement.toJSON(
        message.extract_type.element,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor>, I>>(
    base?: I,
  ): ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor {
    return ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor>, I>>(
    object: I,
  ): ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor {
    const message = createBaseScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor();
    message.name = object.name ?? undefined;
    message.element_separator = object.element_separator ?? undefined;
    if (
      object.extract_type?.$case === "index" &&
      object.extract_type?.index !== undefined &&
      object.extract_type?.index !== null
    ) {
      message.extract_type = { $case: "index", index: object.extract_type.index };
    }
    if (
      object.extract_type?.$case === "element" &&
      object.extract_type?.element !== undefined &&
      object.extract_type?.element !== null
    ) {
      message.extract_type = {
        $case: "element",
        element: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement.fromPartial(
          object.extract_type.element,
        ),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(
  ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor.$type,
  ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor,
);

function createBaseScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement(): ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement {
  return {
    $type:
      "envoy.config.filter.network.http_connection_manager.v2.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor.KvElement",
  };
}

export const ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement: MessageFns<
  ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement,
  "envoy.config.filter.network.http_connection_manager.v2.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor.KvElement"
> = {
  $type:
    "envoy.config.filter.network.http_connection_manager.v2.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor.KvElement" as const,

  encode(
    message: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.separator !== undefined && message.separator !== "") {
      writer.uint32(10).string(message.separator);
    }
    if (message.key !== undefined && message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.separator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement {
    return {
      $type: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement.$type,
      separator: isSet(object.separator) ? globalThis.String(object.separator) : undefined,
      key: isSet(object.key) ? globalThis.String(object.key) : undefined,
    };
  },

  toJSON(message: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement): unknown {
    const obj: any = {};
    if (message.separator !== undefined) {
      obj.separator = message.separator;
    }
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement>, I>>(
    base?: I,
  ): ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement {
    return ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement.fromPartial(base ?? ({} as any));
  },
  fromPartial<
    I extends Exact<DeepPartial<ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement>, I>,
  >(object: I): ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement {
    const message = createBaseScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement();
    message.separator = object.separator ?? undefined;
    message.key = object.key ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(
  ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement.$type,
  ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement,
);

function createBaseScopedRds(): ScopedRds {
  return { $type: "envoy.config.filter.network.http_connection_manager.v2.ScopedRds" };
}

export const ScopedRds: MessageFns<ScopedRds, "envoy.config.filter.network.http_connection_manager.v2.ScopedRds"> = {
  $type: "envoy.config.filter.network.http_connection_manager.v2.ScopedRds" as const,

  encode(message: ScopedRds, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scoped_rds_config_source !== undefined) {
      ConfigSource.encode(message.scoped_rds_config_source, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScopedRds {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScopedRds();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.scoped_rds_config_source = ConfigSource.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScopedRds {
    return {
      $type: ScopedRds.$type,
      scoped_rds_config_source: isSet(object.scoped_rds_config_source)
        ? ConfigSource.fromJSON(object.scoped_rds_config_source)
        : undefined,
    };
  },

  toJSON(message: ScopedRds): unknown {
    const obj: any = {};
    if (message.scoped_rds_config_source !== undefined) {
      obj.scoped_rds_config_source = ConfigSource.toJSON(message.scoped_rds_config_source);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScopedRds>, I>>(base?: I): ScopedRds {
    return ScopedRds.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScopedRds>, I>>(object: I): ScopedRds {
    const message = createBaseScopedRds();
    message.scoped_rds_config_source =
      (object.scoped_rds_config_source !== undefined && object.scoped_rds_config_source !== null)
        ? ConfigSource.fromPartial(object.scoped_rds_config_source)
        : undefined;
    return message;
  },
};

messageTypeRegistry.set(ScopedRds.$type, ScopedRds);

function createBaseHttpFilter(): HttpFilter {
  return { $type: "envoy.config.filter.network.http_connection_manager.v2.HttpFilter", config_type: undefined };
}

export const HttpFilter: MessageFns<HttpFilter, "envoy.config.filter.network.http_connection_manager.v2.HttpFilter"> = {
  $type: "envoy.config.filter.network.http_connection_manager.v2.HttpFilter" as const,

  encode(message: HttpFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    switch (message.config_type?.$case) {
      case "config":
        Struct.encode(Struct.wrap(message.config_type.config), writer.uint32(18).fork()).join();
        break;
      case "typed_config":
        Any.encode(message.config_type.typed_config, writer.uint32(34).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.config_type = { $case: "config", config: Struct.unwrap(Struct.decode(reader, reader.uint32())) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.config_type = { $case: "typed_config", typed_config: Any.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpFilter {
    return {
      $type: HttpFilter.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      config_type: isSet(object.config)
        ? { $case: "config", config: object.config }
        : isSet(object.typed_config)
        ? { $case: "typed_config", typed_config: Any.fromJSON(object.typed_config) }
        : undefined,
    };
  },

  toJSON(message: HttpFilter): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.config_type?.$case === "config") {
      obj.config = message.config_type.config;
    }
    if (message.config_type?.$case === "typed_config") {
      obj.typed_config = Any.toJSON(message.config_type.typed_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpFilter>, I>>(base?: I): HttpFilter {
    return HttpFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpFilter>, I>>(object: I): HttpFilter {
    const message = createBaseHttpFilter();
    message.name = object.name ?? undefined;
    if (
      object.config_type?.$case === "config" &&
      object.config_type?.config !== undefined &&
      object.config_type?.config !== null
    ) {
      message.config_type = { $case: "config", config: object.config_type.config };
    }
    if (
      object.config_type?.$case === "typed_config" &&
      object.config_type?.typed_config !== undefined &&
      object.config_type?.typed_config !== null
    ) {
      message.config_type = { $case: "typed_config", typed_config: Any.fromPartial(object.config_type.typed_config) };
    }
    return message;
  },
};

messageTypeRegistry.set(HttpFilter.$type, HttpFilter);

function createBaseRequestIDExtension(): RequestIDExtension {
  return { $type: "envoy.config.filter.network.http_connection_manager.v2.RequestIDExtension" };
}

export const RequestIDExtension: MessageFns<
  RequestIDExtension,
  "envoy.config.filter.network.http_connection_manager.v2.RequestIDExtension"
> = {
  $type: "envoy.config.filter.network.http_connection_manager.v2.RequestIDExtension" as const,

  encode(message: RequestIDExtension, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.typed_config !== undefined) {
      Any.encode(message.typed_config, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestIDExtension {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestIDExtension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.typed_config = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestIDExtension {
    return {
      $type: RequestIDExtension.$type,
      typed_config: isSet(object.typed_config) ? Any.fromJSON(object.typed_config) : undefined,
    };
  },

  toJSON(message: RequestIDExtension): unknown {
    const obj: any = {};
    if (message.typed_config !== undefined) {
      obj.typed_config = Any.toJSON(message.typed_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestIDExtension>, I>>(base?: I): RequestIDExtension {
    return RequestIDExtension.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestIDExtension>, I>>(object: I): RequestIDExtension {
    const message = createBaseRequestIDExtension();
    message.typed_config = (object.typed_config !== undefined && object.typed_config !== null)
      ? Any.fromPartial(object.typed_config)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(RequestIDExtension.$type, RequestIDExtension);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
