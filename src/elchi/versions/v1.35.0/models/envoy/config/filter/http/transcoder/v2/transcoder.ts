// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/config/filter/http/transcoder/v2/transcoder.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { messageTypeRegistry } from "../../../../../../typeRegistry";

export const protobufPackage = "envoy.config.filter.http.transcoder.v2";

/** [#next-free-field: 10] */
export interface GrpcJsonTranscoder {
  $type: "envoy.config.filter.http.transcoder.v2.GrpcJsonTranscoder";
  descriptor_set?:
    | //
    /**
     * Supplies the filename of
     * :ref:`the proto descriptor set <config_grpc_json_generate_proto_descriptor_set>` for the gRPC
     * services.
     */
    { $case: "proto_descriptor"; proto_descriptor: string }
    | //
    /**
     * Supplies the binary content of
     * :ref:`the proto descriptor set <config_grpc_json_generate_proto_descriptor_set>` for the gRPC
     * services.
     */
    { $case: "proto_descriptor_bin"; proto_descriptor_bin: Uint8Array }
    | undefined;
  /**
   * A list of strings that
   * supplies the fully qualified service names (i.e. "package_name.service_name") that
   * the transcoder will translate. If the service name doesn't exist in ``proto_descriptor``,
   * Envoy will fail at startup. The ``proto_descriptor`` may contain more services than
   * the service names specified here, but they won't be translated.
   */
  services?:
    | string[]
    | undefined;
  /**
   * Control options for response JSON. These options are passed directly to
   * `JsonPrintOptions <https://developers.google.com/protocol-buffers/docs/reference/cpp/
   * google.protobuf.util.json_util#JsonPrintOptions>`_.
   */
  print_options?:
    | GrpcJsonTranscoder_PrintOptions
    | undefined;
  /**
   * Whether to keep the incoming request route after the outgoing headers have been transformed to
   * the match the upstream gRPC service. Note: This means that routes for gRPC services that are
   * not transcoded cannot be used in combination with *match_incoming_request_route*.
   */
  match_incoming_request_route?:
    | boolean
    | undefined;
  /**
   * A list of query parameters to be ignored for transcoding method mapping.
   * By default, the transcoder filter will not transcode a request if there are any
   * unknown/invalid query parameters.
   *
   * Example :
   *
   * .. code-block:: proto
   *
   *     service Bookstore {
   *       rpc GetShelf(GetShelfRequest) returns (Shelf) {
   *         option (google.api.http) = {
   *           get: "/shelves/{shelf}"
   *         };
   *       }
   *     }
   *
   *     message GetShelfRequest {
   *       int64 shelf = 1;
   *     }
   *
   *     message Shelf {}
   *
   * The request ``/shelves/100?foo=bar`` will not be mapped to ``GetShelf``` because variable
   * binding for ``foo`` is not defined. Adding ``foo`` to ``ignored_query_parameters`` will allow
   * the same request to be mapped to ``GetShelf``.
   */
  ignored_query_parameters?:
    | string[]
    | undefined;
  /**
   * Whether to route methods without the ``google.api.http`` option.
   *
   * Example :
   *
   * .. code-block:: proto
   *
   *     package bookstore;
   *
   *     service Bookstore {
   *       rpc GetShelf(GetShelfRequest) returns (Shelf) {}
   *     }
   *
   *     message GetShelfRequest {
   *       int64 shelf = 1;
   *     }
   *
   *     message Shelf {}
   *
   * The client could ``post`` a json body ``{"shelf": 1234}`` with the path of
   * ``/bookstore.Bookstore/GetShelfRequest`` to call ``GetShelfRequest``.
   */
  auto_mapping?:
    | boolean
    | undefined;
  /**
   * Whether to ignore query parameters that cannot be mapped to a corresponding
   * protobuf field. Use this if you cannot control the query parameters and do
   * not know them beforehand. Otherwise use ``ignored_query_parameters``.
   * Defaults to false.
   */
  ignore_unknown_query_parameters?:
    | boolean
    | undefined;
  /**
   * Whether to convert gRPC status headers to JSON.
   * When trailer indicates a gRPC error and there was no HTTP body, take ``google.rpc.Status``
   * from the ``grpc-status-details-bin`` header and use it as JSON body.
   * If there was no such header, make ``google.rpc.Status`` out of the ``grpc-status`` and
   * ``grpc-message`` headers.
   * The error details types must be present in the ``proto_descriptor``.
   *
   * For example, if an upstream server replies with headers:
   *
   * .. code-block:: none
   *
   *     grpc-status: 5
   *     grpc-status-details-bin:
   *         CAUaMwoqdHlwZS5nb29nbGVhcGlzLmNvbS9nb29nbGUucnBjLlJlcXVlc3RJbmZvEgUKA3ItMQ
   *
   * The ``grpc-status-details-bin`` header contains a base64-encoded protobuf message
   * ``google.rpc.Status``. It will be transcoded into:
   *
   * .. code-block:: none
   *
   *     HTTP/1.1 404 Not Found
   *     content-type: application/json
   *
   *     {"code":5,"details":[{"@type":"type.googleapis.com/google.rpc.RequestInfo","requestId":"r-1"}]}
   *
   * In order to transcode the message, the ``google.rpc.RequestInfo`` type from
   * the ``google/rpc/error_details.proto`` should be included in the configured
   * :ref:`proto descriptor set <config_grpc_json_generate_proto_descriptor_set>`.
   */
  convert_grpc_status?: boolean | undefined;
}

export interface GrpcJsonTranscoder_PrintOptions {
  $type: "envoy.config.filter.http.transcoder.v2.GrpcJsonTranscoder.PrintOptions";
  /**
   * Whether to add spaces, line breaks and indentation to make the JSON
   * output easy to read. Defaults to false.
   */
  add_whitespace?:
    | boolean
    | undefined;
  /**
   * Whether to always print primitive fields. By default primitive
   * fields with default values will be omitted in JSON output. For
   * example, an int32 field set to 0 will be omitted. Setting this flag to
   * true will override the default behavior and print primitive fields
   * regardless of their values. Defaults to false.
   */
  always_print_primitive_fields?:
    | boolean
    | undefined;
  /**
   * Whether to always print enums as ints. By default they are rendered
   * as strings. Defaults to false.
   */
  always_print_enums_as_ints?:
    | boolean
    | undefined;
  /**
   * Whether to preserve proto field names. By default protobuf will
   * generate JSON field names using the ``json_name`` option, or lower camel case,
   * in that order. Setting this flag will preserve the original field names. Defaults to false.
   */
  preserve_proto_field_names?: boolean | undefined;
}

function createBaseGrpcJsonTranscoder(): GrpcJsonTranscoder {
  return { $type: "envoy.config.filter.http.transcoder.v2.GrpcJsonTranscoder", descriptor_set: undefined };
}

export const GrpcJsonTranscoder: MessageFns<
  GrpcJsonTranscoder,
  "envoy.config.filter.http.transcoder.v2.GrpcJsonTranscoder"
> = {
  $type: "envoy.config.filter.http.transcoder.v2.GrpcJsonTranscoder" as const,

  encode(message: GrpcJsonTranscoder, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.descriptor_set?.$case) {
      case "proto_descriptor":
        writer.uint32(10).string(message.descriptor_set.proto_descriptor);
        break;
      case "proto_descriptor_bin":
        writer.uint32(34).bytes(message.descriptor_set.proto_descriptor_bin);
        break;
    }
    if (message.services !== undefined && message.services.length !== 0) {
      for (const v of message.services) {
        writer.uint32(18).string(v!);
      }
    }
    if (message.print_options !== undefined) {
      GrpcJsonTranscoder_PrintOptions.encode(message.print_options, writer.uint32(26).fork()).join();
    }
    if (message.match_incoming_request_route !== undefined && message.match_incoming_request_route !== false) {
      writer.uint32(40).bool(message.match_incoming_request_route);
    }
    if (message.ignored_query_parameters !== undefined && message.ignored_query_parameters.length !== 0) {
      for (const v of message.ignored_query_parameters) {
        writer.uint32(50).string(v!);
      }
    }
    if (message.auto_mapping !== undefined && message.auto_mapping !== false) {
      writer.uint32(56).bool(message.auto_mapping);
    }
    if (message.ignore_unknown_query_parameters !== undefined && message.ignore_unknown_query_parameters !== false) {
      writer.uint32(64).bool(message.ignore_unknown_query_parameters);
    }
    if (message.convert_grpc_status !== undefined && message.convert_grpc_status !== false) {
      writer.uint32(72).bool(message.convert_grpc_status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrpcJsonTranscoder {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrpcJsonTranscoder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.descriptor_set = { $case: "proto_descriptor", proto_descriptor: reader.string() };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.descriptor_set = { $case: "proto_descriptor_bin", proto_descriptor_bin: reader.bytes() };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.services === undefined) {
            message.services = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.services!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.print_options = GrpcJsonTranscoder_PrintOptions.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.match_incoming_request_route = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          if (message.ignored_query_parameters === undefined) {
            message.ignored_query_parameters = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.ignored_query_parameters!.push(el);
          }
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.auto_mapping = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.ignore_unknown_query_parameters = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.convert_grpc_status = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrpcJsonTranscoder {
    return {
      $type: GrpcJsonTranscoder.$type,
      descriptor_set: isSet(object.proto_descriptor)
        ? { $case: "proto_descriptor", proto_descriptor: globalThis.String(object.proto_descriptor) }
        : isSet(object.proto_descriptor_bin)
        ? { $case: "proto_descriptor_bin", proto_descriptor_bin: bytesFromBase64(object.proto_descriptor_bin) }
        : undefined,
      services: globalThis.Array.isArray(object?.services)
        ? object.services.map((e: any) => globalThis.String(e))
        : undefined,
      print_options: isSet(object.print_options)
        ? GrpcJsonTranscoder_PrintOptions.fromJSON(object.print_options)
        : undefined,
      match_incoming_request_route: isSet(object.match_incoming_request_route)
        ? globalThis.Boolean(object.match_incoming_request_route)
        : undefined,
      ignored_query_parameters: globalThis.Array.isArray(object?.ignored_query_parameters)
        ? object.ignored_query_parameters.map((e: any) => globalThis.String(e))
        : undefined,
      auto_mapping: isSet(object.auto_mapping) ? globalThis.Boolean(object.auto_mapping) : undefined,
      ignore_unknown_query_parameters: isSet(object.ignore_unknown_query_parameters)
        ? globalThis.Boolean(object.ignore_unknown_query_parameters)
        : undefined,
      convert_grpc_status: isSet(object.convert_grpc_status)
        ? globalThis.Boolean(object.convert_grpc_status)
        : undefined,
    };
  },

  toJSON(message: GrpcJsonTranscoder): unknown {
    const obj: any = {};
    if (message.descriptor_set?.$case === "proto_descriptor") {
      obj.proto_descriptor = message.descriptor_set.proto_descriptor;
    }
    if (message.descriptor_set?.$case === "proto_descriptor_bin") {
      obj.proto_descriptor_bin = base64FromBytes(message.descriptor_set.proto_descriptor_bin);
    }
    if (message.services?.length) {
      obj.services = message.services;
    }
    if (message.print_options !== undefined) {
      obj.print_options = GrpcJsonTranscoder_PrintOptions.toJSON(message.print_options);
    }
    if (message.match_incoming_request_route !== undefined) {
      obj.match_incoming_request_route = message.match_incoming_request_route;
    }
    if (message.ignored_query_parameters?.length) {
      obj.ignored_query_parameters = message.ignored_query_parameters;
    }
    if (message.auto_mapping !== undefined) {
      obj.auto_mapping = message.auto_mapping;
    }
    if (message.ignore_unknown_query_parameters !== undefined) {
      obj.ignore_unknown_query_parameters = message.ignore_unknown_query_parameters;
    }
    if (message.convert_grpc_status !== undefined) {
      obj.convert_grpc_status = message.convert_grpc_status;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GrpcJsonTranscoder>, I>>(base?: I): GrpcJsonTranscoder {
    return GrpcJsonTranscoder.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GrpcJsonTranscoder>, I>>(object: I): GrpcJsonTranscoder {
    const message = createBaseGrpcJsonTranscoder();
    if (
      object.descriptor_set?.$case === "proto_descriptor" &&
      object.descriptor_set?.proto_descriptor !== undefined &&
      object.descriptor_set?.proto_descriptor !== null
    ) {
      message.descriptor_set = { $case: "proto_descriptor", proto_descriptor: object.descriptor_set.proto_descriptor };
    }
    if (
      object.descriptor_set?.$case === "proto_descriptor_bin" &&
      object.descriptor_set?.proto_descriptor_bin !== undefined &&
      object.descriptor_set?.proto_descriptor_bin !== null
    ) {
      message.descriptor_set = {
        $case: "proto_descriptor_bin",
        proto_descriptor_bin: object.descriptor_set.proto_descriptor_bin,
      };
    }
    message.services = object.services?.map((e) => e) || undefined;
    message.print_options = (object.print_options !== undefined && object.print_options !== null)
      ? GrpcJsonTranscoder_PrintOptions.fromPartial(object.print_options)
      : undefined;
    message.match_incoming_request_route = object.match_incoming_request_route ?? undefined;
    message.ignored_query_parameters = object.ignored_query_parameters?.map((e) => e) || undefined;
    message.auto_mapping = object.auto_mapping ?? undefined;
    message.ignore_unknown_query_parameters = object.ignore_unknown_query_parameters ?? undefined;
    message.convert_grpc_status = object.convert_grpc_status ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(GrpcJsonTranscoder.$type, GrpcJsonTranscoder);

function createBaseGrpcJsonTranscoder_PrintOptions(): GrpcJsonTranscoder_PrintOptions {
  return { $type: "envoy.config.filter.http.transcoder.v2.GrpcJsonTranscoder.PrintOptions" };
}

export const GrpcJsonTranscoder_PrintOptions: MessageFns<
  GrpcJsonTranscoder_PrintOptions,
  "envoy.config.filter.http.transcoder.v2.GrpcJsonTranscoder.PrintOptions"
> = {
  $type: "envoy.config.filter.http.transcoder.v2.GrpcJsonTranscoder.PrintOptions" as const,

  encode(message: GrpcJsonTranscoder_PrintOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.add_whitespace !== undefined && message.add_whitespace !== false) {
      writer.uint32(8).bool(message.add_whitespace);
    }
    if (message.always_print_primitive_fields !== undefined && message.always_print_primitive_fields !== false) {
      writer.uint32(16).bool(message.always_print_primitive_fields);
    }
    if (message.always_print_enums_as_ints !== undefined && message.always_print_enums_as_ints !== false) {
      writer.uint32(24).bool(message.always_print_enums_as_ints);
    }
    if (message.preserve_proto_field_names !== undefined && message.preserve_proto_field_names !== false) {
      writer.uint32(32).bool(message.preserve_proto_field_names);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrpcJsonTranscoder_PrintOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrpcJsonTranscoder_PrintOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.add_whitespace = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.always_print_primitive_fields = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.always_print_enums_as_ints = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.preserve_proto_field_names = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrpcJsonTranscoder_PrintOptions {
    return {
      $type: GrpcJsonTranscoder_PrintOptions.$type,
      add_whitespace: isSet(object.add_whitespace) ? globalThis.Boolean(object.add_whitespace) : undefined,
      always_print_primitive_fields: isSet(object.always_print_primitive_fields)
        ? globalThis.Boolean(object.always_print_primitive_fields)
        : undefined,
      always_print_enums_as_ints: isSet(object.always_print_enums_as_ints)
        ? globalThis.Boolean(object.always_print_enums_as_ints)
        : undefined,
      preserve_proto_field_names: isSet(object.preserve_proto_field_names)
        ? globalThis.Boolean(object.preserve_proto_field_names)
        : undefined,
    };
  },

  toJSON(message: GrpcJsonTranscoder_PrintOptions): unknown {
    const obj: any = {};
    if (message.add_whitespace !== undefined) {
      obj.add_whitespace = message.add_whitespace;
    }
    if (message.always_print_primitive_fields !== undefined) {
      obj.always_print_primitive_fields = message.always_print_primitive_fields;
    }
    if (message.always_print_enums_as_ints !== undefined) {
      obj.always_print_enums_as_ints = message.always_print_enums_as_ints;
    }
    if (message.preserve_proto_field_names !== undefined) {
      obj.preserve_proto_field_names = message.preserve_proto_field_names;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GrpcJsonTranscoder_PrintOptions>, I>>(base?: I): GrpcJsonTranscoder_PrintOptions {
    return GrpcJsonTranscoder_PrintOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GrpcJsonTranscoder_PrintOptions>, I>>(
    object: I,
  ): GrpcJsonTranscoder_PrintOptions {
    const message = createBaseGrpcJsonTranscoder_PrintOptions();
    message.add_whitespace = object.add_whitespace ?? undefined;
    message.always_print_primitive_fields = object.always_print_primitive_fields ?? undefined;
    message.always_print_enums_as_ints = object.always_print_enums_as_ints ?? undefined;
    message.preserve_proto_field_names = object.preserve_proto_field_names ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(GrpcJsonTranscoder_PrintOptions.$type, GrpcJsonTranscoder_PrintOptions);

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
