// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/api/v2/listener.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../google/protobuf/duration";
import { BoolValue, UInt32Value } from "../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../typeRegistry";
import { AccessLog } from "../../config/filter/accesslog/v2/accesslog";
import { ApiListener } from "../../config/listener/v2/api_listener";
import { Address } from "./core/address";
import {
  Metadata,
  TrafficDirection,
  trafficDirectionFromJSON,
  trafficDirectionToJSON,
  trafficDirectionToNumber,
} from "./core/base";
import { SocketOption } from "./core/socket_option";
import { FilterChain, ListenerFilter } from "./listener/listener_components";
import { UdpListenerConfig } from "./listener/udp_listener_config";

export const protobufPackage = "envoy.api.v2";

/** [#next-free-field: 23] */
export interface Listener {
  $type: "envoy.api.v2.Listener";
  /**
   * The unique name by which this listener is known. If no name is provided,
   * Envoy will allocate an internal UUID for the listener. If the listener is to be dynamically
   * updated or removed via :ref:`LDS <config_listeners_lds>` a unique name must be provided.
   */
  name?:
    | string
    | undefined;
  /**
   * The address that the listener should listen on. In general, the address must be unique, though
   * that is governed by the bind rules of the OS. E.g., multiple listeners can listen on port 0 on
   * Linux as the actual port will be allocated by the OS.
   */
  address?:
    | Address
    | undefined;
  /**
   * A list of filter chains to consider for this listener. The
   * :ref:`FilterChain <envoy_api_msg_listener.FilterChain>` with the most specific
   * :ref:`FilterChainMatch <envoy_api_msg_listener.FilterChainMatch>` criteria is used on a
   * connection.
   *
   * Example using SNI for filter chain selection can be found in the
   * :ref:`FAQ entry <faq_how_to_setup_sni>`.
   */
  filter_chains?:
    | FilterChain[]
    | undefined;
  /**
   * If a connection is redirected using *iptables*, the port on which the proxy
   * receives it might be different from the original destination address. When this flag is set to
   * true, the listener hands off redirected connections to the listener associated with the
   * original destination address. If there is no listener associated with the original destination
   * address, the connection is handled by the listener that receives it. Defaults to false.
   *
   * .. attention::
   *
   *   This field is deprecated. Use :ref:`an original_dst <config_listener_filters_original_dst>`
   *   :ref:`listener filter <envoy_api_field_Listener.listener_filters>` instead.
   *
   *   Note that hand off to another listener is *NOT* performed without this flag. Once
   *   :ref:`FilterChainMatch <envoy_api_msg_listener.FilterChainMatch>` is implemented this flag
   *   will be removed, as filter chain matching can be used to select a filter chain based on the
   *   restored destination address.
   *
   * @deprecated
   */
  use_original_dst?:
    | boolean
    | undefined;
  /**
   * Soft limit on size of the listenerâ€™s new connection read and write buffers.
   * If unspecified, an implementation defined default is applied (1MiB).
   */
  per_connection_buffer_limit_bytes?:
    | number
    | undefined;
  /** Listener metadata. */
  metadata?:
    | Metadata
    | undefined;
  /** [#not-implemented-hide:] */
  deprecated_v1?:
    | Listener_DeprecatedV1
    | undefined;
  /** The type of draining to perform at a listener-wide level. */
  drain_type?:
    | Listener_DrainType
    | undefined;
  /**
   * Listener filters have the opportunity to manipulate and augment the connection metadata that
   * is used in connection filter chain matching, for example. These filters are run before any in
   * :ref:`filter_chains <envoy_api_field_Listener.filter_chains>`. Order matters as the
   * filters are processed sequentially right after a socket has been accepted by the listener, and
   * before a connection is created.
   * UDP Listener filters can be specified when the protocol in the listener socket address in
   * :ref:`protocol <envoy_api_field_core.SocketAddress.protocol>` is :ref:`UDP
   * <envoy_api_enum_value_core.SocketAddress.Protocol.UDP>`.
   * UDP listeners currently support a single filter.
   */
  listener_filters?:
    | ListenerFilter[]
    | undefined;
  /**
   * The timeout to wait for all listener filters to complete operation. If the timeout is reached,
   * the accepted socket is closed without a connection being created unless
   * `continue_on_listener_filters_timeout` is set to true. Specify 0 to disable the
   * timeout. If not specified, a default timeout of 15s is used.
   */
  listener_filters_timeout?:
    | Duration
    | undefined;
  /**
   * Whether a connection should be created when listener filters timeout. Default is false.
   *
   * .. attention::
   *
   *   Some listener filters, such as :ref:`Proxy Protocol filter
   *   <config_listener_filters_proxy_protocol>`, should not be used with this option. It will cause
   *   unexpected behavior when a connection is created.
   */
  continue_on_listener_filters_timeout?:
    | boolean
    | undefined;
  /**
   * Whether the listener should be set as a transparent socket.
   * When this flag is set to true, connections can be redirected to the listener using an
   * *iptables* *TPROXY* target, in which case the original source and destination addresses and
   * ports are preserved on accepted connections. This flag should be used in combination with
   * :ref:`an original_dst <config_listener_filters_original_dst>` :ref:`listener filter
   * <envoy_api_field_Listener.listener_filters>` to mark the connections' local addresses as
   * "restored." This can be used to hand off each redirected connection to another listener
   * associated with the connection's destination address. Direct connections to the socket without
   * using *TPROXY* cannot be distinguished from connections redirected using *TPROXY* and are
   * therefore treated as if they were redirected.
   * When this flag is set to false, the listener's socket is explicitly reset as non-transparent.
   * Setting this flag requires Envoy to run with the *CAP_NET_ADMIN* capability.
   * When this flag is not set (default), the socket is not modified, i.e. the transparent option
   * is neither set nor reset.
   */
  transparent?:
    | boolean
    | undefined;
  /**
   * Whether the listener should set the *IP_FREEBIND* socket option. When this
   * flag is set to true, listeners can be bound to an IP address that is not
   * configured on the system running Envoy. When this flag is set to false, the
   * option *IP_FREEBIND* is disabled on the socket. When this flag is not set
   * (default), the socket is not modified, i.e. the option is neither enabled
   * nor disabled.
   */
  freebind?:
    | boolean
    | undefined;
  /**
   * Additional socket options that may not be present in Envoy source code or
   * precompiled binaries.
   */
  socket_options?:
    | SocketOption[]
    | undefined;
  /**
   * Whether the listener should accept TCP Fast Open (TFO) connections.
   * When this flag is set to a value greater than 0, the option TCP_FASTOPEN is enabled on
   * the socket, with a queue length of the specified size
   * (see `details in RFC7413 <https://tools.ietf.org/html/rfc7413#section-5.1>`_).
   * When this flag is set to 0, the option TCP_FASTOPEN is disabled on the socket.
   * When this flag is not set (default), the socket is not modified,
   * i.e. the option is neither enabled nor disabled.
   *
   * On Linux, the net.ipv4.tcp_fastopen kernel parameter must include flag 0x2 to enable
   * TCP_FASTOPEN.
   * See `ip-sysctl.txt <https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt>`_.
   *
   * On macOS, only values of 0, 1, and unset are valid; other values may result in an error.
   * To set the queue length on macOS, set the net.inet.tcp.fastopen_backlog kernel parameter.
   */
  tcp_fast_open_queue_length?:
    | number
    | undefined;
  /**
   * Specifies the intended direction of the traffic relative to the local Envoy.
   * This property is required on Windows for listeners using the original destination filter,
   * see :ref:`Original Destination <config_listener_filters_original_dst>`.
   */
  traffic_direction?:
    | TrafficDirection
    | undefined;
  /**
   * If the protocol in the listener socket address in :ref:`protocol
   * <envoy_api_field_core.SocketAddress.protocol>` is :ref:`UDP
   * <envoy_api_enum_value_core.SocketAddress.Protocol.UDP>`, this field specifies the actual udp
   * listener to create, i.e. :ref:`udp_listener_name
   * <envoy_api_field_listener.UdpListenerConfig.udp_listener_name>` = "raw_udp_listener" for
   * creating a packet-oriented UDP listener. If not present, treat it as "raw_udp_listener".
   */
  udp_listener_config?:
    | UdpListenerConfig
    | undefined;
  /**
   * Used to represent an API listener, which is used in non-proxy clients. The type of API
   * exposed to the non-proxy application depends on the type of API listener.
   * When this field is set, no other field except for :ref:`name<envoy_api_field_Listener.name>`
   * should be set.
   *
   * .. note::
   *
   *  Currently only one ApiListener can be installed; and it can only be done via bootstrap config,
   *  not LDS.
   *
   * [#next-major-version: In the v3 API, instead of this messy approach where the socket
   * listener fields are directly in the top-level Listener message and the API listener types
   * are in the ApiListener message, the socket listener messages should be in their own message,
   * and the top-level Listener should essentially be a oneof that selects between the
   * socket listener and the various types of API listener. That way, a given Listener message
   * can structurally only contain the fields of the relevant type.]
   */
  api_listener?:
    | ApiListener
    | undefined;
  /**
   * The listener's connection balancer configuration, currently only applicable to TCP listeners.
   * If no configuration is specified, Envoy will not attempt to balance active connections between
   * worker threads.
   */
  connection_balance_config?:
    | Listener_ConnectionBalanceConfig
    | undefined;
  /**
   * When this flag is set to true, listeners set the *SO_REUSEPORT* socket option and
   * create one socket for each worker thread. This makes inbound connections
   * distribute among worker threads roughly evenly in cases where there are a high number
   * of connections. When this flag is set to false, all worker threads share one socket.
   *
   * Before Linux v4.19-rc1, new TCP connections may be rejected during hot restart
   * (see `3rd paragraph in 'soreuseport' commit message
   * <https://github.com/torvalds/linux/commit/c617f398edd4db2b8567a28e89>`_).
   * This issue was fixed by `tcp: Avoid TCP syncookie rejected by SO_REUSEPORT socket
   * <https://github.com/torvalds/linux/commit/40a1227ea845a37ab197dd1caffb60b047fa36b1>`_.
   */
  reuse_port?:
    | boolean
    | undefined;
  /**
   * Configuration for :ref:`access logs <arch_overview_access_logs>`
   * emitted by this listener.
   */
  access_log?: AccessLog[] | undefined;
}

export enum Listener_DrainType {
  /**
   * DEFAULT - Drain in response to calling /healthcheck/fail admin endpoint (along with the health check
   * filter), listener removal/modification, and hot restart.
   */
  DEFAULT = "DEFAULT",
  /**
   * MODIFY_ONLY - Drain in response to listener removal/modification and hot restart. This setting does not
   * include /healthcheck/fail. This setting may be desirable if Envoy is hosting both ingress
   * and egress listeners.
   */
  MODIFY_ONLY = "MODIFY_ONLY",
}

export function listener_DrainTypeFromJSON(object: any): Listener_DrainType {
  switch (object) {
    case 0:
    case "DEFAULT":
      return Listener_DrainType.DEFAULT;
    case 1:
    case "MODIFY_ONLY":
      return Listener_DrainType.MODIFY_ONLY;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Listener_DrainType");
  }
}

export function listener_DrainTypeToJSON(object: Listener_DrainType): string {
  switch (object) {
    case Listener_DrainType.DEFAULT:
      return "DEFAULT";
    case Listener_DrainType.MODIFY_ONLY:
      return "MODIFY_ONLY";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Listener_DrainType");
  }
}

export function listener_DrainTypeToNumber(object: Listener_DrainType): number {
  switch (object) {
    case Listener_DrainType.DEFAULT:
      return 0;
    case Listener_DrainType.MODIFY_ONLY:
      return 1;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Listener_DrainType");
  }
}

/** [#not-implemented-hide:] */
export interface Listener_DeprecatedV1 {
  $type: "envoy.api.v2.Listener.DeprecatedV1";
  /**
   * Whether the listener should bind to the port. A listener that doesn't
   * bind can only receive connections redirected from other listeners that
   * set use_original_dst parameter to true. Default is true.
   *
   * This is deprecated in v2, all Listeners will bind to their port. An
   * additional filter chain must be created for every original destination
   * port this listener may redirect to in v2, with the original port
   * specified in the FilterChainMatch destination_port field.
   *
   * [#comment:TODO(PiotrSikora): Remove this once verified that we no longer need it.]
   */
  bind_to_port?: boolean | undefined;
}

/** Configuration for listener connection balancing. */
export interface Listener_ConnectionBalanceConfig {
  $type: "envoy.api.v2.Listener.ConnectionBalanceConfig";
  balance_type?:
    | //
    /** If specified, the listener will use the exact connection balancer. */
    { $case: "exact_balance"; exact_balance: Listener_ConnectionBalanceConfig_ExactBalance }
    | undefined;
}

/**
 * A connection balancer implementation that does exact balancing. This means that a lock is
 * held during balancing so that connection counts are nearly exactly balanced between worker
 * threads. This is "nearly" exact in the sense that a connection might close in parallel thus
 * making the counts incorrect, but this should be rectified on the next accept. This balancer
 * sacrifices accept throughput for accuracy and should be used when there are a small number of
 * connections that rarely cycle (e.g., service mesh gRPC egress).
 */
export interface Listener_ConnectionBalanceConfig_ExactBalance {
  $type: "envoy.api.v2.Listener.ConnectionBalanceConfig.ExactBalance";
}

function createBaseListener(): Listener {
  return { $type: "envoy.api.v2.Listener" };
}

export const Listener: MessageFns<Listener, "envoy.api.v2.Listener"> = {
  $type: "envoy.api.v2.Listener" as const,

  encode(message: Listener, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.address !== undefined) {
      Address.encode(message.address, writer.uint32(18).fork()).join();
    }
    if (message.filter_chains !== undefined && message.filter_chains.length !== 0) {
      for (const v of message.filter_chains) {
        FilterChain.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    if (message.use_original_dst !== undefined) {
      BoolValue.encode(
        { $type: "google.protobuf.BoolValue", value: message.use_original_dst! },
        writer.uint32(34).fork(),
      ).join();
    }
    if (message.per_connection_buffer_limit_bytes !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.per_connection_buffer_limit_bytes! },
        writer.uint32(42).fork(),
      ).join();
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(50).fork()).join();
    }
    if (message.deprecated_v1 !== undefined) {
      Listener_DeprecatedV1.encode(message.deprecated_v1, writer.uint32(58).fork()).join();
    }
    if (message.drain_type !== undefined && message.drain_type !== Listener_DrainType.DEFAULT) {
      writer.uint32(64).int32(listener_DrainTypeToNumber(message.drain_type));
    }
    if (message.listener_filters !== undefined && message.listener_filters.length !== 0) {
      for (const v of message.listener_filters) {
        ListenerFilter.encode(v!, writer.uint32(74).fork()).join();
      }
    }
    if (message.listener_filters_timeout !== undefined) {
      Duration.encode(message.listener_filters_timeout, writer.uint32(122).fork()).join();
    }
    if (
      message.continue_on_listener_filters_timeout !== undefined &&
      message.continue_on_listener_filters_timeout !== false
    ) {
      writer.uint32(136).bool(message.continue_on_listener_filters_timeout);
    }
    if (message.transparent !== undefined) {
      BoolValue.encode({ $type: "google.protobuf.BoolValue", value: message.transparent! }, writer.uint32(82).fork())
        .join();
    }
    if (message.freebind !== undefined) {
      BoolValue.encode({ $type: "google.protobuf.BoolValue", value: message.freebind! }, writer.uint32(90).fork())
        .join();
    }
    if (message.socket_options !== undefined && message.socket_options.length !== 0) {
      for (const v of message.socket_options) {
        SocketOption.encode(v!, writer.uint32(106).fork()).join();
      }
    }
    if (message.tcp_fast_open_queue_length !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.tcp_fast_open_queue_length! },
        writer.uint32(98).fork(),
      ).join();
    }
    if (message.traffic_direction !== undefined && message.traffic_direction !== TrafficDirection.UNSPECIFIED) {
      writer.uint32(128).int32(trafficDirectionToNumber(message.traffic_direction));
    }
    if (message.udp_listener_config !== undefined) {
      UdpListenerConfig.encode(message.udp_listener_config, writer.uint32(146).fork()).join();
    }
    if (message.api_listener !== undefined) {
      ApiListener.encode(message.api_listener, writer.uint32(154).fork()).join();
    }
    if (message.connection_balance_config !== undefined) {
      Listener_ConnectionBalanceConfig.encode(message.connection_balance_config, writer.uint32(162).fork()).join();
    }
    if (message.reuse_port !== undefined && message.reuse_port !== false) {
      writer.uint32(168).bool(message.reuse_port);
    }
    if (message.access_log !== undefined && message.access_log.length !== 0) {
      for (const v of message.access_log) {
        AccessLog.encode(v!, writer.uint32(178).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Listener {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListener();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = Address.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.filter_chains === undefined) {
            message.filter_chains = [];
          }
          const el = FilterChain.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.filter_chains!.push(el);
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.use_original_dst = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.per_connection_buffer_limit_bytes = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.deprecated_v1 = Listener_DeprecatedV1.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.drain_type = listener_DrainTypeFromJSON(reader.int32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          if (message.listener_filters === undefined) {
            message.listener_filters = [];
          }
          const el = ListenerFilter.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.listener_filters!.push(el);
          }
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.listener_filters_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.continue_on_listener_filters_timeout = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.transparent = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.freebind = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          if (message.socket_options === undefined) {
            message.socket_options = [];
          }
          const el = SocketOption.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.socket_options!.push(el);
          }
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.tcp_fast_open_queue_length = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.traffic_direction = trafficDirectionFromJSON(reader.int32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.udp_listener_config = UdpListenerConfig.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.api_listener = ApiListener.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.connection_balance_config = Listener_ConnectionBalanceConfig.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.reuse_port = reader.bool();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          if (message.access_log === undefined) {
            message.access_log = [];
          }
          const el = AccessLog.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.access_log!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Listener {
    return {
      $type: Listener.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      address: isSet(object.address) ? Address.fromJSON(object.address) : undefined,
      filter_chains: globalThis.Array.isArray(object?.filter_chains)
        ? object.filter_chains.map((e: any) => FilterChain.fromJSON(e))
        : undefined,
      use_original_dst: isSet(object.use_original_dst) ? Boolean(object.use_original_dst) : undefined,
      per_connection_buffer_limit_bytes: isSet(object.per_connection_buffer_limit_bytes)
        ? Number(object.per_connection_buffer_limit_bytes)
        : undefined,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      deprecated_v1: isSet(object.deprecated_v1) ? Listener_DeprecatedV1.fromJSON(object.deprecated_v1) : undefined,
      drain_type: isSet(object.drain_type) ? listener_DrainTypeFromJSON(object.drain_type) : undefined,
      listener_filters: globalThis.Array.isArray(object?.listener_filters)
        ? object.listener_filters.map((e: any) => ListenerFilter.fromJSON(e))
        : undefined,
      listener_filters_timeout: isSet(object.listener_filters_timeout)
        ? Duration.fromJSON(object.listener_filters_timeout)
        : undefined,
      continue_on_listener_filters_timeout: isSet(object.continue_on_listener_filters_timeout)
        ? globalThis.Boolean(object.continue_on_listener_filters_timeout)
        : undefined,
      transparent: isSet(object.transparent) ? Boolean(object.transparent) : undefined,
      freebind: isSet(object.freebind) ? Boolean(object.freebind) : undefined,
      socket_options: globalThis.Array.isArray(object?.socket_options)
        ? object.socket_options.map((e: any) => SocketOption.fromJSON(e))
        : undefined,
      tcp_fast_open_queue_length: isSet(object.tcp_fast_open_queue_length)
        ? Number(object.tcp_fast_open_queue_length)
        : undefined,
      traffic_direction: isSet(object.traffic_direction)
        ? trafficDirectionFromJSON(object.traffic_direction)
        : undefined,
      udp_listener_config: isSet(object.udp_listener_config)
        ? UdpListenerConfig.fromJSON(object.udp_listener_config)
        : undefined,
      api_listener: isSet(object.api_listener) ? ApiListener.fromJSON(object.api_listener) : undefined,
      connection_balance_config: isSet(object.connection_balance_config)
        ? Listener_ConnectionBalanceConfig.fromJSON(object.connection_balance_config)
        : undefined,
      reuse_port: isSet(object.reuse_port) ? globalThis.Boolean(object.reuse_port) : undefined,
      access_log: globalThis.Array.isArray(object?.access_log)
        ? object.access_log.map((e: any) => AccessLog.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: Listener): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.address !== undefined) {
      obj.address = Address.toJSON(message.address);
    }
    if (message.filter_chains?.length) {
      obj.filter_chains = message.filter_chains.map((e) => FilterChain.toJSON(e));
    }
    if (message.use_original_dst !== undefined) {
      obj.use_original_dst = message.use_original_dst;
    }
    if (message.per_connection_buffer_limit_bytes !== undefined) {
      obj.per_connection_buffer_limit_bytes = message.per_connection_buffer_limit_bytes;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.deprecated_v1 !== undefined) {
      obj.deprecated_v1 = Listener_DeprecatedV1.toJSON(message.deprecated_v1);
    }
    if (message.drain_type !== undefined) {
      obj.drain_type = listener_DrainTypeToJSON(message.drain_type);
    }
    if (message.listener_filters?.length) {
      obj.listener_filters = message.listener_filters.map((e) => ListenerFilter.toJSON(e));
    }
    if (message.listener_filters_timeout !== undefined) {
      obj.listener_filters_timeout = Duration.toJSON(message.listener_filters_timeout);
    }
    if (message.continue_on_listener_filters_timeout !== undefined) {
      obj.continue_on_listener_filters_timeout = message.continue_on_listener_filters_timeout;
    }
    if (message.transparent !== undefined) {
      obj.transparent = message.transparent;
    }
    if (message.freebind !== undefined) {
      obj.freebind = message.freebind;
    }
    if (message.socket_options?.length) {
      obj.socket_options = message.socket_options.map((e) => SocketOption.toJSON(e));
    }
    if (message.tcp_fast_open_queue_length !== undefined) {
      obj.tcp_fast_open_queue_length = message.tcp_fast_open_queue_length;
    }
    if (message.traffic_direction !== undefined) {
      obj.traffic_direction = trafficDirectionToJSON(message.traffic_direction);
    }
    if (message.udp_listener_config !== undefined) {
      obj.udp_listener_config = UdpListenerConfig.toJSON(message.udp_listener_config);
    }
    if (message.api_listener !== undefined) {
      obj.api_listener = ApiListener.toJSON(message.api_listener);
    }
    if (message.connection_balance_config !== undefined) {
      obj.connection_balance_config = Listener_ConnectionBalanceConfig.toJSON(message.connection_balance_config);
    }
    if (message.reuse_port !== undefined) {
      obj.reuse_port = message.reuse_port;
    }
    if (message.access_log?.length) {
      obj.access_log = message.access_log.map((e) => AccessLog.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Listener>, I>>(base?: I): Listener {
    return Listener.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Listener>, I>>(object: I): Listener {
    const message = createBaseListener();
    message.name = object.name ?? undefined;
    message.address = (object.address !== undefined && object.address !== null)
      ? Address.fromPartial(object.address)
      : undefined;
    message.filter_chains = object.filter_chains?.map((e) => FilterChain.fromPartial(e)) || undefined;
    message.use_original_dst = object.use_original_dst ?? undefined;
    message.per_connection_buffer_limit_bytes = object.per_connection_buffer_limit_bytes ?? undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.deprecated_v1 = (object.deprecated_v1 !== undefined && object.deprecated_v1 !== null)
      ? Listener_DeprecatedV1.fromPartial(object.deprecated_v1)
      : undefined;
    message.drain_type = object.drain_type ?? undefined;
    message.listener_filters = object.listener_filters?.map((e) => ListenerFilter.fromPartial(e)) || undefined;
    message.listener_filters_timeout =
      (object.listener_filters_timeout !== undefined && object.listener_filters_timeout !== null)
        ? Duration.fromPartial(object.listener_filters_timeout)
        : undefined;
    message.continue_on_listener_filters_timeout = object.continue_on_listener_filters_timeout ?? undefined;
    message.transparent = object.transparent ?? undefined;
    message.freebind = object.freebind ?? undefined;
    message.socket_options = object.socket_options?.map((e) => SocketOption.fromPartial(e)) || undefined;
    message.tcp_fast_open_queue_length = object.tcp_fast_open_queue_length ?? undefined;
    message.traffic_direction = object.traffic_direction ?? undefined;
    message.udp_listener_config = (object.udp_listener_config !== undefined && object.udp_listener_config !== null)
      ? UdpListenerConfig.fromPartial(object.udp_listener_config)
      : undefined;
    message.api_listener = (object.api_listener !== undefined && object.api_listener !== null)
      ? ApiListener.fromPartial(object.api_listener)
      : undefined;
    message.connection_balance_config =
      (object.connection_balance_config !== undefined && object.connection_balance_config !== null)
        ? Listener_ConnectionBalanceConfig.fromPartial(object.connection_balance_config)
        : undefined;
    message.reuse_port = object.reuse_port ?? undefined;
    message.access_log = object.access_log?.map((e) => AccessLog.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(Listener.$type, Listener);

function createBaseListener_DeprecatedV1(): Listener_DeprecatedV1 {
  return { $type: "envoy.api.v2.Listener.DeprecatedV1" };
}

export const Listener_DeprecatedV1: MessageFns<Listener_DeprecatedV1, "envoy.api.v2.Listener.DeprecatedV1"> = {
  $type: "envoy.api.v2.Listener.DeprecatedV1" as const,

  encode(message: Listener_DeprecatedV1, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bind_to_port !== undefined) {
      BoolValue.encode({ $type: "google.protobuf.BoolValue", value: message.bind_to_port! }, writer.uint32(10).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Listener_DeprecatedV1 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListener_DeprecatedV1();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bind_to_port = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Listener_DeprecatedV1 {
    return {
      $type: Listener_DeprecatedV1.$type,
      bind_to_port: isSet(object.bind_to_port) ? Boolean(object.bind_to_port) : undefined,
    };
  },

  toJSON(message: Listener_DeprecatedV1): unknown {
    const obj: any = {};
    if (message.bind_to_port !== undefined) {
      obj.bind_to_port = message.bind_to_port;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Listener_DeprecatedV1>, I>>(base?: I): Listener_DeprecatedV1 {
    return Listener_DeprecatedV1.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Listener_DeprecatedV1>, I>>(object: I): Listener_DeprecatedV1 {
    const message = createBaseListener_DeprecatedV1();
    message.bind_to_port = object.bind_to_port ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Listener_DeprecatedV1.$type, Listener_DeprecatedV1);

function createBaseListener_ConnectionBalanceConfig(): Listener_ConnectionBalanceConfig {
  return { $type: "envoy.api.v2.Listener.ConnectionBalanceConfig", balance_type: undefined };
}

export const Listener_ConnectionBalanceConfig: MessageFns<
  Listener_ConnectionBalanceConfig,
  "envoy.api.v2.Listener.ConnectionBalanceConfig"
> = {
  $type: "envoy.api.v2.Listener.ConnectionBalanceConfig" as const,

  encode(message: Listener_ConnectionBalanceConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.balance_type?.$case) {
      case "exact_balance":
        Listener_ConnectionBalanceConfig_ExactBalance.encode(
          message.balance_type.exact_balance,
          writer.uint32(10).fork(),
        ).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Listener_ConnectionBalanceConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListener_ConnectionBalanceConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.balance_type = {
            $case: "exact_balance",
            exact_balance: Listener_ConnectionBalanceConfig_ExactBalance.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Listener_ConnectionBalanceConfig {
    return {
      $type: Listener_ConnectionBalanceConfig.$type,
      balance_type: isSet(object.exact_balance)
        ? {
          $case: "exact_balance",
          exact_balance: Listener_ConnectionBalanceConfig_ExactBalance.fromJSON(object.exact_balance),
        }
        : undefined,
    };
  },

  toJSON(message: Listener_ConnectionBalanceConfig): unknown {
    const obj: any = {};
    if (message.balance_type?.$case === "exact_balance") {
      obj.exact_balance = Listener_ConnectionBalanceConfig_ExactBalance.toJSON(message.balance_type.exact_balance);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Listener_ConnectionBalanceConfig>, I>>(
    base?: I,
  ): Listener_ConnectionBalanceConfig {
    return Listener_ConnectionBalanceConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Listener_ConnectionBalanceConfig>, I>>(
    object: I,
  ): Listener_ConnectionBalanceConfig {
    const message = createBaseListener_ConnectionBalanceConfig();
    if (
      object.balance_type?.$case === "exact_balance" &&
      object.balance_type?.exact_balance !== undefined &&
      object.balance_type?.exact_balance !== null
    ) {
      message.balance_type = {
        $case: "exact_balance",
        exact_balance: Listener_ConnectionBalanceConfig_ExactBalance.fromPartial(object.balance_type.exact_balance),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(Listener_ConnectionBalanceConfig.$type, Listener_ConnectionBalanceConfig);

function createBaseListener_ConnectionBalanceConfig_ExactBalance(): Listener_ConnectionBalanceConfig_ExactBalance {
  return { $type: "envoy.api.v2.Listener.ConnectionBalanceConfig.ExactBalance" };
}

export const Listener_ConnectionBalanceConfig_ExactBalance: MessageFns<
  Listener_ConnectionBalanceConfig_ExactBalance,
  "envoy.api.v2.Listener.ConnectionBalanceConfig.ExactBalance"
> = {
  $type: "envoy.api.v2.Listener.ConnectionBalanceConfig.ExactBalance" as const,

  encode(_: Listener_ConnectionBalanceConfig_ExactBalance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Listener_ConnectionBalanceConfig_ExactBalance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListener_ConnectionBalanceConfig_ExactBalance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Listener_ConnectionBalanceConfig_ExactBalance {
    return { $type: Listener_ConnectionBalanceConfig_ExactBalance.$type };
  },

  toJSON(_: Listener_ConnectionBalanceConfig_ExactBalance): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Listener_ConnectionBalanceConfig_ExactBalance>, I>>(
    base?: I,
  ): Listener_ConnectionBalanceConfig_ExactBalance {
    return Listener_ConnectionBalanceConfig_ExactBalance.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Listener_ConnectionBalanceConfig_ExactBalance>, I>>(
    _: I,
  ): Listener_ConnectionBalanceConfig_ExactBalance {
    const message = createBaseListener_ConnectionBalanceConfig_ExactBalance();
    return message;
  },
};

messageTypeRegistry.set(
  Listener_ConnectionBalanceConfig_ExactBalance.$type,
  Listener_ConnectionBalanceConfig_ExactBalance,
);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
