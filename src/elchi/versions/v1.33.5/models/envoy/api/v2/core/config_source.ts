// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/api/v2/core/config_source.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../../google/protobuf/duration";
import { DoubleValue, UInt32Value } from "../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../typeRegistry";
import { GrpcService } from "./grpc_service";

export const protobufPackage = "envoy.api.v2.core";

/**
 * xDS API version. This is used to describe both resource and transport
 * protocol versions (in distinct configuration fields).
 */
export enum ApiVersion {
  /**
   * AUTO - When not specified, we assume v2, to ease migration to Envoy's stable API
   * versioning. If a client does not support v2 (e.g. due to deprecation), this
   * is an invalid value.
   *
   * @deprecated
   */
  AUTO = "AUTO",
  /**
   * V2 - Use xDS v2 API.
   *
   * @deprecated
   */
  V2 = "V2",
  /** V3 - Use xDS v3 API. */
  V3 = "V3",
}

export function apiVersionFromJSON(object: any): ApiVersion {
  switch (object) {
    case 0:
    case "AUTO":
      return ApiVersion.AUTO;
    case 1:
    case "V2":
      return ApiVersion.V2;
    case 2:
    case "V3":
      return ApiVersion.V3;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ApiVersion");
  }
}

export function apiVersionToJSON(object: ApiVersion): string {
  switch (object) {
    case ApiVersion.AUTO:
      return "AUTO";
    case ApiVersion.V2:
      return "V2";
    case ApiVersion.V3:
      return "V3";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ApiVersion");
  }
}

export function apiVersionToNumber(object: ApiVersion): number {
  switch (object) {
    case ApiVersion.AUTO:
      return 0;
    case ApiVersion.V2:
      return 1;
    case ApiVersion.V3:
      return 2;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ApiVersion");
  }
}

/**
 * API configuration source. This identifies the API type and cluster that Envoy
 * will use to fetch an xDS API.
 * [#next-free-field: 9]
 */
export interface ApiConfigSource {
  $type: "envoy.api.v2.core.ApiConfigSource";
  /** API type (gRPC, REST, delta gRPC) */
  api_type?:
    | ApiConfigSource_ApiType
    | undefined;
  /**
   * API version for xDS transport protocol. This describes the xDS gRPC/REST
   * endpoint and version of [Delta]DiscoveryRequest/Response used on the wire.
   */
  transport_api_version?:
    | ApiVersion
    | undefined;
  /**
   * Cluster names should be used only with REST. If > 1
   * cluster is defined, clusters will be cycled through if any kind of failure
   * occurs.
   *
   * .. note::
   *
   *  The cluster with name ``cluster_name`` must be statically defined and its
   *  type must not be ``EDS``.
   */
  cluster_names?:
    | string[]
    | undefined;
  /**
   * Multiple gRPC services be provided for GRPC. If > 1 cluster is defined,
   * services will be cycled through if any kind of failure occurs.
   */
  grpc_services?:
    | GrpcService[]
    | undefined;
  /** For REST APIs, the delay between successive polls. */
  refresh_delay?:
    | Duration
    | undefined;
  /** For REST APIs, the request timeout. If not set, a default value of 1s will be used. */
  request_timeout?:
    | Duration
    | undefined;
  /**
   * For GRPC APIs, the rate limit settings. If present, discovery requests made by Envoy will be
   * rate limited.
   */
  rate_limit_settings?:
    | RateLimitSettings
    | undefined;
  /** Skip the node identifier in subsequent discovery requests for streaming gRPC config types. */
  set_node_on_first_message_only?: boolean | undefined;
}

/** APIs may be fetched via either REST or gRPC. */
export enum ApiConfigSource_ApiType {
  /**
   * UNSUPPORTED_REST_LEGACY - Ideally this would be 'reserved 0' but one can't reserve the default
   * value. Instead we throw an exception if this is ever used.
   *
   * @deprecated
   */
  UNSUPPORTED_REST_LEGACY = "UNSUPPORTED_REST_LEGACY",
  /**
   * REST - REST-JSON v2 API. The `canonical JSON encoding
   * <https://developers.google.com/protocol-buffers/docs/proto3#json>`_ for
   * the v2 protos is used.
   */
  REST = "REST",
  /** GRPC - gRPC v2 API. */
  GRPC = "GRPC",
  /**
   * DELTA_GRPC - Using the delta xDS gRPC service, i.e. DeltaDiscovery{Request,Response}
   * rather than Discovery{Request,Response}. Rather than sending Envoy the entire state
   * with every update, the xDS server only sends what has changed since the last update.
   */
  DELTA_GRPC = "DELTA_GRPC",
}

export function apiConfigSource_ApiTypeFromJSON(object: any): ApiConfigSource_ApiType {
  switch (object) {
    case 0:
    case "UNSUPPORTED_REST_LEGACY":
      return ApiConfigSource_ApiType.UNSUPPORTED_REST_LEGACY;
    case 1:
    case "REST":
      return ApiConfigSource_ApiType.REST;
    case 2:
    case "GRPC":
      return ApiConfigSource_ApiType.GRPC;
    case 3:
    case "DELTA_GRPC":
      return ApiConfigSource_ApiType.DELTA_GRPC;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ApiConfigSource_ApiType");
  }
}

export function apiConfigSource_ApiTypeToJSON(object: ApiConfigSource_ApiType): string {
  switch (object) {
    case ApiConfigSource_ApiType.UNSUPPORTED_REST_LEGACY:
      return "UNSUPPORTED_REST_LEGACY";
    case ApiConfigSource_ApiType.REST:
      return "REST";
    case ApiConfigSource_ApiType.GRPC:
      return "GRPC";
    case ApiConfigSource_ApiType.DELTA_GRPC:
      return "DELTA_GRPC";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ApiConfigSource_ApiType");
  }
}

export function apiConfigSource_ApiTypeToNumber(object: ApiConfigSource_ApiType): number {
  switch (object) {
    case ApiConfigSource_ApiType.UNSUPPORTED_REST_LEGACY:
      return 0;
    case ApiConfigSource_ApiType.REST:
      return 1;
    case ApiConfigSource_ApiType.GRPC:
      return 2;
    case ApiConfigSource_ApiType.DELTA_GRPC:
      return 3;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ApiConfigSource_ApiType");
  }
}

/**
 * Aggregated Discovery Service (ADS) options. This is currently empty, but when
 * set in :ref:`ConfigSource <envoy_api_msg_core.ConfigSource>` can be used to
 * specify that ADS is to be used.
 */
export interface AggregatedConfigSource {
  $type: "envoy.api.v2.core.AggregatedConfigSource";
}

/**
 * [#not-implemented-hide:]
 * Self-referencing config source options. This is currently empty, but when
 * set in :ref:`ConfigSource <envoy_api_msg_core.ConfigSource>` can be used to
 * specify that other data can be obtained from the same server.
 */
export interface SelfConfigSource {
  $type: "envoy.api.v2.core.SelfConfigSource";
  /**
   * API version for xDS transport protocol. This describes the xDS gRPC/REST
   * endpoint and version of [Delta]DiscoveryRequest/Response used on the wire.
   */
  transport_api_version?: ApiVersion | undefined;
}

/** Rate Limit settings to be applied for discovery requests made by Envoy. */
export interface RateLimitSettings {
  $type: "envoy.api.v2.core.RateLimitSettings";
  /**
   * Maximum number of tokens to be used for rate limiting discovery request calls. If not set, a
   * default value of 100 will be used.
   */
  max_tokens?:
    | number
    | undefined;
  /**
   * Rate at which tokens will be filled per second. If not set, a default fill rate of 10 tokens
   * per second will be used.
   */
  fill_rate?: number | undefined;
}

/**
 * Configuration for :ref:`listeners <config_listeners>`, :ref:`clusters
 * <config_cluster_manager>`, :ref:`routes
 * <envoy_api_msg_RouteConfiguration>`, :ref:`endpoints
 * <arch_overview_service_discovery>` etc. may either be sourced from the
 * filesystem or from an xDS API source. Filesystem configs are watched with
 * inotify for updates.
 * [#next-free-field: 7]
 */
export interface ConfigSource {
  $type: "envoy.api.v2.core.ConfigSource";
  config_source_specifier?:
    | //
    /**
     * Path on the filesystem to source and watch for configuration updates.
     * When sourcing configuration for :ref:`secret <envoy_api_msg_auth.Secret>`,
     * the certificate and key files are also watched for updates.
     *
     * .. note::
     *
     *  The path to the source must exist at config load time.
     *
     * .. note::
     *
     *   Envoy will only watch the file path for *moves.* This is because in general only moves
     *   are atomic. The same method of swapping files as is demonstrated in the
     *   :ref:`runtime documentation <config_runtime_symbolic_link_swap>` can be used here also.
     */
    { $case: "path"; path: string }
    | //
    /** API configuration source. */
    { $case: "api_config_source"; api_config_source: ApiConfigSource }
    | //
    /**
     * When set, ADS will be used to fetch resources. The ADS API configuration
     * source in the bootstrap configuration is used.
     */
    { $case: "ads"; ads: AggregatedConfigSource }
    | //
    /**
     * [#not-implemented-hide:]
     * When set, the client will access the resources from the same server it got the
     * ConfigSource from, although not necessarily from the same stream. This is similar to the
     * :ref:`ads<envoy_api_field.ConfigSource.ads>` field, except that the client may use a
     * different stream to the same server. As a result, this field can be used for things
     * like LRS that cannot be sent on an ADS stream. It can also be used to link from (e.g.)
     * LDS to RDS on the same server without requiring the management server to know its name
     * or required credentials.
     * [#next-major-version: In xDS v3, consider replacing the ads field with this one, since
     * this field can implicitly mean to use the same stream in the case where the ConfigSource
     * is provided via ADS and the specified data can also be obtained via ADS.]
     */
    { $case: "self"; self: SelfConfigSource }
    | undefined;
  /**
   * When this timeout is specified, Envoy will wait no longer than the specified time for first
   * config response on this xDS subscription during the :ref:`initialization process
   * <arch_overview_initialization>`. After reaching the timeout, Envoy will move to the next
   * initialization phase, even if the first config is not delivered yet. The timer is activated
   * when the xDS API subscription starts, and is disarmed on first config update or on error. 0
   * means no timeout - Envoy will wait indefinitely for the first xDS config (unless another
   * timeout applies). The default is 15s.
   */
  initial_fetch_timeout?:
    | Duration
    | undefined;
  /**
   * API version for xDS resources. This implies the type URLs that the client
   * will request for resources and the resource type that the client will in
   * turn expect to be delivered.
   */
  resource_api_version?: ApiVersion | undefined;
}

function createBaseApiConfigSource(): ApiConfigSource {
  return { $type: "envoy.api.v2.core.ApiConfigSource" };
}

export const ApiConfigSource: MessageFns<ApiConfigSource, "envoy.api.v2.core.ApiConfigSource"> = {
  $type: "envoy.api.v2.core.ApiConfigSource" as const,

  encode(message: ApiConfigSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.api_type !== undefined && message.api_type !== ApiConfigSource_ApiType.UNSUPPORTED_REST_LEGACY) {
      writer.uint32(8).int32(apiConfigSource_ApiTypeToNumber(message.api_type));
    }
    if (message.transport_api_version !== undefined && message.transport_api_version !== ApiVersion.AUTO) {
      writer.uint32(64).int32(apiVersionToNumber(message.transport_api_version));
    }
    if (message.cluster_names !== undefined && message.cluster_names.length !== 0) {
      for (const v of message.cluster_names) {
        writer.uint32(18).string(v!);
      }
    }
    if (message.grpc_services !== undefined && message.grpc_services.length !== 0) {
      for (const v of message.grpc_services) {
        GrpcService.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    if (message.refresh_delay !== undefined) {
      Duration.encode(message.refresh_delay, writer.uint32(26).fork()).join();
    }
    if (message.request_timeout !== undefined) {
      Duration.encode(message.request_timeout, writer.uint32(42).fork()).join();
    }
    if (message.rate_limit_settings !== undefined) {
      RateLimitSettings.encode(message.rate_limit_settings, writer.uint32(50).fork()).join();
    }
    if (message.set_node_on_first_message_only !== undefined && message.set_node_on_first_message_only !== false) {
      writer.uint32(56).bool(message.set_node_on_first_message_only);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApiConfigSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApiConfigSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.api_type = apiConfigSource_ApiTypeFromJSON(reader.int32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.transport_api_version = apiVersionFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.cluster_names === undefined) {
            message.cluster_names = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.cluster_names!.push(el);
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          if (message.grpc_services === undefined) {
            message.grpc_services = [];
          }
          const el = GrpcService.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.grpc_services!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.refresh_delay = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.request_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.rate_limit_settings = RateLimitSettings.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.set_node_on_first_message_only = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApiConfigSource {
    return {
      $type: ApiConfigSource.$type,
      api_type: isSet(object.api_type) ? apiConfigSource_ApiTypeFromJSON(object.api_type) : undefined,
      transport_api_version: isSet(object.transport_api_version)
        ? apiVersionFromJSON(object.transport_api_version)
        : undefined,
      cluster_names: globalThis.Array.isArray(object?.cluster_names)
        ? object.cluster_names.map((e: any) => globalThis.String(e))
        : undefined,
      grpc_services: globalThis.Array.isArray(object?.grpc_services)
        ? object.grpc_services.map((e: any) => GrpcService.fromJSON(e))
        : undefined,
      refresh_delay: isSet(object.refresh_delay) ? Duration.fromJSON(object.refresh_delay) : undefined,
      request_timeout: isSet(object.request_timeout) ? Duration.fromJSON(object.request_timeout) : undefined,
      rate_limit_settings: isSet(object.rate_limit_settings)
        ? RateLimitSettings.fromJSON(object.rate_limit_settings)
        : undefined,
      set_node_on_first_message_only: isSet(object.set_node_on_first_message_only)
        ? globalThis.Boolean(object.set_node_on_first_message_only)
        : undefined,
    };
  },

  toJSON(message: ApiConfigSource): unknown {
    const obj: any = {};
    if (message.api_type !== undefined) {
      obj.api_type = apiConfigSource_ApiTypeToJSON(message.api_type);
    }
    if (message.transport_api_version !== undefined) {
      obj.transport_api_version = apiVersionToJSON(message.transport_api_version);
    }
    if (message.cluster_names?.length) {
      obj.cluster_names = message.cluster_names;
    }
    if (message.grpc_services?.length) {
      obj.grpc_services = message.grpc_services.map((e) => GrpcService.toJSON(e));
    }
    if (message.refresh_delay !== undefined) {
      obj.refresh_delay = Duration.toJSON(message.refresh_delay);
    }
    if (message.request_timeout !== undefined) {
      obj.request_timeout = Duration.toJSON(message.request_timeout);
    }
    if (message.rate_limit_settings !== undefined) {
      obj.rate_limit_settings = RateLimitSettings.toJSON(message.rate_limit_settings);
    }
    if (message.set_node_on_first_message_only !== undefined) {
      obj.set_node_on_first_message_only = message.set_node_on_first_message_only;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApiConfigSource>, I>>(base?: I): ApiConfigSource {
    return ApiConfigSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApiConfigSource>, I>>(object: I): ApiConfigSource {
    const message = createBaseApiConfigSource();
    message.api_type = object.api_type ?? undefined;
    message.transport_api_version = object.transport_api_version ?? undefined;
    message.cluster_names = object.cluster_names?.map((e) => e) || undefined;
    message.grpc_services = object.grpc_services?.map((e) => GrpcService.fromPartial(e)) || undefined;
    message.refresh_delay = (object.refresh_delay !== undefined && object.refresh_delay !== null)
      ? Duration.fromPartial(object.refresh_delay)
      : undefined;
    message.request_timeout = (object.request_timeout !== undefined && object.request_timeout !== null)
      ? Duration.fromPartial(object.request_timeout)
      : undefined;
    message.rate_limit_settings = (object.rate_limit_settings !== undefined && object.rate_limit_settings !== null)
      ? RateLimitSettings.fromPartial(object.rate_limit_settings)
      : undefined;
    message.set_node_on_first_message_only = object.set_node_on_first_message_only ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ApiConfigSource.$type, ApiConfigSource);

function createBaseAggregatedConfigSource(): AggregatedConfigSource {
  return { $type: "envoy.api.v2.core.AggregatedConfigSource" };
}

export const AggregatedConfigSource: MessageFns<AggregatedConfigSource, "envoy.api.v2.core.AggregatedConfigSource"> = {
  $type: "envoy.api.v2.core.AggregatedConfigSource" as const,

  encode(_: AggregatedConfigSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AggregatedConfigSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregatedConfigSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AggregatedConfigSource {
    return { $type: AggregatedConfigSource.$type };
  },

  toJSON(_: AggregatedConfigSource): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AggregatedConfigSource>, I>>(base?: I): AggregatedConfigSource {
    return AggregatedConfigSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AggregatedConfigSource>, I>>(_: I): AggregatedConfigSource {
    const message = createBaseAggregatedConfigSource();
    return message;
  },
};

messageTypeRegistry.set(AggregatedConfigSource.$type, AggregatedConfigSource);

function createBaseSelfConfigSource(): SelfConfigSource {
  return { $type: "envoy.api.v2.core.SelfConfigSource" };
}

export const SelfConfigSource: MessageFns<SelfConfigSource, "envoy.api.v2.core.SelfConfigSource"> = {
  $type: "envoy.api.v2.core.SelfConfigSource" as const,

  encode(message: SelfConfigSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transport_api_version !== undefined && message.transport_api_version !== ApiVersion.AUTO) {
      writer.uint32(8).int32(apiVersionToNumber(message.transport_api_version));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SelfConfigSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSelfConfigSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.transport_api_version = apiVersionFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SelfConfigSource {
    return {
      $type: SelfConfigSource.$type,
      transport_api_version: isSet(object.transport_api_version)
        ? apiVersionFromJSON(object.transport_api_version)
        : undefined,
    };
  },

  toJSON(message: SelfConfigSource): unknown {
    const obj: any = {};
    if (message.transport_api_version !== undefined) {
      obj.transport_api_version = apiVersionToJSON(message.transport_api_version);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SelfConfigSource>, I>>(base?: I): SelfConfigSource {
    return SelfConfigSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SelfConfigSource>, I>>(object: I): SelfConfigSource {
    const message = createBaseSelfConfigSource();
    message.transport_api_version = object.transport_api_version ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(SelfConfigSource.$type, SelfConfigSource);

function createBaseRateLimitSettings(): RateLimitSettings {
  return { $type: "envoy.api.v2.core.RateLimitSettings" };
}

export const RateLimitSettings: MessageFns<RateLimitSettings, "envoy.api.v2.core.RateLimitSettings"> = {
  $type: "envoy.api.v2.core.RateLimitSettings" as const,

  encode(message: RateLimitSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.max_tokens !== undefined) {
      UInt32Value.encode({ $type: "google.protobuf.UInt32Value", value: message.max_tokens! }, writer.uint32(10).fork())
        .join();
    }
    if (message.fill_rate !== undefined) {
      DoubleValue.encode({ $type: "google.protobuf.DoubleValue", value: message.fill_rate! }, writer.uint32(18).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimitSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimitSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.max_tokens = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fill_rate = DoubleValue.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimitSettings {
    return {
      $type: RateLimitSettings.$type,
      max_tokens: isSet(object.max_tokens) ? Number(object.max_tokens) : undefined,
      fill_rate: isSet(object.fill_rate) ? Number(object.fill_rate) : undefined,
    };
  },

  toJSON(message: RateLimitSettings): unknown {
    const obj: any = {};
    if (message.max_tokens !== undefined) {
      obj.max_tokens = message.max_tokens;
    }
    if (message.fill_rate !== undefined) {
      obj.fill_rate = message.fill_rate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimitSettings>, I>>(base?: I): RateLimitSettings {
    return RateLimitSettings.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimitSettings>, I>>(object: I): RateLimitSettings {
    const message = createBaseRateLimitSettings();
    message.max_tokens = object.max_tokens ?? undefined;
    message.fill_rate = object.fill_rate ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RateLimitSettings.$type, RateLimitSettings);

function createBaseConfigSource(): ConfigSource {
  return { $type: "envoy.api.v2.core.ConfigSource", config_source_specifier: undefined };
}

export const ConfigSource: MessageFns<ConfigSource, "envoy.api.v2.core.ConfigSource"> = {
  $type: "envoy.api.v2.core.ConfigSource" as const,

  encode(message: ConfigSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.config_source_specifier?.$case) {
      case "path":
        writer.uint32(10).string(message.config_source_specifier.path);
        break;
      case "api_config_source":
        ApiConfigSource.encode(message.config_source_specifier.api_config_source, writer.uint32(18).fork()).join();
        break;
      case "ads":
        AggregatedConfigSource.encode(message.config_source_specifier.ads, writer.uint32(26).fork()).join();
        break;
      case "self":
        SelfConfigSource.encode(message.config_source_specifier.self, writer.uint32(42).fork()).join();
        break;
    }
    if (message.initial_fetch_timeout !== undefined) {
      Duration.encode(message.initial_fetch_timeout, writer.uint32(34).fork()).join();
    }
    if (message.resource_api_version !== undefined && message.resource_api_version !== ApiVersion.AUTO) {
      writer.uint32(48).int32(apiVersionToNumber(message.resource_api_version));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConfigSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfigSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.config_source_specifier = { $case: "path", path: reader.string() };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.config_source_specifier = {
            $case: "api_config_source",
            api_config_source: ApiConfigSource.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.config_source_specifier = {
            $case: "ads",
            ads: AggregatedConfigSource.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.config_source_specifier = { $case: "self", self: SelfConfigSource.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.initial_fetch_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.resource_api_version = apiVersionFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfigSource {
    return {
      $type: ConfigSource.$type,
      config_source_specifier: isSet(object.path)
        ? { $case: "path", path: globalThis.String(object.path) }
        : isSet(object.api_config_source)
        ? { $case: "api_config_source", api_config_source: ApiConfigSource.fromJSON(object.api_config_source) }
        : isSet(object.ads)
        ? { $case: "ads", ads: AggregatedConfigSource.fromJSON(object.ads) }
        : isSet(object.self)
        ? { $case: "self", self: SelfConfigSource.fromJSON(object.self) }
        : undefined,
      initial_fetch_timeout: isSet(object.initial_fetch_timeout)
        ? Duration.fromJSON(object.initial_fetch_timeout)
        : undefined,
      resource_api_version: isSet(object.resource_api_version)
        ? apiVersionFromJSON(object.resource_api_version)
        : undefined,
    };
  },

  toJSON(message: ConfigSource): unknown {
    const obj: any = {};
    if (message.config_source_specifier?.$case === "path") {
      obj.path = message.config_source_specifier.path;
    }
    if (message.config_source_specifier?.$case === "api_config_source") {
      obj.api_config_source = ApiConfigSource.toJSON(message.config_source_specifier.api_config_source);
    }
    if (message.config_source_specifier?.$case === "ads") {
      obj.ads = AggregatedConfigSource.toJSON(message.config_source_specifier.ads);
    }
    if (message.config_source_specifier?.$case === "self") {
      obj.self = SelfConfigSource.toJSON(message.config_source_specifier.self);
    }
    if (message.initial_fetch_timeout !== undefined) {
      obj.initial_fetch_timeout = Duration.toJSON(message.initial_fetch_timeout);
    }
    if (message.resource_api_version !== undefined) {
      obj.resource_api_version = apiVersionToJSON(message.resource_api_version);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConfigSource>, I>>(base?: I): ConfigSource {
    return ConfigSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConfigSource>, I>>(object: I): ConfigSource {
    const message = createBaseConfigSource();
    if (
      object.config_source_specifier?.$case === "path" &&
      object.config_source_specifier?.path !== undefined &&
      object.config_source_specifier?.path !== null
    ) {
      message.config_source_specifier = { $case: "path", path: object.config_source_specifier.path };
    }
    if (
      object.config_source_specifier?.$case === "api_config_source" &&
      object.config_source_specifier?.api_config_source !== undefined &&
      object.config_source_specifier?.api_config_source !== null
    ) {
      message.config_source_specifier = {
        $case: "api_config_source",
        api_config_source: ApiConfigSource.fromPartial(object.config_source_specifier.api_config_source),
      };
    }
    if (
      object.config_source_specifier?.$case === "ads" &&
      object.config_source_specifier?.ads !== undefined &&
      object.config_source_specifier?.ads !== null
    ) {
      message.config_source_specifier = {
        $case: "ads",
        ads: AggregatedConfigSource.fromPartial(object.config_source_specifier.ads),
      };
    }
    if (
      object.config_source_specifier?.$case === "self" &&
      object.config_source_specifier?.self !== undefined &&
      object.config_source_specifier?.self !== null
    ) {
      message.config_source_specifier = {
        $case: "self",
        self: SelfConfigSource.fromPartial(object.config_source_specifier.self),
      };
    }
    message.initial_fetch_timeout =
      (object.initial_fetch_timeout !== undefined && object.initial_fetch_timeout !== null)
        ? Duration.fromPartial(object.initial_fetch_timeout)
        : undefined;
    message.resource_api_version = object.resource_api_version ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ConfigSource.$type, ConfigSource);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
