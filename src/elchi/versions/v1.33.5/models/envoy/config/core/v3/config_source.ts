// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/config/core/v3/config_source.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Any } from "../../../../google/protobuf/any";
import { Duration } from "../../../../google/protobuf/duration";
import { DoubleValue, UInt32Value } from "../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../typeRegistry";
import { Authority } from "../../../../xds/core/v3/authority";
import { WatchedDirectory } from "./base";
import { TypedExtensionConfig } from "./extension";
import { GrpcService } from "./grpc_service";

export const protobufPackage = "envoy.config.core.v3";

/**
 * xDS API and non-xDS services version. This is used to describe both resource and transport
 * protocol versions (in distinct configuration fields).
 */
export enum ApiVersion {
  /** AUTO - When not specified, we assume v3; it is the only supported version. */
  AUTO = "AUTO",
  /**
   * V2 - Use xDS v2 API. This is no longer supported.
   *
   * @deprecated
   */
  V2 = "V2",
  /** V3 - Use xDS v3 API. */
  V3 = "V3",
}

export function apiVersionFromJSON(object: any): ApiVersion {
  switch (object) {
    case 0:
    case "AUTO":
      return ApiVersion.AUTO;
    case 1:
    case "V2":
      return ApiVersion.V2;
    case 2:
    case "V3":
      return ApiVersion.V3;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ApiVersion");
  }
}

export function apiVersionToJSON(object: ApiVersion): string {
  switch (object) {
    case ApiVersion.AUTO:
      return "AUTO";
    case ApiVersion.V2:
      return "V2";
    case ApiVersion.V3:
      return "V3";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ApiVersion");
  }
}

export function apiVersionToNumber(object: ApiVersion): number {
  switch (object) {
    case ApiVersion.AUTO:
      return 0;
    case ApiVersion.V2:
      return 1;
    case ApiVersion.V3:
      return 2;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ApiVersion");
  }
}

/**
 * API configuration source. This identifies the API type and cluster that Envoy
 * will use to fetch an xDS API.
 * [#next-free-field: 10]
 */
export interface ApiConfigSource {
  $type: "envoy.config.core.v3.ApiConfigSource";
  /** API type (gRPC, REST, delta gRPC) */
  api_type?:
    | ApiConfigSource_ApiType
    | undefined;
  /**
   * API version for xDS transport protocol. This describes the xDS gRPC/REST
   * endpoint and version of [Delta]DiscoveryRequest/Response used on the wire.
   */
  transport_api_version?:
    | ApiVersion
    | undefined;
  /**
   * Cluster names should be used only with REST. If > 1
   * cluster is defined, clusters will be cycled through if any kind of failure
   * occurs.
   *
   * .. note::
   *
   *  The cluster with name ``cluster_name`` must be statically defined and its
   *  type must not be ``EDS``.
   */
  cluster_names?:
    | string[]
    | undefined;
  /**
   * Multiple gRPC services be provided for GRPC. If > 1 cluster is defined,
   * services will be cycled through if any kind of failure occurs.
   */
  grpc_services?:
    | GrpcService[]
    | undefined;
  /** For REST APIs, the delay between successive polls. */
  refresh_delay?:
    | Duration
    | undefined;
  /** For REST APIs, the request timeout. If not set, a default value of 1s will be used. */
  request_timeout?:
    | Duration
    | undefined;
  /**
   * For GRPC APIs, the rate limit settings. If present, discovery requests made by Envoy will be
   * rate limited.
   */
  rate_limit_settings?:
    | RateLimitSettings
    | undefined;
  /** Skip the node identifier in subsequent discovery requests for streaming gRPC config types. */
  set_node_on_first_message_only?:
    | boolean
    | undefined;
  /**
   * A list of config validators that will be executed when a new update is
   * received from the ApiConfigSource. Note that each validator handles a
   * specific xDS service type, and only the validators corresponding to the
   * type url (in ``:ref: DiscoveryResponse`` or ``:ref: DeltaDiscoveryResponse``)
   * will be invoked.
   * If the validator returns false or throws an exception, the config will be rejected by
   * the client, and a NACK will be sent.
   * [#extension-category: envoy.config.validators]
   */
  config_validators?: TypedExtensionConfig[] | undefined;
}

/** APIs may be fetched via either REST or gRPC. */
export enum ApiConfigSource_ApiType {
  /**
   * DEPRECATED_AND_UNAVAILABLE_DO_NOT_USE - Ideally this would be 'reserved 0' but one can't reserve the default
   * value. Instead we throw an exception if this is ever used.
   *
   * @deprecated
   */
  DEPRECATED_AND_UNAVAILABLE_DO_NOT_USE = "DEPRECATED_AND_UNAVAILABLE_DO_NOT_USE",
  /**
   * REST - REST-JSON v2 API. The `canonical JSON encoding
   * <https://developers.google.com/protocol-buffers/docs/proto3#json>`_ for
   * the v2 protos is used.
   */
  REST = "REST",
  /** GRPC - SotW gRPC service. */
  GRPC = "GRPC",
  /**
   * DELTA_GRPC - Using the delta xDS gRPC service, i.e. DeltaDiscovery{Request,Response}
   * rather than Discovery{Request,Response}. Rather than sending Envoy the entire state
   * with every update, the xDS server only sends what has changed since the last update.
   */
  DELTA_GRPC = "DELTA_GRPC",
  /**
   * AGGREGATED_GRPC - SotW xDS gRPC with ADS. All resources which resolve to this configuration source will be
   * multiplexed on a single connection to an ADS endpoint.
   * [#not-implemented-hide:]
   */
  AGGREGATED_GRPC = "AGGREGATED_GRPC",
  /**
   * AGGREGATED_DELTA_GRPC - Delta xDS gRPC with ADS. All resources which resolve to this configuration source will be
   * multiplexed on a single connection to an ADS endpoint.
   * [#not-implemented-hide:]
   */
  AGGREGATED_DELTA_GRPC = "AGGREGATED_DELTA_GRPC",
}

export function apiConfigSource_ApiTypeFromJSON(object: any): ApiConfigSource_ApiType {
  switch (object) {
    case 0:
    case "DEPRECATED_AND_UNAVAILABLE_DO_NOT_USE":
      return ApiConfigSource_ApiType.DEPRECATED_AND_UNAVAILABLE_DO_NOT_USE;
    case 1:
    case "REST":
      return ApiConfigSource_ApiType.REST;
    case 2:
    case "GRPC":
      return ApiConfigSource_ApiType.GRPC;
    case 3:
    case "DELTA_GRPC":
      return ApiConfigSource_ApiType.DELTA_GRPC;
    case 5:
    case "AGGREGATED_GRPC":
      return ApiConfigSource_ApiType.AGGREGATED_GRPC;
    case 6:
    case "AGGREGATED_DELTA_GRPC":
      return ApiConfigSource_ApiType.AGGREGATED_DELTA_GRPC;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ApiConfigSource_ApiType");
  }
}

export function apiConfigSource_ApiTypeToJSON(object: ApiConfigSource_ApiType): string {
  switch (object) {
    case ApiConfigSource_ApiType.DEPRECATED_AND_UNAVAILABLE_DO_NOT_USE:
      return "DEPRECATED_AND_UNAVAILABLE_DO_NOT_USE";
    case ApiConfigSource_ApiType.REST:
      return "REST";
    case ApiConfigSource_ApiType.GRPC:
      return "GRPC";
    case ApiConfigSource_ApiType.DELTA_GRPC:
      return "DELTA_GRPC";
    case ApiConfigSource_ApiType.AGGREGATED_GRPC:
      return "AGGREGATED_GRPC";
    case ApiConfigSource_ApiType.AGGREGATED_DELTA_GRPC:
      return "AGGREGATED_DELTA_GRPC";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ApiConfigSource_ApiType");
  }
}

export function apiConfigSource_ApiTypeToNumber(object: ApiConfigSource_ApiType): number {
  switch (object) {
    case ApiConfigSource_ApiType.DEPRECATED_AND_UNAVAILABLE_DO_NOT_USE:
      return 0;
    case ApiConfigSource_ApiType.REST:
      return 1;
    case ApiConfigSource_ApiType.GRPC:
      return 2;
    case ApiConfigSource_ApiType.DELTA_GRPC:
      return 3;
    case ApiConfigSource_ApiType.AGGREGATED_GRPC:
      return 5;
    case ApiConfigSource_ApiType.AGGREGATED_DELTA_GRPC:
      return 6;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ApiConfigSource_ApiType");
  }
}

/**
 * Aggregated Discovery Service (ADS) options. This is currently empty, but when
 * set in :ref:`ConfigSource <envoy_v3_api_msg_config.core.v3.ConfigSource>` can be used to
 * specify that ADS is to be used.
 */
export interface AggregatedConfigSource {
  $type: "envoy.config.core.v3.AggregatedConfigSource";
}

/**
 * [#not-implemented-hide:]
 * Self-referencing config source options. This is currently empty, but when
 * set in :ref:`ConfigSource <envoy_v3_api_msg_config.core.v3.ConfigSource>` can be used to
 * specify that other data can be obtained from the same server.
 */
export interface SelfConfigSource {
  $type: "envoy.config.core.v3.SelfConfigSource";
  /**
   * API version for xDS transport protocol. This describes the xDS gRPC/REST
   * endpoint and version of [Delta]DiscoveryRequest/Response used on the wire.
   */
  transport_api_version?: ApiVersion | undefined;
}

/** Rate Limit settings to be applied for discovery requests made by Envoy. */
export interface RateLimitSettings {
  $type: "envoy.config.core.v3.RateLimitSettings";
  /**
   * Maximum number of tokens to be used for rate limiting discovery request calls. If not set, a
   * default value of 100 will be used.
   */
  max_tokens?:
    | number
    | undefined;
  /**
   * Rate at which tokens will be filled per second. If not set, a default fill rate of 10 tokens
   * per second will be used. The minimal fill rate is once per year. Lower
   * fill rates will be set to once per year.
   */
  fill_rate?: number | undefined;
}

/** Local filesystem path configuration source. */
export interface PathConfigSource {
  $type: "envoy.config.core.v3.PathConfigSource";
  /**
   * Path on the filesystem to source and watch for configuration updates.
   * When sourcing configuration for a :ref:`secret <envoy_v3_api_msg_extensions.transport_sockets.tls.v3.Secret>`,
   * the certificate and key files are also watched for updates.
   *
   * .. note::
   *
   *  The path to the source must exist at config load time.
   *
   * .. note::
   *
   *   If ``watched_directory`` is *not* configured, Envoy will watch the file path for *moves*.
   *   This is because in general only moves are atomic. The same method of swapping files as is
   *   demonstrated in the :ref:`runtime documentation <config_runtime_symbolic_link_swap>` can be
   *   used here also. If ``watched_directory`` is configured, no watch will be placed directly on
   *   this path. Instead, the configured ``watched_directory`` will be used to trigger reloads of
   *   this path. This is required in certain deployment scenarios. See below for more information.
   */
  path?:
    | string
    | undefined;
  /**
   * If configured, this directory will be watched for *moves*. When an entry in this directory is
   * moved to, the ``path`` will be reloaded. This is required in certain deployment scenarios.
   *
   * Specifically, if trying to load an xDS resource using a
   * `Kubernetes ConfigMap <https://kubernetes.io/docs/concepts/configuration/configmap/>`_, the
   * following configuration might be used:
   * 1. Store xds.yaml inside a ConfigMap.
   * 2. Mount the ConfigMap to ``/config_map/xds``
   * 3. Configure path ``/config_map/xds/xds.yaml``
   * 4. Configure watched directory ``/config_map/xds``
   *
   * The above configuration will ensure that Envoy watches the owning directory for moves which is
   * required due to how Kubernetes manages ConfigMap symbolic links during atomic updates.
   */
  watched_directory?: WatchedDirectory | undefined;
}

/**
 * Configuration for :ref:`listeners <config_listeners>`, :ref:`clusters
 * <config_cluster_manager>`, :ref:`routes
 * <envoy_v3_api_msg_config.route.v3.RouteConfiguration>`, :ref:`endpoints
 * <arch_overview_service_discovery>` etc. may either be sourced from the
 * filesystem or from an xDS API source. Filesystem configs are watched with
 * inotify for updates.
 * [#next-free-field: 9]
 */
export interface ConfigSource {
  $type: "envoy.config.core.v3.ConfigSource";
  /**
   * Authorities that this config source may be used for. An authority specified in a xdstp:// URL
   * is resolved to a ``ConfigSource`` prior to configuration fetch. This field provides the
   * association between authority name and configuration source.
   * [#not-implemented-hide:]
   */
  authorities?: Authority[] | undefined;
  config_source_specifier?:
    | //
    /** Deprecated in favor of ``path_config_source``. Use that field instead. */
    { $case: "path"; path: string }
    | //
    /** Local filesystem path configuration source. */
    { $case: "path_config_source"; path_config_source: PathConfigSource }
    | //
    /** API configuration source. */
    { $case: "api_config_source"; api_config_source: ApiConfigSource }
    | //
    /**
     * When set, ADS will be used to fetch resources. The ADS API configuration
     * source in the bootstrap configuration is used.
     */
    { $case: "ads"; ads: AggregatedConfigSource }
    | //
    /**
     * [#not-implemented-hide:]
     * When set, the client will access the resources from the same server it got the
     * ConfigSource from, although not necessarily from the same stream. This is similar to the
     * :ref:`ads<envoy_v3_api_field.ConfigSource.ads>` field, except that the client may use a
     * different stream to the same server. As a result, this field can be used for things
     * like LRS that cannot be sent on an ADS stream. It can also be used to link from (e.g.)
     * LDS to RDS on the same server without requiring the management server to know its name
     * or required credentials.
     * [#next-major-version: In xDS v3, consider replacing the ads field with this one, since
     * this field can implicitly mean to use the same stream in the case where the ConfigSource
     * is provided via ADS and the specified data can also be obtained via ADS.]
     */
    { $case: "self"; self: SelfConfigSource }
    | undefined;
  /**
   * When this timeout is specified, Envoy will wait no longer than the specified time for first
   * config response on this xDS subscription during the :ref:`initialization process
   * <arch_overview_initialization>`. After reaching the timeout, Envoy will move to the next
   * initialization phase, even if the first config is not delivered yet. The timer is activated
   * when the xDS API subscription starts, and is disarmed on first config update or on error. 0
   * means no timeout - Envoy will wait indefinitely for the first xDS config (unless another
   * timeout applies). The default is 15s.
   */
  initial_fetch_timeout?:
    | Duration
    | undefined;
  /**
   * API version for xDS resources. This implies the type URLs that the client
   * will request for resources and the resource type that the client will in
   * turn expect to be delivered.
   */
  resource_api_version?: ApiVersion | undefined;
}

/**
 * Configuration source specifier for a late-bound extension configuration. The
 * parent resource is warmed until all the initial extension configurations are
 * received, unless the flag to apply the default configuration is set.
 * Subsequent extension updates are atomic on a per-worker basis. Once an
 * extension configuration is applied to a request or a connection, it remains
 * constant for the duration of processing. If the initial delivery of the
 * extension configuration fails, due to a timeout for example, the optional
 * default configuration is applied. Without a default configuration, the
 * extension is disabled, until an extension configuration is received. The
 * behavior of a disabled extension depends on the context. For example, a
 * filter chain with a disabled extension filter rejects all incoming streams.
 */
export interface ExtensionConfigSource {
  $type: "envoy.config.core.v3.ExtensionConfigSource";
  config_source?:
    | ConfigSource
    | undefined;
  /**
   * Optional default configuration to use as the initial configuration if
   * there is a failure to receive the initial extension configuration or if
   * ``apply_default_config_without_warming`` flag is set.
   */
  default_config?:
    | Any
    | undefined;
  /**
   * Use the default config as the initial configuration without warming and
   * waiting for the first discovery response. Requires the default configuration
   * to be supplied.
   */
  apply_default_config_without_warming?:
    | boolean
    | undefined;
  /**
   * A set of permitted extension type URLs. Extension configuration updates are rejected
   * if they do not match any type URL in the set.
   */
  type_urls?: string[] | undefined;
}

function createBaseApiConfigSource(): ApiConfigSource {
  return { $type: "envoy.config.core.v3.ApiConfigSource" };
}

export const ApiConfigSource: MessageFns<ApiConfigSource, "envoy.config.core.v3.ApiConfigSource"> = {
  $type: "envoy.config.core.v3.ApiConfigSource" as const,

  encode(message: ApiConfigSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (
      message.api_type !== undefined &&
      message.api_type !== ApiConfigSource_ApiType.DEPRECATED_AND_UNAVAILABLE_DO_NOT_USE
    ) {
      writer.uint32(8).int32(apiConfigSource_ApiTypeToNumber(message.api_type));
    }
    if (message.transport_api_version !== undefined && message.transport_api_version !== ApiVersion.AUTO) {
      writer.uint32(64).int32(apiVersionToNumber(message.transport_api_version));
    }
    if (message.cluster_names !== undefined && message.cluster_names.length !== 0) {
      for (const v of message.cluster_names) {
        writer.uint32(18).string(v!);
      }
    }
    if (message.grpc_services !== undefined && message.grpc_services.length !== 0) {
      for (const v of message.grpc_services) {
        GrpcService.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    if (message.refresh_delay !== undefined) {
      Duration.encode(message.refresh_delay, writer.uint32(26).fork()).join();
    }
    if (message.request_timeout !== undefined) {
      Duration.encode(message.request_timeout, writer.uint32(42).fork()).join();
    }
    if (message.rate_limit_settings !== undefined) {
      RateLimitSettings.encode(message.rate_limit_settings, writer.uint32(50).fork()).join();
    }
    if (message.set_node_on_first_message_only !== undefined && message.set_node_on_first_message_only !== false) {
      writer.uint32(56).bool(message.set_node_on_first_message_only);
    }
    if (message.config_validators !== undefined && message.config_validators.length !== 0) {
      for (const v of message.config_validators) {
        TypedExtensionConfig.encode(v!, writer.uint32(74).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApiConfigSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApiConfigSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.api_type = apiConfigSource_ApiTypeFromJSON(reader.int32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.transport_api_version = apiVersionFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.cluster_names === undefined) {
            message.cluster_names = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.cluster_names!.push(el);
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          if (message.grpc_services === undefined) {
            message.grpc_services = [];
          }
          const el = GrpcService.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.grpc_services!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.refresh_delay = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.request_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.rate_limit_settings = RateLimitSettings.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.set_node_on_first_message_only = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          if (message.config_validators === undefined) {
            message.config_validators = [];
          }
          const el = TypedExtensionConfig.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.config_validators!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApiConfigSource {
    return {
      $type: ApiConfigSource.$type,
      api_type: isSet(object.api_type) ? apiConfigSource_ApiTypeFromJSON(object.api_type) : undefined,
      transport_api_version: isSet(object.transport_api_version)
        ? apiVersionFromJSON(object.transport_api_version)
        : undefined,
      cluster_names: globalThis.Array.isArray(object?.cluster_names)
        ? object.cluster_names.map((e: any) => globalThis.String(e))
        : undefined,
      grpc_services: globalThis.Array.isArray(object?.grpc_services)
        ? object.grpc_services.map((e: any) => GrpcService.fromJSON(e))
        : undefined,
      refresh_delay: isSet(object.refresh_delay) ? Duration.fromJSON(object.refresh_delay) : undefined,
      request_timeout: isSet(object.request_timeout) ? Duration.fromJSON(object.request_timeout) : undefined,
      rate_limit_settings: isSet(object.rate_limit_settings)
        ? RateLimitSettings.fromJSON(object.rate_limit_settings)
        : undefined,
      set_node_on_first_message_only: isSet(object.set_node_on_first_message_only)
        ? globalThis.Boolean(object.set_node_on_first_message_only)
        : undefined,
      config_validators: globalThis.Array.isArray(object?.config_validators)
        ? object.config_validators.map((e: any) => TypedExtensionConfig.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: ApiConfigSource): unknown {
    const obj: any = {};
    if (message.api_type !== undefined) {
      obj.api_type = apiConfigSource_ApiTypeToJSON(message.api_type);
    }
    if (message.transport_api_version !== undefined) {
      obj.transport_api_version = apiVersionToJSON(message.transport_api_version);
    }
    if (message.cluster_names?.length) {
      obj.cluster_names = message.cluster_names;
    }
    if (message.grpc_services?.length) {
      obj.grpc_services = message.grpc_services.map((e) => GrpcService.toJSON(e));
    }
    if (message.refresh_delay !== undefined) {
      obj.refresh_delay = Duration.toJSON(message.refresh_delay);
    }
    if (message.request_timeout !== undefined) {
      obj.request_timeout = Duration.toJSON(message.request_timeout);
    }
    if (message.rate_limit_settings !== undefined) {
      obj.rate_limit_settings = RateLimitSettings.toJSON(message.rate_limit_settings);
    }
    if (message.set_node_on_first_message_only !== undefined) {
      obj.set_node_on_first_message_only = message.set_node_on_first_message_only;
    }
    if (message.config_validators?.length) {
      obj.config_validators = message.config_validators.map((e) => TypedExtensionConfig.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApiConfigSource>, I>>(base?: I): ApiConfigSource {
    return ApiConfigSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApiConfigSource>, I>>(object: I): ApiConfigSource {
    const message = createBaseApiConfigSource();
    message.api_type = object.api_type ?? undefined;
    message.transport_api_version = object.transport_api_version ?? undefined;
    message.cluster_names = object.cluster_names?.map((e) => e) || undefined;
    message.grpc_services = object.grpc_services?.map((e) => GrpcService.fromPartial(e)) || undefined;
    message.refresh_delay = (object.refresh_delay !== undefined && object.refresh_delay !== null)
      ? Duration.fromPartial(object.refresh_delay)
      : undefined;
    message.request_timeout = (object.request_timeout !== undefined && object.request_timeout !== null)
      ? Duration.fromPartial(object.request_timeout)
      : undefined;
    message.rate_limit_settings = (object.rate_limit_settings !== undefined && object.rate_limit_settings !== null)
      ? RateLimitSettings.fromPartial(object.rate_limit_settings)
      : undefined;
    message.set_node_on_first_message_only = object.set_node_on_first_message_only ?? undefined;
    message.config_validators = object.config_validators?.map((e) => TypedExtensionConfig.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(ApiConfigSource.$type, ApiConfigSource);

function createBaseAggregatedConfigSource(): AggregatedConfigSource {
  return { $type: "envoy.config.core.v3.AggregatedConfigSource" };
}

export const AggregatedConfigSource: MessageFns<AggregatedConfigSource, "envoy.config.core.v3.AggregatedConfigSource"> =
  {
    $type: "envoy.config.core.v3.AggregatedConfigSource" as const,

    encode(_: AggregatedConfigSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): AggregatedConfigSource {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseAggregatedConfigSource();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(_: any): AggregatedConfigSource {
      return { $type: AggregatedConfigSource.$type };
    },

    toJSON(_: AggregatedConfigSource): unknown {
      const obj: any = {};
      return obj;
    },

    create<I extends Exact<DeepPartial<AggregatedConfigSource>, I>>(base?: I): AggregatedConfigSource {
      return AggregatedConfigSource.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<AggregatedConfigSource>, I>>(_: I): AggregatedConfigSource {
      const message = createBaseAggregatedConfigSource();
      return message;
    },
  };

messageTypeRegistry.set(AggregatedConfigSource.$type, AggregatedConfigSource);

function createBaseSelfConfigSource(): SelfConfigSource {
  return { $type: "envoy.config.core.v3.SelfConfigSource" };
}

export const SelfConfigSource: MessageFns<SelfConfigSource, "envoy.config.core.v3.SelfConfigSource"> = {
  $type: "envoy.config.core.v3.SelfConfigSource" as const,

  encode(message: SelfConfigSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transport_api_version !== undefined && message.transport_api_version !== ApiVersion.AUTO) {
      writer.uint32(8).int32(apiVersionToNumber(message.transport_api_version));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SelfConfigSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSelfConfigSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.transport_api_version = apiVersionFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SelfConfigSource {
    return {
      $type: SelfConfigSource.$type,
      transport_api_version: isSet(object.transport_api_version)
        ? apiVersionFromJSON(object.transport_api_version)
        : undefined,
    };
  },

  toJSON(message: SelfConfigSource): unknown {
    const obj: any = {};
    if (message.transport_api_version !== undefined) {
      obj.transport_api_version = apiVersionToJSON(message.transport_api_version);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SelfConfigSource>, I>>(base?: I): SelfConfigSource {
    return SelfConfigSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SelfConfigSource>, I>>(object: I): SelfConfigSource {
    const message = createBaseSelfConfigSource();
    message.transport_api_version = object.transport_api_version ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(SelfConfigSource.$type, SelfConfigSource);

function createBaseRateLimitSettings(): RateLimitSettings {
  return { $type: "envoy.config.core.v3.RateLimitSettings" };
}

export const RateLimitSettings: MessageFns<RateLimitSettings, "envoy.config.core.v3.RateLimitSettings"> = {
  $type: "envoy.config.core.v3.RateLimitSettings" as const,

  encode(message: RateLimitSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.max_tokens !== undefined) {
      UInt32Value.encode({ $type: "google.protobuf.UInt32Value", value: message.max_tokens! }, writer.uint32(10).fork())
        .join();
    }
    if (message.fill_rate !== undefined) {
      DoubleValue.encode({ $type: "google.protobuf.DoubleValue", value: message.fill_rate! }, writer.uint32(18).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimitSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimitSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.max_tokens = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fill_rate = DoubleValue.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimitSettings {
    return {
      $type: RateLimitSettings.$type,
      max_tokens: isSet(object.max_tokens) ? Number(object.max_tokens) : undefined,
      fill_rate: isSet(object.fill_rate) ? Number(object.fill_rate) : undefined,
    };
  },

  toJSON(message: RateLimitSettings): unknown {
    const obj: any = {};
    if (message.max_tokens !== undefined) {
      obj.max_tokens = message.max_tokens;
    }
    if (message.fill_rate !== undefined) {
      obj.fill_rate = message.fill_rate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimitSettings>, I>>(base?: I): RateLimitSettings {
    return RateLimitSettings.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimitSettings>, I>>(object: I): RateLimitSettings {
    const message = createBaseRateLimitSettings();
    message.max_tokens = object.max_tokens ?? undefined;
    message.fill_rate = object.fill_rate ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RateLimitSettings.$type, RateLimitSettings);

function createBasePathConfigSource(): PathConfigSource {
  return { $type: "envoy.config.core.v3.PathConfigSource" };
}

export const PathConfigSource: MessageFns<PathConfigSource, "envoy.config.core.v3.PathConfigSource"> = {
  $type: "envoy.config.core.v3.PathConfigSource" as const,

  encode(message: PathConfigSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== undefined && message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.watched_directory !== undefined) {
      WatchedDirectory.encode(message.watched_directory, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PathConfigSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePathConfigSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.watched_directory = WatchedDirectory.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PathConfigSource {
    return {
      $type: PathConfigSource.$type,
      path: isSet(object.path) ? globalThis.String(object.path) : undefined,
      watched_directory: isSet(object.watched_directory)
        ? WatchedDirectory.fromJSON(object.watched_directory)
        : undefined,
    };
  },

  toJSON(message: PathConfigSource): unknown {
    const obj: any = {};
    if (message.path !== undefined) {
      obj.path = message.path;
    }
    if (message.watched_directory !== undefined) {
      obj.watched_directory = WatchedDirectory.toJSON(message.watched_directory);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PathConfigSource>, I>>(base?: I): PathConfigSource {
    return PathConfigSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PathConfigSource>, I>>(object: I): PathConfigSource {
    const message = createBasePathConfigSource();
    message.path = object.path ?? undefined;
    message.watched_directory = (object.watched_directory !== undefined && object.watched_directory !== null)
      ? WatchedDirectory.fromPartial(object.watched_directory)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(PathConfigSource.$type, PathConfigSource);

function createBaseConfigSource(): ConfigSource {
  return { $type: "envoy.config.core.v3.ConfigSource", config_source_specifier: undefined };
}

export const ConfigSource: MessageFns<ConfigSource, "envoy.config.core.v3.ConfigSource"> = {
  $type: "envoy.config.core.v3.ConfigSource" as const,

  encode(message: ConfigSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authorities !== undefined && message.authorities.length !== 0) {
      for (const v of message.authorities) {
        Authority.encode(v!, writer.uint32(58).fork()).join();
      }
    }
    switch (message.config_source_specifier?.$case) {
      case "path":
        writer.uint32(10).string(message.config_source_specifier.path);
        break;
      case "path_config_source":
        PathConfigSource.encode(message.config_source_specifier.path_config_source, writer.uint32(66).fork()).join();
        break;
      case "api_config_source":
        ApiConfigSource.encode(message.config_source_specifier.api_config_source, writer.uint32(18).fork()).join();
        break;
      case "ads":
        AggregatedConfigSource.encode(message.config_source_specifier.ads, writer.uint32(26).fork()).join();
        break;
      case "self":
        SelfConfigSource.encode(message.config_source_specifier.self, writer.uint32(42).fork()).join();
        break;
    }
    if (message.initial_fetch_timeout !== undefined) {
      Duration.encode(message.initial_fetch_timeout, writer.uint32(34).fork()).join();
    }
    if (message.resource_api_version !== undefined && message.resource_api_version !== ApiVersion.AUTO) {
      writer.uint32(48).int32(apiVersionToNumber(message.resource_api_version));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConfigSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfigSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 7: {
          if (tag !== 58) {
            break;
          }

          if (message.authorities === undefined) {
            message.authorities = [];
          }
          const el = Authority.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.authorities!.push(el);
          }
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.config_source_specifier = { $case: "path", path: reader.string() };
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.config_source_specifier = {
            $case: "path_config_source",
            path_config_source: PathConfigSource.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.config_source_specifier = {
            $case: "api_config_source",
            api_config_source: ApiConfigSource.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.config_source_specifier = {
            $case: "ads",
            ads: AggregatedConfigSource.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.config_source_specifier = { $case: "self", self: SelfConfigSource.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.initial_fetch_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.resource_api_version = apiVersionFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfigSource {
    return {
      $type: ConfigSource.$type,
      authorities: globalThis.Array.isArray(object?.authorities)
        ? object.authorities.map((e: any) => Authority.fromJSON(e))
        : undefined,
      config_source_specifier: isSet(object.path)
        ? { $case: "path", path: globalThis.String(object.path) }
        : isSet(object.path_config_source)
        ? { $case: "path_config_source", path_config_source: PathConfigSource.fromJSON(object.path_config_source) }
        : isSet(object.api_config_source)
        ? { $case: "api_config_source", api_config_source: ApiConfigSource.fromJSON(object.api_config_source) }
        : isSet(object.ads)
        ? { $case: "ads", ads: AggregatedConfigSource.fromJSON(object.ads) }
        : isSet(object.self)
        ? { $case: "self", self: SelfConfigSource.fromJSON(object.self) }
        : undefined,
      initial_fetch_timeout: isSet(object.initial_fetch_timeout)
        ? Duration.fromJSON(object.initial_fetch_timeout)
        : undefined,
      resource_api_version: isSet(object.resource_api_version)
        ? apiVersionFromJSON(object.resource_api_version)
        : undefined,
    };
  },

  toJSON(message: ConfigSource): unknown {
    const obj: any = {};
    if (message.authorities?.length) {
      obj.authorities = message.authorities.map((e) => Authority.toJSON(e));
    }
    if (message.config_source_specifier?.$case === "path") {
      obj.path = message.config_source_specifier.path;
    }
    if (message.config_source_specifier?.$case === "path_config_source") {
      obj.path_config_source = PathConfigSource.toJSON(message.config_source_specifier.path_config_source);
    }
    if (message.config_source_specifier?.$case === "api_config_source") {
      obj.api_config_source = ApiConfigSource.toJSON(message.config_source_specifier.api_config_source);
    }
    if (message.config_source_specifier?.$case === "ads") {
      obj.ads = AggregatedConfigSource.toJSON(message.config_source_specifier.ads);
    }
    if (message.config_source_specifier?.$case === "self") {
      obj.self = SelfConfigSource.toJSON(message.config_source_specifier.self);
    }
    if (message.initial_fetch_timeout !== undefined) {
      obj.initial_fetch_timeout = Duration.toJSON(message.initial_fetch_timeout);
    }
    if (message.resource_api_version !== undefined) {
      obj.resource_api_version = apiVersionToJSON(message.resource_api_version);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConfigSource>, I>>(base?: I): ConfigSource {
    return ConfigSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConfigSource>, I>>(object: I): ConfigSource {
    const message = createBaseConfigSource();
    message.authorities = object.authorities?.map((e) => Authority.fromPartial(e)) || undefined;
    if (
      object.config_source_specifier?.$case === "path" &&
      object.config_source_specifier?.path !== undefined &&
      object.config_source_specifier?.path !== null
    ) {
      message.config_source_specifier = { $case: "path", path: object.config_source_specifier.path };
    }
    if (
      object.config_source_specifier?.$case === "path_config_source" &&
      object.config_source_specifier?.path_config_source !== undefined &&
      object.config_source_specifier?.path_config_source !== null
    ) {
      message.config_source_specifier = {
        $case: "path_config_source",
        path_config_source: PathConfigSource.fromPartial(object.config_source_specifier.path_config_source),
      };
    }
    if (
      object.config_source_specifier?.$case === "api_config_source" &&
      object.config_source_specifier?.api_config_source !== undefined &&
      object.config_source_specifier?.api_config_source !== null
    ) {
      message.config_source_specifier = {
        $case: "api_config_source",
        api_config_source: ApiConfigSource.fromPartial(object.config_source_specifier.api_config_source),
      };
    }
    if (
      object.config_source_specifier?.$case === "ads" &&
      object.config_source_specifier?.ads !== undefined &&
      object.config_source_specifier?.ads !== null
    ) {
      message.config_source_specifier = {
        $case: "ads",
        ads: AggregatedConfigSource.fromPartial(object.config_source_specifier.ads),
      };
    }
    if (
      object.config_source_specifier?.$case === "self" &&
      object.config_source_specifier?.self !== undefined &&
      object.config_source_specifier?.self !== null
    ) {
      message.config_source_specifier = {
        $case: "self",
        self: SelfConfigSource.fromPartial(object.config_source_specifier.self),
      };
    }
    message.initial_fetch_timeout =
      (object.initial_fetch_timeout !== undefined && object.initial_fetch_timeout !== null)
        ? Duration.fromPartial(object.initial_fetch_timeout)
        : undefined;
    message.resource_api_version = object.resource_api_version ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ConfigSource.$type, ConfigSource);

function createBaseExtensionConfigSource(): ExtensionConfigSource {
  return { $type: "envoy.config.core.v3.ExtensionConfigSource" };
}

export const ExtensionConfigSource: MessageFns<ExtensionConfigSource, "envoy.config.core.v3.ExtensionConfigSource"> = {
  $type: "envoy.config.core.v3.ExtensionConfigSource" as const,

  encode(message: ExtensionConfigSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.config_source !== undefined) {
      ConfigSource.encode(message.config_source, writer.uint32(10).fork()).join();
    }
    if (message.default_config !== undefined) {
      Any.encode(message.default_config, writer.uint32(18).fork()).join();
    }
    if (
      message.apply_default_config_without_warming !== undefined &&
      message.apply_default_config_without_warming !== false
    ) {
      writer.uint32(24).bool(message.apply_default_config_without_warming);
    }
    if (message.type_urls !== undefined && message.type_urls.length !== 0) {
      for (const v of message.type_urls) {
        writer.uint32(34).string(v!);
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExtensionConfigSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExtensionConfigSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.config_source = ConfigSource.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.default_config = Any.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.apply_default_config_without_warming = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          if (message.type_urls === undefined) {
            message.type_urls = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.type_urls!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExtensionConfigSource {
    return {
      $type: ExtensionConfigSource.$type,
      config_source: isSet(object.config_source) ? ConfigSource.fromJSON(object.config_source) : undefined,
      default_config: isSet(object.default_config) ? Any.fromJSON(object.default_config) : undefined,
      apply_default_config_without_warming: isSet(object.apply_default_config_without_warming)
        ? globalThis.Boolean(object.apply_default_config_without_warming)
        : undefined,
      type_urls: globalThis.Array.isArray(object?.type_urls)
        ? object.type_urls.map((e: any) => globalThis.String(e))
        : undefined,
    };
  },

  toJSON(message: ExtensionConfigSource): unknown {
    const obj: any = {};
    if (message.config_source !== undefined) {
      obj.config_source = ConfigSource.toJSON(message.config_source);
    }
    if (message.default_config !== undefined) {
      obj.default_config = Any.toJSON(message.default_config);
    }
    if (message.apply_default_config_without_warming !== undefined) {
      obj.apply_default_config_without_warming = message.apply_default_config_without_warming;
    }
    if (message.type_urls?.length) {
      obj.type_urls = message.type_urls;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExtensionConfigSource>, I>>(base?: I): ExtensionConfigSource {
    return ExtensionConfigSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExtensionConfigSource>, I>>(object: I): ExtensionConfigSource {
    const message = createBaseExtensionConfigSource();
    message.config_source = (object.config_source !== undefined && object.config_source !== null)
      ? ConfigSource.fromPartial(object.config_source)
      : undefined;
    message.default_config = (object.default_config !== undefined && object.default_config !== null)
      ? Any.fromPartial(object.default_config)
      : undefined;
    message.apply_default_config_without_warming = object.apply_default_config_without_warming ?? undefined;
    message.type_urls = object.type_urls?.map((e) => e) || undefined;
    return message;
  },
};

messageTypeRegistry.set(ExtensionConfigSource.$type, ExtensionConfigSource);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
