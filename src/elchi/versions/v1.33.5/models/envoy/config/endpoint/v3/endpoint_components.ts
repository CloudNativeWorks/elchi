// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/config/endpoint/v3/endpoint_components.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { UInt32Value } from "../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../typeRegistry";
import { Address } from "../../core/v3/address";
import { Locality, Metadata } from "../../core/v3/base";
import { ConfigSource } from "../../core/v3/config_source";
import {
  HealthStatus,
  healthStatusFromJSON,
  healthStatusToJSON,
  healthStatusToNumber,
} from "../../core/v3/health_check";

export const protobufPackage = "envoy.config.endpoint.v3";

/** Upstream host identifier. */
export interface Endpoint {
  $type: "envoy.config.endpoint.v3.Endpoint";
  /**
   * The upstream host address.
   *
   * .. attention::
   *
   *   The form of host address depends on the given cluster type. For STATIC or EDS,
   *   it is expected to be a direct IP address (or something resolvable by the
   *   specified :ref:`resolver <envoy_v3_api_field_config.core.v3.SocketAddress.resolver_name>`
   *   in the Address). For LOGICAL or STRICT DNS, it is expected to be hostname,
   *   and will be resolved via DNS.
   */
  address?:
    | Address
    | undefined;
  /**
   * The optional health check configuration is used as configuration for the
   * health checker to contact the health checked host.
   *
   * .. attention::
   *
   *   This takes into effect only for upstream clusters with
   *   :ref:`active health checking <arch_overview_health_checking>` enabled.
   */
  health_check_config?:
    | Endpoint_HealthCheckConfig
    | undefined;
  /**
   * The hostname associated with this endpoint. This hostname is not used for routing or address
   * resolution. If provided, it will be associated with the endpoint, and can be used for features
   * that require a hostname, like
   * :ref:`auto_host_rewrite <envoy_v3_api_field_config.route.v3.RouteAction.auto_host_rewrite>`.
   */
  hostname?:
    | string
    | undefined;
  /**
   * An ordered list of addresses that together with ``address`` comprise the
   * list of addresses for an endpoint. The address given in the ``address`` is
   * prepended to this list. It is assumed that the list must already be
   * sorted by preference order of the addresses. This will only be supported
   * for STATIC and EDS clusters.
   */
  additional_addresses?: Endpoint_AdditionalAddress[] | undefined;
}

/** The optional health check configuration. */
export interface Endpoint_HealthCheckConfig {
  $type: "envoy.config.endpoint.v3.Endpoint.HealthCheckConfig";
  /**
   * Optional alternative health check port value.
   *
   * By default the health check address port of an upstream host is the same
   * as the host's serving address port. This provides an alternative health
   * check port. Setting this with a non-zero value allows an upstream host
   * to have different health check address port.
   */
  port_value?:
    | number
    | undefined;
  /**
   * By default, the host header for L7 health checks is controlled by cluster level configuration
   * (see: :ref:`host <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.host>` and
   * :ref:`authority <envoy_v3_api_field_config.core.v3.HealthCheck.GrpcHealthCheck.authority>`). Setting this
   * to a non-empty value allows overriding the cluster level configuration for a specific
   * endpoint.
   */
  hostname?:
    | string
    | undefined;
  /**
   * Optional alternative health check host address.
   *
   * .. attention::
   *
   *   The form of the health check host address is expected to be a direct IP address.
   */
  address?:
    | Address
    | undefined;
  /**
   * Optional flag to control if perform active health check for this endpoint.
   * Active health check is enabled by default if there is a health checker.
   */
  disable_active_health_check?: boolean | undefined;
}

export interface Endpoint_AdditionalAddress {
  $type: "envoy.config.endpoint.v3.Endpoint.AdditionalAddress";
  /** Additional address that is associated with the endpoint. */
  address?: Address | undefined;
}

/**
 * An Endpoint that Envoy can route traffic to.
 * [#next-free-field: 6]
 */
export interface LbEndpoint {
  $type: "envoy.config.endpoint.v3.LbEndpoint";
  /** Upstream host identifier or a named reference. */
  host_identifier?:
    | //
    { $case: "endpoint"; endpoint: Endpoint }
    | //
    /** [#not-implemented-hide:] */
    { $case: "endpoint_name"; endpoint_name: string }
    | undefined;
  /** Optional health status when known and supplied by EDS server. */
  health_status?:
    | HealthStatus
    | undefined;
  /**
   * The endpoint metadata specifies values that may be used by the load
   * balancer to select endpoints in a cluster for a given request. The filter
   * name should be specified as ``envoy.lb``. An example boolean key-value pair
   * is ``canary``, providing the optional canary status of the upstream host.
   * This may be matched against in a route's
   * :ref:`RouteAction <envoy_v3_api_msg_config.route.v3.RouteAction>` metadata_match field
   * to subset the endpoints considered in cluster load balancing.
   */
  metadata?:
    | Metadata
    | undefined;
  /**
   * The optional load balancing weight of the upstream host; at least 1.
   * Envoy uses the load balancing weight in some of the built in load
   * balancers. The load balancing weight for an endpoint is divided by the sum
   * of the weights of all endpoints in the endpoint's locality to produce a
   * percentage of traffic for the endpoint. This percentage is then further
   * weighted by the endpoint's locality's load balancing weight from
   * LocalityLbEndpoints. If unspecified, will be treated as 1. The sum
   * of the weights of all endpoints in the endpoint's locality must not
   * exceed uint32_t maximal value (4294967295).
   */
  load_balancing_weight?: number | undefined;
}

/**
 * [#not-implemented-hide:]
 * A configuration for a LEDS collection.
 */
export interface LedsClusterLocalityConfig {
  $type: "envoy.config.endpoint.v3.LedsClusterLocalityConfig";
  /** Configuration for the source of LEDS updates for a Locality. */
  leds_config?:
    | ConfigSource
    | undefined;
  /**
   * The xDS transport protocol glob collection resource name.
   * The service is only supported in delta xDS (incremental) mode.
   */
  leds_collection_name?: string | undefined;
}

/**
 * A group of endpoints belonging to a Locality.
 * One can have multiple LocalityLbEndpoints for a locality, but only if
 * they have different priorities.
 * [#next-free-field: 10]
 */
export interface LocalityLbEndpoints {
  $type: "envoy.config.endpoint.v3.LocalityLbEndpoints";
  /** Identifies location of where the upstream hosts run. */
  locality?:
    | Locality
    | undefined;
  /** Metadata to provide additional information about the locality endpoints in aggregate. */
  metadata?:
    | Metadata
    | undefined;
  /**
   * The group of endpoints belonging to the locality specified.
   * [#comment:TODO(adisuissa): Once LEDS is implemented this field needs to be
   * deprecated and replaced by ``load_balancer_endpoints``.]
   */
  lb_endpoints?:
    | LbEndpoint[]
    | undefined;
  /** [#not-implemented-hide:] */
  lb_config?:
    | //
    /**
     * The group of endpoints belonging to the locality.
     * [#comment:TODO(adisuissa): Once LEDS is implemented the ``lb_endpoints`` field
     * needs to be deprecated.]
     */
    { $case: "load_balancer_endpoints"; load_balancer_endpoints: LocalityLbEndpoints_LbEndpointList }
    | //
    /** LEDS Configuration for the current locality. */
    { $case: "leds_cluster_locality_config"; leds_cluster_locality_config: LedsClusterLocalityConfig }
    | undefined;
  /**
   * Optional: Per priority/region/zone/sub_zone weight; at least 1. The load
   * balancing weight for a locality is divided by the sum of the weights of all
   * localities  at the same priority level to produce the effective percentage
   * of traffic for the locality. The sum of the weights of all localities at
   * the same priority level must not exceed uint32_t maximal value (4294967295).
   *
   * Locality weights are only considered when :ref:`locality weighted load
   * balancing <arch_overview_load_balancing_locality_weighted_lb>` is
   * configured. These weights are ignored otherwise. If no weights are
   * specified when locality weighted load balancing is enabled, the locality is
   * assigned no load.
   */
  load_balancing_weight?:
    | number
    | undefined;
  /**
   * Optional: the priority for this LocalityLbEndpoints. If unspecified this will
   * default to the highest priority (0).
   *
   * Under usual circumstances, Envoy will only select endpoints for the highest
   * priority (0). In the event that enough endpoints for a particular priority are
   * unavailable/unhealthy, Envoy will fail over to selecting endpoints for the
   * next highest priority group. Read more at :ref:`priority levels <arch_overview_load_balancing_priority_levels>`.
   *
   * Priorities should range from 0 (highest) to N (lowest) without skipping.
   */
  priority?:
    | number
    | undefined;
  /**
   * Optional: Per locality proximity value which indicates how close this
   * locality is from the source locality. This value only provides ordering
   * information (lower the value, closer it is to the source locality).
   * This will be consumed by load balancing schemes that need proximity order
   * to determine where to route the requests.
   * [#not-implemented-hide:]
   */
  proximity?: number | undefined;
}

/**
 * [#not-implemented-hide:]
 * A list of endpoints of a specific locality.
 */
export interface LocalityLbEndpoints_LbEndpointList {
  $type: "envoy.config.endpoint.v3.LocalityLbEndpoints.LbEndpointList";
  lb_endpoints?: LbEndpoint[] | undefined;
}

function createBaseEndpoint(): Endpoint {
  return { $type: "envoy.config.endpoint.v3.Endpoint" };
}

export const Endpoint: MessageFns<Endpoint, "envoy.config.endpoint.v3.Endpoint"> = {
  $type: "envoy.config.endpoint.v3.Endpoint" as const,

  encode(message: Endpoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== undefined) {
      Address.encode(message.address, writer.uint32(10).fork()).join();
    }
    if (message.health_check_config !== undefined) {
      Endpoint_HealthCheckConfig.encode(message.health_check_config, writer.uint32(18).fork()).join();
    }
    if (message.hostname !== undefined && message.hostname !== "") {
      writer.uint32(26).string(message.hostname);
    }
    if (message.additional_addresses !== undefined && message.additional_addresses.length !== 0) {
      for (const v of message.additional_addresses) {
        Endpoint_AdditionalAddress.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Endpoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = Address.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.health_check_config = Endpoint_HealthCheckConfig.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.hostname = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          if (message.additional_addresses === undefined) {
            message.additional_addresses = [];
          }
          const el = Endpoint_AdditionalAddress.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.additional_addresses!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Endpoint {
    return {
      $type: Endpoint.$type,
      address: isSet(object.address) ? Address.fromJSON(object.address) : undefined,
      health_check_config: isSet(object.health_check_config)
        ? Endpoint_HealthCheckConfig.fromJSON(object.health_check_config)
        : undefined,
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : undefined,
      additional_addresses: globalThis.Array.isArray(object?.additional_addresses)
        ? object.additional_addresses.map((e: any) => Endpoint_AdditionalAddress.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: Endpoint): unknown {
    const obj: any = {};
    if (message.address !== undefined) {
      obj.address = Address.toJSON(message.address);
    }
    if (message.health_check_config !== undefined) {
      obj.health_check_config = Endpoint_HealthCheckConfig.toJSON(message.health_check_config);
    }
    if (message.hostname !== undefined) {
      obj.hostname = message.hostname;
    }
    if (message.additional_addresses?.length) {
      obj.additional_addresses = message.additional_addresses.map((e) => Endpoint_AdditionalAddress.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Endpoint>, I>>(base?: I): Endpoint {
    return Endpoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Endpoint>, I>>(object: I): Endpoint {
    const message = createBaseEndpoint();
    message.address = (object.address !== undefined && object.address !== null)
      ? Address.fromPartial(object.address)
      : undefined;
    message.health_check_config = (object.health_check_config !== undefined && object.health_check_config !== null)
      ? Endpoint_HealthCheckConfig.fromPartial(object.health_check_config)
      : undefined;
    message.hostname = object.hostname ?? undefined;
    message.additional_addresses = object.additional_addresses?.map((e) => Endpoint_AdditionalAddress.fromPartial(e)) ||
      undefined;
    return message;
  },
};

messageTypeRegistry.set(Endpoint.$type, Endpoint);

function createBaseEndpoint_HealthCheckConfig(): Endpoint_HealthCheckConfig {
  return { $type: "envoy.config.endpoint.v3.Endpoint.HealthCheckConfig" };
}

export const Endpoint_HealthCheckConfig: MessageFns<
  Endpoint_HealthCheckConfig,
  "envoy.config.endpoint.v3.Endpoint.HealthCheckConfig"
> = {
  $type: "envoy.config.endpoint.v3.Endpoint.HealthCheckConfig" as const,

  encode(message: Endpoint_HealthCheckConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.port_value !== undefined && message.port_value !== 0) {
      writer.uint32(8).uint32(message.port_value);
    }
    if (message.hostname !== undefined && message.hostname !== "") {
      writer.uint32(18).string(message.hostname);
    }
    if (message.address !== undefined) {
      Address.encode(message.address, writer.uint32(26).fork()).join();
    }
    if (message.disable_active_health_check !== undefined && message.disable_active_health_check !== false) {
      writer.uint32(32).bool(message.disable_active_health_check);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Endpoint_HealthCheckConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndpoint_HealthCheckConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.port_value = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.hostname = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.address = Address.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.disable_active_health_check = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Endpoint_HealthCheckConfig {
    return {
      $type: Endpoint_HealthCheckConfig.$type,
      port_value: isSet(object.port_value) ? globalThis.Number(object.port_value) : undefined,
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : undefined,
      address: isSet(object.address) ? Address.fromJSON(object.address) : undefined,
      disable_active_health_check: isSet(object.disable_active_health_check)
        ? globalThis.Boolean(object.disable_active_health_check)
        : undefined,
    };
  },

  toJSON(message: Endpoint_HealthCheckConfig): unknown {
    const obj: any = {};
    if (message.port_value !== undefined) {
      obj.port_value = Math.round(message.port_value);
    }
    if (message.hostname !== undefined) {
      obj.hostname = message.hostname;
    }
    if (message.address !== undefined) {
      obj.address = Address.toJSON(message.address);
    }
    if (message.disable_active_health_check !== undefined) {
      obj.disable_active_health_check = message.disable_active_health_check;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Endpoint_HealthCheckConfig>, I>>(base?: I): Endpoint_HealthCheckConfig {
    return Endpoint_HealthCheckConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Endpoint_HealthCheckConfig>, I>>(object: I): Endpoint_HealthCheckConfig {
    const message = createBaseEndpoint_HealthCheckConfig();
    message.port_value = object.port_value ?? undefined;
    message.hostname = object.hostname ?? undefined;
    message.address = (object.address !== undefined && object.address !== null)
      ? Address.fromPartial(object.address)
      : undefined;
    message.disable_active_health_check = object.disable_active_health_check ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Endpoint_HealthCheckConfig.$type, Endpoint_HealthCheckConfig);

function createBaseEndpoint_AdditionalAddress(): Endpoint_AdditionalAddress {
  return { $type: "envoy.config.endpoint.v3.Endpoint.AdditionalAddress" };
}

export const Endpoint_AdditionalAddress: MessageFns<
  Endpoint_AdditionalAddress,
  "envoy.config.endpoint.v3.Endpoint.AdditionalAddress"
> = {
  $type: "envoy.config.endpoint.v3.Endpoint.AdditionalAddress" as const,

  encode(message: Endpoint_AdditionalAddress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== undefined) {
      Address.encode(message.address, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Endpoint_AdditionalAddress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndpoint_AdditionalAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = Address.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Endpoint_AdditionalAddress {
    return {
      $type: Endpoint_AdditionalAddress.$type,
      address: isSet(object.address) ? Address.fromJSON(object.address) : undefined,
    };
  },

  toJSON(message: Endpoint_AdditionalAddress): unknown {
    const obj: any = {};
    if (message.address !== undefined) {
      obj.address = Address.toJSON(message.address);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Endpoint_AdditionalAddress>, I>>(base?: I): Endpoint_AdditionalAddress {
    return Endpoint_AdditionalAddress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Endpoint_AdditionalAddress>, I>>(object: I): Endpoint_AdditionalAddress {
    const message = createBaseEndpoint_AdditionalAddress();
    message.address = (object.address !== undefined && object.address !== null)
      ? Address.fromPartial(object.address)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Endpoint_AdditionalAddress.$type, Endpoint_AdditionalAddress);

function createBaseLbEndpoint(): LbEndpoint {
  return { $type: "envoy.config.endpoint.v3.LbEndpoint", host_identifier: undefined };
}

export const LbEndpoint: MessageFns<LbEndpoint, "envoy.config.endpoint.v3.LbEndpoint"> = {
  $type: "envoy.config.endpoint.v3.LbEndpoint" as const,

  encode(message: LbEndpoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.host_identifier?.$case) {
      case "endpoint":
        Endpoint.encode(message.host_identifier.endpoint, writer.uint32(10).fork()).join();
        break;
      case "endpoint_name":
        writer.uint32(42).string(message.host_identifier.endpoint_name);
        break;
    }
    if (message.health_status !== undefined && message.health_status !== HealthStatus.UNKNOWN) {
      writer.uint32(16).int32(healthStatusToNumber(message.health_status));
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    if (message.load_balancing_weight !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.load_balancing_weight! },
        writer.uint32(34).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LbEndpoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLbEndpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.host_identifier = { $case: "endpoint", endpoint: Endpoint.decode(reader, reader.uint32()) };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.host_identifier = { $case: "endpoint_name", endpoint_name: reader.string() };
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.health_status = healthStatusFromJSON(reader.int32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.load_balancing_weight = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LbEndpoint {
    return {
      $type: LbEndpoint.$type,
      host_identifier: isSet(object.endpoint)
        ? { $case: "endpoint", endpoint: Endpoint.fromJSON(object.endpoint) }
        : isSet(object.endpoint_name)
        ? { $case: "endpoint_name", endpoint_name: globalThis.String(object.endpoint_name) }
        : undefined,
      health_status: isSet(object.health_status) ? healthStatusFromJSON(object.health_status) : undefined,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      load_balancing_weight: isSet(object.load_balancing_weight) ? Number(object.load_balancing_weight) : undefined,
    };
  },

  toJSON(message: LbEndpoint): unknown {
    const obj: any = {};
    if (message.host_identifier?.$case === "endpoint") {
      obj.endpoint = Endpoint.toJSON(message.host_identifier.endpoint);
    }
    if (message.host_identifier?.$case === "endpoint_name") {
      obj.endpoint_name = message.host_identifier.endpoint_name;
    }
    if (message.health_status !== undefined) {
      obj.health_status = healthStatusToJSON(message.health_status);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.load_balancing_weight !== undefined) {
      obj.load_balancing_weight = message.load_balancing_weight;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LbEndpoint>, I>>(base?: I): LbEndpoint {
    return LbEndpoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LbEndpoint>, I>>(object: I): LbEndpoint {
    const message = createBaseLbEndpoint();
    if (
      object.host_identifier?.$case === "endpoint" &&
      object.host_identifier?.endpoint !== undefined &&
      object.host_identifier?.endpoint !== null
    ) {
      message.host_identifier = { $case: "endpoint", endpoint: Endpoint.fromPartial(object.host_identifier.endpoint) };
    }
    if (
      object.host_identifier?.$case === "endpoint_name" &&
      object.host_identifier?.endpoint_name !== undefined &&
      object.host_identifier?.endpoint_name !== null
    ) {
      message.host_identifier = { $case: "endpoint_name", endpoint_name: object.host_identifier.endpoint_name };
    }
    message.health_status = object.health_status ?? undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.load_balancing_weight = object.load_balancing_weight ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(LbEndpoint.$type, LbEndpoint);

function createBaseLedsClusterLocalityConfig(): LedsClusterLocalityConfig {
  return { $type: "envoy.config.endpoint.v3.LedsClusterLocalityConfig" };
}

export const LedsClusterLocalityConfig: MessageFns<
  LedsClusterLocalityConfig,
  "envoy.config.endpoint.v3.LedsClusterLocalityConfig"
> = {
  $type: "envoy.config.endpoint.v3.LedsClusterLocalityConfig" as const,

  encode(message: LedsClusterLocalityConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.leds_config !== undefined) {
      ConfigSource.encode(message.leds_config, writer.uint32(10).fork()).join();
    }
    if (message.leds_collection_name !== undefined && message.leds_collection_name !== "") {
      writer.uint32(18).string(message.leds_collection_name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LedsClusterLocalityConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLedsClusterLocalityConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leds_config = ConfigSource.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.leds_collection_name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LedsClusterLocalityConfig {
    return {
      $type: LedsClusterLocalityConfig.$type,
      leds_config: isSet(object.leds_config) ? ConfigSource.fromJSON(object.leds_config) : undefined,
      leds_collection_name: isSet(object.leds_collection_name)
        ? globalThis.String(object.leds_collection_name)
        : undefined,
    };
  },

  toJSON(message: LedsClusterLocalityConfig): unknown {
    const obj: any = {};
    if (message.leds_config !== undefined) {
      obj.leds_config = ConfigSource.toJSON(message.leds_config);
    }
    if (message.leds_collection_name !== undefined) {
      obj.leds_collection_name = message.leds_collection_name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LedsClusterLocalityConfig>, I>>(base?: I): LedsClusterLocalityConfig {
    return LedsClusterLocalityConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LedsClusterLocalityConfig>, I>>(object: I): LedsClusterLocalityConfig {
    const message = createBaseLedsClusterLocalityConfig();
    message.leds_config = (object.leds_config !== undefined && object.leds_config !== null)
      ? ConfigSource.fromPartial(object.leds_config)
      : undefined;
    message.leds_collection_name = object.leds_collection_name ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(LedsClusterLocalityConfig.$type, LedsClusterLocalityConfig);

function createBaseLocalityLbEndpoints(): LocalityLbEndpoints {
  return { $type: "envoy.config.endpoint.v3.LocalityLbEndpoints", lb_config: undefined };
}

export const LocalityLbEndpoints: MessageFns<LocalityLbEndpoints, "envoy.config.endpoint.v3.LocalityLbEndpoints"> = {
  $type: "envoy.config.endpoint.v3.LocalityLbEndpoints" as const,

  encode(message: LocalityLbEndpoints, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.locality !== undefined) {
      Locality.encode(message.locality, writer.uint32(10).fork()).join();
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(74).fork()).join();
    }
    if (message.lb_endpoints !== undefined && message.lb_endpoints.length !== 0) {
      for (const v of message.lb_endpoints) {
        LbEndpoint.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    switch (message.lb_config?.$case) {
      case "load_balancer_endpoints":
        LocalityLbEndpoints_LbEndpointList.encode(message.lb_config.load_balancer_endpoints, writer.uint32(58).fork())
          .join();
        break;
      case "leds_cluster_locality_config":
        LedsClusterLocalityConfig.encode(message.lb_config.leds_cluster_locality_config, writer.uint32(66).fork())
          .join();
        break;
    }
    if (message.load_balancing_weight !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.load_balancing_weight! },
        writer.uint32(26).fork(),
      ).join();
    }
    if (message.priority !== undefined && message.priority !== 0) {
      writer.uint32(40).uint32(message.priority);
    }
    if (message.proximity !== undefined) {
      UInt32Value.encode({ $type: "google.protobuf.UInt32Value", value: message.proximity! }, writer.uint32(50).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocalityLbEndpoints {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocalityLbEndpoints();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.locality = Locality.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.lb_endpoints === undefined) {
            message.lb_endpoints = [];
          }
          const el = LbEndpoint.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.lb_endpoints!.push(el);
          }
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.lb_config = {
            $case: "load_balancer_endpoints",
            load_balancer_endpoints: LocalityLbEndpoints_LbEndpointList.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.lb_config = {
            $case: "leds_cluster_locality_config",
            leds_cluster_locality_config: LedsClusterLocalityConfig.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.load_balancing_weight = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.priority = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.proximity = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocalityLbEndpoints {
    return {
      $type: LocalityLbEndpoints.$type,
      locality: isSet(object.locality) ? Locality.fromJSON(object.locality) : undefined,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      lb_endpoints: globalThis.Array.isArray(object?.lb_endpoints)
        ? object.lb_endpoints.map((e: any) => LbEndpoint.fromJSON(e))
        : undefined,
      lb_config: isSet(object.load_balancer_endpoints)
        ? {
          $case: "load_balancer_endpoints",
          load_balancer_endpoints: LocalityLbEndpoints_LbEndpointList.fromJSON(object.load_balancer_endpoints),
        }
        : isSet(object.leds_cluster_locality_config)
        ? {
          $case: "leds_cluster_locality_config",
          leds_cluster_locality_config: LedsClusterLocalityConfig.fromJSON(object.leds_cluster_locality_config),
        }
        : undefined,
      load_balancing_weight: isSet(object.load_balancing_weight) ? Number(object.load_balancing_weight) : undefined,
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : undefined,
      proximity: isSet(object.proximity) ? Number(object.proximity) : undefined,
    };
  },

  toJSON(message: LocalityLbEndpoints): unknown {
    const obj: any = {};
    if (message.locality !== undefined) {
      obj.locality = Locality.toJSON(message.locality);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.lb_endpoints?.length) {
      obj.lb_endpoints = message.lb_endpoints.map((e) => LbEndpoint.toJSON(e));
    }
    if (message.lb_config?.$case === "load_balancer_endpoints") {
      obj.load_balancer_endpoints = LocalityLbEndpoints_LbEndpointList.toJSON(
        message.lb_config.load_balancer_endpoints,
      );
    }
    if (message.lb_config?.$case === "leds_cluster_locality_config") {
      obj.leds_cluster_locality_config = LedsClusterLocalityConfig.toJSON(
        message.lb_config.leds_cluster_locality_config,
      );
    }
    if (message.load_balancing_weight !== undefined) {
      obj.load_balancing_weight = message.load_balancing_weight;
    }
    if (message.priority !== undefined) {
      obj.priority = Math.round(message.priority);
    }
    if (message.proximity !== undefined) {
      obj.proximity = message.proximity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LocalityLbEndpoints>, I>>(base?: I): LocalityLbEndpoints {
    return LocalityLbEndpoints.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LocalityLbEndpoints>, I>>(object: I): LocalityLbEndpoints {
    const message = createBaseLocalityLbEndpoints();
    message.locality = (object.locality !== undefined && object.locality !== null)
      ? Locality.fromPartial(object.locality)
      : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.lb_endpoints = object.lb_endpoints?.map((e) => LbEndpoint.fromPartial(e)) || undefined;
    if (
      object.lb_config?.$case === "load_balancer_endpoints" &&
      object.lb_config?.load_balancer_endpoints !== undefined &&
      object.lb_config?.load_balancer_endpoints !== null
    ) {
      message.lb_config = {
        $case: "load_balancer_endpoints",
        load_balancer_endpoints: LocalityLbEndpoints_LbEndpointList.fromPartial(
          object.lb_config.load_balancer_endpoints,
        ),
      };
    }
    if (
      object.lb_config?.$case === "leds_cluster_locality_config" &&
      object.lb_config?.leds_cluster_locality_config !== undefined &&
      object.lb_config?.leds_cluster_locality_config !== null
    ) {
      message.lb_config = {
        $case: "leds_cluster_locality_config",
        leds_cluster_locality_config: LedsClusterLocalityConfig.fromPartial(
          object.lb_config.leds_cluster_locality_config,
        ),
      };
    }
    message.load_balancing_weight = object.load_balancing_weight ?? undefined;
    message.priority = object.priority ?? undefined;
    message.proximity = object.proximity ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(LocalityLbEndpoints.$type, LocalityLbEndpoints);

function createBaseLocalityLbEndpoints_LbEndpointList(): LocalityLbEndpoints_LbEndpointList {
  return { $type: "envoy.config.endpoint.v3.LocalityLbEndpoints.LbEndpointList" };
}

export const LocalityLbEndpoints_LbEndpointList: MessageFns<
  LocalityLbEndpoints_LbEndpointList,
  "envoy.config.endpoint.v3.LocalityLbEndpoints.LbEndpointList"
> = {
  $type: "envoy.config.endpoint.v3.LocalityLbEndpoints.LbEndpointList" as const,

  encode(message: LocalityLbEndpoints_LbEndpointList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lb_endpoints !== undefined && message.lb_endpoints.length !== 0) {
      for (const v of message.lb_endpoints) {
        LbEndpoint.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocalityLbEndpoints_LbEndpointList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocalityLbEndpoints_LbEndpointList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.lb_endpoints === undefined) {
            message.lb_endpoints = [];
          }
          const el = LbEndpoint.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.lb_endpoints!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocalityLbEndpoints_LbEndpointList {
    return {
      $type: LocalityLbEndpoints_LbEndpointList.$type,
      lb_endpoints: globalThis.Array.isArray(object?.lb_endpoints)
        ? object.lb_endpoints.map((e: any) => LbEndpoint.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: LocalityLbEndpoints_LbEndpointList): unknown {
    const obj: any = {};
    if (message.lb_endpoints?.length) {
      obj.lb_endpoints = message.lb_endpoints.map((e) => LbEndpoint.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LocalityLbEndpoints_LbEndpointList>, I>>(
    base?: I,
  ): LocalityLbEndpoints_LbEndpointList {
    return LocalityLbEndpoints_LbEndpointList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LocalityLbEndpoints_LbEndpointList>, I>>(
    object: I,
  ): LocalityLbEndpoints_LbEndpointList {
    const message = createBaseLocalityLbEndpoints_LbEndpointList();
    message.lb_endpoints = object.lb_endpoints?.map((e) => LbEndpoint.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(LocalityLbEndpoints_LbEndpointList.$type, LocalityLbEndpoints_LbEndpointList);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
