// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/config/filter/network/tcp_proxy/v2/tcp_proxy.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../../../../google/protobuf/duration";
import { UInt32Value } from "../../../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../../../typeRegistry";
import { CidrRange } from "../../../../../api/v2/core/address";
import { Metadata } from "../../../../../api/v2/core/base";
import { HashPolicy } from "../../../../../type/hash_policy";
import { AccessLog } from "../../../accesslog/v2/accesslog";

export const protobufPackage = "envoy.config.filter.network.tcp_proxy.v2";

/** [#next-free-field: 13] */
export interface TcpProxy {
  $type: "envoy.config.filter.network.tcp_proxy.v2.TcpProxy";
  /**
   * The prefix to use when emitting :ref:`statistics
   * <config_network_filters_tcp_proxy_stats>`.
   */
  stat_prefix?: string | undefined;
  cluster_specifier?:
    | //
    /** The upstream cluster to connect to. */
    { $case: "cluster"; cluster: string }
    | //
    /**
     * Multiple upstream clusters can be specified for a given route. The
     * request is routed to one of the upstream clusters based on weights
     * assigned to each cluster.
     */
    { $case: "weighted_clusters"; weighted_clusters: TcpProxy_WeightedCluster }
    | undefined;
  /**
   * Optional endpoint metadata match criteria. Only endpoints in the upstream
   * cluster with metadata matching that set in metadata_match will be
   * considered. The filter name should be specified as *envoy.lb*.
   */
  metadata_match?:
    | Metadata
    | undefined;
  /**
   * The idle timeout for connections managed by the TCP proxy filter. The idle timeout
   * is defined as the period in which there are no bytes sent or received on either
   * the upstream or downstream connection. If not set, the default idle timeout is 1 hour. If set
   * to 0s, the timeout will be disabled.
   *
   * .. warning::
   *   Disabling this timeout has a highly likelihood of yielding connection leaks due to lost TCP
   *   FIN packets, etc.
   */
  idle_timeout?:
    | Duration
    | undefined;
  /**
   * [#not-implemented-hide:] The idle timeout for connections managed by the TCP proxy
   * filter. The idle timeout is defined as the period in which there is no
   * active traffic. If not set, there is no idle timeout. When the idle timeout
   * is reached the connection will be closed. The distinction between
   * downstream_idle_timeout/upstream_idle_timeout provides a means to set
   * timeout based on the last byte sent on the downstream/upstream connection.
   */
  downstream_idle_timeout?:
    | Duration
    | undefined;
  /** [#not-implemented-hide:] */
  upstream_idle_timeout?:
    | Duration
    | undefined;
  /**
   * Configuration for :ref:`access logs <arch_overview_access_logs>`
   * emitted by the this tcp_proxy.
   */
  access_log?:
    | AccessLog[]
    | undefined;
  /**
   * [#not-implemented-hide:] Deprecated.
   *
   * @deprecated
   */
  deprecated_v1?:
    | TcpProxy_DeprecatedV1
    | undefined;
  /**
   * The maximum number of unsuccessful connection attempts that will be made before
   * giving up. If the parameter is not specified, 1 connection attempt will be made.
   */
  max_connect_attempts?:
    | number
    | undefined;
  /**
   * Optional configuration for TCP proxy hash policy. If hash_policy is not set, the hash-based
   * load balancing algorithms will select a host randomly. Currently the number of hash policies is
   * limited to 1.
   */
  hash_policy?:
    | HashPolicy[]
    | undefined;
  /**
   * [#not-implemented-hide:] feature in progress
   * If set, this configures tunneling, e.g. configuration options to tunnel multiple TCP
   * payloads over a shared HTTP/2 tunnel. If this message is absent, the payload
   * will be proxied upstream as per usual.
   */
  tunneling_config?: TcpProxy_TunnelingConfig | undefined;
}

/**
 * [#not-implemented-hide:] Deprecated.
 * TCP Proxy filter configuration using V1 format.
 *
 * @deprecated
 */
export interface TcpProxy_DeprecatedV1 {
  $type: "envoy.config.filter.network.tcp_proxy.v2.TcpProxy.DeprecatedV1";
  /**
   * The route table for the filter. All filter instances must have a route
   * table, even if it is empty.
   */
  routes?: TcpProxy_DeprecatedV1_TCPRoute[] | undefined;
}

/**
 * A TCP proxy route consists of a set of optional L4 criteria and the
 * name of a cluster. If a downstream connection matches all the
 * specified criteria, the cluster in the route is used for the
 * corresponding upstream connection. Routes are tried in the order
 * specified until a match is found. If no match is found, the connection
 * is closed. A route with no criteria is valid and always produces a
 * match.
 * [#next-free-field: 6]
 */
export interface TcpProxy_DeprecatedV1_TCPRoute {
  $type: "envoy.config.filter.network.tcp_proxy.v2.TcpProxy.DeprecatedV1.TCPRoute";
  /**
   * The cluster to connect to when a the downstream network connection
   * matches the specified criteria.
   */
  cluster?:
    | string
    | undefined;
  /**
   * An optional list of IP address subnets in the form
   * “ip_address/xx”. The criteria is satisfied if the destination IP
   * address of the downstream connection is contained in at least one of
   * the specified subnets. If the parameter is not specified or the list
   * is empty, the destination IP address is ignored. The destination IP
   * address of the downstream connection might be different from the
   * addresses on which the proxy is listening if the connection has been
   * redirected.
   */
  destination_ip_list?:
    | CidrRange[]
    | undefined;
  /**
   * An optional string containing a comma-separated list of port numbers
   * or ranges. The criteria is satisfied if the destination port of the
   * downstream connection is contained in at least one of the specified
   * ranges. If the parameter is not specified, the destination port is
   * ignored. The destination port address of the downstream connection
   * might be different from the port on which the proxy is listening if
   * the connection has been redirected.
   */
  destination_ports?:
    | string
    | undefined;
  /**
   * An optional list of IP address subnets in the form
   * “ip_address/xx”. The criteria is satisfied if the source IP address
   * of the downstream connection is contained in at least one of the
   * specified subnets. If the parameter is not specified or the list is
   * empty, the source IP address is ignored.
   */
  source_ip_list?:
    | CidrRange[]
    | undefined;
  /**
   * An optional string containing a comma-separated list of port numbers
   * or ranges. The criteria is satisfied if the source port of the
   * downstream connection is contained in at least one of the specified
   * ranges. If the parameter is not specified, the source port is
   * ignored.
   */
  source_ports?: string | undefined;
}

/**
 * Allows for specification of multiple upstream clusters along with weights
 * that indicate the percentage of traffic to be forwarded to each cluster.
 * The router selects an upstream cluster based on these weights.
 */
export interface TcpProxy_WeightedCluster {
  $type: "envoy.config.filter.network.tcp_proxy.v2.TcpProxy.WeightedCluster";
  /** Specifies one or more upstream clusters associated with the route. */
  clusters?: TcpProxy_WeightedCluster_ClusterWeight[] | undefined;
}

export interface TcpProxy_WeightedCluster_ClusterWeight {
  $type: "envoy.config.filter.network.tcp_proxy.v2.TcpProxy.WeightedCluster.ClusterWeight";
  /** Name of the upstream cluster. */
  name?:
    | string
    | undefined;
  /**
   * When a request matches the route, the choice of an upstream cluster is
   * determined by its weight. The sum of weights across all entries in the
   * clusters array determines the total weight.
   */
  weight?:
    | number
    | undefined;
  /**
   * Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints
   * in the upstream cluster with metadata matching what is set in this field will be considered
   * for load balancing. Note that this will be merged with what's provided in
   * :ref:`TcpProxy.metadata_match
   * <envoy_api_field_config.filter.network.tcp_proxy.v2.TcpProxy.metadata_match>`, with values
   * here taking precedence. The filter name should be specified as *envoy.lb*.
   */
  metadata_match?: Metadata | undefined;
}

/**
 * Configuration for tunneling TCP over other transports or application layers.
 * Currently, only HTTP/2 is supported. When other options exist, HTTP/2 will
 * remain the default.
 */
export interface TcpProxy_TunnelingConfig {
  $type: "envoy.config.filter.network.tcp_proxy.v2.TcpProxy.TunnelingConfig";
  /** The hostname to send in the synthesized CONNECT headers to the upstream proxy. */
  hostname?: string | undefined;
}

function createBaseTcpProxy(): TcpProxy {
  return { $type: "envoy.config.filter.network.tcp_proxy.v2.TcpProxy", cluster_specifier: undefined };
}

export const TcpProxy: MessageFns<TcpProxy, "envoy.config.filter.network.tcp_proxy.v2.TcpProxy"> = {
  $type: "envoy.config.filter.network.tcp_proxy.v2.TcpProxy" as const,

  encode(message: TcpProxy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stat_prefix !== undefined && message.stat_prefix !== "") {
      writer.uint32(10).string(message.stat_prefix);
    }
    switch (message.cluster_specifier?.$case) {
      case "cluster":
        writer.uint32(18).string(message.cluster_specifier.cluster);
        break;
      case "weighted_clusters":
        TcpProxy_WeightedCluster.encode(message.cluster_specifier.weighted_clusters, writer.uint32(82).fork()).join();
        break;
    }
    if (message.metadata_match !== undefined) {
      Metadata.encode(message.metadata_match, writer.uint32(74).fork()).join();
    }
    if (message.idle_timeout !== undefined) {
      Duration.encode(message.idle_timeout, writer.uint32(66).fork()).join();
    }
    if (message.downstream_idle_timeout !== undefined) {
      Duration.encode(message.downstream_idle_timeout, writer.uint32(26).fork()).join();
    }
    if (message.upstream_idle_timeout !== undefined) {
      Duration.encode(message.upstream_idle_timeout, writer.uint32(34).fork()).join();
    }
    if (message.access_log !== undefined && message.access_log.length !== 0) {
      for (const v of message.access_log) {
        AccessLog.encode(v!, writer.uint32(42).fork()).join();
      }
    }
    if (message.deprecated_v1 !== undefined) {
      TcpProxy_DeprecatedV1.encode(message.deprecated_v1, writer.uint32(50).fork()).join();
    }
    if (message.max_connect_attempts !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.max_connect_attempts! },
        writer.uint32(58).fork(),
      ).join();
    }
    if (message.hash_policy !== undefined && message.hash_policy.length !== 0) {
      for (const v of message.hash_policy) {
        HashPolicy.encode(v!, writer.uint32(90).fork()).join();
      }
    }
    if (message.tunneling_config !== undefined) {
      TcpProxy_TunnelingConfig.encode(message.tunneling_config, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TcpProxy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTcpProxy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stat_prefix = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cluster_specifier = { $case: "cluster", cluster: reader.string() };
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.cluster_specifier = {
            $case: "weighted_clusters",
            weighted_clusters: TcpProxy_WeightedCluster.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.metadata_match = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.idle_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.downstream_idle_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.upstream_idle_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          if (message.access_log === undefined) {
            message.access_log = [];
          }
          const el = AccessLog.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.access_log!.push(el);
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.deprecated_v1 = TcpProxy_DeprecatedV1.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.max_connect_attempts = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          if (message.hash_policy === undefined) {
            message.hash_policy = [];
          }
          const el = HashPolicy.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.hash_policy!.push(el);
          }
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.tunneling_config = TcpProxy_TunnelingConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TcpProxy {
    return {
      $type: TcpProxy.$type,
      stat_prefix: isSet(object.stat_prefix) ? globalThis.String(object.stat_prefix) : undefined,
      cluster_specifier: isSet(object.cluster)
        ? { $case: "cluster", cluster: globalThis.String(object.cluster) }
        : isSet(object.weighted_clusters)
        ? { $case: "weighted_clusters", weighted_clusters: TcpProxy_WeightedCluster.fromJSON(object.weighted_clusters) }
        : undefined,
      metadata_match: isSet(object.metadata_match) ? Metadata.fromJSON(object.metadata_match) : undefined,
      idle_timeout: isSet(object.idle_timeout) ? Duration.fromJSON(object.idle_timeout) : undefined,
      downstream_idle_timeout: isSet(object.downstream_idle_timeout)
        ? Duration.fromJSON(object.downstream_idle_timeout)
        : undefined,
      upstream_idle_timeout: isSet(object.upstream_idle_timeout)
        ? Duration.fromJSON(object.upstream_idle_timeout)
        : undefined,
      access_log: globalThis.Array.isArray(object?.access_log)
        ? object.access_log.map((e: any) => AccessLog.fromJSON(e))
        : undefined,
      deprecated_v1: isSet(object.deprecated_v1) ? TcpProxy_DeprecatedV1.fromJSON(object.deprecated_v1) : undefined,
      max_connect_attempts: isSet(object.max_connect_attempts) ? Number(object.max_connect_attempts) : undefined,
      hash_policy: globalThis.Array.isArray(object?.hash_policy)
        ? object.hash_policy.map((e: any) => HashPolicy.fromJSON(e))
        : undefined,
      tunneling_config: isSet(object.tunneling_config)
        ? TcpProxy_TunnelingConfig.fromJSON(object.tunneling_config)
        : undefined,
    };
  },

  toJSON(message: TcpProxy): unknown {
    const obj: any = {};
    if (message.stat_prefix !== undefined) {
      obj.stat_prefix = message.stat_prefix;
    }
    if (message.cluster_specifier?.$case === "cluster") {
      obj.cluster = message.cluster_specifier.cluster;
    }
    if (message.cluster_specifier?.$case === "weighted_clusters") {
      obj.weighted_clusters = TcpProxy_WeightedCluster.toJSON(message.cluster_specifier.weighted_clusters);
    }
    if (message.metadata_match !== undefined) {
      obj.metadata_match = Metadata.toJSON(message.metadata_match);
    }
    if (message.idle_timeout !== undefined) {
      obj.idle_timeout = Duration.toJSON(message.idle_timeout);
    }
    if (message.downstream_idle_timeout !== undefined) {
      obj.downstream_idle_timeout = Duration.toJSON(message.downstream_idle_timeout);
    }
    if (message.upstream_idle_timeout !== undefined) {
      obj.upstream_idle_timeout = Duration.toJSON(message.upstream_idle_timeout);
    }
    if (message.access_log?.length) {
      obj.access_log = message.access_log.map((e) => AccessLog.toJSON(e));
    }
    if (message.deprecated_v1 !== undefined) {
      obj.deprecated_v1 = TcpProxy_DeprecatedV1.toJSON(message.deprecated_v1);
    }
    if (message.max_connect_attempts !== undefined) {
      obj.max_connect_attempts = message.max_connect_attempts;
    }
    if (message.hash_policy?.length) {
      obj.hash_policy = message.hash_policy.map((e) => HashPolicy.toJSON(e));
    }
    if (message.tunneling_config !== undefined) {
      obj.tunneling_config = TcpProxy_TunnelingConfig.toJSON(message.tunneling_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TcpProxy>, I>>(base?: I): TcpProxy {
    return TcpProxy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TcpProxy>, I>>(object: I): TcpProxy {
    const message = createBaseTcpProxy();
    message.stat_prefix = object.stat_prefix ?? undefined;
    if (
      object.cluster_specifier?.$case === "cluster" &&
      object.cluster_specifier?.cluster !== undefined &&
      object.cluster_specifier?.cluster !== null
    ) {
      message.cluster_specifier = { $case: "cluster", cluster: object.cluster_specifier.cluster };
    }
    if (
      object.cluster_specifier?.$case === "weighted_clusters" &&
      object.cluster_specifier?.weighted_clusters !== undefined &&
      object.cluster_specifier?.weighted_clusters !== null
    ) {
      message.cluster_specifier = {
        $case: "weighted_clusters",
        weighted_clusters: TcpProxy_WeightedCluster.fromPartial(object.cluster_specifier.weighted_clusters),
      };
    }
    message.metadata_match = (object.metadata_match !== undefined && object.metadata_match !== null)
      ? Metadata.fromPartial(object.metadata_match)
      : undefined;
    message.idle_timeout = (object.idle_timeout !== undefined && object.idle_timeout !== null)
      ? Duration.fromPartial(object.idle_timeout)
      : undefined;
    message.downstream_idle_timeout =
      (object.downstream_idle_timeout !== undefined && object.downstream_idle_timeout !== null)
        ? Duration.fromPartial(object.downstream_idle_timeout)
        : undefined;
    message.upstream_idle_timeout =
      (object.upstream_idle_timeout !== undefined && object.upstream_idle_timeout !== null)
        ? Duration.fromPartial(object.upstream_idle_timeout)
        : undefined;
    message.access_log = object.access_log?.map((e) => AccessLog.fromPartial(e)) || undefined;
    message.deprecated_v1 = (object.deprecated_v1 !== undefined && object.deprecated_v1 !== null)
      ? TcpProxy_DeprecatedV1.fromPartial(object.deprecated_v1)
      : undefined;
    message.max_connect_attempts = object.max_connect_attempts ?? undefined;
    message.hash_policy = object.hash_policy?.map((e) => HashPolicy.fromPartial(e)) || undefined;
    message.tunneling_config = (object.tunneling_config !== undefined && object.tunneling_config !== null)
      ? TcpProxy_TunnelingConfig.fromPartial(object.tunneling_config)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(TcpProxy.$type, TcpProxy);

function createBaseTcpProxy_DeprecatedV1(): TcpProxy_DeprecatedV1 {
  return { $type: "envoy.config.filter.network.tcp_proxy.v2.TcpProxy.DeprecatedV1" };
}

export const TcpProxy_DeprecatedV1: MessageFns<
  TcpProxy_DeprecatedV1,
  "envoy.config.filter.network.tcp_proxy.v2.TcpProxy.DeprecatedV1"
> = {
  $type: "envoy.config.filter.network.tcp_proxy.v2.TcpProxy.DeprecatedV1" as const,

  encode(message: TcpProxy_DeprecatedV1, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.routes !== undefined && message.routes.length !== 0) {
      for (const v of message.routes) {
        TcpProxy_DeprecatedV1_TCPRoute.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TcpProxy_DeprecatedV1 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTcpProxy_DeprecatedV1();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.routes === undefined) {
            message.routes = [];
          }
          const el = TcpProxy_DeprecatedV1_TCPRoute.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.routes!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TcpProxy_DeprecatedV1 {
    return {
      $type: TcpProxy_DeprecatedV1.$type,
      routes: globalThis.Array.isArray(object?.routes)
        ? object.routes.map((e: any) => TcpProxy_DeprecatedV1_TCPRoute.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: TcpProxy_DeprecatedV1): unknown {
    const obj: any = {};
    if (message.routes?.length) {
      obj.routes = message.routes.map((e) => TcpProxy_DeprecatedV1_TCPRoute.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TcpProxy_DeprecatedV1>, I>>(base?: I): TcpProxy_DeprecatedV1 {
    return TcpProxy_DeprecatedV1.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TcpProxy_DeprecatedV1>, I>>(object: I): TcpProxy_DeprecatedV1 {
    const message = createBaseTcpProxy_DeprecatedV1();
    message.routes = object.routes?.map((e) => TcpProxy_DeprecatedV1_TCPRoute.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(TcpProxy_DeprecatedV1.$type, TcpProxy_DeprecatedV1);

function createBaseTcpProxy_DeprecatedV1_TCPRoute(): TcpProxy_DeprecatedV1_TCPRoute {
  return { $type: "envoy.config.filter.network.tcp_proxy.v2.TcpProxy.DeprecatedV1.TCPRoute" };
}

export const TcpProxy_DeprecatedV1_TCPRoute: MessageFns<
  TcpProxy_DeprecatedV1_TCPRoute,
  "envoy.config.filter.network.tcp_proxy.v2.TcpProxy.DeprecatedV1.TCPRoute"
> = {
  $type: "envoy.config.filter.network.tcp_proxy.v2.TcpProxy.DeprecatedV1.TCPRoute" as const,

  encode(message: TcpProxy_DeprecatedV1_TCPRoute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cluster !== undefined && message.cluster !== "") {
      writer.uint32(10).string(message.cluster);
    }
    if (message.destination_ip_list !== undefined && message.destination_ip_list.length !== 0) {
      for (const v of message.destination_ip_list) {
        CidrRange.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.destination_ports !== undefined && message.destination_ports !== "") {
      writer.uint32(26).string(message.destination_ports);
    }
    if (message.source_ip_list !== undefined && message.source_ip_list.length !== 0) {
      for (const v of message.source_ip_list) {
        CidrRange.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    if (message.source_ports !== undefined && message.source_ports !== "") {
      writer.uint32(42).string(message.source_ports);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TcpProxy_DeprecatedV1_TCPRoute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTcpProxy_DeprecatedV1_TCPRoute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cluster = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.destination_ip_list === undefined) {
            message.destination_ip_list = [];
          }
          const el = CidrRange.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.destination_ip_list!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.destination_ports = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          if (message.source_ip_list === undefined) {
            message.source_ip_list = [];
          }
          const el = CidrRange.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.source_ip_list!.push(el);
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.source_ports = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TcpProxy_DeprecatedV1_TCPRoute {
    return {
      $type: TcpProxy_DeprecatedV1_TCPRoute.$type,
      cluster: isSet(object.cluster) ? globalThis.String(object.cluster) : undefined,
      destination_ip_list: globalThis.Array.isArray(object?.destination_ip_list)
        ? object.destination_ip_list.map((e: any) => CidrRange.fromJSON(e))
        : undefined,
      destination_ports: isSet(object.destination_ports) ? globalThis.String(object.destination_ports) : undefined,
      source_ip_list: globalThis.Array.isArray(object?.source_ip_list)
        ? object.source_ip_list.map((e: any) => CidrRange.fromJSON(e))
        : undefined,
      source_ports: isSet(object.source_ports) ? globalThis.String(object.source_ports) : undefined,
    };
  },

  toJSON(message: TcpProxy_DeprecatedV1_TCPRoute): unknown {
    const obj: any = {};
    if (message.cluster !== undefined) {
      obj.cluster = message.cluster;
    }
    if (message.destination_ip_list?.length) {
      obj.destination_ip_list = message.destination_ip_list.map((e) => CidrRange.toJSON(e));
    }
    if (message.destination_ports !== undefined) {
      obj.destination_ports = message.destination_ports;
    }
    if (message.source_ip_list?.length) {
      obj.source_ip_list = message.source_ip_list.map((e) => CidrRange.toJSON(e));
    }
    if (message.source_ports !== undefined) {
      obj.source_ports = message.source_ports;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TcpProxy_DeprecatedV1_TCPRoute>, I>>(base?: I): TcpProxy_DeprecatedV1_TCPRoute {
    return TcpProxy_DeprecatedV1_TCPRoute.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TcpProxy_DeprecatedV1_TCPRoute>, I>>(
    object: I,
  ): TcpProxy_DeprecatedV1_TCPRoute {
    const message = createBaseTcpProxy_DeprecatedV1_TCPRoute();
    message.cluster = object.cluster ?? undefined;
    message.destination_ip_list = object.destination_ip_list?.map((e) => CidrRange.fromPartial(e)) || undefined;
    message.destination_ports = object.destination_ports ?? undefined;
    message.source_ip_list = object.source_ip_list?.map((e) => CidrRange.fromPartial(e)) || undefined;
    message.source_ports = object.source_ports ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(TcpProxy_DeprecatedV1_TCPRoute.$type, TcpProxy_DeprecatedV1_TCPRoute);

function createBaseTcpProxy_WeightedCluster(): TcpProxy_WeightedCluster {
  return { $type: "envoy.config.filter.network.tcp_proxy.v2.TcpProxy.WeightedCluster" };
}

export const TcpProxy_WeightedCluster: MessageFns<
  TcpProxy_WeightedCluster,
  "envoy.config.filter.network.tcp_proxy.v2.TcpProxy.WeightedCluster"
> = {
  $type: "envoy.config.filter.network.tcp_proxy.v2.TcpProxy.WeightedCluster" as const,

  encode(message: TcpProxy_WeightedCluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clusters !== undefined && message.clusters.length !== 0) {
      for (const v of message.clusters) {
        TcpProxy_WeightedCluster_ClusterWeight.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TcpProxy_WeightedCluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTcpProxy_WeightedCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.clusters === undefined) {
            message.clusters = [];
          }
          const el = TcpProxy_WeightedCluster_ClusterWeight.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.clusters!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TcpProxy_WeightedCluster {
    return {
      $type: TcpProxy_WeightedCluster.$type,
      clusters: globalThis.Array.isArray(object?.clusters)
        ? object.clusters.map((e: any) => TcpProxy_WeightedCluster_ClusterWeight.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: TcpProxy_WeightedCluster): unknown {
    const obj: any = {};
    if (message.clusters?.length) {
      obj.clusters = message.clusters.map((e) => TcpProxy_WeightedCluster_ClusterWeight.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TcpProxy_WeightedCluster>, I>>(base?: I): TcpProxy_WeightedCluster {
    return TcpProxy_WeightedCluster.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TcpProxy_WeightedCluster>, I>>(object: I): TcpProxy_WeightedCluster {
    const message = createBaseTcpProxy_WeightedCluster();
    message.clusters = object.clusters?.map((e) => TcpProxy_WeightedCluster_ClusterWeight.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(TcpProxy_WeightedCluster.$type, TcpProxy_WeightedCluster);

function createBaseTcpProxy_WeightedCluster_ClusterWeight(): TcpProxy_WeightedCluster_ClusterWeight {
  return { $type: "envoy.config.filter.network.tcp_proxy.v2.TcpProxy.WeightedCluster.ClusterWeight" };
}

export const TcpProxy_WeightedCluster_ClusterWeight: MessageFns<
  TcpProxy_WeightedCluster_ClusterWeight,
  "envoy.config.filter.network.tcp_proxy.v2.TcpProxy.WeightedCluster.ClusterWeight"
> = {
  $type: "envoy.config.filter.network.tcp_proxy.v2.TcpProxy.WeightedCluster.ClusterWeight" as const,

  encode(message: TcpProxy_WeightedCluster_ClusterWeight, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.weight !== undefined && message.weight !== 0) {
      writer.uint32(16).uint32(message.weight);
    }
    if (message.metadata_match !== undefined) {
      Metadata.encode(message.metadata_match, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TcpProxy_WeightedCluster_ClusterWeight {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTcpProxy_WeightedCluster_ClusterWeight();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.weight = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata_match = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TcpProxy_WeightedCluster_ClusterWeight {
    return {
      $type: TcpProxy_WeightedCluster_ClusterWeight.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      weight: isSet(object.weight) ? globalThis.Number(object.weight) : undefined,
      metadata_match: isSet(object.metadata_match) ? Metadata.fromJSON(object.metadata_match) : undefined,
    };
  },

  toJSON(message: TcpProxy_WeightedCluster_ClusterWeight): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.weight !== undefined) {
      obj.weight = Math.round(message.weight);
    }
    if (message.metadata_match !== undefined) {
      obj.metadata_match = Metadata.toJSON(message.metadata_match);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TcpProxy_WeightedCluster_ClusterWeight>, I>>(
    base?: I,
  ): TcpProxy_WeightedCluster_ClusterWeight {
    return TcpProxy_WeightedCluster_ClusterWeight.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TcpProxy_WeightedCluster_ClusterWeight>, I>>(
    object: I,
  ): TcpProxy_WeightedCluster_ClusterWeight {
    const message = createBaseTcpProxy_WeightedCluster_ClusterWeight();
    message.name = object.name ?? undefined;
    message.weight = object.weight ?? undefined;
    message.metadata_match = (object.metadata_match !== undefined && object.metadata_match !== null)
      ? Metadata.fromPartial(object.metadata_match)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(TcpProxy_WeightedCluster_ClusterWeight.$type, TcpProxy_WeightedCluster_ClusterWeight);

function createBaseTcpProxy_TunnelingConfig(): TcpProxy_TunnelingConfig {
  return { $type: "envoy.config.filter.network.tcp_proxy.v2.TcpProxy.TunnelingConfig" };
}

export const TcpProxy_TunnelingConfig: MessageFns<
  TcpProxy_TunnelingConfig,
  "envoy.config.filter.network.tcp_proxy.v2.TcpProxy.TunnelingConfig"
> = {
  $type: "envoy.config.filter.network.tcp_proxy.v2.TcpProxy.TunnelingConfig" as const,

  encode(message: TcpProxy_TunnelingConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hostname !== undefined && message.hostname !== "") {
      writer.uint32(10).string(message.hostname);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TcpProxy_TunnelingConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTcpProxy_TunnelingConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hostname = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TcpProxy_TunnelingConfig {
    return {
      $type: TcpProxy_TunnelingConfig.$type,
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : undefined,
    };
  },

  toJSON(message: TcpProxy_TunnelingConfig): unknown {
    const obj: any = {};
    if (message.hostname !== undefined) {
      obj.hostname = message.hostname;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TcpProxy_TunnelingConfig>, I>>(base?: I): TcpProxy_TunnelingConfig {
    return TcpProxy_TunnelingConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TcpProxy_TunnelingConfig>, I>>(object: I): TcpProxy_TunnelingConfig {
    const message = createBaseTcpProxy_TunnelingConfig();
    message.hostname = object.hostname ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(TcpProxy_TunnelingConfig.$type, TcpProxy_TunnelingConfig);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
