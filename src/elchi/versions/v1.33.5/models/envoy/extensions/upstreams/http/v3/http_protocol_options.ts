// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/upstreams/http/v3/http_protocol_options.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { messageTypeRegistry } from "../../../../../typeRegistry";
import { TypedExtensionConfig } from "../../../../config/core/v3/extension";
import {
  AlternateProtocolsCacheOptions,
  Http1ProtocolOptions,
  Http2ProtocolOptions,
  Http3ProtocolOptions,
  HttpProtocolOptions as HttpProtocolOptions1,
  UpstreamHttpProtocolOptions,
} from "../../../../config/core/v3/protocol";
import { HttpFilter } from "../../../filters/network/http_connection_manager/v3/http_connection_manager";

export const protobufPackage = "envoy.extensions.upstreams.http.v3";

/**
 * HttpProtocolOptions specifies Http upstream protocol options. This object
 * is used in
 * :ref:`typed_extension_protocol_options<envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`,
 * keyed by the name ``envoy.extensions.upstreams.http.v3.HttpProtocolOptions``.
 *
 * This controls what protocol(s) should be used for upstream and how said protocol(s) are configured.
 *
 * This replaces the prior pattern of explicit protocol configuration directly
 * in the cluster. So a configuration like this, explicitly configuring the use of HTTP/2 upstream:
 *
 * .. code::
 *
 *   clusters:
 *     - name: some_service
 *       connect_timeout: 5s
 *       upstream_http_protocol_options:
 *         auto_sni: true
 *       common_http_protocol_options:
 *         idle_timeout: 1s
 *       http2_protocol_options:
 *         max_concurrent_streams: 100
 *        .... [further cluster config]
 *
 * Would now look like this:
 *
 * .. code::
 *
 *   clusters:
 *     - name: some_service
 *       connect_timeout: 5s
 *       typed_extension_protocol_options:
 *         envoy.extensions.upstreams.http.v3.HttpProtocolOptions:
 *           "@type": type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions
 *           upstream_http_protocol_options:
 *             auto_sni: true
 *           common_http_protocol_options:
 *             idle_timeout: 1s
 *           explicit_http_config:
 *             http2_protocol_options:
 *               max_concurrent_streams: 100
 *        .... [further cluster config]
 * [#next-free-field: 8]
 */
export interface HttpProtocolOptions {
  $type: "envoy.extensions.upstreams.http.v3.HttpProtocolOptions";
  /** This contains options common across HTTP/1 and HTTP/2 */
  common_http_protocol_options?:
    | HttpProtocolOptions1
    | undefined;
  /** This contains common protocol options which are only applied upstream. */
  upstream_http_protocol_options?:
    | UpstreamHttpProtocolOptions
    | undefined;
  /** This controls the actual protocol to be used upstream. */
  upstream_protocol_options?:
    | //
    /**
     * To explicitly configure either HTTP/1 or HTTP/2 (but not both!) use ``explicit_http_config``.
     * If the ``explicit_http_config`` is empty, HTTP/1.1 is used.
     */
    { $case: "explicit_http_config"; explicit_http_config: HttpProtocolOptions_ExplicitHttpConfig }
    | //
    /**
     * This allows switching on protocol based on what protocol the downstream
     * connection used.
     */
    {
      $case: "use_downstream_protocol_config";
      use_downstream_protocol_config: HttpProtocolOptions_UseDownstreamHttpConfig;
    }
    | //
    /** This allows switching on protocol based on ALPN */
    { $case: "auto_config"; auto_config: HttpProtocolOptions_AutoHttpConfig }
    | undefined;
  /**
   * .. note::
   *   Upstream HTTP filters are currently in alpha.
   *
   * Optional HTTP filters for the upstream HTTP filter chain.
   *
   * These filters will be applied for all HTTP streams which flow through this
   * cluster. Unlike downstream HTTP filters, they will *not* be applied to terminated CONNECT requests.
   *
   * If using upstream HTTP filters, please be aware that local errors sent by
   * upstream HTTP filters will not trigger retries, and local errors sent by
   * upstream HTTP filters will count as a final response if hedging is configured.
   * [#extension-category: envoy.filters.http.upstream]
   */
  http_filters?:
    | HttpFilter[]
    | undefined;
  /**
   * Configuration options for Unified Header Validation (UHV).
   * UHV is an extensible mechanism for checking validity of HTTP responses.
   *
   * [#comment:TODO(yanavlasov): Make it a link to the default header validator doc when it becomes visible.]
   * Leaving this field unspecified, selects the default header validator ``envoy.http.header_validators.envoy_default``.
   *
   * [#not-implemented-hide:]
   * [#extension-category: envoy.http.header_validators]
   */
  header_validation_config?: TypedExtensionConfig | undefined;
}

/**
 * If this is used, the cluster will only operate on one of the possible upstream protocols.
 * Note that HTTP/2 or above should generally be used for upstream gRPC clusters.
 */
export interface HttpProtocolOptions_ExplicitHttpConfig {
  $type: "envoy.extensions.upstreams.http.v3.HttpProtocolOptions.ExplicitHttpConfig";
  protocol_config?:
    | //
    { $case: "http_protocol_options"; http_protocol_options: Http1ProtocolOptions }
    | //
    { $case: "http2_protocol_options"; http2_protocol_options: Http2ProtocolOptions }
    | //
    /**
     * .. warning::
     *   QUIC upstream support is currently not ready for internet use.
     *   Please see :ref:`here <arch_overview_http3>` for details.
     */
    { $case: "http3_protocol_options"; http3_protocol_options: Http3ProtocolOptions }
    | undefined;
}

/**
 * If this is used, the cluster can use either of the configured protocols, and
 * will use whichever protocol was used by the downstream connection.
 *
 * If HTTP/3 is configured for downstream and not configured for upstream,
 * HTTP/3 requests will fail over to HTTP/2.
 */
export interface HttpProtocolOptions_UseDownstreamHttpConfig {
  $type: "envoy.extensions.upstreams.http.v3.HttpProtocolOptions.UseDownstreamHttpConfig";
  http_protocol_options?: Http1ProtocolOptions | undefined;
  http2_protocol_options?:
    | Http2ProtocolOptions
    | undefined;
  /**
   * .. warning::
   *   QUIC upstream support is currently not ready for internet use.
   *   Please see :ref:`here <arch_overview_http3>` for details.
   */
  http3_protocol_options?: Http3ProtocolOptions | undefined;
}

/**
 * If this is used, the cluster can use either HTTP/1 or HTTP/2, and will use whichever
 * protocol is negotiated by ALPN with the upstream.
 * Clusters configured with ``AutoHttpConfig`` will use the highest available
 * protocol; HTTP/2 if supported, otherwise HTTP/1.
 * If the upstream does not support ALPN, ``AutoHttpConfig`` will fail over to HTTP/1.
 * This can only be used with transport sockets which support ALPN. Using a
 * transport socket which does not support ALPN will result in configuration
 * failure. The transport layer may be configured with custom ALPN, but the default ALPN
 * for the cluster (or if custom ALPN fails) will be "h2,http/1.1".
 */
export interface HttpProtocolOptions_AutoHttpConfig {
  $type: "envoy.extensions.upstreams.http.v3.HttpProtocolOptions.AutoHttpConfig";
  http_protocol_options?: Http1ProtocolOptions | undefined;
  http2_protocol_options?:
    | Http2ProtocolOptions
    | undefined;
  /**
   * Unlike HTTP/1 and HTTP/2, HTTP/3 will not be configured unless it is
   * present, and (soon) only if there is an indication of server side
   * support.
   * See :ref:`here <arch_overview_http3_upstream>` for more information on
   * when HTTP/3 will be used, and when Envoy will fail over to TCP.
   *
   * .. warning::
   *   QUIC upstream support is currently not ready for internet use.
   *   Please see :ref:`here <arch_overview_http3>` for details.
   */
  http3_protocol_options?:
    | Http3ProtocolOptions
    | undefined;
  /**
   * The presence of alternate protocols cache options causes the use of the
   * alternate protocols cache, which is responsible for parsing and caching
   * HTTP Alt-Svc headers. This enables the use of HTTP/3 for origins that
   * advertise supporting it.
   *
   * .. note::
   *   This is required when HTTP/3 is enabled.
   */
  alternate_protocols_cache_options?: AlternateProtocolsCacheOptions | undefined;
}

function createBaseHttpProtocolOptions(): HttpProtocolOptions {
  return { $type: "envoy.extensions.upstreams.http.v3.HttpProtocolOptions", upstream_protocol_options: undefined };
}

export const HttpProtocolOptions: MessageFns<
  HttpProtocolOptions,
  "envoy.extensions.upstreams.http.v3.HttpProtocolOptions"
> = {
  $type: "envoy.extensions.upstreams.http.v3.HttpProtocolOptions" as const,

  encode(message: HttpProtocolOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common_http_protocol_options !== undefined) {
      HttpProtocolOptions1.encode(message.common_http_protocol_options, writer.uint32(10).fork()).join();
    }
    if (message.upstream_http_protocol_options !== undefined) {
      UpstreamHttpProtocolOptions.encode(message.upstream_http_protocol_options, writer.uint32(18).fork()).join();
    }
    switch (message.upstream_protocol_options?.$case) {
      case "explicit_http_config":
        HttpProtocolOptions_ExplicitHttpConfig.encode(
          message.upstream_protocol_options.explicit_http_config,
          writer.uint32(26).fork(),
        ).join();
        break;
      case "use_downstream_protocol_config":
        HttpProtocolOptions_UseDownstreamHttpConfig.encode(
          message.upstream_protocol_options.use_downstream_protocol_config,
          writer.uint32(34).fork(),
        ).join();
        break;
      case "auto_config":
        HttpProtocolOptions_AutoHttpConfig.encode(
          message.upstream_protocol_options.auto_config,
          writer.uint32(42).fork(),
        ).join();
        break;
    }
    if (message.http_filters !== undefined && message.http_filters.length !== 0) {
      for (const v of message.http_filters) {
        HttpFilter.encode(v!, writer.uint32(50).fork()).join();
      }
    }
    if (message.header_validation_config !== undefined) {
      TypedExtensionConfig.encode(message.header_validation_config, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpProtocolOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpProtocolOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common_http_protocol_options = HttpProtocolOptions1.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.upstream_http_protocol_options = UpstreamHttpProtocolOptions.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.upstream_protocol_options = {
            $case: "explicit_http_config",
            explicit_http_config: HttpProtocolOptions_ExplicitHttpConfig.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.upstream_protocol_options = {
            $case: "use_downstream_protocol_config",
            use_downstream_protocol_config: HttpProtocolOptions_UseDownstreamHttpConfig.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.upstream_protocol_options = {
            $case: "auto_config",
            auto_config: HttpProtocolOptions_AutoHttpConfig.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          if (message.http_filters === undefined) {
            message.http_filters = [];
          }
          const el = HttpFilter.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.http_filters!.push(el);
          }
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.header_validation_config = TypedExtensionConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpProtocolOptions {
    return {
      $type: HttpProtocolOptions.$type,
      common_http_protocol_options: isSet(object.common_http_protocol_options)
        ? HttpProtocolOptions1.fromJSON(object.common_http_protocol_options)
        : undefined,
      upstream_http_protocol_options: isSet(object.upstream_http_protocol_options)
        ? UpstreamHttpProtocolOptions.fromJSON(object.upstream_http_protocol_options)
        : undefined,
      upstream_protocol_options: isSet(object.explicit_http_config)
        ? {
          $case: "explicit_http_config",
          explicit_http_config: HttpProtocolOptions_ExplicitHttpConfig.fromJSON(object.explicit_http_config),
        }
        : isSet(object.use_downstream_protocol_config)
        ? {
          $case: "use_downstream_protocol_config",
          use_downstream_protocol_config: HttpProtocolOptions_UseDownstreamHttpConfig.fromJSON(
            object.use_downstream_protocol_config,
          ),
        }
        : isSet(object.auto_config)
        ? { $case: "auto_config", auto_config: HttpProtocolOptions_AutoHttpConfig.fromJSON(object.auto_config) }
        : undefined,
      http_filters: globalThis.Array.isArray(object?.http_filters)
        ? object.http_filters.map((e: any) => HttpFilter.fromJSON(e))
        : undefined,
      header_validation_config: isSet(object.header_validation_config)
        ? TypedExtensionConfig.fromJSON(object.header_validation_config)
        : undefined,
    };
  },

  toJSON(message: HttpProtocolOptions): unknown {
    const obj: any = {};
    if (message.common_http_protocol_options !== undefined) {
      obj.common_http_protocol_options = HttpProtocolOptions1.toJSON(message.common_http_protocol_options);
    }
    if (message.upstream_http_protocol_options !== undefined) {
      obj.upstream_http_protocol_options = UpstreamHttpProtocolOptions.toJSON(message.upstream_http_protocol_options);
    }
    if (message.upstream_protocol_options?.$case === "explicit_http_config") {
      obj.explicit_http_config = HttpProtocolOptions_ExplicitHttpConfig.toJSON(
        message.upstream_protocol_options.explicit_http_config,
      );
    }
    if (message.upstream_protocol_options?.$case === "use_downstream_protocol_config") {
      obj.use_downstream_protocol_config = HttpProtocolOptions_UseDownstreamHttpConfig.toJSON(
        message.upstream_protocol_options.use_downstream_protocol_config,
      );
    }
    if (message.upstream_protocol_options?.$case === "auto_config") {
      obj.auto_config = HttpProtocolOptions_AutoHttpConfig.toJSON(message.upstream_protocol_options.auto_config);
    }
    if (message.http_filters?.length) {
      obj.http_filters = message.http_filters.map((e) => HttpFilter.toJSON(e));
    }
    if (message.header_validation_config !== undefined) {
      obj.header_validation_config = TypedExtensionConfig.toJSON(message.header_validation_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpProtocolOptions>, I>>(base?: I): HttpProtocolOptions {
    return HttpProtocolOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpProtocolOptions>, I>>(object: I): HttpProtocolOptions {
    const message = createBaseHttpProtocolOptions();
    message.common_http_protocol_options =
      (object.common_http_protocol_options !== undefined && object.common_http_protocol_options !== null)
        ? HttpProtocolOptions1.fromPartial(object.common_http_protocol_options)
        : undefined;
    message.upstream_http_protocol_options =
      (object.upstream_http_protocol_options !== undefined && object.upstream_http_protocol_options !== null)
        ? UpstreamHttpProtocolOptions.fromPartial(object.upstream_http_protocol_options)
        : undefined;
    if (
      object.upstream_protocol_options?.$case === "explicit_http_config" &&
      object.upstream_protocol_options?.explicit_http_config !== undefined &&
      object.upstream_protocol_options?.explicit_http_config !== null
    ) {
      message.upstream_protocol_options = {
        $case: "explicit_http_config",
        explicit_http_config: HttpProtocolOptions_ExplicitHttpConfig.fromPartial(
          object.upstream_protocol_options.explicit_http_config,
        ),
      };
    }
    if (
      object.upstream_protocol_options?.$case === "use_downstream_protocol_config" &&
      object.upstream_protocol_options?.use_downstream_protocol_config !== undefined &&
      object.upstream_protocol_options?.use_downstream_protocol_config !== null
    ) {
      message.upstream_protocol_options = {
        $case: "use_downstream_protocol_config",
        use_downstream_protocol_config: HttpProtocolOptions_UseDownstreamHttpConfig.fromPartial(
          object.upstream_protocol_options.use_downstream_protocol_config,
        ),
      };
    }
    if (
      object.upstream_protocol_options?.$case === "auto_config" &&
      object.upstream_protocol_options?.auto_config !== undefined &&
      object.upstream_protocol_options?.auto_config !== null
    ) {
      message.upstream_protocol_options = {
        $case: "auto_config",
        auto_config: HttpProtocolOptions_AutoHttpConfig.fromPartial(object.upstream_protocol_options.auto_config),
      };
    }
    message.http_filters = object.http_filters?.map((e) => HttpFilter.fromPartial(e)) || undefined;
    message.header_validation_config =
      (object.header_validation_config !== undefined && object.header_validation_config !== null)
        ? TypedExtensionConfig.fromPartial(object.header_validation_config)
        : undefined;
    return message;
  },
};

messageTypeRegistry.set(HttpProtocolOptions.$type, HttpProtocolOptions);

function createBaseHttpProtocolOptions_ExplicitHttpConfig(): HttpProtocolOptions_ExplicitHttpConfig {
  return {
    $type: "envoy.extensions.upstreams.http.v3.HttpProtocolOptions.ExplicitHttpConfig",
    protocol_config: undefined,
  };
}

export const HttpProtocolOptions_ExplicitHttpConfig: MessageFns<
  HttpProtocolOptions_ExplicitHttpConfig,
  "envoy.extensions.upstreams.http.v3.HttpProtocolOptions.ExplicitHttpConfig"
> = {
  $type: "envoy.extensions.upstreams.http.v3.HttpProtocolOptions.ExplicitHttpConfig" as const,

  encode(message: HttpProtocolOptions_ExplicitHttpConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.protocol_config?.$case) {
      case "http_protocol_options":
        Http1ProtocolOptions.encode(message.protocol_config.http_protocol_options, writer.uint32(10).fork()).join();
        break;
      case "http2_protocol_options":
        Http2ProtocolOptions.encode(message.protocol_config.http2_protocol_options, writer.uint32(18).fork()).join();
        break;
      case "http3_protocol_options":
        Http3ProtocolOptions.encode(message.protocol_config.http3_protocol_options, writer.uint32(26).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpProtocolOptions_ExplicitHttpConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpProtocolOptions_ExplicitHttpConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.protocol_config = {
            $case: "http_protocol_options",
            http_protocol_options: Http1ProtocolOptions.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.protocol_config = {
            $case: "http2_protocol_options",
            http2_protocol_options: Http2ProtocolOptions.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.protocol_config = {
            $case: "http3_protocol_options",
            http3_protocol_options: Http3ProtocolOptions.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpProtocolOptions_ExplicitHttpConfig {
    return {
      $type: HttpProtocolOptions_ExplicitHttpConfig.$type,
      protocol_config: isSet(object.http_protocol_options)
        ? {
          $case: "http_protocol_options",
          http_protocol_options: Http1ProtocolOptions.fromJSON(object.http_protocol_options),
        }
        : isSet(object.http2_protocol_options)
        ? {
          $case: "http2_protocol_options",
          http2_protocol_options: Http2ProtocolOptions.fromJSON(object.http2_protocol_options),
        }
        : isSet(object.http3_protocol_options)
        ? {
          $case: "http3_protocol_options",
          http3_protocol_options: Http3ProtocolOptions.fromJSON(object.http3_protocol_options),
        }
        : undefined,
    };
  },

  toJSON(message: HttpProtocolOptions_ExplicitHttpConfig): unknown {
    const obj: any = {};
    if (message.protocol_config?.$case === "http_protocol_options") {
      obj.http_protocol_options = Http1ProtocolOptions.toJSON(message.protocol_config.http_protocol_options);
    }
    if (message.protocol_config?.$case === "http2_protocol_options") {
      obj.http2_protocol_options = Http2ProtocolOptions.toJSON(message.protocol_config.http2_protocol_options);
    }
    if (message.protocol_config?.$case === "http3_protocol_options") {
      obj.http3_protocol_options = Http3ProtocolOptions.toJSON(message.protocol_config.http3_protocol_options);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpProtocolOptions_ExplicitHttpConfig>, I>>(
    base?: I,
  ): HttpProtocolOptions_ExplicitHttpConfig {
    return HttpProtocolOptions_ExplicitHttpConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpProtocolOptions_ExplicitHttpConfig>, I>>(
    object: I,
  ): HttpProtocolOptions_ExplicitHttpConfig {
    const message = createBaseHttpProtocolOptions_ExplicitHttpConfig();
    if (
      object.protocol_config?.$case === "http_protocol_options" &&
      object.protocol_config?.http_protocol_options !== undefined &&
      object.protocol_config?.http_protocol_options !== null
    ) {
      message.protocol_config = {
        $case: "http_protocol_options",
        http_protocol_options: Http1ProtocolOptions.fromPartial(object.protocol_config.http_protocol_options),
      };
    }
    if (
      object.protocol_config?.$case === "http2_protocol_options" &&
      object.protocol_config?.http2_protocol_options !== undefined &&
      object.protocol_config?.http2_protocol_options !== null
    ) {
      message.protocol_config = {
        $case: "http2_protocol_options",
        http2_protocol_options: Http2ProtocolOptions.fromPartial(object.protocol_config.http2_protocol_options),
      };
    }
    if (
      object.protocol_config?.$case === "http3_protocol_options" &&
      object.protocol_config?.http3_protocol_options !== undefined &&
      object.protocol_config?.http3_protocol_options !== null
    ) {
      message.protocol_config = {
        $case: "http3_protocol_options",
        http3_protocol_options: Http3ProtocolOptions.fromPartial(object.protocol_config.http3_protocol_options),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(HttpProtocolOptions_ExplicitHttpConfig.$type, HttpProtocolOptions_ExplicitHttpConfig);

function createBaseHttpProtocolOptions_UseDownstreamHttpConfig(): HttpProtocolOptions_UseDownstreamHttpConfig {
  return { $type: "envoy.extensions.upstreams.http.v3.HttpProtocolOptions.UseDownstreamHttpConfig" };
}

export const HttpProtocolOptions_UseDownstreamHttpConfig: MessageFns<
  HttpProtocolOptions_UseDownstreamHttpConfig,
  "envoy.extensions.upstreams.http.v3.HttpProtocolOptions.UseDownstreamHttpConfig"
> = {
  $type: "envoy.extensions.upstreams.http.v3.HttpProtocolOptions.UseDownstreamHttpConfig" as const,

  encode(
    message: HttpProtocolOptions_UseDownstreamHttpConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.http_protocol_options !== undefined) {
      Http1ProtocolOptions.encode(message.http_protocol_options, writer.uint32(10).fork()).join();
    }
    if (message.http2_protocol_options !== undefined) {
      Http2ProtocolOptions.encode(message.http2_protocol_options, writer.uint32(18).fork()).join();
    }
    if (message.http3_protocol_options !== undefined) {
      Http3ProtocolOptions.encode(message.http3_protocol_options, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpProtocolOptions_UseDownstreamHttpConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpProtocolOptions_UseDownstreamHttpConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.http_protocol_options = Http1ProtocolOptions.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.http2_protocol_options = Http2ProtocolOptions.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.http3_protocol_options = Http3ProtocolOptions.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpProtocolOptions_UseDownstreamHttpConfig {
    return {
      $type: HttpProtocolOptions_UseDownstreamHttpConfig.$type,
      http_protocol_options: isSet(object.http_protocol_options)
        ? Http1ProtocolOptions.fromJSON(object.http_protocol_options)
        : undefined,
      http2_protocol_options: isSet(object.http2_protocol_options)
        ? Http2ProtocolOptions.fromJSON(object.http2_protocol_options)
        : undefined,
      http3_protocol_options: isSet(object.http3_protocol_options)
        ? Http3ProtocolOptions.fromJSON(object.http3_protocol_options)
        : undefined,
    };
  },

  toJSON(message: HttpProtocolOptions_UseDownstreamHttpConfig): unknown {
    const obj: any = {};
    if (message.http_protocol_options !== undefined) {
      obj.http_protocol_options = Http1ProtocolOptions.toJSON(message.http_protocol_options);
    }
    if (message.http2_protocol_options !== undefined) {
      obj.http2_protocol_options = Http2ProtocolOptions.toJSON(message.http2_protocol_options);
    }
    if (message.http3_protocol_options !== undefined) {
      obj.http3_protocol_options = Http3ProtocolOptions.toJSON(message.http3_protocol_options);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpProtocolOptions_UseDownstreamHttpConfig>, I>>(
    base?: I,
  ): HttpProtocolOptions_UseDownstreamHttpConfig {
    return HttpProtocolOptions_UseDownstreamHttpConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpProtocolOptions_UseDownstreamHttpConfig>, I>>(
    object: I,
  ): HttpProtocolOptions_UseDownstreamHttpConfig {
    const message = createBaseHttpProtocolOptions_UseDownstreamHttpConfig();
    message.http_protocol_options =
      (object.http_protocol_options !== undefined && object.http_protocol_options !== null)
        ? Http1ProtocolOptions.fromPartial(object.http_protocol_options)
        : undefined;
    message.http2_protocol_options =
      (object.http2_protocol_options !== undefined && object.http2_protocol_options !== null)
        ? Http2ProtocolOptions.fromPartial(object.http2_protocol_options)
        : undefined;
    message.http3_protocol_options =
      (object.http3_protocol_options !== undefined && object.http3_protocol_options !== null)
        ? Http3ProtocolOptions.fromPartial(object.http3_protocol_options)
        : undefined;
    return message;
  },
};

messageTypeRegistry.set(HttpProtocolOptions_UseDownstreamHttpConfig.$type, HttpProtocolOptions_UseDownstreamHttpConfig);

function createBaseHttpProtocolOptions_AutoHttpConfig(): HttpProtocolOptions_AutoHttpConfig {
  return { $type: "envoy.extensions.upstreams.http.v3.HttpProtocolOptions.AutoHttpConfig" };
}

export const HttpProtocolOptions_AutoHttpConfig: MessageFns<
  HttpProtocolOptions_AutoHttpConfig,
  "envoy.extensions.upstreams.http.v3.HttpProtocolOptions.AutoHttpConfig"
> = {
  $type: "envoy.extensions.upstreams.http.v3.HttpProtocolOptions.AutoHttpConfig" as const,

  encode(message: HttpProtocolOptions_AutoHttpConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.http_protocol_options !== undefined) {
      Http1ProtocolOptions.encode(message.http_protocol_options, writer.uint32(10).fork()).join();
    }
    if (message.http2_protocol_options !== undefined) {
      Http2ProtocolOptions.encode(message.http2_protocol_options, writer.uint32(18).fork()).join();
    }
    if (message.http3_protocol_options !== undefined) {
      Http3ProtocolOptions.encode(message.http3_protocol_options, writer.uint32(26).fork()).join();
    }
    if (message.alternate_protocols_cache_options !== undefined) {
      AlternateProtocolsCacheOptions.encode(message.alternate_protocols_cache_options, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpProtocolOptions_AutoHttpConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpProtocolOptions_AutoHttpConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.http_protocol_options = Http1ProtocolOptions.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.http2_protocol_options = Http2ProtocolOptions.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.http3_protocol_options = Http3ProtocolOptions.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.alternate_protocols_cache_options = AlternateProtocolsCacheOptions.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpProtocolOptions_AutoHttpConfig {
    return {
      $type: HttpProtocolOptions_AutoHttpConfig.$type,
      http_protocol_options: isSet(object.http_protocol_options)
        ? Http1ProtocolOptions.fromJSON(object.http_protocol_options)
        : undefined,
      http2_protocol_options: isSet(object.http2_protocol_options)
        ? Http2ProtocolOptions.fromJSON(object.http2_protocol_options)
        : undefined,
      http3_protocol_options: isSet(object.http3_protocol_options)
        ? Http3ProtocolOptions.fromJSON(object.http3_protocol_options)
        : undefined,
      alternate_protocols_cache_options: isSet(object.alternate_protocols_cache_options)
        ? AlternateProtocolsCacheOptions.fromJSON(object.alternate_protocols_cache_options)
        : undefined,
    };
  },

  toJSON(message: HttpProtocolOptions_AutoHttpConfig): unknown {
    const obj: any = {};
    if (message.http_protocol_options !== undefined) {
      obj.http_protocol_options = Http1ProtocolOptions.toJSON(message.http_protocol_options);
    }
    if (message.http2_protocol_options !== undefined) {
      obj.http2_protocol_options = Http2ProtocolOptions.toJSON(message.http2_protocol_options);
    }
    if (message.http3_protocol_options !== undefined) {
      obj.http3_protocol_options = Http3ProtocolOptions.toJSON(message.http3_protocol_options);
    }
    if (message.alternate_protocols_cache_options !== undefined) {
      obj.alternate_protocols_cache_options = AlternateProtocolsCacheOptions.toJSON(
        message.alternate_protocols_cache_options,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpProtocolOptions_AutoHttpConfig>, I>>(
    base?: I,
  ): HttpProtocolOptions_AutoHttpConfig {
    return HttpProtocolOptions_AutoHttpConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpProtocolOptions_AutoHttpConfig>, I>>(
    object: I,
  ): HttpProtocolOptions_AutoHttpConfig {
    const message = createBaseHttpProtocolOptions_AutoHttpConfig();
    message.http_protocol_options =
      (object.http_protocol_options !== undefined && object.http_protocol_options !== null)
        ? Http1ProtocolOptions.fromPartial(object.http_protocol_options)
        : undefined;
    message.http2_protocol_options =
      (object.http2_protocol_options !== undefined && object.http2_protocol_options !== null)
        ? Http2ProtocolOptions.fromPartial(object.http2_protocol_options)
        : undefined;
    message.http3_protocol_options =
      (object.http3_protocol_options !== undefined && object.http3_protocol_options !== null)
        ? Http3ProtocolOptions.fromPartial(object.http3_protocol_options)
        : undefined;
    message.alternate_protocols_cache_options =
      (object.alternate_protocols_cache_options !== undefined && object.alternate_protocols_cache_options !== null)
        ? AlternateProtocolsCacheOptions.fromPartial(object.alternate_protocols_cache_options)
        : undefined;
    return message;
  },
};

messageTypeRegistry.set(HttpProtocolOptions_AutoHttpConfig.$type, HttpProtocolOptions_AutoHttpConfig);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
