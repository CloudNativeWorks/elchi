// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/filters/network/generic_proxy/matcher/v3/matcher.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { messageTypeRegistry } from "../../../../../../../typeRegistry";
import { StringMatcher } from "../../../../../../type/matcher/v3/string";

export const protobufPackage = "envoy.extensions.filters.network.generic_proxy.matcher.v3";

/**
 * Used to match request service of the downstream request. Only applicable if a service provided
 * by the application protocol.
 * This is deprecated and should be replaced by HostMatchInput. This is kept for backward compatibility.
 */
export interface ServiceMatchInput {
  $type: "envoy.extensions.filters.network.generic_proxy.matcher.v3.ServiceMatchInput";
}

/**
 * Used to match request host of the generic downstream request. Only applicable if a host provided
 * by the application protocol.
 * This is same with the ServiceMatchInput and this should be preferred over ServiceMatchInput.
 */
export interface HostMatchInput {
  $type: "envoy.extensions.filters.network.generic_proxy.matcher.v3.HostMatchInput";
}

/**
 * Used to match request path of the generic downstream request. Only applicable if a path provided
 * by the application protocol.
 */
export interface PathMatchInput {
  $type: "envoy.extensions.filters.network.generic_proxy.matcher.v3.PathMatchInput";
}

/**
 * Used to match request method of the generic downstream request. Only applicable if a method provided
 * by the application protocol.
 */
export interface MethodMatchInput {
  $type: "envoy.extensions.filters.network.generic_proxy.matcher.v3.MethodMatchInput";
}

/**
 * Used to match an arbitrary property of the generic downstream request.
 * These properties are populated by the codecs of application protocols.
 */
export interface PropertyMatchInput {
  $type: "envoy.extensions.filters.network.generic_proxy.matcher.v3.PropertyMatchInput";
  /** The property name to match on. */
  property_name?: string | undefined;
}

/** Used to match an whole generic downstream request. */
export interface RequestMatchInput {
  $type: "envoy.extensions.filters.network.generic_proxy.matcher.v3.RequestMatchInput";
}

/** Used to match an arbitrary key-value pair for headers, trailers or properties. */
export interface KeyValueMatchEntry {
  $type: "envoy.extensions.filters.network.generic_proxy.matcher.v3.KeyValueMatchEntry";
  /** The key name to match on. */
  name?:
    | string
    | undefined;
  /** The key value pattern. */
  string_match?: StringMatcher | undefined;
}

/**
 * Custom matcher to match on the generic downstream request. This is used to match
 * multiple fields of the downstream request and avoid complex combinations of
 * HostMatchInput, PathMatchInput, MethodMatchInput and PropertyMatchInput.
 */
export interface RequestMatcher {
  $type: "envoy.extensions.filters.network.generic_proxy.matcher.v3.RequestMatcher";
  /** Optional host pattern to match on. If not specified, any host will match. */
  host?:
    | StringMatcher
    | undefined;
  /** Optional path pattern to match on. If not specified, any path will match. */
  path?:
    | StringMatcher
    | undefined;
  /** Optional method pattern to match on. If not specified, any method will match. */
  method?:
    | StringMatcher
    | undefined;
  /**
   * Optional arbitrary properties to match on. If not specified, any properties
   * will match. The key is the property name and the value is the property value
   * to match on.
   */
  properties?: KeyValueMatchEntry[] | undefined;
}

function createBaseServiceMatchInput(): ServiceMatchInput {
  return { $type: "envoy.extensions.filters.network.generic_proxy.matcher.v3.ServiceMatchInput" };
}

export const ServiceMatchInput: MessageFns<
  ServiceMatchInput,
  "envoy.extensions.filters.network.generic_proxy.matcher.v3.ServiceMatchInput"
> = {
  $type: "envoy.extensions.filters.network.generic_proxy.matcher.v3.ServiceMatchInput" as const,

  encode(_: ServiceMatchInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceMatchInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceMatchInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ServiceMatchInput {
    return { $type: ServiceMatchInput.$type };
  },

  toJSON(_: ServiceMatchInput): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ServiceMatchInput>, I>>(base?: I): ServiceMatchInput {
    return ServiceMatchInput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServiceMatchInput>, I>>(_: I): ServiceMatchInput {
    const message = createBaseServiceMatchInput();
    return message;
  },
};

messageTypeRegistry.set(ServiceMatchInput.$type, ServiceMatchInput);

function createBaseHostMatchInput(): HostMatchInput {
  return { $type: "envoy.extensions.filters.network.generic_proxy.matcher.v3.HostMatchInput" };
}

export const HostMatchInput: MessageFns<
  HostMatchInput,
  "envoy.extensions.filters.network.generic_proxy.matcher.v3.HostMatchInput"
> = {
  $type: "envoy.extensions.filters.network.generic_proxy.matcher.v3.HostMatchInput" as const,

  encode(_: HostMatchInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HostMatchInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHostMatchInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): HostMatchInput {
    return { $type: HostMatchInput.$type };
  },

  toJSON(_: HostMatchInput): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<HostMatchInput>, I>>(base?: I): HostMatchInput {
    return HostMatchInput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HostMatchInput>, I>>(_: I): HostMatchInput {
    const message = createBaseHostMatchInput();
    return message;
  },
};

messageTypeRegistry.set(HostMatchInput.$type, HostMatchInput);

function createBasePathMatchInput(): PathMatchInput {
  return { $type: "envoy.extensions.filters.network.generic_proxy.matcher.v3.PathMatchInput" };
}

export const PathMatchInput: MessageFns<
  PathMatchInput,
  "envoy.extensions.filters.network.generic_proxy.matcher.v3.PathMatchInput"
> = {
  $type: "envoy.extensions.filters.network.generic_proxy.matcher.v3.PathMatchInput" as const,

  encode(_: PathMatchInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PathMatchInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePathMatchInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PathMatchInput {
    return { $type: PathMatchInput.$type };
  },

  toJSON(_: PathMatchInput): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<PathMatchInput>, I>>(base?: I): PathMatchInput {
    return PathMatchInput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PathMatchInput>, I>>(_: I): PathMatchInput {
    const message = createBasePathMatchInput();
    return message;
  },
};

messageTypeRegistry.set(PathMatchInput.$type, PathMatchInput);

function createBaseMethodMatchInput(): MethodMatchInput {
  return { $type: "envoy.extensions.filters.network.generic_proxy.matcher.v3.MethodMatchInput" };
}

export const MethodMatchInput: MessageFns<
  MethodMatchInput,
  "envoy.extensions.filters.network.generic_proxy.matcher.v3.MethodMatchInput"
> = {
  $type: "envoy.extensions.filters.network.generic_proxy.matcher.v3.MethodMatchInput" as const,

  encode(_: MethodMatchInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MethodMatchInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMethodMatchInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MethodMatchInput {
    return { $type: MethodMatchInput.$type };
  },

  toJSON(_: MethodMatchInput): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MethodMatchInput>, I>>(base?: I): MethodMatchInput {
    return MethodMatchInput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MethodMatchInput>, I>>(_: I): MethodMatchInput {
    const message = createBaseMethodMatchInput();
    return message;
  },
};

messageTypeRegistry.set(MethodMatchInput.$type, MethodMatchInput);

function createBasePropertyMatchInput(): PropertyMatchInput {
  return { $type: "envoy.extensions.filters.network.generic_proxy.matcher.v3.PropertyMatchInput" };
}

export const PropertyMatchInput: MessageFns<
  PropertyMatchInput,
  "envoy.extensions.filters.network.generic_proxy.matcher.v3.PropertyMatchInput"
> = {
  $type: "envoy.extensions.filters.network.generic_proxy.matcher.v3.PropertyMatchInput" as const,

  encode(message: PropertyMatchInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.property_name !== undefined && message.property_name !== "") {
      writer.uint32(10).string(message.property_name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PropertyMatchInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePropertyMatchInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.property_name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PropertyMatchInput {
    return {
      $type: PropertyMatchInput.$type,
      property_name: isSet(object.property_name) ? globalThis.String(object.property_name) : undefined,
    };
  },

  toJSON(message: PropertyMatchInput): unknown {
    const obj: any = {};
    if (message.property_name !== undefined) {
      obj.property_name = message.property_name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PropertyMatchInput>, I>>(base?: I): PropertyMatchInput {
    return PropertyMatchInput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PropertyMatchInput>, I>>(object: I): PropertyMatchInput {
    const message = createBasePropertyMatchInput();
    message.property_name = object.property_name ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(PropertyMatchInput.$type, PropertyMatchInput);

function createBaseRequestMatchInput(): RequestMatchInput {
  return { $type: "envoy.extensions.filters.network.generic_proxy.matcher.v3.RequestMatchInput" };
}

export const RequestMatchInput: MessageFns<
  RequestMatchInput,
  "envoy.extensions.filters.network.generic_proxy.matcher.v3.RequestMatchInput"
> = {
  $type: "envoy.extensions.filters.network.generic_proxy.matcher.v3.RequestMatchInput" as const,

  encode(_: RequestMatchInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestMatchInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestMatchInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RequestMatchInput {
    return { $type: RequestMatchInput.$type };
  },

  toJSON(_: RequestMatchInput): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestMatchInput>, I>>(base?: I): RequestMatchInput {
    return RequestMatchInput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestMatchInput>, I>>(_: I): RequestMatchInput {
    const message = createBaseRequestMatchInput();
    return message;
  },
};

messageTypeRegistry.set(RequestMatchInput.$type, RequestMatchInput);

function createBaseKeyValueMatchEntry(): KeyValueMatchEntry {
  return { $type: "envoy.extensions.filters.network.generic_proxy.matcher.v3.KeyValueMatchEntry" };
}

export const KeyValueMatchEntry: MessageFns<
  KeyValueMatchEntry,
  "envoy.extensions.filters.network.generic_proxy.matcher.v3.KeyValueMatchEntry"
> = {
  $type: "envoy.extensions.filters.network.generic_proxy.matcher.v3.KeyValueMatchEntry" as const,

  encode(message: KeyValueMatchEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.string_match !== undefined) {
      StringMatcher.encode(message.string_match, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyValueMatchEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyValueMatchEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.string_match = StringMatcher.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyValueMatchEntry {
    return {
      $type: KeyValueMatchEntry.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      string_match: isSet(object.string_match) ? StringMatcher.fromJSON(object.string_match) : undefined,
    };
  },

  toJSON(message: KeyValueMatchEntry): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.string_match !== undefined) {
      obj.string_match = StringMatcher.toJSON(message.string_match);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KeyValueMatchEntry>, I>>(base?: I): KeyValueMatchEntry {
    return KeyValueMatchEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KeyValueMatchEntry>, I>>(object: I): KeyValueMatchEntry {
    const message = createBaseKeyValueMatchEntry();
    message.name = object.name ?? undefined;
    message.string_match = (object.string_match !== undefined && object.string_match !== null)
      ? StringMatcher.fromPartial(object.string_match)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(KeyValueMatchEntry.$type, KeyValueMatchEntry);

function createBaseRequestMatcher(): RequestMatcher {
  return { $type: "envoy.extensions.filters.network.generic_proxy.matcher.v3.RequestMatcher" };
}

export const RequestMatcher: MessageFns<
  RequestMatcher,
  "envoy.extensions.filters.network.generic_proxy.matcher.v3.RequestMatcher"
> = {
  $type: "envoy.extensions.filters.network.generic_proxy.matcher.v3.RequestMatcher" as const,

  encode(message: RequestMatcher, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.host !== undefined) {
      StringMatcher.encode(message.host, writer.uint32(10).fork()).join();
    }
    if (message.path !== undefined) {
      StringMatcher.encode(message.path, writer.uint32(18).fork()).join();
    }
    if (message.method !== undefined) {
      StringMatcher.encode(message.method, writer.uint32(26).fork()).join();
    }
    if (message.properties !== undefined && message.properties.length !== 0) {
      for (const v of message.properties) {
        KeyValueMatchEntry.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestMatcher {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestMatcher();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.host = StringMatcher.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.path = StringMatcher.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.method = StringMatcher.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          if (message.properties === undefined) {
            message.properties = [];
          }
          const el = KeyValueMatchEntry.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.properties!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestMatcher {
    return {
      $type: RequestMatcher.$type,
      host: isSet(object.host) ? StringMatcher.fromJSON(object.host) : undefined,
      path: isSet(object.path) ? StringMatcher.fromJSON(object.path) : undefined,
      method: isSet(object.method) ? StringMatcher.fromJSON(object.method) : undefined,
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => KeyValueMatchEntry.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: RequestMatcher): unknown {
    const obj: any = {};
    if (message.host !== undefined) {
      obj.host = StringMatcher.toJSON(message.host);
    }
    if (message.path !== undefined) {
      obj.path = StringMatcher.toJSON(message.path);
    }
    if (message.method !== undefined) {
      obj.method = StringMatcher.toJSON(message.method);
    }
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => KeyValueMatchEntry.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestMatcher>, I>>(base?: I): RequestMatcher {
    return RequestMatcher.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestMatcher>, I>>(object: I): RequestMatcher {
    const message = createBaseRequestMatcher();
    message.host = (object.host !== undefined && object.host !== null)
      ? StringMatcher.fromPartial(object.host)
      : undefined;
    message.path = (object.path !== undefined && object.path !== null)
      ? StringMatcher.fromPartial(object.path)
      : undefined;
    message.method = (object.method !== undefined && object.method !== null)
      ? StringMatcher.fromPartial(object.method)
      : undefined;
    message.properties = object.properties?.map((e) => KeyValueMatchEntry.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(RequestMatcher.$type, RequestMatcher);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
