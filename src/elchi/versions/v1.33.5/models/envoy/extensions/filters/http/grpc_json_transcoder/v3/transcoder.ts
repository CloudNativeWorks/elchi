// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/filters/http/grpc_json_transcoder/v3/transcoder.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { UInt32Value } from "../../../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../../../typeRegistry";

export const protobufPackage = "envoy.extensions.filters.http.grpc_json_transcoder.v3";

/**
 * [#next-free-field: 18]
 * GrpcJsonTranscoder filter configuration.
 * The filter itself can be used per route / per virtual host or on the general level. The most
 * specific one is being used for a given route. If the list of services is empty - filter
 * is considered to be disabled.
 * Note that if specifying the filter per route, first the route is matched, and then transcoding
 * filter is applied. It matters when specifying the route configuration and paths to match the
 * request - for per-route grpc transcoder configs, the original path should be matched, while
 * in other cases, the grpc-like path is expected (the one AFTER the filter is applied).
 */
export interface GrpcJsonTranscoder {
  $type: "envoy.extensions.filters.http.grpc_json_transcoder.v3.GrpcJsonTranscoder";
  descriptor_set?:
    | //
    /**
     * Supplies the filename of
     * :ref:`the proto descriptor set <config_grpc_json_generate_proto_descriptor_set>` for the gRPC
     * services.
     */
    { $case: "proto_descriptor"; proto_descriptor: string }
    | //
    /**
     * Supplies the binary content of
     * :ref:`the proto descriptor set <config_grpc_json_generate_proto_descriptor_set>` for the gRPC
     * services.
     */
    { $case: "proto_descriptor_bin"; proto_descriptor_bin: Uint8Array }
    | undefined;
  /**
   * A list of strings that
   * supplies the fully qualified service names (i.e. "package_name.service_name") that
   * the transcoder will translate. If the service name doesn't exist in ``proto_descriptor``,
   * Envoy will fail at startup. The ``proto_descriptor`` may contain more services than
   * the service names specified here, but they won't be translated.
   *
   * By default, the filter will pass through requests that do not map to any specified services.
   * If the list of services is empty, filter is considered disabled.
   * However, this behavior changes if
   * :ref:`reject_unknown_method <envoy_v3_api_field_extensions.filters.http.grpc_json_transcoder.v3.GrpcJsonTranscoder.RequestValidationOptions.reject_unknown_method>`
   * is enabled.
   */
  services?:
    | string[]
    | undefined;
  /**
   * Control options for response JSON. These options are passed directly to
   * `JsonPrintOptions <https://developers.google.com/protocol-buffers/docs/reference/cpp/
   * google.protobuf.util.json_util#JsonPrintOptions>`_.
   */
  print_options?:
    | GrpcJsonTranscoder_PrintOptions
    | undefined;
  /**
   * Whether to keep the incoming request route after the outgoing headers have been transformed to
   * the match the upstream gRPC service. Note: This means that routes for gRPC services that are
   * not transcoded cannot be used in combination with ``match_incoming_request_route``.
   */
  match_incoming_request_route?:
    | boolean
    | undefined;
  /**
   * A list of query parameters to be ignored for transcoding method mapping.
   * By default, the transcoder filter will not transcode a request if there are any
   * unknown/invalid query parameters.
   *
   * Example :
   *
   * .. code-block:: proto
   *
   *     service Bookstore {
   *       rpc GetShelf(GetShelfRequest) returns (Shelf) {
   *         option (google.api.http) = {
   *           get: "/shelves/{shelf}"
   *         };
   *       }
   *     }
   *
   *     message GetShelfRequest {
   *       int64 shelf = 1;
   *     }
   *
   *     message Shelf {}
   *
   * The request ``/shelves/100?foo=bar`` will not be mapped to ``GetShelf``` because variable
   * binding for ``foo`` is not defined. Adding ``foo`` to ``ignored_query_parameters`` will allow
   * the same request to be mapped to ``GetShelf``.
   */
  ignored_query_parameters?:
    | string[]
    | undefined;
  /**
   * Whether to route methods without the ``google.api.http`` option.
   *
   * Example :
   *
   * .. code-block:: proto
   *
   *     package bookstore;
   *
   *     service Bookstore {
   *       rpc GetShelf(GetShelfRequest) returns (Shelf) {}
   *     }
   *
   *     message GetShelfRequest {
   *       int64 shelf = 1;
   *     }
   *
   *     message Shelf {}
   *
   * The client could ``post`` a json body ``{"shelf": 1234}`` with the path of
   * ``/bookstore.Bookstore/GetShelfRequest`` to call ``GetShelfRequest``.
   */
  auto_mapping?:
    | boolean
    | undefined;
  /**
   * Whether to ignore query parameters that cannot be mapped to a corresponding
   * protobuf field. Use this if you cannot control the query parameters and do
   * not know them beforehand. Otherwise use ``ignored_query_parameters``.
   * Defaults to false.
   */
  ignore_unknown_query_parameters?:
    | boolean
    | undefined;
  /**
   * Whether to convert gRPC status headers to JSON.
   * When trailer indicates a gRPC error and there was no HTTP body, take ``google.rpc.Status``
   * from the ``grpc-status-details-bin`` header and use it as JSON body.
   * If there was no such header, make ``google.rpc.Status`` out of the ``grpc-status`` and
   * ``grpc-message`` headers.
   * The error details types must be present in the ``proto_descriptor``.
   *
   * For example, if an upstream server replies with headers:
   *
   * .. code-block:: none
   *
   *     grpc-status: 5
   *     grpc-status-details-bin:
   *         CAUaMwoqdHlwZS5nb29nbGVhcGlzLmNvbS9nb29nbGUucnBjLlJlcXVlc3RJbmZvEgUKA3ItMQ
   *
   * The ``grpc-status-details-bin`` header contains a base64-encoded protobuf message
   * ``google.rpc.Status``. It will be transcoded into:
   *
   * .. code-block:: none
   *
   *     HTTP/1.1 404 Not Found
   *     content-type: application/json
   *
   *     {"code":5,"details":[{"@type":"type.googleapis.com/google.rpc.RequestInfo","requestId":"r-1"}]}
   *
   * In order to transcode the message, the ``google.rpc.RequestInfo`` type from
   * the ``google/rpc/error_details.proto`` should be included in the configured
   * :ref:`proto descriptor set <config_grpc_json_generate_proto_descriptor_set>`.
   */
  convert_grpc_status?:
    | boolean
    | undefined;
  /**
   * URL unescaping policy.
   * This spec is only applied when extracting variable with multiple segments in the URL path.
   * For example, in case of ``/foo/{x=*}/bar/{y=prefix/*}/{z=**}`` ``x`` variable is single segment and ``y`` and ``z`` are multiple segments.
   * For a path with ``/foo/first/bar/prefix/second/third/fourth``, ``x=first``, ``y=prefix/second``, ``z=third/fourth``.
   * If this setting is not specified, the value defaults to :ref:`ALL_CHARACTERS_EXCEPT_RESERVED<envoy_v3_api_enum_value_extensions.filters.http.grpc_json_transcoder.v3.GrpcJsonTranscoder.UrlUnescapeSpec.ALL_CHARACTERS_EXCEPT_RESERVED>`.
   */
  url_unescape_spec?:
    | GrpcJsonTranscoder_UrlUnescapeSpec
    | undefined;
  /**
   * If true, unescape '+' to space when extracting variables in query parameters.
   * This is to support `HTML 2.0 <https://tools.ietf.org/html/rfc1866#section-8.2.1>`_
   */
  query_param_unescape_plus?:
    | boolean
    | undefined;
  /**
   * If true, try to match the custom verb even if it is unregistered. By
   * default, only match when it is registered.
   *
   * According to the http template `syntax <https://github.com/googleapis/googleapis/blob/master/google/api/http.proto#L226-L231>`_,
   * the custom verb is **":" LITERAL** at the end of http template.
   *
   * For a request with ``/foo/bar:baz`` and ``:baz`` is not registered in any url_template, here is the behavior change
   * - if the field is not set, ``:baz`` will not be treated as custom verb, so it will match ``/foo/{x=*}``.
   * - if the field is set, ``:baz`` is treated as custom verb,  so it will NOT match ``/foo/{x=*}`` since the template doesn't use any custom verb.
   */
  match_unregistered_custom_verb?:
    | boolean
    | undefined;
  /**
   * Configure the behavior when handling requests that cannot be transcoded.
   *
   * By default, the transcoder will silently pass through HTTP requests that are malformed.
   * This includes requests with unknown query parameters, unregister paths, etc.
   *
   * Set these options to enable strict HTTP request validation, resulting in the transcoder rejecting
   * such requests with a ``HTTP 4xx``. See each individual option for more details on the validation.
   * gRPC requests will still silently pass through without transcoding.
   *
   * The benefit is a proper error message to the downstream.
   * If the upstream is a gRPC server, it cannot handle the passed-through HTTP requests and will reset
   * the TCP connection. The downstream will then
   * receive a ``HTTP 503 Service Unavailable`` due to the upstream connection reset.
   * This incorrect error message may conflict with other Envoy components, such as retry policies.
   */
  request_validation_options?:
    | GrpcJsonTranscoder_RequestValidationOptions
    | undefined;
  /**
   * Proto enum values are supposed to be in upper cases when used in JSON.
   * Set this to true if your JSON request uses non uppercase enum values.
   */
  case_insensitive_enum_parsing?:
    | boolean
    | undefined;
  /**
   * The maximum size of a request body to be transcoded, in bytes. A body exceeding this size will
   * provoke a ``HTTP 413 Request Entity Too Large`` response.
   *
   * Large values may cause envoy to use a lot of memory if there are many concurrent requests.
   *
   * If unset, the current stream buffer size is used.
   */
  max_request_body_size?:
    | number
    | undefined;
  /**
   * The maximum size of a response body to be transcoded, in bytes. A body exceeding this size will
   * provoke a ``HTTP 500 Internal Server Error`` response.
   *
   * Large values may cause envoy to use a lot of memory if there are many concurrent requests.
   *
   * If unset, the current stream buffer size is used.
   */
  max_response_body_size?:
    | number
    | undefined;
  /**
   * If true, query parameters that cannot be mapped to a corresponding
   * protobuf field are captured in an HttpBody extension of UnknownQueryParams.
   */
  capture_unknown_query_parameters?: boolean | undefined;
}

export enum GrpcJsonTranscoder_UrlUnescapeSpec {
  /**
   * ALL_CHARACTERS_EXCEPT_RESERVED - URL path parameters will not decode RFC 6570 reserved characters.
   * For example, segment ``%2f%23/%20%2523`` is unescaped to ``%2f%23/ %23``.
   */
  ALL_CHARACTERS_EXCEPT_RESERVED = "ALL_CHARACTERS_EXCEPT_RESERVED",
  /**
   * ALL_CHARACTERS_EXCEPT_SLASH - URL path parameters will be fully URI-decoded except in
   * cases of single segment matches in reserved expansion, where ``%2F`` will be
   * left encoded.
   * For example, segment ``%2f%23/%20%2523`` is unescaped to ``%2f#/ %23``.
   */
  ALL_CHARACTERS_EXCEPT_SLASH = "ALL_CHARACTERS_EXCEPT_SLASH",
  /**
   * ALL_CHARACTERS - URL path parameters will be fully URI-decoded.
   * For example, segment ``%2f%23/%20%2523`` is unescaped to ``/#/ %23``.
   */
  ALL_CHARACTERS = "ALL_CHARACTERS",
}

export function grpcJsonTranscoder_UrlUnescapeSpecFromJSON(object: any): GrpcJsonTranscoder_UrlUnescapeSpec {
  switch (object) {
    case 0:
    case "ALL_CHARACTERS_EXCEPT_RESERVED":
      return GrpcJsonTranscoder_UrlUnescapeSpec.ALL_CHARACTERS_EXCEPT_RESERVED;
    case 1:
    case "ALL_CHARACTERS_EXCEPT_SLASH":
      return GrpcJsonTranscoder_UrlUnescapeSpec.ALL_CHARACTERS_EXCEPT_SLASH;
    case 2:
    case "ALL_CHARACTERS":
      return GrpcJsonTranscoder_UrlUnescapeSpec.ALL_CHARACTERS;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum GrpcJsonTranscoder_UrlUnescapeSpec");
  }
}

export function grpcJsonTranscoder_UrlUnescapeSpecToJSON(object: GrpcJsonTranscoder_UrlUnescapeSpec): string {
  switch (object) {
    case GrpcJsonTranscoder_UrlUnescapeSpec.ALL_CHARACTERS_EXCEPT_RESERVED:
      return "ALL_CHARACTERS_EXCEPT_RESERVED";
    case GrpcJsonTranscoder_UrlUnescapeSpec.ALL_CHARACTERS_EXCEPT_SLASH:
      return "ALL_CHARACTERS_EXCEPT_SLASH";
    case GrpcJsonTranscoder_UrlUnescapeSpec.ALL_CHARACTERS:
      return "ALL_CHARACTERS";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum GrpcJsonTranscoder_UrlUnescapeSpec");
  }
}

export function grpcJsonTranscoder_UrlUnescapeSpecToNumber(object: GrpcJsonTranscoder_UrlUnescapeSpec): number {
  switch (object) {
    case GrpcJsonTranscoder_UrlUnescapeSpec.ALL_CHARACTERS_EXCEPT_RESERVED:
      return 0;
    case GrpcJsonTranscoder_UrlUnescapeSpec.ALL_CHARACTERS_EXCEPT_SLASH:
      return 1;
    case GrpcJsonTranscoder_UrlUnescapeSpec.ALL_CHARACTERS:
      return 2;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum GrpcJsonTranscoder_UrlUnescapeSpec");
  }
}

/** [#next-free-field: 6] */
export interface GrpcJsonTranscoder_PrintOptions {
  $type: "envoy.extensions.filters.http.grpc_json_transcoder.v3.GrpcJsonTranscoder.PrintOptions";
  /**
   * Whether to add spaces, line breaks and indentation to make the JSON
   * output easy to read. Defaults to false.
   */
  add_whitespace?:
    | boolean
    | undefined;
  /**
   * Whether to always print primitive fields. By default primitive
   * fields with default values will be omitted in JSON output. For
   * example, an int32 field set to 0 will be omitted. Setting this flag to
   * true will override the default behavior and print primitive fields
   * regardless of their values. Defaults to false.
   */
  always_print_primitive_fields?:
    | boolean
    | undefined;
  /**
   * Whether to always print enums as ints. By default they are rendered
   * as strings. Defaults to false.
   */
  always_print_enums_as_ints?:
    | boolean
    | undefined;
  /**
   * Whether to preserve proto field names. By default protobuf will
   * generate JSON field names using the ``json_name`` option, or lower camel case,
   * in that order. Setting this flag will preserve the original field names. Defaults to false.
   */
  preserve_proto_field_names?:
    | boolean
    | undefined;
  /** If true, return all streams as newline-delimited JSON messages instead of as a comma-separated array */
  stream_newline_delimited?: boolean | undefined;
}

export interface GrpcJsonTranscoder_RequestValidationOptions {
  $type: "envoy.extensions.filters.http.grpc_json_transcoder.v3.GrpcJsonTranscoder.RequestValidationOptions";
  /**
   * By default, a request that cannot be mapped to any specified gRPC
   * :ref:`services <envoy_v3_api_field_extensions.filters.http.grpc_json_transcoder.v3.GrpcJsonTranscoder.services>`
   * will pass-through this filter.
   * When set to true, the request will be rejected with a ``HTTP 404 Not Found``.
   */
  reject_unknown_method?:
    | boolean
    | undefined;
  /**
   * By default, a request with query parameters that cannot be mapped to the gRPC request message
   * will pass-through this filter.
   * When set to true, the request will be rejected with a ``HTTP 400 Bad Request``.
   *
   * The fields
   * :ref:`ignore_unknown_query_parameters <envoy_v3_api_field_extensions.filters.http.grpc_json_transcoder.v3.GrpcJsonTranscoder.ignore_unknown_query_parameters>`,
   * :ref:`capture_unknown_query_parameters <envoy_v3_api_field_extensions.filters.http.grpc_json_transcoder.v3.GrpcJsonTranscoder.capture_unknown_query_parameters>`,
   * and
   * :ref:`ignored_query_parameters <envoy_v3_api_field_extensions.filters.http.grpc_json_transcoder.v3.GrpcJsonTranscoder.ignored_query_parameters>`
   * have priority over this strict validation behavior.
   */
  reject_unknown_query_parameters?:
    | boolean
    | undefined;
  /**
   * "id: 456" in the body will override "id=123" in the binding.
   *
   * If this field is set to true, the request will be rejected if the binding
   * value is different from the body value.
   */
  reject_binding_body_field_collisions?: boolean | undefined;
}

/**
 * ``UnknownQueryParams`` is added as an extension field in ``HttpBody`` if
 * ``GrpcJsonTranscoder::capture_unknown_query_parameters`` is true and unknown query
 * parameters were present in the request.
 */
export interface UnknownQueryParams {
  $type: "envoy.extensions.filters.http.grpc_json_transcoder.v3.UnknownQueryParams";
  /** A map from unrecognized query parameter keys, to the values associated with those keys. */
  key?: Map<string, UnknownQueryParams_Values> | undefined;
}

export interface UnknownQueryParams_Values {
  $type: "envoy.extensions.filters.http.grpc_json_transcoder.v3.UnknownQueryParams.Values";
  values?: string[] | undefined;
}

export interface UnknownQueryParams_KeyEntry {
  $type: "envoy.extensions.filters.http.grpc_json_transcoder.v3.UnknownQueryParams.KeyEntry";
  key: string;
  value?: UnknownQueryParams_Values | undefined;
}

function createBaseGrpcJsonTranscoder(): GrpcJsonTranscoder {
  return {
    $type: "envoy.extensions.filters.http.grpc_json_transcoder.v3.GrpcJsonTranscoder",
    descriptor_set: undefined,
  };
}

export const GrpcJsonTranscoder: MessageFns<
  GrpcJsonTranscoder,
  "envoy.extensions.filters.http.grpc_json_transcoder.v3.GrpcJsonTranscoder"
> = {
  $type: "envoy.extensions.filters.http.grpc_json_transcoder.v3.GrpcJsonTranscoder" as const,

  encode(message: GrpcJsonTranscoder, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.descriptor_set?.$case) {
      case "proto_descriptor":
        writer.uint32(10).string(message.descriptor_set.proto_descriptor);
        break;
      case "proto_descriptor_bin":
        writer.uint32(34).bytes(message.descriptor_set.proto_descriptor_bin);
        break;
    }
    if (message.services !== undefined && message.services.length !== 0) {
      for (const v of message.services) {
        writer.uint32(18).string(v!);
      }
    }
    if (message.print_options !== undefined) {
      GrpcJsonTranscoder_PrintOptions.encode(message.print_options, writer.uint32(26).fork()).join();
    }
    if (message.match_incoming_request_route !== undefined && message.match_incoming_request_route !== false) {
      writer.uint32(40).bool(message.match_incoming_request_route);
    }
    if (message.ignored_query_parameters !== undefined && message.ignored_query_parameters.length !== 0) {
      for (const v of message.ignored_query_parameters) {
        writer.uint32(50).string(v!);
      }
    }
    if (message.auto_mapping !== undefined && message.auto_mapping !== false) {
      writer.uint32(56).bool(message.auto_mapping);
    }
    if (message.ignore_unknown_query_parameters !== undefined && message.ignore_unknown_query_parameters !== false) {
      writer.uint32(64).bool(message.ignore_unknown_query_parameters);
    }
    if (message.convert_grpc_status !== undefined && message.convert_grpc_status !== false) {
      writer.uint32(72).bool(message.convert_grpc_status);
    }
    if (
      message.url_unescape_spec !== undefined &&
      message.url_unescape_spec !== GrpcJsonTranscoder_UrlUnescapeSpec.ALL_CHARACTERS_EXCEPT_RESERVED
    ) {
      writer.uint32(80).int32(grpcJsonTranscoder_UrlUnescapeSpecToNumber(message.url_unescape_spec));
    }
    if (message.query_param_unescape_plus !== undefined && message.query_param_unescape_plus !== false) {
      writer.uint32(96).bool(message.query_param_unescape_plus);
    }
    if (message.match_unregistered_custom_verb !== undefined && message.match_unregistered_custom_verb !== false) {
      writer.uint32(104).bool(message.match_unregistered_custom_verb);
    }
    if (message.request_validation_options !== undefined) {
      GrpcJsonTranscoder_RequestValidationOptions.encode(message.request_validation_options, writer.uint32(90).fork())
        .join();
    }
    if (message.case_insensitive_enum_parsing !== undefined && message.case_insensitive_enum_parsing !== false) {
      writer.uint32(112).bool(message.case_insensitive_enum_parsing);
    }
    if (message.max_request_body_size !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.max_request_body_size! },
        writer.uint32(122).fork(),
      ).join();
    }
    if (message.max_response_body_size !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.max_response_body_size! },
        writer.uint32(130).fork(),
      ).join();
    }
    if (message.capture_unknown_query_parameters !== undefined && message.capture_unknown_query_parameters !== false) {
      writer.uint32(136).bool(message.capture_unknown_query_parameters);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrpcJsonTranscoder {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrpcJsonTranscoder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.descriptor_set = { $case: "proto_descriptor", proto_descriptor: reader.string() };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.descriptor_set = { $case: "proto_descriptor_bin", proto_descriptor_bin: reader.bytes() };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.services === undefined) {
            message.services = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.services!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.print_options = GrpcJsonTranscoder_PrintOptions.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.match_incoming_request_route = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          if (message.ignored_query_parameters === undefined) {
            message.ignored_query_parameters = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.ignored_query_parameters!.push(el);
          }
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.auto_mapping = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.ignore_unknown_query_parameters = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.convert_grpc_status = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.url_unescape_spec = grpcJsonTranscoder_UrlUnescapeSpecFromJSON(reader.int32());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.query_param_unescape_plus = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.match_unregistered_custom_verb = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.request_validation_options = GrpcJsonTranscoder_RequestValidationOptions.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.case_insensitive_enum_parsing = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.max_request_body_size = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.max_response_body_size = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.capture_unknown_query_parameters = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrpcJsonTranscoder {
    return {
      $type: GrpcJsonTranscoder.$type,
      descriptor_set: isSet(object.proto_descriptor)
        ? { $case: "proto_descriptor", proto_descriptor: globalThis.String(object.proto_descriptor) }
        : isSet(object.proto_descriptor_bin)
        ? { $case: "proto_descriptor_bin", proto_descriptor_bin: bytesFromBase64(object.proto_descriptor_bin) }
        : undefined,
      services: globalThis.Array.isArray(object?.services)
        ? object.services.map((e: any) => globalThis.String(e))
        : undefined,
      print_options: isSet(object.print_options)
        ? GrpcJsonTranscoder_PrintOptions.fromJSON(object.print_options)
        : undefined,
      match_incoming_request_route: isSet(object.match_incoming_request_route)
        ? globalThis.Boolean(object.match_incoming_request_route)
        : undefined,
      ignored_query_parameters: globalThis.Array.isArray(object?.ignored_query_parameters)
        ? object.ignored_query_parameters.map((e: any) => globalThis.String(e))
        : undefined,
      auto_mapping: isSet(object.auto_mapping) ? globalThis.Boolean(object.auto_mapping) : undefined,
      ignore_unknown_query_parameters: isSet(object.ignore_unknown_query_parameters)
        ? globalThis.Boolean(object.ignore_unknown_query_parameters)
        : undefined,
      convert_grpc_status: isSet(object.convert_grpc_status)
        ? globalThis.Boolean(object.convert_grpc_status)
        : undefined,
      url_unescape_spec: isSet(object.url_unescape_spec)
        ? grpcJsonTranscoder_UrlUnescapeSpecFromJSON(object.url_unescape_spec)
        : undefined,
      query_param_unescape_plus: isSet(object.query_param_unescape_plus)
        ? globalThis.Boolean(object.query_param_unescape_plus)
        : undefined,
      match_unregistered_custom_verb: isSet(object.match_unregistered_custom_verb)
        ? globalThis.Boolean(object.match_unregistered_custom_verb)
        : undefined,
      request_validation_options: isSet(object.request_validation_options)
        ? GrpcJsonTranscoder_RequestValidationOptions.fromJSON(object.request_validation_options)
        : undefined,
      case_insensitive_enum_parsing: isSet(object.case_insensitive_enum_parsing)
        ? globalThis.Boolean(object.case_insensitive_enum_parsing)
        : undefined,
      max_request_body_size: isSet(object.max_request_body_size) ? Number(object.max_request_body_size) : undefined,
      max_response_body_size: isSet(object.max_response_body_size) ? Number(object.max_response_body_size) : undefined,
      capture_unknown_query_parameters: isSet(object.capture_unknown_query_parameters)
        ? globalThis.Boolean(object.capture_unknown_query_parameters)
        : undefined,
    };
  },

  toJSON(message: GrpcJsonTranscoder): unknown {
    const obj: any = {};
    if (message.descriptor_set?.$case === "proto_descriptor") {
      obj.proto_descriptor = message.descriptor_set.proto_descriptor;
    }
    if (message.descriptor_set?.$case === "proto_descriptor_bin") {
      obj.proto_descriptor_bin = base64FromBytes(message.descriptor_set.proto_descriptor_bin);
    }
    if (message.services?.length) {
      obj.services = message.services;
    }
    if (message.print_options !== undefined) {
      obj.print_options = GrpcJsonTranscoder_PrintOptions.toJSON(message.print_options);
    }
    if (message.match_incoming_request_route !== undefined) {
      obj.match_incoming_request_route = message.match_incoming_request_route;
    }
    if (message.ignored_query_parameters?.length) {
      obj.ignored_query_parameters = message.ignored_query_parameters;
    }
    if (message.auto_mapping !== undefined) {
      obj.auto_mapping = message.auto_mapping;
    }
    if (message.ignore_unknown_query_parameters !== undefined) {
      obj.ignore_unknown_query_parameters = message.ignore_unknown_query_parameters;
    }
    if (message.convert_grpc_status !== undefined) {
      obj.convert_grpc_status = message.convert_grpc_status;
    }
    if (message.url_unescape_spec !== undefined) {
      obj.url_unescape_spec = grpcJsonTranscoder_UrlUnescapeSpecToJSON(message.url_unescape_spec);
    }
    if (message.query_param_unescape_plus !== undefined) {
      obj.query_param_unescape_plus = message.query_param_unescape_plus;
    }
    if (message.match_unregistered_custom_verb !== undefined) {
      obj.match_unregistered_custom_verb = message.match_unregistered_custom_verb;
    }
    if (message.request_validation_options !== undefined) {
      obj.request_validation_options = GrpcJsonTranscoder_RequestValidationOptions.toJSON(
        message.request_validation_options,
      );
    }
    if (message.case_insensitive_enum_parsing !== undefined) {
      obj.case_insensitive_enum_parsing = message.case_insensitive_enum_parsing;
    }
    if (message.max_request_body_size !== undefined) {
      obj.max_request_body_size = message.max_request_body_size;
    }
    if (message.max_response_body_size !== undefined) {
      obj.max_response_body_size = message.max_response_body_size;
    }
    if (message.capture_unknown_query_parameters !== undefined) {
      obj.capture_unknown_query_parameters = message.capture_unknown_query_parameters;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GrpcJsonTranscoder>, I>>(base?: I): GrpcJsonTranscoder {
    return GrpcJsonTranscoder.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GrpcJsonTranscoder>, I>>(object: I): GrpcJsonTranscoder {
    const message = createBaseGrpcJsonTranscoder();
    if (
      object.descriptor_set?.$case === "proto_descriptor" &&
      object.descriptor_set?.proto_descriptor !== undefined &&
      object.descriptor_set?.proto_descriptor !== null
    ) {
      message.descriptor_set = { $case: "proto_descriptor", proto_descriptor: object.descriptor_set.proto_descriptor };
    }
    if (
      object.descriptor_set?.$case === "proto_descriptor_bin" &&
      object.descriptor_set?.proto_descriptor_bin !== undefined &&
      object.descriptor_set?.proto_descriptor_bin !== null
    ) {
      message.descriptor_set = {
        $case: "proto_descriptor_bin",
        proto_descriptor_bin: object.descriptor_set.proto_descriptor_bin,
      };
    }
    message.services = object.services?.map((e) => e) || undefined;
    message.print_options = (object.print_options !== undefined && object.print_options !== null)
      ? GrpcJsonTranscoder_PrintOptions.fromPartial(object.print_options)
      : undefined;
    message.match_incoming_request_route = object.match_incoming_request_route ?? undefined;
    message.ignored_query_parameters = object.ignored_query_parameters?.map((e) => e) || undefined;
    message.auto_mapping = object.auto_mapping ?? undefined;
    message.ignore_unknown_query_parameters = object.ignore_unknown_query_parameters ?? undefined;
    message.convert_grpc_status = object.convert_grpc_status ?? undefined;
    message.url_unescape_spec = object.url_unescape_spec ?? undefined;
    message.query_param_unescape_plus = object.query_param_unescape_plus ?? undefined;
    message.match_unregistered_custom_verb = object.match_unregistered_custom_verb ?? undefined;
    message.request_validation_options =
      (object.request_validation_options !== undefined && object.request_validation_options !== null)
        ? GrpcJsonTranscoder_RequestValidationOptions.fromPartial(object.request_validation_options)
        : undefined;
    message.case_insensitive_enum_parsing = object.case_insensitive_enum_parsing ?? undefined;
    message.max_request_body_size = object.max_request_body_size ?? undefined;
    message.max_response_body_size = object.max_response_body_size ?? undefined;
    message.capture_unknown_query_parameters = object.capture_unknown_query_parameters ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(GrpcJsonTranscoder.$type, GrpcJsonTranscoder);

function createBaseGrpcJsonTranscoder_PrintOptions(): GrpcJsonTranscoder_PrintOptions {
  return { $type: "envoy.extensions.filters.http.grpc_json_transcoder.v3.GrpcJsonTranscoder.PrintOptions" };
}

export const GrpcJsonTranscoder_PrintOptions: MessageFns<
  GrpcJsonTranscoder_PrintOptions,
  "envoy.extensions.filters.http.grpc_json_transcoder.v3.GrpcJsonTranscoder.PrintOptions"
> = {
  $type: "envoy.extensions.filters.http.grpc_json_transcoder.v3.GrpcJsonTranscoder.PrintOptions" as const,

  encode(message: GrpcJsonTranscoder_PrintOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.add_whitespace !== undefined && message.add_whitespace !== false) {
      writer.uint32(8).bool(message.add_whitespace);
    }
    if (message.always_print_primitive_fields !== undefined && message.always_print_primitive_fields !== false) {
      writer.uint32(16).bool(message.always_print_primitive_fields);
    }
    if (message.always_print_enums_as_ints !== undefined && message.always_print_enums_as_ints !== false) {
      writer.uint32(24).bool(message.always_print_enums_as_ints);
    }
    if (message.preserve_proto_field_names !== undefined && message.preserve_proto_field_names !== false) {
      writer.uint32(32).bool(message.preserve_proto_field_names);
    }
    if (message.stream_newline_delimited !== undefined && message.stream_newline_delimited !== false) {
      writer.uint32(40).bool(message.stream_newline_delimited);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrpcJsonTranscoder_PrintOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrpcJsonTranscoder_PrintOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.add_whitespace = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.always_print_primitive_fields = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.always_print_enums_as_ints = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.preserve_proto_field_names = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.stream_newline_delimited = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrpcJsonTranscoder_PrintOptions {
    return {
      $type: GrpcJsonTranscoder_PrintOptions.$type,
      add_whitespace: isSet(object.add_whitespace) ? globalThis.Boolean(object.add_whitespace) : undefined,
      always_print_primitive_fields: isSet(object.always_print_primitive_fields)
        ? globalThis.Boolean(object.always_print_primitive_fields)
        : undefined,
      always_print_enums_as_ints: isSet(object.always_print_enums_as_ints)
        ? globalThis.Boolean(object.always_print_enums_as_ints)
        : undefined,
      preserve_proto_field_names: isSet(object.preserve_proto_field_names)
        ? globalThis.Boolean(object.preserve_proto_field_names)
        : undefined,
      stream_newline_delimited: isSet(object.stream_newline_delimited)
        ? globalThis.Boolean(object.stream_newline_delimited)
        : undefined,
    };
  },

  toJSON(message: GrpcJsonTranscoder_PrintOptions): unknown {
    const obj: any = {};
    if (message.add_whitespace !== undefined) {
      obj.add_whitespace = message.add_whitespace;
    }
    if (message.always_print_primitive_fields !== undefined) {
      obj.always_print_primitive_fields = message.always_print_primitive_fields;
    }
    if (message.always_print_enums_as_ints !== undefined) {
      obj.always_print_enums_as_ints = message.always_print_enums_as_ints;
    }
    if (message.preserve_proto_field_names !== undefined) {
      obj.preserve_proto_field_names = message.preserve_proto_field_names;
    }
    if (message.stream_newline_delimited !== undefined) {
      obj.stream_newline_delimited = message.stream_newline_delimited;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GrpcJsonTranscoder_PrintOptions>, I>>(base?: I): GrpcJsonTranscoder_PrintOptions {
    return GrpcJsonTranscoder_PrintOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GrpcJsonTranscoder_PrintOptions>, I>>(
    object: I,
  ): GrpcJsonTranscoder_PrintOptions {
    const message = createBaseGrpcJsonTranscoder_PrintOptions();
    message.add_whitespace = object.add_whitespace ?? undefined;
    message.always_print_primitive_fields = object.always_print_primitive_fields ?? undefined;
    message.always_print_enums_as_ints = object.always_print_enums_as_ints ?? undefined;
    message.preserve_proto_field_names = object.preserve_proto_field_names ?? undefined;
    message.stream_newline_delimited = object.stream_newline_delimited ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(GrpcJsonTranscoder_PrintOptions.$type, GrpcJsonTranscoder_PrintOptions);

function createBaseGrpcJsonTranscoder_RequestValidationOptions(): GrpcJsonTranscoder_RequestValidationOptions {
  return { $type: "envoy.extensions.filters.http.grpc_json_transcoder.v3.GrpcJsonTranscoder.RequestValidationOptions" };
}

export const GrpcJsonTranscoder_RequestValidationOptions: MessageFns<
  GrpcJsonTranscoder_RequestValidationOptions,
  "envoy.extensions.filters.http.grpc_json_transcoder.v3.GrpcJsonTranscoder.RequestValidationOptions"
> = {
  $type: "envoy.extensions.filters.http.grpc_json_transcoder.v3.GrpcJsonTranscoder.RequestValidationOptions" as const,

  encode(
    message: GrpcJsonTranscoder_RequestValidationOptions,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.reject_unknown_method !== undefined && message.reject_unknown_method !== false) {
      writer.uint32(8).bool(message.reject_unknown_method);
    }
    if (message.reject_unknown_query_parameters !== undefined && message.reject_unknown_query_parameters !== false) {
      writer.uint32(16).bool(message.reject_unknown_query_parameters);
    }
    if (
      message.reject_binding_body_field_collisions !== undefined &&
      message.reject_binding_body_field_collisions !== false
    ) {
      writer.uint32(24).bool(message.reject_binding_body_field_collisions);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrpcJsonTranscoder_RequestValidationOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrpcJsonTranscoder_RequestValidationOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.reject_unknown_method = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.reject_unknown_query_parameters = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.reject_binding_body_field_collisions = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrpcJsonTranscoder_RequestValidationOptions {
    return {
      $type: GrpcJsonTranscoder_RequestValidationOptions.$type,
      reject_unknown_method: isSet(object.reject_unknown_method)
        ? globalThis.Boolean(object.reject_unknown_method)
        : undefined,
      reject_unknown_query_parameters: isSet(object.reject_unknown_query_parameters)
        ? globalThis.Boolean(object.reject_unknown_query_parameters)
        : undefined,
      reject_binding_body_field_collisions: isSet(object.reject_binding_body_field_collisions)
        ? globalThis.Boolean(object.reject_binding_body_field_collisions)
        : undefined,
    };
  },

  toJSON(message: GrpcJsonTranscoder_RequestValidationOptions): unknown {
    const obj: any = {};
    if (message.reject_unknown_method !== undefined) {
      obj.reject_unknown_method = message.reject_unknown_method;
    }
    if (message.reject_unknown_query_parameters !== undefined) {
      obj.reject_unknown_query_parameters = message.reject_unknown_query_parameters;
    }
    if (message.reject_binding_body_field_collisions !== undefined) {
      obj.reject_binding_body_field_collisions = message.reject_binding_body_field_collisions;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GrpcJsonTranscoder_RequestValidationOptions>, I>>(
    base?: I,
  ): GrpcJsonTranscoder_RequestValidationOptions {
    return GrpcJsonTranscoder_RequestValidationOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GrpcJsonTranscoder_RequestValidationOptions>, I>>(
    object: I,
  ): GrpcJsonTranscoder_RequestValidationOptions {
    const message = createBaseGrpcJsonTranscoder_RequestValidationOptions();
    message.reject_unknown_method = object.reject_unknown_method ?? undefined;
    message.reject_unknown_query_parameters = object.reject_unknown_query_parameters ?? undefined;
    message.reject_binding_body_field_collisions = object.reject_binding_body_field_collisions ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(GrpcJsonTranscoder_RequestValidationOptions.$type, GrpcJsonTranscoder_RequestValidationOptions);

function createBaseUnknownQueryParams(): UnknownQueryParams {
  return { $type: "envoy.extensions.filters.http.grpc_json_transcoder.v3.UnknownQueryParams" };
}

export const UnknownQueryParams: MessageFns<
  UnknownQueryParams,
  "envoy.extensions.filters.http.grpc_json_transcoder.v3.UnknownQueryParams"
> = {
  $type: "envoy.extensions.filters.http.grpc_json_transcoder.v3.UnknownQueryParams" as const,

  encode(message: UnknownQueryParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    (message.key || new Map()).forEach((value, key) => {
      UnknownQueryParams_KeyEntry.encode({
        $type: "envoy.extensions.filters.http.grpc_json_transcoder.v3.UnknownQueryParams.KeyEntry",
        key: key as any,
        value,
      }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnknownQueryParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnknownQueryParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = UnknownQueryParams_KeyEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            if (message.key === undefined) {
              message.key = new Map();
            }
            message.key!.set(entry1.key, entry1.value);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnknownQueryParams {
    return {
      $type: UnknownQueryParams.$type,
      key: isObject(object.key)
        ? Object.entries(object.key).reduce<Map<string, UnknownQueryParams_Values>>((acc, [key, value]) => {
          acc.set(key, UnknownQueryParams_Values.fromJSON(value));
          return acc;
        }, new Map())
        : undefined,
    };
  },

  toJSON(message: UnknownQueryParams): unknown {
    const obj: any = {};
    if (message.key?.size) {
      obj.key = {};
      message.key.forEach((v, k) => {
        obj.key[k] = UnknownQueryParams_Values.toJSON(v);
      });
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnknownQueryParams>, I>>(base?: I): UnknownQueryParams {
    return UnknownQueryParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnknownQueryParams>, I>>(object: I): UnknownQueryParams {
    const message = createBaseUnknownQueryParams();
    message.key = (object.key === undefined || object.key === null) ? undefined : (() => {
      const m = new Map();
      (object.key as Map<string, UnknownQueryParams_Values> ?? new Map()).forEach((value, key) => {
        if (value !== undefined) {
          m.set(key, UnknownQueryParams_Values.fromPartial(value));
        }
      });
      return m;
    })();
    return message;
  },
};

messageTypeRegistry.set(UnknownQueryParams.$type, UnknownQueryParams);

function createBaseUnknownQueryParams_Values(): UnknownQueryParams_Values {
  return { $type: "envoy.extensions.filters.http.grpc_json_transcoder.v3.UnknownQueryParams.Values" };
}

export const UnknownQueryParams_Values: MessageFns<
  UnknownQueryParams_Values,
  "envoy.extensions.filters.http.grpc_json_transcoder.v3.UnknownQueryParams.Values"
> = {
  $type: "envoy.extensions.filters.http.grpc_json_transcoder.v3.UnknownQueryParams.Values" as const,

  encode(message: UnknownQueryParams_Values, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.values !== undefined && message.values.length !== 0) {
      for (const v of message.values) {
        writer.uint32(10).string(v!);
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnknownQueryParams_Values {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnknownQueryParams_Values();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.values === undefined) {
            message.values = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.values!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnknownQueryParams_Values {
    return {
      $type: UnknownQueryParams_Values.$type,
      values: globalThis.Array.isArray(object?.values)
        ? object.values.map((e: any) => globalThis.String(e))
        : undefined,
    };
  },

  toJSON(message: UnknownQueryParams_Values): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnknownQueryParams_Values>, I>>(base?: I): UnknownQueryParams_Values {
    return UnknownQueryParams_Values.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnknownQueryParams_Values>, I>>(object: I): UnknownQueryParams_Values {
    const message = createBaseUnknownQueryParams_Values();
    message.values = object.values?.map((e) => e) || undefined;
    return message;
  },
};

messageTypeRegistry.set(UnknownQueryParams_Values.$type, UnknownQueryParams_Values);

function createBaseUnknownQueryParams_KeyEntry(): UnknownQueryParams_KeyEntry {
  return { $type: "envoy.extensions.filters.http.grpc_json_transcoder.v3.UnknownQueryParams.KeyEntry", key: "" };
}

export const UnknownQueryParams_KeyEntry: MessageFns<
  UnknownQueryParams_KeyEntry,
  "envoy.extensions.filters.http.grpc_json_transcoder.v3.UnknownQueryParams.KeyEntry"
> = {
  $type: "envoy.extensions.filters.http.grpc_json_transcoder.v3.UnknownQueryParams.KeyEntry" as const,

  encode(message: UnknownQueryParams_KeyEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      UnknownQueryParams_Values.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnknownQueryParams_KeyEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnknownQueryParams_KeyEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = UnknownQueryParams_Values.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnknownQueryParams_KeyEntry {
    return {
      $type: UnknownQueryParams_KeyEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? UnknownQueryParams_Values.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: UnknownQueryParams_KeyEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = UnknownQueryParams_Values.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnknownQueryParams_KeyEntry>, I>>(base?: I): UnknownQueryParams_KeyEntry {
    return UnknownQueryParams_KeyEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnknownQueryParams_KeyEntry>, I>>(object: I): UnknownQueryParams_KeyEntry {
    const message = createBaseUnknownQueryParams_KeyEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? UnknownQueryParams_Values.fromPartial(object.value)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(UnknownQueryParams_KeyEntry.$type, UnknownQueryParams_KeyEntry);

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
