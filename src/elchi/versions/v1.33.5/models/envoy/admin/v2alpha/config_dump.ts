// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/admin/v2alpha/config_dump.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Any } from "../../../google/protobuf/any";
import { Timestamp } from "../../../google/protobuf/timestamp";
import { messageTypeRegistry } from "../../../typeRegistry";
import { Bootstrap } from "../../config/bootstrap/v2/bootstrap";

export const protobufPackage = "envoy.admin.v2alpha";

/**
 * The :ref:`/config_dump <operations_admin_interface_config_dump>` admin endpoint uses this wrapper
 * message to maintain and serve arbitrary configuration information from any component in Envoy.
 */
export interface ConfigDump {
  $type: "envoy.admin.v2alpha.ConfigDump";
  /**
   * This list is serialized and dumped in its entirety at the
   * :ref:`/config_dump <operations_admin_interface_config_dump>` endpoint.
   *
   * The following configurations are currently supported and will be dumped in the order given
   * below:
   *
   * * *bootstrap*: :ref:`BootstrapConfigDump <envoy_api_msg_admin.v2alpha.BootstrapConfigDump>`
   * * *clusters*: :ref:`ClustersConfigDump <envoy_api_msg_admin.v2alpha.ClustersConfigDump>`
   * * *listeners*: :ref:`ListenersConfigDump <envoy_api_msg_admin.v2alpha.ListenersConfigDump>`
   * * *routes*:  :ref:`RoutesConfigDump <envoy_api_msg_admin.v2alpha.RoutesConfigDump>`
   *
   * You can filter output with the resource and mask query parameters.
   * See :ref:`/config_dump?resource={} <operations_admin_interface_config_dump_by_resource>`,
   * :ref:`/config_dump?mask={} <operations_admin_interface_config_dump_by_mask>`,
   * or :ref:`/config_dump?resource={},mask={}
   * <operations_admin_interface_config_dump_by_resource_and_mask>` for more information.
   */
  configs?: Any[] | undefined;
}

export interface UpdateFailureState {
  $type: "envoy.admin.v2alpha.UpdateFailureState";
  /** What the component configuration would have been if the update had succeeded. */
  failed_configuration?:
    | Any
    | undefined;
  /** Time of the latest failed update attempt. */
  last_update_attempt?:
    | Date
    | undefined;
  /** Details about the last failed update attempt. */
  details?: string | undefined;
}

/**
 * This message describes the bootstrap configuration that Envoy was started with. This includes
 * any CLI overrides that were merged. Bootstrap configuration information can be used to recreate
 * the static portions of an Envoy configuration by reusing the output as the bootstrap
 * configuration for another Envoy.
 */
export interface BootstrapConfigDump {
  $type: "envoy.admin.v2alpha.BootstrapConfigDump";
  bootstrap?:
    | Bootstrap
    | undefined;
  /** The timestamp when the BootstrapConfig was last updated. */
  last_updated?: Date | undefined;
}

/**
 * Envoy's listener manager fills this message with all currently known listeners. Listener
 * configuration information can be used to recreate an Envoy configuration by populating all
 * listeners as static listeners or by returning them in a LDS response.
 */
export interface ListenersConfigDump {
  $type: "envoy.admin.v2alpha.ListenersConfigDump";
  /**
   * This is the :ref:`version_info <envoy_api_field_DiscoveryResponse.version_info>` in the
   * last processed LDS discovery response. If there are only static bootstrap listeners, this field
   * will be "".
   */
  version_info?:
    | string
    | undefined;
  /** The statically loaded listener configs. */
  static_listeners?:
    | ListenersConfigDump_StaticListener[]
    | undefined;
  /** State for any warming, active, or draining listeners. */
  dynamic_listeners?: ListenersConfigDump_DynamicListener[] | undefined;
}

/** Describes a statically loaded listener. */
export interface ListenersConfigDump_StaticListener {
  $type: "envoy.admin.v2alpha.ListenersConfigDump.StaticListener";
  /** The listener config. */
  listener?:
    | Any
    | undefined;
  /** The timestamp when the Listener was last successfully updated. */
  last_updated?: Date | undefined;
}

export interface ListenersConfigDump_DynamicListenerState {
  $type: "envoy.admin.v2alpha.ListenersConfigDump.DynamicListenerState";
  /**
   * This is the per-resource version information. This version is currently taken from the
   * :ref:`version_info <envoy_api_field_DiscoveryResponse.version_info>` field at the time
   * that the listener was loaded. In the future, discrete per-listener versions may be supported
   * by the API.
   */
  version_info?:
    | string
    | undefined;
  /** The listener config. */
  listener?:
    | Any
    | undefined;
  /** The timestamp when the Listener was last successfully updated. */
  last_updated?: Date | undefined;
}

/**
 * Describes a dynamically loaded listener via the LDS API.
 * [#next-free-field: 6]
 */
export interface ListenersConfigDump_DynamicListener {
  $type: "envoy.admin.v2alpha.ListenersConfigDump.DynamicListener";
  /** The name or unique id of this listener, pulled from the DynamicListenerState config. */
  name?:
    | string
    | undefined;
  /**
   * The listener state for any active listener by this name.
   * These are listeners that are available to service data plane traffic.
   */
  active_state?:
    | ListenersConfigDump_DynamicListenerState
    | undefined;
  /**
   * The listener state for any warming listener by this name.
   * These are listeners that are currently undergoing warming in preparation to service data
   * plane traffic. Note that if attempting to recreate an Envoy configuration from a
   * configuration dump, the warming listeners should generally be discarded.
   */
  warming_state?:
    | ListenersConfigDump_DynamicListenerState
    | undefined;
  /**
   * The listener state for any draining listener by this name.
   * These are listeners that are currently undergoing draining in preparation to stop servicing
   * data plane traffic. Note that if attempting to recreate an Envoy configuration from a
   * configuration dump, the draining listeners should generally be discarded.
   */
  draining_state?:
    | ListenersConfigDump_DynamicListenerState
    | undefined;
  /** Set if the last update failed, cleared after the next successful update. */
  error_state?: UpdateFailureState | undefined;
}

/**
 * Envoy's cluster manager fills this message with all currently known clusters. Cluster
 * configuration information can be used to recreate an Envoy configuration by populating all
 * clusters as static clusters or by returning them in a CDS response.
 */
export interface ClustersConfigDump {
  $type: "envoy.admin.v2alpha.ClustersConfigDump";
  /**
   * This is the :ref:`version_info <envoy_api_field_DiscoveryResponse.version_info>` in the
   * last processed CDS discovery response. If there are only static bootstrap clusters, this field
   * will be "".
   */
  version_info?:
    | string
    | undefined;
  /** The statically loaded cluster configs. */
  static_clusters?:
    | ClustersConfigDump_StaticCluster[]
    | undefined;
  /**
   * The dynamically loaded active clusters. These are clusters that are available to service
   * data plane traffic.
   */
  dynamic_active_clusters?:
    | ClustersConfigDump_DynamicCluster[]
    | undefined;
  /**
   * The dynamically loaded warming clusters. These are clusters that are currently undergoing
   * warming in preparation to service data plane traffic. Note that if attempting to recreate an
   * Envoy configuration from a configuration dump, the warming clusters should generally be
   * discarded.
   */
  dynamic_warming_clusters?: ClustersConfigDump_DynamicCluster[] | undefined;
}

/** Describes a statically loaded cluster. */
export interface ClustersConfigDump_StaticCluster {
  $type: "envoy.admin.v2alpha.ClustersConfigDump.StaticCluster";
  /** The cluster config. */
  cluster?:
    | Any
    | undefined;
  /** The timestamp when the Cluster was last updated. */
  last_updated?: Date | undefined;
}

/** Describes a dynamically loaded cluster via the CDS API. */
export interface ClustersConfigDump_DynamicCluster {
  $type: "envoy.admin.v2alpha.ClustersConfigDump.DynamicCluster";
  /**
   * This is the per-resource version information. This version is currently taken from the
   * :ref:`version_info <envoy_api_field_DiscoveryResponse.version_info>` field at the time
   * that the cluster was loaded. In the future, discrete per-cluster versions may be supported by
   * the API.
   */
  version_info?:
    | string
    | undefined;
  /** The cluster config. */
  cluster?:
    | Any
    | undefined;
  /** The timestamp when the Cluster was last updated. */
  last_updated?: Date | undefined;
}

/**
 * Envoy's RDS implementation fills this message with all currently loaded routes, as described by
 * their RouteConfiguration objects. Static routes that are either defined in the bootstrap configuration
 * or defined inline while configuring listeners are separated from those configured dynamically via RDS.
 * Route configuration information can be used to recreate an Envoy configuration by populating all routes
 * as static routes or by returning them in RDS responses.
 */
export interface RoutesConfigDump {
  $type: "envoy.admin.v2alpha.RoutesConfigDump";
  /** The statically loaded route configs. */
  static_route_configs?:
    | RoutesConfigDump_StaticRouteConfig[]
    | undefined;
  /** The dynamically loaded route configs. */
  dynamic_route_configs?: RoutesConfigDump_DynamicRouteConfig[] | undefined;
}

export interface RoutesConfigDump_StaticRouteConfig {
  $type: "envoy.admin.v2alpha.RoutesConfigDump.StaticRouteConfig";
  /** The route config. */
  route_config?:
    | Any
    | undefined;
  /** The timestamp when the Route was last updated. */
  last_updated?: Date | undefined;
}

export interface RoutesConfigDump_DynamicRouteConfig {
  $type: "envoy.admin.v2alpha.RoutesConfigDump.DynamicRouteConfig";
  /**
   * This is the per-resource version information. This version is currently taken from the
   * :ref:`version_info <envoy_api_field_DiscoveryResponse.version_info>` field at the time that
   * the route configuration was loaded.
   */
  version_info?:
    | string
    | undefined;
  /** The route config. */
  route_config?:
    | Any
    | undefined;
  /** The timestamp when the Route was last updated. */
  last_updated?: Date | undefined;
}

/**
 * Envoy's scoped RDS implementation fills this message with all currently loaded route
 * configuration scopes (defined via ScopedRouteConfigurationsSet protos). This message lists both
 * the scopes defined inline with the higher order object (i.e., the HttpConnectionManager) and the
 * dynamically obtained scopes via the SRDS API.
 */
export interface ScopedRoutesConfigDump {
  $type: "envoy.admin.v2alpha.ScopedRoutesConfigDump";
  /** The statically loaded scoped route configs. */
  inline_scoped_route_configs?:
    | ScopedRoutesConfigDump_InlineScopedRouteConfigs[]
    | undefined;
  /** The dynamically loaded scoped route configs. */
  dynamic_scoped_route_configs?: ScopedRoutesConfigDump_DynamicScopedRouteConfigs[] | undefined;
}

export interface ScopedRoutesConfigDump_InlineScopedRouteConfigs {
  $type: "envoy.admin.v2alpha.ScopedRoutesConfigDump.InlineScopedRouteConfigs";
  /** The name assigned to the scoped route configurations. */
  name?:
    | string
    | undefined;
  /** The scoped route configurations. */
  scoped_route_configs?:
    | Any[]
    | undefined;
  /** The timestamp when the scoped route config set was last updated. */
  last_updated?: Date | undefined;
}

export interface ScopedRoutesConfigDump_DynamicScopedRouteConfigs {
  $type: "envoy.admin.v2alpha.ScopedRoutesConfigDump.DynamicScopedRouteConfigs";
  /** The name assigned to the scoped route configurations. */
  name?:
    | string
    | undefined;
  /**
   * This is the per-resource version information. This version is currently taken from the
   * :ref:`version_info <envoy_api_field_DiscoveryResponse.version_info>` field at the time that
   * the scoped routes configuration was loaded.
   */
  version_info?:
    | string
    | undefined;
  /** The scoped route configurations. */
  scoped_route_configs?:
    | Any[]
    | undefined;
  /** The timestamp when the scoped route config set was last updated. */
  last_updated?: Date | undefined;
}

/** Envoys SDS implementation fills this message with all secrets fetched dynamically via SDS. */
export interface SecretsConfigDump {
  $type: "envoy.admin.v2alpha.SecretsConfigDump";
  /** The statically loaded secrets. */
  static_secrets?:
    | SecretsConfigDump_StaticSecret[]
    | undefined;
  /**
   * The dynamically loaded active secrets. These are secrets that are available to service
   * clusters or listeners.
   */
  dynamic_active_secrets?:
    | SecretsConfigDump_DynamicSecret[]
    | undefined;
  /**
   * The dynamically loaded warming secrets. These are secrets that are currently undergoing
   * warming in preparation to service clusters or listeners.
   */
  dynamic_warming_secrets?: SecretsConfigDump_DynamicSecret[] | undefined;
}

/** DynamicSecret contains secret information fetched via SDS. */
export interface SecretsConfigDump_DynamicSecret {
  $type: "envoy.admin.v2alpha.SecretsConfigDump.DynamicSecret";
  /** The name assigned to the secret. */
  name?:
    | string
    | undefined;
  /** This is the per-resource version information. */
  version_info?:
    | string
    | undefined;
  /** The timestamp when the secret was last updated. */
  last_updated?:
    | Date
    | undefined;
  /**
   * The actual secret information.
   * Security sensitive information is redacted (replaced with "[redacted]") for
   * private keys and passwords in TLS certificates.
   */
  secret?: Any | undefined;
}

/** StaticSecret specifies statically loaded secret in bootstrap. */
export interface SecretsConfigDump_StaticSecret {
  $type: "envoy.admin.v2alpha.SecretsConfigDump.StaticSecret";
  /** The name assigned to the secret. */
  name?:
    | string
    | undefined;
  /** The timestamp when the secret was last updated. */
  last_updated?:
    | Date
    | undefined;
  /**
   * The actual secret information.
   * Security sensitive information is redacted (replaced with "[redacted]") for
   * private keys and passwords in TLS certificates.
   */
  secret?: Any | undefined;
}

function createBaseConfigDump(): ConfigDump {
  return { $type: "envoy.admin.v2alpha.ConfigDump" };
}

export const ConfigDump: MessageFns<ConfigDump, "envoy.admin.v2alpha.ConfigDump"> = {
  $type: "envoy.admin.v2alpha.ConfigDump" as const,

  encode(message: ConfigDump, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.configs !== undefined && message.configs.length !== 0) {
      for (const v of message.configs) {
        Any.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConfigDump {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfigDump();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.configs === undefined) {
            message.configs = [];
          }
          const el = Any.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.configs!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfigDump {
    return {
      $type: ConfigDump.$type,
      configs: globalThis.Array.isArray(object?.configs) ? object.configs.map((e: any) => Any.fromJSON(e)) : undefined,
    };
  },

  toJSON(message: ConfigDump): unknown {
    const obj: any = {};
    if (message.configs?.length) {
      obj.configs = message.configs.map((e) => Any.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConfigDump>, I>>(base?: I): ConfigDump {
    return ConfigDump.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConfigDump>, I>>(object: I): ConfigDump {
    const message = createBaseConfigDump();
    message.configs = object.configs?.map((e) => Any.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(ConfigDump.$type, ConfigDump);

function createBaseUpdateFailureState(): UpdateFailureState {
  return { $type: "envoy.admin.v2alpha.UpdateFailureState" };
}

export const UpdateFailureState: MessageFns<UpdateFailureState, "envoy.admin.v2alpha.UpdateFailureState"> = {
  $type: "envoy.admin.v2alpha.UpdateFailureState" as const,

  encode(message: UpdateFailureState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.failed_configuration !== undefined) {
      Any.encode(message.failed_configuration, writer.uint32(10).fork()).join();
    }
    if (message.last_update_attempt !== undefined) {
      Timestamp.encode(toTimestamp(message.last_update_attempt), writer.uint32(18).fork()).join();
    }
    if (message.details !== undefined && message.details !== "") {
      writer.uint32(26).string(message.details);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateFailureState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateFailureState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.failed_configuration = Any.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.last_update_attempt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.details = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateFailureState {
    return {
      $type: UpdateFailureState.$type,
      failed_configuration: isSet(object.failed_configuration) ? Any.fromJSON(object.failed_configuration) : undefined,
      last_update_attempt: isSet(object.last_update_attempt)
        ? fromJsonTimestamp(object.last_update_attempt)
        : undefined,
      details: isSet(object.details) ? globalThis.String(object.details) : undefined,
    };
  },

  toJSON(message: UpdateFailureState): unknown {
    const obj: any = {};
    if (message.failed_configuration !== undefined) {
      obj.failed_configuration = Any.toJSON(message.failed_configuration);
    }
    if (message.last_update_attempt !== undefined) {
      obj.last_update_attempt = message.last_update_attempt.toISOString();
    }
    if (message.details !== undefined) {
      obj.details = message.details;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateFailureState>, I>>(base?: I): UpdateFailureState {
    return UpdateFailureState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateFailureState>, I>>(object: I): UpdateFailureState {
    const message = createBaseUpdateFailureState();
    message.failed_configuration = (object.failed_configuration !== undefined && object.failed_configuration !== null)
      ? Any.fromPartial(object.failed_configuration)
      : undefined;
    message.last_update_attempt = object.last_update_attempt ?? undefined;
    message.details = object.details ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(UpdateFailureState.$type, UpdateFailureState);

function createBaseBootstrapConfigDump(): BootstrapConfigDump {
  return { $type: "envoy.admin.v2alpha.BootstrapConfigDump" };
}

export const BootstrapConfigDump: MessageFns<BootstrapConfigDump, "envoy.admin.v2alpha.BootstrapConfigDump"> = {
  $type: "envoy.admin.v2alpha.BootstrapConfigDump" as const,

  encode(message: BootstrapConfigDump, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bootstrap !== undefined) {
      Bootstrap.encode(message.bootstrap, writer.uint32(10).fork()).join();
    }
    if (message.last_updated !== undefined) {
      Timestamp.encode(toTimestamp(message.last_updated), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BootstrapConfigDump {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBootstrapConfigDump();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bootstrap = Bootstrap.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.last_updated = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BootstrapConfigDump {
    return {
      $type: BootstrapConfigDump.$type,
      bootstrap: isSet(object.bootstrap) ? Bootstrap.fromJSON(object.bootstrap) : undefined,
      last_updated: isSet(object.last_updated) ? fromJsonTimestamp(object.last_updated) : undefined,
    };
  },

  toJSON(message: BootstrapConfigDump): unknown {
    const obj: any = {};
    if (message.bootstrap !== undefined) {
      obj.bootstrap = Bootstrap.toJSON(message.bootstrap);
    }
    if (message.last_updated !== undefined) {
      obj.last_updated = message.last_updated.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BootstrapConfigDump>, I>>(base?: I): BootstrapConfigDump {
    return BootstrapConfigDump.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BootstrapConfigDump>, I>>(object: I): BootstrapConfigDump {
    const message = createBaseBootstrapConfigDump();
    message.bootstrap = (object.bootstrap !== undefined && object.bootstrap !== null)
      ? Bootstrap.fromPartial(object.bootstrap)
      : undefined;
    message.last_updated = object.last_updated ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(BootstrapConfigDump.$type, BootstrapConfigDump);

function createBaseListenersConfigDump(): ListenersConfigDump {
  return { $type: "envoy.admin.v2alpha.ListenersConfigDump" };
}

export const ListenersConfigDump: MessageFns<ListenersConfigDump, "envoy.admin.v2alpha.ListenersConfigDump"> = {
  $type: "envoy.admin.v2alpha.ListenersConfigDump" as const,

  encode(message: ListenersConfigDump, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version_info !== undefined && message.version_info !== "") {
      writer.uint32(10).string(message.version_info);
    }
    if (message.static_listeners !== undefined && message.static_listeners.length !== 0) {
      for (const v of message.static_listeners) {
        ListenersConfigDump_StaticListener.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.dynamic_listeners !== undefined && message.dynamic_listeners.length !== 0) {
      for (const v of message.dynamic_listeners) {
        ListenersConfigDump_DynamicListener.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListenersConfigDump {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListenersConfigDump();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version_info = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.static_listeners === undefined) {
            message.static_listeners = [];
          }
          const el = ListenersConfigDump_StaticListener.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.static_listeners!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.dynamic_listeners === undefined) {
            message.dynamic_listeners = [];
          }
          const el = ListenersConfigDump_DynamicListener.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.dynamic_listeners!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListenersConfigDump {
    return {
      $type: ListenersConfigDump.$type,
      version_info: isSet(object.version_info) ? globalThis.String(object.version_info) : undefined,
      static_listeners: globalThis.Array.isArray(object?.static_listeners)
        ? object.static_listeners.map((e: any) => ListenersConfigDump_StaticListener.fromJSON(e))
        : undefined,
      dynamic_listeners: globalThis.Array.isArray(object?.dynamic_listeners)
        ? object.dynamic_listeners.map((e: any) => ListenersConfigDump_DynamicListener.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: ListenersConfigDump): unknown {
    const obj: any = {};
    if (message.version_info !== undefined) {
      obj.version_info = message.version_info;
    }
    if (message.static_listeners?.length) {
      obj.static_listeners = message.static_listeners.map((e) => ListenersConfigDump_StaticListener.toJSON(e));
    }
    if (message.dynamic_listeners?.length) {
      obj.dynamic_listeners = message.dynamic_listeners.map((e) => ListenersConfigDump_DynamicListener.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListenersConfigDump>, I>>(base?: I): ListenersConfigDump {
    return ListenersConfigDump.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListenersConfigDump>, I>>(object: I): ListenersConfigDump {
    const message = createBaseListenersConfigDump();
    message.version_info = object.version_info ?? undefined;
    message.static_listeners = object.static_listeners?.map((e) => ListenersConfigDump_StaticListener.fromPartial(e)) ||
      undefined;
    message.dynamic_listeners =
      object.dynamic_listeners?.map((e) => ListenersConfigDump_DynamicListener.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(ListenersConfigDump.$type, ListenersConfigDump);

function createBaseListenersConfigDump_StaticListener(): ListenersConfigDump_StaticListener {
  return { $type: "envoy.admin.v2alpha.ListenersConfigDump.StaticListener" };
}

export const ListenersConfigDump_StaticListener: MessageFns<
  ListenersConfigDump_StaticListener,
  "envoy.admin.v2alpha.ListenersConfigDump.StaticListener"
> = {
  $type: "envoy.admin.v2alpha.ListenersConfigDump.StaticListener" as const,

  encode(message: ListenersConfigDump_StaticListener, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.listener !== undefined) {
      Any.encode(message.listener, writer.uint32(10).fork()).join();
    }
    if (message.last_updated !== undefined) {
      Timestamp.encode(toTimestamp(message.last_updated), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListenersConfigDump_StaticListener {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListenersConfigDump_StaticListener();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.listener = Any.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.last_updated = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListenersConfigDump_StaticListener {
    return {
      $type: ListenersConfigDump_StaticListener.$type,
      listener: isSet(object.listener) ? Any.fromJSON(object.listener) : undefined,
      last_updated: isSet(object.last_updated) ? fromJsonTimestamp(object.last_updated) : undefined,
    };
  },

  toJSON(message: ListenersConfigDump_StaticListener): unknown {
    const obj: any = {};
    if (message.listener !== undefined) {
      obj.listener = Any.toJSON(message.listener);
    }
    if (message.last_updated !== undefined) {
      obj.last_updated = message.last_updated.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListenersConfigDump_StaticListener>, I>>(
    base?: I,
  ): ListenersConfigDump_StaticListener {
    return ListenersConfigDump_StaticListener.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListenersConfigDump_StaticListener>, I>>(
    object: I,
  ): ListenersConfigDump_StaticListener {
    const message = createBaseListenersConfigDump_StaticListener();
    message.listener = (object.listener !== undefined && object.listener !== null)
      ? Any.fromPartial(object.listener)
      : undefined;
    message.last_updated = object.last_updated ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ListenersConfigDump_StaticListener.$type, ListenersConfigDump_StaticListener);

function createBaseListenersConfigDump_DynamicListenerState(): ListenersConfigDump_DynamicListenerState {
  return { $type: "envoy.admin.v2alpha.ListenersConfigDump.DynamicListenerState" };
}

export const ListenersConfigDump_DynamicListenerState: MessageFns<
  ListenersConfigDump_DynamicListenerState,
  "envoy.admin.v2alpha.ListenersConfigDump.DynamicListenerState"
> = {
  $type: "envoy.admin.v2alpha.ListenersConfigDump.DynamicListenerState" as const,

  encode(message: ListenersConfigDump_DynamicListenerState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version_info !== undefined && message.version_info !== "") {
      writer.uint32(10).string(message.version_info);
    }
    if (message.listener !== undefined) {
      Any.encode(message.listener, writer.uint32(18).fork()).join();
    }
    if (message.last_updated !== undefined) {
      Timestamp.encode(toTimestamp(message.last_updated), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListenersConfigDump_DynamicListenerState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListenersConfigDump_DynamicListenerState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version_info = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.listener = Any.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.last_updated = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListenersConfigDump_DynamicListenerState {
    return {
      $type: ListenersConfigDump_DynamicListenerState.$type,
      version_info: isSet(object.version_info) ? globalThis.String(object.version_info) : undefined,
      listener: isSet(object.listener) ? Any.fromJSON(object.listener) : undefined,
      last_updated: isSet(object.last_updated) ? fromJsonTimestamp(object.last_updated) : undefined,
    };
  },

  toJSON(message: ListenersConfigDump_DynamicListenerState): unknown {
    const obj: any = {};
    if (message.version_info !== undefined) {
      obj.version_info = message.version_info;
    }
    if (message.listener !== undefined) {
      obj.listener = Any.toJSON(message.listener);
    }
    if (message.last_updated !== undefined) {
      obj.last_updated = message.last_updated.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListenersConfigDump_DynamicListenerState>, I>>(
    base?: I,
  ): ListenersConfigDump_DynamicListenerState {
    return ListenersConfigDump_DynamicListenerState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListenersConfigDump_DynamicListenerState>, I>>(
    object: I,
  ): ListenersConfigDump_DynamicListenerState {
    const message = createBaseListenersConfigDump_DynamicListenerState();
    message.version_info = object.version_info ?? undefined;
    message.listener = (object.listener !== undefined && object.listener !== null)
      ? Any.fromPartial(object.listener)
      : undefined;
    message.last_updated = object.last_updated ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ListenersConfigDump_DynamicListenerState.$type, ListenersConfigDump_DynamicListenerState);

function createBaseListenersConfigDump_DynamicListener(): ListenersConfigDump_DynamicListener {
  return { $type: "envoy.admin.v2alpha.ListenersConfigDump.DynamicListener" };
}

export const ListenersConfigDump_DynamicListener: MessageFns<
  ListenersConfigDump_DynamicListener,
  "envoy.admin.v2alpha.ListenersConfigDump.DynamicListener"
> = {
  $type: "envoy.admin.v2alpha.ListenersConfigDump.DynamicListener" as const,

  encode(message: ListenersConfigDump_DynamicListener, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.active_state !== undefined) {
      ListenersConfigDump_DynamicListenerState.encode(message.active_state, writer.uint32(18).fork()).join();
    }
    if (message.warming_state !== undefined) {
      ListenersConfigDump_DynamicListenerState.encode(message.warming_state, writer.uint32(26).fork()).join();
    }
    if (message.draining_state !== undefined) {
      ListenersConfigDump_DynamicListenerState.encode(message.draining_state, writer.uint32(34).fork()).join();
    }
    if (message.error_state !== undefined) {
      UpdateFailureState.encode(message.error_state, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListenersConfigDump_DynamicListener {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListenersConfigDump_DynamicListener();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.active_state = ListenersConfigDump_DynamicListenerState.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.warming_state = ListenersConfigDump_DynamicListenerState.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.draining_state = ListenersConfigDump_DynamicListenerState.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.error_state = UpdateFailureState.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListenersConfigDump_DynamicListener {
    return {
      $type: ListenersConfigDump_DynamicListener.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      active_state: isSet(object.active_state)
        ? ListenersConfigDump_DynamicListenerState.fromJSON(object.active_state)
        : undefined,
      warming_state: isSet(object.warming_state)
        ? ListenersConfigDump_DynamicListenerState.fromJSON(object.warming_state)
        : undefined,
      draining_state: isSet(object.draining_state)
        ? ListenersConfigDump_DynamicListenerState.fromJSON(object.draining_state)
        : undefined,
      error_state: isSet(object.error_state) ? UpdateFailureState.fromJSON(object.error_state) : undefined,
    };
  },

  toJSON(message: ListenersConfigDump_DynamicListener): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.active_state !== undefined) {
      obj.active_state = ListenersConfigDump_DynamicListenerState.toJSON(message.active_state);
    }
    if (message.warming_state !== undefined) {
      obj.warming_state = ListenersConfigDump_DynamicListenerState.toJSON(message.warming_state);
    }
    if (message.draining_state !== undefined) {
      obj.draining_state = ListenersConfigDump_DynamicListenerState.toJSON(message.draining_state);
    }
    if (message.error_state !== undefined) {
      obj.error_state = UpdateFailureState.toJSON(message.error_state);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListenersConfigDump_DynamicListener>, I>>(
    base?: I,
  ): ListenersConfigDump_DynamicListener {
    return ListenersConfigDump_DynamicListener.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListenersConfigDump_DynamicListener>, I>>(
    object: I,
  ): ListenersConfigDump_DynamicListener {
    const message = createBaseListenersConfigDump_DynamicListener();
    message.name = object.name ?? undefined;
    message.active_state = (object.active_state !== undefined && object.active_state !== null)
      ? ListenersConfigDump_DynamicListenerState.fromPartial(object.active_state)
      : undefined;
    message.warming_state = (object.warming_state !== undefined && object.warming_state !== null)
      ? ListenersConfigDump_DynamicListenerState.fromPartial(object.warming_state)
      : undefined;
    message.draining_state = (object.draining_state !== undefined && object.draining_state !== null)
      ? ListenersConfigDump_DynamicListenerState.fromPartial(object.draining_state)
      : undefined;
    message.error_state = (object.error_state !== undefined && object.error_state !== null)
      ? UpdateFailureState.fromPartial(object.error_state)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(ListenersConfigDump_DynamicListener.$type, ListenersConfigDump_DynamicListener);

function createBaseClustersConfigDump(): ClustersConfigDump {
  return { $type: "envoy.admin.v2alpha.ClustersConfigDump" };
}

export const ClustersConfigDump: MessageFns<ClustersConfigDump, "envoy.admin.v2alpha.ClustersConfigDump"> = {
  $type: "envoy.admin.v2alpha.ClustersConfigDump" as const,

  encode(message: ClustersConfigDump, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version_info !== undefined && message.version_info !== "") {
      writer.uint32(10).string(message.version_info);
    }
    if (message.static_clusters !== undefined && message.static_clusters.length !== 0) {
      for (const v of message.static_clusters) {
        ClustersConfigDump_StaticCluster.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.dynamic_active_clusters !== undefined && message.dynamic_active_clusters.length !== 0) {
      for (const v of message.dynamic_active_clusters) {
        ClustersConfigDump_DynamicCluster.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    if (message.dynamic_warming_clusters !== undefined && message.dynamic_warming_clusters.length !== 0) {
      for (const v of message.dynamic_warming_clusters) {
        ClustersConfigDump_DynamicCluster.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClustersConfigDump {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClustersConfigDump();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version_info = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.static_clusters === undefined) {
            message.static_clusters = [];
          }
          const el = ClustersConfigDump_StaticCluster.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.static_clusters!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.dynamic_active_clusters === undefined) {
            message.dynamic_active_clusters = [];
          }
          const el = ClustersConfigDump_DynamicCluster.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.dynamic_active_clusters!.push(el);
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          if (message.dynamic_warming_clusters === undefined) {
            message.dynamic_warming_clusters = [];
          }
          const el = ClustersConfigDump_DynamicCluster.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.dynamic_warming_clusters!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClustersConfigDump {
    return {
      $type: ClustersConfigDump.$type,
      version_info: isSet(object.version_info) ? globalThis.String(object.version_info) : undefined,
      static_clusters: globalThis.Array.isArray(object?.static_clusters)
        ? object.static_clusters.map((e: any) => ClustersConfigDump_StaticCluster.fromJSON(e))
        : undefined,
      dynamic_active_clusters: globalThis.Array.isArray(object?.dynamic_active_clusters)
        ? object.dynamic_active_clusters.map((e: any) => ClustersConfigDump_DynamicCluster.fromJSON(e))
        : undefined,
      dynamic_warming_clusters: globalThis.Array.isArray(object?.dynamic_warming_clusters)
        ? object.dynamic_warming_clusters.map((e: any) => ClustersConfigDump_DynamicCluster.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: ClustersConfigDump): unknown {
    const obj: any = {};
    if (message.version_info !== undefined) {
      obj.version_info = message.version_info;
    }
    if (message.static_clusters?.length) {
      obj.static_clusters = message.static_clusters.map((e) => ClustersConfigDump_StaticCluster.toJSON(e));
    }
    if (message.dynamic_active_clusters?.length) {
      obj.dynamic_active_clusters = message.dynamic_active_clusters.map((e) =>
        ClustersConfigDump_DynamicCluster.toJSON(e)
      );
    }
    if (message.dynamic_warming_clusters?.length) {
      obj.dynamic_warming_clusters = message.dynamic_warming_clusters.map((e) =>
        ClustersConfigDump_DynamicCluster.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClustersConfigDump>, I>>(base?: I): ClustersConfigDump {
    return ClustersConfigDump.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClustersConfigDump>, I>>(object: I): ClustersConfigDump {
    const message = createBaseClustersConfigDump();
    message.version_info = object.version_info ?? undefined;
    message.static_clusters = object.static_clusters?.map((e) => ClustersConfigDump_StaticCluster.fromPartial(e)) ||
      undefined;
    message.dynamic_active_clusters =
      object.dynamic_active_clusters?.map((e) => ClustersConfigDump_DynamicCluster.fromPartial(e)) || undefined;
    message.dynamic_warming_clusters =
      object.dynamic_warming_clusters?.map((e) => ClustersConfigDump_DynamicCluster.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(ClustersConfigDump.$type, ClustersConfigDump);

function createBaseClustersConfigDump_StaticCluster(): ClustersConfigDump_StaticCluster {
  return { $type: "envoy.admin.v2alpha.ClustersConfigDump.StaticCluster" };
}

export const ClustersConfigDump_StaticCluster: MessageFns<
  ClustersConfigDump_StaticCluster,
  "envoy.admin.v2alpha.ClustersConfigDump.StaticCluster"
> = {
  $type: "envoy.admin.v2alpha.ClustersConfigDump.StaticCluster" as const,

  encode(message: ClustersConfigDump_StaticCluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cluster !== undefined) {
      Any.encode(message.cluster, writer.uint32(10).fork()).join();
    }
    if (message.last_updated !== undefined) {
      Timestamp.encode(toTimestamp(message.last_updated), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClustersConfigDump_StaticCluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClustersConfigDump_StaticCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cluster = Any.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.last_updated = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClustersConfigDump_StaticCluster {
    return {
      $type: ClustersConfigDump_StaticCluster.$type,
      cluster: isSet(object.cluster) ? Any.fromJSON(object.cluster) : undefined,
      last_updated: isSet(object.last_updated) ? fromJsonTimestamp(object.last_updated) : undefined,
    };
  },

  toJSON(message: ClustersConfigDump_StaticCluster): unknown {
    const obj: any = {};
    if (message.cluster !== undefined) {
      obj.cluster = Any.toJSON(message.cluster);
    }
    if (message.last_updated !== undefined) {
      obj.last_updated = message.last_updated.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClustersConfigDump_StaticCluster>, I>>(
    base?: I,
  ): ClustersConfigDump_StaticCluster {
    return ClustersConfigDump_StaticCluster.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClustersConfigDump_StaticCluster>, I>>(
    object: I,
  ): ClustersConfigDump_StaticCluster {
    const message = createBaseClustersConfigDump_StaticCluster();
    message.cluster = (object.cluster !== undefined && object.cluster !== null)
      ? Any.fromPartial(object.cluster)
      : undefined;
    message.last_updated = object.last_updated ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ClustersConfigDump_StaticCluster.$type, ClustersConfigDump_StaticCluster);

function createBaseClustersConfigDump_DynamicCluster(): ClustersConfigDump_DynamicCluster {
  return { $type: "envoy.admin.v2alpha.ClustersConfigDump.DynamicCluster" };
}

export const ClustersConfigDump_DynamicCluster: MessageFns<
  ClustersConfigDump_DynamicCluster,
  "envoy.admin.v2alpha.ClustersConfigDump.DynamicCluster"
> = {
  $type: "envoy.admin.v2alpha.ClustersConfigDump.DynamicCluster" as const,

  encode(message: ClustersConfigDump_DynamicCluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version_info !== undefined && message.version_info !== "") {
      writer.uint32(10).string(message.version_info);
    }
    if (message.cluster !== undefined) {
      Any.encode(message.cluster, writer.uint32(18).fork()).join();
    }
    if (message.last_updated !== undefined) {
      Timestamp.encode(toTimestamp(message.last_updated), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClustersConfigDump_DynamicCluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClustersConfigDump_DynamicCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version_info = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cluster = Any.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.last_updated = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClustersConfigDump_DynamicCluster {
    return {
      $type: ClustersConfigDump_DynamicCluster.$type,
      version_info: isSet(object.version_info) ? globalThis.String(object.version_info) : undefined,
      cluster: isSet(object.cluster) ? Any.fromJSON(object.cluster) : undefined,
      last_updated: isSet(object.last_updated) ? fromJsonTimestamp(object.last_updated) : undefined,
    };
  },

  toJSON(message: ClustersConfigDump_DynamicCluster): unknown {
    const obj: any = {};
    if (message.version_info !== undefined) {
      obj.version_info = message.version_info;
    }
    if (message.cluster !== undefined) {
      obj.cluster = Any.toJSON(message.cluster);
    }
    if (message.last_updated !== undefined) {
      obj.last_updated = message.last_updated.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClustersConfigDump_DynamicCluster>, I>>(
    base?: I,
  ): ClustersConfigDump_DynamicCluster {
    return ClustersConfigDump_DynamicCluster.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClustersConfigDump_DynamicCluster>, I>>(
    object: I,
  ): ClustersConfigDump_DynamicCluster {
    const message = createBaseClustersConfigDump_DynamicCluster();
    message.version_info = object.version_info ?? undefined;
    message.cluster = (object.cluster !== undefined && object.cluster !== null)
      ? Any.fromPartial(object.cluster)
      : undefined;
    message.last_updated = object.last_updated ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ClustersConfigDump_DynamicCluster.$type, ClustersConfigDump_DynamicCluster);

function createBaseRoutesConfigDump(): RoutesConfigDump {
  return { $type: "envoy.admin.v2alpha.RoutesConfigDump" };
}

export const RoutesConfigDump: MessageFns<RoutesConfigDump, "envoy.admin.v2alpha.RoutesConfigDump"> = {
  $type: "envoy.admin.v2alpha.RoutesConfigDump" as const,

  encode(message: RoutesConfigDump, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.static_route_configs !== undefined && message.static_route_configs.length !== 0) {
      for (const v of message.static_route_configs) {
        RoutesConfigDump_StaticRouteConfig.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.dynamic_route_configs !== undefined && message.dynamic_route_configs.length !== 0) {
      for (const v of message.dynamic_route_configs) {
        RoutesConfigDump_DynamicRouteConfig.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoutesConfigDump {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoutesConfigDump();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.static_route_configs === undefined) {
            message.static_route_configs = [];
          }
          const el = RoutesConfigDump_StaticRouteConfig.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.static_route_configs!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.dynamic_route_configs === undefined) {
            message.dynamic_route_configs = [];
          }
          const el = RoutesConfigDump_DynamicRouteConfig.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.dynamic_route_configs!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoutesConfigDump {
    return {
      $type: RoutesConfigDump.$type,
      static_route_configs: globalThis.Array.isArray(object?.static_route_configs)
        ? object.static_route_configs.map((e: any) => RoutesConfigDump_StaticRouteConfig.fromJSON(e))
        : undefined,
      dynamic_route_configs: globalThis.Array.isArray(object?.dynamic_route_configs)
        ? object.dynamic_route_configs.map((e: any) => RoutesConfigDump_DynamicRouteConfig.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: RoutesConfigDump): unknown {
    const obj: any = {};
    if (message.static_route_configs?.length) {
      obj.static_route_configs = message.static_route_configs.map((e) => RoutesConfigDump_StaticRouteConfig.toJSON(e));
    }
    if (message.dynamic_route_configs?.length) {
      obj.dynamic_route_configs = message.dynamic_route_configs.map((e) =>
        RoutesConfigDump_DynamicRouteConfig.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RoutesConfigDump>, I>>(base?: I): RoutesConfigDump {
    return RoutesConfigDump.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RoutesConfigDump>, I>>(object: I): RoutesConfigDump {
    const message = createBaseRoutesConfigDump();
    message.static_route_configs =
      object.static_route_configs?.map((e) => RoutesConfigDump_StaticRouteConfig.fromPartial(e)) || undefined;
    message.dynamic_route_configs =
      object.dynamic_route_configs?.map((e) => RoutesConfigDump_DynamicRouteConfig.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(RoutesConfigDump.$type, RoutesConfigDump);

function createBaseRoutesConfigDump_StaticRouteConfig(): RoutesConfigDump_StaticRouteConfig {
  return { $type: "envoy.admin.v2alpha.RoutesConfigDump.StaticRouteConfig" };
}

export const RoutesConfigDump_StaticRouteConfig: MessageFns<
  RoutesConfigDump_StaticRouteConfig,
  "envoy.admin.v2alpha.RoutesConfigDump.StaticRouteConfig"
> = {
  $type: "envoy.admin.v2alpha.RoutesConfigDump.StaticRouteConfig" as const,

  encode(message: RoutesConfigDump_StaticRouteConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.route_config !== undefined) {
      Any.encode(message.route_config, writer.uint32(10).fork()).join();
    }
    if (message.last_updated !== undefined) {
      Timestamp.encode(toTimestamp(message.last_updated), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoutesConfigDump_StaticRouteConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoutesConfigDump_StaticRouteConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.route_config = Any.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.last_updated = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoutesConfigDump_StaticRouteConfig {
    return {
      $type: RoutesConfigDump_StaticRouteConfig.$type,
      route_config: isSet(object.route_config) ? Any.fromJSON(object.route_config) : undefined,
      last_updated: isSet(object.last_updated) ? fromJsonTimestamp(object.last_updated) : undefined,
    };
  },

  toJSON(message: RoutesConfigDump_StaticRouteConfig): unknown {
    const obj: any = {};
    if (message.route_config !== undefined) {
      obj.route_config = Any.toJSON(message.route_config);
    }
    if (message.last_updated !== undefined) {
      obj.last_updated = message.last_updated.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RoutesConfigDump_StaticRouteConfig>, I>>(
    base?: I,
  ): RoutesConfigDump_StaticRouteConfig {
    return RoutesConfigDump_StaticRouteConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RoutesConfigDump_StaticRouteConfig>, I>>(
    object: I,
  ): RoutesConfigDump_StaticRouteConfig {
    const message = createBaseRoutesConfigDump_StaticRouteConfig();
    message.route_config = (object.route_config !== undefined && object.route_config !== null)
      ? Any.fromPartial(object.route_config)
      : undefined;
    message.last_updated = object.last_updated ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RoutesConfigDump_StaticRouteConfig.$type, RoutesConfigDump_StaticRouteConfig);

function createBaseRoutesConfigDump_DynamicRouteConfig(): RoutesConfigDump_DynamicRouteConfig {
  return { $type: "envoy.admin.v2alpha.RoutesConfigDump.DynamicRouteConfig" };
}

export const RoutesConfigDump_DynamicRouteConfig: MessageFns<
  RoutesConfigDump_DynamicRouteConfig,
  "envoy.admin.v2alpha.RoutesConfigDump.DynamicRouteConfig"
> = {
  $type: "envoy.admin.v2alpha.RoutesConfigDump.DynamicRouteConfig" as const,

  encode(message: RoutesConfigDump_DynamicRouteConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version_info !== undefined && message.version_info !== "") {
      writer.uint32(10).string(message.version_info);
    }
    if (message.route_config !== undefined) {
      Any.encode(message.route_config, writer.uint32(18).fork()).join();
    }
    if (message.last_updated !== undefined) {
      Timestamp.encode(toTimestamp(message.last_updated), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoutesConfigDump_DynamicRouteConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoutesConfigDump_DynamicRouteConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version_info = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.route_config = Any.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.last_updated = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoutesConfigDump_DynamicRouteConfig {
    return {
      $type: RoutesConfigDump_DynamicRouteConfig.$type,
      version_info: isSet(object.version_info) ? globalThis.String(object.version_info) : undefined,
      route_config: isSet(object.route_config) ? Any.fromJSON(object.route_config) : undefined,
      last_updated: isSet(object.last_updated) ? fromJsonTimestamp(object.last_updated) : undefined,
    };
  },

  toJSON(message: RoutesConfigDump_DynamicRouteConfig): unknown {
    const obj: any = {};
    if (message.version_info !== undefined) {
      obj.version_info = message.version_info;
    }
    if (message.route_config !== undefined) {
      obj.route_config = Any.toJSON(message.route_config);
    }
    if (message.last_updated !== undefined) {
      obj.last_updated = message.last_updated.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RoutesConfigDump_DynamicRouteConfig>, I>>(
    base?: I,
  ): RoutesConfigDump_DynamicRouteConfig {
    return RoutesConfigDump_DynamicRouteConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RoutesConfigDump_DynamicRouteConfig>, I>>(
    object: I,
  ): RoutesConfigDump_DynamicRouteConfig {
    const message = createBaseRoutesConfigDump_DynamicRouteConfig();
    message.version_info = object.version_info ?? undefined;
    message.route_config = (object.route_config !== undefined && object.route_config !== null)
      ? Any.fromPartial(object.route_config)
      : undefined;
    message.last_updated = object.last_updated ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RoutesConfigDump_DynamicRouteConfig.$type, RoutesConfigDump_DynamicRouteConfig);

function createBaseScopedRoutesConfigDump(): ScopedRoutesConfigDump {
  return { $type: "envoy.admin.v2alpha.ScopedRoutesConfigDump" };
}

export const ScopedRoutesConfigDump: MessageFns<ScopedRoutesConfigDump, "envoy.admin.v2alpha.ScopedRoutesConfigDump"> =
  {
    $type: "envoy.admin.v2alpha.ScopedRoutesConfigDump" as const,

    encode(message: ScopedRoutesConfigDump, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
      if (message.inline_scoped_route_configs !== undefined && message.inline_scoped_route_configs.length !== 0) {
        for (const v of message.inline_scoped_route_configs) {
          ScopedRoutesConfigDump_InlineScopedRouteConfigs.encode(v!, writer.uint32(10).fork()).join();
        }
      }
      if (message.dynamic_scoped_route_configs !== undefined && message.dynamic_scoped_route_configs.length !== 0) {
        for (const v of message.dynamic_scoped_route_configs) {
          ScopedRoutesConfigDump_DynamicScopedRouteConfigs.encode(v!, writer.uint32(18).fork()).join();
        }
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): ScopedRoutesConfigDump {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseScopedRoutesConfigDump();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            if (message.inline_scoped_route_configs === undefined) {
              message.inline_scoped_route_configs = [];
            }
            const el = ScopedRoutesConfigDump_InlineScopedRouteConfigs.decode(reader, reader.uint32());
            if (el !== undefined) {
              message.inline_scoped_route_configs!.push(el);
            }
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            if (message.dynamic_scoped_route_configs === undefined) {
              message.dynamic_scoped_route_configs = [];
            }
            const el = ScopedRoutesConfigDump_DynamicScopedRouteConfigs.decode(reader, reader.uint32());
            if (el !== undefined) {
              message.dynamic_scoped_route_configs!.push(el);
            }
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): ScopedRoutesConfigDump {
      return {
        $type: ScopedRoutesConfigDump.$type,
        inline_scoped_route_configs: globalThis.Array.isArray(object?.inline_scoped_route_configs)
          ? object.inline_scoped_route_configs.map((e: any) =>
            ScopedRoutesConfigDump_InlineScopedRouteConfigs.fromJSON(e)
          )
          : undefined,
        dynamic_scoped_route_configs: globalThis.Array.isArray(object?.dynamic_scoped_route_configs)
          ? object.dynamic_scoped_route_configs.map((e: any) =>
            ScopedRoutesConfigDump_DynamicScopedRouteConfigs.fromJSON(e)
          )
          : undefined,
      };
    },

    toJSON(message: ScopedRoutesConfigDump): unknown {
      const obj: any = {};
      if (message.inline_scoped_route_configs?.length) {
        obj.inline_scoped_route_configs = message.inline_scoped_route_configs.map((e) =>
          ScopedRoutesConfigDump_InlineScopedRouteConfigs.toJSON(e)
        );
      }
      if (message.dynamic_scoped_route_configs?.length) {
        obj.dynamic_scoped_route_configs = message.dynamic_scoped_route_configs.map((e) =>
          ScopedRoutesConfigDump_DynamicScopedRouteConfigs.toJSON(e)
        );
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<ScopedRoutesConfigDump>, I>>(base?: I): ScopedRoutesConfigDump {
      return ScopedRoutesConfigDump.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<ScopedRoutesConfigDump>, I>>(object: I): ScopedRoutesConfigDump {
      const message = createBaseScopedRoutesConfigDump();
      message.inline_scoped_route_configs =
        object.inline_scoped_route_configs?.map((e) =>
          ScopedRoutesConfigDump_InlineScopedRouteConfigs.fromPartial(e)
        ) || undefined;
      message.dynamic_scoped_route_configs =
        object.dynamic_scoped_route_configs?.map((e) =>
          ScopedRoutesConfigDump_DynamicScopedRouteConfigs.fromPartial(e)
        ) || undefined;
      return message;
    },
  };

messageTypeRegistry.set(ScopedRoutesConfigDump.$type, ScopedRoutesConfigDump);

function createBaseScopedRoutesConfigDump_InlineScopedRouteConfigs(): ScopedRoutesConfigDump_InlineScopedRouteConfigs {
  return { $type: "envoy.admin.v2alpha.ScopedRoutesConfigDump.InlineScopedRouteConfigs" };
}

export const ScopedRoutesConfigDump_InlineScopedRouteConfigs: MessageFns<
  ScopedRoutesConfigDump_InlineScopedRouteConfigs,
  "envoy.admin.v2alpha.ScopedRoutesConfigDump.InlineScopedRouteConfigs"
> = {
  $type: "envoy.admin.v2alpha.ScopedRoutesConfigDump.InlineScopedRouteConfigs" as const,

  encode(
    message: ScopedRoutesConfigDump_InlineScopedRouteConfigs,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.scoped_route_configs !== undefined && message.scoped_route_configs.length !== 0) {
      for (const v of message.scoped_route_configs) {
        Any.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.last_updated !== undefined) {
      Timestamp.encode(toTimestamp(message.last_updated), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScopedRoutesConfigDump_InlineScopedRouteConfigs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScopedRoutesConfigDump_InlineScopedRouteConfigs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.scoped_route_configs === undefined) {
            message.scoped_route_configs = [];
          }
          const el = Any.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.scoped_route_configs!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.last_updated = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScopedRoutesConfigDump_InlineScopedRouteConfigs {
    return {
      $type: ScopedRoutesConfigDump_InlineScopedRouteConfigs.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      scoped_route_configs: globalThis.Array.isArray(object?.scoped_route_configs)
        ? object.scoped_route_configs.map((e: any) => Any.fromJSON(e))
        : undefined,
      last_updated: isSet(object.last_updated) ? fromJsonTimestamp(object.last_updated) : undefined,
    };
  },

  toJSON(message: ScopedRoutesConfigDump_InlineScopedRouteConfigs): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.scoped_route_configs?.length) {
      obj.scoped_route_configs = message.scoped_route_configs.map((e) => Any.toJSON(e));
    }
    if (message.last_updated !== undefined) {
      obj.last_updated = message.last_updated.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScopedRoutesConfigDump_InlineScopedRouteConfigs>, I>>(
    base?: I,
  ): ScopedRoutesConfigDump_InlineScopedRouteConfigs {
    return ScopedRoutesConfigDump_InlineScopedRouteConfigs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScopedRoutesConfigDump_InlineScopedRouteConfigs>, I>>(
    object: I,
  ): ScopedRoutesConfigDump_InlineScopedRouteConfigs {
    const message = createBaseScopedRoutesConfigDump_InlineScopedRouteConfigs();
    message.name = object.name ?? undefined;
    message.scoped_route_configs = object.scoped_route_configs?.map((e) => Any.fromPartial(e)) || undefined;
    message.last_updated = object.last_updated ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(
  ScopedRoutesConfigDump_InlineScopedRouteConfigs.$type,
  ScopedRoutesConfigDump_InlineScopedRouteConfigs,
);

function createBaseScopedRoutesConfigDump_DynamicScopedRouteConfigs(): ScopedRoutesConfigDump_DynamicScopedRouteConfigs {
  return { $type: "envoy.admin.v2alpha.ScopedRoutesConfigDump.DynamicScopedRouteConfigs" };
}

export const ScopedRoutesConfigDump_DynamicScopedRouteConfigs: MessageFns<
  ScopedRoutesConfigDump_DynamicScopedRouteConfigs,
  "envoy.admin.v2alpha.ScopedRoutesConfigDump.DynamicScopedRouteConfigs"
> = {
  $type: "envoy.admin.v2alpha.ScopedRoutesConfigDump.DynamicScopedRouteConfigs" as const,

  encode(
    message: ScopedRoutesConfigDump_DynamicScopedRouteConfigs,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version_info !== undefined && message.version_info !== "") {
      writer.uint32(18).string(message.version_info);
    }
    if (message.scoped_route_configs !== undefined && message.scoped_route_configs.length !== 0) {
      for (const v of message.scoped_route_configs) {
        Any.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    if (message.last_updated !== undefined) {
      Timestamp.encode(toTimestamp(message.last_updated), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScopedRoutesConfigDump_DynamicScopedRouteConfigs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScopedRoutesConfigDump_DynamicScopedRouteConfigs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.version_info = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.scoped_route_configs === undefined) {
            message.scoped_route_configs = [];
          }
          const el = Any.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.scoped_route_configs!.push(el);
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.last_updated = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScopedRoutesConfigDump_DynamicScopedRouteConfigs {
    return {
      $type: ScopedRoutesConfigDump_DynamicScopedRouteConfigs.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      version_info: isSet(object.version_info) ? globalThis.String(object.version_info) : undefined,
      scoped_route_configs: globalThis.Array.isArray(object?.scoped_route_configs)
        ? object.scoped_route_configs.map((e: any) => Any.fromJSON(e))
        : undefined,
      last_updated: isSet(object.last_updated) ? fromJsonTimestamp(object.last_updated) : undefined,
    };
  },

  toJSON(message: ScopedRoutesConfigDump_DynamicScopedRouteConfigs): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.version_info !== undefined) {
      obj.version_info = message.version_info;
    }
    if (message.scoped_route_configs?.length) {
      obj.scoped_route_configs = message.scoped_route_configs.map((e) => Any.toJSON(e));
    }
    if (message.last_updated !== undefined) {
      obj.last_updated = message.last_updated.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScopedRoutesConfigDump_DynamicScopedRouteConfigs>, I>>(
    base?: I,
  ): ScopedRoutesConfigDump_DynamicScopedRouteConfigs {
    return ScopedRoutesConfigDump_DynamicScopedRouteConfigs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScopedRoutesConfigDump_DynamicScopedRouteConfigs>, I>>(
    object: I,
  ): ScopedRoutesConfigDump_DynamicScopedRouteConfigs {
    const message = createBaseScopedRoutesConfigDump_DynamicScopedRouteConfigs();
    message.name = object.name ?? undefined;
    message.version_info = object.version_info ?? undefined;
    message.scoped_route_configs = object.scoped_route_configs?.map((e) => Any.fromPartial(e)) || undefined;
    message.last_updated = object.last_updated ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(
  ScopedRoutesConfigDump_DynamicScopedRouteConfigs.$type,
  ScopedRoutesConfigDump_DynamicScopedRouteConfigs,
);

function createBaseSecretsConfigDump(): SecretsConfigDump {
  return { $type: "envoy.admin.v2alpha.SecretsConfigDump" };
}

export const SecretsConfigDump: MessageFns<SecretsConfigDump, "envoy.admin.v2alpha.SecretsConfigDump"> = {
  $type: "envoy.admin.v2alpha.SecretsConfigDump" as const,

  encode(message: SecretsConfigDump, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.static_secrets !== undefined && message.static_secrets.length !== 0) {
      for (const v of message.static_secrets) {
        SecretsConfigDump_StaticSecret.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    if (message.dynamic_active_secrets !== undefined && message.dynamic_active_secrets.length !== 0) {
      for (const v of message.dynamic_active_secrets) {
        SecretsConfigDump_DynamicSecret.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.dynamic_warming_secrets !== undefined && message.dynamic_warming_secrets.length !== 0) {
      for (const v of message.dynamic_warming_secrets) {
        SecretsConfigDump_DynamicSecret.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SecretsConfigDump {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecretsConfigDump();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.static_secrets === undefined) {
            message.static_secrets = [];
          }
          const el = SecretsConfigDump_StaticSecret.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.static_secrets!.push(el);
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.dynamic_active_secrets === undefined) {
            message.dynamic_active_secrets = [];
          }
          const el = SecretsConfigDump_DynamicSecret.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.dynamic_active_secrets!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.dynamic_warming_secrets === undefined) {
            message.dynamic_warming_secrets = [];
          }
          const el = SecretsConfigDump_DynamicSecret.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.dynamic_warming_secrets!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SecretsConfigDump {
    return {
      $type: SecretsConfigDump.$type,
      static_secrets: globalThis.Array.isArray(object?.static_secrets)
        ? object.static_secrets.map((e: any) => SecretsConfigDump_StaticSecret.fromJSON(e))
        : undefined,
      dynamic_active_secrets: globalThis.Array.isArray(object?.dynamic_active_secrets)
        ? object.dynamic_active_secrets.map((e: any) => SecretsConfigDump_DynamicSecret.fromJSON(e))
        : undefined,
      dynamic_warming_secrets: globalThis.Array.isArray(object?.dynamic_warming_secrets)
        ? object.dynamic_warming_secrets.map((e: any) => SecretsConfigDump_DynamicSecret.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: SecretsConfigDump): unknown {
    const obj: any = {};
    if (message.static_secrets?.length) {
      obj.static_secrets = message.static_secrets.map((e) => SecretsConfigDump_StaticSecret.toJSON(e));
    }
    if (message.dynamic_active_secrets?.length) {
      obj.dynamic_active_secrets = message.dynamic_active_secrets.map((e) => SecretsConfigDump_DynamicSecret.toJSON(e));
    }
    if (message.dynamic_warming_secrets?.length) {
      obj.dynamic_warming_secrets = message.dynamic_warming_secrets.map((e) =>
        SecretsConfigDump_DynamicSecret.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SecretsConfigDump>, I>>(base?: I): SecretsConfigDump {
    return SecretsConfigDump.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SecretsConfigDump>, I>>(object: I): SecretsConfigDump {
    const message = createBaseSecretsConfigDump();
    message.static_secrets = object.static_secrets?.map((e) => SecretsConfigDump_StaticSecret.fromPartial(e)) ||
      undefined;
    message.dynamic_active_secrets =
      object.dynamic_active_secrets?.map((e) => SecretsConfigDump_DynamicSecret.fromPartial(e)) || undefined;
    message.dynamic_warming_secrets =
      object.dynamic_warming_secrets?.map((e) => SecretsConfigDump_DynamicSecret.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(SecretsConfigDump.$type, SecretsConfigDump);

function createBaseSecretsConfigDump_DynamicSecret(): SecretsConfigDump_DynamicSecret {
  return { $type: "envoy.admin.v2alpha.SecretsConfigDump.DynamicSecret" };
}

export const SecretsConfigDump_DynamicSecret: MessageFns<
  SecretsConfigDump_DynamicSecret,
  "envoy.admin.v2alpha.SecretsConfigDump.DynamicSecret"
> = {
  $type: "envoy.admin.v2alpha.SecretsConfigDump.DynamicSecret" as const,

  encode(message: SecretsConfigDump_DynamicSecret, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version_info !== undefined && message.version_info !== "") {
      writer.uint32(18).string(message.version_info);
    }
    if (message.last_updated !== undefined) {
      Timestamp.encode(toTimestamp(message.last_updated), writer.uint32(26).fork()).join();
    }
    if (message.secret !== undefined) {
      Any.encode(message.secret, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SecretsConfigDump_DynamicSecret {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecretsConfigDump_DynamicSecret();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.version_info = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.last_updated = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.secret = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SecretsConfigDump_DynamicSecret {
    return {
      $type: SecretsConfigDump_DynamicSecret.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      version_info: isSet(object.version_info) ? globalThis.String(object.version_info) : undefined,
      last_updated: isSet(object.last_updated) ? fromJsonTimestamp(object.last_updated) : undefined,
      secret: isSet(object.secret) ? Any.fromJSON(object.secret) : undefined,
    };
  },

  toJSON(message: SecretsConfigDump_DynamicSecret): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.version_info !== undefined) {
      obj.version_info = message.version_info;
    }
    if (message.last_updated !== undefined) {
      obj.last_updated = message.last_updated.toISOString();
    }
    if (message.secret !== undefined) {
      obj.secret = Any.toJSON(message.secret);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SecretsConfigDump_DynamicSecret>, I>>(base?: I): SecretsConfigDump_DynamicSecret {
    return SecretsConfigDump_DynamicSecret.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SecretsConfigDump_DynamicSecret>, I>>(
    object: I,
  ): SecretsConfigDump_DynamicSecret {
    const message = createBaseSecretsConfigDump_DynamicSecret();
    message.name = object.name ?? undefined;
    message.version_info = object.version_info ?? undefined;
    message.last_updated = object.last_updated ?? undefined;
    message.secret = (object.secret !== undefined && object.secret !== null)
      ? Any.fromPartial(object.secret)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(SecretsConfigDump_DynamicSecret.$type, SecretsConfigDump_DynamicSecret);

function createBaseSecretsConfigDump_StaticSecret(): SecretsConfigDump_StaticSecret {
  return { $type: "envoy.admin.v2alpha.SecretsConfigDump.StaticSecret" };
}

export const SecretsConfigDump_StaticSecret: MessageFns<
  SecretsConfigDump_StaticSecret,
  "envoy.admin.v2alpha.SecretsConfigDump.StaticSecret"
> = {
  $type: "envoy.admin.v2alpha.SecretsConfigDump.StaticSecret" as const,

  encode(message: SecretsConfigDump_StaticSecret, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.last_updated !== undefined) {
      Timestamp.encode(toTimestamp(message.last_updated), writer.uint32(18).fork()).join();
    }
    if (message.secret !== undefined) {
      Any.encode(message.secret, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SecretsConfigDump_StaticSecret {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecretsConfigDump_StaticSecret();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.last_updated = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.secret = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SecretsConfigDump_StaticSecret {
    return {
      $type: SecretsConfigDump_StaticSecret.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      last_updated: isSet(object.last_updated) ? fromJsonTimestamp(object.last_updated) : undefined,
      secret: isSet(object.secret) ? Any.fromJSON(object.secret) : undefined,
    };
  },

  toJSON(message: SecretsConfigDump_StaticSecret): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.last_updated !== undefined) {
      obj.last_updated = message.last_updated.toISOString();
    }
    if (message.secret !== undefined) {
      obj.secret = Any.toJSON(message.secret);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SecretsConfigDump_StaticSecret>, I>>(base?: I): SecretsConfigDump_StaticSecret {
    return SecretsConfigDump_StaticSecret.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SecretsConfigDump_StaticSecret>, I>>(
    object: I,
  ): SecretsConfigDump_StaticSecret {
    const message = createBaseSecretsConfigDump_StaticSecret();
    message.name = object.name ?? undefined;
    message.last_updated = object.last_updated ?? undefined;
    message.secret = (object.secret !== undefined && object.secret !== null)
      ? Any.fromPartial(object.secret)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(SecretsConfigDump_StaticSecret.$type, SecretsConfigDump_StaticSecret);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { $type: "google.protobuf.Timestamp", seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
