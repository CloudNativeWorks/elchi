// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/data/accesslog/v3/accesslog.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Any } from "../../../../google/protobuf/any";
import { Duration } from "../../../../google/protobuf/duration";
import { Timestamp } from "../../../../google/protobuf/timestamp";
import { UInt32Value } from "../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../typeRegistry";
import { Address } from "../../../config/core/v3/address";
import {
  Metadata,
  RequestMethod,
  requestMethodFromJSON,
  requestMethodToJSON,
  requestMethodToNumber,
} from "../../../config/core/v3/base";

export const protobufPackage = "envoy.data.accesslog.v3";

export enum AccessLogType {
  NotSet = "NotSet",
  TcpUpstreamConnected = "TcpUpstreamConnected",
  TcpPeriodic = "TcpPeriodic",
  TcpConnectionEnd = "TcpConnectionEnd",
  DownstreamStart = "DownstreamStart",
  DownstreamPeriodic = "DownstreamPeriodic",
  DownstreamEnd = "DownstreamEnd",
  UpstreamPoolReady = "UpstreamPoolReady",
  UpstreamPeriodic = "UpstreamPeriodic",
  UpstreamEnd = "UpstreamEnd",
  DownstreamTunnelSuccessfullyEstablished = "DownstreamTunnelSuccessfullyEstablished",
  UdpTunnelUpstreamConnected = "UdpTunnelUpstreamConnected",
  UdpPeriodic = "UdpPeriodic",
  UdpSessionEnd = "UdpSessionEnd",
}

export function accessLogTypeFromJSON(object: any): AccessLogType {
  switch (object) {
    case 0:
    case "NotSet":
      return AccessLogType.NotSet;
    case 1:
    case "TcpUpstreamConnected":
      return AccessLogType.TcpUpstreamConnected;
    case 2:
    case "TcpPeriodic":
      return AccessLogType.TcpPeriodic;
    case 3:
    case "TcpConnectionEnd":
      return AccessLogType.TcpConnectionEnd;
    case 4:
    case "DownstreamStart":
      return AccessLogType.DownstreamStart;
    case 5:
    case "DownstreamPeriodic":
      return AccessLogType.DownstreamPeriodic;
    case 6:
    case "DownstreamEnd":
      return AccessLogType.DownstreamEnd;
    case 7:
    case "UpstreamPoolReady":
      return AccessLogType.UpstreamPoolReady;
    case 8:
    case "UpstreamPeriodic":
      return AccessLogType.UpstreamPeriodic;
    case 9:
    case "UpstreamEnd":
      return AccessLogType.UpstreamEnd;
    case 10:
    case "DownstreamTunnelSuccessfullyEstablished":
      return AccessLogType.DownstreamTunnelSuccessfullyEstablished;
    case 11:
    case "UdpTunnelUpstreamConnected":
      return AccessLogType.UdpTunnelUpstreamConnected;
    case 12:
    case "UdpPeriodic":
      return AccessLogType.UdpPeriodic;
    case 13:
    case "UdpSessionEnd":
      return AccessLogType.UdpSessionEnd;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum AccessLogType");
  }
}

export function accessLogTypeToJSON(object: AccessLogType): string {
  switch (object) {
    case AccessLogType.NotSet:
      return "NotSet";
    case AccessLogType.TcpUpstreamConnected:
      return "TcpUpstreamConnected";
    case AccessLogType.TcpPeriodic:
      return "TcpPeriodic";
    case AccessLogType.TcpConnectionEnd:
      return "TcpConnectionEnd";
    case AccessLogType.DownstreamStart:
      return "DownstreamStart";
    case AccessLogType.DownstreamPeriodic:
      return "DownstreamPeriodic";
    case AccessLogType.DownstreamEnd:
      return "DownstreamEnd";
    case AccessLogType.UpstreamPoolReady:
      return "UpstreamPoolReady";
    case AccessLogType.UpstreamPeriodic:
      return "UpstreamPeriodic";
    case AccessLogType.UpstreamEnd:
      return "UpstreamEnd";
    case AccessLogType.DownstreamTunnelSuccessfullyEstablished:
      return "DownstreamTunnelSuccessfullyEstablished";
    case AccessLogType.UdpTunnelUpstreamConnected:
      return "UdpTunnelUpstreamConnected";
    case AccessLogType.UdpPeriodic:
      return "UdpPeriodic";
    case AccessLogType.UdpSessionEnd:
      return "UdpSessionEnd";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum AccessLogType");
  }
}

export function accessLogTypeToNumber(object: AccessLogType): number {
  switch (object) {
    case AccessLogType.NotSet:
      return 0;
    case AccessLogType.TcpUpstreamConnected:
      return 1;
    case AccessLogType.TcpPeriodic:
      return 2;
    case AccessLogType.TcpConnectionEnd:
      return 3;
    case AccessLogType.DownstreamStart:
      return 4;
    case AccessLogType.DownstreamPeriodic:
      return 5;
    case AccessLogType.DownstreamEnd:
      return 6;
    case AccessLogType.UpstreamPoolReady:
      return 7;
    case AccessLogType.UpstreamPeriodic:
      return 8;
    case AccessLogType.UpstreamEnd:
      return 9;
    case AccessLogType.DownstreamTunnelSuccessfullyEstablished:
      return 10;
    case AccessLogType.UdpTunnelUpstreamConnected:
      return 11;
    case AccessLogType.UdpPeriodic:
      return 12;
    case AccessLogType.UdpSessionEnd:
      return 13;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum AccessLogType");
  }
}

export interface TCPAccessLogEntry {
  $type: "envoy.data.accesslog.v3.TCPAccessLogEntry";
  /** Common properties shared by all Envoy access logs. */
  common_properties?:
    | AccessLogCommon
    | undefined;
  /** Properties of the TCP connection. */
  connection_properties?: ConnectionProperties | undefined;
}

export interface HTTPAccessLogEntry {
  $type: "envoy.data.accesslog.v3.HTTPAccessLogEntry";
  /** Common properties shared by all Envoy access logs. */
  common_properties?: AccessLogCommon | undefined;
  protocol_version?:
    | HTTPAccessLogEntry_HTTPVersion
    | undefined;
  /** Description of the incoming HTTP request. */
  request?:
    | HTTPRequestProperties
    | undefined;
  /** Description of the outgoing HTTP response. */
  response?: HTTPResponseProperties | undefined;
}

/** HTTP version */
export enum HTTPAccessLogEntry_HTTPVersion {
  PROTOCOL_UNSPECIFIED = "PROTOCOL_UNSPECIFIED",
  HTTP10 = "HTTP10",
  HTTP11 = "HTTP11",
  HTTP2 = "HTTP2",
  HTTP3 = "HTTP3",
}

export function hTTPAccessLogEntry_HTTPVersionFromJSON(object: any): HTTPAccessLogEntry_HTTPVersion {
  switch (object) {
    case 0:
    case "PROTOCOL_UNSPECIFIED":
      return HTTPAccessLogEntry_HTTPVersion.PROTOCOL_UNSPECIFIED;
    case 1:
    case "HTTP10":
      return HTTPAccessLogEntry_HTTPVersion.HTTP10;
    case 2:
    case "HTTP11":
      return HTTPAccessLogEntry_HTTPVersion.HTTP11;
    case 3:
    case "HTTP2":
      return HTTPAccessLogEntry_HTTPVersion.HTTP2;
    case 4:
    case "HTTP3":
      return HTTPAccessLogEntry_HTTPVersion.HTTP3;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum HTTPAccessLogEntry_HTTPVersion");
  }
}

export function hTTPAccessLogEntry_HTTPVersionToJSON(object: HTTPAccessLogEntry_HTTPVersion): string {
  switch (object) {
    case HTTPAccessLogEntry_HTTPVersion.PROTOCOL_UNSPECIFIED:
      return "PROTOCOL_UNSPECIFIED";
    case HTTPAccessLogEntry_HTTPVersion.HTTP10:
      return "HTTP10";
    case HTTPAccessLogEntry_HTTPVersion.HTTP11:
      return "HTTP11";
    case HTTPAccessLogEntry_HTTPVersion.HTTP2:
      return "HTTP2";
    case HTTPAccessLogEntry_HTTPVersion.HTTP3:
      return "HTTP3";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum HTTPAccessLogEntry_HTTPVersion");
  }
}

export function hTTPAccessLogEntry_HTTPVersionToNumber(object: HTTPAccessLogEntry_HTTPVersion): number {
  switch (object) {
    case HTTPAccessLogEntry_HTTPVersion.PROTOCOL_UNSPECIFIED:
      return 0;
    case HTTPAccessLogEntry_HTTPVersion.HTTP10:
      return 1;
    case HTTPAccessLogEntry_HTTPVersion.HTTP11:
      return 2;
    case HTTPAccessLogEntry_HTTPVersion.HTTP2:
      return 3;
    case HTTPAccessLogEntry_HTTPVersion.HTTP3:
      return 4;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum HTTPAccessLogEntry_HTTPVersion");
  }
}

/** Defines fields for a connection */
export interface ConnectionProperties {
  $type: "envoy.data.accesslog.v3.ConnectionProperties";
  /** Number of bytes received from downstream. */
  received_bytes?:
    | number
    | undefined;
  /** Number of bytes sent to downstream. */
  sent_bytes?: number | undefined;
}

/**
 * Defines fields that are shared by all Envoy access logs.
 * [#next-free-field: 34]
 */
export interface AccessLogCommon {
  $type: "envoy.data.accesslog.v3.AccessLogCommon";
  /**
   * [#not-implemented-hide:]
   * This field indicates the rate at which this log entry was sampled.
   * Valid range is (0.0, 1.0].
   */
  sample_rate?:
    | number
    | undefined;
  /**
   * This field is the remote/origin address on which the request from the user was received.
   * Note: This may not be the physical peer. E.g, if the remote address is inferred from for
   * example the x-forwarder-for header, proxy protocol, etc.
   */
  downstream_remote_address?:
    | Address
    | undefined;
  /** This field is the local/destination address on which the request from the user was received. */
  downstream_local_address?:
    | Address
    | undefined;
  /** If the connection is secure,S this field will contain TLS properties. */
  tls_properties?:
    | TLSProperties
    | undefined;
  /**
   * The time that Envoy started servicing this request. This is effectively the time that the first
   * downstream byte is received.
   */
  start_time?:
    | Date
    | undefined;
  /**
   * Interval between the first downstream byte received and the last
   * downstream byte received (i.e. time it takes to receive a request).
   */
  time_to_last_rx_byte?:
    | Duration
    | undefined;
  /**
   * Interval between the first downstream byte received and the first upstream byte sent. There may
   * by considerable delta between ``time_to_last_rx_byte`` and this value due to filters.
   * Additionally, the same caveats apply as documented in ``time_to_last_downstream_tx_byte`` about
   * not accounting for kernel socket buffer time, etc.
   */
  time_to_first_upstream_tx_byte?:
    | Duration
    | undefined;
  /**
   * Interval between the first downstream byte received and the last upstream byte sent. There may
   * by considerable delta between ``time_to_last_rx_byte`` and this value due to filters.
   * Additionally, the same caveats apply as documented in ``time_to_last_downstream_tx_byte`` about
   * not accounting for kernel socket buffer time, etc.
   */
  time_to_last_upstream_tx_byte?:
    | Duration
    | undefined;
  /**
   * Interval between the first downstream byte received and the first upstream
   * byte received (i.e. time it takes to start receiving a response).
   */
  time_to_first_upstream_rx_byte?:
    | Duration
    | undefined;
  /**
   * Interval between the first downstream byte received and the last upstream
   * byte received (i.e. time it takes to receive a complete response).
   */
  time_to_last_upstream_rx_byte?:
    | Duration
    | undefined;
  /**
   * Interval between the first downstream byte received and the first downstream byte sent.
   * There may be a considerable delta between the ``time_to_first_upstream_rx_byte`` and this field
   * due to filters. Additionally, the same caveats apply as documented in
   * ``time_to_last_downstream_tx_byte`` about not accounting for kernel socket buffer time, etc.
   */
  time_to_first_downstream_tx_byte?:
    | Duration
    | undefined;
  /**
   * Interval between the first downstream byte received and the last downstream byte sent.
   * Depending on protocol, buffering, windowing, filters, etc. there may be a considerable delta
   * between ``time_to_last_upstream_rx_byte`` and this field. Note also that this is an approximate
   * time. In the current implementation it does not include kernel socket buffer time. In the
   * current implementation it also does not include send window buffering inside the HTTP/2 codec.
   * In the future it is likely that work will be done to make this duration more accurate.
   */
  time_to_last_downstream_tx_byte?:
    | Duration
    | undefined;
  /**
   * The upstream remote/destination address that handles this exchange. This does not include
   * retries.
   */
  upstream_remote_address?:
    | Address
    | undefined;
  /** The upstream local/origin address that handles this exchange. This does not include retries. */
  upstream_local_address?:
    | Address
    | undefined;
  /** The upstream cluster that ``upstream_remote_address`` belongs to. */
  upstream_cluster?:
    | string
    | undefined;
  /** Flags indicating occurrences during request/response processing. */
  response_flags?:
    | ResponseFlags
    | undefined;
  /**
   * All metadata encountered during request processing, including endpoint
   * selection.
   *
   * This can be used to associate IDs attached to the various configurations
   * used to process this request with the access log entry. For example, a
   * route created from a higher level forwarding rule with some ID can place
   * that ID in this field and cross reference later. It can also be used to
   * determine if a canary endpoint was used or not.
   */
  metadata?:
    | Metadata
    | undefined;
  /**
   * If upstream connection failed due to transport socket (e.g. TLS handshake), provides the
   * failure reason from the transport socket. The format of this field depends on the configured
   * upstream transport socket. Common TLS failures are in
   * :ref:`TLS trouble shooting <arch_overview_ssl_trouble_shooting>`.
   */
  upstream_transport_failure_reason?:
    | string
    | undefined;
  /** The name of the route */
  route_name?:
    | string
    | undefined;
  /**
   * This field is the downstream direct remote address on which the request from the user was
   * received. Note: This is always the physical peer, even if the remote address is inferred from
   * for example the x-forwarder-for header, proxy protocol, etc.
   */
  downstream_direct_remote_address?:
    | Address
    | undefined;
  /**
   * Map of filter state in stream info that have been configured to be logged. If the filter
   * state serialized to any message other than ``google.protobuf.Any`` it will be packed into
   * ``google.protobuf.Any``.
   */
  filter_state_objects?:
    | Map<string, Any>
    | undefined;
  /**
   * A list of custom tags, which annotate logs with additional information.
   * To configure this value, users should configure
   * :ref:`custom_tags <envoy_v3_api_field_extensions.access_loggers.grpc.v3.CommonGrpcAccessLogConfig.custom_tags>`.
   */
  custom_tags?:
    | Map<string, string>
    | undefined;
  /**
   * For HTTP: Total duration in milliseconds of the request from the start time to the last byte out.
   * For TCP: Total duration in milliseconds of the downstream connection.
   * This is the total duration of the request (i.e., when the request's ActiveStream is destroyed)
   * and may be longer than ``time_to_last_downstream_tx_byte``.
   */
  duration?:
    | Duration
    | undefined;
  /**
   * For HTTP: Number of times the request is attempted upstream. Note that the field is omitted when the request was never attempted upstream.
   * For TCP: Number of times the connection request is attempted upstream. Note that the field is omitted when the connect request was never attempted upstream.
   */
  upstream_request_attempt_count?:
    | number
    | undefined;
  /** Connection termination details may provide additional information about why the connection was terminated by Envoy for L4 reasons. */
  connection_termination_details?:
    | string
    | undefined;
  /**
   * Optional unique id of stream (TCP connection, long-live HTTP2 stream, HTTP request) for logging and tracing.
   * This could be any format string that could be used to identify one stream.
   */
  stream_id?:
    | string
    | undefined;
  /**
   * If this log entry is final log entry that flushed after the stream completed or
   * intermediate log entry that flushed periodically during the stream.
   * There may be multiple intermediate log entries and only one final log entry for each
   * long-live stream (TCP connection, long-live HTTP2 stream).
   * And if it is necessary, unique ID or identifier can be added to the log entry
   * :ref:`stream_id <envoy_v3_api_field_data.accesslog.v3.AccessLogCommon.stream_id>` to
   * correlate all these intermediate log entries and final log entry.
   *
   * .. attention::
   *
   *   This field is deprecated in favor of ``access_log_type`` for better indication of the
   *   type of the access log record.
   *
   * @deprecated
   */
  intermediate_log_entry?:
    | boolean
    | undefined;
  /**
   * If downstream connection in listener failed due to transport socket (e.g. TLS handshake), provides the
   * failure reason from the transport socket. The format of this field depends on the configured downstream
   * transport socket. Common TLS failures are in :ref:`TLS trouble shooting <arch_overview_ssl_trouble_shooting>`.
   */
  downstream_transport_failure_reason?:
    | string
    | undefined;
  /**
   * For HTTP: Total number of bytes sent to the downstream by the http stream.
   * For TCP: Total number of bytes sent to the downstream by the tcp proxy.
   */
  downstream_wire_bytes_sent?:
    | number
    | undefined;
  /**
   * For HTTP: Total number of bytes received from the downstream by the http stream. Envoy over counts sizes of received HTTP/1.1 pipelined requests by adding up bytes of requests in the pipeline to the one currently being processed.
   * For TCP: Total number of bytes received from the downstream by the tcp proxy.
   */
  downstream_wire_bytes_received?:
    | number
    | undefined;
  /**
   * For HTTP: Total number of bytes sent to the upstream by the http stream. This value accumulates during upstream retries.
   * For TCP: Total number of bytes sent to the upstream by the tcp proxy.
   */
  upstream_wire_bytes_sent?:
    | number
    | undefined;
  /**
   * For HTTP: Total number of bytes received from the upstream by the http stream.
   * For TCP: Total number of bytes sent to the upstream by the tcp proxy.
   */
  upstream_wire_bytes_received?:
    | number
    | undefined;
  /**
   * The type of the access log, which indicates when the log was recorded.
   * See :ref:`ACCESS_LOG_TYPE <config_access_log_format_access_log_type>` for the available values.
   * In case the access log was recorded by a flow which does not correspond to one of the supported
   * values, then the default value will be ``NotSet``.
   * For more information about how access log behaves and when it is being recorded,
   * please refer to :ref:`access logging <arch_overview_access_logs>`.
   */
  access_log_type?: AccessLogType | undefined;
}

export interface AccessLogCommon_FilterStateObjectsEntry {
  $type: "envoy.data.accesslog.v3.AccessLogCommon.FilterStateObjectsEntry";
  key: string;
  value?: Any | undefined;
}

export interface AccessLogCommon_CustomTagsEntry {
  $type: "envoy.data.accesslog.v3.AccessLogCommon.CustomTagsEntry";
  key: string;
  value: string;
}

/**
 * Flags indicating occurrences during request/response processing.
 * [#next-free-field: 29]
 */
export interface ResponseFlags {
  $type: "envoy.data.accesslog.v3.ResponseFlags";
  /** Indicates local server healthcheck failed. */
  failed_local_healthcheck?:
    | boolean
    | undefined;
  /** Indicates there was no healthy upstream. */
  no_healthy_upstream?:
    | boolean
    | undefined;
  /** Indicates an there was an upstream request timeout. */
  upstream_request_timeout?:
    | boolean
    | undefined;
  /** Indicates local codec level reset was sent on the stream. */
  local_reset?:
    | boolean
    | undefined;
  /** Indicates remote codec level reset was received on the stream. */
  upstream_remote_reset?:
    | boolean
    | undefined;
  /** Indicates there was a local reset by a connection pool due to an initial connection failure. */
  upstream_connection_failure?:
    | boolean
    | undefined;
  /** Indicates the stream was reset due to an upstream connection termination. */
  upstream_connection_termination?:
    | boolean
    | undefined;
  /** Indicates the stream was reset because of a resource overflow. */
  upstream_overflow?:
    | boolean
    | undefined;
  /** Indicates no route was found for the request. */
  no_route_found?:
    | boolean
    | undefined;
  /** Indicates that the request was delayed before proxying. */
  delay_injected?:
    | boolean
    | undefined;
  /** Indicates that the request was aborted with an injected error code. */
  fault_injected?:
    | boolean
    | undefined;
  /** Indicates that the request was rate-limited locally. */
  rate_limited?:
    | boolean
    | undefined;
  /** Indicates if the request was deemed unauthorized and the reason for it. */
  unauthorized_details?:
    | ResponseFlags_Unauthorized
    | undefined;
  /** Indicates that the request was rejected because there was an error in rate limit service. */
  rate_limit_service_error?:
    | boolean
    | undefined;
  /** Indicates the stream was reset due to a downstream connection termination. */
  downstream_connection_termination?:
    | boolean
    | undefined;
  /** Indicates that the upstream retry limit was exceeded, resulting in a downstream error. */
  upstream_retry_limit_exceeded?:
    | boolean
    | undefined;
  /** Indicates that the stream idle timeout was hit, resulting in a downstream 408. */
  stream_idle_timeout?:
    | boolean
    | undefined;
  /**
   * Indicates that the request was rejected because an envoy request header failed strict
   * validation.
   */
  invalid_envoy_request_headers?:
    | boolean
    | undefined;
  /** Indicates there was an HTTP protocol error on the downstream request. */
  downstream_protocol_error?:
    | boolean
    | undefined;
  /** Indicates there was a max stream duration reached on the upstream request. */
  upstream_max_stream_duration_reached?:
    | boolean
    | undefined;
  /** Indicates the response was served from a cache filter. */
  response_from_cache_filter?:
    | boolean
    | undefined;
  /** Indicates that a filter configuration is not available. */
  no_filter_config_found?:
    | boolean
    | undefined;
  /** Indicates that request or connection exceeded the downstream connection duration. */
  duration_timeout?:
    | boolean
    | undefined;
  /** Indicates there was an HTTP protocol error in the upstream response. */
  upstream_protocol_error?:
    | boolean
    | undefined;
  /** Indicates no cluster was found for the request. */
  no_cluster_found?:
    | boolean
    | undefined;
  /** Indicates overload manager terminated the request. */
  overload_manager?:
    | boolean
    | undefined;
  /** Indicates a DNS resolution failed. */
  dns_resolution_failure?:
    | boolean
    | undefined;
  /** Indicates a downstream remote codec level reset was received on the stream */
  downstream_remote_reset?: boolean | undefined;
}

export interface ResponseFlags_Unauthorized {
  $type: "envoy.data.accesslog.v3.ResponseFlags.Unauthorized";
  reason?: ResponseFlags_Unauthorized_Reason | undefined;
}

/** Reasons why the request was unauthorized */
export enum ResponseFlags_Unauthorized_Reason {
  REASON_UNSPECIFIED = "REASON_UNSPECIFIED",
  /** EXTERNAL_SERVICE - The request was denied by the external authorization service. */
  EXTERNAL_SERVICE = "EXTERNAL_SERVICE",
}

export function responseFlags_Unauthorized_ReasonFromJSON(object: any): ResponseFlags_Unauthorized_Reason {
  switch (object) {
    case 0:
    case "REASON_UNSPECIFIED":
      return ResponseFlags_Unauthorized_Reason.REASON_UNSPECIFIED;
    case 1:
    case "EXTERNAL_SERVICE":
      return ResponseFlags_Unauthorized_Reason.EXTERNAL_SERVICE;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ResponseFlags_Unauthorized_Reason");
  }
}

export function responseFlags_Unauthorized_ReasonToJSON(object: ResponseFlags_Unauthorized_Reason): string {
  switch (object) {
    case ResponseFlags_Unauthorized_Reason.REASON_UNSPECIFIED:
      return "REASON_UNSPECIFIED";
    case ResponseFlags_Unauthorized_Reason.EXTERNAL_SERVICE:
      return "EXTERNAL_SERVICE";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ResponseFlags_Unauthorized_Reason");
  }
}

export function responseFlags_Unauthorized_ReasonToNumber(object: ResponseFlags_Unauthorized_Reason): number {
  switch (object) {
    case ResponseFlags_Unauthorized_Reason.REASON_UNSPECIFIED:
      return 0;
    case ResponseFlags_Unauthorized_Reason.EXTERNAL_SERVICE:
      return 1;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ResponseFlags_Unauthorized_Reason");
  }
}

/**
 * Properties of a negotiated TLS connection.
 * [#next-free-field: 8]
 */
export interface TLSProperties {
  $type: "envoy.data.accesslog.v3.TLSProperties";
  /** Version of TLS that was negotiated. */
  tls_version?:
    | TLSProperties_TLSVersion
    | undefined;
  /**
   * TLS cipher suite negotiated during handshake. The value is a
   * four-digit hex code defined by the IANA TLS Cipher Suite Registry
   * (e.g. ``009C`` for ``TLS_RSA_WITH_AES_128_GCM_SHA256``).
   *
   * Here it is expressed as an integer.
   */
  tls_cipher_suite?:
    | number
    | undefined;
  /** SNI hostname from handshake. */
  tls_sni_hostname?:
    | string
    | undefined;
  /** Properties of the local certificate used to negotiate TLS. */
  local_certificate_properties?:
    | TLSProperties_CertificateProperties
    | undefined;
  /** Properties of the peer certificate used to negotiate TLS. */
  peer_certificate_properties?:
    | TLSProperties_CertificateProperties
    | undefined;
  /** The TLS session ID. */
  tls_session_id?:
    | string
    | undefined;
  /** The ``JA3`` fingerprint when ``JA3`` fingerprinting is enabled. */
  ja3_fingerprint?: string | undefined;
}

export enum TLSProperties_TLSVersion {
  VERSION_UNSPECIFIED = "VERSION_UNSPECIFIED",
  TLSv1 = "TLSv1",
  TLSv1_1 = "TLSv1_1",
  TLSv1_2 = "TLSv1_2",
  TLSv1_3 = "TLSv1_3",
}

export function tLSProperties_TLSVersionFromJSON(object: any): TLSProperties_TLSVersion {
  switch (object) {
    case 0:
    case "VERSION_UNSPECIFIED":
      return TLSProperties_TLSVersion.VERSION_UNSPECIFIED;
    case 1:
    case "TLSv1":
      return TLSProperties_TLSVersion.TLSv1;
    case 2:
    case "TLSv1_1":
      return TLSProperties_TLSVersion.TLSv1_1;
    case 3:
    case "TLSv1_2":
      return TLSProperties_TLSVersion.TLSv1_2;
    case 4:
    case "TLSv1_3":
      return TLSProperties_TLSVersion.TLSv1_3;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum TLSProperties_TLSVersion");
  }
}

export function tLSProperties_TLSVersionToJSON(object: TLSProperties_TLSVersion): string {
  switch (object) {
    case TLSProperties_TLSVersion.VERSION_UNSPECIFIED:
      return "VERSION_UNSPECIFIED";
    case TLSProperties_TLSVersion.TLSv1:
      return "TLSv1";
    case TLSProperties_TLSVersion.TLSv1_1:
      return "TLSv1_1";
    case TLSProperties_TLSVersion.TLSv1_2:
      return "TLSv1_2";
    case TLSProperties_TLSVersion.TLSv1_3:
      return "TLSv1_3";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum TLSProperties_TLSVersion");
  }
}

export function tLSProperties_TLSVersionToNumber(object: TLSProperties_TLSVersion): number {
  switch (object) {
    case TLSProperties_TLSVersion.VERSION_UNSPECIFIED:
      return 0;
    case TLSProperties_TLSVersion.TLSv1:
      return 1;
    case TLSProperties_TLSVersion.TLSv1_1:
      return 2;
    case TLSProperties_TLSVersion.TLSv1_2:
      return 3;
    case TLSProperties_TLSVersion.TLSv1_3:
      return 4;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum TLSProperties_TLSVersion");
  }
}

export interface TLSProperties_CertificateProperties {
  $type: "envoy.data.accesslog.v3.TLSProperties.CertificateProperties";
  /** SANs present in the certificate. */
  subject_alt_name?:
    | TLSProperties_CertificateProperties_SubjectAltName[]
    | undefined;
  /** The subject field of the certificate. */
  subject?:
    | string
    | undefined;
  /** The issuer field of the certificate. */
  issuer?: string | undefined;
}

export interface TLSProperties_CertificateProperties_SubjectAltName {
  $type: "envoy.data.accesslog.v3.TLSProperties.CertificateProperties.SubjectAltName";
  san?:
    | //
    { $case: "uri"; uri: string }
    | //
    /** [#not-implemented-hide:] */
    { $case: "dns"; dns: string }
    | undefined;
}

/** [#next-free-field: 16] */
export interface HTTPRequestProperties {
  $type: "envoy.data.accesslog.v3.HTTPRequestProperties";
  /** The request method (RFC 7231/2616). */
  request_method?:
    | RequestMethod
    | undefined;
  /** The scheme portion of the incoming request URI. */
  scheme?:
    | string
    | undefined;
  /** HTTP/2 ``:authority`` or HTTP/1.1 ``Host`` header value. */
  authority?:
    | string
    | undefined;
  /**
   * The port of the incoming request URI
   * (unused currently, as port is composed onto authority).
   */
  port?:
    | number
    | undefined;
  /** The path portion from the incoming request URI. */
  path?:
    | string
    | undefined;
  /** Value of the ``User-Agent`` request header. */
  user_agent?:
    | string
    | undefined;
  /** Value of the ``Referer`` request header. */
  referer?:
    | string
    | undefined;
  /** Value of the ``X-Forwarded-For`` request header. */
  forwarded_for?:
    | string
    | undefined;
  /**
   * Value of the ``X-Request-Id`` request header
   *
   * This header is used by Envoy to uniquely identify a request.
   * It will be generated for all external requests and internal requests that
   * do not already have a request ID.
   */
  request_id?:
    | string
    | undefined;
  /** Value of the ``X-Envoy-Original-Path`` request header. */
  original_path?:
    | string
    | undefined;
  /**
   * Size of the HTTP request headers in bytes.
   *
   * This value is captured from the OSI layer 7 perspective, i.e. it does not
   * include overhead from framing or encoding at other networking layers.
   */
  request_headers_bytes?:
    | number
    | undefined;
  /**
   * Size of the HTTP request body in bytes.
   *
   * This value is captured from the OSI layer 7 perspective, i.e. it does not
   * include overhead from framing or encoding at other networking layers.
   */
  request_body_bytes?:
    | number
    | undefined;
  /** Map of additional headers that have been configured to be logged. */
  request_headers?:
    | Map<string, string>
    | undefined;
  /**
   * Number of header bytes sent to the upstream by the http stream, including protocol overhead.
   *
   * This value accumulates during upstream retries.
   */
  upstream_header_bytes_sent?:
    | number
    | undefined;
  /** Number of header bytes received from the downstream by the http stream, including protocol overhead. */
  downstream_header_bytes_received?: number | undefined;
}

export interface HTTPRequestProperties_RequestHeadersEntry {
  $type: "envoy.data.accesslog.v3.HTTPRequestProperties.RequestHeadersEntry";
  key: string;
  value: string;
}

/** [#next-free-field: 9] */
export interface HTTPResponseProperties {
  $type: "envoy.data.accesslog.v3.HTTPResponseProperties";
  /** The HTTP response code returned by Envoy. */
  response_code?:
    | number
    | undefined;
  /**
   * Size of the HTTP response headers in bytes.
   *
   * This value is captured from the OSI layer 7 perspective, i.e. it does not
   * include protocol overhead or overhead from framing or encoding at other networking layers.
   */
  response_headers_bytes?:
    | number
    | undefined;
  /**
   * Size of the HTTP response body in bytes.
   *
   * This value is captured from the OSI layer 7 perspective, i.e. it does not
   * include overhead from framing or encoding at other networking layers.
   */
  response_body_bytes?:
    | number
    | undefined;
  /** Map of additional headers configured to be logged. */
  response_headers?:
    | Map<string, string>
    | undefined;
  /** Map of trailers configured to be logged. */
  response_trailers?:
    | Map<string, string>
    | undefined;
  /** The HTTP response code details. */
  response_code_details?:
    | string
    | undefined;
  /** Number of header bytes received from the upstream by the http stream, including protocol overhead. */
  upstream_header_bytes_received?:
    | number
    | undefined;
  /** Number of header bytes sent to the downstream by the http stream, including protocol overhead. */
  downstream_header_bytes_sent?: number | undefined;
}

export interface HTTPResponseProperties_ResponseHeadersEntry {
  $type: "envoy.data.accesslog.v3.HTTPResponseProperties.ResponseHeadersEntry";
  key: string;
  value: string;
}

export interface HTTPResponseProperties_ResponseTrailersEntry {
  $type: "envoy.data.accesslog.v3.HTTPResponseProperties.ResponseTrailersEntry";
  key: string;
  value: string;
}

function createBaseTCPAccessLogEntry(): TCPAccessLogEntry {
  return { $type: "envoy.data.accesslog.v3.TCPAccessLogEntry" };
}

export const TCPAccessLogEntry: MessageFns<TCPAccessLogEntry, "envoy.data.accesslog.v3.TCPAccessLogEntry"> = {
  $type: "envoy.data.accesslog.v3.TCPAccessLogEntry" as const,

  encode(message: TCPAccessLogEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common_properties !== undefined) {
      AccessLogCommon.encode(message.common_properties, writer.uint32(10).fork()).join();
    }
    if (message.connection_properties !== undefined) {
      ConnectionProperties.encode(message.connection_properties, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TCPAccessLogEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTCPAccessLogEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common_properties = AccessLogCommon.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.connection_properties = ConnectionProperties.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TCPAccessLogEntry {
    return {
      $type: TCPAccessLogEntry.$type,
      common_properties: isSet(object.common_properties)
        ? AccessLogCommon.fromJSON(object.common_properties)
        : undefined,
      connection_properties: isSet(object.connection_properties)
        ? ConnectionProperties.fromJSON(object.connection_properties)
        : undefined,
    };
  },

  toJSON(message: TCPAccessLogEntry): unknown {
    const obj: any = {};
    if (message.common_properties !== undefined) {
      obj.common_properties = AccessLogCommon.toJSON(message.common_properties);
    }
    if (message.connection_properties !== undefined) {
      obj.connection_properties = ConnectionProperties.toJSON(message.connection_properties);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TCPAccessLogEntry>, I>>(base?: I): TCPAccessLogEntry {
    return TCPAccessLogEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TCPAccessLogEntry>, I>>(object: I): TCPAccessLogEntry {
    const message = createBaseTCPAccessLogEntry();
    message.common_properties = (object.common_properties !== undefined && object.common_properties !== null)
      ? AccessLogCommon.fromPartial(object.common_properties)
      : undefined;
    message.connection_properties =
      (object.connection_properties !== undefined && object.connection_properties !== null)
        ? ConnectionProperties.fromPartial(object.connection_properties)
        : undefined;
    return message;
  },
};

messageTypeRegistry.set(TCPAccessLogEntry.$type, TCPAccessLogEntry);

function createBaseHTTPAccessLogEntry(): HTTPAccessLogEntry {
  return { $type: "envoy.data.accesslog.v3.HTTPAccessLogEntry" };
}

export const HTTPAccessLogEntry: MessageFns<HTTPAccessLogEntry, "envoy.data.accesslog.v3.HTTPAccessLogEntry"> = {
  $type: "envoy.data.accesslog.v3.HTTPAccessLogEntry" as const,

  encode(message: HTTPAccessLogEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common_properties !== undefined) {
      AccessLogCommon.encode(message.common_properties, writer.uint32(10).fork()).join();
    }
    if (
      message.protocol_version !== undefined &&
      message.protocol_version !== HTTPAccessLogEntry_HTTPVersion.PROTOCOL_UNSPECIFIED
    ) {
      writer.uint32(16).int32(hTTPAccessLogEntry_HTTPVersionToNumber(message.protocol_version));
    }
    if (message.request !== undefined) {
      HTTPRequestProperties.encode(message.request, writer.uint32(26).fork()).join();
    }
    if (message.response !== undefined) {
      HTTPResponseProperties.encode(message.response, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HTTPAccessLogEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHTTPAccessLogEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common_properties = AccessLogCommon.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.protocol_version = hTTPAccessLogEntry_HTTPVersionFromJSON(reader.int32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.request = HTTPRequestProperties.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.response = HTTPResponseProperties.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HTTPAccessLogEntry {
    return {
      $type: HTTPAccessLogEntry.$type,
      common_properties: isSet(object.common_properties)
        ? AccessLogCommon.fromJSON(object.common_properties)
        : undefined,
      protocol_version: isSet(object.protocol_version)
        ? hTTPAccessLogEntry_HTTPVersionFromJSON(object.protocol_version)
        : undefined,
      request: isSet(object.request) ? HTTPRequestProperties.fromJSON(object.request) : undefined,
      response: isSet(object.response) ? HTTPResponseProperties.fromJSON(object.response) : undefined,
    };
  },

  toJSON(message: HTTPAccessLogEntry): unknown {
    const obj: any = {};
    if (message.common_properties !== undefined) {
      obj.common_properties = AccessLogCommon.toJSON(message.common_properties);
    }
    if (message.protocol_version !== undefined) {
      obj.protocol_version = hTTPAccessLogEntry_HTTPVersionToJSON(message.protocol_version);
    }
    if (message.request !== undefined) {
      obj.request = HTTPRequestProperties.toJSON(message.request);
    }
    if (message.response !== undefined) {
      obj.response = HTTPResponseProperties.toJSON(message.response);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HTTPAccessLogEntry>, I>>(base?: I): HTTPAccessLogEntry {
    return HTTPAccessLogEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HTTPAccessLogEntry>, I>>(object: I): HTTPAccessLogEntry {
    const message = createBaseHTTPAccessLogEntry();
    message.common_properties = (object.common_properties !== undefined && object.common_properties !== null)
      ? AccessLogCommon.fromPartial(object.common_properties)
      : undefined;
    message.protocol_version = object.protocol_version ?? undefined;
    message.request = (object.request !== undefined && object.request !== null)
      ? HTTPRequestProperties.fromPartial(object.request)
      : undefined;
    message.response = (object.response !== undefined && object.response !== null)
      ? HTTPResponseProperties.fromPartial(object.response)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(HTTPAccessLogEntry.$type, HTTPAccessLogEntry);

function createBaseConnectionProperties(): ConnectionProperties {
  return { $type: "envoy.data.accesslog.v3.ConnectionProperties" };
}

export const ConnectionProperties: MessageFns<ConnectionProperties, "envoy.data.accesslog.v3.ConnectionProperties"> = {
  $type: "envoy.data.accesslog.v3.ConnectionProperties" as const,

  encode(message: ConnectionProperties, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.received_bytes !== undefined && message.received_bytes !== 0) {
      writer.uint32(8).uint64(message.received_bytes);
    }
    if (message.sent_bytes !== undefined && message.sent_bytes !== 0) {
      writer.uint32(16).uint64(message.sent_bytes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectionProperties {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectionProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.received_bytes = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.sent_bytes = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectionProperties {
    return {
      $type: ConnectionProperties.$type,
      received_bytes: isSet(object.received_bytes) ? globalThis.Number(object.received_bytes) : undefined,
      sent_bytes: isSet(object.sent_bytes) ? globalThis.Number(object.sent_bytes) : undefined,
    };
  },

  toJSON(message: ConnectionProperties): unknown {
    const obj: any = {};
    if (message.received_bytes !== undefined) {
      obj.received_bytes = Math.round(message.received_bytes);
    }
    if (message.sent_bytes !== undefined) {
      obj.sent_bytes = Math.round(message.sent_bytes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConnectionProperties>, I>>(base?: I): ConnectionProperties {
    return ConnectionProperties.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConnectionProperties>, I>>(object: I): ConnectionProperties {
    const message = createBaseConnectionProperties();
    message.received_bytes = object.received_bytes ?? undefined;
    message.sent_bytes = object.sent_bytes ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ConnectionProperties.$type, ConnectionProperties);

function createBaseAccessLogCommon(): AccessLogCommon {
  return { $type: "envoy.data.accesslog.v3.AccessLogCommon" };
}

export const AccessLogCommon: MessageFns<AccessLogCommon, "envoy.data.accesslog.v3.AccessLogCommon"> = {
  $type: "envoy.data.accesslog.v3.AccessLogCommon" as const,

  encode(message: AccessLogCommon, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sample_rate !== undefined && message.sample_rate !== 0) {
      writer.uint32(9).double(message.sample_rate);
    }
    if (message.downstream_remote_address !== undefined) {
      Address.encode(message.downstream_remote_address, writer.uint32(18).fork()).join();
    }
    if (message.downstream_local_address !== undefined) {
      Address.encode(message.downstream_local_address, writer.uint32(26).fork()).join();
    }
    if (message.tls_properties !== undefined) {
      TLSProperties.encode(message.tls_properties, writer.uint32(34).fork()).join();
    }
    if (message.start_time !== undefined) {
      Timestamp.encode(toTimestamp(message.start_time), writer.uint32(42).fork()).join();
    }
    if (message.time_to_last_rx_byte !== undefined) {
      Duration.encode(message.time_to_last_rx_byte, writer.uint32(50).fork()).join();
    }
    if (message.time_to_first_upstream_tx_byte !== undefined) {
      Duration.encode(message.time_to_first_upstream_tx_byte, writer.uint32(58).fork()).join();
    }
    if (message.time_to_last_upstream_tx_byte !== undefined) {
      Duration.encode(message.time_to_last_upstream_tx_byte, writer.uint32(66).fork()).join();
    }
    if (message.time_to_first_upstream_rx_byte !== undefined) {
      Duration.encode(message.time_to_first_upstream_rx_byte, writer.uint32(74).fork()).join();
    }
    if (message.time_to_last_upstream_rx_byte !== undefined) {
      Duration.encode(message.time_to_last_upstream_rx_byte, writer.uint32(82).fork()).join();
    }
    if (message.time_to_first_downstream_tx_byte !== undefined) {
      Duration.encode(message.time_to_first_downstream_tx_byte, writer.uint32(90).fork()).join();
    }
    if (message.time_to_last_downstream_tx_byte !== undefined) {
      Duration.encode(message.time_to_last_downstream_tx_byte, writer.uint32(98).fork()).join();
    }
    if (message.upstream_remote_address !== undefined) {
      Address.encode(message.upstream_remote_address, writer.uint32(106).fork()).join();
    }
    if (message.upstream_local_address !== undefined) {
      Address.encode(message.upstream_local_address, writer.uint32(114).fork()).join();
    }
    if (message.upstream_cluster !== undefined && message.upstream_cluster !== "") {
      writer.uint32(122).string(message.upstream_cluster);
    }
    if (message.response_flags !== undefined) {
      ResponseFlags.encode(message.response_flags, writer.uint32(130).fork()).join();
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(138).fork()).join();
    }
    if (message.upstream_transport_failure_reason !== undefined && message.upstream_transport_failure_reason !== "") {
      writer.uint32(146).string(message.upstream_transport_failure_reason);
    }
    if (message.route_name !== undefined && message.route_name !== "") {
      writer.uint32(154).string(message.route_name);
    }
    if (message.downstream_direct_remote_address !== undefined) {
      Address.encode(message.downstream_direct_remote_address, writer.uint32(162).fork()).join();
    }
    (message.filter_state_objects || new Map()).forEach((value, key) => {
      AccessLogCommon_FilterStateObjectsEntry.encode({
        $type: "envoy.data.accesslog.v3.AccessLogCommon.FilterStateObjectsEntry",
        key: key as any,
        value,
      }, writer.uint32(170).fork()).join();
    });
    (message.custom_tags || new Map()).forEach((value, key) => {
      AccessLogCommon_CustomTagsEntry.encode({
        $type: "envoy.data.accesslog.v3.AccessLogCommon.CustomTagsEntry",
        key: key as any,
        value,
      }, writer.uint32(178).fork()).join();
    });
    if (message.duration !== undefined) {
      Duration.encode(message.duration, writer.uint32(186).fork()).join();
    }
    if (message.upstream_request_attempt_count !== undefined && message.upstream_request_attempt_count !== 0) {
      writer.uint32(192).uint32(message.upstream_request_attempt_count);
    }
    if (message.connection_termination_details !== undefined && message.connection_termination_details !== "") {
      writer.uint32(202).string(message.connection_termination_details);
    }
    if (message.stream_id !== undefined && message.stream_id !== "") {
      writer.uint32(210).string(message.stream_id);
    }
    if (message.intermediate_log_entry !== undefined && message.intermediate_log_entry !== false) {
      writer.uint32(216).bool(message.intermediate_log_entry);
    }
    if (
      message.downstream_transport_failure_reason !== undefined && message.downstream_transport_failure_reason !== ""
    ) {
      writer.uint32(226).string(message.downstream_transport_failure_reason);
    }
    if (message.downstream_wire_bytes_sent !== undefined && message.downstream_wire_bytes_sent !== 0) {
      writer.uint32(232).uint64(message.downstream_wire_bytes_sent);
    }
    if (message.downstream_wire_bytes_received !== undefined && message.downstream_wire_bytes_received !== 0) {
      writer.uint32(240).uint64(message.downstream_wire_bytes_received);
    }
    if (message.upstream_wire_bytes_sent !== undefined && message.upstream_wire_bytes_sent !== 0) {
      writer.uint32(248).uint64(message.upstream_wire_bytes_sent);
    }
    if (message.upstream_wire_bytes_received !== undefined && message.upstream_wire_bytes_received !== 0) {
      writer.uint32(256).uint64(message.upstream_wire_bytes_received);
    }
    if (message.access_log_type !== undefined && message.access_log_type !== AccessLogType.NotSet) {
      writer.uint32(264).int32(accessLogTypeToNumber(message.access_log_type));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessLogCommon {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessLogCommon();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.sample_rate = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.downstream_remote_address = Address.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.downstream_local_address = Address.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tls_properties = TLSProperties.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.start_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.time_to_last_rx_byte = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.time_to_first_upstream_tx_byte = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.time_to_last_upstream_tx_byte = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.time_to_first_upstream_rx_byte = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.time_to_last_upstream_rx_byte = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.time_to_first_downstream_tx_byte = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.time_to_last_downstream_tx_byte = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.upstream_remote_address = Address.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.upstream_local_address = Address.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.upstream_cluster = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.response_flags = ResponseFlags.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.upstream_transport_failure_reason = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.route_name = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.downstream_direct_remote_address = Address.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          const entry21 = AccessLogCommon_FilterStateObjectsEntry.decode(reader, reader.uint32());
          if (entry21.value !== undefined) {
            if (message.filter_state_objects === undefined) {
              message.filter_state_objects = new Map();
            }
            message.filter_state_objects!.set(entry21.key, entry21.value);
          }
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          const entry22 = AccessLogCommon_CustomTagsEntry.decode(reader, reader.uint32());
          if (entry22.value !== undefined) {
            if (message.custom_tags === undefined) {
              message.custom_tags = new Map();
            }
            message.custom_tags!.set(entry22.key, entry22.value);
          }
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.duration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.upstream_request_attempt_count = reader.uint32();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.connection_termination_details = reader.string();
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.stream_id = reader.string();
          continue;
        }
        case 27: {
          if (tag !== 216) {
            break;
          }

          message.intermediate_log_entry = reader.bool();
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.downstream_transport_failure_reason = reader.string();
          continue;
        }
        case 29: {
          if (tag !== 232) {
            break;
          }

          message.downstream_wire_bytes_sent = longToNumber(reader.uint64());
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }

          message.downstream_wire_bytes_received = longToNumber(reader.uint64());
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.upstream_wire_bytes_sent = longToNumber(reader.uint64());
          continue;
        }
        case 32: {
          if (tag !== 256) {
            break;
          }

          message.upstream_wire_bytes_received = longToNumber(reader.uint64());
          continue;
        }
        case 33: {
          if (tag !== 264) {
            break;
          }

          message.access_log_type = accessLogTypeFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessLogCommon {
    return {
      $type: AccessLogCommon.$type,
      sample_rate: isSet(object.sample_rate) ? globalThis.Number(object.sample_rate) : undefined,
      downstream_remote_address: isSet(object.downstream_remote_address)
        ? Address.fromJSON(object.downstream_remote_address)
        : undefined,
      downstream_local_address: isSet(object.downstream_local_address)
        ? Address.fromJSON(object.downstream_local_address)
        : undefined,
      tls_properties: isSet(object.tls_properties) ? TLSProperties.fromJSON(object.tls_properties) : undefined,
      start_time: isSet(object.start_time) ? fromJsonTimestamp(object.start_time) : undefined,
      time_to_last_rx_byte: isSet(object.time_to_last_rx_byte)
        ? Duration.fromJSON(object.time_to_last_rx_byte)
        : undefined,
      time_to_first_upstream_tx_byte: isSet(object.time_to_first_upstream_tx_byte)
        ? Duration.fromJSON(object.time_to_first_upstream_tx_byte)
        : undefined,
      time_to_last_upstream_tx_byte: isSet(object.time_to_last_upstream_tx_byte)
        ? Duration.fromJSON(object.time_to_last_upstream_tx_byte)
        : undefined,
      time_to_first_upstream_rx_byte: isSet(object.time_to_first_upstream_rx_byte)
        ? Duration.fromJSON(object.time_to_first_upstream_rx_byte)
        : undefined,
      time_to_last_upstream_rx_byte: isSet(object.time_to_last_upstream_rx_byte)
        ? Duration.fromJSON(object.time_to_last_upstream_rx_byte)
        : undefined,
      time_to_first_downstream_tx_byte: isSet(object.time_to_first_downstream_tx_byte)
        ? Duration.fromJSON(object.time_to_first_downstream_tx_byte)
        : undefined,
      time_to_last_downstream_tx_byte: isSet(object.time_to_last_downstream_tx_byte)
        ? Duration.fromJSON(object.time_to_last_downstream_tx_byte)
        : undefined,
      upstream_remote_address: isSet(object.upstream_remote_address)
        ? Address.fromJSON(object.upstream_remote_address)
        : undefined,
      upstream_local_address: isSet(object.upstream_local_address)
        ? Address.fromJSON(object.upstream_local_address)
        : undefined,
      upstream_cluster: isSet(object.upstream_cluster) ? globalThis.String(object.upstream_cluster) : undefined,
      response_flags: isSet(object.response_flags) ? ResponseFlags.fromJSON(object.response_flags) : undefined,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      upstream_transport_failure_reason: isSet(object.upstream_transport_failure_reason)
        ? globalThis.String(object.upstream_transport_failure_reason)
        : undefined,
      route_name: isSet(object.route_name) ? globalThis.String(object.route_name) : undefined,
      downstream_direct_remote_address: isSet(object.downstream_direct_remote_address)
        ? Address.fromJSON(object.downstream_direct_remote_address)
        : undefined,
      filter_state_objects: isObject(object.filter_state_objects)
        ? Object.entries(object.filter_state_objects).reduce<Map<string, Any>>((acc, [key, value]) => {
          acc.set(key, Any.fromJSON(value));
          return acc;
        }, new Map())
        : undefined,
      custom_tags: isObject(object.custom_tags)
        ? Object.entries(object.custom_tags).reduce<Map<string, string>>((acc, [key, value]) => {
          acc.set(key, String(value));
          return acc;
        }, new Map())
        : undefined,
      duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined,
      upstream_request_attempt_count: isSet(object.upstream_request_attempt_count)
        ? globalThis.Number(object.upstream_request_attempt_count)
        : undefined,
      connection_termination_details: isSet(object.connection_termination_details)
        ? globalThis.String(object.connection_termination_details)
        : undefined,
      stream_id: isSet(object.stream_id) ? globalThis.String(object.stream_id) : undefined,
      intermediate_log_entry: isSet(object.intermediate_log_entry)
        ? globalThis.Boolean(object.intermediate_log_entry)
        : undefined,
      downstream_transport_failure_reason: isSet(object.downstream_transport_failure_reason)
        ? globalThis.String(object.downstream_transport_failure_reason)
        : undefined,
      downstream_wire_bytes_sent: isSet(object.downstream_wire_bytes_sent)
        ? globalThis.Number(object.downstream_wire_bytes_sent)
        : undefined,
      downstream_wire_bytes_received: isSet(object.downstream_wire_bytes_received)
        ? globalThis.Number(object.downstream_wire_bytes_received)
        : undefined,
      upstream_wire_bytes_sent: isSet(object.upstream_wire_bytes_sent)
        ? globalThis.Number(object.upstream_wire_bytes_sent)
        : undefined,
      upstream_wire_bytes_received: isSet(object.upstream_wire_bytes_received)
        ? globalThis.Number(object.upstream_wire_bytes_received)
        : undefined,
      access_log_type: isSet(object.access_log_type) ? accessLogTypeFromJSON(object.access_log_type) : undefined,
    };
  },

  toJSON(message: AccessLogCommon): unknown {
    const obj: any = {};
    if (message.sample_rate !== undefined) {
      obj.sample_rate = message.sample_rate;
    }
    if (message.downstream_remote_address !== undefined) {
      obj.downstream_remote_address = Address.toJSON(message.downstream_remote_address);
    }
    if (message.downstream_local_address !== undefined) {
      obj.downstream_local_address = Address.toJSON(message.downstream_local_address);
    }
    if (message.tls_properties !== undefined) {
      obj.tls_properties = TLSProperties.toJSON(message.tls_properties);
    }
    if (message.start_time !== undefined) {
      obj.start_time = message.start_time.toISOString();
    }
    if (message.time_to_last_rx_byte !== undefined) {
      obj.time_to_last_rx_byte = Duration.toJSON(message.time_to_last_rx_byte);
    }
    if (message.time_to_first_upstream_tx_byte !== undefined) {
      obj.time_to_first_upstream_tx_byte = Duration.toJSON(message.time_to_first_upstream_tx_byte);
    }
    if (message.time_to_last_upstream_tx_byte !== undefined) {
      obj.time_to_last_upstream_tx_byte = Duration.toJSON(message.time_to_last_upstream_tx_byte);
    }
    if (message.time_to_first_upstream_rx_byte !== undefined) {
      obj.time_to_first_upstream_rx_byte = Duration.toJSON(message.time_to_first_upstream_rx_byte);
    }
    if (message.time_to_last_upstream_rx_byte !== undefined) {
      obj.time_to_last_upstream_rx_byte = Duration.toJSON(message.time_to_last_upstream_rx_byte);
    }
    if (message.time_to_first_downstream_tx_byte !== undefined) {
      obj.time_to_first_downstream_tx_byte = Duration.toJSON(message.time_to_first_downstream_tx_byte);
    }
    if (message.time_to_last_downstream_tx_byte !== undefined) {
      obj.time_to_last_downstream_tx_byte = Duration.toJSON(message.time_to_last_downstream_tx_byte);
    }
    if (message.upstream_remote_address !== undefined) {
      obj.upstream_remote_address = Address.toJSON(message.upstream_remote_address);
    }
    if (message.upstream_local_address !== undefined) {
      obj.upstream_local_address = Address.toJSON(message.upstream_local_address);
    }
    if (message.upstream_cluster !== undefined) {
      obj.upstream_cluster = message.upstream_cluster;
    }
    if (message.response_flags !== undefined) {
      obj.response_flags = ResponseFlags.toJSON(message.response_flags);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.upstream_transport_failure_reason !== undefined) {
      obj.upstream_transport_failure_reason = message.upstream_transport_failure_reason;
    }
    if (message.route_name !== undefined) {
      obj.route_name = message.route_name;
    }
    if (message.downstream_direct_remote_address !== undefined) {
      obj.downstream_direct_remote_address = Address.toJSON(message.downstream_direct_remote_address);
    }
    if (message.filter_state_objects?.size) {
      obj.filter_state_objects = {};
      message.filter_state_objects.forEach((v, k) => {
        obj.filter_state_objects[k] = Any.toJSON(v);
      });
    }
    if (message.custom_tags?.size) {
      obj.custom_tags = {};
      message.custom_tags.forEach((v, k) => {
        obj.custom_tags[k] = v;
      });
    }
    if (message.duration !== undefined) {
      obj.duration = Duration.toJSON(message.duration);
    }
    if (message.upstream_request_attempt_count !== undefined) {
      obj.upstream_request_attempt_count = Math.round(message.upstream_request_attempt_count);
    }
    if (message.connection_termination_details !== undefined) {
      obj.connection_termination_details = message.connection_termination_details;
    }
    if (message.stream_id !== undefined) {
      obj.stream_id = message.stream_id;
    }
    if (message.intermediate_log_entry !== undefined) {
      obj.intermediate_log_entry = message.intermediate_log_entry;
    }
    if (message.downstream_transport_failure_reason !== undefined) {
      obj.downstream_transport_failure_reason = message.downstream_transport_failure_reason;
    }
    if (message.downstream_wire_bytes_sent !== undefined) {
      obj.downstream_wire_bytes_sent = Math.round(message.downstream_wire_bytes_sent);
    }
    if (message.downstream_wire_bytes_received !== undefined) {
      obj.downstream_wire_bytes_received = Math.round(message.downstream_wire_bytes_received);
    }
    if (message.upstream_wire_bytes_sent !== undefined) {
      obj.upstream_wire_bytes_sent = Math.round(message.upstream_wire_bytes_sent);
    }
    if (message.upstream_wire_bytes_received !== undefined) {
      obj.upstream_wire_bytes_received = Math.round(message.upstream_wire_bytes_received);
    }
    if (message.access_log_type !== undefined) {
      obj.access_log_type = accessLogTypeToJSON(message.access_log_type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccessLogCommon>, I>>(base?: I): AccessLogCommon {
    return AccessLogCommon.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccessLogCommon>, I>>(object: I): AccessLogCommon {
    const message = createBaseAccessLogCommon();
    message.sample_rate = object.sample_rate ?? undefined;
    message.downstream_remote_address =
      (object.downstream_remote_address !== undefined && object.downstream_remote_address !== null)
        ? Address.fromPartial(object.downstream_remote_address)
        : undefined;
    message.downstream_local_address =
      (object.downstream_local_address !== undefined && object.downstream_local_address !== null)
        ? Address.fromPartial(object.downstream_local_address)
        : undefined;
    message.tls_properties = (object.tls_properties !== undefined && object.tls_properties !== null)
      ? TLSProperties.fromPartial(object.tls_properties)
      : undefined;
    message.start_time = object.start_time ?? undefined;
    message.time_to_last_rx_byte = (object.time_to_last_rx_byte !== undefined && object.time_to_last_rx_byte !== null)
      ? Duration.fromPartial(object.time_to_last_rx_byte)
      : undefined;
    message.time_to_first_upstream_tx_byte =
      (object.time_to_first_upstream_tx_byte !== undefined && object.time_to_first_upstream_tx_byte !== null)
        ? Duration.fromPartial(object.time_to_first_upstream_tx_byte)
        : undefined;
    message.time_to_last_upstream_tx_byte =
      (object.time_to_last_upstream_tx_byte !== undefined && object.time_to_last_upstream_tx_byte !== null)
        ? Duration.fromPartial(object.time_to_last_upstream_tx_byte)
        : undefined;
    message.time_to_first_upstream_rx_byte =
      (object.time_to_first_upstream_rx_byte !== undefined && object.time_to_first_upstream_rx_byte !== null)
        ? Duration.fromPartial(object.time_to_first_upstream_rx_byte)
        : undefined;
    message.time_to_last_upstream_rx_byte =
      (object.time_to_last_upstream_rx_byte !== undefined && object.time_to_last_upstream_rx_byte !== null)
        ? Duration.fromPartial(object.time_to_last_upstream_rx_byte)
        : undefined;
    message.time_to_first_downstream_tx_byte =
      (object.time_to_first_downstream_tx_byte !== undefined && object.time_to_first_downstream_tx_byte !== null)
        ? Duration.fromPartial(object.time_to_first_downstream_tx_byte)
        : undefined;
    message.time_to_last_downstream_tx_byte =
      (object.time_to_last_downstream_tx_byte !== undefined && object.time_to_last_downstream_tx_byte !== null)
        ? Duration.fromPartial(object.time_to_last_downstream_tx_byte)
        : undefined;
    message.upstream_remote_address =
      (object.upstream_remote_address !== undefined && object.upstream_remote_address !== null)
        ? Address.fromPartial(object.upstream_remote_address)
        : undefined;
    message.upstream_local_address =
      (object.upstream_local_address !== undefined && object.upstream_local_address !== null)
        ? Address.fromPartial(object.upstream_local_address)
        : undefined;
    message.upstream_cluster = object.upstream_cluster ?? undefined;
    message.response_flags = (object.response_flags !== undefined && object.response_flags !== null)
      ? ResponseFlags.fromPartial(object.response_flags)
      : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.upstream_transport_failure_reason = object.upstream_transport_failure_reason ?? undefined;
    message.route_name = object.route_name ?? undefined;
    message.downstream_direct_remote_address =
      (object.downstream_direct_remote_address !== undefined && object.downstream_direct_remote_address !== null)
        ? Address.fromPartial(object.downstream_direct_remote_address)
        : undefined;
    message.filter_state_objects = (object.filter_state_objects === undefined || object.filter_state_objects === null)
      ? undefined
      : (() => {
        const m = new Map();
        (object.filter_state_objects as Map<string, Any> ?? new Map()).forEach((value, key) => {
          if (value !== undefined) {
            m.set(key, Any.fromPartial(value));
          }
        });
        return m;
      })();
    message.custom_tags = (object.custom_tags === undefined || object.custom_tags === null) ? undefined : (() => {
      const m = new Map();
      (object.custom_tags as Map<string, string> ?? new Map()).forEach((value, key) => {
        if (value !== undefined) {
          m.set(key, globalThis.String(value));
        }
      });
      return m;
    })();
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? Duration.fromPartial(object.duration)
      : undefined;
    message.upstream_request_attempt_count = object.upstream_request_attempt_count ?? undefined;
    message.connection_termination_details = object.connection_termination_details ?? undefined;
    message.stream_id = object.stream_id ?? undefined;
    message.intermediate_log_entry = object.intermediate_log_entry ?? undefined;
    message.downstream_transport_failure_reason = object.downstream_transport_failure_reason ?? undefined;
    message.downstream_wire_bytes_sent = object.downstream_wire_bytes_sent ?? undefined;
    message.downstream_wire_bytes_received = object.downstream_wire_bytes_received ?? undefined;
    message.upstream_wire_bytes_sent = object.upstream_wire_bytes_sent ?? undefined;
    message.upstream_wire_bytes_received = object.upstream_wire_bytes_received ?? undefined;
    message.access_log_type = object.access_log_type ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(AccessLogCommon.$type, AccessLogCommon);

function createBaseAccessLogCommon_FilterStateObjectsEntry(): AccessLogCommon_FilterStateObjectsEntry {
  return { $type: "envoy.data.accesslog.v3.AccessLogCommon.FilterStateObjectsEntry", key: "" };
}

export const AccessLogCommon_FilterStateObjectsEntry: MessageFns<
  AccessLogCommon_FilterStateObjectsEntry,
  "envoy.data.accesslog.v3.AccessLogCommon.FilterStateObjectsEntry"
> = {
  $type: "envoy.data.accesslog.v3.AccessLogCommon.FilterStateObjectsEntry" as const,

  encode(message: AccessLogCommon_FilterStateObjectsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Any.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessLogCommon_FilterStateObjectsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessLogCommon_FilterStateObjectsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessLogCommon_FilterStateObjectsEntry {
    return {
      $type: AccessLogCommon_FilterStateObjectsEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Any.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: AccessLogCommon_FilterStateObjectsEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Any.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccessLogCommon_FilterStateObjectsEntry>, I>>(
    base?: I,
  ): AccessLogCommon_FilterStateObjectsEntry {
    return AccessLogCommon_FilterStateObjectsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccessLogCommon_FilterStateObjectsEntry>, I>>(
    object: I,
  ): AccessLogCommon_FilterStateObjectsEntry {
    const message = createBaseAccessLogCommon_FilterStateObjectsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Any.fromPartial(object.value) : undefined;
    return message;
  },
};

messageTypeRegistry.set(AccessLogCommon_FilterStateObjectsEntry.$type, AccessLogCommon_FilterStateObjectsEntry);

function createBaseAccessLogCommon_CustomTagsEntry(): AccessLogCommon_CustomTagsEntry {
  return { $type: "envoy.data.accesslog.v3.AccessLogCommon.CustomTagsEntry", key: "", value: "" };
}

export const AccessLogCommon_CustomTagsEntry: MessageFns<
  AccessLogCommon_CustomTagsEntry,
  "envoy.data.accesslog.v3.AccessLogCommon.CustomTagsEntry"
> = {
  $type: "envoy.data.accesslog.v3.AccessLogCommon.CustomTagsEntry" as const,

  encode(message: AccessLogCommon_CustomTagsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessLogCommon_CustomTagsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessLogCommon_CustomTagsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessLogCommon_CustomTagsEntry {
    return {
      $type: AccessLogCommon_CustomTagsEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AccessLogCommon_CustomTagsEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccessLogCommon_CustomTagsEntry>, I>>(base?: I): AccessLogCommon_CustomTagsEntry {
    return AccessLogCommon_CustomTagsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccessLogCommon_CustomTagsEntry>, I>>(
    object: I,
  ): AccessLogCommon_CustomTagsEntry {
    const message = createBaseAccessLogCommon_CustomTagsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

messageTypeRegistry.set(AccessLogCommon_CustomTagsEntry.$type, AccessLogCommon_CustomTagsEntry);

function createBaseResponseFlags(): ResponseFlags {
  return { $type: "envoy.data.accesslog.v3.ResponseFlags" };
}

export const ResponseFlags: MessageFns<ResponseFlags, "envoy.data.accesslog.v3.ResponseFlags"> = {
  $type: "envoy.data.accesslog.v3.ResponseFlags" as const,

  encode(message: ResponseFlags, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.failed_local_healthcheck !== undefined && message.failed_local_healthcheck !== false) {
      writer.uint32(8).bool(message.failed_local_healthcheck);
    }
    if (message.no_healthy_upstream !== undefined && message.no_healthy_upstream !== false) {
      writer.uint32(16).bool(message.no_healthy_upstream);
    }
    if (message.upstream_request_timeout !== undefined && message.upstream_request_timeout !== false) {
      writer.uint32(24).bool(message.upstream_request_timeout);
    }
    if (message.local_reset !== undefined && message.local_reset !== false) {
      writer.uint32(32).bool(message.local_reset);
    }
    if (message.upstream_remote_reset !== undefined && message.upstream_remote_reset !== false) {
      writer.uint32(40).bool(message.upstream_remote_reset);
    }
    if (message.upstream_connection_failure !== undefined && message.upstream_connection_failure !== false) {
      writer.uint32(48).bool(message.upstream_connection_failure);
    }
    if (message.upstream_connection_termination !== undefined && message.upstream_connection_termination !== false) {
      writer.uint32(56).bool(message.upstream_connection_termination);
    }
    if (message.upstream_overflow !== undefined && message.upstream_overflow !== false) {
      writer.uint32(64).bool(message.upstream_overflow);
    }
    if (message.no_route_found !== undefined && message.no_route_found !== false) {
      writer.uint32(72).bool(message.no_route_found);
    }
    if (message.delay_injected !== undefined && message.delay_injected !== false) {
      writer.uint32(80).bool(message.delay_injected);
    }
    if (message.fault_injected !== undefined && message.fault_injected !== false) {
      writer.uint32(88).bool(message.fault_injected);
    }
    if (message.rate_limited !== undefined && message.rate_limited !== false) {
      writer.uint32(96).bool(message.rate_limited);
    }
    if (message.unauthorized_details !== undefined) {
      ResponseFlags_Unauthorized.encode(message.unauthorized_details, writer.uint32(106).fork()).join();
    }
    if (message.rate_limit_service_error !== undefined && message.rate_limit_service_error !== false) {
      writer.uint32(112).bool(message.rate_limit_service_error);
    }
    if (
      message.downstream_connection_termination !== undefined && message.downstream_connection_termination !== false
    ) {
      writer.uint32(120).bool(message.downstream_connection_termination);
    }
    if (message.upstream_retry_limit_exceeded !== undefined && message.upstream_retry_limit_exceeded !== false) {
      writer.uint32(128).bool(message.upstream_retry_limit_exceeded);
    }
    if (message.stream_idle_timeout !== undefined && message.stream_idle_timeout !== false) {
      writer.uint32(136).bool(message.stream_idle_timeout);
    }
    if (message.invalid_envoy_request_headers !== undefined && message.invalid_envoy_request_headers !== false) {
      writer.uint32(144).bool(message.invalid_envoy_request_headers);
    }
    if (message.downstream_protocol_error !== undefined && message.downstream_protocol_error !== false) {
      writer.uint32(152).bool(message.downstream_protocol_error);
    }
    if (
      message.upstream_max_stream_duration_reached !== undefined &&
      message.upstream_max_stream_duration_reached !== false
    ) {
      writer.uint32(160).bool(message.upstream_max_stream_duration_reached);
    }
    if (message.response_from_cache_filter !== undefined && message.response_from_cache_filter !== false) {
      writer.uint32(168).bool(message.response_from_cache_filter);
    }
    if (message.no_filter_config_found !== undefined && message.no_filter_config_found !== false) {
      writer.uint32(176).bool(message.no_filter_config_found);
    }
    if (message.duration_timeout !== undefined && message.duration_timeout !== false) {
      writer.uint32(184).bool(message.duration_timeout);
    }
    if (message.upstream_protocol_error !== undefined && message.upstream_protocol_error !== false) {
      writer.uint32(192).bool(message.upstream_protocol_error);
    }
    if (message.no_cluster_found !== undefined && message.no_cluster_found !== false) {
      writer.uint32(200).bool(message.no_cluster_found);
    }
    if (message.overload_manager !== undefined && message.overload_manager !== false) {
      writer.uint32(208).bool(message.overload_manager);
    }
    if (message.dns_resolution_failure !== undefined && message.dns_resolution_failure !== false) {
      writer.uint32(216).bool(message.dns_resolution_failure);
    }
    if (message.downstream_remote_reset !== undefined && message.downstream_remote_reset !== false) {
      writer.uint32(224).bool(message.downstream_remote_reset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResponseFlags {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseFlags();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.failed_local_healthcheck = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.no_healthy_upstream = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.upstream_request_timeout = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.local_reset = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.upstream_remote_reset = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.upstream_connection_failure = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.upstream_connection_termination = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.upstream_overflow = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.no_route_found = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.delay_injected = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.fault_injected = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.rate_limited = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.unauthorized_details = ResponseFlags_Unauthorized.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.rate_limit_service_error = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.downstream_connection_termination = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.upstream_retry_limit_exceeded = reader.bool();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.stream_idle_timeout = reader.bool();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.invalid_envoy_request_headers = reader.bool();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.downstream_protocol_error = reader.bool();
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.upstream_max_stream_duration_reached = reader.bool();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.response_from_cache_filter = reader.bool();
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.no_filter_config_found = reader.bool();
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }

          message.duration_timeout = reader.bool();
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.upstream_protocol_error = reader.bool();
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.no_cluster_found = reader.bool();
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.overload_manager = reader.bool();
          continue;
        }
        case 27: {
          if (tag !== 216) {
            break;
          }

          message.dns_resolution_failure = reader.bool();
          continue;
        }
        case 28: {
          if (tag !== 224) {
            break;
          }

          message.downstream_remote_reset = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResponseFlags {
    return {
      $type: ResponseFlags.$type,
      failed_local_healthcheck: isSet(object.failed_local_healthcheck)
        ? globalThis.Boolean(object.failed_local_healthcheck)
        : undefined,
      no_healthy_upstream: isSet(object.no_healthy_upstream)
        ? globalThis.Boolean(object.no_healthy_upstream)
        : undefined,
      upstream_request_timeout: isSet(object.upstream_request_timeout)
        ? globalThis.Boolean(object.upstream_request_timeout)
        : undefined,
      local_reset: isSet(object.local_reset) ? globalThis.Boolean(object.local_reset) : undefined,
      upstream_remote_reset: isSet(object.upstream_remote_reset)
        ? globalThis.Boolean(object.upstream_remote_reset)
        : undefined,
      upstream_connection_failure: isSet(object.upstream_connection_failure)
        ? globalThis.Boolean(object.upstream_connection_failure)
        : undefined,
      upstream_connection_termination: isSet(object.upstream_connection_termination)
        ? globalThis.Boolean(object.upstream_connection_termination)
        : undefined,
      upstream_overflow: isSet(object.upstream_overflow) ? globalThis.Boolean(object.upstream_overflow) : undefined,
      no_route_found: isSet(object.no_route_found) ? globalThis.Boolean(object.no_route_found) : undefined,
      delay_injected: isSet(object.delay_injected) ? globalThis.Boolean(object.delay_injected) : undefined,
      fault_injected: isSet(object.fault_injected) ? globalThis.Boolean(object.fault_injected) : undefined,
      rate_limited: isSet(object.rate_limited) ? globalThis.Boolean(object.rate_limited) : undefined,
      unauthorized_details: isSet(object.unauthorized_details)
        ? ResponseFlags_Unauthorized.fromJSON(object.unauthorized_details)
        : undefined,
      rate_limit_service_error: isSet(object.rate_limit_service_error)
        ? globalThis.Boolean(object.rate_limit_service_error)
        : undefined,
      downstream_connection_termination: isSet(object.downstream_connection_termination)
        ? globalThis.Boolean(object.downstream_connection_termination)
        : undefined,
      upstream_retry_limit_exceeded: isSet(object.upstream_retry_limit_exceeded)
        ? globalThis.Boolean(object.upstream_retry_limit_exceeded)
        : undefined,
      stream_idle_timeout: isSet(object.stream_idle_timeout)
        ? globalThis.Boolean(object.stream_idle_timeout)
        : undefined,
      invalid_envoy_request_headers: isSet(object.invalid_envoy_request_headers)
        ? globalThis.Boolean(object.invalid_envoy_request_headers)
        : undefined,
      downstream_protocol_error: isSet(object.downstream_protocol_error)
        ? globalThis.Boolean(object.downstream_protocol_error)
        : undefined,
      upstream_max_stream_duration_reached: isSet(object.upstream_max_stream_duration_reached)
        ? globalThis.Boolean(object.upstream_max_stream_duration_reached)
        : undefined,
      response_from_cache_filter: isSet(object.response_from_cache_filter)
        ? globalThis.Boolean(object.response_from_cache_filter)
        : undefined,
      no_filter_config_found: isSet(object.no_filter_config_found)
        ? globalThis.Boolean(object.no_filter_config_found)
        : undefined,
      duration_timeout: isSet(object.duration_timeout) ? globalThis.Boolean(object.duration_timeout) : undefined,
      upstream_protocol_error: isSet(object.upstream_protocol_error)
        ? globalThis.Boolean(object.upstream_protocol_error)
        : undefined,
      no_cluster_found: isSet(object.no_cluster_found) ? globalThis.Boolean(object.no_cluster_found) : undefined,
      overload_manager: isSet(object.overload_manager) ? globalThis.Boolean(object.overload_manager) : undefined,
      dns_resolution_failure: isSet(object.dns_resolution_failure)
        ? globalThis.Boolean(object.dns_resolution_failure)
        : undefined,
      downstream_remote_reset: isSet(object.downstream_remote_reset)
        ? globalThis.Boolean(object.downstream_remote_reset)
        : undefined,
    };
  },

  toJSON(message: ResponseFlags): unknown {
    const obj: any = {};
    if (message.failed_local_healthcheck !== undefined) {
      obj.failed_local_healthcheck = message.failed_local_healthcheck;
    }
    if (message.no_healthy_upstream !== undefined) {
      obj.no_healthy_upstream = message.no_healthy_upstream;
    }
    if (message.upstream_request_timeout !== undefined) {
      obj.upstream_request_timeout = message.upstream_request_timeout;
    }
    if (message.local_reset !== undefined) {
      obj.local_reset = message.local_reset;
    }
    if (message.upstream_remote_reset !== undefined) {
      obj.upstream_remote_reset = message.upstream_remote_reset;
    }
    if (message.upstream_connection_failure !== undefined) {
      obj.upstream_connection_failure = message.upstream_connection_failure;
    }
    if (message.upstream_connection_termination !== undefined) {
      obj.upstream_connection_termination = message.upstream_connection_termination;
    }
    if (message.upstream_overflow !== undefined) {
      obj.upstream_overflow = message.upstream_overflow;
    }
    if (message.no_route_found !== undefined) {
      obj.no_route_found = message.no_route_found;
    }
    if (message.delay_injected !== undefined) {
      obj.delay_injected = message.delay_injected;
    }
    if (message.fault_injected !== undefined) {
      obj.fault_injected = message.fault_injected;
    }
    if (message.rate_limited !== undefined) {
      obj.rate_limited = message.rate_limited;
    }
    if (message.unauthorized_details !== undefined) {
      obj.unauthorized_details = ResponseFlags_Unauthorized.toJSON(message.unauthorized_details);
    }
    if (message.rate_limit_service_error !== undefined) {
      obj.rate_limit_service_error = message.rate_limit_service_error;
    }
    if (message.downstream_connection_termination !== undefined) {
      obj.downstream_connection_termination = message.downstream_connection_termination;
    }
    if (message.upstream_retry_limit_exceeded !== undefined) {
      obj.upstream_retry_limit_exceeded = message.upstream_retry_limit_exceeded;
    }
    if (message.stream_idle_timeout !== undefined) {
      obj.stream_idle_timeout = message.stream_idle_timeout;
    }
    if (message.invalid_envoy_request_headers !== undefined) {
      obj.invalid_envoy_request_headers = message.invalid_envoy_request_headers;
    }
    if (message.downstream_protocol_error !== undefined) {
      obj.downstream_protocol_error = message.downstream_protocol_error;
    }
    if (message.upstream_max_stream_duration_reached !== undefined) {
      obj.upstream_max_stream_duration_reached = message.upstream_max_stream_duration_reached;
    }
    if (message.response_from_cache_filter !== undefined) {
      obj.response_from_cache_filter = message.response_from_cache_filter;
    }
    if (message.no_filter_config_found !== undefined) {
      obj.no_filter_config_found = message.no_filter_config_found;
    }
    if (message.duration_timeout !== undefined) {
      obj.duration_timeout = message.duration_timeout;
    }
    if (message.upstream_protocol_error !== undefined) {
      obj.upstream_protocol_error = message.upstream_protocol_error;
    }
    if (message.no_cluster_found !== undefined) {
      obj.no_cluster_found = message.no_cluster_found;
    }
    if (message.overload_manager !== undefined) {
      obj.overload_manager = message.overload_manager;
    }
    if (message.dns_resolution_failure !== undefined) {
      obj.dns_resolution_failure = message.dns_resolution_failure;
    }
    if (message.downstream_remote_reset !== undefined) {
      obj.downstream_remote_reset = message.downstream_remote_reset;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResponseFlags>, I>>(base?: I): ResponseFlags {
    return ResponseFlags.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResponseFlags>, I>>(object: I): ResponseFlags {
    const message = createBaseResponseFlags();
    message.failed_local_healthcheck = object.failed_local_healthcheck ?? undefined;
    message.no_healthy_upstream = object.no_healthy_upstream ?? undefined;
    message.upstream_request_timeout = object.upstream_request_timeout ?? undefined;
    message.local_reset = object.local_reset ?? undefined;
    message.upstream_remote_reset = object.upstream_remote_reset ?? undefined;
    message.upstream_connection_failure = object.upstream_connection_failure ?? undefined;
    message.upstream_connection_termination = object.upstream_connection_termination ?? undefined;
    message.upstream_overflow = object.upstream_overflow ?? undefined;
    message.no_route_found = object.no_route_found ?? undefined;
    message.delay_injected = object.delay_injected ?? undefined;
    message.fault_injected = object.fault_injected ?? undefined;
    message.rate_limited = object.rate_limited ?? undefined;
    message.unauthorized_details = (object.unauthorized_details !== undefined && object.unauthorized_details !== null)
      ? ResponseFlags_Unauthorized.fromPartial(object.unauthorized_details)
      : undefined;
    message.rate_limit_service_error = object.rate_limit_service_error ?? undefined;
    message.downstream_connection_termination = object.downstream_connection_termination ?? undefined;
    message.upstream_retry_limit_exceeded = object.upstream_retry_limit_exceeded ?? undefined;
    message.stream_idle_timeout = object.stream_idle_timeout ?? undefined;
    message.invalid_envoy_request_headers = object.invalid_envoy_request_headers ?? undefined;
    message.downstream_protocol_error = object.downstream_protocol_error ?? undefined;
    message.upstream_max_stream_duration_reached = object.upstream_max_stream_duration_reached ?? undefined;
    message.response_from_cache_filter = object.response_from_cache_filter ?? undefined;
    message.no_filter_config_found = object.no_filter_config_found ?? undefined;
    message.duration_timeout = object.duration_timeout ?? undefined;
    message.upstream_protocol_error = object.upstream_protocol_error ?? undefined;
    message.no_cluster_found = object.no_cluster_found ?? undefined;
    message.overload_manager = object.overload_manager ?? undefined;
    message.dns_resolution_failure = object.dns_resolution_failure ?? undefined;
    message.downstream_remote_reset = object.downstream_remote_reset ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ResponseFlags.$type, ResponseFlags);

function createBaseResponseFlags_Unauthorized(): ResponseFlags_Unauthorized {
  return { $type: "envoy.data.accesslog.v3.ResponseFlags.Unauthorized" };
}

export const ResponseFlags_Unauthorized: MessageFns<
  ResponseFlags_Unauthorized,
  "envoy.data.accesslog.v3.ResponseFlags.Unauthorized"
> = {
  $type: "envoy.data.accesslog.v3.ResponseFlags.Unauthorized" as const,

  encode(message: ResponseFlags_Unauthorized, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reason !== undefined && message.reason !== ResponseFlags_Unauthorized_Reason.REASON_UNSPECIFIED) {
      writer.uint32(8).int32(responseFlags_Unauthorized_ReasonToNumber(message.reason));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResponseFlags_Unauthorized {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseFlags_Unauthorized();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.reason = responseFlags_Unauthorized_ReasonFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResponseFlags_Unauthorized {
    return {
      $type: ResponseFlags_Unauthorized.$type,
      reason: isSet(object.reason) ? responseFlags_Unauthorized_ReasonFromJSON(object.reason) : undefined,
    };
  },

  toJSON(message: ResponseFlags_Unauthorized): unknown {
    const obj: any = {};
    if (message.reason !== undefined) {
      obj.reason = responseFlags_Unauthorized_ReasonToJSON(message.reason);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResponseFlags_Unauthorized>, I>>(base?: I): ResponseFlags_Unauthorized {
    return ResponseFlags_Unauthorized.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResponseFlags_Unauthorized>, I>>(object: I): ResponseFlags_Unauthorized {
    const message = createBaseResponseFlags_Unauthorized();
    message.reason = object.reason ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ResponseFlags_Unauthorized.$type, ResponseFlags_Unauthorized);

function createBaseTLSProperties(): TLSProperties {
  return { $type: "envoy.data.accesslog.v3.TLSProperties" };
}

export const TLSProperties: MessageFns<TLSProperties, "envoy.data.accesslog.v3.TLSProperties"> = {
  $type: "envoy.data.accesslog.v3.TLSProperties" as const,

  encode(message: TLSProperties, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tls_version !== undefined && message.tls_version !== TLSProperties_TLSVersion.VERSION_UNSPECIFIED) {
      writer.uint32(8).int32(tLSProperties_TLSVersionToNumber(message.tls_version));
    }
    if (message.tls_cipher_suite !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.tls_cipher_suite! },
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.tls_sni_hostname !== undefined && message.tls_sni_hostname !== "") {
      writer.uint32(26).string(message.tls_sni_hostname);
    }
    if (message.local_certificate_properties !== undefined) {
      TLSProperties_CertificateProperties.encode(message.local_certificate_properties, writer.uint32(34).fork()).join();
    }
    if (message.peer_certificate_properties !== undefined) {
      TLSProperties_CertificateProperties.encode(message.peer_certificate_properties, writer.uint32(42).fork()).join();
    }
    if (message.tls_session_id !== undefined && message.tls_session_id !== "") {
      writer.uint32(50).string(message.tls_session_id);
    }
    if (message.ja3_fingerprint !== undefined && message.ja3_fingerprint !== "") {
      writer.uint32(58).string(message.ja3_fingerprint);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TLSProperties {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTLSProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.tls_version = tLSProperties_TLSVersionFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tls_cipher_suite = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tls_sni_hostname = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.local_certificate_properties = TLSProperties_CertificateProperties.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.peer_certificate_properties = TLSProperties_CertificateProperties.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.tls_session_id = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.ja3_fingerprint = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TLSProperties {
    return {
      $type: TLSProperties.$type,
      tls_version: isSet(object.tls_version) ? tLSProperties_TLSVersionFromJSON(object.tls_version) : undefined,
      tls_cipher_suite: isSet(object.tls_cipher_suite) ? Number(object.tls_cipher_suite) : undefined,
      tls_sni_hostname: isSet(object.tls_sni_hostname) ? globalThis.String(object.tls_sni_hostname) : undefined,
      local_certificate_properties: isSet(object.local_certificate_properties)
        ? TLSProperties_CertificateProperties.fromJSON(object.local_certificate_properties)
        : undefined,
      peer_certificate_properties: isSet(object.peer_certificate_properties)
        ? TLSProperties_CertificateProperties.fromJSON(object.peer_certificate_properties)
        : undefined,
      tls_session_id: isSet(object.tls_session_id) ? globalThis.String(object.tls_session_id) : undefined,
      ja3_fingerprint: isSet(object.ja3_fingerprint) ? globalThis.String(object.ja3_fingerprint) : undefined,
    };
  },

  toJSON(message: TLSProperties): unknown {
    const obj: any = {};
    if (message.tls_version !== undefined) {
      obj.tls_version = tLSProperties_TLSVersionToJSON(message.tls_version);
    }
    if (message.tls_cipher_suite !== undefined) {
      obj.tls_cipher_suite = message.tls_cipher_suite;
    }
    if (message.tls_sni_hostname !== undefined) {
      obj.tls_sni_hostname = message.tls_sni_hostname;
    }
    if (message.local_certificate_properties !== undefined) {
      obj.local_certificate_properties = TLSProperties_CertificateProperties.toJSON(
        message.local_certificate_properties,
      );
    }
    if (message.peer_certificate_properties !== undefined) {
      obj.peer_certificate_properties = TLSProperties_CertificateProperties.toJSON(message.peer_certificate_properties);
    }
    if (message.tls_session_id !== undefined) {
      obj.tls_session_id = message.tls_session_id;
    }
    if (message.ja3_fingerprint !== undefined) {
      obj.ja3_fingerprint = message.ja3_fingerprint;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TLSProperties>, I>>(base?: I): TLSProperties {
    return TLSProperties.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TLSProperties>, I>>(object: I): TLSProperties {
    const message = createBaseTLSProperties();
    message.tls_version = object.tls_version ?? undefined;
    message.tls_cipher_suite = object.tls_cipher_suite ?? undefined;
    message.tls_sni_hostname = object.tls_sni_hostname ?? undefined;
    message.local_certificate_properties =
      (object.local_certificate_properties !== undefined && object.local_certificate_properties !== null)
        ? TLSProperties_CertificateProperties.fromPartial(object.local_certificate_properties)
        : undefined;
    message.peer_certificate_properties =
      (object.peer_certificate_properties !== undefined && object.peer_certificate_properties !== null)
        ? TLSProperties_CertificateProperties.fromPartial(object.peer_certificate_properties)
        : undefined;
    message.tls_session_id = object.tls_session_id ?? undefined;
    message.ja3_fingerprint = object.ja3_fingerprint ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(TLSProperties.$type, TLSProperties);

function createBaseTLSProperties_CertificateProperties(): TLSProperties_CertificateProperties {
  return { $type: "envoy.data.accesslog.v3.TLSProperties.CertificateProperties" };
}

export const TLSProperties_CertificateProperties: MessageFns<
  TLSProperties_CertificateProperties,
  "envoy.data.accesslog.v3.TLSProperties.CertificateProperties"
> = {
  $type: "envoy.data.accesslog.v3.TLSProperties.CertificateProperties" as const,

  encode(message: TLSProperties_CertificateProperties, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subject_alt_name !== undefined && message.subject_alt_name.length !== 0) {
      for (const v of message.subject_alt_name) {
        TLSProperties_CertificateProperties_SubjectAltName.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    if (message.subject !== undefined && message.subject !== "") {
      writer.uint32(18).string(message.subject);
    }
    if (message.issuer !== undefined && message.issuer !== "") {
      writer.uint32(26).string(message.issuer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TLSProperties_CertificateProperties {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTLSProperties_CertificateProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.subject_alt_name === undefined) {
            message.subject_alt_name = [];
          }
          const el = TLSProperties_CertificateProperties_SubjectAltName.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.subject_alt_name!.push(el);
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.subject = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.issuer = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TLSProperties_CertificateProperties {
    return {
      $type: TLSProperties_CertificateProperties.$type,
      subject_alt_name: globalThis.Array.isArray(object?.subject_alt_name)
        ? object.subject_alt_name.map((e: any) => TLSProperties_CertificateProperties_SubjectAltName.fromJSON(e))
        : undefined,
      subject: isSet(object.subject) ? globalThis.String(object.subject) : undefined,
      issuer: isSet(object.issuer) ? globalThis.String(object.issuer) : undefined,
    };
  },

  toJSON(message: TLSProperties_CertificateProperties): unknown {
    const obj: any = {};
    if (message.subject_alt_name?.length) {
      obj.subject_alt_name = message.subject_alt_name.map((e) =>
        TLSProperties_CertificateProperties_SubjectAltName.toJSON(e)
      );
    }
    if (message.subject !== undefined) {
      obj.subject = message.subject;
    }
    if (message.issuer !== undefined) {
      obj.issuer = message.issuer;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TLSProperties_CertificateProperties>, I>>(
    base?: I,
  ): TLSProperties_CertificateProperties {
    return TLSProperties_CertificateProperties.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TLSProperties_CertificateProperties>, I>>(
    object: I,
  ): TLSProperties_CertificateProperties {
    const message = createBaseTLSProperties_CertificateProperties();
    message.subject_alt_name =
      object.subject_alt_name?.map((e) => TLSProperties_CertificateProperties_SubjectAltName.fromPartial(e)) ||
      undefined;
    message.subject = object.subject ?? undefined;
    message.issuer = object.issuer ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(TLSProperties_CertificateProperties.$type, TLSProperties_CertificateProperties);

function createBaseTLSProperties_CertificateProperties_SubjectAltName(): TLSProperties_CertificateProperties_SubjectAltName {
  return { $type: "envoy.data.accesslog.v3.TLSProperties.CertificateProperties.SubjectAltName", san: undefined };
}

export const TLSProperties_CertificateProperties_SubjectAltName: MessageFns<
  TLSProperties_CertificateProperties_SubjectAltName,
  "envoy.data.accesslog.v3.TLSProperties.CertificateProperties.SubjectAltName"
> = {
  $type: "envoy.data.accesslog.v3.TLSProperties.CertificateProperties.SubjectAltName" as const,

  encode(
    message: TLSProperties_CertificateProperties_SubjectAltName,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    switch (message.san?.$case) {
      case "uri":
        writer.uint32(10).string(message.san.uri);
        break;
      case "dns":
        writer.uint32(18).string(message.san.dns);
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TLSProperties_CertificateProperties_SubjectAltName {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTLSProperties_CertificateProperties_SubjectAltName();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.san = { $case: "uri", uri: reader.string() };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.san = { $case: "dns", dns: reader.string() };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TLSProperties_CertificateProperties_SubjectAltName {
    return {
      $type: TLSProperties_CertificateProperties_SubjectAltName.$type,
      san: isSet(object.uri)
        ? { $case: "uri", uri: globalThis.String(object.uri) }
        : isSet(object.dns)
        ? { $case: "dns", dns: globalThis.String(object.dns) }
        : undefined,
    };
  },

  toJSON(message: TLSProperties_CertificateProperties_SubjectAltName): unknown {
    const obj: any = {};
    if (message.san?.$case === "uri") {
      obj.uri = message.san.uri;
    }
    if (message.san?.$case === "dns") {
      obj.dns = message.san.dns;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TLSProperties_CertificateProperties_SubjectAltName>, I>>(
    base?: I,
  ): TLSProperties_CertificateProperties_SubjectAltName {
    return TLSProperties_CertificateProperties_SubjectAltName.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TLSProperties_CertificateProperties_SubjectAltName>, I>>(
    object: I,
  ): TLSProperties_CertificateProperties_SubjectAltName {
    const message = createBaseTLSProperties_CertificateProperties_SubjectAltName();
    if (object.san?.$case === "uri" && object.san?.uri !== undefined && object.san?.uri !== null) {
      message.san = { $case: "uri", uri: object.san.uri };
    }
    if (object.san?.$case === "dns" && object.san?.dns !== undefined && object.san?.dns !== null) {
      message.san = { $case: "dns", dns: object.san.dns };
    }
    return message;
  },
};

messageTypeRegistry.set(
  TLSProperties_CertificateProperties_SubjectAltName.$type,
  TLSProperties_CertificateProperties_SubjectAltName,
);

function createBaseHTTPRequestProperties(): HTTPRequestProperties {
  return { $type: "envoy.data.accesslog.v3.HTTPRequestProperties" };
}

export const HTTPRequestProperties: MessageFns<HTTPRequestProperties, "envoy.data.accesslog.v3.HTTPRequestProperties"> =
  {
    $type: "envoy.data.accesslog.v3.HTTPRequestProperties" as const,

    encode(message: HTTPRequestProperties, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
      if (message.request_method !== undefined && message.request_method !== RequestMethod.METHOD_UNSPECIFIED) {
        writer.uint32(8).int32(requestMethodToNumber(message.request_method));
      }
      if (message.scheme !== undefined && message.scheme !== "") {
        writer.uint32(18).string(message.scheme);
      }
      if (message.authority !== undefined && message.authority !== "") {
        writer.uint32(26).string(message.authority);
      }
      if (message.port !== undefined) {
        UInt32Value.encode({ $type: "google.protobuf.UInt32Value", value: message.port! }, writer.uint32(34).fork())
          .join();
      }
      if (message.path !== undefined && message.path !== "") {
        writer.uint32(42).string(message.path);
      }
      if (message.user_agent !== undefined && message.user_agent !== "") {
        writer.uint32(50).string(message.user_agent);
      }
      if (message.referer !== undefined && message.referer !== "") {
        writer.uint32(58).string(message.referer);
      }
      if (message.forwarded_for !== undefined && message.forwarded_for !== "") {
        writer.uint32(66).string(message.forwarded_for);
      }
      if (message.request_id !== undefined && message.request_id !== "") {
        writer.uint32(74).string(message.request_id);
      }
      if (message.original_path !== undefined && message.original_path !== "") {
        writer.uint32(82).string(message.original_path);
      }
      if (message.request_headers_bytes !== undefined && message.request_headers_bytes !== 0) {
        writer.uint32(88).uint64(message.request_headers_bytes);
      }
      if (message.request_body_bytes !== undefined && message.request_body_bytes !== 0) {
        writer.uint32(96).uint64(message.request_body_bytes);
      }
      (message.request_headers || new Map()).forEach((value, key) => {
        HTTPRequestProperties_RequestHeadersEntry.encode({
          $type: "envoy.data.accesslog.v3.HTTPRequestProperties.RequestHeadersEntry",
          key: key as any,
          value,
        }, writer.uint32(106).fork()).join();
      });
      if (message.upstream_header_bytes_sent !== undefined && message.upstream_header_bytes_sent !== 0) {
        writer.uint32(112).uint64(message.upstream_header_bytes_sent);
      }
      if (message.downstream_header_bytes_received !== undefined && message.downstream_header_bytes_received !== 0) {
        writer.uint32(120).uint64(message.downstream_header_bytes_received);
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): HTTPRequestProperties {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseHTTPRequestProperties();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.request_method = requestMethodFromJSON(reader.int32());
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.scheme = reader.string();
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.authority = reader.string();
            continue;
          }
          case 4: {
            if (tag !== 34) {
              break;
            }

            message.port = UInt32Value.decode(reader, reader.uint32()).value;
            continue;
          }
          case 5: {
            if (tag !== 42) {
              break;
            }

            message.path = reader.string();
            continue;
          }
          case 6: {
            if (tag !== 50) {
              break;
            }

            message.user_agent = reader.string();
            continue;
          }
          case 7: {
            if (tag !== 58) {
              break;
            }

            message.referer = reader.string();
            continue;
          }
          case 8: {
            if (tag !== 66) {
              break;
            }

            message.forwarded_for = reader.string();
            continue;
          }
          case 9: {
            if (tag !== 74) {
              break;
            }

            message.request_id = reader.string();
            continue;
          }
          case 10: {
            if (tag !== 82) {
              break;
            }

            message.original_path = reader.string();
            continue;
          }
          case 11: {
            if (tag !== 88) {
              break;
            }

            message.request_headers_bytes = longToNumber(reader.uint64());
            continue;
          }
          case 12: {
            if (tag !== 96) {
              break;
            }

            message.request_body_bytes = longToNumber(reader.uint64());
            continue;
          }
          case 13: {
            if (tag !== 106) {
              break;
            }

            const entry13 = HTTPRequestProperties_RequestHeadersEntry.decode(reader, reader.uint32());
            if (entry13.value !== undefined) {
              if (message.request_headers === undefined) {
                message.request_headers = new Map();
              }
              message.request_headers!.set(entry13.key, entry13.value);
            }
            continue;
          }
          case 14: {
            if (tag !== 112) {
              break;
            }

            message.upstream_header_bytes_sent = longToNumber(reader.uint64());
            continue;
          }
          case 15: {
            if (tag !== 120) {
              break;
            }

            message.downstream_header_bytes_received = longToNumber(reader.uint64());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): HTTPRequestProperties {
      return {
        $type: HTTPRequestProperties.$type,
        request_method: isSet(object.request_method) ? requestMethodFromJSON(object.request_method) : undefined,
        scheme: isSet(object.scheme) ? globalThis.String(object.scheme) : undefined,
        authority: isSet(object.authority) ? globalThis.String(object.authority) : undefined,
        port: isSet(object.port) ? Number(object.port) : undefined,
        path: isSet(object.path) ? globalThis.String(object.path) : undefined,
        user_agent: isSet(object.user_agent) ? globalThis.String(object.user_agent) : undefined,
        referer: isSet(object.referer) ? globalThis.String(object.referer) : undefined,
        forwarded_for: isSet(object.forwarded_for) ? globalThis.String(object.forwarded_for) : undefined,
        request_id: isSet(object.request_id) ? globalThis.String(object.request_id) : undefined,
        original_path: isSet(object.original_path) ? globalThis.String(object.original_path) : undefined,
        request_headers_bytes: isSet(object.request_headers_bytes)
          ? globalThis.Number(object.request_headers_bytes)
          : undefined,
        request_body_bytes: isSet(object.request_body_bytes) ? globalThis.Number(object.request_body_bytes) : undefined,
        request_headers: isObject(object.request_headers)
          ? Object.entries(object.request_headers).reduce<Map<string, string>>((acc, [key, value]) => {
            acc.set(key, String(value));
            return acc;
          }, new Map())
          : undefined,
        upstream_header_bytes_sent: isSet(object.upstream_header_bytes_sent)
          ? globalThis.Number(object.upstream_header_bytes_sent)
          : undefined,
        downstream_header_bytes_received: isSet(object.downstream_header_bytes_received)
          ? globalThis.Number(object.downstream_header_bytes_received)
          : undefined,
      };
    },

    toJSON(message: HTTPRequestProperties): unknown {
      const obj: any = {};
      if (message.request_method !== undefined) {
        obj.request_method = requestMethodToJSON(message.request_method);
      }
      if (message.scheme !== undefined) {
        obj.scheme = message.scheme;
      }
      if (message.authority !== undefined) {
        obj.authority = message.authority;
      }
      if (message.port !== undefined) {
        obj.port = message.port;
      }
      if (message.path !== undefined) {
        obj.path = message.path;
      }
      if (message.user_agent !== undefined) {
        obj.user_agent = message.user_agent;
      }
      if (message.referer !== undefined) {
        obj.referer = message.referer;
      }
      if (message.forwarded_for !== undefined) {
        obj.forwarded_for = message.forwarded_for;
      }
      if (message.request_id !== undefined) {
        obj.request_id = message.request_id;
      }
      if (message.original_path !== undefined) {
        obj.original_path = message.original_path;
      }
      if (message.request_headers_bytes !== undefined) {
        obj.request_headers_bytes = Math.round(message.request_headers_bytes);
      }
      if (message.request_body_bytes !== undefined) {
        obj.request_body_bytes = Math.round(message.request_body_bytes);
      }
      if (message.request_headers?.size) {
        obj.request_headers = {};
        message.request_headers.forEach((v, k) => {
          obj.request_headers[k] = v;
        });
      }
      if (message.upstream_header_bytes_sent !== undefined) {
        obj.upstream_header_bytes_sent = Math.round(message.upstream_header_bytes_sent);
      }
      if (message.downstream_header_bytes_received !== undefined) {
        obj.downstream_header_bytes_received = Math.round(message.downstream_header_bytes_received);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<HTTPRequestProperties>, I>>(base?: I): HTTPRequestProperties {
      return HTTPRequestProperties.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<HTTPRequestProperties>, I>>(object: I): HTTPRequestProperties {
      const message = createBaseHTTPRequestProperties();
      message.request_method = object.request_method ?? undefined;
      message.scheme = object.scheme ?? undefined;
      message.authority = object.authority ?? undefined;
      message.port = object.port ?? undefined;
      message.path = object.path ?? undefined;
      message.user_agent = object.user_agent ?? undefined;
      message.referer = object.referer ?? undefined;
      message.forwarded_for = object.forwarded_for ?? undefined;
      message.request_id = object.request_id ?? undefined;
      message.original_path = object.original_path ?? undefined;
      message.request_headers_bytes = object.request_headers_bytes ?? undefined;
      message.request_body_bytes = object.request_body_bytes ?? undefined;
      message.request_headers = (object.request_headers === undefined || object.request_headers === null)
        ? undefined
        : (() => {
          const m = new Map();
          (object.request_headers as Map<string, string> ?? new Map()).forEach((value, key) => {
            if (value !== undefined) {
              m.set(key, globalThis.String(value));
            }
          });
          return m;
        })();
      message.upstream_header_bytes_sent = object.upstream_header_bytes_sent ?? undefined;
      message.downstream_header_bytes_received = object.downstream_header_bytes_received ?? undefined;
      return message;
    },
  };

messageTypeRegistry.set(HTTPRequestProperties.$type, HTTPRequestProperties);

function createBaseHTTPRequestProperties_RequestHeadersEntry(): HTTPRequestProperties_RequestHeadersEntry {
  return { $type: "envoy.data.accesslog.v3.HTTPRequestProperties.RequestHeadersEntry", key: "", value: "" };
}

export const HTTPRequestProperties_RequestHeadersEntry: MessageFns<
  HTTPRequestProperties_RequestHeadersEntry,
  "envoy.data.accesslog.v3.HTTPRequestProperties.RequestHeadersEntry"
> = {
  $type: "envoy.data.accesslog.v3.HTTPRequestProperties.RequestHeadersEntry" as const,

  encode(message: HTTPRequestProperties_RequestHeadersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HTTPRequestProperties_RequestHeadersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHTTPRequestProperties_RequestHeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HTTPRequestProperties_RequestHeadersEntry {
    return {
      $type: HTTPRequestProperties_RequestHeadersEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: HTTPRequestProperties_RequestHeadersEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HTTPRequestProperties_RequestHeadersEntry>, I>>(
    base?: I,
  ): HTTPRequestProperties_RequestHeadersEntry {
    return HTTPRequestProperties_RequestHeadersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HTTPRequestProperties_RequestHeadersEntry>, I>>(
    object: I,
  ): HTTPRequestProperties_RequestHeadersEntry {
    const message = createBaseHTTPRequestProperties_RequestHeadersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

messageTypeRegistry.set(HTTPRequestProperties_RequestHeadersEntry.$type, HTTPRequestProperties_RequestHeadersEntry);

function createBaseHTTPResponseProperties(): HTTPResponseProperties {
  return { $type: "envoy.data.accesslog.v3.HTTPResponseProperties" };
}

export const HTTPResponseProperties: MessageFns<
  HTTPResponseProperties,
  "envoy.data.accesslog.v3.HTTPResponseProperties"
> = {
  $type: "envoy.data.accesslog.v3.HTTPResponseProperties" as const,

  encode(message: HTTPResponseProperties, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.response_code !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.response_code! },
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.response_headers_bytes !== undefined && message.response_headers_bytes !== 0) {
      writer.uint32(16).uint64(message.response_headers_bytes);
    }
    if (message.response_body_bytes !== undefined && message.response_body_bytes !== 0) {
      writer.uint32(24).uint64(message.response_body_bytes);
    }
    (message.response_headers || new Map()).forEach((value, key) => {
      HTTPResponseProperties_ResponseHeadersEntry.encode({
        $type: "envoy.data.accesslog.v3.HTTPResponseProperties.ResponseHeadersEntry",
        key: key as any,
        value,
      }, writer.uint32(34).fork()).join();
    });
    (message.response_trailers || new Map()).forEach((value, key) => {
      HTTPResponseProperties_ResponseTrailersEntry.encode({
        $type: "envoy.data.accesslog.v3.HTTPResponseProperties.ResponseTrailersEntry",
        key: key as any,
        value,
      }, writer.uint32(42).fork()).join();
    });
    if (message.response_code_details !== undefined && message.response_code_details !== "") {
      writer.uint32(50).string(message.response_code_details);
    }
    if (message.upstream_header_bytes_received !== undefined && message.upstream_header_bytes_received !== 0) {
      writer.uint32(56).uint64(message.upstream_header_bytes_received);
    }
    if (message.downstream_header_bytes_sent !== undefined && message.downstream_header_bytes_sent !== 0) {
      writer.uint32(64).uint64(message.downstream_header_bytes_sent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HTTPResponseProperties {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHTTPResponseProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.response_code = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.response_headers_bytes = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.response_body_bytes = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = HTTPResponseProperties_ResponseHeadersEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            if (message.response_headers === undefined) {
              message.response_headers = new Map();
            }
            message.response_headers!.set(entry4.key, entry4.value);
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = HTTPResponseProperties_ResponseTrailersEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            if (message.response_trailers === undefined) {
              message.response_trailers = new Map();
            }
            message.response_trailers!.set(entry5.key, entry5.value);
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.response_code_details = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.upstream_header_bytes_received = longToNumber(reader.uint64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.downstream_header_bytes_sent = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HTTPResponseProperties {
    return {
      $type: HTTPResponseProperties.$type,
      response_code: isSet(object.response_code) ? Number(object.response_code) : undefined,
      response_headers_bytes: isSet(object.response_headers_bytes)
        ? globalThis.Number(object.response_headers_bytes)
        : undefined,
      response_body_bytes: isSet(object.response_body_bytes)
        ? globalThis.Number(object.response_body_bytes)
        : undefined,
      response_headers: isObject(object.response_headers)
        ? Object.entries(object.response_headers).reduce<Map<string, string>>((acc, [key, value]) => {
          acc.set(key, String(value));
          return acc;
        }, new Map())
        : undefined,
      response_trailers: isObject(object.response_trailers)
        ? Object.entries(object.response_trailers).reduce<Map<string, string>>((acc, [key, value]) => {
          acc.set(key, String(value));
          return acc;
        }, new Map())
        : undefined,
      response_code_details: isSet(object.response_code_details)
        ? globalThis.String(object.response_code_details)
        : undefined,
      upstream_header_bytes_received: isSet(object.upstream_header_bytes_received)
        ? globalThis.Number(object.upstream_header_bytes_received)
        : undefined,
      downstream_header_bytes_sent: isSet(object.downstream_header_bytes_sent)
        ? globalThis.Number(object.downstream_header_bytes_sent)
        : undefined,
    };
  },

  toJSON(message: HTTPResponseProperties): unknown {
    const obj: any = {};
    if (message.response_code !== undefined) {
      obj.response_code = message.response_code;
    }
    if (message.response_headers_bytes !== undefined) {
      obj.response_headers_bytes = Math.round(message.response_headers_bytes);
    }
    if (message.response_body_bytes !== undefined) {
      obj.response_body_bytes = Math.round(message.response_body_bytes);
    }
    if (message.response_headers?.size) {
      obj.response_headers = {};
      message.response_headers.forEach((v, k) => {
        obj.response_headers[k] = v;
      });
    }
    if (message.response_trailers?.size) {
      obj.response_trailers = {};
      message.response_trailers.forEach((v, k) => {
        obj.response_trailers[k] = v;
      });
    }
    if (message.response_code_details !== undefined) {
      obj.response_code_details = message.response_code_details;
    }
    if (message.upstream_header_bytes_received !== undefined) {
      obj.upstream_header_bytes_received = Math.round(message.upstream_header_bytes_received);
    }
    if (message.downstream_header_bytes_sent !== undefined) {
      obj.downstream_header_bytes_sent = Math.round(message.downstream_header_bytes_sent);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HTTPResponseProperties>, I>>(base?: I): HTTPResponseProperties {
    return HTTPResponseProperties.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HTTPResponseProperties>, I>>(object: I): HTTPResponseProperties {
    const message = createBaseHTTPResponseProperties();
    message.response_code = object.response_code ?? undefined;
    message.response_headers_bytes = object.response_headers_bytes ?? undefined;
    message.response_body_bytes = object.response_body_bytes ?? undefined;
    message.response_headers = (object.response_headers === undefined || object.response_headers === null)
      ? undefined
      : (() => {
        const m = new Map();
        (object.response_headers as Map<string, string> ?? new Map()).forEach((value, key) => {
          if (value !== undefined) {
            m.set(key, globalThis.String(value));
          }
        });
        return m;
      })();
    message.response_trailers = (object.response_trailers === undefined || object.response_trailers === null)
      ? undefined
      : (() => {
        const m = new Map();
        (object.response_trailers as Map<string, string> ?? new Map()).forEach((value, key) => {
          if (value !== undefined) {
            m.set(key, globalThis.String(value));
          }
        });
        return m;
      })();
    message.response_code_details = object.response_code_details ?? undefined;
    message.upstream_header_bytes_received = object.upstream_header_bytes_received ?? undefined;
    message.downstream_header_bytes_sent = object.downstream_header_bytes_sent ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(HTTPResponseProperties.$type, HTTPResponseProperties);

function createBaseHTTPResponseProperties_ResponseHeadersEntry(): HTTPResponseProperties_ResponseHeadersEntry {
  return { $type: "envoy.data.accesslog.v3.HTTPResponseProperties.ResponseHeadersEntry", key: "", value: "" };
}

export const HTTPResponseProperties_ResponseHeadersEntry: MessageFns<
  HTTPResponseProperties_ResponseHeadersEntry,
  "envoy.data.accesslog.v3.HTTPResponseProperties.ResponseHeadersEntry"
> = {
  $type: "envoy.data.accesslog.v3.HTTPResponseProperties.ResponseHeadersEntry" as const,

  encode(
    message: HTTPResponseProperties_ResponseHeadersEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HTTPResponseProperties_ResponseHeadersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHTTPResponseProperties_ResponseHeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HTTPResponseProperties_ResponseHeadersEntry {
    return {
      $type: HTTPResponseProperties_ResponseHeadersEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: HTTPResponseProperties_ResponseHeadersEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HTTPResponseProperties_ResponseHeadersEntry>, I>>(
    base?: I,
  ): HTTPResponseProperties_ResponseHeadersEntry {
    return HTTPResponseProperties_ResponseHeadersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HTTPResponseProperties_ResponseHeadersEntry>, I>>(
    object: I,
  ): HTTPResponseProperties_ResponseHeadersEntry {
    const message = createBaseHTTPResponseProperties_ResponseHeadersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

messageTypeRegistry.set(HTTPResponseProperties_ResponseHeadersEntry.$type, HTTPResponseProperties_ResponseHeadersEntry);

function createBaseHTTPResponseProperties_ResponseTrailersEntry(): HTTPResponseProperties_ResponseTrailersEntry {
  return { $type: "envoy.data.accesslog.v3.HTTPResponseProperties.ResponseTrailersEntry", key: "", value: "" };
}

export const HTTPResponseProperties_ResponseTrailersEntry: MessageFns<
  HTTPResponseProperties_ResponseTrailersEntry,
  "envoy.data.accesslog.v3.HTTPResponseProperties.ResponseTrailersEntry"
> = {
  $type: "envoy.data.accesslog.v3.HTTPResponseProperties.ResponseTrailersEntry" as const,

  encode(
    message: HTTPResponseProperties_ResponseTrailersEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HTTPResponseProperties_ResponseTrailersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHTTPResponseProperties_ResponseTrailersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HTTPResponseProperties_ResponseTrailersEntry {
    return {
      $type: HTTPResponseProperties_ResponseTrailersEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: HTTPResponseProperties_ResponseTrailersEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HTTPResponseProperties_ResponseTrailersEntry>, I>>(
    base?: I,
  ): HTTPResponseProperties_ResponseTrailersEntry {
    return HTTPResponseProperties_ResponseTrailersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HTTPResponseProperties_ResponseTrailersEntry>, I>>(
    object: I,
  ): HTTPResponseProperties_ResponseTrailersEntry {
    const message = createBaseHTTPResponseProperties_ResponseTrailersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

messageTypeRegistry.set(
  HTTPResponseProperties_ResponseTrailersEntry.$type,
  HTTPResponseProperties_ResponseTrailersEntry,
);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { $type: "google.protobuf.Timestamp", seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
