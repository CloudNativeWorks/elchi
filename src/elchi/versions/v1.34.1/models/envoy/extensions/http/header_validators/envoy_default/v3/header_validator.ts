// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/http/header_validators/envoy_default/v3/header_validator.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { messageTypeRegistry } from "../../../../../../typeRegistry";

export const protobufPackage = "envoy.extensions.http.header_validators.envoy_default.v3";

/**
 * This extension validates that HTTP request and response headers are well formed according to respective RFCs.
 *
 * #. HTTP/1 header map validity according to `RFC 7230 section 3.2 <https://datatracker.ietf.org/doc/html/rfc7230#section-3.2>`_
 * #. Syntax of HTTP/1 request target URI and response status
 * #. HTTP/2 header map validity according to `RFC 7540 section 8.1.2 <https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2>`_
 * #. Syntax of HTTP/2 pseudo headers
 * #. HTTP/3 header map validity according to `RFC 9114 section 4.3  <https://www.rfc-editor.org/rfc/rfc9114.html>`_
 * #. Syntax of HTTP/3 pseudo headers
 * #. Syntax of Content-Length and Transfer-Encoding
 * #. Validation of HTTP/1 requests with both ``Content-Length`` and ``Transfer-Encoding`` headers
 * #. Normalization of the URI path according to `Normalization and Comparison <https://datatracker.ietf.org/doc/html/rfc3986#section-6>`_
 *    without `case normalization <https://datatracker.ietf.org/doc/html/rfc3986#section-6.2.2.1>`_
 *
 * [#comment:TODO(yanavlasov): Put #extension: envoy.http.header_validators.envoy_default after it is not hidden any more]
 * [#next-free-field: 6]
 */
export interface HeaderValidatorConfig {
  $type: "envoy.extensions.http.header_validators.envoy_default.v3.HeaderValidatorConfig";
  http1_protocol_options?:
    | HeaderValidatorConfig_Http1ProtocolOptions
    | undefined;
  /**
   * The URI path normalization options.
   * By default Envoy normalizes URI path using the default values of the :ref:`UriPathNormalizationOptions
   * <envoy_v3_api_msg_extensions.http.header_validators.envoy_default.v3.HeaderValidatorConfig.UriPathNormalizationOptions>`.
   * URI path transformations specified by the ``uri_path_normalization_options`` configuration can be applied to a portion
   * of requests by setting the ``envoy_default_header_validator.uri_path_transformations`` runtime value.
   * Caution: disabling path normalization may lead to path confusion vulnerabilities in access control or incorrect service
   * selection.
   */
  uri_path_normalization_options?:
    | HeaderValidatorConfig_UriPathNormalizationOptions
    | undefined;
  /**
   * Restrict HTTP methods to these defined in the `RFC 7231 section 4.1 <https://datatracker.ietf.org/doc/html/rfc7231#section-4.1>`_
   * Envoy will respond with 400 to requests with disallowed methods.
   * By default methods with arbitrary names are accepted.
   */
  restrict_http_methods?:
    | boolean
    | undefined;
  /**
   * Action to take when a client request with a header name containing underscore characters is received.
   * If this setting is not specified, the value defaults to ALLOW.
   */
  headers_with_underscores_action?:
    | HeaderValidatorConfig_HeadersWithUnderscoresAction
    | undefined;
  /**
   * Allow requests with fragment in URL path and strip the fragment before request processing.
   * By default Envoy rejects requests with fragment in URL path.
   */
  strip_fragment_from_path?: boolean | undefined;
}

/**
 * Action to take when Envoy receives client request with header names containing underscore
 * characters.
 * Underscore character is allowed in header names by the RFC-7230 and this behavior is implemented
 * as a security measure due to systems that treat '_' and '-' as interchangeable. Envoy by default allows client request headers with underscore
 * characters.
 */
export enum HeaderValidatorConfig_HeadersWithUnderscoresAction {
  /** ALLOW - Allow headers with underscores. This is the default behavior. */
  ALLOW = "ALLOW",
  /**
   * REJECT_REQUEST - Reject client request. HTTP/1 requests are rejected with the 400 status. HTTP/2 requests
   * end with the stream reset. The
   * :ref:`httpN.requests_rejected_with_underscores_in_headers <config_http_conn_man_stats_per_codec>` counter
   * is incremented for each rejected request.
   */
  REJECT_REQUEST = "REJECT_REQUEST",
  /**
   * DROP_HEADER - Drop the client header with name containing underscores. The header is dropped before the filter chain is
   * invoked and as such filters will not see dropped headers. The
   * :ref:`httpN.dropped_headers_with_underscores <config_http_conn_man_stats_per_codec>` is incremented for
   * each dropped header.
   */
  DROP_HEADER = "DROP_HEADER",
}

export function headerValidatorConfig_HeadersWithUnderscoresActionFromJSON(
  object: any,
): HeaderValidatorConfig_HeadersWithUnderscoresAction {
  switch (object) {
    case 0:
    case "ALLOW":
      return HeaderValidatorConfig_HeadersWithUnderscoresAction.ALLOW;
    case 1:
    case "REJECT_REQUEST":
      return HeaderValidatorConfig_HeadersWithUnderscoresAction.REJECT_REQUEST;
    case 2:
    case "DROP_HEADER":
      return HeaderValidatorConfig_HeadersWithUnderscoresAction.DROP_HEADER;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum HeaderValidatorConfig_HeadersWithUnderscoresAction",
      );
  }
}

export function headerValidatorConfig_HeadersWithUnderscoresActionToJSON(
  object: HeaderValidatorConfig_HeadersWithUnderscoresAction,
): string {
  switch (object) {
    case HeaderValidatorConfig_HeadersWithUnderscoresAction.ALLOW:
      return "ALLOW";
    case HeaderValidatorConfig_HeadersWithUnderscoresAction.REJECT_REQUEST:
      return "REJECT_REQUEST";
    case HeaderValidatorConfig_HeadersWithUnderscoresAction.DROP_HEADER:
      return "DROP_HEADER";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum HeaderValidatorConfig_HeadersWithUnderscoresAction",
      );
  }
}

export function headerValidatorConfig_HeadersWithUnderscoresActionToNumber(
  object: HeaderValidatorConfig_HeadersWithUnderscoresAction,
): number {
  switch (object) {
    case HeaderValidatorConfig_HeadersWithUnderscoresAction.ALLOW:
      return 0;
    case HeaderValidatorConfig_HeadersWithUnderscoresAction.REJECT_REQUEST:
      return 1;
    case HeaderValidatorConfig_HeadersWithUnderscoresAction.DROP_HEADER:
      return 2;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum HeaderValidatorConfig_HeadersWithUnderscoresAction",
      );
  }
}

export interface HeaderValidatorConfig_UriPathNormalizationOptions {
  $type: "envoy.extensions.http.header_validators.envoy_default.v3.HeaderValidatorConfig.UriPathNormalizationOptions";
  /**
   * Should paths be normalized according to RFC 3986?
   * This operation overwrites the original request URI path and the new path is used for processing of
   * the request by HTTP filters and proxied to the upstream service.
   * Envoy will respond with 400 to requests with malformed paths that fail path normalization.
   * The default behavior is to normalize the path.
   * This value may be overridden by the runtime variable
   * :ref:`http_connection_manager.normalize_path<config_http_conn_man_runtime_normalize_path>`.
   * See `Normalization and Comparison <https://datatracker.ietf.org/doc/html/rfc3986#section-6>`_
   * for details of normalization.
   * Note that Envoy does not perform
   * `case normalization <https://datatracker.ietf.org/doc/html/rfc3986#section-6.2.2.1>`_
   * URI path normalization can be applied to a portion of requests by setting the
   * ``envoy_default_header_validator.path_normalization`` runtime value.
   */
  skip_path_normalization?:
    | boolean
    | undefined;
  /**
   * Determines if adjacent slashes in the path are merged into one.
   * This operation overwrites the original request URI path and the new path is used for processing of
   * the request by HTTP filters and proxied to the upstream service.
   * Setting this option to true will cause incoming requests with path ``//dir///file`` to not match against
   * route with ``prefix`` match set to ``/dir``. Defaults to ``false``. Note that slash merging is not part of
   * `HTTP spec <https://datatracker.ietf.org/doc/html/rfc3986>`_ and is provided for convenience.
   * Merging of slashes in URI path can be applied to a portion of requests by setting the
   * ``envoy_default_header_validator.merge_slashes`` runtime value.
   */
  skip_merging_slashes?:
    | boolean
    | undefined;
  /**
   * The action to take when request URL path contains escaped slash sequences (``%2F``, ``%2f``, ``%5C`` and ``%5c``).
   * This operation may overwrite the original request URI path and the new path is used for processing of
   * the request by HTTP filters and proxied to the upstream service.
   */
  path_with_escaped_slashes_action?:
    | HeaderValidatorConfig_UriPathNormalizationOptions_PathWithEscapedSlashesAction
    | undefined;
}

/**
 * Determines the action for requests that contain ``%2F``, ``%2f``, ``%5C`` or ``%5c`` sequences in the URI path.
 * This operation occurs before URL normalization and the merge slashes transformations if they were enabled.
 */
export enum HeaderValidatorConfig_UriPathNormalizationOptions_PathWithEscapedSlashesAction {
  /**
   * IMPLEMENTATION_SPECIFIC_DEFAULT - Default behavior specific to implementation (i.e. Envoy) of this configuration option.
   * Envoy, by default, takes the ``KEEP_UNCHANGED`` action.
   * NOTE: the implementation may change the default behavior at-will.
   */
  IMPLEMENTATION_SPECIFIC_DEFAULT = "IMPLEMENTATION_SPECIFIC_DEFAULT",
  /** KEEP_UNCHANGED - Keep escaped slashes. */
  KEEP_UNCHANGED = "KEEP_UNCHANGED",
  /**
   * REJECT_REQUEST - Reject client request with the 400 status. gRPC requests will be rejected with the ``INTERNAL`` (13) error code.
   * The ``http#.downstream_rq_failed_path_normalization`` counter is incremented for each rejected request.
   */
  REJECT_REQUEST = "REJECT_REQUEST",
  /**
   * UNESCAPE_AND_REDIRECT - Unescape ``%2F`` and ``%5C`` sequences and redirect the request to the new path if these sequences were present.
   * The redirect occurs after path normalization and merge slashes transformations if they were configured.
   * NOTE: gRPC requests will be rejected with the ``INTERNAL`` (13) error code.
   * This option minimizes possibility of path confusion exploits by forcing request with unescaped slashes to
   * traverse all parties: downstream client, intermediate proxies, Envoy and upstream server.
   * The ``http#.downstream_rq_redirected_with_normalized_path`` counter is incremented for each
   * redirected request.
   */
  UNESCAPE_AND_REDIRECT = "UNESCAPE_AND_REDIRECT",
  /**
   * UNESCAPE_AND_FORWARD - Unescape ``%2F`` and ``%5C`` sequences.
   * Note: this option should not be enabled if intermediaries perform path based access control as
   * it may lead to path confusion vulnerabilities.
   */
  UNESCAPE_AND_FORWARD = "UNESCAPE_AND_FORWARD",
}

export function headerValidatorConfig_UriPathNormalizationOptions_PathWithEscapedSlashesActionFromJSON(
  object: any,
): HeaderValidatorConfig_UriPathNormalizationOptions_PathWithEscapedSlashesAction {
  switch (object) {
    case 0:
    case "IMPLEMENTATION_SPECIFIC_DEFAULT":
      return HeaderValidatorConfig_UriPathNormalizationOptions_PathWithEscapedSlashesAction
        .IMPLEMENTATION_SPECIFIC_DEFAULT;
    case 1:
    case "KEEP_UNCHANGED":
      return HeaderValidatorConfig_UriPathNormalizationOptions_PathWithEscapedSlashesAction.KEEP_UNCHANGED;
    case 2:
    case "REJECT_REQUEST":
      return HeaderValidatorConfig_UriPathNormalizationOptions_PathWithEscapedSlashesAction.REJECT_REQUEST;
    case 3:
    case "UNESCAPE_AND_REDIRECT":
      return HeaderValidatorConfig_UriPathNormalizationOptions_PathWithEscapedSlashesAction.UNESCAPE_AND_REDIRECT;
    case 4:
    case "UNESCAPE_AND_FORWARD":
      return HeaderValidatorConfig_UriPathNormalizationOptions_PathWithEscapedSlashesAction.UNESCAPE_AND_FORWARD;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object +
          " for enum HeaderValidatorConfig_UriPathNormalizationOptions_PathWithEscapedSlashesAction",
      );
  }
}

export function headerValidatorConfig_UriPathNormalizationOptions_PathWithEscapedSlashesActionToJSON(
  object: HeaderValidatorConfig_UriPathNormalizationOptions_PathWithEscapedSlashesAction,
): string {
  switch (object) {
    case HeaderValidatorConfig_UriPathNormalizationOptions_PathWithEscapedSlashesAction.IMPLEMENTATION_SPECIFIC_DEFAULT:
      return "IMPLEMENTATION_SPECIFIC_DEFAULT";
    case HeaderValidatorConfig_UriPathNormalizationOptions_PathWithEscapedSlashesAction.KEEP_UNCHANGED:
      return "KEEP_UNCHANGED";
    case HeaderValidatorConfig_UriPathNormalizationOptions_PathWithEscapedSlashesAction.REJECT_REQUEST:
      return "REJECT_REQUEST";
    case HeaderValidatorConfig_UriPathNormalizationOptions_PathWithEscapedSlashesAction.UNESCAPE_AND_REDIRECT:
      return "UNESCAPE_AND_REDIRECT";
    case HeaderValidatorConfig_UriPathNormalizationOptions_PathWithEscapedSlashesAction.UNESCAPE_AND_FORWARD:
      return "UNESCAPE_AND_FORWARD";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object +
          " for enum HeaderValidatorConfig_UriPathNormalizationOptions_PathWithEscapedSlashesAction",
      );
  }
}

export function headerValidatorConfig_UriPathNormalizationOptions_PathWithEscapedSlashesActionToNumber(
  object: HeaderValidatorConfig_UriPathNormalizationOptions_PathWithEscapedSlashesAction,
): number {
  switch (object) {
    case HeaderValidatorConfig_UriPathNormalizationOptions_PathWithEscapedSlashesAction.IMPLEMENTATION_SPECIFIC_DEFAULT:
      return 0;
    case HeaderValidatorConfig_UriPathNormalizationOptions_PathWithEscapedSlashesAction.KEEP_UNCHANGED:
      return 1;
    case HeaderValidatorConfig_UriPathNormalizationOptions_PathWithEscapedSlashesAction.REJECT_REQUEST:
      return 2;
    case HeaderValidatorConfig_UriPathNormalizationOptions_PathWithEscapedSlashesAction.UNESCAPE_AND_REDIRECT:
      return 3;
    case HeaderValidatorConfig_UriPathNormalizationOptions_PathWithEscapedSlashesAction.UNESCAPE_AND_FORWARD:
      return 4;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object +
          " for enum HeaderValidatorConfig_UriPathNormalizationOptions_PathWithEscapedSlashesAction",
      );
  }
}

export interface HeaderValidatorConfig_Http1ProtocolOptions {
  $type: "envoy.extensions.http.header_validators.envoy_default.v3.HeaderValidatorConfig.Http1ProtocolOptions";
  /**
   * Allows Envoy to process HTTP/1 requests/responses with both ``Content-Length`` and ``Transfer-Encoding``
   * headers set. By default such messages are rejected, but if option is enabled - Envoy will
   * remove the ``Content-Length`` header and process the message.
   * See `RFC7230, sec. 3.3.3 <https://datatracker.ietf.org/doc/html/rfc7230#section-3.3.3>`_ for details.
   *
   * .. attention::
   *   Enabling this option might lead to request smuggling vulnerabilities, especially if traffic
   *   is proxied via multiple layers of proxies.
   */
  allow_chunked_length?: boolean | undefined;
}

function createBaseHeaderValidatorConfig(): HeaderValidatorConfig {
  return { $type: "envoy.extensions.http.header_validators.envoy_default.v3.HeaderValidatorConfig" };
}

export const HeaderValidatorConfig: MessageFns<
  HeaderValidatorConfig,
  "envoy.extensions.http.header_validators.envoy_default.v3.HeaderValidatorConfig"
> = {
  $type: "envoy.extensions.http.header_validators.envoy_default.v3.HeaderValidatorConfig" as const,

  encode(message: HeaderValidatorConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.http1_protocol_options !== undefined) {
      HeaderValidatorConfig_Http1ProtocolOptions.encode(message.http1_protocol_options, writer.uint32(10).fork())
        .join();
    }
    if (message.uri_path_normalization_options !== undefined) {
      HeaderValidatorConfig_UriPathNormalizationOptions.encode(
        message.uri_path_normalization_options,
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.restrict_http_methods !== undefined && message.restrict_http_methods !== false) {
      writer.uint32(24).bool(message.restrict_http_methods);
    }
    if (
      message.headers_with_underscores_action !== undefined &&
      message.headers_with_underscores_action !== HeaderValidatorConfig_HeadersWithUnderscoresAction.ALLOW
    ) {
      writer.uint32(32).int32(
        headerValidatorConfig_HeadersWithUnderscoresActionToNumber(message.headers_with_underscores_action),
      );
    }
    if (message.strip_fragment_from_path !== undefined && message.strip_fragment_from_path !== false) {
      writer.uint32(40).bool(message.strip_fragment_from_path);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeaderValidatorConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeaderValidatorConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.http1_protocol_options = HeaderValidatorConfig_Http1ProtocolOptions.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uri_path_normalization_options = HeaderValidatorConfig_UriPathNormalizationOptions.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.restrict_http_methods = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.headers_with_underscores_action = headerValidatorConfig_HeadersWithUnderscoresActionFromJSON(
            reader.int32(),
          );
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.strip_fragment_from_path = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeaderValidatorConfig {
    return {
      $type: HeaderValidatorConfig.$type,
      http1_protocol_options: isSet(object.http1_protocol_options)
        ? HeaderValidatorConfig_Http1ProtocolOptions.fromJSON(object.http1_protocol_options)
        : undefined,
      uri_path_normalization_options: isSet(object.uri_path_normalization_options)
        ? HeaderValidatorConfig_UriPathNormalizationOptions.fromJSON(object.uri_path_normalization_options)
        : undefined,
      restrict_http_methods: isSet(object.restrict_http_methods)
        ? globalThis.Boolean(object.restrict_http_methods)
        : undefined,
      headers_with_underscores_action: isSet(object.headers_with_underscores_action)
        ? headerValidatorConfig_HeadersWithUnderscoresActionFromJSON(object.headers_with_underscores_action)
        : undefined,
      strip_fragment_from_path: isSet(object.strip_fragment_from_path)
        ? globalThis.Boolean(object.strip_fragment_from_path)
        : undefined,
    };
  },

  toJSON(message: HeaderValidatorConfig): unknown {
    const obj: any = {};
    if (message.http1_protocol_options !== undefined) {
      obj.http1_protocol_options = HeaderValidatorConfig_Http1ProtocolOptions.toJSON(message.http1_protocol_options);
    }
    if (message.uri_path_normalization_options !== undefined) {
      obj.uri_path_normalization_options = HeaderValidatorConfig_UriPathNormalizationOptions.toJSON(
        message.uri_path_normalization_options,
      );
    }
    if (message.restrict_http_methods !== undefined) {
      obj.restrict_http_methods = message.restrict_http_methods;
    }
    if (message.headers_with_underscores_action !== undefined) {
      obj.headers_with_underscores_action = headerValidatorConfig_HeadersWithUnderscoresActionToJSON(
        message.headers_with_underscores_action,
      );
    }
    if (message.strip_fragment_from_path !== undefined) {
      obj.strip_fragment_from_path = message.strip_fragment_from_path;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HeaderValidatorConfig>, I>>(base?: I): HeaderValidatorConfig {
    return HeaderValidatorConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HeaderValidatorConfig>, I>>(object: I): HeaderValidatorConfig {
    const message = createBaseHeaderValidatorConfig();
    message.http1_protocol_options =
      (object.http1_protocol_options !== undefined && object.http1_protocol_options !== null)
        ? HeaderValidatorConfig_Http1ProtocolOptions.fromPartial(object.http1_protocol_options)
        : undefined;
    message.uri_path_normalization_options =
      (object.uri_path_normalization_options !== undefined && object.uri_path_normalization_options !== null)
        ? HeaderValidatorConfig_UriPathNormalizationOptions.fromPartial(object.uri_path_normalization_options)
        : undefined;
    message.restrict_http_methods = object.restrict_http_methods ?? undefined;
    message.headers_with_underscores_action = object.headers_with_underscores_action ?? undefined;
    message.strip_fragment_from_path = object.strip_fragment_from_path ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(HeaderValidatorConfig.$type, HeaderValidatorConfig);

function createBaseHeaderValidatorConfig_UriPathNormalizationOptions(): HeaderValidatorConfig_UriPathNormalizationOptions {
  return {
    $type: "envoy.extensions.http.header_validators.envoy_default.v3.HeaderValidatorConfig.UriPathNormalizationOptions",
  };
}

export const HeaderValidatorConfig_UriPathNormalizationOptions: MessageFns<
  HeaderValidatorConfig_UriPathNormalizationOptions,
  "envoy.extensions.http.header_validators.envoy_default.v3.HeaderValidatorConfig.UriPathNormalizationOptions"
> = {
  $type:
    "envoy.extensions.http.header_validators.envoy_default.v3.HeaderValidatorConfig.UriPathNormalizationOptions" as const,

  encode(
    message: HeaderValidatorConfig_UriPathNormalizationOptions,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.skip_path_normalization !== undefined && message.skip_path_normalization !== false) {
      writer.uint32(8).bool(message.skip_path_normalization);
    }
    if (message.skip_merging_slashes !== undefined && message.skip_merging_slashes !== false) {
      writer.uint32(16).bool(message.skip_merging_slashes);
    }
    if (
      message.path_with_escaped_slashes_action !== undefined &&
      message.path_with_escaped_slashes_action !==
        HeaderValidatorConfig_UriPathNormalizationOptions_PathWithEscapedSlashesAction.IMPLEMENTATION_SPECIFIC_DEFAULT
    ) {
      writer.uint32(24).int32(
        headerValidatorConfig_UriPathNormalizationOptions_PathWithEscapedSlashesActionToNumber(
          message.path_with_escaped_slashes_action,
        ),
      );
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeaderValidatorConfig_UriPathNormalizationOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeaderValidatorConfig_UriPathNormalizationOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.skip_path_normalization = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.skip_merging_slashes = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.path_with_escaped_slashes_action =
            headerValidatorConfig_UriPathNormalizationOptions_PathWithEscapedSlashesActionFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeaderValidatorConfig_UriPathNormalizationOptions {
    return {
      $type: HeaderValidatorConfig_UriPathNormalizationOptions.$type,
      skip_path_normalization: isSet(object.skip_path_normalization)
        ? globalThis.Boolean(object.skip_path_normalization)
        : undefined,
      skip_merging_slashes: isSet(object.skip_merging_slashes)
        ? globalThis.Boolean(object.skip_merging_slashes)
        : undefined,
      path_with_escaped_slashes_action: isSet(object.path_with_escaped_slashes_action)
        ? headerValidatorConfig_UriPathNormalizationOptions_PathWithEscapedSlashesActionFromJSON(
          object.path_with_escaped_slashes_action,
        )
        : undefined,
    };
  },

  toJSON(message: HeaderValidatorConfig_UriPathNormalizationOptions): unknown {
    const obj: any = {};
    if (message.skip_path_normalization !== undefined) {
      obj.skip_path_normalization = message.skip_path_normalization;
    }
    if (message.skip_merging_slashes !== undefined) {
      obj.skip_merging_slashes = message.skip_merging_slashes;
    }
    if (message.path_with_escaped_slashes_action !== undefined) {
      obj.path_with_escaped_slashes_action =
        headerValidatorConfig_UriPathNormalizationOptions_PathWithEscapedSlashesActionToJSON(
          message.path_with_escaped_slashes_action,
        );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HeaderValidatorConfig_UriPathNormalizationOptions>, I>>(
    base?: I,
  ): HeaderValidatorConfig_UriPathNormalizationOptions {
    return HeaderValidatorConfig_UriPathNormalizationOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HeaderValidatorConfig_UriPathNormalizationOptions>, I>>(
    object: I,
  ): HeaderValidatorConfig_UriPathNormalizationOptions {
    const message = createBaseHeaderValidatorConfig_UriPathNormalizationOptions();
    message.skip_path_normalization = object.skip_path_normalization ?? undefined;
    message.skip_merging_slashes = object.skip_merging_slashes ?? undefined;
    message.path_with_escaped_slashes_action = object.path_with_escaped_slashes_action ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(
  HeaderValidatorConfig_UriPathNormalizationOptions.$type,
  HeaderValidatorConfig_UriPathNormalizationOptions,
);

function createBaseHeaderValidatorConfig_Http1ProtocolOptions(): HeaderValidatorConfig_Http1ProtocolOptions {
  return {
    $type: "envoy.extensions.http.header_validators.envoy_default.v3.HeaderValidatorConfig.Http1ProtocolOptions",
  };
}

export const HeaderValidatorConfig_Http1ProtocolOptions: MessageFns<
  HeaderValidatorConfig_Http1ProtocolOptions,
  "envoy.extensions.http.header_validators.envoy_default.v3.HeaderValidatorConfig.Http1ProtocolOptions"
> = {
  $type: "envoy.extensions.http.header_validators.envoy_default.v3.HeaderValidatorConfig.Http1ProtocolOptions" as const,

  encode(message: HeaderValidatorConfig_Http1ProtocolOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.allow_chunked_length !== undefined && message.allow_chunked_length !== false) {
      writer.uint32(8).bool(message.allow_chunked_length);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeaderValidatorConfig_Http1ProtocolOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeaderValidatorConfig_Http1ProtocolOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.allow_chunked_length = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeaderValidatorConfig_Http1ProtocolOptions {
    return {
      $type: HeaderValidatorConfig_Http1ProtocolOptions.$type,
      allow_chunked_length: isSet(object.allow_chunked_length)
        ? globalThis.Boolean(object.allow_chunked_length)
        : undefined,
    };
  },

  toJSON(message: HeaderValidatorConfig_Http1ProtocolOptions): unknown {
    const obj: any = {};
    if (message.allow_chunked_length !== undefined) {
      obj.allow_chunked_length = message.allow_chunked_length;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HeaderValidatorConfig_Http1ProtocolOptions>, I>>(
    base?: I,
  ): HeaderValidatorConfig_Http1ProtocolOptions {
    return HeaderValidatorConfig_Http1ProtocolOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HeaderValidatorConfig_Http1ProtocolOptions>, I>>(
    object: I,
  ): HeaderValidatorConfig_Http1ProtocolOptions {
    const message = createBaseHeaderValidatorConfig_Http1ProtocolOptions();
    message.allow_chunked_length = object.allow_chunked_length ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(HeaderValidatorConfig_Http1ProtocolOptions.$type, HeaderValidatorConfig_Http1ProtocolOptions);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
