// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/http/cache/file_system_http_cache/v3/file_system_http_cache.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../../../../google/protobuf/duration";
import { UInt64Value } from "../../../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../../../typeRegistry";
import { AsyncFileManagerConfig } from "../../../../common/async_files/v3/async_file_manager";

export const protobufPackage = "envoy.extensions.http.cache.file_system_http_cache.v3";

/**
 * Configuration for a cache implementation that caches in the local file system.
 *
 * By default this cache uses a least-recently-used eviction strategy.
 *
 * For implementation details, see `DESIGN.md <https://github.com/envoyproxy/envoy/blob/main/source/extensions/http/cache/file_system_http_cache/DESIGN.md>`_.
 * [#next-free-field: 11]
 */
export interface FileSystemHttpCacheConfig {
  $type: "envoy.extensions.http.cache.file_system_http_cache.v3.FileSystemHttpCacheConfig";
  /** Configuration of a manager for how the file system is used asynchronously. */
  manager_config?:
    | AsyncFileManagerConfig
    | undefined;
  /**
   * Path at which the cache files will be stored.
   *
   * This also doubles as the unique identifier for a cache, so a cache can be shared
   * between different routes, or separate paths can be used to specify separate caches.
   *
   * If the same ``cache_path`` is used in more than one ``CacheConfig``, the rest of the
   * ``FileSystemHttpCacheConfig`` must also match, and will refer to the same cache
   * instance.
   */
  cache_path?:
    | string
    | undefined;
  /**
   * The maximum size of the cache in bytes - when reached, cache eviction is triggered.
   *
   * This is measured as the sum of file sizes, such that it includes headers, trailers,
   * and metadata, but does not include e.g. file system overhead and block size padding.
   *
   * If unset there is no limit except file system failure.
   */
  max_cache_size_bytes?:
    | number
    | undefined;
  /**
   * The maximum size of a cache entry in bytes - larger responses will not be cached.
   *
   * This is measured as the file size for the cache entry, such that it includes
   * headers, trailers, and metadata.
   *
   * If unset there is no limit.
   *
   * [#not-implemented-hide:]
   */
  max_individual_cache_entry_size_bytes?:
    | number
    | undefined;
  /**
   * The maximum number of cache entries - when reached, cache eviction is triggered.
   *
   * If unset there is no limit.
   */
  max_cache_entry_count?:
    | number
    | undefined;
  /**
   * A number of folders into which to subdivide the cache.
   *
   * Setting this can help with performance in file systems where a large number of inodes
   * in a single branch degrades performance. The optimal value in that case would be
   * ``sqrt(expected_cache_entry_count)``.
   *
   * On file systems that perform well with many inodes, the default value of 1 should be used.
   *
   * [#not-implemented-hide:]
   */
  cache_subdivisions?:
    | number
    | undefined;
  /**
   * The amount of the maximum cache size or count to evict when cache eviction is
   * triggered. For example, if ``max_cache_size_bytes`` is 10000000 and ``evict_fraction``
   * is 0.2, then when the cache exceeds 10MB, entries will be evicted until the cache size is
   * less than or equal to 8MB.
   *
   * The default value of 0 means when the cache exceeds 10MB, entries will be evicted only
   * until the cache is less than or equal to 10MB.
   *
   * Evicting a larger fraction will mean the eviction thread will run less often (sparing
   * CPU load) at the cost of more cache misses due to the extra evicted entries.
   *
   * [#not-implemented-hide:]
   */
  evict_fraction?:
    | number
    | undefined;
  /**
   * The longest amount of time to wait before running a cache eviction pass. An eviction
   * pass may not necessarily remove any files, but it will update the cache state to match
   * the on-disk state. This can be important if multiple instances are accessing the same
   * cache in parallel. (e.g. if two instances each independently added non-overlapping 10MB
   * of content to a cache with a 15MB limit, neither instance would be aware that the limit
   * was exceeded without this synchronizing pass.)
   *
   * If an eviction pass has not happened within this duration, the eviction thread will
   * be awoken and perform an eviction pass.
   *
   * If unset, there will be no eviction passes except those triggered by cache limits.
   *
   * [#not-implemented-hide:]
   */
  max_eviction_period?:
    | Duration
    | undefined;
  /**
   * The shortest amount of time between cache eviction passes. This can be used to reduce
   * eviction churn, if your cache max size can be flexible. If a cache eviction pass already
   * occurred more recently than this period when another would be triggered, that new
   * pass is cancelled.
   *
   * This means the cache can potentially grow beyond ``max_cache_size_bytes`` by as much as
   * can be written within the duration specified.
   *
   * Generally you would use *either* ``min_eviction_period`` *or* ``evict_fraction`` to
   * reduce churn. Both together will work but since they're both aiming for the same goal,
   * it's simpler not to.
   *
   * [#not-implemented-hide:]
   */
  min_eviction_period?:
    | Duration
    | undefined;
  /**
   * If true, and the cache path does not exist, attempt to create the cache path, including
   * any missing directories leading up to it. On failure, the config is rejected.
   *
   * If false, and the cache path does not exist, the config is rejected.
   *
   * [#not-implemented-hide:]
   */
  create_cache_path?: boolean | undefined;
}

function createBaseFileSystemHttpCacheConfig(): FileSystemHttpCacheConfig {
  return { $type: "envoy.extensions.http.cache.file_system_http_cache.v3.FileSystemHttpCacheConfig" };
}

export const FileSystemHttpCacheConfig: MessageFns<
  FileSystemHttpCacheConfig,
  "envoy.extensions.http.cache.file_system_http_cache.v3.FileSystemHttpCacheConfig"
> = {
  $type: "envoy.extensions.http.cache.file_system_http_cache.v3.FileSystemHttpCacheConfig" as const,

  encode(message: FileSystemHttpCacheConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.manager_config !== undefined) {
      AsyncFileManagerConfig.encode(message.manager_config, writer.uint32(10).fork()).join();
    }
    if (message.cache_path !== undefined && message.cache_path !== "") {
      writer.uint32(18).string(message.cache_path);
    }
    if (message.max_cache_size_bytes !== undefined) {
      UInt64Value.encode(
        { $type: "google.protobuf.UInt64Value", value: message.max_cache_size_bytes! },
        writer.uint32(26).fork(),
      ).join();
    }
    if (message.max_individual_cache_entry_size_bytes !== undefined) {
      UInt64Value.encode({
        $type: "google.protobuf.UInt64Value",
        value: message.max_individual_cache_entry_size_bytes!,
      }, writer.uint32(34).fork()).join();
    }
    if (message.max_cache_entry_count !== undefined) {
      UInt64Value.encode(
        { $type: "google.protobuf.UInt64Value", value: message.max_cache_entry_count! },
        writer.uint32(42).fork(),
      ).join();
    }
    if (message.cache_subdivisions !== undefined && message.cache_subdivisions !== 0) {
      writer.uint32(48).uint32(message.cache_subdivisions);
    }
    if (message.evict_fraction !== undefined && message.evict_fraction !== 0) {
      writer.uint32(61).float(message.evict_fraction);
    }
    if (message.max_eviction_period !== undefined) {
      Duration.encode(message.max_eviction_period, writer.uint32(66).fork()).join();
    }
    if (message.min_eviction_period !== undefined) {
      Duration.encode(message.min_eviction_period, writer.uint32(74).fork()).join();
    }
    if (message.create_cache_path !== undefined && message.create_cache_path !== false) {
      writer.uint32(80).bool(message.create_cache_path);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileSystemHttpCacheConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileSystemHttpCacheConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.manager_config = AsyncFileManagerConfig.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cache_path = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.max_cache_size_bytes = UInt64Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.max_individual_cache_entry_size_bytes = UInt64Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.max_cache_entry_count = UInt64Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.cache_subdivisions = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 61) {
            break;
          }

          message.evict_fraction = reader.float();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.max_eviction_period = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.min_eviction_period = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.create_cache_path = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileSystemHttpCacheConfig {
    return {
      $type: FileSystemHttpCacheConfig.$type,
      manager_config: isSet(object.manager_config) ? AsyncFileManagerConfig.fromJSON(object.manager_config) : undefined,
      cache_path: isSet(object.cache_path) ? globalThis.String(object.cache_path) : undefined,
      max_cache_size_bytes: isSet(object.max_cache_size_bytes) ? Number(object.max_cache_size_bytes) : undefined,
      max_individual_cache_entry_size_bytes: isSet(object.max_individual_cache_entry_size_bytes)
        ? Number(object.max_individual_cache_entry_size_bytes)
        : undefined,
      max_cache_entry_count: isSet(object.max_cache_entry_count) ? Number(object.max_cache_entry_count) : undefined,
      cache_subdivisions: isSet(object.cache_subdivisions) ? globalThis.Number(object.cache_subdivisions) : undefined,
      evict_fraction: isSet(object.evict_fraction) ? globalThis.Number(object.evict_fraction) : undefined,
      max_eviction_period: isSet(object.max_eviction_period)
        ? Duration.fromJSON(object.max_eviction_period)
        : undefined,
      min_eviction_period: isSet(object.min_eviction_period)
        ? Duration.fromJSON(object.min_eviction_period)
        : undefined,
      create_cache_path: isSet(object.create_cache_path) ? globalThis.Boolean(object.create_cache_path) : undefined,
    };
  },

  toJSON(message: FileSystemHttpCacheConfig): unknown {
    const obj: any = {};
    if (message.manager_config !== undefined) {
      obj.manager_config = AsyncFileManagerConfig.toJSON(message.manager_config);
    }
    if (message.cache_path !== undefined) {
      obj.cache_path = message.cache_path;
    }
    if (message.max_cache_size_bytes !== undefined) {
      obj.max_cache_size_bytes = message.max_cache_size_bytes;
    }
    if (message.max_individual_cache_entry_size_bytes !== undefined) {
      obj.max_individual_cache_entry_size_bytes = message.max_individual_cache_entry_size_bytes;
    }
    if (message.max_cache_entry_count !== undefined) {
      obj.max_cache_entry_count = message.max_cache_entry_count;
    }
    if (message.cache_subdivisions !== undefined) {
      obj.cache_subdivisions = Math.round(message.cache_subdivisions);
    }
    if (message.evict_fraction !== undefined) {
      obj.evict_fraction = message.evict_fraction;
    }
    if (message.max_eviction_period !== undefined) {
      obj.max_eviction_period = Duration.toJSON(message.max_eviction_period);
    }
    if (message.min_eviction_period !== undefined) {
      obj.min_eviction_period = Duration.toJSON(message.min_eviction_period);
    }
    if (message.create_cache_path !== undefined) {
      obj.create_cache_path = message.create_cache_path;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FileSystemHttpCacheConfig>, I>>(base?: I): FileSystemHttpCacheConfig {
    return FileSystemHttpCacheConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FileSystemHttpCacheConfig>, I>>(object: I): FileSystemHttpCacheConfig {
    const message = createBaseFileSystemHttpCacheConfig();
    message.manager_config = (object.manager_config !== undefined && object.manager_config !== null)
      ? AsyncFileManagerConfig.fromPartial(object.manager_config)
      : undefined;
    message.cache_path = object.cache_path ?? undefined;
    message.max_cache_size_bytes = object.max_cache_size_bytes ?? undefined;
    message.max_individual_cache_entry_size_bytes = object.max_individual_cache_entry_size_bytes ?? undefined;
    message.max_cache_entry_count = object.max_cache_entry_count ?? undefined;
    message.cache_subdivisions = object.cache_subdivisions ?? undefined;
    message.evict_fraction = object.evict_fraction ?? undefined;
    message.max_eviction_period = (object.max_eviction_period !== undefined && object.max_eviction_period !== null)
      ? Duration.fromPartial(object.max_eviction_period)
      : undefined;
    message.min_eviction_period = (object.min_eviction_period !== undefined && object.min_eviction_period !== null)
      ? Duration.fromPartial(object.min_eviction_period)
      : undefined;
    message.create_cache_path = object.create_cache_path ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(FileSystemHttpCacheConfig.$type, FileSystemHttpCacheConfig);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
