// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/config/cluster/v3/outlier_detection.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../../google/protobuf/duration";
import { BoolValue, UInt32Value } from "../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../typeRegistry";
import { TypedExtensionConfig } from "../../core/v3/extension";

export const protobufPackage = "envoy.config.cluster.v3";

/**
 * See the :ref:`architecture overview <arch_overview_outlier_detection>` for
 * more information on outlier detection.
 * [#next-free-field: 26]
 */
export interface OutlierDetection {
  $type: "envoy.config.cluster.v3.OutlierDetection";
  /**
   * The number of consecutive server-side error responses (for HTTP traffic,
   * 5xx responses; for TCP traffic, connection failures; for Redis, failure to
   * respond PONG; etc.) before a consecutive 5xx ejection occurs. Defaults to 5.
   */
  consecutive_5xx?:
    | number
    | undefined;
  /**
   * The time interval between ejection analysis sweeps. This can result in
   * both new ejections as well as hosts being returned to service. Defaults
   * to 10000ms or 10s.
   */
  interval?:
    | Duration
    | undefined;
  /**
   * The base time that a host is ejected for. The real time is equal to the
   * base time multiplied by the number of times the host has been ejected and is
   * capped by :ref:`max_ejection_time<envoy_v3_api_field_config.cluster.v3.OutlierDetection.max_ejection_time>`.
   * Defaults to 30000ms or 30s.
   */
  base_ejection_time?:
    | Duration
    | undefined;
  /**
   * The maximum % of an upstream cluster that can be ejected due to outlier detection. Defaults to 10% .
   * Will eject at least one host regardless of the value if :ref:`always_eject_one_host<envoy_v3_api_field_config.cluster.v3.OutlierDetection.always_eject_one_host>` is enabled.
   */
  max_ejection_percent?:
    | number
    | undefined;
  /**
   * The % chance that a host will be actually ejected when an outlier status
   * is detected through consecutive 5xx. This setting can be used to disable
   * ejection or to ramp it up slowly. Defaults to 100.
   */
  enforcing_consecutive_5xx?:
    | number
    | undefined;
  /**
   * The % chance that a host will be actually ejected when an outlier status
   * is detected through success rate statistics. This setting can be used to
   * disable ejection or to ramp it up slowly. Defaults to 100.
   */
  enforcing_success_rate?:
    | number
    | undefined;
  /**
   * The number of hosts in a cluster that must have enough request volume to
   * detect success rate outliers. If the number of hosts is less than this
   * setting, outlier detection via success rate statistics is not performed
   * for any host in the cluster. Defaults to 5.
   */
  success_rate_minimum_hosts?:
    | number
    | undefined;
  /**
   * The minimum number of total requests that must be collected in one
   * interval (as defined by the interval duration above) to include this host
   * in success rate based outlier detection. If the volume is lower than this
   * setting, outlier detection via success rate statistics is not performed
   * for that host. Defaults to 100.
   */
  success_rate_request_volume?:
    | number
    | undefined;
  /**
   * This factor is used to determine the ejection threshold for success rate
   * outlier ejection. The ejection threshold is the difference between the
   * mean success rate, and the product of this factor and the standard
   * deviation of the mean success rate: mean - (stdev *
   * success_rate_stdev_factor). This factor is divided by a thousand to get a
   * double. That is, if the desired factor is 1.9, the runtime value should
   * be 1900. Defaults to 1900.
   */
  success_rate_stdev_factor?:
    | number
    | undefined;
  /**
   * The number of consecutive gateway failures (502, 503, 504 status codes)
   * before a consecutive gateway failure ejection occurs. Defaults to 5.
   */
  consecutive_gateway_failure?:
    | number
    | undefined;
  /**
   * The % chance that a host will be actually ejected when an outlier status
   * is detected through consecutive gateway failures. This setting can be
   * used to disable ejection or to ramp it up slowly. Defaults to 0.
   */
  enforcing_consecutive_gateway_failure?:
    | number
    | undefined;
  /**
   * Determines whether to distinguish local origin failures from external errors. If set to true
   * the following configuration parameters are taken into account:
   * :ref:`consecutive_local_origin_failure<envoy_v3_api_field_config.cluster.v3.OutlierDetection.consecutive_local_origin_failure>`,
   * :ref:`enforcing_consecutive_local_origin_failure<envoy_v3_api_field_config.cluster.v3.OutlierDetection.enforcing_consecutive_local_origin_failure>`
   * and
   * :ref:`enforcing_local_origin_success_rate<envoy_v3_api_field_config.cluster.v3.OutlierDetection.enforcing_local_origin_success_rate>`.
   * Defaults to false.
   */
  split_external_local_origin_errors?:
    | boolean
    | undefined;
  /**
   * The number of consecutive locally originated failures before ejection
   * occurs. Defaults to 5. Parameter takes effect only when
   * :ref:`split_external_local_origin_errors<envoy_v3_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
   * is set to true.
   */
  consecutive_local_origin_failure?:
    | number
    | undefined;
  /**
   * The % chance that a host will be actually ejected when an outlier status
   * is detected through consecutive locally originated failures. This setting can be
   * used to disable ejection or to ramp it up slowly. Defaults to 100.
   * Parameter takes effect only when
   * :ref:`split_external_local_origin_errors<envoy_v3_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
   * is set to true.
   */
  enforcing_consecutive_local_origin_failure?:
    | number
    | undefined;
  /**
   * The % chance that a host will be actually ejected when an outlier status
   * is detected through success rate statistics for locally originated errors.
   * This setting can be used to disable ejection or to ramp it up slowly. Defaults to 100.
   * Parameter takes effect only when
   * :ref:`split_external_local_origin_errors<envoy_v3_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
   * is set to true.
   */
  enforcing_local_origin_success_rate?:
    | number
    | undefined;
  /**
   * The failure percentage to use when determining failure percentage-based outlier detection. If
   * the failure percentage of a given host is greater than or equal to this value, it will be
   * ejected. Defaults to 85.
   */
  failure_percentage_threshold?:
    | number
    | undefined;
  /**
   * The % chance that a host will be actually ejected when an outlier status is detected through
   * failure percentage statistics. This setting can be used to disable ejection or to ramp it up
   * slowly. Defaults to 0.
   *
   * [#next-major-version: setting this without setting failure_percentage_threshold should be
   * invalid in v4.]
   */
  enforcing_failure_percentage?:
    | number
    | undefined;
  /**
   * The % chance that a host will be actually ejected when an outlier status is detected through
   * local-origin failure percentage statistics. This setting can be used to disable ejection or to
   * ramp it up slowly. Defaults to 0.
   */
  enforcing_failure_percentage_local_origin?:
    | number
    | undefined;
  /**
   * The minimum number of hosts in a cluster in order to perform failure percentage-based ejection.
   * If the total number of hosts in the cluster is less than this value, failure percentage-based
   * ejection will not be performed. Defaults to 5.
   */
  failure_percentage_minimum_hosts?:
    | number
    | undefined;
  /**
   * The minimum number of total requests that must be collected in one interval (as defined by the
   * interval duration above) to perform failure percentage-based ejection for this host. If the
   * volume is lower than this setting, failure percentage-based ejection will not be performed for
   * this host. Defaults to 50.
   */
  failure_percentage_request_volume?:
    | number
    | undefined;
  /**
   * The maximum time that a host is ejected for. See :ref:`base_ejection_time<envoy_v3_api_field_config.cluster.v3.OutlierDetection.base_ejection_time>`
   * for more information. If not specified, the default value (300000ms or 300s) or
   * :ref:`base_ejection_time<envoy_v3_api_field_config.cluster.v3.OutlierDetection.base_ejection_time>` value is applied, whatever is larger.
   */
  max_ejection_time?:
    | Duration
    | undefined;
  /**
   * The maximum amount of jitter to add to the ejection time, in order to prevent
   * a 'thundering herd' effect where all proxies try to reconnect to host at the same time.
   * See :ref:`max_ejection_time_jitter<envoy_v3_api_field_config.cluster.v3.OutlierDetection.base_ejection_time>`
   * Defaults to 0s.
   */
  max_ejection_time_jitter?:
    | Duration
    | undefined;
  /**
   * If active health checking is enabled and a host is ejected by outlier detection, a successful active health check
   * unejects the host by default and considers it as healthy. Unejection also clears all the outlier detection counters.
   * To change this default behavior set this config to ``false`` where active health checking will not uneject the host.
   * Defaults to true.
   */
  successful_active_health_check_uneject_host?:
    | boolean
    | undefined;
  /**
   * Set of host's passive monitors.
   * [#not-implemented-hide:]
   */
  monitors?:
    | TypedExtensionConfig[]
    | undefined;
  /**
   * If enabled, at least one host is ejected regardless of the value of :ref:`max_ejection_percent<envoy_v3_api_field_config.cluster.v3.OutlierDetection.max_ejection_percent>`.
   * Defaults to false.
   */
  always_eject_one_host?: boolean | undefined;
}

function createBaseOutlierDetection(): OutlierDetection {
  return { $type: "envoy.config.cluster.v3.OutlierDetection" };
}

export const OutlierDetection: MessageFns<OutlierDetection, "envoy.config.cluster.v3.OutlierDetection"> = {
  $type: "envoy.config.cluster.v3.OutlierDetection" as const,

  encode(message: OutlierDetection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.consecutive_5xx !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.consecutive_5xx! },
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.interval !== undefined) {
      Duration.encode(message.interval, writer.uint32(18).fork()).join();
    }
    if (message.base_ejection_time !== undefined) {
      Duration.encode(message.base_ejection_time, writer.uint32(26).fork()).join();
    }
    if (message.max_ejection_percent !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.max_ejection_percent! },
        writer.uint32(34).fork(),
      ).join();
    }
    if (message.enforcing_consecutive_5xx !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.enforcing_consecutive_5xx! },
        writer.uint32(42).fork(),
      ).join();
    }
    if (message.enforcing_success_rate !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.enforcing_success_rate! },
        writer.uint32(50).fork(),
      ).join();
    }
    if (message.success_rate_minimum_hosts !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.success_rate_minimum_hosts! },
        writer.uint32(58).fork(),
      ).join();
    }
    if (message.success_rate_request_volume !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.success_rate_request_volume! },
        writer.uint32(66).fork(),
      ).join();
    }
    if (message.success_rate_stdev_factor !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.success_rate_stdev_factor! },
        writer.uint32(74).fork(),
      ).join();
    }
    if (message.consecutive_gateway_failure !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.consecutive_gateway_failure! },
        writer.uint32(82).fork(),
      ).join();
    }
    if (message.enforcing_consecutive_gateway_failure !== undefined) {
      UInt32Value.encode({
        $type: "google.protobuf.UInt32Value",
        value: message.enforcing_consecutive_gateway_failure!,
      }, writer.uint32(90).fork()).join();
    }
    if (
      message.split_external_local_origin_errors !== undefined && message.split_external_local_origin_errors !== false
    ) {
      writer.uint32(96).bool(message.split_external_local_origin_errors);
    }
    if (message.consecutive_local_origin_failure !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.consecutive_local_origin_failure! },
        writer.uint32(106).fork(),
      ).join();
    }
    if (message.enforcing_consecutive_local_origin_failure !== undefined) {
      UInt32Value.encode({
        $type: "google.protobuf.UInt32Value",
        value: message.enforcing_consecutive_local_origin_failure!,
      }, writer.uint32(114).fork()).join();
    }
    if (message.enforcing_local_origin_success_rate !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.enforcing_local_origin_success_rate! },
        writer.uint32(122).fork(),
      ).join();
    }
    if (message.failure_percentage_threshold !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.failure_percentage_threshold! },
        writer.uint32(130).fork(),
      ).join();
    }
    if (message.enforcing_failure_percentage !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.enforcing_failure_percentage! },
        writer.uint32(138).fork(),
      ).join();
    }
    if (message.enforcing_failure_percentage_local_origin !== undefined) {
      UInt32Value.encode({
        $type: "google.protobuf.UInt32Value",
        value: message.enforcing_failure_percentage_local_origin!,
      }, writer.uint32(146).fork()).join();
    }
    if (message.failure_percentage_minimum_hosts !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.failure_percentage_minimum_hosts! },
        writer.uint32(154).fork(),
      ).join();
    }
    if (message.failure_percentage_request_volume !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.failure_percentage_request_volume! },
        writer.uint32(162).fork(),
      ).join();
    }
    if (message.max_ejection_time !== undefined) {
      Duration.encode(message.max_ejection_time, writer.uint32(170).fork()).join();
    }
    if (message.max_ejection_time_jitter !== undefined) {
      Duration.encode(message.max_ejection_time_jitter, writer.uint32(178).fork()).join();
    }
    if (message.successful_active_health_check_uneject_host !== undefined) {
      BoolValue.encode({
        $type: "google.protobuf.BoolValue",
        value: message.successful_active_health_check_uneject_host!,
      }, writer.uint32(186).fork()).join();
    }
    if (message.monitors !== undefined && message.monitors.length !== 0) {
      for (const v of message.monitors) {
        TypedExtensionConfig.encode(v!, writer.uint32(194).fork()).join();
      }
    }
    if (message.always_eject_one_host !== undefined) {
      BoolValue.encode(
        { $type: "google.protobuf.BoolValue", value: message.always_eject_one_host! },
        writer.uint32(202).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutlierDetection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutlierDetection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.consecutive_5xx = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.interval = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.base_ejection_time = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.max_ejection_percent = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.enforcing_consecutive_5xx = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.enforcing_success_rate = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.success_rate_minimum_hosts = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.success_rate_request_volume = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.success_rate_stdev_factor = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.consecutive_gateway_failure = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.enforcing_consecutive_gateway_failure = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.split_external_local_origin_errors = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.consecutive_local_origin_failure = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.enforcing_consecutive_local_origin_failure = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.enforcing_local_origin_success_rate = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.failure_percentage_threshold = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.enforcing_failure_percentage = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.enforcing_failure_percentage_local_origin = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.failure_percentage_minimum_hosts = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.failure_percentage_request_volume = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.max_ejection_time = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.max_ejection_time_jitter = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.successful_active_health_check_uneject_host = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          if (message.monitors === undefined) {
            message.monitors = [];
          }
          const el = TypedExtensionConfig.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.monitors!.push(el);
          }
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.always_eject_one_host = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutlierDetection {
    return {
      $type: OutlierDetection.$type,
      consecutive_5xx: isSet(object.consecutive_5xx) ? Number(object.consecutive_5xx) : undefined,
      interval: isSet(object.interval) ? Duration.fromJSON(object.interval) : undefined,
      base_ejection_time: isSet(object.base_ejection_time) ? Duration.fromJSON(object.base_ejection_time) : undefined,
      max_ejection_percent: isSet(object.max_ejection_percent) ? Number(object.max_ejection_percent) : undefined,
      enforcing_consecutive_5xx: isSet(object.enforcing_consecutive_5xx)
        ? Number(object.enforcing_consecutive_5xx)
        : undefined,
      enforcing_success_rate: isSet(object.enforcing_success_rate) ? Number(object.enforcing_success_rate) : undefined,
      success_rate_minimum_hosts: isSet(object.success_rate_minimum_hosts)
        ? Number(object.success_rate_minimum_hosts)
        : undefined,
      success_rate_request_volume: isSet(object.success_rate_request_volume)
        ? Number(object.success_rate_request_volume)
        : undefined,
      success_rate_stdev_factor: isSet(object.success_rate_stdev_factor)
        ? Number(object.success_rate_stdev_factor)
        : undefined,
      consecutive_gateway_failure: isSet(object.consecutive_gateway_failure)
        ? Number(object.consecutive_gateway_failure)
        : undefined,
      enforcing_consecutive_gateway_failure: isSet(object.enforcing_consecutive_gateway_failure)
        ? Number(object.enforcing_consecutive_gateway_failure)
        : undefined,
      split_external_local_origin_errors: isSet(object.split_external_local_origin_errors)
        ? globalThis.Boolean(object.split_external_local_origin_errors)
        : undefined,
      consecutive_local_origin_failure: isSet(object.consecutive_local_origin_failure)
        ? Number(object.consecutive_local_origin_failure)
        : undefined,
      enforcing_consecutive_local_origin_failure: isSet(object.enforcing_consecutive_local_origin_failure)
        ? Number(object.enforcing_consecutive_local_origin_failure)
        : undefined,
      enforcing_local_origin_success_rate: isSet(object.enforcing_local_origin_success_rate)
        ? Number(object.enforcing_local_origin_success_rate)
        : undefined,
      failure_percentage_threshold: isSet(object.failure_percentage_threshold)
        ? Number(object.failure_percentage_threshold)
        : undefined,
      enforcing_failure_percentage: isSet(object.enforcing_failure_percentage)
        ? Number(object.enforcing_failure_percentage)
        : undefined,
      enforcing_failure_percentage_local_origin: isSet(object.enforcing_failure_percentage_local_origin)
        ? Number(object.enforcing_failure_percentage_local_origin)
        : undefined,
      failure_percentage_minimum_hosts: isSet(object.failure_percentage_minimum_hosts)
        ? Number(object.failure_percentage_minimum_hosts)
        : undefined,
      failure_percentage_request_volume: isSet(object.failure_percentage_request_volume)
        ? Number(object.failure_percentage_request_volume)
        : undefined,
      max_ejection_time: isSet(object.max_ejection_time) ? Duration.fromJSON(object.max_ejection_time) : undefined,
      max_ejection_time_jitter: isSet(object.max_ejection_time_jitter)
        ? Duration.fromJSON(object.max_ejection_time_jitter)
        : undefined,
      successful_active_health_check_uneject_host: isSet(object.successful_active_health_check_uneject_host)
        ? Boolean(object.successful_active_health_check_uneject_host)
        : undefined,
      monitors: globalThis.Array.isArray(object?.monitors)
        ? object.monitors.map((e: any) => TypedExtensionConfig.fromJSON(e))
        : undefined,
      always_eject_one_host: isSet(object.always_eject_one_host) ? Boolean(object.always_eject_one_host) : undefined,
    };
  },

  toJSON(message: OutlierDetection): unknown {
    const obj: any = {};
    if (message.consecutive_5xx !== undefined) {
      obj.consecutive_5xx = message.consecutive_5xx;
    }
    if (message.interval !== undefined) {
      obj.interval = Duration.toJSON(message.interval);
    }
    if (message.base_ejection_time !== undefined) {
      obj.base_ejection_time = Duration.toJSON(message.base_ejection_time);
    }
    if (message.max_ejection_percent !== undefined) {
      obj.max_ejection_percent = message.max_ejection_percent;
    }
    if (message.enforcing_consecutive_5xx !== undefined) {
      obj.enforcing_consecutive_5xx = message.enforcing_consecutive_5xx;
    }
    if (message.enforcing_success_rate !== undefined) {
      obj.enforcing_success_rate = message.enforcing_success_rate;
    }
    if (message.success_rate_minimum_hosts !== undefined) {
      obj.success_rate_minimum_hosts = message.success_rate_minimum_hosts;
    }
    if (message.success_rate_request_volume !== undefined) {
      obj.success_rate_request_volume = message.success_rate_request_volume;
    }
    if (message.success_rate_stdev_factor !== undefined) {
      obj.success_rate_stdev_factor = message.success_rate_stdev_factor;
    }
    if (message.consecutive_gateway_failure !== undefined) {
      obj.consecutive_gateway_failure = message.consecutive_gateway_failure;
    }
    if (message.enforcing_consecutive_gateway_failure !== undefined) {
      obj.enforcing_consecutive_gateway_failure = message.enforcing_consecutive_gateway_failure;
    }
    if (message.split_external_local_origin_errors !== undefined) {
      obj.split_external_local_origin_errors = message.split_external_local_origin_errors;
    }
    if (message.consecutive_local_origin_failure !== undefined) {
      obj.consecutive_local_origin_failure = message.consecutive_local_origin_failure;
    }
    if (message.enforcing_consecutive_local_origin_failure !== undefined) {
      obj.enforcing_consecutive_local_origin_failure = message.enforcing_consecutive_local_origin_failure;
    }
    if (message.enforcing_local_origin_success_rate !== undefined) {
      obj.enforcing_local_origin_success_rate = message.enforcing_local_origin_success_rate;
    }
    if (message.failure_percentage_threshold !== undefined) {
      obj.failure_percentage_threshold = message.failure_percentage_threshold;
    }
    if (message.enforcing_failure_percentage !== undefined) {
      obj.enforcing_failure_percentage = message.enforcing_failure_percentage;
    }
    if (message.enforcing_failure_percentage_local_origin !== undefined) {
      obj.enforcing_failure_percentage_local_origin = message.enforcing_failure_percentage_local_origin;
    }
    if (message.failure_percentage_minimum_hosts !== undefined) {
      obj.failure_percentage_minimum_hosts = message.failure_percentage_minimum_hosts;
    }
    if (message.failure_percentage_request_volume !== undefined) {
      obj.failure_percentage_request_volume = message.failure_percentage_request_volume;
    }
    if (message.max_ejection_time !== undefined) {
      obj.max_ejection_time = Duration.toJSON(message.max_ejection_time);
    }
    if (message.max_ejection_time_jitter !== undefined) {
      obj.max_ejection_time_jitter = Duration.toJSON(message.max_ejection_time_jitter);
    }
    if (message.successful_active_health_check_uneject_host !== undefined) {
      obj.successful_active_health_check_uneject_host = message.successful_active_health_check_uneject_host;
    }
    if (message.monitors?.length) {
      obj.monitors = message.monitors.map((e) => TypedExtensionConfig.toJSON(e));
    }
    if (message.always_eject_one_host !== undefined) {
      obj.always_eject_one_host = message.always_eject_one_host;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OutlierDetection>, I>>(base?: I): OutlierDetection {
    return OutlierDetection.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OutlierDetection>, I>>(object: I): OutlierDetection {
    const message = createBaseOutlierDetection();
    message.consecutive_5xx = object.consecutive_5xx ?? undefined;
    message.interval = (object.interval !== undefined && object.interval !== null)
      ? Duration.fromPartial(object.interval)
      : undefined;
    message.base_ejection_time = (object.base_ejection_time !== undefined && object.base_ejection_time !== null)
      ? Duration.fromPartial(object.base_ejection_time)
      : undefined;
    message.max_ejection_percent = object.max_ejection_percent ?? undefined;
    message.enforcing_consecutive_5xx = object.enforcing_consecutive_5xx ?? undefined;
    message.enforcing_success_rate = object.enforcing_success_rate ?? undefined;
    message.success_rate_minimum_hosts = object.success_rate_minimum_hosts ?? undefined;
    message.success_rate_request_volume = object.success_rate_request_volume ?? undefined;
    message.success_rate_stdev_factor = object.success_rate_stdev_factor ?? undefined;
    message.consecutive_gateway_failure = object.consecutive_gateway_failure ?? undefined;
    message.enforcing_consecutive_gateway_failure = object.enforcing_consecutive_gateway_failure ?? undefined;
    message.split_external_local_origin_errors = object.split_external_local_origin_errors ?? undefined;
    message.consecutive_local_origin_failure = object.consecutive_local_origin_failure ?? undefined;
    message.enforcing_consecutive_local_origin_failure = object.enforcing_consecutive_local_origin_failure ?? undefined;
    message.enforcing_local_origin_success_rate = object.enforcing_local_origin_success_rate ?? undefined;
    message.failure_percentage_threshold = object.failure_percentage_threshold ?? undefined;
    message.enforcing_failure_percentage = object.enforcing_failure_percentage ?? undefined;
    message.enforcing_failure_percentage_local_origin = object.enforcing_failure_percentage_local_origin ?? undefined;
    message.failure_percentage_minimum_hosts = object.failure_percentage_minimum_hosts ?? undefined;
    message.failure_percentage_request_volume = object.failure_percentage_request_volume ?? undefined;
    message.max_ejection_time = (object.max_ejection_time !== undefined && object.max_ejection_time !== null)
      ? Duration.fromPartial(object.max_ejection_time)
      : undefined;
    message.max_ejection_time_jitter =
      (object.max_ejection_time_jitter !== undefined && object.max_ejection_time_jitter !== null)
        ? Duration.fromPartial(object.max_ejection_time_jitter)
        : undefined;
    message.successful_active_health_check_uneject_host = object.successful_active_health_check_uneject_host ??
      undefined;
    message.monitors = object.monitors?.map((e) => TypedExtensionConfig.fromPartial(e)) || undefined;
    message.always_eject_one_host = object.always_eject_one_host ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(OutlierDetection.$type, OutlierDetection);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
