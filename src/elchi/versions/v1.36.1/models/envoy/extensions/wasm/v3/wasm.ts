// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/wasm/v3/wasm.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Any } from "../../../../google/protobuf/any";
import { BoolValue } from "../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../typeRegistry";
import { BackoffStrategy } from "../../../config/core/v3/backoff";
import { AsyncDataSource } from "../../../config/core/v3/base";

export const protobufPackage = "envoy.extensions.wasm.v3";

/** If there is a fatal error on the VM (e.g. exception, ``abort()``), then the policy will be applied. */
export enum FailurePolicy {
  /** UNSPECIFIED - No policy is specified. The default policy will be used. The default policy is ``FAIL_CLOSED``. */
  UNSPECIFIED = "UNSPECIFIED",
  /**
   * FAIL_RELOAD - New plugin instance will be created for the new request if the VM is failed. Note this will only
   * be applied to the following failures:
   *
   * * ``proxy_wasm::FailState::RuntimeError``
   *
   * This will fallback to the ``FAIL_CLOSED`` for all other failures.
   */
  FAIL_RELOAD = "FAIL_RELOAD",
  /** FAIL_CLOSED - All plugins associated with the VM will return an HTTP 503 error. */
  FAIL_CLOSED = "FAIL_CLOSED",
  /**
   * FAIL_OPEN - All plugins associated with the VM will be ignored and the filter chain will continue. This
   * makes sense when the plugin is optional.
   */
  FAIL_OPEN = "FAIL_OPEN",
}

export function failurePolicyFromJSON(object: any): FailurePolicy {
  switch (object) {
    case 0:
    case "UNSPECIFIED":
      return FailurePolicy.UNSPECIFIED;
    case 1:
    case "FAIL_RELOAD":
      return FailurePolicy.FAIL_RELOAD;
    case 2:
    case "FAIL_CLOSED":
      return FailurePolicy.FAIL_CLOSED;
    case 3:
    case "FAIL_OPEN":
      return FailurePolicy.FAIL_OPEN;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum FailurePolicy");
  }
}

export function failurePolicyToJSON(object: FailurePolicy): string {
  switch (object) {
    case FailurePolicy.UNSPECIFIED:
      return "UNSPECIFIED";
    case FailurePolicy.FAIL_RELOAD:
      return "FAIL_RELOAD";
    case FailurePolicy.FAIL_CLOSED:
      return "FAIL_CLOSED";
    case FailurePolicy.FAIL_OPEN:
      return "FAIL_OPEN";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum FailurePolicy");
  }
}

export function failurePolicyToNumber(object: FailurePolicy): number {
  switch (object) {
    case FailurePolicy.UNSPECIFIED:
      return 0;
    case FailurePolicy.FAIL_RELOAD:
      return 1;
    case FailurePolicy.FAIL_CLOSED:
      return 2;
    case FailurePolicy.FAIL_OPEN:
      return 3;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum FailurePolicy");
  }
}

export interface ReloadConfig {
  $type: "envoy.extensions.wasm.v3.ReloadConfig";
  /**
   * Backoff strategy for the VM failure reload. If not specified, the default 1s base interval
   * will be applied.
   */
  backoff?: BackoffStrategy | undefined;
}

/** Configuration for restricting Proxy-Wasm capabilities available to modules. */
export interface CapabilityRestrictionConfig {
  $type: "envoy.extensions.wasm.v3.CapabilityRestrictionConfig";
  /**
   * The Proxy-Wasm capabilities which will be allowed. Capabilities are mapped by
   * name. The ``SanitizationConfig`` which each capability maps to is currently unimplemented and ignored,
   * and so should be left empty.
   *
   * The capability names are given in the
   * `Proxy-Wasm ABI <https://github.com/proxy-wasm/spec/tree/master/abi-versions/vNEXT>`_.
   * Additionally, the following WASI capabilities from
   * `this list <https://github.com/WebAssembly/WASI/blob/master/phases/snapshot/docs.md#modules>`_
   * are implemented and can be allowed:
   * ``fd_write``, ``fd_read``, ``fd_seek``, ``fd_close``, ``fd_fdstat_get``, ``environ_get``, ``environ_sizes_get``,
   * ``args_get``, ``args_sizes_get``, ``proc_exit``, ``clock_time_get``, ``random_get``.
   */
  allowed_capabilities?: Map<string, SanitizationConfig> | undefined;
}

export interface CapabilityRestrictionConfig_AllowedCapabilitiesEntry {
  $type: "envoy.extensions.wasm.v3.CapabilityRestrictionConfig.AllowedCapabilitiesEntry";
  key: string;
  value?: SanitizationConfig | undefined;
}

/**
 * Configuration for sanitization of inputs to an allowed capability.
 *
 * .. note::
 *   This is currently unimplemented.
 */
export interface SanitizationConfig {
  $type: "envoy.extensions.wasm.v3.SanitizationConfig";
}

/**
 * Configuration for a Wasm VM.
 * [#next-free-field: 8]
 */
export interface VmConfig {
  $type: "envoy.extensions.wasm.v3.VmConfig";
  /**
   * An ID which will be used along with a hash of the wasm code (or the name of the registered Null
   * VM plugin) to determine which VM will be used for the plugin. All plugins which use the same
   * ``vm_id`` and code will use the same VM. May be left blank. Sharing a VM between plugins can
   * reduce memory utilization and make sharing of data easier which may have security implications.
   * [#comment: TODO: add ref for details.]
   */
  vm_id?:
    | string
    | undefined;
  /**
   * The Wasm runtime type, defaults to the first available Wasm engine used at Envoy build-time.
   * The priority to search for the available engine is: v8 -> wasmtime -> wamr.
   * Available Wasm runtime types are registered as extensions. The following runtimes are included
   * in Envoy code base:
   *
   * .. _extension_envoy.wasm.runtime.null:
   *
   * **envoy.wasm.runtime.null**: Null sandbox, the Wasm module must be compiled and linked into the
   * Envoy binary. The registered name is given in the ``code`` field as ``inline_string``.
   *
   * .. _extension_envoy.wasm.runtime.v8:
   *
   * **envoy.wasm.runtime.v8**: `V8 <https://v8.dev/>`_-based WebAssembly runtime.
   *
   * .. _extension_envoy.wasm.runtime.wamr:
   *
   * **envoy.wasm.runtime.wamr**: `WAMR <https://github.com/bytecodealliance/wasm-micro-runtime/>`_-based WebAssembly runtime.
   * This runtime is not enabled in the official build.
   *
   * .. _extension_envoy.wasm.runtime.wasmtime:
   *
   * **envoy.wasm.runtime.wasmtime**: `Wasmtime <https://wasmtime.dev/>`_-based WebAssembly runtime.
   * This runtime is not enabled in the official build.
   *
   * [#extension-category: envoy.wasm.runtime]
   */
  runtime?:
    | string
    | undefined;
  /** The Wasm code that Envoy will execute. */
  code?:
    | AsyncDataSource
    | undefined;
  /**
   * The Wasm configuration used in initialization of a new VM
   * (``proxy_on_start``). ``google.protobuf.Struct`` is serialized as JSON before
   * passing it to the plugin. ``google.protobuf.BytesValue`` and
   * ``google.protobuf.StringValue`` are passed directly without the wrapper.
   */
  configuration?:
    | Any
    | undefined;
  /**
   * Allow the wasm file to include pre-compiled code on VMs which support it.
   *
   * .. warning::
   *   This should only be enabled for trusted sources as the precompiled code is not
   *   verified.
   */
  allow_precompiled?:
    | boolean
    | undefined;
  /**
   * If true and the code needs to be remotely fetched and it is not in the cache then NACK the configuration
   * update and do a background fetch to fill the cache, otherwise fetch the code asynchronously and enter
   * warming state.
   */
  nack_on_code_cache_miss?:
    | boolean
    | undefined;
  /**
   * Specifies environment variables to be injected to this VM which will be available through
   * WASI's ``environ_get`` and ``environ_get_sizes`` system calls. Note that these functions
   * are generally called implicitly by your language's standard library. Therefore, you do not
   * need to call them directly. You can access environment variables in the same way you would
   * on native platforms.
   *
   * .. warning::
   *   Envoy rejects the configuration if there's conflict of key space.
   */
  environment_variables?: EnvironmentVariables | undefined;
}

export interface EnvironmentVariables {
  $type: "envoy.extensions.wasm.v3.EnvironmentVariables";
  /**
   * The keys of *Envoy's* environment variables exposed to this VM. In other words, if a key exists in Envoy's environment
   * variables, then that key-value pair will be injected. Note that if a key does not exist, it will be ignored.
   */
  host_env_keys?:
    | string[]
    | undefined;
  /** Explicitly given key-value pairs to be injected to this VM in the form of "KEY=VALUE". */
  key_values?: Map<string, string> | undefined;
}

export interface EnvironmentVariables_KeyValuesEntry {
  $type: "envoy.extensions.wasm.v3.EnvironmentVariables.KeyValuesEntry";
  key: string;
  value: string;
}

/**
 * Base Configuration for Wasm Plugins e.g. filters and services.
 * [#next-free-field: 10]
 */
export interface PluginConfig {
  $type: "envoy.extensions.wasm.v3.PluginConfig";
  /**
   * A unique name for a filters/services in a VM for use in identifying the filter/service if
   * multiple filters/services are handled by the same ``vm_id`` and ``root_id`` and for
   * logging/debugging.
   */
  name?:
    | string
    | undefined;
  /**
   * A unique ID for a set of filters/services in a VM which will share a RootContext and Contexts
   * if applicable (e.g. an Wasm HttpFilter and an Wasm AccessLog). If left blank, all
   * filters/services with a blank root_id with the same ``vm_id`` will share Context(s).
   */
  root_id?:
    | string
    | undefined;
  /** Configuration for finding or starting VM. */
  vm?:
    | //
    /** TODO: add referential VM configurations. */
    { $case: "vm_config"; vm_config: VmConfig }
    | undefined;
  /**
   * Filter/service configuration used to configure or reconfigure a plugin
   * (``proxy_on_configure``).
   * ``google.protobuf.Struct`` is serialized as JSON before
   * passing it to the plugin. ``google.protobuf.BytesValue`` and
   * ``google.protobuf.StringValue`` are passed directly without the wrapper.
   */
  configuration?:
    | Any
    | undefined;
  /**
   * If there is a fatal error on the VM (e.g. exception, ``abort()``, ``on_start`` or ``on_configure`` return false),
   * then all plugins associated with the VM will either fail closed (by default), e.g. by returning an HTTP 503 error,
   * or fail open (if 'fail_open' is set to true) by bypassing the filter.
   *
   * .. note::
   *   When ``on_start`` or ``on_configure`` return ``false`` during xDS updates the xDS configuration will be rejected and when ``on_start`` or ``on_configure`` return ``false`` on
   *   initial startup the proxy will not start.
   *
   * This field is deprecated in favor of the ``failure_policy`` field.
   *
   * @deprecated
   */
  fail_open?:
    | boolean
    | undefined;
  /** The failure policy for the plugin. */
  failure_policy?:
    | FailurePolicy
    | undefined;
  /** Reload configuration. This is only applied when ``failure_policy`` is set to ``FAIL_RELOAD``. */
  reload_config?:
    | ReloadConfig
    | undefined;
  /** Configuration for restricting Proxy-Wasm capabilities available to modules. */
  capability_restriction_config?:
    | CapabilityRestrictionConfig
    | undefined;
  /**
   * Whether or not to allow plugin onRequestHeaders and onResponseHeaders callbacks to return
   * FilterHeadersStatus::StopIteration.
   */
  allow_on_headers_stop_iteration?: boolean | undefined;
}

/**
 * WasmService is configured as a built-in ``envoy.wasm_service`` :ref:`WasmService
 * <config_wasm_service>` This opaque configuration will be used to create a Wasm Service.
 */
export interface WasmService {
  $type: "envoy.extensions.wasm.v3.WasmService";
  /** General plugin configuration. */
  config?:
    | PluginConfig
    | undefined;
  /**
   * If true, create a single VM rather than creating one VM per worker. Such a singleton can
   * not be used with filters.
   */
  singleton?: boolean | undefined;
}

function createBaseReloadConfig(): ReloadConfig {
  return { $type: "envoy.extensions.wasm.v3.ReloadConfig" };
}

export const ReloadConfig: MessageFns<ReloadConfig, "envoy.extensions.wasm.v3.ReloadConfig"> = {
  $type: "envoy.extensions.wasm.v3.ReloadConfig" as const,

  encode(message: ReloadConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.backoff !== undefined) {
      BackoffStrategy.encode(message.backoff, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReloadConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReloadConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.backoff = BackoffStrategy.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReloadConfig {
    return {
      $type: ReloadConfig.$type,
      backoff: isSet(object.backoff) ? BackoffStrategy.fromJSON(object.backoff) : undefined,
    };
  },

  toJSON(message: ReloadConfig): unknown {
    const obj: any = {};
    if (message.backoff !== undefined) {
      obj.backoff = BackoffStrategy.toJSON(message.backoff);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReloadConfig>, I>>(base?: I): ReloadConfig {
    return ReloadConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReloadConfig>, I>>(object: I): ReloadConfig {
    const message = createBaseReloadConfig();
    message.backoff = (object.backoff !== undefined && object.backoff !== null)
      ? BackoffStrategy.fromPartial(object.backoff)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(ReloadConfig.$type, ReloadConfig);

function createBaseCapabilityRestrictionConfig(): CapabilityRestrictionConfig {
  return { $type: "envoy.extensions.wasm.v3.CapabilityRestrictionConfig" };
}

export const CapabilityRestrictionConfig: MessageFns<
  CapabilityRestrictionConfig,
  "envoy.extensions.wasm.v3.CapabilityRestrictionConfig"
> = {
  $type: "envoy.extensions.wasm.v3.CapabilityRestrictionConfig" as const,

  encode(message: CapabilityRestrictionConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    (message.allowed_capabilities || new Map()).forEach((value, key) => {
      CapabilityRestrictionConfig_AllowedCapabilitiesEntry.encode({
        $type: "envoy.extensions.wasm.v3.CapabilityRestrictionConfig.AllowedCapabilitiesEntry",
        key: key as any,
        value,
      }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CapabilityRestrictionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCapabilityRestrictionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = CapabilityRestrictionConfig_AllowedCapabilitiesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            if (message.allowed_capabilities === undefined) {
              message.allowed_capabilities = new Map();
            }
            message.allowed_capabilities!.set(entry1.key, entry1.value);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CapabilityRestrictionConfig {
    return {
      $type: CapabilityRestrictionConfig.$type,
      allowed_capabilities: isObject(object.allowed_capabilities)
        ? Object.entries(object.allowed_capabilities).reduce<Map<string, SanitizationConfig>>((acc, [key, value]) => {
          acc.set(key, SanitizationConfig.fromJSON(value));
          return acc;
        }, new Map())
        : undefined,
    };
  },

  toJSON(message: CapabilityRestrictionConfig): unknown {
    const obj: any = {};
    if (message.allowed_capabilities?.size) {
      obj.allowed_capabilities = {};
      message.allowed_capabilities.forEach((v, k) => {
        obj.allowed_capabilities[k] = SanitizationConfig.toJSON(v);
      });
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CapabilityRestrictionConfig>, I>>(base?: I): CapabilityRestrictionConfig {
    return CapabilityRestrictionConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CapabilityRestrictionConfig>, I>>(object: I): CapabilityRestrictionConfig {
    const message = createBaseCapabilityRestrictionConfig();
    message.allowed_capabilities = (object.allowed_capabilities === undefined || object.allowed_capabilities === null)
      ? undefined
      : (() => {
        const m = new Map();
        (object.allowed_capabilities as Map<string, SanitizationConfig> ?? new Map()).forEach((value, key) => {
          if (value !== undefined) {
            m.set(key, SanitizationConfig.fromPartial(value));
          }
        });
        return m;
      })();
    return message;
  },
};

messageTypeRegistry.set(CapabilityRestrictionConfig.$type, CapabilityRestrictionConfig);

function createBaseCapabilityRestrictionConfig_AllowedCapabilitiesEntry(): CapabilityRestrictionConfig_AllowedCapabilitiesEntry {
  return { $type: "envoy.extensions.wasm.v3.CapabilityRestrictionConfig.AllowedCapabilitiesEntry", key: "" };
}

export const CapabilityRestrictionConfig_AllowedCapabilitiesEntry: MessageFns<
  CapabilityRestrictionConfig_AllowedCapabilitiesEntry,
  "envoy.extensions.wasm.v3.CapabilityRestrictionConfig.AllowedCapabilitiesEntry"
> = {
  $type: "envoy.extensions.wasm.v3.CapabilityRestrictionConfig.AllowedCapabilitiesEntry" as const,

  encode(
    message: CapabilityRestrictionConfig_AllowedCapabilitiesEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      SanitizationConfig.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CapabilityRestrictionConfig_AllowedCapabilitiesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCapabilityRestrictionConfig_AllowedCapabilitiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = SanitizationConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CapabilityRestrictionConfig_AllowedCapabilitiesEntry {
    return {
      $type: CapabilityRestrictionConfig_AllowedCapabilitiesEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? SanitizationConfig.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: CapabilityRestrictionConfig_AllowedCapabilitiesEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = SanitizationConfig.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CapabilityRestrictionConfig_AllowedCapabilitiesEntry>, I>>(
    base?: I,
  ): CapabilityRestrictionConfig_AllowedCapabilitiesEntry {
    return CapabilityRestrictionConfig_AllowedCapabilitiesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CapabilityRestrictionConfig_AllowedCapabilitiesEntry>, I>>(
    object: I,
  ): CapabilityRestrictionConfig_AllowedCapabilitiesEntry {
    const message = createBaseCapabilityRestrictionConfig_AllowedCapabilitiesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? SanitizationConfig.fromPartial(object.value)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(
  CapabilityRestrictionConfig_AllowedCapabilitiesEntry.$type,
  CapabilityRestrictionConfig_AllowedCapabilitiesEntry,
);

function createBaseSanitizationConfig(): SanitizationConfig {
  return { $type: "envoy.extensions.wasm.v3.SanitizationConfig" };
}

export const SanitizationConfig: MessageFns<SanitizationConfig, "envoy.extensions.wasm.v3.SanitizationConfig"> = {
  $type: "envoy.extensions.wasm.v3.SanitizationConfig" as const,

  encode(_: SanitizationConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SanitizationConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSanitizationConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SanitizationConfig {
    return { $type: SanitizationConfig.$type };
  },

  toJSON(_: SanitizationConfig): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SanitizationConfig>, I>>(base?: I): SanitizationConfig {
    return SanitizationConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SanitizationConfig>, I>>(_: I): SanitizationConfig {
    const message = createBaseSanitizationConfig();
    return message;
  },
};

messageTypeRegistry.set(SanitizationConfig.$type, SanitizationConfig);

function createBaseVmConfig(): VmConfig {
  return { $type: "envoy.extensions.wasm.v3.VmConfig" };
}

export const VmConfig: MessageFns<VmConfig, "envoy.extensions.wasm.v3.VmConfig"> = {
  $type: "envoy.extensions.wasm.v3.VmConfig" as const,

  encode(message: VmConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vm_id !== undefined && message.vm_id !== "") {
      writer.uint32(10).string(message.vm_id);
    }
    if (message.runtime !== undefined && message.runtime !== "") {
      writer.uint32(18).string(message.runtime);
    }
    if (message.code !== undefined) {
      AsyncDataSource.encode(message.code, writer.uint32(26).fork()).join();
    }
    if (message.configuration !== undefined) {
      Any.encode(message.configuration, writer.uint32(34).fork()).join();
    }
    if (message.allow_precompiled !== undefined && message.allow_precompiled !== false) {
      writer.uint32(40).bool(message.allow_precompiled);
    }
    if (message.nack_on_code_cache_miss !== undefined && message.nack_on_code_cache_miss !== false) {
      writer.uint32(48).bool(message.nack_on_code_cache_miss);
    }
    if (message.environment_variables !== undefined) {
      EnvironmentVariables.encode(message.environment_variables, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VmConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVmConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.vm_id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.runtime = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.code = AsyncDataSource.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.configuration = Any.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.allow_precompiled = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.nack_on_code_cache_miss = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.environment_variables = EnvironmentVariables.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VmConfig {
    return {
      $type: VmConfig.$type,
      vm_id: isSet(object.vm_id) ? globalThis.String(object.vm_id) : undefined,
      runtime: isSet(object.runtime) ? globalThis.String(object.runtime) : undefined,
      code: isSet(object.code) ? AsyncDataSource.fromJSON(object.code) : undefined,
      configuration: isSet(object.configuration) ? Any.fromJSON(object.configuration) : undefined,
      allow_precompiled: isSet(object.allow_precompiled) ? globalThis.Boolean(object.allow_precompiled) : undefined,
      nack_on_code_cache_miss: isSet(object.nack_on_code_cache_miss)
        ? globalThis.Boolean(object.nack_on_code_cache_miss)
        : undefined,
      environment_variables: isSet(object.environment_variables)
        ? EnvironmentVariables.fromJSON(object.environment_variables)
        : undefined,
    };
  },

  toJSON(message: VmConfig): unknown {
    const obj: any = {};
    if (message.vm_id !== undefined) {
      obj.vm_id = message.vm_id;
    }
    if (message.runtime !== undefined) {
      obj.runtime = message.runtime;
    }
    if (message.code !== undefined) {
      obj.code = AsyncDataSource.toJSON(message.code);
    }
    if (message.configuration !== undefined) {
      obj.configuration = Any.toJSON(message.configuration);
    }
    if (message.allow_precompiled !== undefined) {
      obj.allow_precompiled = message.allow_precompiled;
    }
    if (message.nack_on_code_cache_miss !== undefined) {
      obj.nack_on_code_cache_miss = message.nack_on_code_cache_miss;
    }
    if (message.environment_variables !== undefined) {
      obj.environment_variables = EnvironmentVariables.toJSON(message.environment_variables);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VmConfig>, I>>(base?: I): VmConfig {
    return VmConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VmConfig>, I>>(object: I): VmConfig {
    const message = createBaseVmConfig();
    message.vm_id = object.vm_id ?? undefined;
    message.runtime = object.runtime ?? undefined;
    message.code = (object.code !== undefined && object.code !== null)
      ? AsyncDataSource.fromPartial(object.code)
      : undefined;
    message.configuration = (object.configuration !== undefined && object.configuration !== null)
      ? Any.fromPartial(object.configuration)
      : undefined;
    message.allow_precompiled = object.allow_precompiled ?? undefined;
    message.nack_on_code_cache_miss = object.nack_on_code_cache_miss ?? undefined;
    message.environment_variables =
      (object.environment_variables !== undefined && object.environment_variables !== null)
        ? EnvironmentVariables.fromPartial(object.environment_variables)
        : undefined;
    return message;
  },
};

messageTypeRegistry.set(VmConfig.$type, VmConfig);

function createBaseEnvironmentVariables(): EnvironmentVariables {
  return { $type: "envoy.extensions.wasm.v3.EnvironmentVariables" };
}

export const EnvironmentVariables: MessageFns<EnvironmentVariables, "envoy.extensions.wasm.v3.EnvironmentVariables"> = {
  $type: "envoy.extensions.wasm.v3.EnvironmentVariables" as const,

  encode(message: EnvironmentVariables, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.host_env_keys !== undefined && message.host_env_keys.length !== 0) {
      for (const v of message.host_env_keys) {
        writer.uint32(10).string(v!);
      }
    }
    (message.key_values || new Map()).forEach((value, key) => {
      EnvironmentVariables_KeyValuesEntry.encode({
        $type: "envoy.extensions.wasm.v3.EnvironmentVariables.KeyValuesEntry",
        key: key as any,
        value,
      }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnvironmentVariables {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvironmentVariables();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.host_env_keys === undefined) {
            message.host_env_keys = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.host_env_keys!.push(el);
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = EnvironmentVariables_KeyValuesEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            if (message.key_values === undefined) {
              message.key_values = new Map();
            }
            message.key_values!.set(entry2.key, entry2.value);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnvironmentVariables {
    return {
      $type: EnvironmentVariables.$type,
      host_env_keys: globalThis.Array.isArray(object?.host_env_keys)
        ? object.host_env_keys.map((e: any) => globalThis.String(e))
        : undefined,
      key_values: isObject(object.key_values)
        ? Object.entries(object.key_values).reduce<Map<string, string>>((acc, [key, value]) => {
          acc.set(key, String(value));
          return acc;
        }, new Map())
        : undefined,
    };
  },

  toJSON(message: EnvironmentVariables): unknown {
    const obj: any = {};
    if (message.host_env_keys?.length) {
      obj.host_env_keys = message.host_env_keys;
    }
    if (message.key_values?.size) {
      obj.key_values = {};
      message.key_values.forEach((v, k) => {
        obj.key_values[k] = v;
      });
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EnvironmentVariables>, I>>(base?: I): EnvironmentVariables {
    return EnvironmentVariables.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EnvironmentVariables>, I>>(object: I): EnvironmentVariables {
    const message = createBaseEnvironmentVariables();
    message.host_env_keys = object.host_env_keys?.map((e) => e) || undefined;
    message.key_values = (object.key_values === undefined || object.key_values === null) ? undefined : (() => {
      const m = new Map();
      (object.key_values as Map<string, string> ?? new Map()).forEach((value, key) => {
        if (value !== undefined) {
          m.set(key, globalThis.String(value));
        }
      });
      return m;
    })();
    return message;
  },
};

messageTypeRegistry.set(EnvironmentVariables.$type, EnvironmentVariables);

function createBaseEnvironmentVariables_KeyValuesEntry(): EnvironmentVariables_KeyValuesEntry {
  return { $type: "envoy.extensions.wasm.v3.EnvironmentVariables.KeyValuesEntry", key: "", value: "" };
}

export const EnvironmentVariables_KeyValuesEntry: MessageFns<
  EnvironmentVariables_KeyValuesEntry,
  "envoy.extensions.wasm.v3.EnvironmentVariables.KeyValuesEntry"
> = {
  $type: "envoy.extensions.wasm.v3.EnvironmentVariables.KeyValuesEntry" as const,

  encode(message: EnvironmentVariables_KeyValuesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnvironmentVariables_KeyValuesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvironmentVariables_KeyValuesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnvironmentVariables_KeyValuesEntry {
    return {
      $type: EnvironmentVariables_KeyValuesEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: EnvironmentVariables_KeyValuesEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EnvironmentVariables_KeyValuesEntry>, I>>(
    base?: I,
  ): EnvironmentVariables_KeyValuesEntry {
    return EnvironmentVariables_KeyValuesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EnvironmentVariables_KeyValuesEntry>, I>>(
    object: I,
  ): EnvironmentVariables_KeyValuesEntry {
    const message = createBaseEnvironmentVariables_KeyValuesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

messageTypeRegistry.set(EnvironmentVariables_KeyValuesEntry.$type, EnvironmentVariables_KeyValuesEntry);

function createBasePluginConfig(): PluginConfig {
  return { $type: "envoy.extensions.wasm.v3.PluginConfig", vm: undefined };
}

export const PluginConfig: MessageFns<PluginConfig, "envoy.extensions.wasm.v3.PluginConfig"> = {
  $type: "envoy.extensions.wasm.v3.PluginConfig" as const,

  encode(message: PluginConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.root_id !== undefined && message.root_id !== "") {
      writer.uint32(18).string(message.root_id);
    }
    switch (message.vm?.$case) {
      case "vm_config":
        VmConfig.encode(message.vm.vm_config, writer.uint32(26).fork()).join();
        break;
    }
    if (message.configuration !== undefined) {
      Any.encode(message.configuration, writer.uint32(34).fork()).join();
    }
    if (message.fail_open !== undefined && message.fail_open !== false) {
      writer.uint32(40).bool(message.fail_open);
    }
    if (message.failure_policy !== undefined && message.failure_policy !== FailurePolicy.UNSPECIFIED) {
      writer.uint32(56).int32(failurePolicyToNumber(message.failure_policy));
    }
    if (message.reload_config !== undefined) {
      ReloadConfig.encode(message.reload_config, writer.uint32(66).fork()).join();
    }
    if (message.capability_restriction_config !== undefined) {
      CapabilityRestrictionConfig.encode(message.capability_restriction_config, writer.uint32(50).fork()).join();
    }
    if (message.allow_on_headers_stop_iteration !== undefined) {
      BoolValue.encode(
        { $type: "google.protobuf.BoolValue", value: message.allow_on_headers_stop_iteration! },
        writer.uint32(74).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PluginConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePluginConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.root_id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.vm = { $case: "vm_config", vm_config: VmConfig.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.configuration = Any.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.fail_open = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.failure_policy = failurePolicyFromJSON(reader.int32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.reload_config = ReloadConfig.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.capability_restriction_config = CapabilityRestrictionConfig.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.allow_on_headers_stop_iteration = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PluginConfig {
    return {
      $type: PluginConfig.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      root_id: isSet(object.root_id) ? globalThis.String(object.root_id) : undefined,
      vm: isSet(object.vm_config) ? { $case: "vm_config", vm_config: VmConfig.fromJSON(object.vm_config) } : undefined,
      configuration: isSet(object.configuration) ? Any.fromJSON(object.configuration) : undefined,
      fail_open: isSet(object.fail_open) ? globalThis.Boolean(object.fail_open) : undefined,
      failure_policy: isSet(object.failure_policy) ? failurePolicyFromJSON(object.failure_policy) : undefined,
      reload_config: isSet(object.reload_config) ? ReloadConfig.fromJSON(object.reload_config) : undefined,
      capability_restriction_config: isSet(object.capability_restriction_config)
        ? CapabilityRestrictionConfig.fromJSON(object.capability_restriction_config)
        : undefined,
      allow_on_headers_stop_iteration: isSet(object.allow_on_headers_stop_iteration)
        ? Boolean(object.allow_on_headers_stop_iteration)
        : undefined,
    };
  },

  toJSON(message: PluginConfig): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.root_id !== undefined) {
      obj.root_id = message.root_id;
    }
    if (message.vm?.$case === "vm_config") {
      obj.vm_config = VmConfig.toJSON(message.vm.vm_config);
    }
    if (message.configuration !== undefined) {
      obj.configuration = Any.toJSON(message.configuration);
    }
    if (message.fail_open !== undefined) {
      obj.fail_open = message.fail_open;
    }
    if (message.failure_policy !== undefined) {
      obj.failure_policy = failurePolicyToJSON(message.failure_policy);
    }
    if (message.reload_config !== undefined) {
      obj.reload_config = ReloadConfig.toJSON(message.reload_config);
    }
    if (message.capability_restriction_config !== undefined) {
      obj.capability_restriction_config = CapabilityRestrictionConfig.toJSON(message.capability_restriction_config);
    }
    if (message.allow_on_headers_stop_iteration !== undefined) {
      obj.allow_on_headers_stop_iteration = message.allow_on_headers_stop_iteration;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PluginConfig>, I>>(base?: I): PluginConfig {
    return PluginConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PluginConfig>, I>>(object: I): PluginConfig {
    const message = createBasePluginConfig();
    message.name = object.name ?? undefined;
    message.root_id = object.root_id ?? undefined;
    if (object.vm?.$case === "vm_config" && object.vm?.vm_config !== undefined && object.vm?.vm_config !== null) {
      message.vm = { $case: "vm_config", vm_config: VmConfig.fromPartial(object.vm.vm_config) };
    }
    message.configuration = (object.configuration !== undefined && object.configuration !== null)
      ? Any.fromPartial(object.configuration)
      : undefined;
    message.fail_open = object.fail_open ?? undefined;
    message.failure_policy = object.failure_policy ?? undefined;
    message.reload_config = (object.reload_config !== undefined && object.reload_config !== null)
      ? ReloadConfig.fromPartial(object.reload_config)
      : undefined;
    message.capability_restriction_config =
      (object.capability_restriction_config !== undefined && object.capability_restriction_config !== null)
        ? CapabilityRestrictionConfig.fromPartial(object.capability_restriction_config)
        : undefined;
    message.allow_on_headers_stop_iteration = object.allow_on_headers_stop_iteration ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(PluginConfig.$type, PluginConfig);

function createBaseWasmService(): WasmService {
  return { $type: "envoy.extensions.wasm.v3.WasmService" };
}

export const WasmService: MessageFns<WasmService, "envoy.extensions.wasm.v3.WasmService"> = {
  $type: "envoy.extensions.wasm.v3.WasmService" as const,

  encode(message: WasmService, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.config !== undefined) {
      PluginConfig.encode(message.config, writer.uint32(10).fork()).join();
    }
    if (message.singleton !== undefined && message.singleton !== false) {
      writer.uint32(16).bool(message.singleton);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WasmService {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWasmService();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.config = PluginConfig.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.singleton = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WasmService {
    return {
      $type: WasmService.$type,
      config: isSet(object.config) ? PluginConfig.fromJSON(object.config) : undefined,
      singleton: isSet(object.singleton) ? globalThis.Boolean(object.singleton) : undefined,
    };
  },

  toJSON(message: WasmService): unknown {
    const obj: any = {};
    if (message.config !== undefined) {
      obj.config = PluginConfig.toJSON(message.config);
    }
    if (message.singleton !== undefined) {
      obj.singleton = message.singleton;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WasmService>, I>>(base?: I): WasmService {
    return WasmService.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WasmService>, I>>(object: I): WasmService {
    const message = createBaseWasmService();
    message.config = (object.config !== undefined && object.config !== null)
      ? PluginConfig.fromPartial(object.config)
      : undefined;
    message.singleton = object.singleton ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(WasmService.$type, WasmService);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
