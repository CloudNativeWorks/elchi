// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/filters/http/ratelimit/v3/rate_limit.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../../../../google/protobuf/duration";
import { messageTypeRegistry } from "../../../../../../typeRegistry";
import { HeaderValueOption, RuntimeFractionalPercent } from "../../../../../config/core/v3/base";
import { RateLimitServiceConfig } from "../../../../../config/ratelimit/v3/rls";
import { RateLimit as RateLimit1 } from "../../../../../config/route/v3/route_components";
import { HttpStatus } from "../../../../../type/v3/http_status";

export const protobufPackage = "envoy.extensions.filters.http.ratelimit.v3";

/** [#next-free-field: 18] */
export interface RateLimit {
  $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimit";
  /** The rate limit domain to use when calling the rate limit service. */
  domain?:
    | string
    | undefined;
  /**
   * Specifies the rate limit configurations to be applied with the same
   * stage number. If not set, the default stage number is 0.
   *
   * .. note::
   *
   *  The filter supports a range of 0 - 10 inclusively for stage numbers.
   */
  stage?:
    | number
    | undefined;
  /**
   * The type of requests the filter should apply to. The supported
   * types are ``internal``, ``external`` or ``both``. A request is considered internal if
   * :ref:`x-envoy-internal<config_http_conn_man_headers_x-envoy-internal>` is set to true. If
   * :ref:`x-envoy-internal<config_http_conn_man_headers_x-envoy-internal>` is not set or false, a
   * request is considered external. The filter defaults to ``both``, and it will apply to all request
   * types.
   */
  request_type?:
    | string
    | undefined;
  /**
   * The timeout in milliseconds for the rate limit service RPC. If not
   * set, this defaults to 20ms.
   */
  timeout?:
    | Duration
    | undefined;
  /**
   * The filter's behaviour in case the rate limiting service does
   * not respond back. When it is set to true, Envoy will not allow traffic in case of
   * communication failure between rate limiting service and the proxy.
   */
  failure_mode_deny?:
    | boolean
    | undefined;
  /**
   * Specifies whether a ``RESOURCE_EXHAUSTED`` gRPC code must be returned instead
   * of the default ``UNAVAILABLE`` gRPC code for a rate limited gRPC call. The
   * HTTP code will be 200 for a gRPC response.
   */
  rate_limited_as_resource_exhausted?:
    | boolean
    | undefined;
  /**
   * Configuration for an external rate limit service provider. If not
   * specified, any calls to the rate limit service will immediately return
   * success.
   */
  rate_limit_service?:
    | RateLimitServiceConfig
    | undefined;
  /**
   * Defines the standard version to use for X-RateLimit headers emitted by the filter:
   *
   * * ``X-RateLimit-Limit`` - indicates the request-quota associated to the
   *   client in the current time-window followed by the description of the
   *   quota policy. The values are returned by the rate limiting service in
   *   :ref:`current_limit<envoy_v3_api_field_service.ratelimit.v3.RateLimitResponse.DescriptorStatus.current_limit>`
   *   field. Example: ``10, 10;w=1;name="per-ip", 1000;w=3600``.
   * * ``X-RateLimit-Remaining`` - indicates the remaining requests in the
   *   current time-window. The values are returned by the rate limiting service
   *   in :ref:`limit_remaining<envoy_v3_api_field_service.ratelimit.v3.RateLimitResponse.DescriptorStatus.limit_remaining>`
   *   field.
   * * ``X-RateLimit-Reset`` - indicates the number of seconds until reset of
   *   the current time-window. The values are returned by the rate limiting service
   *   in :ref:`duration_until_reset<envoy_v3_api_field_service.ratelimit.v3.RateLimitResponse.DescriptorStatus.duration_until_reset>`
   *   field.
   *
   * In case rate limiting policy specifies more than one time window, the values
   * above represent the window that is closest to reaching its limit.
   *
   * For more information about the headers specification see selected version of
   * the `draft RFC <https://tools.ietf.org/id/draft-polli-ratelimit-headers-03.html>`_.
   *
   * Disabled by default.
   *
   * [#next-major-version: unify with local ratelimit, should use common.ratelimit.v3.XRateLimitHeadersRFCVersion instead.]
   */
  enable_x_ratelimit_headers?:
    | RateLimit_XRateLimitHeadersRFCVersion
    | undefined;
  /**
   * Disables emitting the :ref:`x-envoy-ratelimited<config_http_filters_router_x-envoy-ratelimited>` header
   * in case of rate limiting (i.e. 429 responses).
   * Having this header not present potentially makes the request retriable.
   */
  disable_x_envoy_ratelimited_header?:
    | boolean
    | undefined;
  /**
   * This field allows for a custom HTTP response status code to the downstream client when
   * the request has been rate limited.
   * Defaults to 429 (TooManyRequests).
   *
   * .. note::
   *   If this is set to < 400, 429 will be used instead.
   */
  rate_limited_status?:
    | HttpStatus
    | undefined;
  /**
   * Specifies a list of HTTP headers that should be added to each response for requests that
   * have been rate limited.
   */
  response_headers_to_add?:
    | HeaderValueOption[]
    | undefined;
  /**
   * Sets the HTTP status that is returned to the client when the ratelimit server returns an error
   * or cannot be reached. The default status is 500.
   */
  status_on_error?:
    | HttpStatus
    | undefined;
  /**
   * Optional additional prefix to use when emitting statistics. This allows to distinguish
   * emitted statistics between configured ``ratelimit`` filters in an HTTP filter chain.
   */
  stat_prefix?:
    | string
    | undefined;
  /**
   * If set, this will enable -- but not necessarily enforce -- the rate limit for the given
   * fraction of requests.
   *
   * If not set then ``ratelimit.http_filter_enabled`` runtime key will be used to determine
   * the fraction of requests to enforce rate limits on. And the default percentage of the
   * runtime key is 100% for backwards compatibility.
   */
  filter_enabled?:
    | RuntimeFractionalPercent
    | undefined;
  /**
   * If set, this will enforce the rate limit decisions for the given fraction of requests.
   *
   * Note: this only applies to the fraction of enabled requests.
   *
   * If not set then ``ratelimit.http_filter_enforcing`` runtime key will be used to determine
   * the fraction of requests to enforce rate limits on. And the default percentage of the
   * runtime key is 100% for backwards compatibility.
   */
  filter_enforced?:
    | RuntimeFractionalPercent
    | undefined;
  /**
   * If set, this will override the failure_mode_deny parameter with a runtime fraction.
   * If the runtime key is not specified, the value of failure_mode_deny will be used.
   *
   * Example:
   *
   * .. code-block:: yaml
   *
   *   failure_mode_deny: true
   *   failure_mode_deny_percent:
   *     default_value:
   *       numerator: 50
   *       denominator: HUNDRED
   *     runtime_key: ratelimit.failure_mode_deny_percent
   *
   * This means that when the rate limit service is unavailable, 50% of requests will be denied
   * (fail closed) and 50% will be allowed (fail open).
   */
  failure_mode_deny_percent?:
    | RuntimeFractionalPercent
    | undefined;
  /**
   * Rate limit configuration that is used to generate a list of descriptor entries based on
   * the request context. The generated entries will be sent to the rate limit service.
   * If this is set, then
   * :ref:`VirtualHost.rate_limits<envoy_v3_api_field_config.route.v3.VirtualHost.rate_limits>` or
   * :ref:`RouteAction.rate_limits<envoy_v3_api_field_config.route.v3.RouteAction.rate_limits>` fields
   * will be ignored. However, :ref:`RateLimitPerRoute.rate_limits<envoy_v3_api_field_extensions.filters.http.ratelimit.v3.RateLimitPerRoute.rate_limits>`
   * will take precedence over this field.
   *
   * .. note::
   *   Not all configuration fields of
   *   :ref:`rate limit config <envoy_v3_api_msg_config.route.v3.RateLimit>` is supported at here.
   *   Following fields are not supported:
   *
   *   1. :ref:`rate limit stage <envoy_v3_api_field_config.route.v3.RateLimit.stage>`.
   *   2. :ref:`dynamic metadata <envoy_v3_api_field_config.route.v3.RateLimit.Action.dynamic_metadata>`.
   *   3. :ref:`disable_key <envoy_v3_api_field_config.route.v3.RateLimit.disable_key>`.
   *   4. :ref:`override limit <envoy_v3_api_field_config.route.v3.RateLimit.limit>`.
   */
  rate_limits?: RateLimit1[] | undefined;
}

/**
 * Defines the version of the standard to use for X-RateLimit headers.
 *
 * [#next-major-version: unify with local ratelimit, should use common.ratelimit.v3.XRateLimitHeadersRFCVersion instead.]
 */
export enum RateLimit_XRateLimitHeadersRFCVersion {
  /** OFF - X-RateLimit headers disabled. */
  OFF = "OFF",
  /** DRAFT_VERSION_03 - Use `draft RFC Version 03 <https://tools.ietf.org/id/draft-polli-ratelimit-headers-03.html>`_. */
  DRAFT_VERSION_03 = "DRAFT_VERSION_03",
}

export function rateLimit_XRateLimitHeadersRFCVersionFromJSON(object: any): RateLimit_XRateLimitHeadersRFCVersion {
  switch (object) {
    case 0:
    case "OFF":
      return RateLimit_XRateLimitHeadersRFCVersion.OFF;
    case 1:
    case "DRAFT_VERSION_03":
      return RateLimit_XRateLimitHeadersRFCVersion.DRAFT_VERSION_03;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum RateLimit_XRateLimitHeadersRFCVersion",
      );
  }
}

export function rateLimit_XRateLimitHeadersRFCVersionToJSON(object: RateLimit_XRateLimitHeadersRFCVersion): string {
  switch (object) {
    case RateLimit_XRateLimitHeadersRFCVersion.OFF:
      return "OFF";
    case RateLimit_XRateLimitHeadersRFCVersion.DRAFT_VERSION_03:
      return "DRAFT_VERSION_03";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum RateLimit_XRateLimitHeadersRFCVersion",
      );
  }
}

export function rateLimit_XRateLimitHeadersRFCVersionToNumber(object: RateLimit_XRateLimitHeadersRFCVersion): number {
  switch (object) {
    case RateLimit_XRateLimitHeadersRFCVersion.OFF:
      return 0;
    case RateLimit_XRateLimitHeadersRFCVersion.DRAFT_VERSION_03:
      return 1;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum RateLimit_XRateLimitHeadersRFCVersion",
      );
  }
}

export interface RateLimitPerRoute {
  $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimitPerRoute";
  /**
   * Specifies if the rate limit filter should include the virtual host rate limits.
   * [#next-major-version: unify with local ratelimit, should use common.ratelimit.v3.VhRateLimitsOptions instead.]
   */
  vh_rate_limits?:
    | RateLimitPerRoute_VhRateLimitsOptions
    | undefined;
  /**
   * Specifies if the rate limit filter should include the lower levels (route level, virtual host level or cluster weight level) rate limits override options.
   * [#not-implemented-hide:]
   */
  override_option?:
    | RateLimitPerRoute_OverrideOptions
    | undefined;
  /**
   * Rate limit configuration that is used to generate a list of descriptor entries based on
   * the request context. The generated entries will be used to find one or multiple matched rate
   * limit rule from the ``descriptors``.
   * If this is set, then
   * :ref:`VirtualHost.rate_limits<envoy_v3_api_field_config.route.v3.VirtualHost.rate_limits>`,
   * :ref:`RouteAction.rate_limits<envoy_v3_api_field_config.route.v3.RouteAction.rate_limits>` and
   * :ref:`RateLimit.rate_limits<envoy_v3_api_field_extensions.filters.http.ratelimit.v3.RateLimit.rate_limits>` fields
   * will be ignored.
   *
   * .. note::
   *   Not all configuration fields of
   *   :ref:`rate limit config <envoy_v3_api_msg_config.route.v3.RateLimit>` is supported at here.
   *   Following fields are not supported:
   *
   *   1. :ref:`rate limit stage <envoy_v3_api_field_config.route.v3.RateLimit.stage>`.
   *   2. :ref:`dynamic metadata <envoy_v3_api_field_config.route.v3.RateLimit.Action.dynamic_metadata>`.
   *   3. :ref:`disable_key <envoy_v3_api_field_config.route.v3.RateLimit.disable_key>`.
   *   4. :ref:`override limit <envoy_v3_api_field_config.route.v3.RateLimit.limit>`.
   */
  rate_limits?:
    | RateLimit1[]
    | undefined;
  /** Overrides the domain. If not set, uses the filter-level domain instead. */
  domain?: string | undefined;
}

/** [#next-major-version: unify with local ratelimit, should use common.ratelimit.v3.VhRateLimitsOptions instead.] */
export enum RateLimitPerRoute_VhRateLimitsOptions {
  /** OVERRIDE - Use the virtual host rate limits unless the route has a rate limit policy. */
  OVERRIDE = "OVERRIDE",
  /** INCLUDE - Use the virtual host rate limits even if the route has a rate limit policy. */
  INCLUDE = "INCLUDE",
  /** IGNORE - Ignore the virtual host rate limits even if the route does not have a rate limit policy. */
  IGNORE = "IGNORE",
}

export function rateLimitPerRoute_VhRateLimitsOptionsFromJSON(object: any): RateLimitPerRoute_VhRateLimitsOptions {
  switch (object) {
    case 0:
    case "OVERRIDE":
      return RateLimitPerRoute_VhRateLimitsOptions.OVERRIDE;
    case 1:
    case "INCLUDE":
      return RateLimitPerRoute_VhRateLimitsOptions.INCLUDE;
    case 2:
    case "IGNORE":
      return RateLimitPerRoute_VhRateLimitsOptions.IGNORE;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum RateLimitPerRoute_VhRateLimitsOptions",
      );
  }
}

export function rateLimitPerRoute_VhRateLimitsOptionsToJSON(object: RateLimitPerRoute_VhRateLimitsOptions): string {
  switch (object) {
    case RateLimitPerRoute_VhRateLimitsOptions.OVERRIDE:
      return "OVERRIDE";
    case RateLimitPerRoute_VhRateLimitsOptions.INCLUDE:
      return "INCLUDE";
    case RateLimitPerRoute_VhRateLimitsOptions.IGNORE:
      return "IGNORE";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum RateLimitPerRoute_VhRateLimitsOptions",
      );
  }
}

export function rateLimitPerRoute_VhRateLimitsOptionsToNumber(object: RateLimitPerRoute_VhRateLimitsOptions): number {
  switch (object) {
    case RateLimitPerRoute_VhRateLimitsOptions.OVERRIDE:
      return 0;
    case RateLimitPerRoute_VhRateLimitsOptions.INCLUDE:
      return 1;
    case RateLimitPerRoute_VhRateLimitsOptions.IGNORE:
      return 2;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum RateLimitPerRoute_VhRateLimitsOptions",
      );
  }
}

/**
 * The override option determines how the filter handles the cases where there is an override config at a more specific level than this one (from least to most specific: virtual host, route, cluster weight).
 * [#not-implemented-hide:]
 */
export enum RateLimitPerRoute_OverrideOptions {
  /** DEFAULT - Client-defined default, typically OVERRIDE_POLICY. If VhRateLimitsOptions is set, that will be used instead. */
  DEFAULT = "DEFAULT",
  /** OVERRIDE_POLICY - If there is an override config at a more specific level, use that instead of this one. */
  OVERRIDE_POLICY = "OVERRIDE_POLICY",
  /** INCLUDE_POLICY - If there is an override config at a more specific level, use data from both. */
  INCLUDE_POLICY = "INCLUDE_POLICY",
  /** IGNORE_POLICY - If there is an override config at a more specific level, ignore it and use only this one. */
  IGNORE_POLICY = "IGNORE_POLICY",
}

export function rateLimitPerRoute_OverrideOptionsFromJSON(object: any): RateLimitPerRoute_OverrideOptions {
  switch (object) {
    case 0:
    case "DEFAULT":
      return RateLimitPerRoute_OverrideOptions.DEFAULT;
    case 1:
    case "OVERRIDE_POLICY":
      return RateLimitPerRoute_OverrideOptions.OVERRIDE_POLICY;
    case 2:
    case "INCLUDE_POLICY":
      return RateLimitPerRoute_OverrideOptions.INCLUDE_POLICY;
    case 3:
    case "IGNORE_POLICY":
      return RateLimitPerRoute_OverrideOptions.IGNORE_POLICY;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RateLimitPerRoute_OverrideOptions");
  }
}

export function rateLimitPerRoute_OverrideOptionsToJSON(object: RateLimitPerRoute_OverrideOptions): string {
  switch (object) {
    case RateLimitPerRoute_OverrideOptions.DEFAULT:
      return "DEFAULT";
    case RateLimitPerRoute_OverrideOptions.OVERRIDE_POLICY:
      return "OVERRIDE_POLICY";
    case RateLimitPerRoute_OverrideOptions.INCLUDE_POLICY:
      return "INCLUDE_POLICY";
    case RateLimitPerRoute_OverrideOptions.IGNORE_POLICY:
      return "IGNORE_POLICY";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RateLimitPerRoute_OverrideOptions");
  }
}

export function rateLimitPerRoute_OverrideOptionsToNumber(object: RateLimitPerRoute_OverrideOptions): number {
  switch (object) {
    case RateLimitPerRoute_OverrideOptions.DEFAULT:
      return 0;
    case RateLimitPerRoute_OverrideOptions.OVERRIDE_POLICY:
      return 1;
    case RateLimitPerRoute_OverrideOptions.INCLUDE_POLICY:
      return 2;
    case RateLimitPerRoute_OverrideOptions.IGNORE_POLICY:
      return 3;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RateLimitPerRoute_OverrideOptions");
  }
}

function createBaseRateLimit(): RateLimit {
  return { $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimit" };
}

export const RateLimit: MessageFns<RateLimit, "envoy.extensions.filters.http.ratelimit.v3.RateLimit"> = {
  $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimit" as const,

  encode(message: RateLimit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.domain !== undefined && message.domain !== "") {
      writer.uint32(10).string(message.domain);
    }
    if (message.stage !== undefined && message.stage !== 0) {
      writer.uint32(16).uint32(message.stage);
    }
    if (message.request_type !== undefined && message.request_type !== "") {
      writer.uint32(26).string(message.request_type);
    }
    if (message.timeout !== undefined) {
      Duration.encode(message.timeout, writer.uint32(34).fork()).join();
    }
    if (message.failure_mode_deny !== undefined && message.failure_mode_deny !== false) {
      writer.uint32(40).bool(message.failure_mode_deny);
    }
    if (
      message.rate_limited_as_resource_exhausted !== undefined && message.rate_limited_as_resource_exhausted !== false
    ) {
      writer.uint32(48).bool(message.rate_limited_as_resource_exhausted);
    }
    if (message.rate_limit_service !== undefined) {
      RateLimitServiceConfig.encode(message.rate_limit_service, writer.uint32(58).fork()).join();
    }
    if (
      message.enable_x_ratelimit_headers !== undefined &&
      message.enable_x_ratelimit_headers !== RateLimit_XRateLimitHeadersRFCVersion.OFF
    ) {
      writer.uint32(64).int32(rateLimit_XRateLimitHeadersRFCVersionToNumber(message.enable_x_ratelimit_headers));
    }
    if (
      message.disable_x_envoy_ratelimited_header !== undefined && message.disable_x_envoy_ratelimited_header !== false
    ) {
      writer.uint32(72).bool(message.disable_x_envoy_ratelimited_header);
    }
    if (message.rate_limited_status !== undefined) {
      HttpStatus.encode(message.rate_limited_status, writer.uint32(82).fork()).join();
    }
    if (message.response_headers_to_add !== undefined && message.response_headers_to_add.length !== 0) {
      for (const v of message.response_headers_to_add) {
        HeaderValueOption.encode(v!, writer.uint32(90).fork()).join();
      }
    }
    if (message.status_on_error !== undefined) {
      HttpStatus.encode(message.status_on_error, writer.uint32(98).fork()).join();
    }
    if (message.stat_prefix !== undefined && message.stat_prefix !== "") {
      writer.uint32(106).string(message.stat_prefix);
    }
    if (message.filter_enabled !== undefined) {
      RuntimeFractionalPercent.encode(message.filter_enabled, writer.uint32(114).fork()).join();
    }
    if (message.filter_enforced !== undefined) {
      RuntimeFractionalPercent.encode(message.filter_enforced, writer.uint32(122).fork()).join();
    }
    if (message.failure_mode_deny_percent !== undefined) {
      RuntimeFractionalPercent.encode(message.failure_mode_deny_percent, writer.uint32(130).fork()).join();
    }
    if (message.rate_limits !== undefined && message.rate_limits.length !== 0) {
      for (const v of message.rate_limits) {
        RateLimit1.encode(v!, writer.uint32(138).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.domain = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.stage = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.request_type = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.failure_mode_deny = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.rate_limited_as_resource_exhausted = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.rate_limit_service = RateLimitServiceConfig.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.enable_x_ratelimit_headers = rateLimit_XRateLimitHeadersRFCVersionFromJSON(reader.int32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.disable_x_envoy_ratelimited_header = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.rate_limited_status = HttpStatus.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          if (message.response_headers_to_add === undefined) {
            message.response_headers_to_add = [];
          }
          const el = HeaderValueOption.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.response_headers_to_add!.push(el);
          }
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.status_on_error = HttpStatus.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.stat_prefix = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.filter_enabled = RuntimeFractionalPercent.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.filter_enforced = RuntimeFractionalPercent.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.failure_mode_deny_percent = RuntimeFractionalPercent.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          if (message.rate_limits === undefined) {
            message.rate_limits = [];
          }
          const el = RateLimit1.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.rate_limits!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimit {
    return {
      $type: RateLimit.$type,
      domain: isSet(object.domain) ? globalThis.String(object.domain) : undefined,
      stage: isSet(object.stage) ? globalThis.Number(object.stage) : undefined,
      request_type: isSet(object.request_type) ? globalThis.String(object.request_type) : undefined,
      timeout: isSet(object.timeout) ? Duration.fromJSON(object.timeout) : undefined,
      failure_mode_deny: isSet(object.failure_mode_deny) ? globalThis.Boolean(object.failure_mode_deny) : undefined,
      rate_limited_as_resource_exhausted: isSet(object.rate_limited_as_resource_exhausted)
        ? globalThis.Boolean(object.rate_limited_as_resource_exhausted)
        : undefined,
      rate_limit_service: isSet(object.rate_limit_service)
        ? RateLimitServiceConfig.fromJSON(object.rate_limit_service)
        : undefined,
      enable_x_ratelimit_headers: isSet(object.enable_x_ratelimit_headers)
        ? rateLimit_XRateLimitHeadersRFCVersionFromJSON(object.enable_x_ratelimit_headers)
        : undefined,
      disable_x_envoy_ratelimited_header: isSet(object.disable_x_envoy_ratelimited_header)
        ? globalThis.Boolean(object.disable_x_envoy_ratelimited_header)
        : undefined,
      rate_limited_status: isSet(object.rate_limited_status)
        ? HttpStatus.fromJSON(object.rate_limited_status)
        : undefined,
      response_headers_to_add: globalThis.Array.isArray(object?.response_headers_to_add)
        ? object.response_headers_to_add.map((e: any) => HeaderValueOption.fromJSON(e))
        : undefined,
      status_on_error: isSet(object.status_on_error) ? HttpStatus.fromJSON(object.status_on_error) : undefined,
      stat_prefix: isSet(object.stat_prefix) ? globalThis.String(object.stat_prefix) : undefined,
      filter_enabled: isSet(object.filter_enabled)
        ? RuntimeFractionalPercent.fromJSON(object.filter_enabled)
        : undefined,
      filter_enforced: isSet(object.filter_enforced)
        ? RuntimeFractionalPercent.fromJSON(object.filter_enforced)
        : undefined,
      failure_mode_deny_percent: isSet(object.failure_mode_deny_percent)
        ? RuntimeFractionalPercent.fromJSON(object.failure_mode_deny_percent)
        : undefined,
      rate_limits: globalThis.Array.isArray(object?.rate_limits)
        ? object.rate_limits.map((e: any) => RateLimit1.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: RateLimit): unknown {
    const obj: any = {};
    if (message.domain !== undefined) {
      obj.domain = message.domain;
    }
    if (message.stage !== undefined) {
      obj.stage = Math.round(message.stage);
    }
    if (message.request_type !== undefined) {
      obj.request_type = message.request_type;
    }
    if (message.timeout !== undefined) {
      obj.timeout = Duration.toJSON(message.timeout);
    }
    if (message.failure_mode_deny !== undefined) {
      obj.failure_mode_deny = message.failure_mode_deny;
    }
    if (message.rate_limited_as_resource_exhausted !== undefined) {
      obj.rate_limited_as_resource_exhausted = message.rate_limited_as_resource_exhausted;
    }
    if (message.rate_limit_service !== undefined) {
      obj.rate_limit_service = RateLimitServiceConfig.toJSON(message.rate_limit_service);
    }
    if (message.enable_x_ratelimit_headers !== undefined) {
      obj.enable_x_ratelimit_headers = rateLimit_XRateLimitHeadersRFCVersionToJSON(message.enable_x_ratelimit_headers);
    }
    if (message.disable_x_envoy_ratelimited_header !== undefined) {
      obj.disable_x_envoy_ratelimited_header = message.disable_x_envoy_ratelimited_header;
    }
    if (message.rate_limited_status !== undefined) {
      obj.rate_limited_status = HttpStatus.toJSON(message.rate_limited_status);
    }
    if (message.response_headers_to_add?.length) {
      obj.response_headers_to_add = message.response_headers_to_add.map((e) => HeaderValueOption.toJSON(e));
    }
    if (message.status_on_error !== undefined) {
      obj.status_on_error = HttpStatus.toJSON(message.status_on_error);
    }
    if (message.stat_prefix !== undefined) {
      obj.stat_prefix = message.stat_prefix;
    }
    if (message.filter_enabled !== undefined) {
      obj.filter_enabled = RuntimeFractionalPercent.toJSON(message.filter_enabled);
    }
    if (message.filter_enforced !== undefined) {
      obj.filter_enforced = RuntimeFractionalPercent.toJSON(message.filter_enforced);
    }
    if (message.failure_mode_deny_percent !== undefined) {
      obj.failure_mode_deny_percent = RuntimeFractionalPercent.toJSON(message.failure_mode_deny_percent);
    }
    if (message.rate_limits?.length) {
      obj.rate_limits = message.rate_limits.map((e) => RateLimit1.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimit>, I>>(base?: I): RateLimit {
    return RateLimit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimit>, I>>(object: I): RateLimit {
    const message = createBaseRateLimit();
    message.domain = object.domain ?? undefined;
    message.stage = object.stage ?? undefined;
    message.request_type = object.request_type ?? undefined;
    message.timeout = (object.timeout !== undefined && object.timeout !== null)
      ? Duration.fromPartial(object.timeout)
      : undefined;
    message.failure_mode_deny = object.failure_mode_deny ?? undefined;
    message.rate_limited_as_resource_exhausted = object.rate_limited_as_resource_exhausted ?? undefined;
    message.rate_limit_service = (object.rate_limit_service !== undefined && object.rate_limit_service !== null)
      ? RateLimitServiceConfig.fromPartial(object.rate_limit_service)
      : undefined;
    message.enable_x_ratelimit_headers = object.enable_x_ratelimit_headers ?? undefined;
    message.disable_x_envoy_ratelimited_header = object.disable_x_envoy_ratelimited_header ?? undefined;
    message.rate_limited_status = (object.rate_limited_status !== undefined && object.rate_limited_status !== null)
      ? HttpStatus.fromPartial(object.rate_limited_status)
      : undefined;
    message.response_headers_to_add = object.response_headers_to_add?.map((e) => HeaderValueOption.fromPartial(e)) ||
      undefined;
    message.status_on_error = (object.status_on_error !== undefined && object.status_on_error !== null)
      ? HttpStatus.fromPartial(object.status_on_error)
      : undefined;
    message.stat_prefix = object.stat_prefix ?? undefined;
    message.filter_enabled = (object.filter_enabled !== undefined && object.filter_enabled !== null)
      ? RuntimeFractionalPercent.fromPartial(object.filter_enabled)
      : undefined;
    message.filter_enforced = (object.filter_enforced !== undefined && object.filter_enforced !== null)
      ? RuntimeFractionalPercent.fromPartial(object.filter_enforced)
      : undefined;
    message.failure_mode_deny_percent =
      (object.failure_mode_deny_percent !== undefined && object.failure_mode_deny_percent !== null)
        ? RuntimeFractionalPercent.fromPartial(object.failure_mode_deny_percent)
        : undefined;
    message.rate_limits = object.rate_limits?.map((e) => RateLimit1.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(RateLimit.$type, RateLimit);

function createBaseRateLimitPerRoute(): RateLimitPerRoute {
  return { $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimitPerRoute" };
}

export const RateLimitPerRoute: MessageFns<
  RateLimitPerRoute,
  "envoy.extensions.filters.http.ratelimit.v3.RateLimitPerRoute"
> = {
  $type: "envoy.extensions.filters.http.ratelimit.v3.RateLimitPerRoute" as const,

  encode(message: RateLimitPerRoute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (
      message.vh_rate_limits !== undefined && message.vh_rate_limits !== RateLimitPerRoute_VhRateLimitsOptions.OVERRIDE
    ) {
      writer.uint32(8).int32(rateLimitPerRoute_VhRateLimitsOptionsToNumber(message.vh_rate_limits));
    }
    if (
      message.override_option !== undefined && message.override_option !== RateLimitPerRoute_OverrideOptions.DEFAULT
    ) {
      writer.uint32(16).int32(rateLimitPerRoute_OverrideOptionsToNumber(message.override_option));
    }
    if (message.rate_limits !== undefined && message.rate_limits.length !== 0) {
      for (const v of message.rate_limits) {
        RateLimit1.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    if (message.domain !== undefined && message.domain !== "") {
      writer.uint32(34).string(message.domain);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimitPerRoute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimitPerRoute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.vh_rate_limits = rateLimitPerRoute_VhRateLimitsOptionsFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.override_option = rateLimitPerRoute_OverrideOptionsFromJSON(reader.int32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.rate_limits === undefined) {
            message.rate_limits = [];
          }
          const el = RateLimit1.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.rate_limits!.push(el);
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.domain = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimitPerRoute {
    return {
      $type: RateLimitPerRoute.$type,
      vh_rate_limits: isSet(object.vh_rate_limits)
        ? rateLimitPerRoute_VhRateLimitsOptionsFromJSON(object.vh_rate_limits)
        : undefined,
      override_option: isSet(object.override_option)
        ? rateLimitPerRoute_OverrideOptionsFromJSON(object.override_option)
        : undefined,
      rate_limits: globalThis.Array.isArray(object?.rate_limits)
        ? object.rate_limits.map((e: any) => RateLimit1.fromJSON(e))
        : undefined,
      domain: isSet(object.domain) ? globalThis.String(object.domain) : undefined,
    };
  },

  toJSON(message: RateLimitPerRoute): unknown {
    const obj: any = {};
    if (message.vh_rate_limits !== undefined) {
      obj.vh_rate_limits = rateLimitPerRoute_VhRateLimitsOptionsToJSON(message.vh_rate_limits);
    }
    if (message.override_option !== undefined) {
      obj.override_option = rateLimitPerRoute_OverrideOptionsToJSON(message.override_option);
    }
    if (message.rate_limits?.length) {
      obj.rate_limits = message.rate_limits.map((e) => RateLimit1.toJSON(e));
    }
    if (message.domain !== undefined) {
      obj.domain = message.domain;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimitPerRoute>, I>>(base?: I): RateLimitPerRoute {
    return RateLimitPerRoute.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimitPerRoute>, I>>(object: I): RateLimitPerRoute {
    const message = createBaseRateLimitPerRoute();
    message.vh_rate_limits = object.vh_rate_limits ?? undefined;
    message.override_option = object.override_option ?? undefined;
    message.rate_limits = object.rate_limits?.map((e) => RateLimit1.fromPartial(e)) || undefined;
    message.domain = object.domain ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RateLimitPerRoute.$type, RateLimitPerRoute);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
