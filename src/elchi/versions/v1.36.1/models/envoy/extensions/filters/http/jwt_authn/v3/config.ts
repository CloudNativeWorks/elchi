// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/filters/http/jwt_authn/v3/config.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../../../../google/protobuf/duration";
import { Empty } from "../../../../../../google/protobuf/empty";
import { messageTypeRegistry } from "../../../../../../typeRegistry";
import { DataSource, RetryPolicy } from "../../../../../config/core/v3/base";
import { HttpUri } from "../../../../../config/core/v3/http_uri";
import { RouteMatch } from "../../../../../config/route/v3/route_components";
import { StringMatcher } from "../../../../../type/matcher/v3/string";

export const protobufPackage = "envoy.extensions.filters.http.jwt_authn.v3";

/**
 * Please see following for JWT authentication flow:
 *
 * * `JSON Web Token (JWT) <https://tools.ietf.org/html/rfc7519>`_
 * * `The OAuth 2.0 Authorization Framework <https://tools.ietf.org/html/rfc6749>`_
 * * `OpenID Connect <http://openid.net/connect>`_
 *
 * A JwtProvider message specifies how a JSON Web Token (JWT) can be verified. It specifies:
 *
 * * issuer: the principal that issues the JWT. If specified, it has to match the ``iss`` field in JWT.
 * * allowed audiences: the ones in the token have to be listed here.
 * * how to fetch public key JWKS to verify the token signature.
 * * how to extract the JWT in the request.
 * * how to pass successfully verified token payload.
 *
 * Example:
 *
 * .. code-block:: yaml
 *
 *     issuer: https://example.com
 *     audiences:
 *     - bookstore_android.apps.googleusercontent.com
 *     - bookstore_web.apps.googleusercontent.com
 *     remote_jwks:
 *       http_uri:
 *         uri: https://example.com/.well-known/jwks.json
 *         cluster: example_jwks_cluster
 *         timeout: 1s
 *       cache_duration:
 *         seconds: 300
 *
 * [#next-free-field: 22]
 */
export interface JwtProvider {
  $type: "envoy.extensions.filters.http.jwt_authn.v3.JwtProvider";
  /**
   * Specify the `principal <https://tools.ietf.org/html/rfc7519#section-4.1.1>`_ that issued
   * the JWT, usually a URL or an email address.
   *
   * It is optional. If specified, it has to match the ``iss`` field in JWT,
   * otherwise the JWT ``iss`` field is not checked.
   *
   * Note: ``JwtRequirement`` :ref:`allow_missing <envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.JwtRequirement.allow_missing>`
   * and :ref:`allow_missing_or_failed <envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.JwtRequirement.allow_missing_or_failed>`
   * are implemented differently than other ``JwtRequirements``. Hence the usage of this field
   * is different as follows if ``allow_missing`` or ``allow_missing_or_failed`` is used:
   *
   * * If a JWT has ``iss`` field, it needs to be specified by this field in one of ``JwtProviders``.
   * * If a JWT doesn't have ``iss`` field, one of ``JwtProviders`` should fill this field empty.
   * * Multiple ``JwtProviders`` should not have same value in this field.
   *
   * Example: https://securetoken.google.com
   * Example: 1234567-compute@developer.gserviceaccount.com
   */
  issuer?:
    | string
    | undefined;
  /**
   * The list of JWT `audiences <https://tools.ietf.org/html/rfc7519#section-4.1.3>`_ are
   * allowed to access. A JWT containing any of these audiences will be accepted. If not specified,
   * will not check audiences in the token.
   *
   * Example:
   *
   * .. code-block:: yaml
   *
   *     audiences:
   *     - bookstore_android.apps.googleusercontent.com
   *     - bookstore_web.apps.googleusercontent.com
   */
  audiences?:
    | string[]
    | undefined;
  /**
   * Restrict the `subjects <https://tools.ietf.org/html/rfc7519#section-4.1.2>`_
   * that the JwtProvider can assert. For instance, this could implement JWT-SVID
   * `subject restrictions <https://github.com/spiffe/spiffe/blob/main/standards/JWT-SVID.md#31-subject>`_.
   * If not specified, will not check subjects in the token.
   *
   * Example:
   *
   * .. code-block:: yaml
   *
   *     subjects:
   *       prefix: spiffe://spiffe.example.com/
   */
  subjects?:
    | StringMatcher
    | undefined;
  /**
   * Requires that the credential contains an `expiration <https://tools.ietf.org/html/rfc7519#section-4.1.4>`_.
   * For instance, this could implement JWT-SVID
   * `expiration restrictions <https://github.com/spiffe/spiffe/blob/main/standards/JWT-SVID.md#33-expiration-time>`_.
   * Unlike ``max_lifetime``, this only requires that expiration is present, where ``max_lifetime`` also checks the value.
   *
   * Example:
   *
   * .. code-block:: yaml
   *
   *     require_expiration: true
   */
  require_expiration?:
    | boolean
    | undefined;
  /**
   * Restrict the maximum remaining lifetime of a credential from the JwtProvider. Credential lifetime
   * is the difference between the current time and the expiration of the credential. For instance,
   * the following example will reject credentials that have a lifetime longer than 24 hours. If not set,
   * expiration checking still occurs, but there is no limit on credential lifetime. If set, takes precedence
   * over ``require_expiration``.
   *
   * Example:
   *
   * .. code-block:: yaml
   *
   *     max_lifetime:
   *       seconds: 86400
   */
  max_lifetime?:
    | Duration
    | undefined;
  /**
   * `JSON Web Key Set (JWKS) <https://tools.ietf.org/html/rfc7517#appendix-A>`_ is needed to
   * validate signature of a JWT. This field specifies where to fetch JWKS.
   */
  jwks_source_specifier?:
    | //
    /**
     * JWKS can be fetched from remote server via HTTP/HTTPS. This field specifies the remote HTTP
     * URI and how the fetched JWKS should be cached.
     *
     * Example:
     *
     * .. code-block:: yaml
     *
     *    remote_jwks:
     *      http_uri:
     *        uri: https://www.googleapis.com/oauth2/v1/certs
     *        cluster: jwt.www.googleapis.com|443
     *        timeout: 1s
     *      cache_duration:
     *        seconds: 300
     */
    { $case: "remote_jwks"; remote_jwks: RemoteJwks }
    | //
    /**
     * JWKS is in local data source. It could be either in a local file or embedded in the
     * inline_string.
     *
     * Example: local file
     *
     * .. code-block:: yaml
     *
     *    local_jwks:
     *      filename: /etc/envoy/jwks/jwks1.txt
     *
     * Example: inline_string
     *
     * .. code-block:: yaml
     *
     *    local_jwks:
     *      inline_string: ACADADADADA
     */
    { $case: "local_jwks"; local_jwks: DataSource }
    | undefined;
  /**
   * If false, the JWT is removed in the request after a success verification. If true, the JWT is
   * not removed in the request. Default value is false.
   * caveat: only works for from_header/from_params & has no effect for JWTs extracted through from_cookies.
   */
  forward?:
    | boolean
    | undefined;
  /**
   * Two fields below define where to extract the JWT from an HTTP request.
   *
   * If no explicit location is specified, the following default locations are tried in order:
   *
   * 1. The Authorization header using the `Bearer schema
   * <https://tools.ietf.org/html/rfc6750#section-2.1>`_. Example::
   *
   *    Authorization: Bearer <token>.
   *
   * 2. `access_token <https://tools.ietf.org/html/rfc6750#section-2.3>`_ query parameter.
   *
   * Multiple JWTs can be verified for a request. Each JWT has to be extracted from the locations
   * its provider specified or from the default locations.
   *
   * Specify the HTTP headers to extract the JWT. For examples, following config:
   *
   * .. code-block:: yaml
   *
   *   from_headers:
   *   - name: x-goog-iap-jwt-assertion
   *
   * can be used to extract token from header::
   *
   *   ``x-goog-iap-jwt-assertion: <JWT>``.
   */
  from_headers?:
    | JwtHeader[]
    | undefined;
  /**
   * JWT is sent in a query parameter. ``jwt_params`` represents the query parameter names.
   *
   * For example, if config is:
   *
   * .. code-block:: yaml
   *
   *   from_params:
   *   - jwt_token
   *
   * The JWT format in query parameter is::
   *
   *    /path?jwt_token=<JWT>
   */
  from_params?:
    | string[]
    | undefined;
  /**
   * JWT is sent in a cookie. ``from_cookies`` represents the cookie names to extract from.
   *
   * For example, if config is:
   *
   * .. code-block:: yaml
   *
   *   from_cookies:
   *   - auth-token
   *
   * Then JWT will be extracted from ``auth-token`` cookie in the request.
   */
  from_cookies?:
    | string[]
    | undefined;
  /**
   * This field specifies the header name to forward a successfully verified JWT payload to the
   * backend. The forwarded data is::
   *
   *    base64url_encoded(jwt_payload_in_JSON)
   *
   * If it is not specified, the payload will not be forwarded.
   */
  forward_payload_header?:
    | string
    | undefined;
  /**
   * When :ref:`forward_payload_header <envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.JwtProvider.forward_payload_header>`
   * is specified, the base64 encoded payload will be added to the headers.
   * Normally JWT based64 encode doesn't add padding. If this field is true,
   * the header will be padded.
   *
   * This field is only relevant if :ref:`forward_payload_header <envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.JwtProvider.forward_payload_header>`
   * is specified.
   */
  pad_forward_payload_header?:
    | boolean
    | undefined;
  /**
   * If non empty, successfully verified JWT payloads will be written to StreamInfo DynamicMetadata
   * in the format as: ``namespace`` is the jwt_authn filter name as ````envoy.filters.http.jwt_authn````
   * The value is the ``protobuf::Struct``. The value of this field will be the key for its ``fields``
   * and the value is the ``protobuf::Struct`` converted from JWT JSON payload.
   *
   * For example, if payload_in_metadata is ``my_payload``:
   *
   * .. code-block:: yaml
   *
   *   envoy.filters.http.jwt_authn:
   *     my_payload:
   *       iss: https://example.com
   *       sub: test@example.com
   *       aud: https://example.com
   *       exp: 1501281058
   */
  payload_in_metadata?:
    | string
    | undefined;
  /** Normalizes the payload representation in the request metadata. */
  normalize_payload_in_metadata?:
    | JwtProvider_NormalizePayload
    | undefined;
  /**
   * If not empty, similar to :ref:`payload_in_metadata <envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.JwtProvider.payload_in_metadata>`,
   * a successfully verified JWT header will be written to :ref:`Dynamic State <arch_overview_data_sharing_between_filters>`
   * as an entry (``protobuf::Struct``) in ``envoy.filters.http.jwt_authn`` ``namespace`` with the
   * value of this field as the key.
   *
   * For example, if ``header_in_metadata`` is ``my_header``:
   *
   * .. code-block:: yaml
   *
   *   envoy.filters.http.jwt_authn:
   *     my_header:
   *       alg: JWT
   *       kid: EF71iSaosbC5C4tC6Syq1Gm647M
   *       alg: PS256
   *
   * When the metadata has ``envoy.filters.http.jwt_authn`` entry already (for example if
   * :ref:`payload_in_metadata <envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.JwtProvider.payload_in_metadata>`
   * is not empty), it will be inserted as a new entry in the same ``namespace`` as shown below:
   *
   * .. code-block:: yaml
   *
   *   envoy.filters.http.jwt_authn:
   *     my_payload:
   *       iss: https://example.com
   *       sub: test@example.com
   *       aud: https://example.com
   *       exp: 1501281058
   *     my_header:
   *       alg: JWT
   *       kid: EF71iSaosbC5C4tC6Syq1Gm647M
   *       alg: PS256
   *
   * .. warning::
   *   Using the same key name for :ref:`header_in_metadata <envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.JwtProvider.payload_in_metadata>`
   *   and :ref:`payload_in_metadata <envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.JwtProvider.payload_in_metadata>`
   *   is not suggested due to potential override of existing entry, while it is not enforced during
   *   config validation.
   */
  header_in_metadata?:
    | string
    | undefined;
  /**
   * If non empty, the failure status ``::google::jwt_verify::Status`` for a non verified JWT will be written to StreamInfo DynamicMetadata
   * in the format as: ``namespace`` is the jwt_authn filter name as ``envoy.filters.http.jwt_authn``
   * The value is the ``protobuf::Struct``. The values of this field will be ``code`` and ``message``
   * and they will contain the JWT authentication failure status code and a message describing the failure.
   *
   * For example, if failed_status_in_metadata is ``my_auth_failure_status``:
   *
   * .. code-block:: yaml
   *
   *   envoy.filters.http.jwt_authn:
   *     my_auth_failure_status:
   *       code: 3
   *       message: Jwt expired
   */
  failed_status_in_metadata?:
    | string
    | undefined;
  /**
   * Specify the clock skew in seconds when verifying JWT time constraint,
   * such as ``exp``, and ``nbf``. If not specified, default is 60 seconds.
   */
  clock_skew_seconds?:
    | number
    | undefined;
  /**
   * Enables JWT cache, its size is specified by ``jwt_cache_size``.
   * Only valid JWTs are cached.
   */
  jwt_cache_config?:
    | JwtCacheConfig
    | undefined;
  /**
   * Add JWT claim to HTTP Header
   * Specify the claim name you want to copy in which HTTP header. For examples, following config:
   * The claim must be of type; string, int, double, bool. Array type claims are not supported
   *
   * .. literalinclude:: /_configs/repo/jwt_authn.yaml
   *    :language: yaml
   *    :lines: 44-48
   *    :linenos:
   *    :lineno-start: 44
   *    :caption: :download:`jwt_authn.yaml </_configs/repo/jwt_authn.yaml>`
   *
   * This header is only reserved for jwt claim; any other value will be overwritten.
   */
  claim_to_headers?:
    | JwtClaimToHeader[]
    | undefined;
  /**
   * Clears route cache in order to allow the JWT to correctly affect
   * routing decisions. Filter clears all cached routes when:
   *
   * 1. The field is set to ``true``.
   *
   * 2. At least one ``claim_to_headers`` header is added to the request OR
   *    if ``payload_in_metadata`` is set.
   */
  clear_route_cache?: boolean | undefined;
}

/** Alters the payload representation in the request dynamic metadata to facilitate its use in matching. */
export interface JwtProvider_NormalizePayload {
  $type: "envoy.extensions.filters.http.jwt_authn.v3.JwtProvider.NormalizePayload";
  /**
   * Each claim in this list will be interpreted as a space-delimited string
   * and converted to a list of strings based on the delimited values.
   * Example: a token with a claim ``scope: "email profile"`` is translated
   * to dynamic metadata  ``scope: ["email", "profile"]`` if this field is
   * set value ``["scope"]``. This special handling of ``scope`` is
   * recommended by `RFC8693
   * <https://datatracker.ietf.org/doc/html/rfc8693#name-scope-scopes-claim>`_.
   */
  space_delimited_claims?: string[] | undefined;
}

/** This message specifies JWT Cache configuration. */
export interface JwtCacheConfig {
  $type: "envoy.extensions.filters.http.jwt_authn.v3.JwtCacheConfig";
  /** The unit is number of JWTs, default to 100. */
  jwt_cache_size?:
    | number
    | undefined;
  /**
   * The maximum size of a single cached token in bytes.
   * If this field is not set or is set to 0, then the default value 4096 bytes is used.
   * The maximum value for a token is inclusive.
   */
  jwt_max_token_size?: number | undefined;
}

/** This message specifies how to fetch JWKS from remote and how to cache it. */
export interface RemoteJwks {
  $type: "envoy.extensions.filters.http.jwt_authn.v3.RemoteJwks";
  /**
   * The HTTP URI to fetch the JWKS. For example:
   *
   * .. code-block:: yaml
   *
   *    http_uri:
   *      uri: https://www.googleapis.com/oauth2/v1/certs
   *      cluster: jwt.www.googleapis.com|443
   *      timeout: 1s
   */
  http_uri?:
    | HttpUri
    | undefined;
  /**
   * Duration after which the cached JWKS should be expired. If not specified, default cache
   * duration is 10 minutes.
   */
  cache_duration?:
    | Duration
    | undefined;
  /**
   * Fetch Jwks asynchronously in the main thread before the listener is activated.
   * Fetched Jwks can be used by all worker threads.
   *
   * If this feature is not enabled:
   *
   * * The Jwks is fetched on-demand when the requests come. During the fetching, first
   *   few requests are paused until the Jwks is fetched.
   * * Each worker thread fetches its own Jwks since Jwks cache is per worker thread.
   *
   * If this feature is enabled:
   *
   * * Fetched Jwks is done in the main thread before the listener is activated. Its fetched
   *   Jwks can be used by all worker threads. Each worker thread doesn't need to fetch its own.
   * * Jwks is ready when the requests come, not need to wait for the Jwks fetching.
   */
  async_fetch?:
    | JwksAsyncFetch
    | undefined;
  /**
   * Retry policy for fetching Jwks. optional. turned off by default.
   *
   * For example:
   *
   * .. code-block:: yaml
   *
   *   retry_policy:
   *     retry_back_off:
   *       base_interval: 0.01s
   *       max_interval: 20s
   *     num_retries: 10
   *
   * will yield a randomized truncated exponential backoff policy with an initial delay of 10ms
   * 10 maximum attempts spaced at most 20s seconds.
   *
   * .. code-block:: yaml
   *
   *   retry_policy:
   *     num_retries:1
   *
   * uses the default :ref:`retry backoff strategy <envoy_v3_api_msg_config.core.v3.BackoffStrategy>`.
   * with the default base interval is 1000 milliseconds. and the default maximum interval of 10 times the base interval.
   *
   * if num_retries is omitted, the default is to allow only one retry.
   *
   * If enabled, the retry policy will apply to all Jwks fetching approaches, e.g. on demand or asynchronously in background.
   */
  retry_policy?: RetryPolicy | undefined;
}

/**
 * Fetch Jwks asynchronously in the main thread when the filter config is parsed.
 * The listener is activated only after the Jwks is fetched.
 * When the Jwks is expired in the cache, it is fetched again in the main thread.
 * The fetched Jwks from the main thread can be used by all worker threads.
 */
export interface JwksAsyncFetch {
  $type: "envoy.extensions.filters.http.jwt_authn.v3.JwksAsyncFetch";
  /**
   * If false, the listener is activated after the initial fetch is completed.
   * The initial fetch result can be either successful or failed.
   * If true, it is activated without waiting for the initial fetch to complete.
   * Default is false.
   */
  fast_listener?:
    | boolean
    | undefined;
  /** The duration to refetch after a failed fetch. If not specified, default is 1 second. */
  failed_refetch_duration?: Duration | undefined;
}

/** This message specifies a header location to extract the JWT. */
export interface JwtHeader {
  $type: "envoy.extensions.filters.http.jwt_authn.v3.JwtHeader";
  /** The HTTP header name. */
  name?:
    | string
    | undefined;
  /**
   * The value prefix. The value format is "value_prefix<token>"
   * For example, for "Authorization: Bearer <token>", value_prefix="Bearer " with a space at the
   * end.
   */
  value_prefix?: string | undefined;
}

/** Specify a required provider with audiences. */
export interface ProviderWithAudiences {
  $type: "envoy.extensions.filters.http.jwt_authn.v3.ProviderWithAudiences";
  /** Specify a required provider name. */
  provider_name?:
    | string
    | undefined;
  /** This field overrides the one specified in the JwtProvider. */
  audiences?: string[] | undefined;
}

/**
 * This message specifies a Jwt requirement. An empty message means JWT verification is not
 * required. Here are some config examples:
 *
 * .. code-block:: yaml
 *
 *  # Example 1: not required with an empty message
 *
 *  # Example 2: require A
 *  provider_name: provider-A
 *
 *  # Example 3: require A or B
 *  requires_any:
 *    requirements:
 *      - provider_name: provider-A
 *      - provider_name: provider-B
 *
 *  # Example 4: require A and B
 *  requires_all:
 *    requirements:
 *      - provider_name: provider-A
 *      - provider_name: provider-B
 *
 *  # Example 5: require A and (B or C)
 *  requires_all:
 *    requirements:
 *      - provider_name: provider-A
 *      - requires_any:
 *        requirements:
 *          - provider_name: provider-B
 *          - provider_name: provider-C
 *
 *  # Example 6: require A or (B and C)
 *  requires_any:
 *    requirements:
 *      - provider_name: provider-A
 *      - requires_all:
 *        requirements:
 *          - provider_name: provider-B
 *          - provider_name: provider-C
 *
 *  # Example 7: A is optional (if token from A is provided, it must be valid, but also allows
 *  missing token.)
 *  requires_any:
 *    requirements:
 *    - provider_name: provider-A
 *    - allow_missing: {}
 *
 *  # Example 8: A is optional and B is required.
 *  requires_all:
 *    requirements:
 *    - requires_any:
 *        requirements:
 *        - provider_name: provider-A
 *        - allow_missing: {}
 *    - provider_name: provider-B
 *
 * [#next-free-field: 7]
 */
export interface JwtRequirement {
  $type: "envoy.extensions.filters.http.jwt_authn.v3.JwtRequirement";
  requires_type?:
    | //
    /** Specify a required provider name. */
    { $case: "provider_name"; provider_name: string }
    | //
    /** Specify a required provider with audiences. */
    { $case: "provider_and_audiences"; provider_and_audiences: ProviderWithAudiences }
    | //
    /**
     * Specify list of JwtRequirement. Their results are OR-ed.
     * If any one of them passes, the result is passed.
     */
    { $case: "requires_any"; requires_any: JwtRequirementOrList }
    | //
    /**
     * Specify list of JwtRequirement. Their results are AND-ed.
     * All of them must pass, if one of them fails or missing, it fails.
     */
    { $case: "requires_all"; requires_all: JwtRequirementAndList }
    | //
    /**
     * The requirement is always satisfied even if JWT is missing or the JWT
     * verification fails. A typical usage is: this filter is used to only verify
     * JWTs and pass the verified JWT payloads to another filter, the other filter
     * will make decision. In this mode, all JWTs will be verified.
     */
    { $case: "allow_missing_or_failed"; allow_missing_or_failed: Empty }
    | //
    /**
     * The requirement is satisfied if JWT is missing, but failed if JWT is
     * presented but invalid. Similar to allow_missing_or_failed, this is used
     * to only verify JWTs and pass the verified payload to another filter. The
     * different is this mode will reject requests with invalid tokens.
     */
    { $case: "allow_missing"; allow_missing: Empty }
    | undefined;
}

/**
 * This message specifies a list of RequiredProvider.
 * Their results are OR-ed; if any one of them passes, the result is passed
 */
export interface JwtRequirementOrList {
  $type: "envoy.extensions.filters.http.jwt_authn.v3.JwtRequirementOrList";
  /** Specify a list of JwtRequirement. */
  requirements?: JwtRequirement[] | undefined;
}

/**
 * This message specifies a list of RequiredProvider.
 * Their results are AND-ed; all of them must pass, if one of them fails or missing, it fails.
 */
export interface JwtRequirementAndList {
  $type: "envoy.extensions.filters.http.jwt_authn.v3.JwtRequirementAndList";
  /** Specify a list of JwtRequirement. */
  requirements?: JwtRequirement[] | undefined;
}

/**
 * This message specifies a Jwt requirement for a specific Route condition.
 * Example 1:
 *
 * .. code-block:: yaml
 *
 *    - match:
 *        prefix: /healthz
 *
 * In above example, "requires" field is empty for /healthz prefix match,
 * it means that requests matching the path prefix don't require JWT authentication.
 *
 * Example 2:
 *
 * .. code-block:: yaml
 *
 *    - match:
 *        prefix: /
 *      requires: { provider_name: provider-A }
 *
 * In above example, all requests matched the path prefix require jwt authentication
 * from "provider-A".
 */
export interface RequirementRule {
  $type: "envoy.extensions.filters.http.jwt_authn.v3.RequirementRule";
  /**
   * The route matching parameter. Only when the match is satisfied, the "requires" field will
   * apply.
   *
   * For example: following match will match all requests.
   *
   * .. code-block:: yaml
   *
   *    match:
   *      prefix: /
   */
  match?:
    | RouteMatch
    | undefined;
  /**
   * Specify a Jwt requirement.
   * If not specified, Jwt verification is disabled.
   */
  requirement_type?:
    | //
    /** Specify a Jwt requirement. Please see detail comment in message JwtRequirement. */
    { $case: "requires"; requires: JwtRequirement }
    | //
    /**
     * Use requirement_name to specify a Jwt requirement.
     * This requirement_name MUST be specified at the
     * :ref:`requirement_map <envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.JwtAuthentication.requirement_map>`
     * in ``JwtAuthentication``.
     */
    { $case: "requirement_name"; requirement_name: string }
    | undefined;
}

/**
 * This message specifies Jwt requirements based on stream_info.filterState.
 * This FilterState should use ``Router::StringAccessor`` object to set a string value.
 * Other HTTP filters can use it to specify Jwt requirements dynamically.
 *
 * Example:
 *
 * .. code-block:: yaml
 *
 *    name: jwt_selector
 *    requires:
 *      issuer_1:
 *        provider_name: issuer1
 *      issuer_2:
 *        provider_name: issuer2
 *
 * If a filter set "jwt_selector" with "issuer_1" to FilterState for a request,
 * jwt_authn filter will use JwtRequirement{"provider_name": "issuer1"} to verify.
 */
export interface FilterStateRule {
  $type: "envoy.extensions.filters.http.jwt_authn.v3.FilterStateRule";
  /** The filter state name to retrieve the ``Router::StringAccessor`` object. */
  name?:
    | string
    | undefined;
  /**
   * A map of string keys to requirements. The string key is the string value
   * in the FilterState with the name specified in the ``name`` field above.
   */
  requires?: Map<string, JwtRequirement> | undefined;
}

export interface FilterStateRule_RequiresEntry {
  $type: "envoy.extensions.filters.http.jwt_authn.v3.FilterStateRule.RequiresEntry";
  key: string;
  value?: JwtRequirement | undefined;
}

/**
 * This is the Envoy HTTP filter config for JWT authentication.
 *
 * For example:
 *
 * .. code-block:: yaml
 *
 *   providers:
 *      provider1:
 *        issuer: issuer1
 *        audiences:
 *        - audience1
 *        - audience2
 *        remote_jwks:
 *          http_uri:
 *            uri: https://example.com/.well-known/jwks.json
 *            cluster: example_jwks_cluster
 *            timeout: 1s
 *      provider2:
 *        issuer: issuer2
 *        local_jwks:
 *          inline_string: jwks_string
 *
 *   rules:
 *      # Not jwt verification is required for /health path
 *      - match:
 *          prefix: /health
 *
 *      # Jwt verification for provider1 is required for path prefixed with "prefix"
 *      - match:
 *          prefix: /prefix
 *        requires:
 *          provider_name: provider1
 *
 *      # Jwt verification for either provider1 or provider2 is required for all other requests.
 *      - match:
 *          prefix: /
 *        requires:
 *          requires_any:
 *            requirements:
 *              - provider_name: provider1
 *              - provider_name: provider2
 *
 * [#next-free-field: 8]
 */
export interface JwtAuthentication {
  $type: "envoy.extensions.filters.http.jwt_authn.v3.JwtAuthentication";
  /**
   * Map of provider names to JwtProviders.
   *
   * .. code-block:: yaml
   *
   *   providers:
   *     provider1:
   *        issuer: issuer1
   *        audiences:
   *        - audience1
   *        - audience2
   *        remote_jwks:
   *          http_uri:
   *            uri: https://example.com/.well-known/jwks.json
   *            cluster: example_jwks_cluster
   *            timeout: 1s
   *      provider2:
   *        issuer: provider2
   *        local_jwks:
   *          inline_string: jwks_string
   */
  providers?:
    | Map<string, JwtProvider>
    | undefined;
  /**
   * Specifies requirements based on the route matches. The first matched requirement will be
   * applied. If there are overlapped match conditions, please put the most specific match first.
   *
   * Examples
   *
   * .. code-block:: yaml
   *
   *   rules:
   *     - match:
   *         prefix: /healthz
   *     - match:
   *         prefix: /baz
   *       requires:
   *         provider_name: provider1
   *     - match:
   *         prefix: /foo
   *       requires:
   *         requires_any:
   *           requirements:
   *             - provider_name: provider1
   *             - provider_name: provider2
   *     - match:
   *         prefix: /bar
   *       requires:
   *         requires_all:
   *           requirements:
   *             - provider_name: provider1
   *             - provider_name: provider2
   */
  rules?:
    | RequirementRule[]
    | undefined;
  /**
   * This message specifies Jwt requirements based on stream_info.filterState.
   * Other HTTP filters can use it to specify Jwt requirements dynamically.
   * The ``rules`` field above is checked first, if it could not find any matches,
   * check this one.
   */
  filter_state_rules?:
    | FilterStateRule
    | undefined;
  /**
   * When set to true, bypass the `CORS preflight request
   * <http://www.w3.org/TR/cors/#cross-origin-request-with-preflight>`_ regardless of JWT
   * requirements specified in the rules.
   */
  bypass_cors_preflight?:
    | boolean
    | undefined;
  /**
   * A map of unique requirement_names to JwtRequirements.
   * :ref:`requirement_name <envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.PerRouteConfig.requirement_name>`
   * in ``PerRouteConfig`` uses this map to specify a JwtRequirement.
   */
  requirement_map?:
    | Map<string, JwtRequirement>
    | undefined;
  /**
   * A request failing the verification process will receive a 401 downstream with the failure response details
   * in the body along with WWWAuthenticate header value set with "invalid token". If this value is set to true,
   * the response details will be stripped and only a 401 response code will be returned. Default value is false
   */
  strip_failure_response?:
    | boolean
    | undefined;
  /** Optional additional prefix to use when emitting statistics. */
  stat_prefix?: string | undefined;
}

export interface JwtAuthentication_ProvidersEntry {
  $type: "envoy.extensions.filters.http.jwt_authn.v3.JwtAuthentication.ProvidersEntry";
  key: string;
  value?: JwtProvider | undefined;
}

export interface JwtAuthentication_RequirementMapEntry {
  $type: "envoy.extensions.filters.http.jwt_authn.v3.JwtAuthentication.RequirementMapEntry";
  key: string;
  value?: JwtRequirement | undefined;
}

/** Specify per-route config. */
export interface PerRouteConfig {
  $type: "envoy.extensions.filters.http.jwt_authn.v3.PerRouteConfig";
  requirement_specifier?:
    | //
    /** Disable Jwt Authentication for this route. */
    { $case: "disabled"; disabled: boolean }
    | //
    /**
     * Use requirement_name to specify a JwtRequirement.
     * This requirement_name MUST be specified at the
     * :ref:`requirement_map <envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.JwtAuthentication.requirement_map>`
     * in ``JwtAuthentication``. If no, the requests using this route will be rejected with 403.
     */
    { $case: "requirement_name"; requirement_name: string }
    | undefined;
}

/** This message specifies a combination of header name and claim name. */
export interface JwtClaimToHeader {
  $type: "envoy.extensions.filters.http.jwt_authn.v3.JwtClaimToHeader";
  /**
   * The HTTP header name to copy the claim to.
   * The header name will be sanitized and replaced.
   */
  header_name?:
    | string
    | undefined;
  /**
   * The field name for the JWT Claim : it can be a nested claim of type (eg. "claim.nested.key", "sub")
   * String separated with "." in case of nested claims. The nested claim name must use dot "." to separate
   * the JSON name path.
   */
  claim_name?: string | undefined;
}

function createBaseJwtProvider(): JwtProvider {
  return { $type: "envoy.extensions.filters.http.jwt_authn.v3.JwtProvider", jwks_source_specifier: undefined };
}

export const JwtProvider: MessageFns<JwtProvider, "envoy.extensions.filters.http.jwt_authn.v3.JwtProvider"> = {
  $type: "envoy.extensions.filters.http.jwt_authn.v3.JwtProvider" as const,

  encode(message: JwtProvider, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.issuer !== undefined && message.issuer !== "") {
      writer.uint32(10).string(message.issuer);
    }
    if (message.audiences !== undefined && message.audiences.length !== 0) {
      for (const v of message.audiences) {
        writer.uint32(18).string(v!);
      }
    }
    if (message.subjects !== undefined) {
      StringMatcher.encode(message.subjects, writer.uint32(154).fork()).join();
    }
    if (message.require_expiration !== undefined && message.require_expiration !== false) {
      writer.uint32(160).bool(message.require_expiration);
    }
    if (message.max_lifetime !== undefined) {
      Duration.encode(message.max_lifetime, writer.uint32(170).fork()).join();
    }
    switch (message.jwks_source_specifier?.$case) {
      case "remote_jwks":
        RemoteJwks.encode(message.jwks_source_specifier.remote_jwks, writer.uint32(26).fork()).join();
        break;
      case "local_jwks":
        DataSource.encode(message.jwks_source_specifier.local_jwks, writer.uint32(34).fork()).join();
        break;
    }
    if (message.forward !== undefined && message.forward !== false) {
      writer.uint32(40).bool(message.forward);
    }
    if (message.from_headers !== undefined && message.from_headers.length !== 0) {
      for (const v of message.from_headers) {
        JwtHeader.encode(v!, writer.uint32(50).fork()).join();
      }
    }
    if (message.from_params !== undefined && message.from_params.length !== 0) {
      for (const v of message.from_params) {
        writer.uint32(58).string(v!);
      }
    }
    if (message.from_cookies !== undefined && message.from_cookies.length !== 0) {
      for (const v of message.from_cookies) {
        writer.uint32(106).string(v!);
      }
    }
    if (message.forward_payload_header !== undefined && message.forward_payload_header !== "") {
      writer.uint32(66).string(message.forward_payload_header);
    }
    if (message.pad_forward_payload_header !== undefined && message.pad_forward_payload_header !== false) {
      writer.uint32(88).bool(message.pad_forward_payload_header);
    }
    if (message.payload_in_metadata !== undefined && message.payload_in_metadata !== "") {
      writer.uint32(74).string(message.payload_in_metadata);
    }
    if (message.normalize_payload_in_metadata !== undefined) {
      JwtProvider_NormalizePayload.encode(message.normalize_payload_in_metadata, writer.uint32(146).fork()).join();
    }
    if (message.header_in_metadata !== undefined && message.header_in_metadata !== "") {
      writer.uint32(114).string(message.header_in_metadata);
    }
    if (message.failed_status_in_metadata !== undefined && message.failed_status_in_metadata !== "") {
      writer.uint32(130).string(message.failed_status_in_metadata);
    }
    if (message.clock_skew_seconds !== undefined && message.clock_skew_seconds !== 0) {
      writer.uint32(80).uint32(message.clock_skew_seconds);
    }
    if (message.jwt_cache_config !== undefined) {
      JwtCacheConfig.encode(message.jwt_cache_config, writer.uint32(98).fork()).join();
    }
    if (message.claim_to_headers !== undefined && message.claim_to_headers.length !== 0) {
      for (const v of message.claim_to_headers) {
        JwtClaimToHeader.encode(v!, writer.uint32(122).fork()).join();
      }
    }
    if (message.clear_route_cache !== undefined && message.clear_route_cache !== false) {
      writer.uint32(136).bool(message.clear_route_cache);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JwtProvider {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJwtProvider();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.issuer = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.audiences === undefined) {
            message.audiences = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.audiences!.push(el);
          }
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.subjects = StringMatcher.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.require_expiration = reader.bool();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.max_lifetime = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.jwks_source_specifier = {
            $case: "remote_jwks",
            remote_jwks: RemoteJwks.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.jwks_source_specifier = {
            $case: "local_jwks",
            local_jwks: DataSource.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.forward = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          if (message.from_headers === undefined) {
            message.from_headers = [];
          }
          const el = JwtHeader.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.from_headers!.push(el);
          }
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          if (message.from_params === undefined) {
            message.from_params = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.from_params!.push(el);
          }
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          if (message.from_cookies === undefined) {
            message.from_cookies = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.from_cookies!.push(el);
          }
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.forward_payload_header = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.pad_forward_payload_header = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.payload_in_metadata = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.normalize_payload_in_metadata = JwtProvider_NormalizePayload.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.header_in_metadata = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.failed_status_in_metadata = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.clock_skew_seconds = reader.uint32();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.jwt_cache_config = JwtCacheConfig.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          if (message.claim_to_headers === undefined) {
            message.claim_to_headers = [];
          }
          const el = JwtClaimToHeader.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.claim_to_headers!.push(el);
          }
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.clear_route_cache = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JwtProvider {
    return {
      $type: JwtProvider.$type,
      issuer: isSet(object.issuer) ? globalThis.String(object.issuer) : undefined,
      audiences: globalThis.Array.isArray(object?.audiences)
        ? object.audiences.map((e: any) => globalThis.String(e))
        : undefined,
      subjects: isSet(object.subjects) ? StringMatcher.fromJSON(object.subjects) : undefined,
      require_expiration: isSet(object.require_expiration) ? globalThis.Boolean(object.require_expiration) : undefined,
      max_lifetime: isSet(object.max_lifetime) ? Duration.fromJSON(object.max_lifetime) : undefined,
      jwks_source_specifier: isSet(object.remote_jwks)
        ? { $case: "remote_jwks", remote_jwks: RemoteJwks.fromJSON(object.remote_jwks) }
        : isSet(object.local_jwks)
        ? { $case: "local_jwks", local_jwks: DataSource.fromJSON(object.local_jwks) }
        : undefined,
      forward: isSet(object.forward) ? globalThis.Boolean(object.forward) : undefined,
      from_headers: globalThis.Array.isArray(object?.from_headers)
        ? object.from_headers.map((e: any) => JwtHeader.fromJSON(e))
        : undefined,
      from_params: globalThis.Array.isArray(object?.from_params)
        ? object.from_params.map((e: any) => globalThis.String(e))
        : undefined,
      from_cookies: globalThis.Array.isArray(object?.from_cookies)
        ? object.from_cookies.map((e: any) => globalThis.String(e))
        : undefined,
      forward_payload_header: isSet(object.forward_payload_header)
        ? globalThis.String(object.forward_payload_header)
        : undefined,
      pad_forward_payload_header: isSet(object.pad_forward_payload_header)
        ? globalThis.Boolean(object.pad_forward_payload_header)
        : undefined,
      payload_in_metadata: isSet(object.payload_in_metadata)
        ? globalThis.String(object.payload_in_metadata)
        : undefined,
      normalize_payload_in_metadata: isSet(object.normalize_payload_in_metadata)
        ? JwtProvider_NormalizePayload.fromJSON(object.normalize_payload_in_metadata)
        : undefined,
      header_in_metadata: isSet(object.header_in_metadata) ? globalThis.String(object.header_in_metadata) : undefined,
      failed_status_in_metadata: isSet(object.failed_status_in_metadata)
        ? globalThis.String(object.failed_status_in_metadata)
        : undefined,
      clock_skew_seconds: isSet(object.clock_skew_seconds) ? globalThis.Number(object.clock_skew_seconds) : undefined,
      jwt_cache_config: isSet(object.jwt_cache_config) ? JwtCacheConfig.fromJSON(object.jwt_cache_config) : undefined,
      claim_to_headers: globalThis.Array.isArray(object?.claim_to_headers)
        ? object.claim_to_headers.map((e: any) => JwtClaimToHeader.fromJSON(e))
        : undefined,
      clear_route_cache: isSet(object.clear_route_cache) ? globalThis.Boolean(object.clear_route_cache) : undefined,
    };
  },

  toJSON(message: JwtProvider): unknown {
    const obj: any = {};
    if (message.issuer !== undefined) {
      obj.issuer = message.issuer;
    }
    if (message.audiences?.length) {
      obj.audiences = message.audiences;
    }
    if (message.subjects !== undefined) {
      obj.subjects = StringMatcher.toJSON(message.subjects);
    }
    if (message.require_expiration !== undefined) {
      obj.require_expiration = message.require_expiration;
    }
    if (message.max_lifetime !== undefined) {
      obj.max_lifetime = Duration.toJSON(message.max_lifetime);
    }
    if (message.jwks_source_specifier?.$case === "remote_jwks") {
      obj.remote_jwks = RemoteJwks.toJSON(message.jwks_source_specifier.remote_jwks);
    }
    if (message.jwks_source_specifier?.$case === "local_jwks") {
      obj.local_jwks = DataSource.toJSON(message.jwks_source_specifier.local_jwks);
    }
    if (message.forward !== undefined) {
      obj.forward = message.forward;
    }
    if (message.from_headers?.length) {
      obj.from_headers = message.from_headers.map((e) => JwtHeader.toJSON(e));
    }
    if (message.from_params?.length) {
      obj.from_params = message.from_params;
    }
    if (message.from_cookies?.length) {
      obj.from_cookies = message.from_cookies;
    }
    if (message.forward_payload_header !== undefined) {
      obj.forward_payload_header = message.forward_payload_header;
    }
    if (message.pad_forward_payload_header !== undefined) {
      obj.pad_forward_payload_header = message.pad_forward_payload_header;
    }
    if (message.payload_in_metadata !== undefined) {
      obj.payload_in_metadata = message.payload_in_metadata;
    }
    if (message.normalize_payload_in_metadata !== undefined) {
      obj.normalize_payload_in_metadata = JwtProvider_NormalizePayload.toJSON(message.normalize_payload_in_metadata);
    }
    if (message.header_in_metadata !== undefined) {
      obj.header_in_metadata = message.header_in_metadata;
    }
    if (message.failed_status_in_metadata !== undefined) {
      obj.failed_status_in_metadata = message.failed_status_in_metadata;
    }
    if (message.clock_skew_seconds !== undefined) {
      obj.clock_skew_seconds = Math.round(message.clock_skew_seconds);
    }
    if (message.jwt_cache_config !== undefined) {
      obj.jwt_cache_config = JwtCacheConfig.toJSON(message.jwt_cache_config);
    }
    if (message.claim_to_headers?.length) {
      obj.claim_to_headers = message.claim_to_headers.map((e) => JwtClaimToHeader.toJSON(e));
    }
    if (message.clear_route_cache !== undefined) {
      obj.clear_route_cache = message.clear_route_cache;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JwtProvider>, I>>(base?: I): JwtProvider {
    return JwtProvider.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JwtProvider>, I>>(object: I): JwtProvider {
    const message = createBaseJwtProvider();
    message.issuer = object.issuer ?? undefined;
    message.audiences = object.audiences?.map((e) => e) || undefined;
    message.subjects = (object.subjects !== undefined && object.subjects !== null)
      ? StringMatcher.fromPartial(object.subjects)
      : undefined;
    message.require_expiration = object.require_expiration ?? undefined;
    message.max_lifetime = (object.max_lifetime !== undefined && object.max_lifetime !== null)
      ? Duration.fromPartial(object.max_lifetime)
      : undefined;
    if (
      object.jwks_source_specifier?.$case === "remote_jwks" &&
      object.jwks_source_specifier?.remote_jwks !== undefined &&
      object.jwks_source_specifier?.remote_jwks !== null
    ) {
      message.jwks_source_specifier = {
        $case: "remote_jwks",
        remote_jwks: RemoteJwks.fromPartial(object.jwks_source_specifier.remote_jwks),
      };
    }
    if (
      object.jwks_source_specifier?.$case === "local_jwks" &&
      object.jwks_source_specifier?.local_jwks !== undefined &&
      object.jwks_source_specifier?.local_jwks !== null
    ) {
      message.jwks_source_specifier = {
        $case: "local_jwks",
        local_jwks: DataSource.fromPartial(object.jwks_source_specifier.local_jwks),
      };
    }
    message.forward = object.forward ?? undefined;
    message.from_headers = object.from_headers?.map((e) => JwtHeader.fromPartial(e)) || undefined;
    message.from_params = object.from_params?.map((e) => e) || undefined;
    message.from_cookies = object.from_cookies?.map((e) => e) || undefined;
    message.forward_payload_header = object.forward_payload_header ?? undefined;
    message.pad_forward_payload_header = object.pad_forward_payload_header ?? undefined;
    message.payload_in_metadata = object.payload_in_metadata ?? undefined;
    message.normalize_payload_in_metadata =
      (object.normalize_payload_in_metadata !== undefined && object.normalize_payload_in_metadata !== null)
        ? JwtProvider_NormalizePayload.fromPartial(object.normalize_payload_in_metadata)
        : undefined;
    message.header_in_metadata = object.header_in_metadata ?? undefined;
    message.failed_status_in_metadata = object.failed_status_in_metadata ?? undefined;
    message.clock_skew_seconds = object.clock_skew_seconds ?? undefined;
    message.jwt_cache_config = (object.jwt_cache_config !== undefined && object.jwt_cache_config !== null)
      ? JwtCacheConfig.fromPartial(object.jwt_cache_config)
      : undefined;
    message.claim_to_headers = object.claim_to_headers?.map((e) => JwtClaimToHeader.fromPartial(e)) || undefined;
    message.clear_route_cache = object.clear_route_cache ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(JwtProvider.$type, JwtProvider);

function createBaseJwtProvider_NormalizePayload(): JwtProvider_NormalizePayload {
  return { $type: "envoy.extensions.filters.http.jwt_authn.v3.JwtProvider.NormalizePayload" };
}

export const JwtProvider_NormalizePayload: MessageFns<
  JwtProvider_NormalizePayload,
  "envoy.extensions.filters.http.jwt_authn.v3.JwtProvider.NormalizePayload"
> = {
  $type: "envoy.extensions.filters.http.jwt_authn.v3.JwtProvider.NormalizePayload" as const,

  encode(message: JwtProvider_NormalizePayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.space_delimited_claims !== undefined && message.space_delimited_claims.length !== 0) {
      for (const v of message.space_delimited_claims) {
        writer.uint32(10).string(v!);
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JwtProvider_NormalizePayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJwtProvider_NormalizePayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.space_delimited_claims === undefined) {
            message.space_delimited_claims = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.space_delimited_claims!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JwtProvider_NormalizePayload {
    return {
      $type: JwtProvider_NormalizePayload.$type,
      space_delimited_claims: globalThis.Array.isArray(object?.space_delimited_claims)
        ? object.space_delimited_claims.map((e: any) => globalThis.String(e))
        : undefined,
    };
  },

  toJSON(message: JwtProvider_NormalizePayload): unknown {
    const obj: any = {};
    if (message.space_delimited_claims?.length) {
      obj.space_delimited_claims = message.space_delimited_claims;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JwtProvider_NormalizePayload>, I>>(base?: I): JwtProvider_NormalizePayload {
    return JwtProvider_NormalizePayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JwtProvider_NormalizePayload>, I>>(object: I): JwtProvider_NormalizePayload {
    const message = createBaseJwtProvider_NormalizePayload();
    message.space_delimited_claims = object.space_delimited_claims?.map((e) => e) || undefined;
    return message;
  },
};

messageTypeRegistry.set(JwtProvider_NormalizePayload.$type, JwtProvider_NormalizePayload);

function createBaseJwtCacheConfig(): JwtCacheConfig {
  return { $type: "envoy.extensions.filters.http.jwt_authn.v3.JwtCacheConfig" };
}

export const JwtCacheConfig: MessageFns<JwtCacheConfig, "envoy.extensions.filters.http.jwt_authn.v3.JwtCacheConfig"> = {
  $type: "envoy.extensions.filters.http.jwt_authn.v3.JwtCacheConfig" as const,

  encode(message: JwtCacheConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jwt_cache_size !== undefined && message.jwt_cache_size !== 0) {
      writer.uint32(8).uint32(message.jwt_cache_size);
    }
    if (message.jwt_max_token_size !== undefined && message.jwt_max_token_size !== 0) {
      writer.uint32(16).uint32(message.jwt_max_token_size);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JwtCacheConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJwtCacheConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.jwt_cache_size = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.jwt_max_token_size = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JwtCacheConfig {
    return {
      $type: JwtCacheConfig.$type,
      jwt_cache_size: isSet(object.jwt_cache_size) ? globalThis.Number(object.jwt_cache_size) : undefined,
      jwt_max_token_size: isSet(object.jwt_max_token_size) ? globalThis.Number(object.jwt_max_token_size) : undefined,
    };
  },

  toJSON(message: JwtCacheConfig): unknown {
    const obj: any = {};
    if (message.jwt_cache_size !== undefined) {
      obj.jwt_cache_size = Math.round(message.jwt_cache_size);
    }
    if (message.jwt_max_token_size !== undefined) {
      obj.jwt_max_token_size = Math.round(message.jwt_max_token_size);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JwtCacheConfig>, I>>(base?: I): JwtCacheConfig {
    return JwtCacheConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JwtCacheConfig>, I>>(object: I): JwtCacheConfig {
    const message = createBaseJwtCacheConfig();
    message.jwt_cache_size = object.jwt_cache_size ?? undefined;
    message.jwt_max_token_size = object.jwt_max_token_size ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(JwtCacheConfig.$type, JwtCacheConfig);

function createBaseRemoteJwks(): RemoteJwks {
  return { $type: "envoy.extensions.filters.http.jwt_authn.v3.RemoteJwks" };
}

export const RemoteJwks: MessageFns<RemoteJwks, "envoy.extensions.filters.http.jwt_authn.v3.RemoteJwks"> = {
  $type: "envoy.extensions.filters.http.jwt_authn.v3.RemoteJwks" as const,

  encode(message: RemoteJwks, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.http_uri !== undefined) {
      HttpUri.encode(message.http_uri, writer.uint32(10).fork()).join();
    }
    if (message.cache_duration !== undefined) {
      Duration.encode(message.cache_duration, writer.uint32(18).fork()).join();
    }
    if (message.async_fetch !== undefined) {
      JwksAsyncFetch.encode(message.async_fetch, writer.uint32(26).fork()).join();
    }
    if (message.retry_policy !== undefined) {
      RetryPolicy.encode(message.retry_policy, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoteJwks {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoteJwks();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.http_uri = HttpUri.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cache_duration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.async_fetch = JwksAsyncFetch.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.retry_policy = RetryPolicy.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoteJwks {
    return {
      $type: RemoteJwks.$type,
      http_uri: isSet(object.http_uri) ? HttpUri.fromJSON(object.http_uri) : undefined,
      cache_duration: isSet(object.cache_duration) ? Duration.fromJSON(object.cache_duration) : undefined,
      async_fetch: isSet(object.async_fetch) ? JwksAsyncFetch.fromJSON(object.async_fetch) : undefined,
      retry_policy: isSet(object.retry_policy) ? RetryPolicy.fromJSON(object.retry_policy) : undefined,
    };
  },

  toJSON(message: RemoteJwks): unknown {
    const obj: any = {};
    if (message.http_uri !== undefined) {
      obj.http_uri = HttpUri.toJSON(message.http_uri);
    }
    if (message.cache_duration !== undefined) {
      obj.cache_duration = Duration.toJSON(message.cache_duration);
    }
    if (message.async_fetch !== undefined) {
      obj.async_fetch = JwksAsyncFetch.toJSON(message.async_fetch);
    }
    if (message.retry_policy !== undefined) {
      obj.retry_policy = RetryPolicy.toJSON(message.retry_policy);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoteJwks>, I>>(base?: I): RemoteJwks {
    return RemoteJwks.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoteJwks>, I>>(object: I): RemoteJwks {
    const message = createBaseRemoteJwks();
    message.http_uri = (object.http_uri !== undefined && object.http_uri !== null)
      ? HttpUri.fromPartial(object.http_uri)
      : undefined;
    message.cache_duration = (object.cache_duration !== undefined && object.cache_duration !== null)
      ? Duration.fromPartial(object.cache_duration)
      : undefined;
    message.async_fetch = (object.async_fetch !== undefined && object.async_fetch !== null)
      ? JwksAsyncFetch.fromPartial(object.async_fetch)
      : undefined;
    message.retry_policy = (object.retry_policy !== undefined && object.retry_policy !== null)
      ? RetryPolicy.fromPartial(object.retry_policy)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(RemoteJwks.$type, RemoteJwks);

function createBaseJwksAsyncFetch(): JwksAsyncFetch {
  return { $type: "envoy.extensions.filters.http.jwt_authn.v3.JwksAsyncFetch" };
}

export const JwksAsyncFetch: MessageFns<JwksAsyncFetch, "envoy.extensions.filters.http.jwt_authn.v3.JwksAsyncFetch"> = {
  $type: "envoy.extensions.filters.http.jwt_authn.v3.JwksAsyncFetch" as const,

  encode(message: JwksAsyncFetch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fast_listener !== undefined && message.fast_listener !== false) {
      writer.uint32(8).bool(message.fast_listener);
    }
    if (message.failed_refetch_duration !== undefined) {
      Duration.encode(message.failed_refetch_duration, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JwksAsyncFetch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJwksAsyncFetch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fast_listener = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.failed_refetch_duration = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JwksAsyncFetch {
    return {
      $type: JwksAsyncFetch.$type,
      fast_listener: isSet(object.fast_listener) ? globalThis.Boolean(object.fast_listener) : undefined,
      failed_refetch_duration: isSet(object.failed_refetch_duration)
        ? Duration.fromJSON(object.failed_refetch_duration)
        : undefined,
    };
  },

  toJSON(message: JwksAsyncFetch): unknown {
    const obj: any = {};
    if (message.fast_listener !== undefined) {
      obj.fast_listener = message.fast_listener;
    }
    if (message.failed_refetch_duration !== undefined) {
      obj.failed_refetch_duration = Duration.toJSON(message.failed_refetch_duration);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JwksAsyncFetch>, I>>(base?: I): JwksAsyncFetch {
    return JwksAsyncFetch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JwksAsyncFetch>, I>>(object: I): JwksAsyncFetch {
    const message = createBaseJwksAsyncFetch();
    message.fast_listener = object.fast_listener ?? undefined;
    message.failed_refetch_duration =
      (object.failed_refetch_duration !== undefined && object.failed_refetch_duration !== null)
        ? Duration.fromPartial(object.failed_refetch_duration)
        : undefined;
    return message;
  },
};

messageTypeRegistry.set(JwksAsyncFetch.$type, JwksAsyncFetch);

function createBaseJwtHeader(): JwtHeader {
  return { $type: "envoy.extensions.filters.http.jwt_authn.v3.JwtHeader" };
}

export const JwtHeader: MessageFns<JwtHeader, "envoy.extensions.filters.http.jwt_authn.v3.JwtHeader"> = {
  $type: "envoy.extensions.filters.http.jwt_authn.v3.JwtHeader" as const,

  encode(message: JwtHeader, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value_prefix !== undefined && message.value_prefix !== "") {
      writer.uint32(18).string(message.value_prefix);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JwtHeader {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJwtHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value_prefix = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JwtHeader {
    return {
      $type: JwtHeader.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      value_prefix: isSet(object.value_prefix) ? globalThis.String(object.value_prefix) : undefined,
    };
  },

  toJSON(message: JwtHeader): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.value_prefix !== undefined) {
      obj.value_prefix = message.value_prefix;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JwtHeader>, I>>(base?: I): JwtHeader {
    return JwtHeader.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JwtHeader>, I>>(object: I): JwtHeader {
    const message = createBaseJwtHeader();
    message.name = object.name ?? undefined;
    message.value_prefix = object.value_prefix ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(JwtHeader.$type, JwtHeader);

function createBaseProviderWithAudiences(): ProviderWithAudiences {
  return { $type: "envoy.extensions.filters.http.jwt_authn.v3.ProviderWithAudiences" };
}

export const ProviderWithAudiences: MessageFns<
  ProviderWithAudiences,
  "envoy.extensions.filters.http.jwt_authn.v3.ProviderWithAudiences"
> = {
  $type: "envoy.extensions.filters.http.jwt_authn.v3.ProviderWithAudiences" as const,

  encode(message: ProviderWithAudiences, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provider_name !== undefined && message.provider_name !== "") {
      writer.uint32(10).string(message.provider_name);
    }
    if (message.audiences !== undefined && message.audiences.length !== 0) {
      for (const v of message.audiences) {
        writer.uint32(18).string(v!);
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProviderWithAudiences {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProviderWithAudiences();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.provider_name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.audiences === undefined) {
            message.audiences = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.audiences!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProviderWithAudiences {
    return {
      $type: ProviderWithAudiences.$type,
      provider_name: isSet(object.provider_name) ? globalThis.String(object.provider_name) : undefined,
      audiences: globalThis.Array.isArray(object?.audiences)
        ? object.audiences.map((e: any) => globalThis.String(e))
        : undefined,
    };
  },

  toJSON(message: ProviderWithAudiences): unknown {
    const obj: any = {};
    if (message.provider_name !== undefined) {
      obj.provider_name = message.provider_name;
    }
    if (message.audiences?.length) {
      obj.audiences = message.audiences;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProviderWithAudiences>, I>>(base?: I): ProviderWithAudiences {
    return ProviderWithAudiences.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProviderWithAudiences>, I>>(object: I): ProviderWithAudiences {
    const message = createBaseProviderWithAudiences();
    message.provider_name = object.provider_name ?? undefined;
    message.audiences = object.audiences?.map((e) => e) || undefined;
    return message;
  },
};

messageTypeRegistry.set(ProviderWithAudiences.$type, ProviderWithAudiences);

function createBaseJwtRequirement(): JwtRequirement {
  return { $type: "envoy.extensions.filters.http.jwt_authn.v3.JwtRequirement", requires_type: undefined };
}

export const JwtRequirement: MessageFns<JwtRequirement, "envoy.extensions.filters.http.jwt_authn.v3.JwtRequirement"> = {
  $type: "envoy.extensions.filters.http.jwt_authn.v3.JwtRequirement" as const,

  encode(message: JwtRequirement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.requires_type?.$case) {
      case "provider_name":
        writer.uint32(10).string(message.requires_type.provider_name);
        break;
      case "provider_and_audiences":
        ProviderWithAudiences.encode(message.requires_type.provider_and_audiences, writer.uint32(18).fork()).join();
        break;
      case "requires_any":
        JwtRequirementOrList.encode(message.requires_type.requires_any, writer.uint32(26).fork()).join();
        break;
      case "requires_all":
        JwtRequirementAndList.encode(message.requires_type.requires_all, writer.uint32(34).fork()).join();
        break;
      case "allow_missing_or_failed":
        Empty.encode(message.requires_type.allow_missing_or_failed, writer.uint32(42).fork()).join();
        break;
      case "allow_missing":
        Empty.encode(message.requires_type.allow_missing, writer.uint32(50).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JwtRequirement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJwtRequirement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requires_type = { $case: "provider_name", provider_name: reader.string() };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.requires_type = {
            $case: "provider_and_audiences",
            provider_and_audiences: ProviderWithAudiences.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.requires_type = {
            $case: "requires_any",
            requires_any: JwtRequirementOrList.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.requires_type = {
            $case: "requires_all",
            requires_all: JwtRequirementAndList.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.requires_type = {
            $case: "allow_missing_or_failed",
            allow_missing_or_failed: Empty.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.requires_type = { $case: "allow_missing", allow_missing: Empty.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JwtRequirement {
    return {
      $type: JwtRequirement.$type,
      requires_type: isSet(object.provider_name)
        ? { $case: "provider_name", provider_name: globalThis.String(object.provider_name) }
        : isSet(object.provider_and_audiences)
        ? {
          $case: "provider_and_audiences",
          provider_and_audiences: ProviderWithAudiences.fromJSON(object.provider_and_audiences),
        }
        : isSet(object.requires_any)
        ? { $case: "requires_any", requires_any: JwtRequirementOrList.fromJSON(object.requires_any) }
        : isSet(object.requires_all)
        ? { $case: "requires_all", requires_all: JwtRequirementAndList.fromJSON(object.requires_all) }
        : isSet(object.allow_missing_or_failed)
        ? { $case: "allow_missing_or_failed", allow_missing_or_failed: Empty.fromJSON(object.allow_missing_or_failed) }
        : isSet(object.allow_missing)
        ? { $case: "allow_missing", allow_missing: Empty.fromJSON(object.allow_missing) }
        : undefined,
    };
  },

  toJSON(message: JwtRequirement): unknown {
    const obj: any = {};
    if (message.requires_type?.$case === "provider_name") {
      obj.provider_name = message.requires_type.provider_name;
    }
    if (message.requires_type?.$case === "provider_and_audiences") {
      obj.provider_and_audiences = ProviderWithAudiences.toJSON(message.requires_type.provider_and_audiences);
    }
    if (message.requires_type?.$case === "requires_any") {
      obj.requires_any = JwtRequirementOrList.toJSON(message.requires_type.requires_any);
    }
    if (message.requires_type?.$case === "requires_all") {
      obj.requires_all = JwtRequirementAndList.toJSON(message.requires_type.requires_all);
    }
    if (message.requires_type?.$case === "allow_missing_or_failed") {
      obj.allow_missing_or_failed = Empty.toJSON(message.requires_type.allow_missing_or_failed);
    }
    if (message.requires_type?.$case === "allow_missing") {
      obj.allow_missing = Empty.toJSON(message.requires_type.allow_missing);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JwtRequirement>, I>>(base?: I): JwtRequirement {
    return JwtRequirement.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JwtRequirement>, I>>(object: I): JwtRequirement {
    const message = createBaseJwtRequirement();
    if (
      object.requires_type?.$case === "provider_name" &&
      object.requires_type?.provider_name !== undefined &&
      object.requires_type?.provider_name !== null
    ) {
      message.requires_type = { $case: "provider_name", provider_name: object.requires_type.provider_name };
    }
    if (
      object.requires_type?.$case === "provider_and_audiences" &&
      object.requires_type?.provider_and_audiences !== undefined &&
      object.requires_type?.provider_and_audiences !== null
    ) {
      message.requires_type = {
        $case: "provider_and_audiences",
        provider_and_audiences: ProviderWithAudiences.fromPartial(object.requires_type.provider_and_audiences),
      };
    }
    if (
      object.requires_type?.$case === "requires_any" &&
      object.requires_type?.requires_any !== undefined &&
      object.requires_type?.requires_any !== null
    ) {
      message.requires_type = {
        $case: "requires_any",
        requires_any: JwtRequirementOrList.fromPartial(object.requires_type.requires_any),
      };
    }
    if (
      object.requires_type?.$case === "requires_all" &&
      object.requires_type?.requires_all !== undefined &&
      object.requires_type?.requires_all !== null
    ) {
      message.requires_type = {
        $case: "requires_all",
        requires_all: JwtRequirementAndList.fromPartial(object.requires_type.requires_all),
      };
    }
    if (
      object.requires_type?.$case === "allow_missing_or_failed" &&
      object.requires_type?.allow_missing_or_failed !== undefined &&
      object.requires_type?.allow_missing_or_failed !== null
    ) {
      message.requires_type = {
        $case: "allow_missing_or_failed",
        allow_missing_or_failed: Empty.fromPartial(object.requires_type.allow_missing_or_failed),
      };
    }
    if (
      object.requires_type?.$case === "allow_missing" &&
      object.requires_type?.allow_missing !== undefined &&
      object.requires_type?.allow_missing !== null
    ) {
      message.requires_type = {
        $case: "allow_missing",
        allow_missing: Empty.fromPartial(object.requires_type.allow_missing),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(JwtRequirement.$type, JwtRequirement);

function createBaseJwtRequirementOrList(): JwtRequirementOrList {
  return { $type: "envoy.extensions.filters.http.jwt_authn.v3.JwtRequirementOrList" };
}

export const JwtRequirementOrList: MessageFns<
  JwtRequirementOrList,
  "envoy.extensions.filters.http.jwt_authn.v3.JwtRequirementOrList"
> = {
  $type: "envoy.extensions.filters.http.jwt_authn.v3.JwtRequirementOrList" as const,

  encode(message: JwtRequirementOrList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requirements !== undefined && message.requirements.length !== 0) {
      for (const v of message.requirements) {
        JwtRequirement.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JwtRequirementOrList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJwtRequirementOrList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.requirements === undefined) {
            message.requirements = [];
          }
          const el = JwtRequirement.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.requirements!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JwtRequirementOrList {
    return {
      $type: JwtRequirementOrList.$type,
      requirements: globalThis.Array.isArray(object?.requirements)
        ? object.requirements.map((e: any) => JwtRequirement.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: JwtRequirementOrList): unknown {
    const obj: any = {};
    if (message.requirements?.length) {
      obj.requirements = message.requirements.map((e) => JwtRequirement.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JwtRequirementOrList>, I>>(base?: I): JwtRequirementOrList {
    return JwtRequirementOrList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JwtRequirementOrList>, I>>(object: I): JwtRequirementOrList {
    const message = createBaseJwtRequirementOrList();
    message.requirements = object.requirements?.map((e) => JwtRequirement.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(JwtRequirementOrList.$type, JwtRequirementOrList);

function createBaseJwtRequirementAndList(): JwtRequirementAndList {
  return { $type: "envoy.extensions.filters.http.jwt_authn.v3.JwtRequirementAndList" };
}

export const JwtRequirementAndList: MessageFns<
  JwtRequirementAndList,
  "envoy.extensions.filters.http.jwt_authn.v3.JwtRequirementAndList"
> = {
  $type: "envoy.extensions.filters.http.jwt_authn.v3.JwtRequirementAndList" as const,

  encode(message: JwtRequirementAndList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requirements !== undefined && message.requirements.length !== 0) {
      for (const v of message.requirements) {
        JwtRequirement.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JwtRequirementAndList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJwtRequirementAndList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.requirements === undefined) {
            message.requirements = [];
          }
          const el = JwtRequirement.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.requirements!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JwtRequirementAndList {
    return {
      $type: JwtRequirementAndList.$type,
      requirements: globalThis.Array.isArray(object?.requirements)
        ? object.requirements.map((e: any) => JwtRequirement.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: JwtRequirementAndList): unknown {
    const obj: any = {};
    if (message.requirements?.length) {
      obj.requirements = message.requirements.map((e) => JwtRequirement.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JwtRequirementAndList>, I>>(base?: I): JwtRequirementAndList {
    return JwtRequirementAndList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JwtRequirementAndList>, I>>(object: I): JwtRequirementAndList {
    const message = createBaseJwtRequirementAndList();
    message.requirements = object.requirements?.map((e) => JwtRequirement.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(JwtRequirementAndList.$type, JwtRequirementAndList);

function createBaseRequirementRule(): RequirementRule {
  return { $type: "envoy.extensions.filters.http.jwt_authn.v3.RequirementRule", requirement_type: undefined };
}

export const RequirementRule: MessageFns<
  RequirementRule,
  "envoy.extensions.filters.http.jwt_authn.v3.RequirementRule"
> = {
  $type: "envoy.extensions.filters.http.jwt_authn.v3.RequirementRule" as const,

  encode(message: RequirementRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.match !== undefined) {
      RouteMatch.encode(message.match, writer.uint32(10).fork()).join();
    }
    switch (message.requirement_type?.$case) {
      case "requires":
        JwtRequirement.encode(message.requirement_type.requires, writer.uint32(18).fork()).join();
        break;
      case "requirement_name":
        writer.uint32(26).string(message.requirement_type.requirement_name);
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequirementRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequirementRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.match = RouteMatch.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.requirement_type = { $case: "requires", requires: JwtRequirement.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.requirement_type = { $case: "requirement_name", requirement_name: reader.string() };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequirementRule {
    return {
      $type: RequirementRule.$type,
      match: isSet(object.match) ? RouteMatch.fromJSON(object.match) : undefined,
      requirement_type: isSet(object.requires)
        ? { $case: "requires", requires: JwtRequirement.fromJSON(object.requires) }
        : isSet(object.requirement_name)
        ? { $case: "requirement_name", requirement_name: globalThis.String(object.requirement_name) }
        : undefined,
    };
  },

  toJSON(message: RequirementRule): unknown {
    const obj: any = {};
    if (message.match !== undefined) {
      obj.match = RouteMatch.toJSON(message.match);
    }
    if (message.requirement_type?.$case === "requires") {
      obj.requires = JwtRequirement.toJSON(message.requirement_type.requires);
    }
    if (message.requirement_type?.$case === "requirement_name") {
      obj.requirement_name = message.requirement_type.requirement_name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequirementRule>, I>>(base?: I): RequirementRule {
    return RequirementRule.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequirementRule>, I>>(object: I): RequirementRule {
    const message = createBaseRequirementRule();
    message.match = (object.match !== undefined && object.match !== null)
      ? RouteMatch.fromPartial(object.match)
      : undefined;
    if (
      object.requirement_type?.$case === "requires" &&
      object.requirement_type?.requires !== undefined &&
      object.requirement_type?.requires !== null
    ) {
      message.requirement_type = {
        $case: "requires",
        requires: JwtRequirement.fromPartial(object.requirement_type.requires),
      };
    }
    if (
      object.requirement_type?.$case === "requirement_name" &&
      object.requirement_type?.requirement_name !== undefined &&
      object.requirement_type?.requirement_name !== null
    ) {
      message.requirement_type = {
        $case: "requirement_name",
        requirement_name: object.requirement_type.requirement_name,
      };
    }
    return message;
  },
};

messageTypeRegistry.set(RequirementRule.$type, RequirementRule);

function createBaseFilterStateRule(): FilterStateRule {
  return { $type: "envoy.extensions.filters.http.jwt_authn.v3.FilterStateRule" };
}

export const FilterStateRule: MessageFns<
  FilterStateRule,
  "envoy.extensions.filters.http.jwt_authn.v3.FilterStateRule"
> = {
  $type: "envoy.extensions.filters.http.jwt_authn.v3.FilterStateRule" as const,

  encode(message: FilterStateRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    (message.requires || new Map()).forEach((value, key) => {
      FilterStateRule_RequiresEntry.encode({
        $type: "envoy.extensions.filters.http.jwt_authn.v3.FilterStateRule.RequiresEntry",
        key: key as any,
        value,
      }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FilterStateRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilterStateRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = FilterStateRule_RequiresEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            if (message.requires === undefined) {
              message.requires = new Map();
            }
            message.requires!.set(entry3.key, entry3.value);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FilterStateRule {
    return {
      $type: FilterStateRule.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      requires: isObject(object.requires)
        ? Object.entries(object.requires).reduce<Map<string, JwtRequirement>>((acc, [key, value]) => {
          acc.set(key, JwtRequirement.fromJSON(value));
          return acc;
        }, new Map())
        : undefined,
    };
  },

  toJSON(message: FilterStateRule): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.requires?.size) {
      obj.requires = {};
      message.requires.forEach((v, k) => {
        obj.requires[k] = JwtRequirement.toJSON(v);
      });
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FilterStateRule>, I>>(base?: I): FilterStateRule {
    return FilterStateRule.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FilterStateRule>, I>>(object: I): FilterStateRule {
    const message = createBaseFilterStateRule();
    message.name = object.name ?? undefined;
    message.requires = (object.requires === undefined || object.requires === null) ? undefined : (() => {
      const m = new Map();
      (object.requires as Map<string, JwtRequirement> ?? new Map()).forEach((value, key) => {
        if (value !== undefined) {
          m.set(key, JwtRequirement.fromPartial(value));
        }
      });
      return m;
    })();
    return message;
  },
};

messageTypeRegistry.set(FilterStateRule.$type, FilterStateRule);

function createBaseFilterStateRule_RequiresEntry(): FilterStateRule_RequiresEntry {
  return { $type: "envoy.extensions.filters.http.jwt_authn.v3.FilterStateRule.RequiresEntry", key: "" };
}

export const FilterStateRule_RequiresEntry: MessageFns<
  FilterStateRule_RequiresEntry,
  "envoy.extensions.filters.http.jwt_authn.v3.FilterStateRule.RequiresEntry"
> = {
  $type: "envoy.extensions.filters.http.jwt_authn.v3.FilterStateRule.RequiresEntry" as const,

  encode(message: FilterStateRule_RequiresEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      JwtRequirement.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FilterStateRule_RequiresEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilterStateRule_RequiresEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = JwtRequirement.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FilterStateRule_RequiresEntry {
    return {
      $type: FilterStateRule_RequiresEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? JwtRequirement.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: FilterStateRule_RequiresEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = JwtRequirement.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FilterStateRule_RequiresEntry>, I>>(base?: I): FilterStateRule_RequiresEntry {
    return FilterStateRule_RequiresEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FilterStateRule_RequiresEntry>, I>>(
    object: I,
  ): FilterStateRule_RequiresEntry {
    const message = createBaseFilterStateRule_RequiresEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? JwtRequirement.fromPartial(object.value)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(FilterStateRule_RequiresEntry.$type, FilterStateRule_RequiresEntry);

function createBaseJwtAuthentication(): JwtAuthentication {
  return { $type: "envoy.extensions.filters.http.jwt_authn.v3.JwtAuthentication" };
}

export const JwtAuthentication: MessageFns<
  JwtAuthentication,
  "envoy.extensions.filters.http.jwt_authn.v3.JwtAuthentication"
> = {
  $type: "envoy.extensions.filters.http.jwt_authn.v3.JwtAuthentication" as const,

  encode(message: JwtAuthentication, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    (message.providers || new Map()).forEach((value, key) => {
      JwtAuthentication_ProvidersEntry.encode({
        $type: "envoy.extensions.filters.http.jwt_authn.v3.JwtAuthentication.ProvidersEntry",
        key: key as any,
        value,
      }, writer.uint32(10).fork()).join();
    });
    if (message.rules !== undefined && message.rules.length !== 0) {
      for (const v of message.rules) {
        RequirementRule.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.filter_state_rules !== undefined) {
      FilterStateRule.encode(message.filter_state_rules, writer.uint32(26).fork()).join();
    }
    if (message.bypass_cors_preflight !== undefined && message.bypass_cors_preflight !== false) {
      writer.uint32(32).bool(message.bypass_cors_preflight);
    }
    (message.requirement_map || new Map()).forEach((value, key) => {
      JwtAuthentication_RequirementMapEntry.encode({
        $type: "envoy.extensions.filters.http.jwt_authn.v3.JwtAuthentication.RequirementMapEntry",
        key: key as any,
        value,
      }, writer.uint32(42).fork()).join();
    });
    if (message.strip_failure_response !== undefined && message.strip_failure_response !== false) {
      writer.uint32(48).bool(message.strip_failure_response);
    }
    if (message.stat_prefix !== undefined && message.stat_prefix !== "") {
      writer.uint32(58).string(message.stat_prefix);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JwtAuthentication {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJwtAuthentication();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = JwtAuthentication_ProvidersEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            if (message.providers === undefined) {
              message.providers = new Map();
            }
            message.providers!.set(entry1.key, entry1.value);
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.rules === undefined) {
            message.rules = [];
          }
          const el = RequirementRule.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.rules!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.filter_state_rules = FilterStateRule.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.bypass_cors_preflight = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = JwtAuthentication_RequirementMapEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            if (message.requirement_map === undefined) {
              message.requirement_map = new Map();
            }
            message.requirement_map!.set(entry5.key, entry5.value);
          }
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.strip_failure_response = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.stat_prefix = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JwtAuthentication {
    return {
      $type: JwtAuthentication.$type,
      providers: isObject(object.providers)
        ? Object.entries(object.providers).reduce<Map<string, JwtProvider>>((acc, [key, value]) => {
          acc.set(key, JwtProvider.fromJSON(value));
          return acc;
        }, new Map())
        : undefined,
      rules: globalThis.Array.isArray(object?.rules)
        ? object.rules.map((e: any) => RequirementRule.fromJSON(e))
        : undefined,
      filter_state_rules: isSet(object.filter_state_rules)
        ? FilterStateRule.fromJSON(object.filter_state_rules)
        : undefined,
      bypass_cors_preflight: isSet(object.bypass_cors_preflight)
        ? globalThis.Boolean(object.bypass_cors_preflight)
        : undefined,
      requirement_map: isObject(object.requirement_map)
        ? Object.entries(object.requirement_map).reduce<Map<string, JwtRequirement>>((acc, [key, value]) => {
          acc.set(key, JwtRequirement.fromJSON(value));
          return acc;
        }, new Map())
        : undefined,
      strip_failure_response: isSet(object.strip_failure_response)
        ? globalThis.Boolean(object.strip_failure_response)
        : undefined,
      stat_prefix: isSet(object.stat_prefix) ? globalThis.String(object.stat_prefix) : undefined,
    };
  },

  toJSON(message: JwtAuthentication): unknown {
    const obj: any = {};
    if (message.providers?.size) {
      obj.providers = {};
      message.providers.forEach((v, k) => {
        obj.providers[k] = JwtProvider.toJSON(v);
      });
    }
    if (message.rules?.length) {
      obj.rules = message.rules.map((e) => RequirementRule.toJSON(e));
    }
    if (message.filter_state_rules !== undefined) {
      obj.filter_state_rules = FilterStateRule.toJSON(message.filter_state_rules);
    }
    if (message.bypass_cors_preflight !== undefined) {
      obj.bypass_cors_preflight = message.bypass_cors_preflight;
    }
    if (message.requirement_map?.size) {
      obj.requirement_map = {};
      message.requirement_map.forEach((v, k) => {
        obj.requirement_map[k] = JwtRequirement.toJSON(v);
      });
    }
    if (message.strip_failure_response !== undefined) {
      obj.strip_failure_response = message.strip_failure_response;
    }
    if (message.stat_prefix !== undefined) {
      obj.stat_prefix = message.stat_prefix;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JwtAuthentication>, I>>(base?: I): JwtAuthentication {
    return JwtAuthentication.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JwtAuthentication>, I>>(object: I): JwtAuthentication {
    const message = createBaseJwtAuthentication();
    message.providers = (object.providers === undefined || object.providers === null) ? undefined : (() => {
      const m = new Map();
      (object.providers as Map<string, JwtProvider> ?? new Map()).forEach((value, key) => {
        if (value !== undefined) {
          m.set(key, JwtProvider.fromPartial(value));
        }
      });
      return m;
    })();
    message.rules = object.rules?.map((e) => RequirementRule.fromPartial(e)) || undefined;
    message.filter_state_rules = (object.filter_state_rules !== undefined && object.filter_state_rules !== null)
      ? FilterStateRule.fromPartial(object.filter_state_rules)
      : undefined;
    message.bypass_cors_preflight = object.bypass_cors_preflight ?? undefined;
    message.requirement_map = (object.requirement_map === undefined || object.requirement_map === null)
      ? undefined
      : (() => {
        const m = new Map();
        (object.requirement_map as Map<string, JwtRequirement> ?? new Map()).forEach((value, key) => {
          if (value !== undefined) {
            m.set(key, JwtRequirement.fromPartial(value));
          }
        });
        return m;
      })();
    message.strip_failure_response = object.strip_failure_response ?? undefined;
    message.stat_prefix = object.stat_prefix ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(JwtAuthentication.$type, JwtAuthentication);

function createBaseJwtAuthentication_ProvidersEntry(): JwtAuthentication_ProvidersEntry {
  return { $type: "envoy.extensions.filters.http.jwt_authn.v3.JwtAuthentication.ProvidersEntry", key: "" };
}

export const JwtAuthentication_ProvidersEntry: MessageFns<
  JwtAuthentication_ProvidersEntry,
  "envoy.extensions.filters.http.jwt_authn.v3.JwtAuthentication.ProvidersEntry"
> = {
  $type: "envoy.extensions.filters.http.jwt_authn.v3.JwtAuthentication.ProvidersEntry" as const,

  encode(message: JwtAuthentication_ProvidersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      JwtProvider.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JwtAuthentication_ProvidersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJwtAuthentication_ProvidersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = JwtProvider.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JwtAuthentication_ProvidersEntry {
    return {
      $type: JwtAuthentication_ProvidersEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? JwtProvider.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: JwtAuthentication_ProvidersEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = JwtProvider.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JwtAuthentication_ProvidersEntry>, I>>(
    base?: I,
  ): JwtAuthentication_ProvidersEntry {
    return JwtAuthentication_ProvidersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JwtAuthentication_ProvidersEntry>, I>>(
    object: I,
  ): JwtAuthentication_ProvidersEntry {
    const message = createBaseJwtAuthentication_ProvidersEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? JwtProvider.fromPartial(object.value)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(JwtAuthentication_ProvidersEntry.$type, JwtAuthentication_ProvidersEntry);

function createBaseJwtAuthentication_RequirementMapEntry(): JwtAuthentication_RequirementMapEntry {
  return { $type: "envoy.extensions.filters.http.jwt_authn.v3.JwtAuthentication.RequirementMapEntry", key: "" };
}

export const JwtAuthentication_RequirementMapEntry: MessageFns<
  JwtAuthentication_RequirementMapEntry,
  "envoy.extensions.filters.http.jwt_authn.v3.JwtAuthentication.RequirementMapEntry"
> = {
  $type: "envoy.extensions.filters.http.jwt_authn.v3.JwtAuthentication.RequirementMapEntry" as const,

  encode(message: JwtAuthentication_RequirementMapEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      JwtRequirement.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JwtAuthentication_RequirementMapEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJwtAuthentication_RequirementMapEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = JwtRequirement.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JwtAuthentication_RequirementMapEntry {
    return {
      $type: JwtAuthentication_RequirementMapEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? JwtRequirement.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: JwtAuthentication_RequirementMapEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = JwtRequirement.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JwtAuthentication_RequirementMapEntry>, I>>(
    base?: I,
  ): JwtAuthentication_RequirementMapEntry {
    return JwtAuthentication_RequirementMapEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JwtAuthentication_RequirementMapEntry>, I>>(
    object: I,
  ): JwtAuthentication_RequirementMapEntry {
    const message = createBaseJwtAuthentication_RequirementMapEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? JwtRequirement.fromPartial(object.value)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(JwtAuthentication_RequirementMapEntry.$type, JwtAuthentication_RequirementMapEntry);

function createBasePerRouteConfig(): PerRouteConfig {
  return { $type: "envoy.extensions.filters.http.jwt_authn.v3.PerRouteConfig", requirement_specifier: undefined };
}

export const PerRouteConfig: MessageFns<PerRouteConfig, "envoy.extensions.filters.http.jwt_authn.v3.PerRouteConfig"> = {
  $type: "envoy.extensions.filters.http.jwt_authn.v3.PerRouteConfig" as const,

  encode(message: PerRouteConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.requirement_specifier?.$case) {
      case "disabled":
        writer.uint32(8).bool(message.requirement_specifier.disabled);
        break;
      case "requirement_name":
        writer.uint32(18).string(message.requirement_specifier.requirement_name);
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PerRouteConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePerRouteConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.requirement_specifier = { $case: "disabled", disabled: reader.bool() };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.requirement_specifier = { $case: "requirement_name", requirement_name: reader.string() };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PerRouteConfig {
    return {
      $type: PerRouteConfig.$type,
      requirement_specifier: isSet(object.disabled)
        ? { $case: "disabled", disabled: globalThis.Boolean(object.disabled) }
        : isSet(object.requirement_name)
        ? { $case: "requirement_name", requirement_name: globalThis.String(object.requirement_name) }
        : undefined,
    };
  },

  toJSON(message: PerRouteConfig): unknown {
    const obj: any = {};
    if (message.requirement_specifier?.$case === "disabled") {
      obj.disabled = message.requirement_specifier.disabled;
    }
    if (message.requirement_specifier?.$case === "requirement_name") {
      obj.requirement_name = message.requirement_specifier.requirement_name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PerRouteConfig>, I>>(base?: I): PerRouteConfig {
    return PerRouteConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PerRouteConfig>, I>>(object: I): PerRouteConfig {
    const message = createBasePerRouteConfig();
    if (
      object.requirement_specifier?.$case === "disabled" &&
      object.requirement_specifier?.disabled !== undefined &&
      object.requirement_specifier?.disabled !== null
    ) {
      message.requirement_specifier = { $case: "disabled", disabled: object.requirement_specifier.disabled };
    }
    if (
      object.requirement_specifier?.$case === "requirement_name" &&
      object.requirement_specifier?.requirement_name !== undefined &&
      object.requirement_specifier?.requirement_name !== null
    ) {
      message.requirement_specifier = {
        $case: "requirement_name",
        requirement_name: object.requirement_specifier.requirement_name,
      };
    }
    return message;
  },
};

messageTypeRegistry.set(PerRouteConfig.$type, PerRouteConfig);

function createBaseJwtClaimToHeader(): JwtClaimToHeader {
  return { $type: "envoy.extensions.filters.http.jwt_authn.v3.JwtClaimToHeader" };
}

export const JwtClaimToHeader: MessageFns<
  JwtClaimToHeader,
  "envoy.extensions.filters.http.jwt_authn.v3.JwtClaimToHeader"
> = {
  $type: "envoy.extensions.filters.http.jwt_authn.v3.JwtClaimToHeader" as const,

  encode(message: JwtClaimToHeader, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header_name !== undefined && message.header_name !== "") {
      writer.uint32(10).string(message.header_name);
    }
    if (message.claim_name !== undefined && message.claim_name !== "") {
      writer.uint32(18).string(message.claim_name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JwtClaimToHeader {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJwtClaimToHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header_name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.claim_name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JwtClaimToHeader {
    return {
      $type: JwtClaimToHeader.$type,
      header_name: isSet(object.header_name) ? globalThis.String(object.header_name) : undefined,
      claim_name: isSet(object.claim_name) ? globalThis.String(object.claim_name) : undefined,
    };
  },

  toJSON(message: JwtClaimToHeader): unknown {
    const obj: any = {};
    if (message.header_name !== undefined) {
      obj.header_name = message.header_name;
    }
    if (message.claim_name !== undefined) {
      obj.claim_name = message.claim_name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JwtClaimToHeader>, I>>(base?: I): JwtClaimToHeader {
    return JwtClaimToHeader.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JwtClaimToHeader>, I>>(object: I): JwtClaimToHeader {
    const message = createBaseJwtClaimToHeader();
    message.header_name = object.header_name ?? undefined;
    message.claim_name = object.claim_name ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(JwtClaimToHeader.$type, JwtClaimToHeader);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
