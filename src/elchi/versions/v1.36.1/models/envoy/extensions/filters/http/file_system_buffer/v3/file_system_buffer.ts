// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/filters/http/file_system_buffer/v3/file_system_buffer.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { StringValue, UInt64Value } from "../../../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../../../typeRegistry";
import { AsyncFileManagerConfig } from "../../../../common/async_files/v3/async_file_manager";

export const protobufPackage = "envoy.extensions.filters.http.file_system_buffer.v3";

/**
 * The behavior of the filter for a stream.
 * [#next-free-field: 6]
 */
export interface BufferBehavior {
  $type: "envoy.extensions.filters.http.file_system_buffer.v3.BufferBehavior";
  behavior?:
    | //
    /**
     * Don't inject ``content-length`` header.
     * Output immediately, buffer only if output is slower than input.
     */
    { $case: "stream_when_possible"; stream_when_possible: BufferBehavior_StreamWhenPossible }
    | //
    /** Never buffer, do nothing. */
    { $case: "bypass"; bypass: BufferBehavior_Bypass }
    | //
    /**
     * If ``content-length`` is not present, buffer the entire input,
     * inject ``content-length`` header, then output.
     * If ``content-length`` is already present, act like ``stream_when_possible``.
     */
    {
      $case: "inject_content_length_if_necessary";
      inject_content_length_if_necessary: BufferBehavior_InjectContentLengthIfNecessary;
    }
    | //
    /**
     * Always buffer the entire input, and inject ``content-length``,
     * overwriting any provided content-length header.
     */
    {
      $case: "fully_buffer_and_always_inject_content_length";
      fully_buffer_and_always_inject_content_length: BufferBehavior_FullyBufferAndAlwaysInjectContentLength;
    }
    | //
    /** Always buffer the entire input, do not modify ``content-length``. */
    { $case: "fully_buffer"; fully_buffer: BufferBehavior_FullyBuffer }
    | undefined;
}

export interface BufferBehavior_StreamWhenPossible {
  $type: "envoy.extensions.filters.http.file_system_buffer.v3.BufferBehavior.StreamWhenPossible";
}

export interface BufferBehavior_Bypass {
  $type: "envoy.extensions.filters.http.file_system_buffer.v3.BufferBehavior.Bypass";
}

export interface BufferBehavior_InjectContentLengthIfNecessary {
  $type: "envoy.extensions.filters.http.file_system_buffer.v3.BufferBehavior.InjectContentLengthIfNecessary";
}

export interface BufferBehavior_FullyBufferAndAlwaysInjectContentLength {
  $type: "envoy.extensions.filters.http.file_system_buffer.v3.BufferBehavior.FullyBufferAndAlwaysInjectContentLength";
}

export interface BufferBehavior_FullyBuffer {
  $type: "envoy.extensions.filters.http.file_system_buffer.v3.BufferBehavior.FullyBuffer";
}

/** The configuration for one direction of the filter behavior. */
export interface StreamConfig {
  $type: "envoy.extensions.filters.http.file_system_buffer.v3.StreamConfig";
  /**
   * Whether to bypass / stream / fully buffer / etc.
   * If unset in route, vhost and listener config, the default is ``stream_when_possible``.
   */
  behavior?:
    | BufferBehavior
    | undefined;
  /**
   * The amount stored in the memory buffer before buffering to disk.
   * If unset in route, vhost and listener config, defaults to a hardcoded value of 1MiB
   */
  memory_buffer_bytes_limit?:
    | number
    | undefined;
  /**
   * The maximum storage (excluding memory) to be buffered in this filter.
   * If unset in route, vhost and listener config, defaults to a hardcoded value of 32MiB
   */
  storage_buffer_bytes_limit?:
    | number
    | undefined;
  /**
   * The maximum amount that can be queued for writing to storage, above which the
   * source is requested to pause. If unset, defaults to the same value as
   * ``memory_buffer_bytes_limit``.
   *
   * For example, assuming the recipient is not consuming data at all, if
   * ``memory_buffer_bytes_limit`` was 32MiB, and ``storage_buffer_queue_high_watermark_bytes``
   * was 64MiB, and the filesystem is backed up so writes are not occurring promptly,
   * then:
   *
   * * Any request less than 32MiB will eventually pass through without ever attempting
   *   to write to disk.
   * * Any request with over 32MiB buffered will start trying to write to disk.
   *   If it reaches (32+64)MiB buffered in memory (write to disk isn't keeping up), a high
   *   watermark signal is sent to the source.
   * * Any stream whose total size exceeds
   *   ``memory_buffer_bytes_limit + storage_buffer_bytes_limit`` will provoke an error.
   *   (Note, if the recipient *is* consuming data then it is possible for such an
   *   oversized request to pass through the buffer filter, provided the recipient
   *   isn't consuming data too slowly.)
   *
   * The low watermark signal is sent when the memory buffer is at size
   * ``memory_buffer_bytes_limit + (storage_buffer_queue_high_watermark_bytes / 2)``.
   */
  storage_buffer_queue_high_watermark_bytes?: number | undefined;
}

/**
 * A :ref:`file system buffer <config_http_filters_file_system_buffer>` filter configuration.
 *
 * Route-specific configs override only the fields they explicitly include; unset
 * fields inherit from the vhost or listener-level config, or, if never set,
 * and not required, use a default value.
 */
export interface FileSystemBufferFilterConfig {
  $type: "envoy.extensions.filters.http.file_system_buffer.v3.FileSystemBufferFilterConfig";
  /**
   * A configuration for an AsyncFileManager.
   *
   * If unset in route, vhost and listener, and the behavior is not ``bypass``
   * in both directions, an Internal Server Error response will be sent.
   */
  manager_config?:
    | AsyncFileManagerConfig
    | undefined;
  /**
   * An optional path to which the unlinked files should be written - this may
   * determine which physical storage device will be used.
   *
   * If unset in route, vhost and listener, will use the environment variable
   * ``TMPDIR``, or, if that's also unset, will use ``/tmp``.
   */
  storage_buffer_path?:
    | string
    | undefined;
  /**
   * Optional configuration for how to buffer (or not) requests.
   * If unset in route, vhost and listener, ``StreamConfig`` default values will be used
   * (with behavior ``stream_when_possible``)
   */
  request?:
    | StreamConfig
    | undefined;
  /**
   * Optional configuration for how to buffer (or not) responses.
   * If unset in route, vhost and listener, ``StreamConfig`` default values will be used
   * (with behavior ``stream_when_possible``)
   */
  response?: StreamConfig | undefined;
}

function createBaseBufferBehavior(): BufferBehavior {
  return { $type: "envoy.extensions.filters.http.file_system_buffer.v3.BufferBehavior", behavior: undefined };
}

export const BufferBehavior: MessageFns<
  BufferBehavior,
  "envoy.extensions.filters.http.file_system_buffer.v3.BufferBehavior"
> = {
  $type: "envoy.extensions.filters.http.file_system_buffer.v3.BufferBehavior" as const,

  encode(message: BufferBehavior, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.behavior?.$case) {
      case "stream_when_possible":
        BufferBehavior_StreamWhenPossible.encode(message.behavior.stream_when_possible, writer.uint32(10).fork())
          .join();
        break;
      case "bypass":
        BufferBehavior_Bypass.encode(message.behavior.bypass, writer.uint32(18).fork()).join();
        break;
      case "inject_content_length_if_necessary":
        BufferBehavior_InjectContentLengthIfNecessary.encode(
          message.behavior.inject_content_length_if_necessary,
          writer.uint32(26).fork(),
        ).join();
        break;
      case "fully_buffer_and_always_inject_content_length":
        BufferBehavior_FullyBufferAndAlwaysInjectContentLength.encode(
          message.behavior.fully_buffer_and_always_inject_content_length,
          writer.uint32(34).fork(),
        ).join();
        break;
      case "fully_buffer":
        BufferBehavior_FullyBuffer.encode(message.behavior.fully_buffer, writer.uint32(42).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BufferBehavior {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBufferBehavior();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.behavior = {
            $case: "stream_when_possible",
            stream_when_possible: BufferBehavior_StreamWhenPossible.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.behavior = { $case: "bypass", bypass: BufferBehavior_Bypass.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.behavior = {
            $case: "inject_content_length_if_necessary",
            inject_content_length_if_necessary: BufferBehavior_InjectContentLengthIfNecessary.decode(
              reader,
              reader.uint32(),
            ),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.behavior = {
            $case: "fully_buffer_and_always_inject_content_length",
            fully_buffer_and_always_inject_content_length: BufferBehavior_FullyBufferAndAlwaysInjectContentLength
              .decode(reader, reader.uint32()),
          };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.behavior = {
            $case: "fully_buffer",
            fully_buffer: BufferBehavior_FullyBuffer.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BufferBehavior {
    return {
      $type: BufferBehavior.$type,
      behavior: isSet(object.stream_when_possible)
        ? {
          $case: "stream_when_possible",
          stream_when_possible: BufferBehavior_StreamWhenPossible.fromJSON(object.stream_when_possible),
        }
        : isSet(object.bypass)
        ? { $case: "bypass", bypass: BufferBehavior_Bypass.fromJSON(object.bypass) }
        : isSet(object.inject_content_length_if_necessary)
        ? {
          $case: "inject_content_length_if_necessary",
          inject_content_length_if_necessary: BufferBehavior_InjectContentLengthIfNecessary.fromJSON(
            object.inject_content_length_if_necessary,
          ),
        }
        : isSet(object.fully_buffer_and_always_inject_content_length)
        ? {
          $case: "fully_buffer_and_always_inject_content_length",
          fully_buffer_and_always_inject_content_length: BufferBehavior_FullyBufferAndAlwaysInjectContentLength
            .fromJSON(object.fully_buffer_and_always_inject_content_length),
        }
        : isSet(object.fully_buffer)
        ? { $case: "fully_buffer", fully_buffer: BufferBehavior_FullyBuffer.fromJSON(object.fully_buffer) }
        : undefined,
    };
  },

  toJSON(message: BufferBehavior): unknown {
    const obj: any = {};
    if (message.behavior?.$case === "stream_when_possible") {
      obj.stream_when_possible = BufferBehavior_StreamWhenPossible.toJSON(message.behavior.stream_when_possible);
    }
    if (message.behavior?.$case === "bypass") {
      obj.bypass = BufferBehavior_Bypass.toJSON(message.behavior.bypass);
    }
    if (message.behavior?.$case === "inject_content_length_if_necessary") {
      obj.inject_content_length_if_necessary = BufferBehavior_InjectContentLengthIfNecessary.toJSON(
        message.behavior.inject_content_length_if_necessary,
      );
    }
    if (message.behavior?.$case === "fully_buffer_and_always_inject_content_length") {
      obj.fully_buffer_and_always_inject_content_length = BufferBehavior_FullyBufferAndAlwaysInjectContentLength.toJSON(
        message.behavior.fully_buffer_and_always_inject_content_length,
      );
    }
    if (message.behavior?.$case === "fully_buffer") {
      obj.fully_buffer = BufferBehavior_FullyBuffer.toJSON(message.behavior.fully_buffer);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BufferBehavior>, I>>(base?: I): BufferBehavior {
    return BufferBehavior.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BufferBehavior>, I>>(object: I): BufferBehavior {
    const message = createBaseBufferBehavior();
    if (
      object.behavior?.$case === "stream_when_possible" &&
      object.behavior?.stream_when_possible !== undefined &&
      object.behavior?.stream_when_possible !== null
    ) {
      message.behavior = {
        $case: "stream_when_possible",
        stream_when_possible: BufferBehavior_StreamWhenPossible.fromPartial(object.behavior.stream_when_possible),
      };
    }
    if (
      object.behavior?.$case === "bypass" && object.behavior?.bypass !== undefined && object.behavior?.bypass !== null
    ) {
      message.behavior = { $case: "bypass", bypass: BufferBehavior_Bypass.fromPartial(object.behavior.bypass) };
    }
    if (
      object.behavior?.$case === "inject_content_length_if_necessary" &&
      object.behavior?.inject_content_length_if_necessary !== undefined &&
      object.behavior?.inject_content_length_if_necessary !== null
    ) {
      message.behavior = {
        $case: "inject_content_length_if_necessary",
        inject_content_length_if_necessary: BufferBehavior_InjectContentLengthIfNecessary.fromPartial(
          object.behavior.inject_content_length_if_necessary,
        ),
      };
    }
    if (
      object.behavior?.$case === "fully_buffer_and_always_inject_content_length" &&
      object.behavior?.fully_buffer_and_always_inject_content_length !== undefined &&
      object.behavior?.fully_buffer_and_always_inject_content_length !== null
    ) {
      message.behavior = {
        $case: "fully_buffer_and_always_inject_content_length",
        fully_buffer_and_always_inject_content_length: BufferBehavior_FullyBufferAndAlwaysInjectContentLength
          .fromPartial(object.behavior.fully_buffer_and_always_inject_content_length),
      };
    }
    if (
      object.behavior?.$case === "fully_buffer" &&
      object.behavior?.fully_buffer !== undefined &&
      object.behavior?.fully_buffer !== null
    ) {
      message.behavior = {
        $case: "fully_buffer",
        fully_buffer: BufferBehavior_FullyBuffer.fromPartial(object.behavior.fully_buffer),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(BufferBehavior.$type, BufferBehavior);

function createBaseBufferBehavior_StreamWhenPossible(): BufferBehavior_StreamWhenPossible {
  return { $type: "envoy.extensions.filters.http.file_system_buffer.v3.BufferBehavior.StreamWhenPossible" };
}

export const BufferBehavior_StreamWhenPossible: MessageFns<
  BufferBehavior_StreamWhenPossible,
  "envoy.extensions.filters.http.file_system_buffer.v3.BufferBehavior.StreamWhenPossible"
> = {
  $type: "envoy.extensions.filters.http.file_system_buffer.v3.BufferBehavior.StreamWhenPossible" as const,

  encode(_: BufferBehavior_StreamWhenPossible, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BufferBehavior_StreamWhenPossible {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBufferBehavior_StreamWhenPossible();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): BufferBehavior_StreamWhenPossible {
    return { $type: BufferBehavior_StreamWhenPossible.$type };
  },

  toJSON(_: BufferBehavior_StreamWhenPossible): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<BufferBehavior_StreamWhenPossible>, I>>(
    base?: I,
  ): BufferBehavior_StreamWhenPossible {
    return BufferBehavior_StreamWhenPossible.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BufferBehavior_StreamWhenPossible>, I>>(
    _: I,
  ): BufferBehavior_StreamWhenPossible {
    const message = createBaseBufferBehavior_StreamWhenPossible();
    return message;
  },
};

messageTypeRegistry.set(BufferBehavior_StreamWhenPossible.$type, BufferBehavior_StreamWhenPossible);

function createBaseBufferBehavior_Bypass(): BufferBehavior_Bypass {
  return { $type: "envoy.extensions.filters.http.file_system_buffer.v3.BufferBehavior.Bypass" };
}

export const BufferBehavior_Bypass: MessageFns<
  BufferBehavior_Bypass,
  "envoy.extensions.filters.http.file_system_buffer.v3.BufferBehavior.Bypass"
> = {
  $type: "envoy.extensions.filters.http.file_system_buffer.v3.BufferBehavior.Bypass" as const,

  encode(_: BufferBehavior_Bypass, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BufferBehavior_Bypass {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBufferBehavior_Bypass();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): BufferBehavior_Bypass {
    return { $type: BufferBehavior_Bypass.$type };
  },

  toJSON(_: BufferBehavior_Bypass): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<BufferBehavior_Bypass>, I>>(base?: I): BufferBehavior_Bypass {
    return BufferBehavior_Bypass.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BufferBehavior_Bypass>, I>>(_: I): BufferBehavior_Bypass {
    const message = createBaseBufferBehavior_Bypass();
    return message;
  },
};

messageTypeRegistry.set(BufferBehavior_Bypass.$type, BufferBehavior_Bypass);

function createBaseBufferBehavior_InjectContentLengthIfNecessary(): BufferBehavior_InjectContentLengthIfNecessary {
  return { $type: "envoy.extensions.filters.http.file_system_buffer.v3.BufferBehavior.InjectContentLengthIfNecessary" };
}

export const BufferBehavior_InjectContentLengthIfNecessary: MessageFns<
  BufferBehavior_InjectContentLengthIfNecessary,
  "envoy.extensions.filters.http.file_system_buffer.v3.BufferBehavior.InjectContentLengthIfNecessary"
> = {
  $type: "envoy.extensions.filters.http.file_system_buffer.v3.BufferBehavior.InjectContentLengthIfNecessary" as const,

  encode(_: BufferBehavior_InjectContentLengthIfNecessary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BufferBehavior_InjectContentLengthIfNecessary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBufferBehavior_InjectContentLengthIfNecessary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): BufferBehavior_InjectContentLengthIfNecessary {
    return { $type: BufferBehavior_InjectContentLengthIfNecessary.$type };
  },

  toJSON(_: BufferBehavior_InjectContentLengthIfNecessary): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<BufferBehavior_InjectContentLengthIfNecessary>, I>>(
    base?: I,
  ): BufferBehavior_InjectContentLengthIfNecessary {
    return BufferBehavior_InjectContentLengthIfNecessary.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BufferBehavior_InjectContentLengthIfNecessary>, I>>(
    _: I,
  ): BufferBehavior_InjectContentLengthIfNecessary {
    const message = createBaseBufferBehavior_InjectContentLengthIfNecessary();
    return message;
  },
};

messageTypeRegistry.set(
  BufferBehavior_InjectContentLengthIfNecessary.$type,
  BufferBehavior_InjectContentLengthIfNecessary,
);

function createBaseBufferBehavior_FullyBufferAndAlwaysInjectContentLength(): BufferBehavior_FullyBufferAndAlwaysInjectContentLength {
  return {
    $type: "envoy.extensions.filters.http.file_system_buffer.v3.BufferBehavior.FullyBufferAndAlwaysInjectContentLength",
  };
}

export const BufferBehavior_FullyBufferAndAlwaysInjectContentLength: MessageFns<
  BufferBehavior_FullyBufferAndAlwaysInjectContentLength,
  "envoy.extensions.filters.http.file_system_buffer.v3.BufferBehavior.FullyBufferAndAlwaysInjectContentLength"
> = {
  $type:
    "envoy.extensions.filters.http.file_system_buffer.v3.BufferBehavior.FullyBufferAndAlwaysInjectContentLength" as const,

  encode(
    _: BufferBehavior_FullyBufferAndAlwaysInjectContentLength,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BufferBehavior_FullyBufferAndAlwaysInjectContentLength {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBufferBehavior_FullyBufferAndAlwaysInjectContentLength();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): BufferBehavior_FullyBufferAndAlwaysInjectContentLength {
    return { $type: BufferBehavior_FullyBufferAndAlwaysInjectContentLength.$type };
  },

  toJSON(_: BufferBehavior_FullyBufferAndAlwaysInjectContentLength): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<BufferBehavior_FullyBufferAndAlwaysInjectContentLength>, I>>(
    base?: I,
  ): BufferBehavior_FullyBufferAndAlwaysInjectContentLength {
    return BufferBehavior_FullyBufferAndAlwaysInjectContentLength.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BufferBehavior_FullyBufferAndAlwaysInjectContentLength>, I>>(
    _: I,
  ): BufferBehavior_FullyBufferAndAlwaysInjectContentLength {
    const message = createBaseBufferBehavior_FullyBufferAndAlwaysInjectContentLength();
    return message;
  },
};

messageTypeRegistry.set(
  BufferBehavior_FullyBufferAndAlwaysInjectContentLength.$type,
  BufferBehavior_FullyBufferAndAlwaysInjectContentLength,
);

function createBaseBufferBehavior_FullyBuffer(): BufferBehavior_FullyBuffer {
  return { $type: "envoy.extensions.filters.http.file_system_buffer.v3.BufferBehavior.FullyBuffer" };
}

export const BufferBehavior_FullyBuffer: MessageFns<
  BufferBehavior_FullyBuffer,
  "envoy.extensions.filters.http.file_system_buffer.v3.BufferBehavior.FullyBuffer"
> = {
  $type: "envoy.extensions.filters.http.file_system_buffer.v3.BufferBehavior.FullyBuffer" as const,

  encode(_: BufferBehavior_FullyBuffer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BufferBehavior_FullyBuffer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBufferBehavior_FullyBuffer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): BufferBehavior_FullyBuffer {
    return { $type: BufferBehavior_FullyBuffer.$type };
  },

  toJSON(_: BufferBehavior_FullyBuffer): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<BufferBehavior_FullyBuffer>, I>>(base?: I): BufferBehavior_FullyBuffer {
    return BufferBehavior_FullyBuffer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BufferBehavior_FullyBuffer>, I>>(_: I): BufferBehavior_FullyBuffer {
    const message = createBaseBufferBehavior_FullyBuffer();
    return message;
  },
};

messageTypeRegistry.set(BufferBehavior_FullyBuffer.$type, BufferBehavior_FullyBuffer);

function createBaseStreamConfig(): StreamConfig {
  return { $type: "envoy.extensions.filters.http.file_system_buffer.v3.StreamConfig" };
}

export const StreamConfig: MessageFns<
  StreamConfig,
  "envoy.extensions.filters.http.file_system_buffer.v3.StreamConfig"
> = {
  $type: "envoy.extensions.filters.http.file_system_buffer.v3.StreamConfig" as const,

  encode(message: StreamConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.behavior !== undefined) {
      BufferBehavior.encode(message.behavior, writer.uint32(10).fork()).join();
    }
    if (message.memory_buffer_bytes_limit !== undefined) {
      UInt64Value.encode(
        { $type: "google.protobuf.UInt64Value", value: message.memory_buffer_bytes_limit! },
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.storage_buffer_bytes_limit !== undefined) {
      UInt64Value.encode(
        { $type: "google.protobuf.UInt64Value", value: message.storage_buffer_bytes_limit! },
        writer.uint32(26).fork(),
      ).join();
    }
    if (message.storage_buffer_queue_high_watermark_bytes !== undefined) {
      UInt64Value.encode({
        $type: "google.protobuf.UInt64Value",
        value: message.storage_buffer_queue_high_watermark_bytes!,
      }, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.behavior = BufferBehavior.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.memory_buffer_bytes_limit = UInt64Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.storage_buffer_bytes_limit = UInt64Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.storage_buffer_queue_high_watermark_bytes = UInt64Value.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamConfig {
    return {
      $type: StreamConfig.$type,
      behavior: isSet(object.behavior) ? BufferBehavior.fromJSON(object.behavior) : undefined,
      memory_buffer_bytes_limit: isSet(object.memory_buffer_bytes_limit)
        ? Number(object.memory_buffer_bytes_limit)
        : undefined,
      storage_buffer_bytes_limit: isSet(object.storage_buffer_bytes_limit)
        ? Number(object.storage_buffer_bytes_limit)
        : undefined,
      storage_buffer_queue_high_watermark_bytes: isSet(object.storage_buffer_queue_high_watermark_bytes)
        ? Number(object.storage_buffer_queue_high_watermark_bytes)
        : undefined,
    };
  },

  toJSON(message: StreamConfig): unknown {
    const obj: any = {};
    if (message.behavior !== undefined) {
      obj.behavior = BufferBehavior.toJSON(message.behavior);
    }
    if (message.memory_buffer_bytes_limit !== undefined) {
      obj.memory_buffer_bytes_limit = message.memory_buffer_bytes_limit;
    }
    if (message.storage_buffer_bytes_limit !== undefined) {
      obj.storage_buffer_bytes_limit = message.storage_buffer_bytes_limit;
    }
    if (message.storage_buffer_queue_high_watermark_bytes !== undefined) {
      obj.storage_buffer_queue_high_watermark_bytes = message.storage_buffer_queue_high_watermark_bytes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamConfig>, I>>(base?: I): StreamConfig {
    return StreamConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamConfig>, I>>(object: I): StreamConfig {
    const message = createBaseStreamConfig();
    message.behavior = (object.behavior !== undefined && object.behavior !== null)
      ? BufferBehavior.fromPartial(object.behavior)
      : undefined;
    message.memory_buffer_bytes_limit = object.memory_buffer_bytes_limit ?? undefined;
    message.storage_buffer_bytes_limit = object.storage_buffer_bytes_limit ?? undefined;
    message.storage_buffer_queue_high_watermark_bytes = object.storage_buffer_queue_high_watermark_bytes ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(StreamConfig.$type, StreamConfig);

function createBaseFileSystemBufferFilterConfig(): FileSystemBufferFilterConfig {
  return { $type: "envoy.extensions.filters.http.file_system_buffer.v3.FileSystemBufferFilterConfig" };
}

export const FileSystemBufferFilterConfig: MessageFns<
  FileSystemBufferFilterConfig,
  "envoy.extensions.filters.http.file_system_buffer.v3.FileSystemBufferFilterConfig"
> = {
  $type: "envoy.extensions.filters.http.file_system_buffer.v3.FileSystemBufferFilterConfig" as const,

  encode(message: FileSystemBufferFilterConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.manager_config !== undefined) {
      AsyncFileManagerConfig.encode(message.manager_config, writer.uint32(10).fork()).join();
    }
    if (message.storage_buffer_path !== undefined) {
      StringValue.encode(
        { $type: "google.protobuf.StringValue", value: message.storage_buffer_path! },
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.request !== undefined) {
      StreamConfig.encode(message.request, writer.uint32(26).fork()).join();
    }
    if (message.response !== undefined) {
      StreamConfig.encode(message.response, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileSystemBufferFilterConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileSystemBufferFilterConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.manager_config = AsyncFileManagerConfig.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.storage_buffer_path = StringValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.request = StreamConfig.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.response = StreamConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileSystemBufferFilterConfig {
    return {
      $type: FileSystemBufferFilterConfig.$type,
      manager_config: isSet(object.manager_config) ? AsyncFileManagerConfig.fromJSON(object.manager_config) : undefined,
      storage_buffer_path: isSet(object.storage_buffer_path) ? String(object.storage_buffer_path) : undefined,
      request: isSet(object.request) ? StreamConfig.fromJSON(object.request) : undefined,
      response: isSet(object.response) ? StreamConfig.fromJSON(object.response) : undefined,
    };
  },

  toJSON(message: FileSystemBufferFilterConfig): unknown {
    const obj: any = {};
    if (message.manager_config !== undefined) {
      obj.manager_config = AsyncFileManagerConfig.toJSON(message.manager_config);
    }
    if (message.storage_buffer_path !== undefined) {
      obj.storage_buffer_path = message.storage_buffer_path;
    }
    if (message.request !== undefined) {
      obj.request = StreamConfig.toJSON(message.request);
    }
    if (message.response !== undefined) {
      obj.response = StreamConfig.toJSON(message.response);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FileSystemBufferFilterConfig>, I>>(base?: I): FileSystemBufferFilterConfig {
    return FileSystemBufferFilterConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FileSystemBufferFilterConfig>, I>>(object: I): FileSystemBufferFilterConfig {
    const message = createBaseFileSystemBufferFilterConfig();
    message.manager_config = (object.manager_config !== undefined && object.manager_config !== null)
      ? AsyncFileManagerConfig.fromPartial(object.manager_config)
      : undefined;
    message.storage_buffer_path = object.storage_buffer_path ?? undefined;
    message.request = (object.request !== undefined && object.request !== null)
      ? StreamConfig.fromPartial(object.request)
      : undefined;
    message.response = (object.response !== undefined && object.response !== null)
      ? StreamConfig.fromPartial(object.response)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(FileSystemBufferFilterConfig.$type, FileSystemBufferFilterConfig);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
