// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/filters/network/tcp_proxy/v3/tcp_proxy.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../../../../google/protobuf/duration";
import { UInt32Value } from "../../../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../../../typeRegistry";
import { AccessLog } from "../../../../../config/accesslog/v3/accesslog";
import { BackoffStrategy } from "../../../../../config/core/v3/backoff";
import { HeaderValueOption, Metadata } from "../../../../../config/core/v3/base";
import { ConfigSource } from "../../../../../config/core/v3/config_source";
import { TlvEntry } from "../../../../../config/core/v3/proxy_protocol";
import { HashPolicy } from "../../../../../type/v3/hash_policy";
import { Percent } from "../../../../../type/v3/percent";
import { RequestIDExtension } from "../../http_connection_manager/v3/http_connection_manager";

export const protobufPackage = "envoy.extensions.filters.network.tcp_proxy.v3";

/** [#next-free-field: 21] */
export interface TcpProxy {
  $type: "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy";
  /**
   * The prefix to use when emitting :ref:`statistics
   * <config_network_filters_tcp_proxy_stats>`.
   */
  stat_prefix?: string | undefined;
  cluster_specifier?:
    | //
    /** The upstream cluster to connect to. */
    { $case: "cluster"; cluster: string }
    | //
    /**
     * Multiple upstream clusters can be specified. The request is routed to one of the upstream clusters
     * based on the weights assigned to each cluster.
     */
    { $case: "weighted_clusters"; weighted_clusters: TcpProxy_WeightedCluster }
    | undefined;
  /**
   * The on demand policy for the upstream cluster.
   * It applies to both
   * :ref:`TcpProxy.cluster <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.cluster>`
   * and
   * :ref:`TcpProxy.weighted_clusters <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.weighted_clusters>`.
   */
  on_demand?:
    | TcpProxy_OnDemand
    | undefined;
  /**
   * Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints
   * in the upstream cluster with metadata matching what is set in this field will be considered
   * for load balancing. The filter name should be specified as ``envoy.lb``.
   */
  metadata_match?:
    | Metadata
    | undefined;
  /**
   * The idle timeout for connections managed by the TCP proxy filter. The idle timeout is defined as the
   * period in which there are no bytes sent or received on either the upstream or downstream connection.
   * If not set, the default idle timeout is 1 hour. If set to ``0s``, the timeout is disabled.
   * It is possible to dynamically override this configuration by setting a per-connection filter state
   * object for the key ``envoy.tcp_proxy.per_connection_idle_timeout_ms``.
   *
   * .. warning::
   *   Disabling this timeout is likely to yield connection leaks due to lost TCP FIN packets, etc.
   */
  idle_timeout?:
    | Duration
    | undefined;
  /**
   * [#not-implemented-hide:] The idle timeout for connections managed by the TCP proxy
   * filter. The idle timeout is defined as the period in which there is no
   * active traffic. If not set, there is no idle timeout. When the idle timeout
   * is reached the connection will be closed. The distinction between
   * downstream_idle_timeout/upstream_idle_timeout provides a means to set
   * timeout based on the last byte sent on the downstream/upstream connection.
   */
  downstream_idle_timeout?:
    | Duration
    | undefined;
  /** [#not-implemented-hide:] */
  upstream_idle_timeout?:
    | Duration
    | undefined;
  /** Configuration for :ref:`access logs <arch_overview_access_logs>` emitted by this TCP proxy. */
  access_log?:
    | AccessLog[]
    | undefined;
  /**
   * The maximum number of unsuccessful connection attempts that will be made before
   * giving up. If the parameter is not specified, 1 connection attempt will be made.
   */
  max_connect_attempts?:
    | number
    | undefined;
  /** Sets the backoff strategy. If not set, the retries are performed without backoff. */
  backoff_options?:
    | BackoffStrategy
    | undefined;
  /**
   * Optional configuration for TCP proxy hash policy. If hash_policy is not set, the hash-based
   * load balancing algorithms will select a host randomly. Currently the number of hash policies is
   * limited to 1.
   */
  hash_policy?:
    | HashPolicy[]
    | undefined;
  /**
   * If set, this configures tunneling, for example configuration options to tunnel TCP payload over
   * HTTP CONNECT. If this message is absent, the payload is proxied upstream as usual.
   * It is possible to dynamically override this configuration and disable tunneling per connection by
   * setting a per-connection filter state object for the key ``envoy.tcp_proxy.disable_tunneling``.
   */
  tunneling_config?:
    | TcpProxy_TunnelingConfig
    | undefined;
  /**
   * The maximum duration of a connection. The duration is defined as the period since a connection was
   * established. If not set, there is no maximum duration. When ``max_downstream_connection_duration`` is
   * reached, the connection is closed. The duration must be at least ``1ms``.
   */
  max_downstream_connection_duration?:
    | Duration
    | undefined;
  /**
   * Percentage-based jitter for ``max_downstream_connection_duration``. The jitter increases the
   * ``max_downstream_connection_duration`` by a random duration up to the provided percentage.
   * This field is ignored if ``max_downstream_connection_duration`` is not set. If not set, no jitter
   * is added.
   */
  max_downstream_connection_duration_jitter_percentage?:
    | Percent
    | undefined;
  /**
   * If both this field and :ref:`access_log_flush_interval
   * <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions.access_log_flush_interval>`
   * are specified, the former (deprecated field) is ignored.
   *
   * .. attention::
   *   This field is deprecated in favor of
   *   :ref:`access_log_flush_interval
   *   <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions.access_log_flush_interval>`.
   *
   * @deprecated
   */
  access_log_flush_interval?:
    | Duration
    | undefined;
  /**
   * If both this field and :ref:`flush_access_log_on_connected
   * <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions.flush_access_log_on_connected>`
   * are specified, the former (deprecated field) is ignored.
   *
   * .. attention::
   *   This field is deprecated in favor of
   *   :ref:`flush_access_log_on_connected
   *   <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions.flush_access_log_on_connected>`.
   *
   * @deprecated
   */
  flush_access_log_on_connected?:
    | boolean
    | undefined;
  /** Additional access log options for the TCP proxy. */
  access_log_options?:
    | TcpProxy_TcpAccessLogOptions
    | undefined;
  /**
   * If set, the specified ``PROXY`` protocol TLVs (Type-Length-Value) are added to the ``PROXY`` protocol state
   * created by the TCP proxy filter. These TLVs are sent in the PROXY protocol v2 header to the upstream.
   *
   * This field only takes effect when the TCP proxy filter is creating new ``PROXY`` protocol state and an
   * upstream proxy protocol transport socket is configured in the cluster. If the connection already
   * contains ``PROXY`` protocol state (including any TLVs) parsed by a downstream proxy protocol listener
   * upstream proxy protocol transport socket is configured in the cluster. If the connection already
   * contains PROXY protocol state (including any TLVs) parsed by a downstream proxy protocol listener
   * filter, the TLVs specified here are ignored.
   *
   * .. note::
   *   To ensure the specified TLVs are allowed in the upstream ``PROXY`` protocol header, you must also
   *   configure passthrough TLVs on the upstream proxy protocol transport. See
   *   :ref:`core.v3.ProxyProtocolConfig.pass_through_tlvs <envoy_v3_api_field_config.core.v3.ProxyProtocolConfig.pass_through_tlvs>`
   *   for details.
   */
  proxy_protocol_tlvs?: TlvEntry[] | undefined;
}

/**
 * Allows specification of multiple upstream clusters along with weights indicating the percentage of
 * traffic forwarded to each cluster. The cluster selection is based on these weights.
 */
export interface TcpProxy_WeightedCluster {
  $type: "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.WeightedCluster";
  /** Specifies the upstream clusters associated with this configuration. */
  clusters?: TcpProxy_WeightedCluster_ClusterWeight[] | undefined;
}

export interface TcpProxy_WeightedCluster_ClusterWeight {
  $type: "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.WeightedCluster.ClusterWeight";
  /** Name of the upstream cluster. */
  name?:
    | string
    | undefined;
  /**
   * When a request matches the route, the choice of an upstream cluster is
   * determined by its weight. The sum of weights across all entries in the
   * clusters array determines the total weight.
   */
  weight?:
    | number
    | undefined;
  /**
   * Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints
   * in the upstream cluster with metadata matching what is set in this field will be considered
   * for load balancing. Note that this will be merged with what's provided in
   * :ref:`TcpProxy.metadata_match
   * <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.metadata_match>`, with values
   * here taking precedence. The filter name should be specified as ``envoy.lb``.
   */
  metadata_match?: Metadata | undefined;
}

/**
 * Configuration for tunneling TCP over other transports or application layers.
 * Tunneling is supported over HTTP/1.1 and HTTP/2. The upstream protocol is
 * determined by the cluster configuration.
 * [#next-free-field: 10]
 */
export interface TcpProxy_TunnelingConfig {
  $type: "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.TunnelingConfig";
  /**
   * The hostname to send in the synthesized CONNECT headers to the upstream proxy.
   * This field evaluates command operators if present; otherwise, the value is used as-is.
   *
   * For example, dynamically set the hostname using downstream SNI:
   *
   * .. code-block:: yaml
   *
   *    tunneling_config:
   *      hostname: "%REQUESTED_SERVER_NAME%:443"
   *
   * For example, dynamically set the hostname using dynamic metadata:
   *
   * .. code-block:: yaml
   *
   *    tunneling_config:
   *      hostname: "%DYNAMIC_METADATA(tunnel:address)%"
   */
  hostname?:
    | string
    | undefined;
  /**
   * Use the ``POST`` method instead of the ``CONNECT`` method to tunnel the TCP stream.
   * The ``protocol: bytestream`` header is not set for HTTP/2 to comply with the specification.
   *
   * The upstream proxy is expected to interpret the POST payload as raw TCP.
   */
  use_post?:
    | boolean
    | undefined;
  /**
   * Additional request headers to send to the upstream proxy. This is mainly used to
   * trigger the upstream to convert POST requests back to CONNECT requests.
   *
   * Neither ``:``-prefixed pseudo-headers like ``:path`` nor the ``host`` header can be overridden.
   */
  headers_to_add?:
    | HeaderValueOption[]
    | undefined;
  /**
   * Save response headers to the downstream connection's filter state for consumption
   * by network filters. The filter state key is ``envoy.tcp_proxy.propagate_response_headers``.
   */
  propagate_response_headers?:
    | boolean
    | undefined;
  /**
   * The path used with the POST method. The default path is ``/``. If this field is specified and
   * :ref:`use_post field <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.TunnelingConfig.use_post>`
   * is not set to true, the configuration will be rejected.
   */
  post_path?:
    | string
    | undefined;
  /**
   * Save response trailers to the downstream connection's filter state for consumption
   * by network filters. The filter state key is ``envoy.tcp_proxy.propagate_response_trailers``.
   */
  propagate_response_trailers?:
    | boolean
    | undefined;
  /**
   * The configuration of the request ID extension used for generation, validation, and
   * associated tracing operations when tunneling.
   *
   * If this field is set, a request ID is generated using the specified extension. If
   * this field is not set, no request ID is generated.
   *
   * When a request ID is generated, it is also stored in the downstream connection's
   * dynamic metadata under the namespace ``envoy.filters.network.tcp_proxy`` with the key
   * ``tunnel_request_id`` to allow emission from TCP proxy access logs via the
   * ``%DYNAMIC_METADATA(envoy.filters.network.tcp_proxy:tunnel_request_id)%`` formatter.
   * [#extension-category: envoy.request_id]
   */
  request_id_extension?:
    | RequestIDExtension
    | undefined;
  /**
   * The request header name to use for emitting the generated request ID on the tunneling
   * HTTP request.
   *
   * If not specified or set to an empty string, the default header name ``x-request-id`` is
   * used.
   *
   * .. note::
   *   This setting does not alter the internal request ID handling elsewhere in Envoy and
   *   only controls the header emitted on the tunneling request.
   */
  request_id_header?:
    | string
    | undefined;
  /**
   * The dynamic metadata key to use when storing the generated request ID. The metadata is
   * stored under the namespace ``envoy.filters.network.tcp_proxy``.
   *
   * If not specified or set to an empty string, the default key ``tunnel_request_id`` is used.
   * This enables customizing the key used by access log formatters such as
   * ``%DYNAMIC_METADATA(envoy.filters.network.tcp_proxy:<key>)%``.
   */
  request_id_metadata_key?: string | undefined;
}

export interface TcpProxy_OnDemand {
  $type: "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.OnDemand";
  /**
   * Optional configuration for the on-demand cluster discovery service.
   * If not specified, on-demand cluster discovery is disabled. When specified, the filter pauses a request
   * to an unknown cluster and begins a cluster discovery process. When discovery completes (successfully
   * or not), the request is resumed.
   */
  odcds_config?:
    | ConfigSource
    | undefined;
  /**
   * xdstp:// resource locator for on-demand cluster collection.
   * [#not-implemented-hide:]
   */
  resources_locator?:
    | string
    | undefined;
  /**
   * The timeout for on-demand cluster lookup. If the CDS cannot return the required cluster,
   * the downstream request will be closed with the error code detail NO_CLUSTER_FOUND.
   * [#not-implemented-hide:]
   */
  timeout?: Duration | undefined;
}

export interface TcpProxy_TcpAccessLogOptions {
  $type: "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions";
  /**
   * The interval for flushing access logs. By default, the TCP proxy flushes a single access log when the
   * connection is closed. If this field is set, the TCP proxy flushes access logs periodically at the
   * specified interval.
   * The interval must be at least 1ms.
   */
  access_log_flush_interval?:
    | Duration
    | undefined;
  /**
   * If set to true, the access log is flushed when the TCP proxy successfully establishes a
   * connection with the upstream. If the connection fails, the access log is not flushed.
   */
  flush_access_log_on_connected?: boolean | undefined;
}

function createBaseTcpProxy(): TcpProxy {
  return { $type: "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy", cluster_specifier: undefined };
}

export const TcpProxy: MessageFns<TcpProxy, "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy"> = {
  $type: "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy" as const,

  encode(message: TcpProxy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stat_prefix !== undefined && message.stat_prefix !== "") {
      writer.uint32(10).string(message.stat_prefix);
    }
    switch (message.cluster_specifier?.$case) {
      case "cluster":
        writer.uint32(18).string(message.cluster_specifier.cluster);
        break;
      case "weighted_clusters":
        TcpProxy_WeightedCluster.encode(message.cluster_specifier.weighted_clusters, writer.uint32(82).fork()).join();
        break;
    }
    if (message.on_demand !== undefined) {
      TcpProxy_OnDemand.encode(message.on_demand, writer.uint32(114).fork()).join();
    }
    if (message.metadata_match !== undefined) {
      Metadata.encode(message.metadata_match, writer.uint32(74).fork()).join();
    }
    if (message.idle_timeout !== undefined) {
      Duration.encode(message.idle_timeout, writer.uint32(66).fork()).join();
    }
    if (message.downstream_idle_timeout !== undefined) {
      Duration.encode(message.downstream_idle_timeout, writer.uint32(26).fork()).join();
    }
    if (message.upstream_idle_timeout !== undefined) {
      Duration.encode(message.upstream_idle_timeout, writer.uint32(34).fork()).join();
    }
    if (message.access_log !== undefined && message.access_log.length !== 0) {
      for (const v of message.access_log) {
        AccessLog.encode(v!, writer.uint32(42).fork()).join();
      }
    }
    if (message.max_connect_attempts !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.max_connect_attempts! },
        writer.uint32(58).fork(),
      ).join();
    }
    if (message.backoff_options !== undefined) {
      BackoffStrategy.encode(message.backoff_options, writer.uint32(146).fork()).join();
    }
    if (message.hash_policy !== undefined && message.hash_policy.length !== 0) {
      for (const v of message.hash_policy) {
        HashPolicy.encode(v!, writer.uint32(90).fork()).join();
      }
    }
    if (message.tunneling_config !== undefined) {
      TcpProxy_TunnelingConfig.encode(message.tunneling_config, writer.uint32(98).fork()).join();
    }
    if (message.max_downstream_connection_duration !== undefined) {
      Duration.encode(message.max_downstream_connection_duration, writer.uint32(106).fork()).join();
    }
    if (message.max_downstream_connection_duration_jitter_percentage !== undefined) {
      Percent.encode(message.max_downstream_connection_duration_jitter_percentage, writer.uint32(162).fork()).join();
    }
    if (message.access_log_flush_interval !== undefined) {
      Duration.encode(message.access_log_flush_interval, writer.uint32(122).fork()).join();
    }
    if (message.flush_access_log_on_connected !== undefined && message.flush_access_log_on_connected !== false) {
      writer.uint32(128).bool(message.flush_access_log_on_connected);
    }
    if (message.access_log_options !== undefined) {
      TcpProxy_TcpAccessLogOptions.encode(message.access_log_options, writer.uint32(138).fork()).join();
    }
    if (message.proxy_protocol_tlvs !== undefined && message.proxy_protocol_tlvs.length !== 0) {
      for (const v of message.proxy_protocol_tlvs) {
        TlvEntry.encode(v!, writer.uint32(154).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TcpProxy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTcpProxy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stat_prefix = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cluster_specifier = { $case: "cluster", cluster: reader.string() };
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.cluster_specifier = {
            $case: "weighted_clusters",
            weighted_clusters: TcpProxy_WeightedCluster.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.on_demand = TcpProxy_OnDemand.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.metadata_match = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.idle_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.downstream_idle_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.upstream_idle_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          if (message.access_log === undefined) {
            message.access_log = [];
          }
          const el = AccessLog.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.access_log!.push(el);
          }
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.max_connect_attempts = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.backoff_options = BackoffStrategy.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          if (message.hash_policy === undefined) {
            message.hash_policy = [];
          }
          const el = HashPolicy.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.hash_policy!.push(el);
          }
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.tunneling_config = TcpProxy_TunnelingConfig.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.max_downstream_connection_duration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.max_downstream_connection_duration_jitter_percentage = Percent.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.access_log_flush_interval = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.flush_access_log_on_connected = reader.bool();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.access_log_options = TcpProxy_TcpAccessLogOptions.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          if (message.proxy_protocol_tlvs === undefined) {
            message.proxy_protocol_tlvs = [];
          }
          const el = TlvEntry.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.proxy_protocol_tlvs!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TcpProxy {
    return {
      $type: TcpProxy.$type,
      stat_prefix: isSet(object.stat_prefix) ? globalThis.String(object.stat_prefix) : undefined,
      cluster_specifier: isSet(object.cluster)
        ? { $case: "cluster", cluster: globalThis.String(object.cluster) }
        : isSet(object.weighted_clusters)
        ? { $case: "weighted_clusters", weighted_clusters: TcpProxy_WeightedCluster.fromJSON(object.weighted_clusters) }
        : undefined,
      on_demand: isSet(object.on_demand) ? TcpProxy_OnDemand.fromJSON(object.on_demand) : undefined,
      metadata_match: isSet(object.metadata_match) ? Metadata.fromJSON(object.metadata_match) : undefined,
      idle_timeout: isSet(object.idle_timeout) ? Duration.fromJSON(object.idle_timeout) : undefined,
      downstream_idle_timeout: isSet(object.downstream_idle_timeout)
        ? Duration.fromJSON(object.downstream_idle_timeout)
        : undefined,
      upstream_idle_timeout: isSet(object.upstream_idle_timeout)
        ? Duration.fromJSON(object.upstream_idle_timeout)
        : undefined,
      access_log: globalThis.Array.isArray(object?.access_log)
        ? object.access_log.map((e: any) => AccessLog.fromJSON(e))
        : undefined,
      max_connect_attempts: isSet(object.max_connect_attempts) ? Number(object.max_connect_attempts) : undefined,
      backoff_options: isSet(object.backoff_options) ? BackoffStrategy.fromJSON(object.backoff_options) : undefined,
      hash_policy: globalThis.Array.isArray(object?.hash_policy)
        ? object.hash_policy.map((e: any) => HashPolicy.fromJSON(e))
        : undefined,
      tunneling_config: isSet(object.tunneling_config)
        ? TcpProxy_TunnelingConfig.fromJSON(object.tunneling_config)
        : undefined,
      max_downstream_connection_duration: isSet(object.max_downstream_connection_duration)
        ? Duration.fromJSON(object.max_downstream_connection_duration)
        : undefined,
      max_downstream_connection_duration_jitter_percentage:
        isSet(object.max_downstream_connection_duration_jitter_percentage)
          ? Percent.fromJSON(object.max_downstream_connection_duration_jitter_percentage)
          : undefined,
      access_log_flush_interval: isSet(object.access_log_flush_interval)
        ? Duration.fromJSON(object.access_log_flush_interval)
        : undefined,
      flush_access_log_on_connected: isSet(object.flush_access_log_on_connected)
        ? globalThis.Boolean(object.flush_access_log_on_connected)
        : undefined,
      access_log_options: isSet(object.access_log_options)
        ? TcpProxy_TcpAccessLogOptions.fromJSON(object.access_log_options)
        : undefined,
      proxy_protocol_tlvs: globalThis.Array.isArray(object?.proxy_protocol_tlvs)
        ? object.proxy_protocol_tlvs.map((e: any) => TlvEntry.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: TcpProxy): unknown {
    const obj: any = {};
    if (message.stat_prefix !== undefined) {
      obj.stat_prefix = message.stat_prefix;
    }
    if (message.cluster_specifier?.$case === "cluster") {
      obj.cluster = message.cluster_specifier.cluster;
    }
    if (message.cluster_specifier?.$case === "weighted_clusters") {
      obj.weighted_clusters = TcpProxy_WeightedCluster.toJSON(message.cluster_specifier.weighted_clusters);
    }
    if (message.on_demand !== undefined) {
      obj.on_demand = TcpProxy_OnDemand.toJSON(message.on_demand);
    }
    if (message.metadata_match !== undefined) {
      obj.metadata_match = Metadata.toJSON(message.metadata_match);
    }
    if (message.idle_timeout !== undefined) {
      obj.idle_timeout = Duration.toJSON(message.idle_timeout);
    }
    if (message.downstream_idle_timeout !== undefined) {
      obj.downstream_idle_timeout = Duration.toJSON(message.downstream_idle_timeout);
    }
    if (message.upstream_idle_timeout !== undefined) {
      obj.upstream_idle_timeout = Duration.toJSON(message.upstream_idle_timeout);
    }
    if (message.access_log?.length) {
      obj.access_log = message.access_log.map((e) => AccessLog.toJSON(e));
    }
    if (message.max_connect_attempts !== undefined) {
      obj.max_connect_attempts = message.max_connect_attempts;
    }
    if (message.backoff_options !== undefined) {
      obj.backoff_options = BackoffStrategy.toJSON(message.backoff_options);
    }
    if (message.hash_policy?.length) {
      obj.hash_policy = message.hash_policy.map((e) => HashPolicy.toJSON(e));
    }
    if (message.tunneling_config !== undefined) {
      obj.tunneling_config = TcpProxy_TunnelingConfig.toJSON(message.tunneling_config);
    }
    if (message.max_downstream_connection_duration !== undefined) {
      obj.max_downstream_connection_duration = Duration.toJSON(message.max_downstream_connection_duration);
    }
    if (message.max_downstream_connection_duration_jitter_percentage !== undefined) {
      obj.max_downstream_connection_duration_jitter_percentage = Percent.toJSON(
        message.max_downstream_connection_duration_jitter_percentage,
      );
    }
    if (message.access_log_flush_interval !== undefined) {
      obj.access_log_flush_interval = Duration.toJSON(message.access_log_flush_interval);
    }
    if (message.flush_access_log_on_connected !== undefined) {
      obj.flush_access_log_on_connected = message.flush_access_log_on_connected;
    }
    if (message.access_log_options !== undefined) {
      obj.access_log_options = TcpProxy_TcpAccessLogOptions.toJSON(message.access_log_options);
    }
    if (message.proxy_protocol_tlvs?.length) {
      obj.proxy_protocol_tlvs = message.proxy_protocol_tlvs.map((e) => TlvEntry.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TcpProxy>, I>>(base?: I): TcpProxy {
    return TcpProxy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TcpProxy>, I>>(object: I): TcpProxy {
    const message = createBaseTcpProxy();
    message.stat_prefix = object.stat_prefix ?? undefined;
    if (
      object.cluster_specifier?.$case === "cluster" &&
      object.cluster_specifier?.cluster !== undefined &&
      object.cluster_specifier?.cluster !== null
    ) {
      message.cluster_specifier = { $case: "cluster", cluster: object.cluster_specifier.cluster };
    }
    if (
      object.cluster_specifier?.$case === "weighted_clusters" &&
      object.cluster_specifier?.weighted_clusters !== undefined &&
      object.cluster_specifier?.weighted_clusters !== null
    ) {
      message.cluster_specifier = {
        $case: "weighted_clusters",
        weighted_clusters: TcpProxy_WeightedCluster.fromPartial(object.cluster_specifier.weighted_clusters),
      };
    }
    message.on_demand = (object.on_demand !== undefined && object.on_demand !== null)
      ? TcpProxy_OnDemand.fromPartial(object.on_demand)
      : undefined;
    message.metadata_match = (object.metadata_match !== undefined && object.metadata_match !== null)
      ? Metadata.fromPartial(object.metadata_match)
      : undefined;
    message.idle_timeout = (object.idle_timeout !== undefined && object.idle_timeout !== null)
      ? Duration.fromPartial(object.idle_timeout)
      : undefined;
    message.downstream_idle_timeout =
      (object.downstream_idle_timeout !== undefined && object.downstream_idle_timeout !== null)
        ? Duration.fromPartial(object.downstream_idle_timeout)
        : undefined;
    message.upstream_idle_timeout =
      (object.upstream_idle_timeout !== undefined && object.upstream_idle_timeout !== null)
        ? Duration.fromPartial(object.upstream_idle_timeout)
        : undefined;
    message.access_log = object.access_log?.map((e) => AccessLog.fromPartial(e)) || undefined;
    message.max_connect_attempts = object.max_connect_attempts ?? undefined;
    message.backoff_options = (object.backoff_options !== undefined && object.backoff_options !== null)
      ? BackoffStrategy.fromPartial(object.backoff_options)
      : undefined;
    message.hash_policy = object.hash_policy?.map((e) => HashPolicy.fromPartial(e)) || undefined;
    message.tunneling_config = (object.tunneling_config !== undefined && object.tunneling_config !== null)
      ? TcpProxy_TunnelingConfig.fromPartial(object.tunneling_config)
      : undefined;
    message.max_downstream_connection_duration =
      (object.max_downstream_connection_duration !== undefined && object.max_downstream_connection_duration !== null)
        ? Duration.fromPartial(object.max_downstream_connection_duration)
        : undefined;
    message.max_downstream_connection_duration_jitter_percentage =
      (object.max_downstream_connection_duration_jitter_percentage !== undefined &&
          object.max_downstream_connection_duration_jitter_percentage !== null)
        ? Percent.fromPartial(object.max_downstream_connection_duration_jitter_percentage)
        : undefined;
    message.access_log_flush_interval =
      (object.access_log_flush_interval !== undefined && object.access_log_flush_interval !== null)
        ? Duration.fromPartial(object.access_log_flush_interval)
        : undefined;
    message.flush_access_log_on_connected = object.flush_access_log_on_connected ?? undefined;
    message.access_log_options = (object.access_log_options !== undefined && object.access_log_options !== null)
      ? TcpProxy_TcpAccessLogOptions.fromPartial(object.access_log_options)
      : undefined;
    message.proxy_protocol_tlvs = object.proxy_protocol_tlvs?.map((e) => TlvEntry.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(TcpProxy.$type, TcpProxy);

function createBaseTcpProxy_WeightedCluster(): TcpProxy_WeightedCluster {
  return { $type: "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.WeightedCluster" };
}

export const TcpProxy_WeightedCluster: MessageFns<
  TcpProxy_WeightedCluster,
  "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.WeightedCluster"
> = {
  $type: "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.WeightedCluster" as const,

  encode(message: TcpProxy_WeightedCluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clusters !== undefined && message.clusters.length !== 0) {
      for (const v of message.clusters) {
        TcpProxy_WeightedCluster_ClusterWeight.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TcpProxy_WeightedCluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTcpProxy_WeightedCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.clusters === undefined) {
            message.clusters = [];
          }
          const el = TcpProxy_WeightedCluster_ClusterWeight.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.clusters!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TcpProxy_WeightedCluster {
    return {
      $type: TcpProxy_WeightedCluster.$type,
      clusters: globalThis.Array.isArray(object?.clusters)
        ? object.clusters.map((e: any) => TcpProxy_WeightedCluster_ClusterWeight.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: TcpProxy_WeightedCluster): unknown {
    const obj: any = {};
    if (message.clusters?.length) {
      obj.clusters = message.clusters.map((e) => TcpProxy_WeightedCluster_ClusterWeight.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TcpProxy_WeightedCluster>, I>>(base?: I): TcpProxy_WeightedCluster {
    return TcpProxy_WeightedCluster.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TcpProxy_WeightedCluster>, I>>(object: I): TcpProxy_WeightedCluster {
    const message = createBaseTcpProxy_WeightedCluster();
    message.clusters = object.clusters?.map((e) => TcpProxy_WeightedCluster_ClusterWeight.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(TcpProxy_WeightedCluster.$type, TcpProxy_WeightedCluster);

function createBaseTcpProxy_WeightedCluster_ClusterWeight(): TcpProxy_WeightedCluster_ClusterWeight {
  return { $type: "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.WeightedCluster.ClusterWeight" };
}

export const TcpProxy_WeightedCluster_ClusterWeight: MessageFns<
  TcpProxy_WeightedCluster_ClusterWeight,
  "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.WeightedCluster.ClusterWeight"
> = {
  $type: "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.WeightedCluster.ClusterWeight" as const,

  encode(message: TcpProxy_WeightedCluster_ClusterWeight, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.weight !== undefined && message.weight !== 0) {
      writer.uint32(16).uint32(message.weight);
    }
    if (message.metadata_match !== undefined) {
      Metadata.encode(message.metadata_match, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TcpProxy_WeightedCluster_ClusterWeight {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTcpProxy_WeightedCluster_ClusterWeight();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.weight = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata_match = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TcpProxy_WeightedCluster_ClusterWeight {
    return {
      $type: TcpProxy_WeightedCluster_ClusterWeight.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      weight: isSet(object.weight) ? globalThis.Number(object.weight) : undefined,
      metadata_match: isSet(object.metadata_match) ? Metadata.fromJSON(object.metadata_match) : undefined,
    };
  },

  toJSON(message: TcpProxy_WeightedCluster_ClusterWeight): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.weight !== undefined) {
      obj.weight = Math.round(message.weight);
    }
    if (message.metadata_match !== undefined) {
      obj.metadata_match = Metadata.toJSON(message.metadata_match);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TcpProxy_WeightedCluster_ClusterWeight>, I>>(
    base?: I,
  ): TcpProxy_WeightedCluster_ClusterWeight {
    return TcpProxy_WeightedCluster_ClusterWeight.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TcpProxy_WeightedCluster_ClusterWeight>, I>>(
    object: I,
  ): TcpProxy_WeightedCluster_ClusterWeight {
    const message = createBaseTcpProxy_WeightedCluster_ClusterWeight();
    message.name = object.name ?? undefined;
    message.weight = object.weight ?? undefined;
    message.metadata_match = (object.metadata_match !== undefined && object.metadata_match !== null)
      ? Metadata.fromPartial(object.metadata_match)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(TcpProxy_WeightedCluster_ClusterWeight.$type, TcpProxy_WeightedCluster_ClusterWeight);

function createBaseTcpProxy_TunnelingConfig(): TcpProxy_TunnelingConfig {
  return { $type: "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.TunnelingConfig" };
}

export const TcpProxy_TunnelingConfig: MessageFns<
  TcpProxy_TunnelingConfig,
  "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.TunnelingConfig"
> = {
  $type: "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.TunnelingConfig" as const,

  encode(message: TcpProxy_TunnelingConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hostname !== undefined && message.hostname !== "") {
      writer.uint32(10).string(message.hostname);
    }
    if (message.use_post !== undefined && message.use_post !== false) {
      writer.uint32(16).bool(message.use_post);
    }
    if (message.headers_to_add !== undefined && message.headers_to_add.length !== 0) {
      for (const v of message.headers_to_add) {
        HeaderValueOption.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    if (message.propagate_response_headers !== undefined && message.propagate_response_headers !== false) {
      writer.uint32(32).bool(message.propagate_response_headers);
    }
    if (message.post_path !== undefined && message.post_path !== "") {
      writer.uint32(42).string(message.post_path);
    }
    if (message.propagate_response_trailers !== undefined && message.propagate_response_trailers !== false) {
      writer.uint32(48).bool(message.propagate_response_trailers);
    }
    if (message.request_id_extension !== undefined) {
      RequestIDExtension.encode(message.request_id_extension, writer.uint32(58).fork()).join();
    }
    if (message.request_id_header !== undefined && message.request_id_header !== "") {
      writer.uint32(66).string(message.request_id_header);
    }
    if (message.request_id_metadata_key !== undefined && message.request_id_metadata_key !== "") {
      writer.uint32(74).string(message.request_id_metadata_key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TcpProxy_TunnelingConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTcpProxy_TunnelingConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hostname = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.use_post = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.headers_to_add === undefined) {
            message.headers_to_add = [];
          }
          const el = HeaderValueOption.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.headers_to_add!.push(el);
          }
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.propagate_response_headers = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.post_path = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.propagate_response_trailers = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.request_id_extension = RequestIDExtension.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.request_id_header = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.request_id_metadata_key = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TcpProxy_TunnelingConfig {
    return {
      $type: TcpProxy_TunnelingConfig.$type,
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : undefined,
      use_post: isSet(object.use_post) ? globalThis.Boolean(object.use_post) : undefined,
      headers_to_add: globalThis.Array.isArray(object?.headers_to_add)
        ? object.headers_to_add.map((e: any) => HeaderValueOption.fromJSON(e))
        : undefined,
      propagate_response_headers: isSet(object.propagate_response_headers)
        ? globalThis.Boolean(object.propagate_response_headers)
        : undefined,
      post_path: isSet(object.post_path) ? globalThis.String(object.post_path) : undefined,
      propagate_response_trailers: isSet(object.propagate_response_trailers)
        ? globalThis.Boolean(object.propagate_response_trailers)
        : undefined,
      request_id_extension: isSet(object.request_id_extension)
        ? RequestIDExtension.fromJSON(object.request_id_extension)
        : undefined,
      request_id_header: isSet(object.request_id_header) ? globalThis.String(object.request_id_header) : undefined,
      request_id_metadata_key: isSet(object.request_id_metadata_key)
        ? globalThis.String(object.request_id_metadata_key)
        : undefined,
    };
  },

  toJSON(message: TcpProxy_TunnelingConfig): unknown {
    const obj: any = {};
    if (message.hostname !== undefined) {
      obj.hostname = message.hostname;
    }
    if (message.use_post !== undefined) {
      obj.use_post = message.use_post;
    }
    if (message.headers_to_add?.length) {
      obj.headers_to_add = message.headers_to_add.map((e) => HeaderValueOption.toJSON(e));
    }
    if (message.propagate_response_headers !== undefined) {
      obj.propagate_response_headers = message.propagate_response_headers;
    }
    if (message.post_path !== undefined) {
      obj.post_path = message.post_path;
    }
    if (message.propagate_response_trailers !== undefined) {
      obj.propagate_response_trailers = message.propagate_response_trailers;
    }
    if (message.request_id_extension !== undefined) {
      obj.request_id_extension = RequestIDExtension.toJSON(message.request_id_extension);
    }
    if (message.request_id_header !== undefined) {
      obj.request_id_header = message.request_id_header;
    }
    if (message.request_id_metadata_key !== undefined) {
      obj.request_id_metadata_key = message.request_id_metadata_key;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TcpProxy_TunnelingConfig>, I>>(base?: I): TcpProxy_TunnelingConfig {
    return TcpProxy_TunnelingConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TcpProxy_TunnelingConfig>, I>>(object: I): TcpProxy_TunnelingConfig {
    const message = createBaseTcpProxy_TunnelingConfig();
    message.hostname = object.hostname ?? undefined;
    message.use_post = object.use_post ?? undefined;
    message.headers_to_add = object.headers_to_add?.map((e) => HeaderValueOption.fromPartial(e)) || undefined;
    message.propagate_response_headers = object.propagate_response_headers ?? undefined;
    message.post_path = object.post_path ?? undefined;
    message.propagate_response_trailers = object.propagate_response_trailers ?? undefined;
    message.request_id_extension = (object.request_id_extension !== undefined && object.request_id_extension !== null)
      ? RequestIDExtension.fromPartial(object.request_id_extension)
      : undefined;
    message.request_id_header = object.request_id_header ?? undefined;
    message.request_id_metadata_key = object.request_id_metadata_key ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(TcpProxy_TunnelingConfig.$type, TcpProxy_TunnelingConfig);

function createBaseTcpProxy_OnDemand(): TcpProxy_OnDemand {
  return { $type: "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.OnDemand" };
}

export const TcpProxy_OnDemand: MessageFns<
  TcpProxy_OnDemand,
  "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.OnDemand"
> = {
  $type: "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.OnDemand" as const,

  encode(message: TcpProxy_OnDemand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.odcds_config !== undefined) {
      ConfigSource.encode(message.odcds_config, writer.uint32(10).fork()).join();
    }
    if (message.resources_locator !== undefined && message.resources_locator !== "") {
      writer.uint32(18).string(message.resources_locator);
    }
    if (message.timeout !== undefined) {
      Duration.encode(message.timeout, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TcpProxy_OnDemand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTcpProxy_OnDemand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.odcds_config = ConfigSource.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.resources_locator = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TcpProxy_OnDemand {
    return {
      $type: TcpProxy_OnDemand.$type,
      odcds_config: isSet(object.odcds_config) ? ConfigSource.fromJSON(object.odcds_config) : undefined,
      resources_locator: isSet(object.resources_locator) ? globalThis.String(object.resources_locator) : undefined,
      timeout: isSet(object.timeout) ? Duration.fromJSON(object.timeout) : undefined,
    };
  },

  toJSON(message: TcpProxy_OnDemand): unknown {
    const obj: any = {};
    if (message.odcds_config !== undefined) {
      obj.odcds_config = ConfigSource.toJSON(message.odcds_config);
    }
    if (message.resources_locator !== undefined) {
      obj.resources_locator = message.resources_locator;
    }
    if (message.timeout !== undefined) {
      obj.timeout = Duration.toJSON(message.timeout);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TcpProxy_OnDemand>, I>>(base?: I): TcpProxy_OnDemand {
    return TcpProxy_OnDemand.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TcpProxy_OnDemand>, I>>(object: I): TcpProxy_OnDemand {
    const message = createBaseTcpProxy_OnDemand();
    message.odcds_config = (object.odcds_config !== undefined && object.odcds_config !== null)
      ? ConfigSource.fromPartial(object.odcds_config)
      : undefined;
    message.resources_locator = object.resources_locator ?? undefined;
    message.timeout = (object.timeout !== undefined && object.timeout !== null)
      ? Duration.fromPartial(object.timeout)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(TcpProxy_OnDemand.$type, TcpProxy_OnDemand);

function createBaseTcpProxy_TcpAccessLogOptions(): TcpProxy_TcpAccessLogOptions {
  return { $type: "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions" };
}

export const TcpProxy_TcpAccessLogOptions: MessageFns<
  TcpProxy_TcpAccessLogOptions,
  "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions"
> = {
  $type: "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions" as const,

  encode(message: TcpProxy_TcpAccessLogOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.access_log_flush_interval !== undefined) {
      Duration.encode(message.access_log_flush_interval, writer.uint32(10).fork()).join();
    }
    if (message.flush_access_log_on_connected !== undefined && message.flush_access_log_on_connected !== false) {
      writer.uint32(16).bool(message.flush_access_log_on_connected);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TcpProxy_TcpAccessLogOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTcpProxy_TcpAccessLogOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.access_log_flush_interval = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.flush_access_log_on_connected = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TcpProxy_TcpAccessLogOptions {
    return {
      $type: TcpProxy_TcpAccessLogOptions.$type,
      access_log_flush_interval: isSet(object.access_log_flush_interval)
        ? Duration.fromJSON(object.access_log_flush_interval)
        : undefined,
      flush_access_log_on_connected: isSet(object.flush_access_log_on_connected)
        ? globalThis.Boolean(object.flush_access_log_on_connected)
        : undefined,
    };
  },

  toJSON(message: TcpProxy_TcpAccessLogOptions): unknown {
    const obj: any = {};
    if (message.access_log_flush_interval !== undefined) {
      obj.access_log_flush_interval = Duration.toJSON(message.access_log_flush_interval);
    }
    if (message.flush_access_log_on_connected !== undefined) {
      obj.flush_access_log_on_connected = message.flush_access_log_on_connected;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TcpProxy_TcpAccessLogOptions>, I>>(base?: I): TcpProxy_TcpAccessLogOptions {
    return TcpProxy_TcpAccessLogOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TcpProxy_TcpAccessLogOptions>, I>>(object: I): TcpProxy_TcpAccessLogOptions {
    const message = createBaseTcpProxy_TcpAccessLogOptions();
    message.access_log_flush_interval =
      (object.access_log_flush_interval !== undefined && object.access_log_flush_interval !== null)
        ? Duration.fromPartial(object.access_log_flush_interval)
        : undefined;
    message.flush_access_log_on_connected = object.flush_access_log_on_connected ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(TcpProxy_TcpAccessLogOptions.$type, TcpProxy_TcpAccessLogOptions);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
