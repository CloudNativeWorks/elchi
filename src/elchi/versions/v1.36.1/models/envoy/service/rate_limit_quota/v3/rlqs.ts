// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/service/rate_limit_quota/v3/rlqs.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Observable } from "rxjs";
import { map } from "rxjs/operators";
import { Duration } from "../../../../google/protobuf/duration";
import { messageTypeRegistry } from "../../../../typeRegistry";
import { RateLimitStrategy } from "../../../type/v3/ratelimit_strategy";

export const protobufPackage = "envoy.service.rate_limit_quota.v3";

export interface RateLimitQuotaUsageReports {
  $type: "envoy.service.rate_limit_quota.v3.RateLimitQuotaUsageReports";
  /**
   * All quota requests must specify the domain. This enables sharing the quota
   * server between different applications without fear of overlap.
   * E.g., "envoy".
   *
   * Should only be provided in the first report, all subsequent messages on the same
   * stream are considered to be in the same domain. In case the domain needs to be
   * changes, close the stream, and reopen a new one with the different domain.
   */
  domain?:
    | string
    | undefined;
  /**
   * A list of quota usage reports. The list is processed by the RLQS server in the same order
   * it's provided by the client.
   */
  bucket_quota_usages?: RateLimitQuotaUsageReports_BucketQuotaUsage[] | undefined;
}

/**
 * The usage report for a bucket.
 *
 * .. note::
 *   Note that the first report sent for a ``BucketId`` indicates to the RLQS server that
 *   the RLQS client is subscribing for the future assignments for this ``BucketId``.
 */
export interface RateLimitQuotaUsageReports_BucketQuotaUsage {
  $type: "envoy.service.rate_limit_quota.v3.RateLimitQuotaUsageReports.BucketQuotaUsage";
  /** ``BucketId`` for which request quota usage is reported. */
  bucket_id?:
    | BucketId
    | undefined;
  /** Time elapsed since the last report. */
  time_elapsed?:
    | Duration
    | undefined;
  /** Requests the data plane has allowed through. */
  num_requests_allowed?:
    | number
    | undefined;
  /** Requests throttled. */
  num_requests_denied?: number | undefined;
}

export interface RateLimitQuotaResponse {
  $type: "envoy.service.rate_limit_quota.v3.RateLimitQuotaResponse";
  /**
   * An ordered list of actions to be applied to the buckets. The actions are applied in the
   * given order, from top to bottom.
   */
  bucket_action?: RateLimitQuotaResponse_BucketAction[] | undefined;
}

/**
 * Commands the data plane to apply one of the actions to the bucket with the
 * :ref:`bucket_id <envoy_v3_api_field_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.bucket_id>`.
 */
export interface RateLimitQuotaResponse_BucketAction {
  $type: "envoy.service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction";
  /** ``BucketId`` for which request the action is applied. */
  bucket_id?: BucketId | undefined;
  bucket_action?:
    | //
    /**
     * Apply the quota assignment to the bucket.
     *
     * Commands the data plane to apply a rate limiting strategy to the bucket.
     * The process of applying and expiring the rate limiting strategy is detailed in the
     * :ref:`QuotaAssignmentAction
     * <envoy_v3_api_msg_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.QuotaAssignmentAction>`
     * message.
     */
    {
      $case: "quota_assignment_action";
      quota_assignment_action: RateLimitQuotaResponse_BucketAction_QuotaAssignmentAction;
    }
    | //
    /**
     * Abandon the bucket.
     *
     * Commands the data plane to abandon the bucket.
     * The process of abandoning the bucket is described in the :ref:`AbandonAction
     * <envoy_v3_api_msg_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.AbandonAction>`
     * message.
     */
    { $case: "abandon_action"; abandon_action: RateLimitQuotaResponse_BucketAction_AbandonAction }
    | undefined;
}

/**
 * Quota assignment for the bucket. Configures the rate limiting strategy and the duration
 * for the given :ref:`bucket_id
 * <envoy_v3_api_field_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.bucket_id>`.
 *
 * **Applying the first assignment to the bucket**
 *
 * Once the data plane receives the ``QuotaAssignmentAction``, it must send the current usage
 * report for the bucket, and start rate limiting requests matched into the bucket
 * using the strategy configured in the :ref:`rate_limit_strategy
 * <envoy_v3_api_field_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.QuotaAssignmentAction.rate_limit_strategy>`
 * field. The assignment becomes bucket's ``active`` assignment.
 *
 * **Expiring the assignment**
 *
 * The duration of the assignment defined in the :ref:`assignment_time_to_live
 * <envoy_v3_api_field_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.QuotaAssignmentAction.assignment_time_to_live>`
 * field. When the duration runs off, the assignment is ``expired``, and no longer ``active``.
 * The data plane should stop applying the rate limiting strategy to the bucket, and transition
 * the bucket to the "expired assignment" state. This activates the behavior configured in the
 * :ref:`expired_assignment_behavior <envoy_v3_api_field_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.expired_assignment_behavior>`
 * field.
 *
 * **Replacing the assignment**
 *
 * * If the rate limiting strategy is different from bucket's ``active`` assignment, or
 *   the current bucket assignment is ``expired``, the data plane must immediately
 *   end the current assignment, report the bucket usage, and apply the new assignment.
 *   The new assignment becomes bucket's ``active`` assignment.
 * * If the rate limiting strategy is the same as the bucket's ``active`` (not ``expired``)
 *   assignment, the data plane should extend the duration of the ``active`` assignment
 *   for the duration of the new assignment provided in the :ref:`assignment_time_to_live
 *   <envoy_v3_api_field_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.QuotaAssignmentAction.assignment_time_to_live>`
 *   field. The ``active`` assignment is considered unchanged.
 */
export interface RateLimitQuotaResponse_BucketAction_QuotaAssignmentAction {
  $type: "envoy.service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.QuotaAssignmentAction";
  /**
   * A duration after which the assignment is be considered ``expired``. The process of the
   * expiration is described :ref:`above
   * <envoy_v3_api_msg_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.QuotaAssignmentAction>`.
   *
   * * If unset, the assignment has no expiration date.
   * * If set to ``0``, the assignment expires immediately, forcing the client into the
   *   :ref:`"expired assignment"
   *   <envoy_v3_api_field_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.ExpiredAssignmentBehavior.expired_assignment_behavior_timeout>`
   *   state. This may be used by the RLQS server in cases when it needs clients to proactively
   *   fall back to the pre-configured :ref:`ExpiredAssignmentBehavior
   *   <envoy_v3_api_msg_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.ExpiredAssignmentBehavior>`,
   *   f.e. before the server going into restart.
   *
   * .. attention::
   *   Note that :ref:`expiring
   *   <envoy_v3_api_msg_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.QuotaAssignmentAction>`
   *   the assignment is not the same as :ref:`abandoning
   *   <envoy_v3_api_msg_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.AbandonAction>`
   *   the assignment. While expiring the assignment just transitions the bucket to
   *   the "expired assignment" state; abandoning the assignment completely erases
   *   the bucket from the data plane memory, and stops the usage reports.
   */
  assignment_time_to_live?:
    | Duration
    | undefined;
  /**
   * Configures the local rate limiter for the request matched to the bucket.
   * If not set, allow all requests.
   */
  rate_limit_strategy?: RateLimitStrategy | undefined;
}

/**
 * Abandon action for the bucket. Indicates that the RLQS server will no longer be
 * sending updates for the given :ref:`bucket_id
 * <envoy_v3_api_field_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.bucket_id>`.
 *
 * If no requests are reported for a bucket, after some time the server considers the bucket
 * inactive. The server stops tracking the bucket, and instructs the the data plane to abandon
 * the bucket via this message.
 *
 * **Abandoning the assignment**
 *
 * The data plane is to erase the bucket (including its usage data) from the memory.
 * It should stop tracking the bucket, and stop reporting its usage. This effectively resets
 * the data plane to the state prior to matching the first request into the bucket.
 *
 * **Restarting the subscription**
 *
 * If a new request is matched into a bucket previously abandoned, the data plane must behave
 * as if it has never tracked the bucket, and it's the first request matched into it:
 *
 * 1. The process of :ref:`subscription and reporting
 *    <envoy_v3_api_field_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.reporting_interval>`
 *    starts from the beginning.
 *
 * 2. The bucket transitions to the :ref:`"no assignment"
 *    <envoy_v3_api_field_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.no_assignment_behavior>`
 *    state.
 *
 * 3. Once the new assignment is received, it's applied per
 *    "Applying the first assignment to the bucket" section of the :ref:`QuotaAssignmentAction
 *    <envoy_v3_api_msg_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.QuotaAssignmentAction>`.
 */
export interface RateLimitQuotaResponse_BucketAction_AbandonAction {
  $type: "envoy.service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.AbandonAction";
}

/**
 * The identifier for the bucket. Used to match the bucket between the control plane (RLQS server),
 * and the data plane (RLQS client), f.e.:
 *
 * * the data plane sends a usage report for requests matched into the bucket with ``BucketId``
 *   to the control plane
 * * the control plane sends an assignment for the bucket with ``BucketId`` to the data plane
 *   Bucket ID.
 *
 * Example:
 *
 * .. validated-code-block:: yaml
 *   :type-name: envoy.service.rate_limit_quota.v3.BucketId
 *
 *   bucket:
 *     name: my_bucket
 *     env: staging
 *
 * .. note::
 *   The order of ``BucketId`` keys do not matter. Buckets ``{ a: 'A', b: 'B' }`` and
 *   ``{ b: 'B', a: 'A' }`` are identical.
 */
export interface BucketId {
  $type: "envoy.service.rate_limit_quota.v3.BucketId";
  bucket?: Map<string, string> | undefined;
}

export interface BucketId_BucketEntry {
  $type: "envoy.service.rate_limit_quota.v3.BucketId.BucketEntry";
  key: string;
  value: string;
}

function createBaseRateLimitQuotaUsageReports(): RateLimitQuotaUsageReports {
  return { $type: "envoy.service.rate_limit_quota.v3.RateLimitQuotaUsageReports" };
}

export const RateLimitQuotaUsageReports: MessageFns<
  RateLimitQuotaUsageReports,
  "envoy.service.rate_limit_quota.v3.RateLimitQuotaUsageReports"
> = {
  $type: "envoy.service.rate_limit_quota.v3.RateLimitQuotaUsageReports" as const,

  encode(message: RateLimitQuotaUsageReports, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.domain !== undefined && message.domain !== "") {
      writer.uint32(10).string(message.domain);
    }
    if (message.bucket_quota_usages !== undefined && message.bucket_quota_usages.length !== 0) {
      for (const v of message.bucket_quota_usages) {
        RateLimitQuotaUsageReports_BucketQuotaUsage.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimitQuotaUsageReports {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimitQuotaUsageReports();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.domain = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.bucket_quota_usages === undefined) {
            message.bucket_quota_usages = [];
          }
          const el = RateLimitQuotaUsageReports_BucketQuotaUsage.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.bucket_quota_usages!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimitQuotaUsageReports {
    return {
      $type: RateLimitQuotaUsageReports.$type,
      domain: isSet(object.domain) ? globalThis.String(object.domain) : undefined,
      bucket_quota_usages: globalThis.Array.isArray(object?.bucket_quota_usages)
        ? object.bucket_quota_usages.map((e: any) => RateLimitQuotaUsageReports_BucketQuotaUsage.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: RateLimitQuotaUsageReports): unknown {
    const obj: any = {};
    if (message.domain !== undefined) {
      obj.domain = message.domain;
    }
    if (message.bucket_quota_usages?.length) {
      obj.bucket_quota_usages = message.bucket_quota_usages.map((e) =>
        RateLimitQuotaUsageReports_BucketQuotaUsage.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimitQuotaUsageReports>, I>>(base?: I): RateLimitQuotaUsageReports {
    return RateLimitQuotaUsageReports.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimitQuotaUsageReports>, I>>(object: I): RateLimitQuotaUsageReports {
    const message = createBaseRateLimitQuotaUsageReports();
    message.domain = object.domain ?? undefined;
    message.bucket_quota_usages =
      object.bucket_quota_usages?.map((e) => RateLimitQuotaUsageReports_BucketQuotaUsage.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(RateLimitQuotaUsageReports.$type, RateLimitQuotaUsageReports);

function createBaseRateLimitQuotaUsageReports_BucketQuotaUsage(): RateLimitQuotaUsageReports_BucketQuotaUsage {
  return { $type: "envoy.service.rate_limit_quota.v3.RateLimitQuotaUsageReports.BucketQuotaUsage" };
}

export const RateLimitQuotaUsageReports_BucketQuotaUsage: MessageFns<
  RateLimitQuotaUsageReports_BucketQuotaUsage,
  "envoy.service.rate_limit_quota.v3.RateLimitQuotaUsageReports.BucketQuotaUsage"
> = {
  $type: "envoy.service.rate_limit_quota.v3.RateLimitQuotaUsageReports.BucketQuotaUsage" as const,

  encode(
    message: RateLimitQuotaUsageReports_BucketQuotaUsage,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.bucket_id !== undefined) {
      BucketId.encode(message.bucket_id, writer.uint32(10).fork()).join();
    }
    if (message.time_elapsed !== undefined) {
      Duration.encode(message.time_elapsed, writer.uint32(18).fork()).join();
    }
    if (message.num_requests_allowed !== undefined && message.num_requests_allowed !== 0) {
      writer.uint32(24).uint64(message.num_requests_allowed);
    }
    if (message.num_requests_denied !== undefined && message.num_requests_denied !== 0) {
      writer.uint32(32).uint64(message.num_requests_denied);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimitQuotaUsageReports_BucketQuotaUsage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimitQuotaUsageReports_BucketQuotaUsage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bucket_id = BucketId.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.time_elapsed = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.num_requests_allowed = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.num_requests_denied = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimitQuotaUsageReports_BucketQuotaUsage {
    return {
      $type: RateLimitQuotaUsageReports_BucketQuotaUsage.$type,
      bucket_id: isSet(object.bucket_id) ? BucketId.fromJSON(object.bucket_id) : undefined,
      time_elapsed: isSet(object.time_elapsed) ? Duration.fromJSON(object.time_elapsed) : undefined,
      num_requests_allowed: isSet(object.num_requests_allowed)
        ? globalThis.Number(object.num_requests_allowed)
        : undefined,
      num_requests_denied: isSet(object.num_requests_denied)
        ? globalThis.Number(object.num_requests_denied)
        : undefined,
    };
  },

  toJSON(message: RateLimitQuotaUsageReports_BucketQuotaUsage): unknown {
    const obj: any = {};
    if (message.bucket_id !== undefined) {
      obj.bucket_id = BucketId.toJSON(message.bucket_id);
    }
    if (message.time_elapsed !== undefined) {
      obj.time_elapsed = Duration.toJSON(message.time_elapsed);
    }
    if (message.num_requests_allowed !== undefined) {
      obj.num_requests_allowed = Math.round(message.num_requests_allowed);
    }
    if (message.num_requests_denied !== undefined) {
      obj.num_requests_denied = Math.round(message.num_requests_denied);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimitQuotaUsageReports_BucketQuotaUsage>, I>>(
    base?: I,
  ): RateLimitQuotaUsageReports_BucketQuotaUsage {
    return RateLimitQuotaUsageReports_BucketQuotaUsage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimitQuotaUsageReports_BucketQuotaUsage>, I>>(
    object: I,
  ): RateLimitQuotaUsageReports_BucketQuotaUsage {
    const message = createBaseRateLimitQuotaUsageReports_BucketQuotaUsage();
    message.bucket_id = (object.bucket_id !== undefined && object.bucket_id !== null)
      ? BucketId.fromPartial(object.bucket_id)
      : undefined;
    message.time_elapsed = (object.time_elapsed !== undefined && object.time_elapsed !== null)
      ? Duration.fromPartial(object.time_elapsed)
      : undefined;
    message.num_requests_allowed = object.num_requests_allowed ?? undefined;
    message.num_requests_denied = object.num_requests_denied ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RateLimitQuotaUsageReports_BucketQuotaUsage.$type, RateLimitQuotaUsageReports_BucketQuotaUsage);

function createBaseRateLimitQuotaResponse(): RateLimitQuotaResponse {
  return { $type: "envoy.service.rate_limit_quota.v3.RateLimitQuotaResponse" };
}

export const RateLimitQuotaResponse: MessageFns<
  RateLimitQuotaResponse,
  "envoy.service.rate_limit_quota.v3.RateLimitQuotaResponse"
> = {
  $type: "envoy.service.rate_limit_quota.v3.RateLimitQuotaResponse" as const,

  encode(message: RateLimitQuotaResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bucket_action !== undefined && message.bucket_action.length !== 0) {
      for (const v of message.bucket_action) {
        RateLimitQuotaResponse_BucketAction.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimitQuotaResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimitQuotaResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.bucket_action === undefined) {
            message.bucket_action = [];
          }
          const el = RateLimitQuotaResponse_BucketAction.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.bucket_action!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimitQuotaResponse {
    return {
      $type: RateLimitQuotaResponse.$type,
      bucket_action: globalThis.Array.isArray(object?.bucket_action)
        ? object.bucket_action.map((e: any) => RateLimitQuotaResponse_BucketAction.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: RateLimitQuotaResponse): unknown {
    const obj: any = {};
    if (message.bucket_action?.length) {
      obj.bucket_action = message.bucket_action.map((e) => RateLimitQuotaResponse_BucketAction.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimitQuotaResponse>, I>>(base?: I): RateLimitQuotaResponse {
    return RateLimitQuotaResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimitQuotaResponse>, I>>(object: I): RateLimitQuotaResponse {
    const message = createBaseRateLimitQuotaResponse();
    message.bucket_action = object.bucket_action?.map((e) => RateLimitQuotaResponse_BucketAction.fromPartial(e)) ||
      undefined;
    return message;
  },
};

messageTypeRegistry.set(RateLimitQuotaResponse.$type, RateLimitQuotaResponse);

function createBaseRateLimitQuotaResponse_BucketAction(): RateLimitQuotaResponse_BucketAction {
  return { $type: "envoy.service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction", bucket_action: undefined };
}

export const RateLimitQuotaResponse_BucketAction: MessageFns<
  RateLimitQuotaResponse_BucketAction,
  "envoy.service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction"
> = {
  $type: "envoy.service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction" as const,

  encode(message: RateLimitQuotaResponse_BucketAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bucket_id !== undefined) {
      BucketId.encode(message.bucket_id, writer.uint32(10).fork()).join();
    }
    switch (message.bucket_action?.$case) {
      case "quota_assignment_action":
        RateLimitQuotaResponse_BucketAction_QuotaAssignmentAction.encode(
          message.bucket_action.quota_assignment_action,
          writer.uint32(18).fork(),
        ).join();
        break;
      case "abandon_action":
        RateLimitQuotaResponse_BucketAction_AbandonAction.encode(
          message.bucket_action.abandon_action,
          writer.uint32(26).fork(),
        ).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimitQuotaResponse_BucketAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimitQuotaResponse_BucketAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bucket_id = BucketId.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bucket_action = {
            $case: "quota_assignment_action",
            quota_assignment_action: RateLimitQuotaResponse_BucketAction_QuotaAssignmentAction.decode(
              reader,
              reader.uint32(),
            ),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bucket_action = {
            $case: "abandon_action",
            abandon_action: RateLimitQuotaResponse_BucketAction_AbandonAction.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimitQuotaResponse_BucketAction {
    return {
      $type: RateLimitQuotaResponse_BucketAction.$type,
      bucket_id: isSet(object.bucket_id) ? BucketId.fromJSON(object.bucket_id) : undefined,
      bucket_action: isSet(object.quota_assignment_action)
        ? {
          $case: "quota_assignment_action",
          quota_assignment_action: RateLimitQuotaResponse_BucketAction_QuotaAssignmentAction.fromJSON(
            object.quota_assignment_action,
          ),
        }
        : isSet(object.abandon_action)
        ? {
          $case: "abandon_action",
          abandon_action: RateLimitQuotaResponse_BucketAction_AbandonAction.fromJSON(object.abandon_action),
        }
        : undefined,
    };
  },

  toJSON(message: RateLimitQuotaResponse_BucketAction): unknown {
    const obj: any = {};
    if (message.bucket_id !== undefined) {
      obj.bucket_id = BucketId.toJSON(message.bucket_id);
    }
    if (message.bucket_action?.$case === "quota_assignment_action") {
      obj.quota_assignment_action = RateLimitQuotaResponse_BucketAction_QuotaAssignmentAction.toJSON(
        message.bucket_action.quota_assignment_action,
      );
    }
    if (message.bucket_action?.$case === "abandon_action") {
      obj.abandon_action = RateLimitQuotaResponse_BucketAction_AbandonAction.toJSON(
        message.bucket_action.abandon_action,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimitQuotaResponse_BucketAction>, I>>(
    base?: I,
  ): RateLimitQuotaResponse_BucketAction {
    return RateLimitQuotaResponse_BucketAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimitQuotaResponse_BucketAction>, I>>(
    object: I,
  ): RateLimitQuotaResponse_BucketAction {
    const message = createBaseRateLimitQuotaResponse_BucketAction();
    message.bucket_id = (object.bucket_id !== undefined && object.bucket_id !== null)
      ? BucketId.fromPartial(object.bucket_id)
      : undefined;
    if (
      object.bucket_action?.$case === "quota_assignment_action" &&
      object.bucket_action?.quota_assignment_action !== undefined &&
      object.bucket_action?.quota_assignment_action !== null
    ) {
      message.bucket_action = {
        $case: "quota_assignment_action",
        quota_assignment_action: RateLimitQuotaResponse_BucketAction_QuotaAssignmentAction.fromPartial(
          object.bucket_action.quota_assignment_action,
        ),
      };
    }
    if (
      object.bucket_action?.$case === "abandon_action" &&
      object.bucket_action?.abandon_action !== undefined &&
      object.bucket_action?.abandon_action !== null
    ) {
      message.bucket_action = {
        $case: "abandon_action",
        abandon_action: RateLimitQuotaResponse_BucketAction_AbandonAction.fromPartial(
          object.bucket_action.abandon_action,
        ),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(RateLimitQuotaResponse_BucketAction.$type, RateLimitQuotaResponse_BucketAction);

function createBaseRateLimitQuotaResponse_BucketAction_QuotaAssignmentAction(): RateLimitQuotaResponse_BucketAction_QuotaAssignmentAction {
  return { $type: "envoy.service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.QuotaAssignmentAction" };
}

export const RateLimitQuotaResponse_BucketAction_QuotaAssignmentAction: MessageFns<
  RateLimitQuotaResponse_BucketAction_QuotaAssignmentAction,
  "envoy.service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.QuotaAssignmentAction"
> = {
  $type: "envoy.service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.QuotaAssignmentAction" as const,

  encode(
    message: RateLimitQuotaResponse_BucketAction_QuotaAssignmentAction,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.assignment_time_to_live !== undefined) {
      Duration.encode(message.assignment_time_to_live, writer.uint32(18).fork()).join();
    }
    if (message.rate_limit_strategy !== undefined) {
      RateLimitStrategy.encode(message.rate_limit_strategy, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimitQuotaResponse_BucketAction_QuotaAssignmentAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimitQuotaResponse_BucketAction_QuotaAssignmentAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.assignment_time_to_live = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rate_limit_strategy = RateLimitStrategy.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimitQuotaResponse_BucketAction_QuotaAssignmentAction {
    return {
      $type: RateLimitQuotaResponse_BucketAction_QuotaAssignmentAction.$type,
      assignment_time_to_live: isSet(object.assignment_time_to_live)
        ? Duration.fromJSON(object.assignment_time_to_live)
        : undefined,
      rate_limit_strategy: isSet(object.rate_limit_strategy)
        ? RateLimitStrategy.fromJSON(object.rate_limit_strategy)
        : undefined,
    };
  },

  toJSON(message: RateLimitQuotaResponse_BucketAction_QuotaAssignmentAction): unknown {
    const obj: any = {};
    if (message.assignment_time_to_live !== undefined) {
      obj.assignment_time_to_live = Duration.toJSON(message.assignment_time_to_live);
    }
    if (message.rate_limit_strategy !== undefined) {
      obj.rate_limit_strategy = RateLimitStrategy.toJSON(message.rate_limit_strategy);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimitQuotaResponse_BucketAction_QuotaAssignmentAction>, I>>(
    base?: I,
  ): RateLimitQuotaResponse_BucketAction_QuotaAssignmentAction {
    return RateLimitQuotaResponse_BucketAction_QuotaAssignmentAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimitQuotaResponse_BucketAction_QuotaAssignmentAction>, I>>(
    object: I,
  ): RateLimitQuotaResponse_BucketAction_QuotaAssignmentAction {
    const message = createBaseRateLimitQuotaResponse_BucketAction_QuotaAssignmentAction();
    message.assignment_time_to_live =
      (object.assignment_time_to_live !== undefined && object.assignment_time_to_live !== null)
        ? Duration.fromPartial(object.assignment_time_to_live)
        : undefined;
    message.rate_limit_strategy = (object.rate_limit_strategy !== undefined && object.rate_limit_strategy !== null)
      ? RateLimitStrategy.fromPartial(object.rate_limit_strategy)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(
  RateLimitQuotaResponse_BucketAction_QuotaAssignmentAction.$type,
  RateLimitQuotaResponse_BucketAction_QuotaAssignmentAction,
);

function createBaseRateLimitQuotaResponse_BucketAction_AbandonAction(): RateLimitQuotaResponse_BucketAction_AbandonAction {
  return { $type: "envoy.service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.AbandonAction" };
}

export const RateLimitQuotaResponse_BucketAction_AbandonAction: MessageFns<
  RateLimitQuotaResponse_BucketAction_AbandonAction,
  "envoy.service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.AbandonAction"
> = {
  $type: "envoy.service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.AbandonAction" as const,

  encode(
    _: RateLimitQuotaResponse_BucketAction_AbandonAction,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimitQuotaResponse_BucketAction_AbandonAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimitQuotaResponse_BucketAction_AbandonAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RateLimitQuotaResponse_BucketAction_AbandonAction {
    return { $type: RateLimitQuotaResponse_BucketAction_AbandonAction.$type };
  },

  toJSON(_: RateLimitQuotaResponse_BucketAction_AbandonAction): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimitQuotaResponse_BucketAction_AbandonAction>, I>>(
    base?: I,
  ): RateLimitQuotaResponse_BucketAction_AbandonAction {
    return RateLimitQuotaResponse_BucketAction_AbandonAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimitQuotaResponse_BucketAction_AbandonAction>, I>>(
    _: I,
  ): RateLimitQuotaResponse_BucketAction_AbandonAction {
    const message = createBaseRateLimitQuotaResponse_BucketAction_AbandonAction();
    return message;
  },
};

messageTypeRegistry.set(
  RateLimitQuotaResponse_BucketAction_AbandonAction.$type,
  RateLimitQuotaResponse_BucketAction_AbandonAction,
);

function createBaseBucketId(): BucketId {
  return { $type: "envoy.service.rate_limit_quota.v3.BucketId" };
}

export const BucketId: MessageFns<BucketId, "envoy.service.rate_limit_quota.v3.BucketId"> = {
  $type: "envoy.service.rate_limit_quota.v3.BucketId" as const,

  encode(message: BucketId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    (message.bucket || new Map()).forEach((value, key) => {
      BucketId_BucketEntry.encode({
        $type: "envoy.service.rate_limit_quota.v3.BucketId.BucketEntry",
        key: key as any,
        value,
      }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BucketId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBucketId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = BucketId_BucketEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            if (message.bucket === undefined) {
              message.bucket = new Map();
            }
            message.bucket!.set(entry1.key, entry1.value);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BucketId {
    return {
      $type: BucketId.$type,
      bucket: isObject(object.bucket)
        ? Object.entries(object.bucket).reduce<Map<string, string>>((acc, [key, value]) => {
          acc.set(key, String(value));
          return acc;
        }, new Map())
        : undefined,
    };
  },

  toJSON(message: BucketId): unknown {
    const obj: any = {};
    if (message.bucket?.size) {
      obj.bucket = {};
      message.bucket.forEach((v, k) => {
        obj.bucket[k] = v;
      });
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BucketId>, I>>(base?: I): BucketId {
    return BucketId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BucketId>, I>>(object: I): BucketId {
    const message = createBaseBucketId();
    message.bucket = (object.bucket === undefined || object.bucket === null) ? undefined : (() => {
      const m = new Map();
      (object.bucket as Map<string, string> ?? new Map()).forEach((value, key) => {
        if (value !== undefined) {
          m.set(key, globalThis.String(value));
        }
      });
      return m;
    })();
    return message;
  },
};

messageTypeRegistry.set(BucketId.$type, BucketId);

function createBaseBucketId_BucketEntry(): BucketId_BucketEntry {
  return { $type: "envoy.service.rate_limit_quota.v3.BucketId.BucketEntry", key: "", value: "" };
}

export const BucketId_BucketEntry: MessageFns<
  BucketId_BucketEntry,
  "envoy.service.rate_limit_quota.v3.BucketId.BucketEntry"
> = {
  $type: "envoy.service.rate_limit_quota.v3.BucketId.BucketEntry" as const,

  encode(message: BucketId_BucketEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BucketId_BucketEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBucketId_BucketEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BucketId_BucketEntry {
    return {
      $type: BucketId_BucketEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: BucketId_BucketEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BucketId_BucketEntry>, I>>(base?: I): BucketId_BucketEntry {
    return BucketId_BucketEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BucketId_BucketEntry>, I>>(object: I): BucketId_BucketEntry {
    const message = createBaseBucketId_BucketEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

messageTypeRegistry.set(BucketId_BucketEntry.$type, BucketId_BucketEntry);

/** Defines the Rate Limit Quota Service (RLQS). */
export interface RateLimitQuotaService {
  /**
   * Main communication channel: the data plane sends usage reports to the RLQS server,
   * and the server asynchronously responding with the assignments.
   */
  StreamRateLimitQuotas(request: Observable<RateLimitQuotaUsageReports>): Observable<RateLimitQuotaResponse>;
}

export const RateLimitQuotaServiceServiceName = "envoy.service.rate_limit_quota.v3.RateLimitQuotaService";
export class RateLimitQuotaServiceClientImpl implements RateLimitQuotaService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || RateLimitQuotaServiceServiceName;
    this.rpc = rpc;
    this.StreamRateLimitQuotas = this.StreamRateLimitQuotas.bind(this);
  }
  StreamRateLimitQuotas(request: Observable<RateLimitQuotaUsageReports>): Observable<RateLimitQuotaResponse> {
    const data = request.pipe(map((request) => RateLimitQuotaUsageReports.encode(request).finish()));
    const result = this.rpc.bidirectionalStreamingRequest(this.service, "StreamRateLimitQuotas", data);
    return result.pipe(map((data) => RateLimitQuotaResponse.decode(new BinaryReader(data))));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
  clientStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Promise<Uint8Array>;
  serverStreamingRequest(service: string, method: string, data: Uint8Array): Observable<Uint8Array>;
  bidirectionalStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Observable<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
