// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/service/ext_proc/v3/external_processor.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Observable } from "rxjs";
import { map } from "rxjs/operators";
import { Duration } from "../../../../google/protobuf/duration";
import { Struct } from "../../../../google/protobuf/struct";
import { messageTypeRegistry } from "../../../../typeRegistry";
import { HeaderMap, HeaderValueOption, Metadata } from "../../../config/core/v3/base";
import {
  ProcessingMode,
  ProcessingMode_BodySendMode,
  processingMode_BodySendModeFromJSON,
  processingMode_BodySendModeToJSON,
  processingMode_BodySendModeToNumber,
} from "../../../extensions/filters/http/ext_proc/v3/processing_mode";
import { HttpStatus } from "../../../type/v3/http_status";

export const protobufPackage = "envoy.service.ext_proc.v3";

/**
 * This message specifies the filter protocol configurations which will be sent to the ext_proc
 * server in a :ref:`ProcessingRequest <envoy_v3_api_msg_service.ext_proc.v3.ProcessingRequest>`.
 * If the server does not support these protocol configurations, it may choose to close the gRPC stream.
 * If the server supports these protocol configurations, it should respond based on the API specifications.
 */
export interface ProtocolConfiguration {
  $type: "envoy.service.ext_proc.v3.ProtocolConfiguration";
  /**
   * Specify the filter configuration :ref:`request_body_mode
   * <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ProcessingMode.request_body_mode>`
   */
  request_body_mode?:
    | ProcessingMode_BodySendMode
    | undefined;
  /**
   * Specify the filter configuration :ref:`response_body_mode
   * <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ProcessingMode.response_body_mode>`
   */
  response_body_mode?:
    | ProcessingMode_BodySendMode
    | undefined;
  /**
   * Specify the filter configuration :ref:`send_body_without_waiting_for_header_response
   * <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.send_body_without_waiting_for_header_response>`
   * If the client is waiting for a header response from the server, setting ``true`` means the client will send body to the server
   * as they arrive. Setting ``false`` means the client will buffer the arrived data and not send it to the server immediately.
   */
  send_body_without_waiting_for_header_response?: boolean | undefined;
}

/**
 * This represents the different types of messages that the data plane can send
 * to an external processing server.
 * [#next-free-field: 12]
 */
export interface ProcessingRequest {
  $type: "envoy.service.ext_proc.v3.ProcessingRequest";
  /**
   * Each request message will include one of the following sub-messages. Which
   * ones are set for a particular HTTP request/response depend on the
   * processing mode.
   */
  request?:
    | //
    /**
     * Information about the HTTP request headers, as well as peer info and additional
     * properties. Unless ``observability_mode`` is ``true``, the server must send back a
     * HeaderResponse message, an ImmediateResponse message, or close the stream.
     */
    { $case: "request_headers"; request_headers: HttpHeaders }
    | //
    /**
     * Information about the HTTP response headers, as well as peer info and additional
     * properties. Unless ``observability_mode`` is ``true``, the server must send back a
     * HeaderResponse message or close the stream.
     */
    { $case: "response_headers"; response_headers: HttpHeaders }
    | //
    /**
     * A chunk of the HTTP request body. Unless ``observability_mode`` is true, the server must send back
     * a BodyResponse message, an ImmediateResponse message, or close the stream.
     */
    { $case: "request_body"; request_body: HttpBody }
    | //
    /**
     * A chunk of the HTTP response body. Unless ``observability_mode`` is ``true``, the server must send back
     * a BodyResponse message or close the stream.
     */
    { $case: "response_body"; response_body: HttpBody }
    | //
    /**
     * The HTTP trailers for the request path. Unless ``observability_mode`` is ``true``, the server
     * must send back a TrailerResponse message or close the stream.
     *
     * This message is only sent if the trailers processing mode is set to ``SEND`` and
     * the original downstream request has trailers.
     */
    { $case: "request_trailers"; request_trailers: HttpTrailers }
    | //
    /**
     * The HTTP trailers for the response path. Unless ``observability_mode`` is ``true``, the server
     * must send back a TrailerResponse message or close the stream.
     *
     * This message is only sent if the trailers processing mode is set to ``SEND`` and
     * the original upstream response has trailers.
     */
    { $case: "response_trailers"; response_trailers: HttpTrailers }
    | undefined;
  /** Dynamic metadata associated with the request. */
  metadata_context?:
    | Metadata
    | undefined;
  /**
   * The values of properties selected by the ``request_attributes``
   * or ``response_attributes`` list in the configuration. Each entry
   * in the list is populated from the standard
   * :ref:`attributes <arch_overview_attributes>` supported in the data plane.
   */
  attributes?:
    | Map<string, { [key: string]: any } | undefined>
    | undefined;
  /**
   * Specify whether the filter that sent this request is running in :ref:`observability_mode
   * <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.observability_mode>`
   * and defaults to false.
   *
   * * A value of ``false`` indicates that the server must respond
   *   to this message by either sending back a matching ProcessingResponse message,
   *   or by closing the stream.
   * * A value of ``true`` indicates that the server should not respond to this message, as any
   *   responses will be ignored. However, it may still close the stream to indicate that no more messages
   *   are needed.
   */
  observability_mode?:
    | boolean
    | undefined;
  /**
   * Specify the filter protocol configurations to be sent to the server.
   * ``protocol_config`` is only encoded in the first ``ProcessingRequest`` message from the client to the server.
   */
  protocol_config?: ProtocolConfiguration | undefined;
}

export interface ProcessingRequest_AttributesEntry {
  $type: "envoy.service.ext_proc.v3.ProcessingRequest.AttributesEntry";
  key: string;
  value?: { [key: string]: any } | undefined;
}

/**
 * This represents the different types of messages the server may send back to the data plane
 * when the ``observability_mode`` field in the received ProcessingRequest is set to false.
 *
 * * If the corresponding ``BodySendMode`` in the
 *   :ref:`processing_mode <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.processing_mode>`
 *   is not set to ``FULL_DUPLEX_STREAMED``, then for every received ProcessingRequest,
 *   the server must send back exactly one ProcessingResponse message.
 * * If it is set to ``FULL_DUPLEX_STREAMED``, the server must follow the API defined
 *   for this mode to send the ProcessingResponse messages.
 * [#next-free-field: 11]
 */
export interface ProcessingResponse {
  $type: "envoy.service.ext_proc.v3.ProcessingResponse";
  /** The response type that is sent by the server. */
  response?:
    | //
    /**
     * The server must send back this message in response to a message with the
     * ``request_headers`` field set.
     */
    { $case: "request_headers"; request_headers: HeadersResponse }
    | //
    /**
     * The server must send back this message in response to a message with the
     * ``response_headers`` field set.
     */
    { $case: "response_headers"; response_headers: HeadersResponse }
    | //
    /**
     * The server must send back this message in response to a message with
     * the ``request_body`` field set.
     */
    { $case: "request_body"; request_body: BodyResponse }
    | //
    /**
     * The server must send back this message in response to a message with
     * the ``response_body`` field set.
     */
    { $case: "response_body"; response_body: BodyResponse }
    | //
    /**
     * The server must send back this message in response to a message with
     * the ``request_trailers`` field set.
     */
    { $case: "request_trailers"; request_trailers: TrailersResponse }
    | //
    /**
     * The server must send back this message in response to a message with
     * the ``response_trailers`` field set.
     */
    { $case: "response_trailers"; response_trailers: TrailersResponse }
    | //
    /**
     * If specified, attempt to create a locally generated response, send it
     * downstream, and stop processing additional filters and ignore any
     * additional messages received from the remote server for this request or
     * response. If a response has already started -- for example, if this
     * message is sent response to a ``response_body`` message -- then
     * this will either ship the reply directly to the downstream codec,
     * or reset the stream.
     */
    { $case: "immediate_response"; immediate_response: ImmediateResponse }
    | undefined;
  /**
   * Optional metadata that will be emitted as dynamic metadata to be consumed by
   * following filters. This metadata will be placed in the namespace(s) specified by the top-level
   * field name(s) of the struct.
   */
  dynamic_metadata?:
    | { [key: string]: any }
    | undefined;
  /**
   * Override how parts of the HTTP request and response are processed
   * for the duration of this particular request/response only. Servers
   * may use this to intelligently control how requests are processed
   * based on the headers and other metadata that they see.
   * This field is only applicable when servers responding to the header requests.
   * If it is set in the response to the body or trailer requests, it will be ignored by the data plane.
   * It is also ignored by the data plane when the ext_proc filter config
   * :ref:`allow_mode_override
   * <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.allow_mode_override>`
   * is set to false, or
   * :ref:`send_body_without_waiting_for_header_response
   * <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.send_body_without_waiting_for_header_response>`
   * is set to true.
   */
  mode_override?:
    | ProcessingMode
    | undefined;
  /**
   * When ext_proc server receives a request message, in case it needs more
   * time to process the message, it sends back a ProcessingResponse message
   * with a new timeout value. When the data plane receives this response
   * message, it ignores other fields in the response, just stop the original
   * timer, which has the timeout value specified in
   * :ref:`message_timeout
   * <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.message_timeout>`
   * and start a new timer with this ``override_message_timeout`` value and keep the
   * data plane ext_proc filter state machine intact.
   * Has to be >= 1ms and <=
   * :ref:`max_message_timeout <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.max_message_timeout>`
   * Such message can be sent at most once in a particular data plane ext_proc filter processing state.
   * To enable this API, one has to set ``max_message_timeout`` to a number >= 1ms.
   */
  override_message_timeout?: Duration | undefined;
}

/**
 * This message is sent to the external server when the HTTP request and responses
 * are first received.
 */
export interface HttpHeaders {
  $type: "envoy.service.ext_proc.v3.HttpHeaders";
  /**
   * The HTTP request headers. All header keys will be
   * lower-cased, because HTTP header keys are case-insensitive.
   * The header value is encoded in the
   * :ref:`raw_value <envoy_v3_api_field_config.core.v3.HeaderValue.raw_value>` field.
   */
  headers?:
    | HeaderMap
    | undefined;
  /**
   * [#not-implemented-hide:]
   * This field is deprecated and not implemented. Attributes will be sent in
   * the  top-level :ref:`attributes <envoy_v3_api_field_service.ext_proc.v3.ProcessingRequest.attributes`
   * field.
   *
   * @deprecated
   */
  attributes?:
    | Map<string, { [key: string]: any } | undefined>
    | undefined;
  /**
   * If ``true``, then there is no message body associated with this
   * request or response.
   */
  end_of_stream?: boolean | undefined;
}

export interface HttpHeaders_AttributesEntry {
  $type: "envoy.service.ext_proc.v3.HttpHeaders.AttributesEntry";
  key: string;
  value?: { [key: string]: any } | undefined;
}

/**
 * This message is sent to the external server when the HTTP request and
 * response bodies are received.
 */
export interface HttpBody {
  $type: "envoy.service.ext_proc.v3.HttpBody";
  /**
   * The contents of the body in the HTTP request/response. Note that in
   * streaming mode multiple ``HttpBody`` messages may be sent.
   */
  body?:
    | Uint8Array
    | undefined;
  /**
   * If ``true``, this will be the last ``HttpBody`` message that will be sent and no
   * trailers will be sent for the current request/response.
   */
  end_of_stream?: boolean | undefined;
}

/**
 * This message is sent to the external server when the HTTP request and
 * response trailers are received.
 */
export interface HttpTrailers {
  $type: "envoy.service.ext_proc.v3.HttpTrailers";
  /**
   * The header value is encoded in the
   * :ref:`raw_value <envoy_v3_api_field_config.core.v3.HeaderValue.raw_value>` field.
   */
  trailers?: HeaderMap | undefined;
}

/**
 * This message is sent by the external server to the data plane after ``HttpHeaders`` was
 * sent to it.
 */
export interface HeadersResponse {
  $type: "envoy.service.ext_proc.v3.HeadersResponse";
  /**
   * Details the modifications (if any) to be made by the data plane to the current
   * request/response.
   */
  response?: CommonResponse | undefined;
}

/**
 * This message is sent by the external server to the data plane after ``HttpBody`` was
 * sent to it.
 */
export interface BodyResponse {
  $type: "envoy.service.ext_proc.v3.BodyResponse";
  /**
   * Details the modifications (if any) to be made by the data plane to the current
   * request/response.
   */
  response?: CommonResponse | undefined;
}

/**
 * This message is sent by the external server to the data plane after ``HttpTrailers`` was
 * sent to it.
 */
export interface TrailersResponse {
  $type: "envoy.service.ext_proc.v3.TrailersResponse";
  /**
   * Details the modifications (if any) to be made by the data plane to the current
   * request/response trailers.
   */
  header_mutation?: HeaderMutation | undefined;
}

/**
 * This message contains common fields between header and body responses.
 * [#next-free-field: 6]
 */
export interface CommonResponse {
  $type: "envoy.service.ext_proc.v3.CommonResponse";
  /**
   * If set, provide additional direction on how the data plane should
   * handle the rest of the HTTP filter chain.
   */
  status?:
    | CommonResponse_ResponseStatus
    | undefined;
  /**
   * Instructions on how to manipulate the headers. When responding to an
   * HttpBody request, header mutations will only take effect if
   * the current processing mode for the body is BUFFERED.
   */
  header_mutation?:
    | HeaderMutation
    | undefined;
  /**
   * Replace the body of the last message sent to the remote server on this
   * stream. If responding to an HttpBody request, simply replace or clear
   * the body chunk that was sent with that request. Body mutations may take
   * effect in response either to ``header`` or ``body`` messages. When it is
   * in response to ``header`` messages, it only take effect if the
   * :ref:`status <envoy_v3_api_field_service.ext_proc.v3.CommonResponse.status>`
   * is set to CONTINUE_AND_REPLACE.
   */
  body_mutation?:
    | BodyMutation
    | undefined;
  /**
   * [#not-implemented-hide:]
   * Add new trailers to the message. This may be used when responding to either a
   * HttpHeaders or HttpBody message, but only if this message is returned
   * along with the CONTINUE_AND_REPLACE status.
   * The header value is encoded in the
   * :ref:`raw_value <envoy_v3_api_field_config.core.v3.HeaderValue.raw_value>` field.
   */
  trailers?:
    | HeaderMap
    | undefined;
  /**
   * Clear the route cache for the current client request. This is necessary
   * if the remote server modified headers that are used to calculate the route.
   * This field is ignored in the response direction. This field is also ignored
   * if the data plane ext_proc filter is in the upstream filter chain.
   */
  clear_route_cache?: boolean | undefined;
}

/** The status of the response. */
export enum CommonResponse_ResponseStatus {
  /**
   * CONTINUE - Apply the mutation instructions in this message to the
   * request or response, and then continue processing the filter
   * stream as normal. This is the default.
   */
  CONTINUE = "CONTINUE",
  /**
   * CONTINUE_AND_REPLACE - Apply the specified header mutation, replace the body with the body
   * specified in the body mutation (if present), and do not send any
   * further messages for this request or response even if the processing
   * mode is configured to do so.
   *
   * When used in response to a request_headers or response_headers message,
   * this status makes it possible to either completely replace the body
   * while discarding the original body, or to add a body to a message that
   * formerly did not have one.
   *
   * In other words, this response makes it possible to turn an HTTP GET
   * into a POST, PUT, or PATCH.
   */
  CONTINUE_AND_REPLACE = "CONTINUE_AND_REPLACE",
}

export function commonResponse_ResponseStatusFromJSON(object: any): CommonResponse_ResponseStatus {
  switch (object) {
    case 0:
    case "CONTINUE":
      return CommonResponse_ResponseStatus.CONTINUE;
    case 1:
    case "CONTINUE_AND_REPLACE":
      return CommonResponse_ResponseStatus.CONTINUE_AND_REPLACE;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CommonResponse_ResponseStatus");
  }
}

export function commonResponse_ResponseStatusToJSON(object: CommonResponse_ResponseStatus): string {
  switch (object) {
    case CommonResponse_ResponseStatus.CONTINUE:
      return "CONTINUE";
    case CommonResponse_ResponseStatus.CONTINUE_AND_REPLACE:
      return "CONTINUE_AND_REPLACE";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CommonResponse_ResponseStatus");
  }
}

export function commonResponse_ResponseStatusToNumber(object: CommonResponse_ResponseStatus): number {
  switch (object) {
    case CommonResponse_ResponseStatus.CONTINUE:
      return 0;
    case CommonResponse_ResponseStatus.CONTINUE_AND_REPLACE:
      return 1;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CommonResponse_ResponseStatus");
  }
}

/**
 * This message causes the filter to attempt to create a locally
 * generated response, send it  downstream, stop processing
 * additional filters, and ignore any additional messages received
 * from the remote server for this request or response. If a response
 * has already started, then  this will either ship the reply directly
 * to the downstream codec, or reset the stream.
 * [#next-free-field: 6]
 */
export interface ImmediateResponse {
  $type: "envoy.service.ext_proc.v3.ImmediateResponse";
  /** The response code to return. */
  status?:
    | HttpStatus
    | undefined;
  /** Apply changes to the default headers, which will include content-type. */
  headers?:
    | HeaderMutation
    | undefined;
  /**
   * The message body to return with the response which is sent using the
   * text/plain content type, or encoded in the grpc-message header.
   */
  body?:
    | Uint8Array
    | undefined;
  /** If set, then include a gRPC status trailer. */
  grpc_status?:
    | GrpcStatus
    | undefined;
  /**
   * A string detailing why this local reply was sent, which may be included
   * in log and debug output (e.g. this populates the %RESPONSE_CODE_DETAILS%
   * command operator field for use in access logging).
   */
  details?: string | undefined;
}

/** This message specifies a gRPC status for an ImmediateResponse message. */
export interface GrpcStatus {
  $type: "envoy.service.ext_proc.v3.GrpcStatus";
  /** The actual gRPC status. */
  status?: number | undefined;
}

/**
 * Change HTTP headers or trailers by appending, replacing, or removing
 * headers.
 */
export interface HeaderMutation {
  $type: "envoy.service.ext_proc.v3.HeaderMutation";
  /**
   * Add or replace HTTP headers. Attempts to set the value of
   * any ``x-envoy`` header, and attempts to set the ``:method``,
   * ``:authority``, ``:scheme``, or ``host`` headers will be ignored.
   * The header value is encoded in the
   * :ref:`raw_value <envoy_v3_api_field_config.core.v3.HeaderValue.raw_value>` field.
   */
  set_headers?:
    | HeaderValueOption[]
    | undefined;
  /**
   * Remove these HTTP headers. Attempts to remove system headers --
   * any header starting with ``:``, plus ``host`` -- will be ignored.
   */
  remove_headers?: string[] | undefined;
}

/** The body response message corresponding to FULL_DUPLEX_STREAMED body mode. */
export interface StreamedBodyResponse {
  $type: "envoy.service.ext_proc.v3.StreamedBodyResponse";
  /** The body response chunk that will be passed to the upstream/downstream by the data plane. */
  body?:
    | Uint8Array
    | undefined;
  /**
   * The server sets this flag to true if it has received a body request with
   * :ref:`end_of_stream <envoy_v3_api_field_service.ext_proc.v3.HttpBody.end_of_stream>` set to true,
   * and this is the last chunk of body responses.
   */
  end_of_stream?: boolean | undefined;
}

/** This message specifies the body mutation the server sends to the data plane. */
export interface BodyMutation {
  $type: "envoy.service.ext_proc.v3.BodyMutation";
  /** The type of mutation for the body. */
  mutation?:
    | //
    /**
     * The entire body to replace.
     * Should only be used when the corresponding ``BodySendMode`` in the
     * :ref:`processing_mode <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.processing_mode>`
     * is not set to ``FULL_DUPLEX_STREAMED``.
     */
    { $case: "body"; body: Uint8Array }
    | //
    /**
     * Clear the corresponding body chunk.
     * Should only be used when the corresponding ``BodySendMode`` in the
     * :ref:`processing_mode <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.processing_mode>`
     * is not set to ``FULL_DUPLEX_STREAMED``.
     * Clear the corresponding body chunk.
     */
    { $case: "clear_body"; clear_body: boolean }
    | //
    /**
     * Must be used when the corresponding ``BodySendMode`` in the
     * :ref:`processing_mode <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.processing_mode>`
     * is set to ``FULL_DUPLEX_STREAMED``.
     */
    { $case: "streamed_response"; streamed_response: StreamedBodyResponse }
    | undefined;
}

function createBaseProtocolConfiguration(): ProtocolConfiguration {
  return { $type: "envoy.service.ext_proc.v3.ProtocolConfiguration" };
}

export const ProtocolConfiguration: MessageFns<
  ProtocolConfiguration,
  "envoy.service.ext_proc.v3.ProtocolConfiguration"
> = {
  $type: "envoy.service.ext_proc.v3.ProtocolConfiguration" as const,

  encode(message: ProtocolConfiguration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request_body_mode !== undefined && message.request_body_mode !== ProcessingMode_BodySendMode.NONE) {
      writer.uint32(8).int32(processingMode_BodySendModeToNumber(message.request_body_mode));
    }
    if (message.response_body_mode !== undefined && message.response_body_mode !== ProcessingMode_BodySendMode.NONE) {
      writer.uint32(16).int32(processingMode_BodySendModeToNumber(message.response_body_mode));
    }
    if (
      message.send_body_without_waiting_for_header_response !== undefined &&
      message.send_body_without_waiting_for_header_response !== false
    ) {
      writer.uint32(24).bool(message.send_body_without_waiting_for_header_response);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtocolConfiguration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtocolConfiguration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.request_body_mode = processingMode_BodySendModeFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.response_body_mode = processingMode_BodySendModeFromJSON(reader.int32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.send_body_without_waiting_for_header_response = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtocolConfiguration {
    return {
      $type: ProtocolConfiguration.$type,
      request_body_mode: isSet(object.request_body_mode)
        ? processingMode_BodySendModeFromJSON(object.request_body_mode)
        : undefined,
      response_body_mode: isSet(object.response_body_mode)
        ? processingMode_BodySendModeFromJSON(object.response_body_mode)
        : undefined,
      send_body_without_waiting_for_header_response: isSet(object.send_body_without_waiting_for_header_response)
        ? globalThis.Boolean(object.send_body_without_waiting_for_header_response)
        : undefined,
    };
  },

  toJSON(message: ProtocolConfiguration): unknown {
    const obj: any = {};
    if (message.request_body_mode !== undefined) {
      obj.request_body_mode = processingMode_BodySendModeToJSON(message.request_body_mode);
    }
    if (message.response_body_mode !== undefined) {
      obj.response_body_mode = processingMode_BodySendModeToJSON(message.response_body_mode);
    }
    if (message.send_body_without_waiting_for_header_response !== undefined) {
      obj.send_body_without_waiting_for_header_response = message.send_body_without_waiting_for_header_response;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtocolConfiguration>, I>>(base?: I): ProtocolConfiguration {
    return ProtocolConfiguration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtocolConfiguration>, I>>(object: I): ProtocolConfiguration {
    const message = createBaseProtocolConfiguration();
    message.request_body_mode = object.request_body_mode ?? undefined;
    message.response_body_mode = object.response_body_mode ?? undefined;
    message.send_body_without_waiting_for_header_response = object.send_body_without_waiting_for_header_response ??
      undefined;
    return message;
  },
};

messageTypeRegistry.set(ProtocolConfiguration.$type, ProtocolConfiguration);

function createBaseProcessingRequest(): ProcessingRequest {
  return { $type: "envoy.service.ext_proc.v3.ProcessingRequest", request: undefined };
}

export const ProcessingRequest: MessageFns<ProcessingRequest, "envoy.service.ext_proc.v3.ProcessingRequest"> = {
  $type: "envoy.service.ext_proc.v3.ProcessingRequest" as const,

  encode(message: ProcessingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.request?.$case) {
      case "request_headers":
        HttpHeaders.encode(message.request.request_headers, writer.uint32(18).fork()).join();
        break;
      case "response_headers":
        HttpHeaders.encode(message.request.response_headers, writer.uint32(26).fork()).join();
        break;
      case "request_body":
        HttpBody.encode(message.request.request_body, writer.uint32(34).fork()).join();
        break;
      case "response_body":
        HttpBody.encode(message.request.response_body, writer.uint32(42).fork()).join();
        break;
      case "request_trailers":
        HttpTrailers.encode(message.request.request_trailers, writer.uint32(50).fork()).join();
        break;
      case "response_trailers":
        HttpTrailers.encode(message.request.response_trailers, writer.uint32(58).fork()).join();
        break;
    }
    if (message.metadata_context !== undefined) {
      Metadata.encode(message.metadata_context, writer.uint32(66).fork()).join();
    }
    (message.attributes || new Map()).forEach((value, key) => {
      if (value !== undefined) {
        ProcessingRequest_AttributesEntry.encode({
          $type: "envoy.service.ext_proc.v3.ProcessingRequest.AttributesEntry",
          key: key as any,
          value,
        }, writer.uint32(74).fork()).join();
      }
    });
    if (message.observability_mode !== undefined && message.observability_mode !== false) {
      writer.uint32(80).bool(message.observability_mode);
    }
    if (message.protocol_config !== undefined) {
      ProtocolConfiguration.encode(message.protocol_config, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.request = { $case: "request_headers", request_headers: HttpHeaders.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.request = {
            $case: "response_headers",
            response_headers: HttpHeaders.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.request = { $case: "request_body", request_body: HttpBody.decode(reader, reader.uint32()) };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.request = { $case: "response_body", response_body: HttpBody.decode(reader, reader.uint32()) };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.request = {
            $case: "request_trailers",
            request_trailers: HttpTrailers.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.request = {
            $case: "response_trailers",
            response_trailers: HttpTrailers.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.metadata_context = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          const entry9 = ProcessingRequest_AttributesEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            if (message.attributes === undefined) {
              message.attributes = new Map();
            }
            message.attributes!.set(entry9.key, entry9.value);
          }
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.observability_mode = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.protocol_config = ProtocolConfiguration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessingRequest {
    return {
      $type: ProcessingRequest.$type,
      request: isSet(object.request_headers)
        ? { $case: "request_headers", request_headers: HttpHeaders.fromJSON(object.request_headers) }
        : isSet(object.response_headers)
        ? { $case: "response_headers", response_headers: HttpHeaders.fromJSON(object.response_headers) }
        : isSet(object.request_body)
        ? { $case: "request_body", request_body: HttpBody.fromJSON(object.request_body) }
        : isSet(object.response_body)
        ? { $case: "response_body", response_body: HttpBody.fromJSON(object.response_body) }
        : isSet(object.request_trailers)
        ? { $case: "request_trailers", request_trailers: HttpTrailers.fromJSON(object.request_trailers) }
        : isSet(object.response_trailers)
        ? { $case: "response_trailers", response_trailers: HttpTrailers.fromJSON(object.response_trailers) }
        : undefined,
      metadata_context: isSet(object.metadata_context) ? Metadata.fromJSON(object.metadata_context) : undefined,
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<Map<string, { [key: string]: any } | undefined>>(
          (acc, [key, value]) => {
            acc.set(key, value as { [key: string]: any } | undefined);
            return acc;
          },
          new Map(),
        )
        : undefined,
      observability_mode: isSet(object.observability_mode) ? globalThis.Boolean(object.observability_mode) : undefined,
      protocol_config: isSet(object.protocol_config)
        ? ProtocolConfiguration.fromJSON(object.protocol_config)
        : undefined,
    };
  },

  toJSON(message: ProcessingRequest): unknown {
    const obj: any = {};
    if (message.request?.$case === "request_headers") {
      obj.request_headers = HttpHeaders.toJSON(message.request.request_headers);
    }
    if (message.request?.$case === "response_headers") {
      obj.response_headers = HttpHeaders.toJSON(message.request.response_headers);
    }
    if (message.request?.$case === "request_body") {
      obj.request_body = HttpBody.toJSON(message.request.request_body);
    }
    if (message.request?.$case === "response_body") {
      obj.response_body = HttpBody.toJSON(message.request.response_body);
    }
    if (message.request?.$case === "request_trailers") {
      obj.request_trailers = HttpTrailers.toJSON(message.request.request_trailers);
    }
    if (message.request?.$case === "response_trailers") {
      obj.response_trailers = HttpTrailers.toJSON(message.request.response_trailers);
    }
    if (message.metadata_context !== undefined) {
      obj.metadata_context = Metadata.toJSON(message.metadata_context);
    }
    if (message.attributes?.size) {
      obj.attributes = {};
      message.attributes.forEach((v, k) => {
        obj.attributes[k] = v;
      });
    }
    if (message.observability_mode !== undefined) {
      obj.observability_mode = message.observability_mode;
    }
    if (message.protocol_config !== undefined) {
      obj.protocol_config = ProtocolConfiguration.toJSON(message.protocol_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessingRequest>, I>>(base?: I): ProcessingRequest {
    return ProcessingRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessingRequest>, I>>(object: I): ProcessingRequest {
    const message = createBaseProcessingRequest();
    if (
      object.request?.$case === "request_headers" &&
      object.request?.request_headers !== undefined &&
      object.request?.request_headers !== null
    ) {
      message.request = {
        $case: "request_headers",
        request_headers: HttpHeaders.fromPartial(object.request.request_headers),
      };
    }
    if (
      object.request?.$case === "response_headers" &&
      object.request?.response_headers !== undefined &&
      object.request?.response_headers !== null
    ) {
      message.request = {
        $case: "response_headers",
        response_headers: HttpHeaders.fromPartial(object.request.response_headers),
      };
    }
    if (
      object.request?.$case === "request_body" &&
      object.request?.request_body !== undefined &&
      object.request?.request_body !== null
    ) {
      message.request = { $case: "request_body", request_body: HttpBody.fromPartial(object.request.request_body) };
    }
    if (
      object.request?.$case === "response_body" &&
      object.request?.response_body !== undefined &&
      object.request?.response_body !== null
    ) {
      message.request = { $case: "response_body", response_body: HttpBody.fromPartial(object.request.response_body) };
    }
    if (
      object.request?.$case === "request_trailers" &&
      object.request?.request_trailers !== undefined &&
      object.request?.request_trailers !== null
    ) {
      message.request = {
        $case: "request_trailers",
        request_trailers: HttpTrailers.fromPartial(object.request.request_trailers),
      };
    }
    if (
      object.request?.$case === "response_trailers" &&
      object.request?.response_trailers !== undefined &&
      object.request?.response_trailers !== null
    ) {
      message.request = {
        $case: "response_trailers",
        response_trailers: HttpTrailers.fromPartial(object.request.response_trailers),
      };
    }
    message.metadata_context = (object.metadata_context !== undefined && object.metadata_context !== null)
      ? Metadata.fromPartial(object.metadata_context)
      : undefined;
    message.attributes = (object.attributes === undefined || object.attributes === null) ? undefined : (() => {
      const m = new Map();
      (object.attributes as Map<string, { [key: string]: any } | undefined> ?? new Map()).forEach((value, key) => {
        if (value !== undefined) {
          m.set(key, value);
        }
      });
      return m;
    })();
    message.observability_mode = object.observability_mode ?? undefined;
    message.protocol_config = (object.protocol_config !== undefined && object.protocol_config !== null)
      ? ProtocolConfiguration.fromPartial(object.protocol_config)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(ProcessingRequest.$type, ProcessingRequest);

function createBaseProcessingRequest_AttributesEntry(): ProcessingRequest_AttributesEntry {
  return { $type: "envoy.service.ext_proc.v3.ProcessingRequest.AttributesEntry", key: "" };
}

export const ProcessingRequest_AttributesEntry: MessageFns<
  ProcessingRequest_AttributesEntry,
  "envoy.service.ext_proc.v3.ProcessingRequest.AttributesEntry"
> = {
  $type: "envoy.service.ext_proc.v3.ProcessingRequest.AttributesEntry" as const,

  encode(message: ProcessingRequest_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Struct.encode(Struct.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessingRequest_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessingRequest_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessingRequest_AttributesEntry {
    return {
      $type: ProcessingRequest_AttributesEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isObject(object.value) ? object.value : undefined,
    };
  },

  toJSON(message: ProcessingRequest_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessingRequest_AttributesEntry>, I>>(
    base?: I,
  ): ProcessingRequest_AttributesEntry {
    return ProcessingRequest_AttributesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessingRequest_AttributesEntry>, I>>(
    object: I,
  ): ProcessingRequest_AttributesEntry {
    const message = createBaseProcessingRequest_AttributesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ProcessingRequest_AttributesEntry.$type, ProcessingRequest_AttributesEntry);

function createBaseProcessingResponse(): ProcessingResponse {
  return { $type: "envoy.service.ext_proc.v3.ProcessingResponse", response: undefined };
}

export const ProcessingResponse: MessageFns<ProcessingResponse, "envoy.service.ext_proc.v3.ProcessingResponse"> = {
  $type: "envoy.service.ext_proc.v3.ProcessingResponse" as const,

  encode(message: ProcessingResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.response?.$case) {
      case "request_headers":
        HeadersResponse.encode(message.response.request_headers, writer.uint32(10).fork()).join();
        break;
      case "response_headers":
        HeadersResponse.encode(message.response.response_headers, writer.uint32(18).fork()).join();
        break;
      case "request_body":
        BodyResponse.encode(message.response.request_body, writer.uint32(26).fork()).join();
        break;
      case "response_body":
        BodyResponse.encode(message.response.response_body, writer.uint32(34).fork()).join();
        break;
      case "request_trailers":
        TrailersResponse.encode(message.response.request_trailers, writer.uint32(42).fork()).join();
        break;
      case "response_trailers":
        TrailersResponse.encode(message.response.response_trailers, writer.uint32(50).fork()).join();
        break;
      case "immediate_response":
        ImmediateResponse.encode(message.response.immediate_response, writer.uint32(58).fork()).join();
        break;
    }
    if (message.dynamic_metadata !== undefined) {
      Struct.encode(Struct.wrap(message.dynamic_metadata), writer.uint32(66).fork()).join();
    }
    if (message.mode_override !== undefined) {
      ProcessingMode.encode(message.mode_override, writer.uint32(74).fork()).join();
    }
    if (message.override_message_timeout !== undefined) {
      Duration.encode(message.override_message_timeout, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessingResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.response = {
            $case: "request_headers",
            request_headers: HeadersResponse.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.response = {
            $case: "response_headers",
            response_headers: HeadersResponse.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.response = { $case: "request_body", request_body: BodyResponse.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.response = { $case: "response_body", response_body: BodyResponse.decode(reader, reader.uint32()) };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.response = {
            $case: "request_trailers",
            request_trailers: TrailersResponse.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.response = {
            $case: "response_trailers",
            response_trailers: TrailersResponse.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.response = {
            $case: "immediate_response",
            immediate_response: ImmediateResponse.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.dynamic_metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.mode_override = ProcessingMode.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.override_message_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessingResponse {
    return {
      $type: ProcessingResponse.$type,
      response: isSet(object.request_headers)
        ? { $case: "request_headers", request_headers: HeadersResponse.fromJSON(object.request_headers) }
        : isSet(object.response_headers)
        ? { $case: "response_headers", response_headers: HeadersResponse.fromJSON(object.response_headers) }
        : isSet(object.request_body)
        ? { $case: "request_body", request_body: BodyResponse.fromJSON(object.request_body) }
        : isSet(object.response_body)
        ? { $case: "response_body", response_body: BodyResponse.fromJSON(object.response_body) }
        : isSet(object.request_trailers)
        ? { $case: "request_trailers", request_trailers: TrailersResponse.fromJSON(object.request_trailers) }
        : isSet(object.response_trailers)
        ? { $case: "response_trailers", response_trailers: TrailersResponse.fromJSON(object.response_trailers) }
        : isSet(object.immediate_response)
        ? { $case: "immediate_response", immediate_response: ImmediateResponse.fromJSON(object.immediate_response) }
        : undefined,
      dynamic_metadata: isObject(object.dynamic_metadata) ? object.dynamic_metadata : undefined,
      mode_override: isSet(object.mode_override) ? ProcessingMode.fromJSON(object.mode_override) : undefined,
      override_message_timeout: isSet(object.override_message_timeout)
        ? Duration.fromJSON(object.override_message_timeout)
        : undefined,
    };
  },

  toJSON(message: ProcessingResponse): unknown {
    const obj: any = {};
    if (message.response?.$case === "request_headers") {
      obj.request_headers = HeadersResponse.toJSON(message.response.request_headers);
    }
    if (message.response?.$case === "response_headers") {
      obj.response_headers = HeadersResponse.toJSON(message.response.response_headers);
    }
    if (message.response?.$case === "request_body") {
      obj.request_body = BodyResponse.toJSON(message.response.request_body);
    }
    if (message.response?.$case === "response_body") {
      obj.response_body = BodyResponse.toJSON(message.response.response_body);
    }
    if (message.response?.$case === "request_trailers") {
      obj.request_trailers = TrailersResponse.toJSON(message.response.request_trailers);
    }
    if (message.response?.$case === "response_trailers") {
      obj.response_trailers = TrailersResponse.toJSON(message.response.response_trailers);
    }
    if (message.response?.$case === "immediate_response") {
      obj.immediate_response = ImmediateResponse.toJSON(message.response.immediate_response);
    }
    if (message.dynamic_metadata !== undefined) {
      obj.dynamic_metadata = message.dynamic_metadata;
    }
    if (message.mode_override !== undefined) {
      obj.mode_override = ProcessingMode.toJSON(message.mode_override);
    }
    if (message.override_message_timeout !== undefined) {
      obj.override_message_timeout = Duration.toJSON(message.override_message_timeout);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessingResponse>, I>>(base?: I): ProcessingResponse {
    return ProcessingResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessingResponse>, I>>(object: I): ProcessingResponse {
    const message = createBaseProcessingResponse();
    if (
      object.response?.$case === "request_headers" &&
      object.response?.request_headers !== undefined &&
      object.response?.request_headers !== null
    ) {
      message.response = {
        $case: "request_headers",
        request_headers: HeadersResponse.fromPartial(object.response.request_headers),
      };
    }
    if (
      object.response?.$case === "response_headers" &&
      object.response?.response_headers !== undefined &&
      object.response?.response_headers !== null
    ) {
      message.response = {
        $case: "response_headers",
        response_headers: HeadersResponse.fromPartial(object.response.response_headers),
      };
    }
    if (
      object.response?.$case === "request_body" &&
      object.response?.request_body !== undefined &&
      object.response?.request_body !== null
    ) {
      message.response = {
        $case: "request_body",
        request_body: BodyResponse.fromPartial(object.response.request_body),
      };
    }
    if (
      object.response?.$case === "response_body" &&
      object.response?.response_body !== undefined &&
      object.response?.response_body !== null
    ) {
      message.response = {
        $case: "response_body",
        response_body: BodyResponse.fromPartial(object.response.response_body),
      };
    }
    if (
      object.response?.$case === "request_trailers" &&
      object.response?.request_trailers !== undefined &&
      object.response?.request_trailers !== null
    ) {
      message.response = {
        $case: "request_trailers",
        request_trailers: TrailersResponse.fromPartial(object.response.request_trailers),
      };
    }
    if (
      object.response?.$case === "response_trailers" &&
      object.response?.response_trailers !== undefined &&
      object.response?.response_trailers !== null
    ) {
      message.response = {
        $case: "response_trailers",
        response_trailers: TrailersResponse.fromPartial(object.response.response_trailers),
      };
    }
    if (
      object.response?.$case === "immediate_response" &&
      object.response?.immediate_response !== undefined &&
      object.response?.immediate_response !== null
    ) {
      message.response = {
        $case: "immediate_response",
        immediate_response: ImmediateResponse.fromPartial(object.response.immediate_response),
      };
    }
    message.dynamic_metadata = object.dynamic_metadata ?? undefined;
    message.mode_override = (object.mode_override !== undefined && object.mode_override !== null)
      ? ProcessingMode.fromPartial(object.mode_override)
      : undefined;
    message.override_message_timeout =
      (object.override_message_timeout !== undefined && object.override_message_timeout !== null)
        ? Duration.fromPartial(object.override_message_timeout)
        : undefined;
    return message;
  },
};

messageTypeRegistry.set(ProcessingResponse.$type, ProcessingResponse);

function createBaseHttpHeaders(): HttpHeaders {
  return { $type: "envoy.service.ext_proc.v3.HttpHeaders" };
}

export const HttpHeaders: MessageFns<HttpHeaders, "envoy.service.ext_proc.v3.HttpHeaders"> = {
  $type: "envoy.service.ext_proc.v3.HttpHeaders" as const,

  encode(message: HttpHeaders, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.headers !== undefined) {
      HeaderMap.encode(message.headers, writer.uint32(10).fork()).join();
    }
    (message.attributes || new Map()).forEach((value, key) => {
      if (value !== undefined) {
        HttpHeaders_AttributesEntry.encode({
          $type: "envoy.service.ext_proc.v3.HttpHeaders.AttributesEntry",
          key: key as any,
          value,
        }, writer.uint32(18).fork()).join();
      }
    });
    if (message.end_of_stream !== undefined && message.end_of_stream !== false) {
      writer.uint32(24).bool(message.end_of_stream);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpHeaders {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpHeaders();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.headers = HeaderMap.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = HttpHeaders_AttributesEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            if (message.attributes === undefined) {
              message.attributes = new Map();
            }
            message.attributes!.set(entry2.key, entry2.value);
          }
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.end_of_stream = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpHeaders {
    return {
      $type: HttpHeaders.$type,
      headers: isSet(object.headers) ? HeaderMap.fromJSON(object.headers) : undefined,
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<Map<string, { [key: string]: any } | undefined>>(
          (acc, [key, value]) => {
            acc.set(key, value as { [key: string]: any } | undefined);
            return acc;
          },
          new Map(),
        )
        : undefined,
      end_of_stream: isSet(object.end_of_stream) ? globalThis.Boolean(object.end_of_stream) : undefined,
    };
  },

  toJSON(message: HttpHeaders): unknown {
    const obj: any = {};
    if (message.headers !== undefined) {
      obj.headers = HeaderMap.toJSON(message.headers);
    }
    if (message.attributes?.size) {
      obj.attributes = {};
      message.attributes.forEach((v, k) => {
        obj.attributes[k] = v;
      });
    }
    if (message.end_of_stream !== undefined) {
      obj.end_of_stream = message.end_of_stream;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpHeaders>, I>>(base?: I): HttpHeaders {
    return HttpHeaders.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpHeaders>, I>>(object: I): HttpHeaders {
    const message = createBaseHttpHeaders();
    message.headers = (object.headers !== undefined && object.headers !== null)
      ? HeaderMap.fromPartial(object.headers)
      : undefined;
    message.attributes = (object.attributes === undefined || object.attributes === null) ? undefined : (() => {
      const m = new Map();
      (object.attributes as Map<string, { [key: string]: any } | undefined> ?? new Map()).forEach((value, key) => {
        if (value !== undefined) {
          m.set(key, value);
        }
      });
      return m;
    })();
    message.end_of_stream = object.end_of_stream ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(HttpHeaders.$type, HttpHeaders);

function createBaseHttpHeaders_AttributesEntry(): HttpHeaders_AttributesEntry {
  return { $type: "envoy.service.ext_proc.v3.HttpHeaders.AttributesEntry", key: "" };
}

export const HttpHeaders_AttributesEntry: MessageFns<
  HttpHeaders_AttributesEntry,
  "envoy.service.ext_proc.v3.HttpHeaders.AttributesEntry"
> = {
  $type: "envoy.service.ext_proc.v3.HttpHeaders.AttributesEntry" as const,

  encode(message: HttpHeaders_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Struct.encode(Struct.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpHeaders_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpHeaders_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpHeaders_AttributesEntry {
    return {
      $type: HttpHeaders_AttributesEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isObject(object.value) ? object.value : undefined,
    };
  },

  toJSON(message: HttpHeaders_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpHeaders_AttributesEntry>, I>>(base?: I): HttpHeaders_AttributesEntry {
    return HttpHeaders_AttributesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpHeaders_AttributesEntry>, I>>(object: I): HttpHeaders_AttributesEntry {
    const message = createBaseHttpHeaders_AttributesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(HttpHeaders_AttributesEntry.$type, HttpHeaders_AttributesEntry);

function createBaseHttpBody(): HttpBody {
  return { $type: "envoy.service.ext_proc.v3.HttpBody" };
}

export const HttpBody: MessageFns<HttpBody, "envoy.service.ext_proc.v3.HttpBody"> = {
  $type: "envoy.service.ext_proc.v3.HttpBody" as const,

  encode(message: HttpBody, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.body !== undefined && message.body.length !== 0) {
      writer.uint32(10).bytes(message.body);
    }
    if (message.end_of_stream !== undefined && message.end_of_stream !== false) {
      writer.uint32(16).bool(message.end_of_stream);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpBody {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.body = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.end_of_stream = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpBody {
    return {
      $type: HttpBody.$type,
      body: isSet(object.body) ? bytesFromBase64(object.body) : undefined,
      end_of_stream: isSet(object.end_of_stream) ? globalThis.Boolean(object.end_of_stream) : undefined,
    };
  },

  toJSON(message: HttpBody): unknown {
    const obj: any = {};
    if (message.body !== undefined) {
      obj.body = base64FromBytes(message.body);
    }
    if (message.end_of_stream !== undefined) {
      obj.end_of_stream = message.end_of_stream;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpBody>, I>>(base?: I): HttpBody {
    return HttpBody.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpBody>, I>>(object: I): HttpBody {
    const message = createBaseHttpBody();
    message.body = object.body ?? undefined;
    message.end_of_stream = object.end_of_stream ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(HttpBody.$type, HttpBody);

function createBaseHttpTrailers(): HttpTrailers {
  return { $type: "envoy.service.ext_proc.v3.HttpTrailers" };
}

export const HttpTrailers: MessageFns<HttpTrailers, "envoy.service.ext_proc.v3.HttpTrailers"> = {
  $type: "envoy.service.ext_proc.v3.HttpTrailers" as const,

  encode(message: HttpTrailers, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trailers !== undefined) {
      HeaderMap.encode(message.trailers, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpTrailers {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpTrailers();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trailers = HeaderMap.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpTrailers {
    return {
      $type: HttpTrailers.$type,
      trailers: isSet(object.trailers) ? HeaderMap.fromJSON(object.trailers) : undefined,
    };
  },

  toJSON(message: HttpTrailers): unknown {
    const obj: any = {};
    if (message.trailers !== undefined) {
      obj.trailers = HeaderMap.toJSON(message.trailers);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpTrailers>, I>>(base?: I): HttpTrailers {
    return HttpTrailers.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpTrailers>, I>>(object: I): HttpTrailers {
    const message = createBaseHttpTrailers();
    message.trailers = (object.trailers !== undefined && object.trailers !== null)
      ? HeaderMap.fromPartial(object.trailers)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(HttpTrailers.$type, HttpTrailers);

function createBaseHeadersResponse(): HeadersResponse {
  return { $type: "envoy.service.ext_proc.v3.HeadersResponse" };
}

export const HeadersResponse: MessageFns<HeadersResponse, "envoy.service.ext_proc.v3.HeadersResponse"> = {
  $type: "envoy.service.ext_proc.v3.HeadersResponse" as const,

  encode(message: HeadersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.response !== undefined) {
      CommonResponse.encode(message.response, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeadersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeadersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.response = CommonResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeadersResponse {
    return {
      $type: HeadersResponse.$type,
      response: isSet(object.response) ? CommonResponse.fromJSON(object.response) : undefined,
    };
  },

  toJSON(message: HeadersResponse): unknown {
    const obj: any = {};
    if (message.response !== undefined) {
      obj.response = CommonResponse.toJSON(message.response);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HeadersResponse>, I>>(base?: I): HeadersResponse {
    return HeadersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HeadersResponse>, I>>(object: I): HeadersResponse {
    const message = createBaseHeadersResponse();
    message.response = (object.response !== undefined && object.response !== null)
      ? CommonResponse.fromPartial(object.response)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(HeadersResponse.$type, HeadersResponse);

function createBaseBodyResponse(): BodyResponse {
  return { $type: "envoy.service.ext_proc.v3.BodyResponse" };
}

export const BodyResponse: MessageFns<BodyResponse, "envoy.service.ext_proc.v3.BodyResponse"> = {
  $type: "envoy.service.ext_proc.v3.BodyResponse" as const,

  encode(message: BodyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.response !== undefined) {
      CommonResponse.encode(message.response, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BodyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBodyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.response = CommonResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BodyResponse {
    return {
      $type: BodyResponse.$type,
      response: isSet(object.response) ? CommonResponse.fromJSON(object.response) : undefined,
    };
  },

  toJSON(message: BodyResponse): unknown {
    const obj: any = {};
    if (message.response !== undefined) {
      obj.response = CommonResponse.toJSON(message.response);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BodyResponse>, I>>(base?: I): BodyResponse {
    return BodyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BodyResponse>, I>>(object: I): BodyResponse {
    const message = createBaseBodyResponse();
    message.response = (object.response !== undefined && object.response !== null)
      ? CommonResponse.fromPartial(object.response)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(BodyResponse.$type, BodyResponse);

function createBaseTrailersResponse(): TrailersResponse {
  return { $type: "envoy.service.ext_proc.v3.TrailersResponse" };
}

export const TrailersResponse: MessageFns<TrailersResponse, "envoy.service.ext_proc.v3.TrailersResponse"> = {
  $type: "envoy.service.ext_proc.v3.TrailersResponse" as const,

  encode(message: TrailersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header_mutation !== undefined) {
      HeaderMutation.encode(message.header_mutation, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrailersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrailersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header_mutation = HeaderMutation.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrailersResponse {
    return {
      $type: TrailersResponse.$type,
      header_mutation: isSet(object.header_mutation) ? HeaderMutation.fromJSON(object.header_mutation) : undefined,
    };
  },

  toJSON(message: TrailersResponse): unknown {
    const obj: any = {};
    if (message.header_mutation !== undefined) {
      obj.header_mutation = HeaderMutation.toJSON(message.header_mutation);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TrailersResponse>, I>>(base?: I): TrailersResponse {
    return TrailersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TrailersResponse>, I>>(object: I): TrailersResponse {
    const message = createBaseTrailersResponse();
    message.header_mutation = (object.header_mutation !== undefined && object.header_mutation !== null)
      ? HeaderMutation.fromPartial(object.header_mutation)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(TrailersResponse.$type, TrailersResponse);

function createBaseCommonResponse(): CommonResponse {
  return { $type: "envoy.service.ext_proc.v3.CommonResponse" };
}

export const CommonResponse: MessageFns<CommonResponse, "envoy.service.ext_proc.v3.CommonResponse"> = {
  $type: "envoy.service.ext_proc.v3.CommonResponse" as const,

  encode(message: CommonResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined && message.status !== CommonResponse_ResponseStatus.CONTINUE) {
      writer.uint32(8).int32(commonResponse_ResponseStatusToNumber(message.status));
    }
    if (message.header_mutation !== undefined) {
      HeaderMutation.encode(message.header_mutation, writer.uint32(18).fork()).join();
    }
    if (message.body_mutation !== undefined) {
      BodyMutation.encode(message.body_mutation, writer.uint32(26).fork()).join();
    }
    if (message.trailers !== undefined) {
      HeaderMap.encode(message.trailers, writer.uint32(34).fork()).join();
    }
    if (message.clear_route_cache !== undefined && message.clear_route_cache !== false) {
      writer.uint32(40).bool(message.clear_route_cache);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommonResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommonResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = commonResponse_ResponseStatusFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.header_mutation = HeaderMutation.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.body_mutation = BodyMutation.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.trailers = HeaderMap.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.clear_route_cache = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommonResponse {
    return {
      $type: CommonResponse.$type,
      status: isSet(object.status) ? commonResponse_ResponseStatusFromJSON(object.status) : undefined,
      header_mutation: isSet(object.header_mutation) ? HeaderMutation.fromJSON(object.header_mutation) : undefined,
      body_mutation: isSet(object.body_mutation) ? BodyMutation.fromJSON(object.body_mutation) : undefined,
      trailers: isSet(object.trailers) ? HeaderMap.fromJSON(object.trailers) : undefined,
      clear_route_cache: isSet(object.clear_route_cache) ? globalThis.Boolean(object.clear_route_cache) : undefined,
    };
  },

  toJSON(message: CommonResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = commonResponse_ResponseStatusToJSON(message.status);
    }
    if (message.header_mutation !== undefined) {
      obj.header_mutation = HeaderMutation.toJSON(message.header_mutation);
    }
    if (message.body_mutation !== undefined) {
      obj.body_mutation = BodyMutation.toJSON(message.body_mutation);
    }
    if (message.trailers !== undefined) {
      obj.trailers = HeaderMap.toJSON(message.trailers);
    }
    if (message.clear_route_cache !== undefined) {
      obj.clear_route_cache = message.clear_route_cache;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommonResponse>, I>>(base?: I): CommonResponse {
    return CommonResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommonResponse>, I>>(object: I): CommonResponse {
    const message = createBaseCommonResponse();
    message.status = object.status ?? undefined;
    message.header_mutation = (object.header_mutation !== undefined && object.header_mutation !== null)
      ? HeaderMutation.fromPartial(object.header_mutation)
      : undefined;
    message.body_mutation = (object.body_mutation !== undefined && object.body_mutation !== null)
      ? BodyMutation.fromPartial(object.body_mutation)
      : undefined;
    message.trailers = (object.trailers !== undefined && object.trailers !== null)
      ? HeaderMap.fromPartial(object.trailers)
      : undefined;
    message.clear_route_cache = object.clear_route_cache ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(CommonResponse.$type, CommonResponse);

function createBaseImmediateResponse(): ImmediateResponse {
  return { $type: "envoy.service.ext_proc.v3.ImmediateResponse" };
}

export const ImmediateResponse: MessageFns<ImmediateResponse, "envoy.service.ext_proc.v3.ImmediateResponse"> = {
  $type: "envoy.service.ext_proc.v3.ImmediateResponse" as const,

  encode(message: ImmediateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      HttpStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.headers !== undefined) {
      HeaderMutation.encode(message.headers, writer.uint32(18).fork()).join();
    }
    if (message.body !== undefined && message.body.length !== 0) {
      writer.uint32(26).bytes(message.body);
    }
    if (message.grpc_status !== undefined) {
      GrpcStatus.encode(message.grpc_status, writer.uint32(34).fork()).join();
    }
    if (message.details !== undefined && message.details !== "") {
      writer.uint32(42).string(message.details);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImmediateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImmediateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = HttpStatus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.headers = HeaderMutation.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.body = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.grpc_status = GrpcStatus.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.details = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImmediateResponse {
    return {
      $type: ImmediateResponse.$type,
      status: isSet(object.status) ? HttpStatus.fromJSON(object.status) : undefined,
      headers: isSet(object.headers) ? HeaderMutation.fromJSON(object.headers) : undefined,
      body: isSet(object.body) ? bytesFromBase64(object.body) : undefined,
      grpc_status: isSet(object.grpc_status) ? GrpcStatus.fromJSON(object.grpc_status) : undefined,
      details: isSet(object.details) ? globalThis.String(object.details) : undefined,
    };
  },

  toJSON(message: ImmediateResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = HttpStatus.toJSON(message.status);
    }
    if (message.headers !== undefined) {
      obj.headers = HeaderMutation.toJSON(message.headers);
    }
    if (message.body !== undefined) {
      obj.body = base64FromBytes(message.body);
    }
    if (message.grpc_status !== undefined) {
      obj.grpc_status = GrpcStatus.toJSON(message.grpc_status);
    }
    if (message.details !== undefined) {
      obj.details = message.details;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ImmediateResponse>, I>>(base?: I): ImmediateResponse {
    return ImmediateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ImmediateResponse>, I>>(object: I): ImmediateResponse {
    const message = createBaseImmediateResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? HttpStatus.fromPartial(object.status)
      : undefined;
    message.headers = (object.headers !== undefined && object.headers !== null)
      ? HeaderMutation.fromPartial(object.headers)
      : undefined;
    message.body = object.body ?? undefined;
    message.grpc_status = (object.grpc_status !== undefined && object.grpc_status !== null)
      ? GrpcStatus.fromPartial(object.grpc_status)
      : undefined;
    message.details = object.details ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ImmediateResponse.$type, ImmediateResponse);

function createBaseGrpcStatus(): GrpcStatus {
  return { $type: "envoy.service.ext_proc.v3.GrpcStatus" };
}

export const GrpcStatus: MessageFns<GrpcStatus, "envoy.service.ext_proc.v3.GrpcStatus"> = {
  $type: "envoy.service.ext_proc.v3.GrpcStatus" as const,

  encode(message: GrpcStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined && message.status !== 0) {
      writer.uint32(8).uint32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrpcStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrpcStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrpcStatus {
    return { $type: GrpcStatus.$type, status: isSet(object.status) ? globalThis.Number(object.status) : undefined };
  },

  toJSON(message: GrpcStatus): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Math.round(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GrpcStatus>, I>>(base?: I): GrpcStatus {
    return GrpcStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GrpcStatus>, I>>(object: I): GrpcStatus {
    const message = createBaseGrpcStatus();
    message.status = object.status ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(GrpcStatus.$type, GrpcStatus);

function createBaseHeaderMutation(): HeaderMutation {
  return { $type: "envoy.service.ext_proc.v3.HeaderMutation" };
}

export const HeaderMutation: MessageFns<HeaderMutation, "envoy.service.ext_proc.v3.HeaderMutation"> = {
  $type: "envoy.service.ext_proc.v3.HeaderMutation" as const,

  encode(message: HeaderMutation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.set_headers !== undefined && message.set_headers.length !== 0) {
      for (const v of message.set_headers) {
        HeaderValueOption.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    if (message.remove_headers !== undefined && message.remove_headers.length !== 0) {
      for (const v of message.remove_headers) {
        writer.uint32(18).string(v!);
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeaderMutation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeaderMutation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.set_headers === undefined) {
            message.set_headers = [];
          }
          const el = HeaderValueOption.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.set_headers!.push(el);
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.remove_headers === undefined) {
            message.remove_headers = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.remove_headers!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeaderMutation {
    return {
      $type: HeaderMutation.$type,
      set_headers: globalThis.Array.isArray(object?.set_headers)
        ? object.set_headers.map((e: any) => HeaderValueOption.fromJSON(e))
        : undefined,
      remove_headers: globalThis.Array.isArray(object?.remove_headers)
        ? object.remove_headers.map((e: any) => globalThis.String(e))
        : undefined,
    };
  },

  toJSON(message: HeaderMutation): unknown {
    const obj: any = {};
    if (message.set_headers?.length) {
      obj.set_headers = message.set_headers.map((e) => HeaderValueOption.toJSON(e));
    }
    if (message.remove_headers?.length) {
      obj.remove_headers = message.remove_headers;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HeaderMutation>, I>>(base?: I): HeaderMutation {
    return HeaderMutation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HeaderMutation>, I>>(object: I): HeaderMutation {
    const message = createBaseHeaderMutation();
    message.set_headers = object.set_headers?.map((e) => HeaderValueOption.fromPartial(e)) || undefined;
    message.remove_headers = object.remove_headers?.map((e) => e) || undefined;
    return message;
  },
};

messageTypeRegistry.set(HeaderMutation.$type, HeaderMutation);

function createBaseStreamedBodyResponse(): StreamedBodyResponse {
  return { $type: "envoy.service.ext_proc.v3.StreamedBodyResponse" };
}

export const StreamedBodyResponse: MessageFns<StreamedBodyResponse, "envoy.service.ext_proc.v3.StreamedBodyResponse"> =
  {
    $type: "envoy.service.ext_proc.v3.StreamedBodyResponse" as const,

    encode(message: StreamedBodyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
      if (message.body !== undefined && message.body.length !== 0) {
        writer.uint32(10).bytes(message.body);
      }
      if (message.end_of_stream !== undefined && message.end_of_stream !== false) {
        writer.uint32(16).bool(message.end_of_stream);
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): StreamedBodyResponse {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseStreamedBodyResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.body = reader.bytes();
            continue;
          }
          case 2: {
            if (tag !== 16) {
              break;
            }

            message.end_of_stream = reader.bool();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): StreamedBodyResponse {
      return {
        $type: StreamedBodyResponse.$type,
        body: isSet(object.body) ? bytesFromBase64(object.body) : undefined,
        end_of_stream: isSet(object.end_of_stream) ? globalThis.Boolean(object.end_of_stream) : undefined,
      };
    },

    toJSON(message: StreamedBodyResponse): unknown {
      const obj: any = {};
      if (message.body !== undefined) {
        obj.body = base64FromBytes(message.body);
      }
      if (message.end_of_stream !== undefined) {
        obj.end_of_stream = message.end_of_stream;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<StreamedBodyResponse>, I>>(base?: I): StreamedBodyResponse {
      return StreamedBodyResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<StreamedBodyResponse>, I>>(object: I): StreamedBodyResponse {
      const message = createBaseStreamedBodyResponse();
      message.body = object.body ?? undefined;
      message.end_of_stream = object.end_of_stream ?? undefined;
      return message;
    },
  };

messageTypeRegistry.set(StreamedBodyResponse.$type, StreamedBodyResponse);

function createBaseBodyMutation(): BodyMutation {
  return { $type: "envoy.service.ext_proc.v3.BodyMutation", mutation: undefined };
}

export const BodyMutation: MessageFns<BodyMutation, "envoy.service.ext_proc.v3.BodyMutation"> = {
  $type: "envoy.service.ext_proc.v3.BodyMutation" as const,

  encode(message: BodyMutation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.mutation?.$case) {
      case "body":
        writer.uint32(10).bytes(message.mutation.body);
        break;
      case "clear_body":
        writer.uint32(16).bool(message.mutation.clear_body);
        break;
      case "streamed_response":
        StreamedBodyResponse.encode(message.mutation.streamed_response, writer.uint32(26).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BodyMutation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBodyMutation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mutation = { $case: "body", body: reader.bytes() };
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.mutation = { $case: "clear_body", clear_body: reader.bool() };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.mutation = {
            $case: "streamed_response",
            streamed_response: StreamedBodyResponse.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BodyMutation {
    return {
      $type: BodyMutation.$type,
      mutation: isSet(object.body)
        ? { $case: "body", body: bytesFromBase64(object.body) }
        : isSet(object.clear_body)
        ? { $case: "clear_body", clear_body: globalThis.Boolean(object.clear_body) }
        : isSet(object.streamed_response)
        ? { $case: "streamed_response", streamed_response: StreamedBodyResponse.fromJSON(object.streamed_response) }
        : undefined,
    };
  },

  toJSON(message: BodyMutation): unknown {
    const obj: any = {};
    if (message.mutation?.$case === "body") {
      obj.body = base64FromBytes(message.mutation.body);
    }
    if (message.mutation?.$case === "clear_body") {
      obj.clear_body = message.mutation.clear_body;
    }
    if (message.mutation?.$case === "streamed_response") {
      obj.streamed_response = StreamedBodyResponse.toJSON(message.mutation.streamed_response);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BodyMutation>, I>>(base?: I): BodyMutation {
    return BodyMutation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BodyMutation>, I>>(object: I): BodyMutation {
    const message = createBaseBodyMutation();
    if (object.mutation?.$case === "body" && object.mutation?.body !== undefined && object.mutation?.body !== null) {
      message.mutation = { $case: "body", body: object.mutation.body };
    }
    if (
      object.mutation?.$case === "clear_body" &&
      object.mutation?.clear_body !== undefined &&
      object.mutation?.clear_body !== null
    ) {
      message.mutation = { $case: "clear_body", clear_body: object.mutation.clear_body };
    }
    if (
      object.mutation?.$case === "streamed_response" &&
      object.mutation?.streamed_response !== undefined &&
      object.mutation?.streamed_response !== null
    ) {
      message.mutation = {
        $case: "streamed_response",
        streamed_response: StreamedBodyResponse.fromPartial(object.mutation.streamed_response),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(BodyMutation.$type, BodyMutation);

/**
 * A service that can access and modify HTTP requests and responses
 * as part of a filter chain.
 * The overall external processing protocol works like this:
 *
 * 1. The data plane sends to the service information about the HTTP request.
 * 2. The service sends back a ProcessingResponse message that directs
 *    the data plane to either stop processing, continue without it, or send
 *    it the next chunk of the message body.
 * 3. If so requested, the data plane sends the server the message body in
 *    chunks, or the entire body at once. In either case, the server may send
 *    back a ProcessingResponse for each message it receives, or wait for
 *    a certain amount of body chunks received before streaming back the
 *    ProcessingResponse messages.
 * 4. If so requested, the data plane sends the server the HTTP trailers,
 *    and the server sends back a ProcessingResponse.
 * 5. At this point, request processing is done, and we pick up again
 *    at step 1 when the data plane receives a response from the upstream
 *    server.
 * 6. At any point above, if the server closes the gRPC stream cleanly,
 *    then the data plane proceeds without consulting the server.
 * 7. At any point above, if the server closes the gRPC stream with an error,
 *    then the data plane returns a 500 error to the client, unless the filter
 *    was configured to ignore errors.
 *
 * In other words, the process is a request/response conversation, but
 * using a gRPC stream to make it easier for the server to
 * maintain state.
 */
export interface ExternalProcessor {
  /**
   * This begins the bidirectional stream that the data plane will use to
   * give the server control over what the filter does. The actual
   * protocol is described by the ProcessingRequest and ProcessingResponse
   * messages below.
   */
  Process(request: Observable<ProcessingRequest>): Observable<ProcessingResponse>;
}

export const ExternalProcessorServiceName = "envoy.service.ext_proc.v3.ExternalProcessor";
export class ExternalProcessorClientImpl implements ExternalProcessor {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || ExternalProcessorServiceName;
    this.rpc = rpc;
    this.Process = this.Process.bind(this);
  }
  Process(request: Observable<ProcessingRequest>): Observable<ProcessingResponse> {
    const data = request.pipe(map((request) => ProcessingRequest.encode(request).finish()));
    const result = this.rpc.bidirectionalStreamingRequest(this.service, "Process", data);
    return result.pipe(map((data) => ProcessingResponse.decode(new BinaryReader(data))));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
  clientStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Promise<Uint8Array>;
  serverStreamingRequest(service: string, method: string, data: Uint8Array): Observable<Uint8Array>;
  bidirectionalStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Observable<Uint8Array>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
