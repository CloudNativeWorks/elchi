// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/admin/v3/clusters.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { messageTypeRegistry } from "../../../typeRegistry";
import { CircuitBreakers } from "../../config/cluster/v3/circuit_breaker";
import { Address } from "../../config/core/v3/address";
import { Locality } from "../../config/core/v3/base";
import {
  HealthStatus,
  healthStatusFromJSON,
  healthStatusToJSON,
  healthStatusToNumber,
} from "../../config/core/v3/health_check";
import { Percent } from "../../type/v3/percent";
import { SimpleMetric } from "./metrics";

export const protobufPackage = "envoy.admin.v3";

/**
 * Admin endpoint uses this wrapper for ``/clusters`` to display cluster status information.
 * See :ref:`/clusters <operations_admin_interface_clusters>` for more information.
 */
export interface Clusters {
  $type: "envoy.admin.v3.Clusters";
  /** Mapping from cluster name to each cluster's status. */
  cluster_statuses?: ClusterStatus[] | undefined;
}

/**
 * Details an individual cluster's current status.
 * [#next-free-field: 9]
 */
export interface ClusterStatus {
  $type: "envoy.admin.v3.ClusterStatus";
  /** Name of the cluster. */
  name?:
    | string
    | undefined;
  /** Denotes whether this cluster was added via API or configured statically. */
  added_via_api?:
    | boolean
    | undefined;
  /**
   * The success rate threshold used in the last interval.
   *
   * * If :ref:`outlier_detection.split_external_local_origin_errors<envoy_v3_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
   *   is ``false``, all errors: externally and locally generated were used to calculate the threshold.
   * * If :ref:`outlier_detection.split_external_local_origin_errors<envoy_v3_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
   *   is ``true``, only externally generated errors were used to calculate the threshold.
   *
   * The threshold is used to eject hosts based on their success rate. For more information, see the
   * :ref:`Cluster outlier detection <arch_overview_outlier_detection>` documentation.
   *
   * .. note::
   *
   *   This field may be omitted in any of the three following cases:
   *
   *   1. There were not enough hosts with enough request volume to proceed with success rate based outlier ejection.
   *   2. The threshold is computed to be < 0 because a negative value implies that there was no threshold for that
   *      interval.
   *   3. Outlier detection is not enabled for this cluster.
   */
  success_rate_ejection_threshold?:
    | Percent
    | undefined;
  /** Mapping from host address to the host's current status. */
  host_statuses?:
    | HostStatus[]
    | undefined;
  /**
   * The success rate threshold used in the last interval when only locally originated failures were
   * taken into account and externally originated errors were treated as success.
   * This field should be interpreted only when
   * :ref:`outlier_detection.split_external_local_origin_errors<envoy_v3_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
   * is ``true``. The threshold is used to eject hosts based on their success rate.
   *
   * For more information, see the :ref:`Cluster outlier detection <arch_overview_outlier_detection>` documentation.
   *
   * .. note::
   *
   *   This field may be omitted in any of the three following cases:
   *
   *   1. There were not enough hosts with enough request volume to proceed with success rate based outlier ejection.
   *   2. The threshold is computed to be < 0 because a negative value implies that there was no threshold for that
   *      interval.
   *   3. Outlier detection is not enabled for this cluster.
   */
  local_origin_success_rate_ejection_threshold?:
    | Percent
    | undefined;
  /** :ref:`Circuit breaking <arch_overview_circuit_break>` settings of the cluster. */
  circuit_breakers?:
    | CircuitBreakers
    | undefined;
  /** Observability name of the cluster. */
  observability_name?:
    | string
    | undefined;
  /** The :ref:`EDS service name <envoy_v3_api_field_config.cluster.v3.Cluster.EdsClusterConfig.service_name>` if the cluster is an EDS cluster. */
  eds_service_name?: string | undefined;
}

/**
 * Current state of a particular host.
 * [#next-free-field: 10]
 */
export interface HostStatus {
  $type: "envoy.admin.v3.HostStatus";
  /** Address of this host. */
  address?:
    | Address
    | undefined;
  /** List of stats specific to this host. */
  stats?:
    | SimpleMetric[]
    | undefined;
  /** The host's current health status. */
  health_status?:
    | HostHealthStatus
    | undefined;
  /**
   * The success rate for this host during the last measurement interval.
   *
   * * If :ref:`outlier_detection.split_external_local_origin_errors<envoy_v3_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
   *   is ``false``, all errors: externally and locally generated were used in success rate calculation.
   * * If :ref:`outlier_detection.split_external_local_origin_errors<envoy_v3_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
   *   is ``true``, only externally generated errors were used in success rate calculation.
   *
   * For more information, see the :ref:`Cluster outlier detection <arch_overview_outlier_detection>` documentation.
   *
   * .. note::
   *
   *   The message will be missing if the host didn't receive enough traffic to calculate a reliable success rate, or
   *   if the cluster had too few hosts to apply outlier ejection based on success rate.
   */
  success_rate?:
    | Percent
    | undefined;
  /** The host's weight. If not configured, the value defaults to 1. */
  weight?:
    | number
    | undefined;
  /** The hostname of the host, if applicable. */
  hostname?:
    | string
    | undefined;
  /** The host's priority. If not configured, the value defaults to 0 (highest priority). */
  priority?:
    | number
    | undefined;
  /**
   * The success rate for this host during the last interval, considering only locally generated errors. Externally
   * generated errors are treated as successes.
   *
   * This field is only relevant when
   * :ref:`outlier_detection.split_external_local_origin_errors<envoy_v3_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
   * is set to ``true``.
   *
   * For more information, see the :ref:`Cluster outlier detection <arch_overview_outlier_detection>` documentation.
   *
   * .. note::
   *
   *   The message will be missing if the host didn't receive enough traffic to compute a success rate, or if the
   *   cluster didn't have enough hosts to perform outlier ejection based on success rate.
   */
  local_origin_success_rate?:
    | Percent
    | undefined;
  /** locality of the host. */
  locality?: Locality | undefined;
}

/**
 * Health status for a host.
 * [#next-free-field: 9]
 */
export interface HostHealthStatus {
  $type: "envoy.admin.v3.HostHealthStatus";
  /** The host is currently failing active health checks. */
  failed_active_health_check?:
    | boolean
    | undefined;
  /** The host is currently considered an outlier and has been ejected. */
  failed_outlier_check?:
    | boolean
    | undefined;
  /** The host is currently being marked as degraded through active health checking. */
  failed_active_degraded_check?:
    | boolean
    | undefined;
  /**
   * The host has been removed from service discovery, but is being stabilized due to active
   * health checking.
   */
  pending_dynamic_removal?:
    | boolean
    | undefined;
  /** The host is awaiting first health check. */
  pending_active_hc?:
    | boolean
    | undefined;
  /**
   * The host should be excluded from panic, spillover, etc. calculations because it was explicitly
   * taken out of rotation via protocol signal and is not meant to be routed to.
   */
  excluded_via_immediate_hc_fail?:
    | boolean
    | undefined;
  /** The host failed active health check due to timeout. */
  active_hc_timeout?:
    | boolean
    | undefined;
  /**
   * Health status as reported by EDS.
   *
   * .. note::
   *
   *   Currently, only ``HEALTHY`` and ``UNHEALTHY`` are supported.
   *
   * [#comment:TODO(mrice32): pipe through remaining EDS health status possibilities.]
   */
  eds_health_status?: HealthStatus | undefined;
}

function createBaseClusters(): Clusters {
  return { $type: "envoy.admin.v3.Clusters" };
}

export const Clusters: MessageFns<Clusters, "envoy.admin.v3.Clusters"> = {
  $type: "envoy.admin.v3.Clusters" as const,

  encode(message: Clusters, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cluster_statuses !== undefined && message.cluster_statuses.length !== 0) {
      for (const v of message.cluster_statuses) {
        ClusterStatus.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Clusters {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClusters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.cluster_statuses === undefined) {
            message.cluster_statuses = [];
          }
          const el = ClusterStatus.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.cluster_statuses!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Clusters {
    return {
      $type: Clusters.$type,
      cluster_statuses: globalThis.Array.isArray(object?.cluster_statuses)
        ? object.cluster_statuses.map((e: any) => ClusterStatus.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: Clusters): unknown {
    const obj: any = {};
    if (message.cluster_statuses?.length) {
      obj.cluster_statuses = message.cluster_statuses.map((e) => ClusterStatus.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Clusters>, I>>(base?: I): Clusters {
    return Clusters.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Clusters>, I>>(object: I): Clusters {
    const message = createBaseClusters();
    message.cluster_statuses = object.cluster_statuses?.map((e) => ClusterStatus.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(Clusters.$type, Clusters);

function createBaseClusterStatus(): ClusterStatus {
  return { $type: "envoy.admin.v3.ClusterStatus" };
}

export const ClusterStatus: MessageFns<ClusterStatus, "envoy.admin.v3.ClusterStatus"> = {
  $type: "envoy.admin.v3.ClusterStatus" as const,

  encode(message: ClusterStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.added_via_api !== undefined && message.added_via_api !== false) {
      writer.uint32(16).bool(message.added_via_api);
    }
    if (message.success_rate_ejection_threshold !== undefined) {
      Percent.encode(message.success_rate_ejection_threshold, writer.uint32(26).fork()).join();
    }
    if (message.host_statuses !== undefined && message.host_statuses.length !== 0) {
      for (const v of message.host_statuses) {
        HostStatus.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    if (message.local_origin_success_rate_ejection_threshold !== undefined) {
      Percent.encode(message.local_origin_success_rate_ejection_threshold, writer.uint32(42).fork()).join();
    }
    if (message.circuit_breakers !== undefined) {
      CircuitBreakers.encode(message.circuit_breakers, writer.uint32(50).fork()).join();
    }
    if (message.observability_name !== undefined && message.observability_name !== "") {
      writer.uint32(58).string(message.observability_name);
    }
    if (message.eds_service_name !== undefined && message.eds_service_name !== "") {
      writer.uint32(66).string(message.eds_service_name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClusterStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClusterStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.added_via_api = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.success_rate_ejection_threshold = Percent.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          if (message.host_statuses === undefined) {
            message.host_statuses = [];
          }
          const el = HostStatus.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.host_statuses!.push(el);
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.local_origin_success_rate_ejection_threshold = Percent.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.circuit_breakers = CircuitBreakers.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.observability_name = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.eds_service_name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClusterStatus {
    return {
      $type: ClusterStatus.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      added_via_api: isSet(object.added_via_api) ? globalThis.Boolean(object.added_via_api) : undefined,
      success_rate_ejection_threshold: isSet(object.success_rate_ejection_threshold)
        ? Percent.fromJSON(object.success_rate_ejection_threshold)
        : undefined,
      host_statuses: globalThis.Array.isArray(object?.host_statuses)
        ? object.host_statuses.map((e: any) => HostStatus.fromJSON(e))
        : undefined,
      local_origin_success_rate_ejection_threshold: isSet(object.local_origin_success_rate_ejection_threshold)
        ? Percent.fromJSON(object.local_origin_success_rate_ejection_threshold)
        : undefined,
      circuit_breakers: isSet(object.circuit_breakers) ? CircuitBreakers.fromJSON(object.circuit_breakers) : undefined,
      observability_name: isSet(object.observability_name) ? globalThis.String(object.observability_name) : undefined,
      eds_service_name: isSet(object.eds_service_name) ? globalThis.String(object.eds_service_name) : undefined,
    };
  },

  toJSON(message: ClusterStatus): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.added_via_api !== undefined) {
      obj.added_via_api = message.added_via_api;
    }
    if (message.success_rate_ejection_threshold !== undefined) {
      obj.success_rate_ejection_threshold = Percent.toJSON(message.success_rate_ejection_threshold);
    }
    if (message.host_statuses?.length) {
      obj.host_statuses = message.host_statuses.map((e) => HostStatus.toJSON(e));
    }
    if (message.local_origin_success_rate_ejection_threshold !== undefined) {
      obj.local_origin_success_rate_ejection_threshold = Percent.toJSON(
        message.local_origin_success_rate_ejection_threshold,
      );
    }
    if (message.circuit_breakers !== undefined) {
      obj.circuit_breakers = CircuitBreakers.toJSON(message.circuit_breakers);
    }
    if (message.observability_name !== undefined) {
      obj.observability_name = message.observability_name;
    }
    if (message.eds_service_name !== undefined) {
      obj.eds_service_name = message.eds_service_name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClusterStatus>, I>>(base?: I): ClusterStatus {
    return ClusterStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClusterStatus>, I>>(object: I): ClusterStatus {
    const message = createBaseClusterStatus();
    message.name = object.name ?? undefined;
    message.added_via_api = object.added_via_api ?? undefined;
    message.success_rate_ejection_threshold =
      (object.success_rate_ejection_threshold !== undefined && object.success_rate_ejection_threshold !== null)
        ? Percent.fromPartial(object.success_rate_ejection_threshold)
        : undefined;
    message.host_statuses = object.host_statuses?.map((e) => HostStatus.fromPartial(e)) || undefined;
    message.local_origin_success_rate_ejection_threshold =
      (object.local_origin_success_rate_ejection_threshold !== undefined &&
          object.local_origin_success_rate_ejection_threshold !== null)
        ? Percent.fromPartial(object.local_origin_success_rate_ejection_threshold)
        : undefined;
    message.circuit_breakers = (object.circuit_breakers !== undefined && object.circuit_breakers !== null)
      ? CircuitBreakers.fromPartial(object.circuit_breakers)
      : undefined;
    message.observability_name = object.observability_name ?? undefined;
    message.eds_service_name = object.eds_service_name ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ClusterStatus.$type, ClusterStatus);

function createBaseHostStatus(): HostStatus {
  return { $type: "envoy.admin.v3.HostStatus" };
}

export const HostStatus: MessageFns<HostStatus, "envoy.admin.v3.HostStatus"> = {
  $type: "envoy.admin.v3.HostStatus" as const,

  encode(message: HostStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== undefined) {
      Address.encode(message.address, writer.uint32(10).fork()).join();
    }
    if (message.stats !== undefined && message.stats.length !== 0) {
      for (const v of message.stats) {
        SimpleMetric.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.health_status !== undefined) {
      HostHealthStatus.encode(message.health_status, writer.uint32(26).fork()).join();
    }
    if (message.success_rate !== undefined) {
      Percent.encode(message.success_rate, writer.uint32(34).fork()).join();
    }
    if (message.weight !== undefined && message.weight !== 0) {
      writer.uint32(40).uint32(message.weight);
    }
    if (message.hostname !== undefined && message.hostname !== "") {
      writer.uint32(50).string(message.hostname);
    }
    if (message.priority !== undefined && message.priority !== 0) {
      writer.uint32(56).uint32(message.priority);
    }
    if (message.local_origin_success_rate !== undefined) {
      Percent.encode(message.local_origin_success_rate, writer.uint32(66).fork()).join();
    }
    if (message.locality !== undefined) {
      Locality.encode(message.locality, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HostStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHostStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = Address.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.stats === undefined) {
            message.stats = [];
          }
          const el = SimpleMetric.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.stats!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.health_status = HostHealthStatus.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.success_rate = Percent.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.weight = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.hostname = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.priority = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.local_origin_success_rate = Percent.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.locality = Locality.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HostStatus {
    return {
      $type: HostStatus.$type,
      address: isSet(object.address) ? Address.fromJSON(object.address) : undefined,
      stats: globalThis.Array.isArray(object?.stats)
        ? object.stats.map((e: any) => SimpleMetric.fromJSON(e))
        : undefined,
      health_status: isSet(object.health_status) ? HostHealthStatus.fromJSON(object.health_status) : undefined,
      success_rate: isSet(object.success_rate) ? Percent.fromJSON(object.success_rate) : undefined,
      weight: isSet(object.weight) ? globalThis.Number(object.weight) : undefined,
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : undefined,
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : undefined,
      local_origin_success_rate: isSet(object.local_origin_success_rate)
        ? Percent.fromJSON(object.local_origin_success_rate)
        : undefined,
      locality: isSet(object.locality) ? Locality.fromJSON(object.locality) : undefined,
    };
  },

  toJSON(message: HostStatus): unknown {
    const obj: any = {};
    if (message.address !== undefined) {
      obj.address = Address.toJSON(message.address);
    }
    if (message.stats?.length) {
      obj.stats = message.stats.map((e) => SimpleMetric.toJSON(e));
    }
    if (message.health_status !== undefined) {
      obj.health_status = HostHealthStatus.toJSON(message.health_status);
    }
    if (message.success_rate !== undefined) {
      obj.success_rate = Percent.toJSON(message.success_rate);
    }
    if (message.weight !== undefined) {
      obj.weight = Math.round(message.weight);
    }
    if (message.hostname !== undefined) {
      obj.hostname = message.hostname;
    }
    if (message.priority !== undefined) {
      obj.priority = Math.round(message.priority);
    }
    if (message.local_origin_success_rate !== undefined) {
      obj.local_origin_success_rate = Percent.toJSON(message.local_origin_success_rate);
    }
    if (message.locality !== undefined) {
      obj.locality = Locality.toJSON(message.locality);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HostStatus>, I>>(base?: I): HostStatus {
    return HostStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HostStatus>, I>>(object: I): HostStatus {
    const message = createBaseHostStatus();
    message.address = (object.address !== undefined && object.address !== null)
      ? Address.fromPartial(object.address)
      : undefined;
    message.stats = object.stats?.map((e) => SimpleMetric.fromPartial(e)) || undefined;
    message.health_status = (object.health_status !== undefined && object.health_status !== null)
      ? HostHealthStatus.fromPartial(object.health_status)
      : undefined;
    message.success_rate = (object.success_rate !== undefined && object.success_rate !== null)
      ? Percent.fromPartial(object.success_rate)
      : undefined;
    message.weight = object.weight ?? undefined;
    message.hostname = object.hostname ?? undefined;
    message.priority = object.priority ?? undefined;
    message.local_origin_success_rate =
      (object.local_origin_success_rate !== undefined && object.local_origin_success_rate !== null)
        ? Percent.fromPartial(object.local_origin_success_rate)
        : undefined;
    message.locality = (object.locality !== undefined && object.locality !== null)
      ? Locality.fromPartial(object.locality)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(HostStatus.$type, HostStatus);

function createBaseHostHealthStatus(): HostHealthStatus {
  return { $type: "envoy.admin.v3.HostHealthStatus" };
}

export const HostHealthStatus: MessageFns<HostHealthStatus, "envoy.admin.v3.HostHealthStatus"> = {
  $type: "envoy.admin.v3.HostHealthStatus" as const,

  encode(message: HostHealthStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.failed_active_health_check !== undefined && message.failed_active_health_check !== false) {
      writer.uint32(8).bool(message.failed_active_health_check);
    }
    if (message.failed_outlier_check !== undefined && message.failed_outlier_check !== false) {
      writer.uint32(16).bool(message.failed_outlier_check);
    }
    if (message.failed_active_degraded_check !== undefined && message.failed_active_degraded_check !== false) {
      writer.uint32(32).bool(message.failed_active_degraded_check);
    }
    if (message.pending_dynamic_removal !== undefined && message.pending_dynamic_removal !== false) {
      writer.uint32(40).bool(message.pending_dynamic_removal);
    }
    if (message.pending_active_hc !== undefined && message.pending_active_hc !== false) {
      writer.uint32(48).bool(message.pending_active_hc);
    }
    if (message.excluded_via_immediate_hc_fail !== undefined && message.excluded_via_immediate_hc_fail !== false) {
      writer.uint32(56).bool(message.excluded_via_immediate_hc_fail);
    }
    if (message.active_hc_timeout !== undefined && message.active_hc_timeout !== false) {
      writer.uint32(64).bool(message.active_hc_timeout);
    }
    if (message.eds_health_status !== undefined && message.eds_health_status !== HealthStatus.UNKNOWN) {
      writer.uint32(24).int32(healthStatusToNumber(message.eds_health_status));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HostHealthStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHostHealthStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.failed_active_health_check = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.failed_outlier_check = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.failed_active_degraded_check = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.pending_dynamic_removal = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.pending_active_hc = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.excluded_via_immediate_hc_fail = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.active_hc_timeout = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.eds_health_status = healthStatusFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HostHealthStatus {
    return {
      $type: HostHealthStatus.$type,
      failed_active_health_check: isSet(object.failed_active_health_check)
        ? globalThis.Boolean(object.failed_active_health_check)
        : undefined,
      failed_outlier_check: isSet(object.failed_outlier_check)
        ? globalThis.Boolean(object.failed_outlier_check)
        : undefined,
      failed_active_degraded_check: isSet(object.failed_active_degraded_check)
        ? globalThis.Boolean(object.failed_active_degraded_check)
        : undefined,
      pending_dynamic_removal: isSet(object.pending_dynamic_removal)
        ? globalThis.Boolean(object.pending_dynamic_removal)
        : undefined,
      pending_active_hc: isSet(object.pending_active_hc) ? globalThis.Boolean(object.pending_active_hc) : undefined,
      excluded_via_immediate_hc_fail: isSet(object.excluded_via_immediate_hc_fail)
        ? globalThis.Boolean(object.excluded_via_immediate_hc_fail)
        : undefined,
      active_hc_timeout: isSet(object.active_hc_timeout) ? globalThis.Boolean(object.active_hc_timeout) : undefined,
      eds_health_status: isSet(object.eds_health_status) ? healthStatusFromJSON(object.eds_health_status) : undefined,
    };
  },

  toJSON(message: HostHealthStatus): unknown {
    const obj: any = {};
    if (message.failed_active_health_check !== undefined) {
      obj.failed_active_health_check = message.failed_active_health_check;
    }
    if (message.failed_outlier_check !== undefined) {
      obj.failed_outlier_check = message.failed_outlier_check;
    }
    if (message.failed_active_degraded_check !== undefined) {
      obj.failed_active_degraded_check = message.failed_active_degraded_check;
    }
    if (message.pending_dynamic_removal !== undefined) {
      obj.pending_dynamic_removal = message.pending_dynamic_removal;
    }
    if (message.pending_active_hc !== undefined) {
      obj.pending_active_hc = message.pending_active_hc;
    }
    if (message.excluded_via_immediate_hc_fail !== undefined) {
      obj.excluded_via_immediate_hc_fail = message.excluded_via_immediate_hc_fail;
    }
    if (message.active_hc_timeout !== undefined) {
      obj.active_hc_timeout = message.active_hc_timeout;
    }
    if (message.eds_health_status !== undefined) {
      obj.eds_health_status = healthStatusToJSON(message.eds_health_status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HostHealthStatus>, I>>(base?: I): HostHealthStatus {
    return HostHealthStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HostHealthStatus>, I>>(object: I): HostHealthStatus {
    const message = createBaseHostHealthStatus();
    message.failed_active_health_check = object.failed_active_health_check ?? undefined;
    message.failed_outlier_check = object.failed_outlier_check ?? undefined;
    message.failed_active_degraded_check = object.failed_active_degraded_check ?? undefined;
    message.pending_dynamic_removal = object.pending_dynamic_removal ?? undefined;
    message.pending_active_hc = object.pending_active_hc ?? undefined;
    message.excluded_via_immediate_hc_fail = object.excluded_via_immediate_hc_fail ?? undefined;
    message.active_hc_timeout = object.active_hc_timeout ?? undefined;
    message.eds_health_status = object.eds_health_status ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(HostHealthStatus.$type, HostHealthStatus);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
