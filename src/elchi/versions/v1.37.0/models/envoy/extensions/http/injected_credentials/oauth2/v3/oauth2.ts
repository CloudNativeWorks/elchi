// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/http/injected_credentials/oauth2/v3/oauth2.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../../../../google/protobuf/duration";
import { messageTypeRegistry } from "../../../../../../typeRegistry";
import { HttpUri } from "../../../../../config/core/v3/http_uri";
import { SdsSecretConfig } from "../../../../transport_sockets/tls/v3/secret";

export const protobufPackage = "envoy.extensions.http.injected_credentials.oauth2.v3";

/**
 * OAuth2 extension can be used to retrieve an OAuth2 access token from an authorization server and inject it into the
 * proxied requests.
 * Currently, only the Client Credentials Grant flow is supported.
 * The access token will be injected into the request headers using the ``Authorization`` header as a bearer token.
 * [#next-free-field: 6]
 */
export interface OAuth2 {
  $type: "envoy.extensions.http.injected_credentials.oauth2.v3.OAuth2";
  /**
   * Endpoint on the authorization server to retrieve the access token from.
   * Refer to [RFC 6749: The OAuth 2.0 Authorization Framework](https://www.rfc-editor.org/rfc/rfc6749#section-3.2) for details.
   */
  token_endpoint?:
    | HttpUri
    | undefined;
  /**
   * Optional list of OAuth scopes to be claimed in the authorization request.
   * Refer to [RFC 6749: The OAuth 2.0 Authorization Framework](https://www.rfc-editor.org/rfc/rfc6749#section-4.4.2) for details.
   */
  scopes?: string[] | undefined;
  flow_type?:
    | //
    /**
     * Client Credentials Grant.
     * Refer to [RFC 6749: The OAuth 2.0 Authorization Framework](https://www.rfc-editor.org/rfc/rfc6749#section-4.4) for details.
     */
    { $case: "client_credentials"; client_credentials: OAuth2_ClientCredentials }
    | undefined;
  /**
   * The interval between two successive retries to fetch token from Identity Provider. Default is 2 secs.
   * The interval must be at least 1 second.
   */
  token_fetch_retry_interval?:
    | Duration
    | undefined;
  /**
   * Optional list of additional parameters to send to the token endpoint.
   * These parameters will be URL-encoded and included in the token request body.
   */
  endpoint_params?: OAuth2_EndpointParameter[] | undefined;
}

export enum OAuth2_AuthType {
  /** BASIC_AUTH - The ``client_id`` and ``client_secret`` will be sent using HTTP Basic authentication scheme. */
  BASIC_AUTH = "BASIC_AUTH",
  /**
   * URL_ENCODED_BODY - The ``client_id`` and ``client_secret`` will be sent in the URL encoded request body.
   * This type should only be used when Auth server does not support Basic authentication.
   */
  URL_ENCODED_BODY = "URL_ENCODED_BODY",
}

export function oAuth2_AuthTypeFromJSON(object: any): OAuth2_AuthType {
  switch (object) {
    case 0:
    case "BASIC_AUTH":
      return OAuth2_AuthType.BASIC_AUTH;
    case 1:
    case "URL_ENCODED_BODY":
      return OAuth2_AuthType.URL_ENCODED_BODY;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum OAuth2_AuthType");
  }
}

export function oAuth2_AuthTypeToJSON(object: OAuth2_AuthType): string {
  switch (object) {
    case OAuth2_AuthType.BASIC_AUTH:
      return "BASIC_AUTH";
    case OAuth2_AuthType.URL_ENCODED_BODY:
      return "URL_ENCODED_BODY";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum OAuth2_AuthType");
  }
}

export function oAuth2_AuthTypeToNumber(object: OAuth2_AuthType): number {
  switch (object) {
    case OAuth2_AuthType.BASIC_AUTH:
      return 0;
    case OAuth2_AuthType.URL_ENCODED_BODY:
      return 1;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum OAuth2_AuthType");
  }
}

/**
 * Credentials to authenticate client to the authorization server.
 * Refer to [RFC 6749: The OAuth 2.0 Authorization Framework](https://www.rfc-editor.org/rfc/rfc6749#section-2.3) for details.
 */
export interface OAuth2_ClientCredentials {
  $type: "envoy.extensions.http.injected_credentials.oauth2.v3.OAuth2.ClientCredentials";
  /**
   * Client ID.
   * Refer to [RFC 6749: The OAuth 2.0 Authorization Framework](https://www.rfc-editor.org/rfc/rfc6749#section-2.3.1) for details.
   */
  client_id?:
    | string
    | undefined;
  /**
   * Client secret.
   * Refer to [RFC 6749: The OAuth 2.0 Authorization Framework](https://www.rfc-editor.org/rfc/rfc6749#section-2.3.1) for details.
   */
  client_secret?:
    | SdsSecretConfig
    | undefined;
  /**
   * The method to use when sending credentials to the authorization server.
   * Refer to [RFC 6749: The OAuth 2.0 Authorization Framework](https://www.rfc-editor.org/rfc/rfc6749#section-2.3.1) for details.
   */
  auth_type?: OAuth2_AuthType | undefined;
}

/**
 * Optional additional parameters to include in the token endpoint request body.
 * These parameters will be URL-encoded and added to the request body along with the standard OAuth2 parameters.
 * Refer to your authorization server's documentation for supported parameters.
 */
export interface OAuth2_EndpointParameter {
  $type: "envoy.extensions.http.injected_credentials.oauth2.v3.OAuth2.EndpointParameter";
  /** Parameter name. */
  name?:
    | string
    | undefined;
  /** Parameter value. */
  value?: string | undefined;
}

function createBaseOAuth2(): OAuth2 {
  return { $type: "envoy.extensions.http.injected_credentials.oauth2.v3.OAuth2", flow_type: undefined };
}

export const OAuth2: MessageFns<OAuth2, "envoy.extensions.http.injected_credentials.oauth2.v3.OAuth2"> = {
  $type: "envoy.extensions.http.injected_credentials.oauth2.v3.OAuth2" as const,

  encode(message: OAuth2, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token_endpoint !== undefined) {
      HttpUri.encode(message.token_endpoint, writer.uint32(10).fork()).join();
    }
    if (message.scopes !== undefined && message.scopes.length !== 0) {
      for (const v of message.scopes) {
        writer.uint32(18).string(v!);
      }
    }
    switch (message.flow_type?.$case) {
      case "client_credentials":
        OAuth2_ClientCredentials.encode(message.flow_type.client_credentials, writer.uint32(26).fork()).join();
        break;
    }
    if (message.token_fetch_retry_interval !== undefined) {
      Duration.encode(message.token_fetch_retry_interval, writer.uint32(34).fork()).join();
    }
    if (message.endpoint_params !== undefined && message.endpoint_params.length !== 0) {
      for (const v of message.endpoint_params) {
        OAuth2_EndpointParameter.encode(v!, writer.uint32(42).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OAuth2 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOAuth2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token_endpoint = HttpUri.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.scopes === undefined) {
            message.scopes = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.scopes!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.flow_type = {
            $case: "client_credentials",
            client_credentials: OAuth2_ClientCredentials.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.token_fetch_retry_interval = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          if (message.endpoint_params === undefined) {
            message.endpoint_params = [];
          }
          const el = OAuth2_EndpointParameter.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.endpoint_params!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OAuth2 {
    return {
      $type: OAuth2.$type,
      token_endpoint: isSet(object.token_endpoint) ? HttpUri.fromJSON(object.token_endpoint) : undefined,
      scopes: globalThis.Array.isArray(object?.scopes)
        ? object.scopes.map((e: any) => globalThis.String(e))
        : undefined,
      flow_type: isSet(object.client_credentials)
        ? {
          $case: "client_credentials",
          client_credentials: OAuth2_ClientCredentials.fromJSON(object.client_credentials),
        }
        : undefined,
      token_fetch_retry_interval: isSet(object.token_fetch_retry_interval)
        ? Duration.fromJSON(object.token_fetch_retry_interval)
        : undefined,
      endpoint_params: globalThis.Array.isArray(object?.endpoint_params)
        ? object.endpoint_params.map((e: any) => OAuth2_EndpointParameter.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: OAuth2): unknown {
    const obj: any = {};
    if (message.token_endpoint !== undefined) {
      obj.token_endpoint = HttpUri.toJSON(message.token_endpoint);
    }
    if (message.scopes?.length) {
      obj.scopes = message.scopes;
    }
    if (message.flow_type?.$case === "client_credentials") {
      obj.client_credentials = OAuth2_ClientCredentials.toJSON(message.flow_type.client_credentials);
    }
    if (message.token_fetch_retry_interval !== undefined) {
      obj.token_fetch_retry_interval = Duration.toJSON(message.token_fetch_retry_interval);
    }
    if (message.endpoint_params?.length) {
      obj.endpoint_params = message.endpoint_params.map((e) => OAuth2_EndpointParameter.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OAuth2>, I>>(base?: I): OAuth2 {
    return OAuth2.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OAuth2>, I>>(object: I): OAuth2 {
    const message = createBaseOAuth2();
    message.token_endpoint = (object.token_endpoint !== undefined && object.token_endpoint !== null)
      ? HttpUri.fromPartial(object.token_endpoint)
      : undefined;
    message.scopes = object.scopes?.map((e) => e) || undefined;
    if (
      object.flow_type?.$case === "client_credentials" &&
      object.flow_type?.client_credentials !== undefined &&
      object.flow_type?.client_credentials !== null
    ) {
      message.flow_type = {
        $case: "client_credentials",
        client_credentials: OAuth2_ClientCredentials.fromPartial(object.flow_type.client_credentials),
      };
    }
    message.token_fetch_retry_interval =
      (object.token_fetch_retry_interval !== undefined && object.token_fetch_retry_interval !== null)
        ? Duration.fromPartial(object.token_fetch_retry_interval)
        : undefined;
    message.endpoint_params = object.endpoint_params?.map((e) => OAuth2_EndpointParameter.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(OAuth2.$type, OAuth2);

function createBaseOAuth2_ClientCredentials(): OAuth2_ClientCredentials {
  return { $type: "envoy.extensions.http.injected_credentials.oauth2.v3.OAuth2.ClientCredentials" };
}

export const OAuth2_ClientCredentials: MessageFns<
  OAuth2_ClientCredentials,
  "envoy.extensions.http.injected_credentials.oauth2.v3.OAuth2.ClientCredentials"
> = {
  $type: "envoy.extensions.http.injected_credentials.oauth2.v3.OAuth2.ClientCredentials" as const,

  encode(message: OAuth2_ClientCredentials, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.client_id !== undefined && message.client_id !== "") {
      writer.uint32(10).string(message.client_id);
    }
    if (message.client_secret !== undefined) {
      SdsSecretConfig.encode(message.client_secret, writer.uint32(18).fork()).join();
    }
    if (message.auth_type !== undefined && message.auth_type !== OAuth2_AuthType.BASIC_AUTH) {
      writer.uint32(24).int32(oAuth2_AuthTypeToNumber(message.auth_type));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OAuth2_ClientCredentials {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOAuth2_ClientCredentials();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.client_id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.client_secret = SdsSecretConfig.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.auth_type = oAuth2_AuthTypeFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OAuth2_ClientCredentials {
    return {
      $type: OAuth2_ClientCredentials.$type,
      client_id: isSet(object.client_id) ? globalThis.String(object.client_id) : undefined,
      client_secret: isSet(object.client_secret) ? SdsSecretConfig.fromJSON(object.client_secret) : undefined,
      auth_type: isSet(object.auth_type) ? oAuth2_AuthTypeFromJSON(object.auth_type) : undefined,
    };
  },

  toJSON(message: OAuth2_ClientCredentials): unknown {
    const obj: any = {};
    if (message.client_id !== undefined) {
      obj.client_id = message.client_id;
    }
    if (message.client_secret !== undefined) {
      obj.client_secret = SdsSecretConfig.toJSON(message.client_secret);
    }
    if (message.auth_type !== undefined) {
      obj.auth_type = oAuth2_AuthTypeToJSON(message.auth_type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OAuth2_ClientCredentials>, I>>(base?: I): OAuth2_ClientCredentials {
    return OAuth2_ClientCredentials.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OAuth2_ClientCredentials>, I>>(object: I): OAuth2_ClientCredentials {
    const message = createBaseOAuth2_ClientCredentials();
    message.client_id = object.client_id ?? undefined;
    message.client_secret = (object.client_secret !== undefined && object.client_secret !== null)
      ? SdsSecretConfig.fromPartial(object.client_secret)
      : undefined;
    message.auth_type = object.auth_type ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(OAuth2_ClientCredentials.$type, OAuth2_ClientCredentials);

function createBaseOAuth2_EndpointParameter(): OAuth2_EndpointParameter {
  return { $type: "envoy.extensions.http.injected_credentials.oauth2.v3.OAuth2.EndpointParameter" };
}

export const OAuth2_EndpointParameter: MessageFns<
  OAuth2_EndpointParameter,
  "envoy.extensions.http.injected_credentials.oauth2.v3.OAuth2.EndpointParameter"
> = {
  $type: "envoy.extensions.http.injected_credentials.oauth2.v3.OAuth2.EndpointParameter" as const,

  encode(message: OAuth2_EndpointParameter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== undefined && message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OAuth2_EndpointParameter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOAuth2_EndpointParameter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OAuth2_EndpointParameter {
    return {
      $type: OAuth2_EndpointParameter.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      value: isSet(object.value) ? globalThis.String(object.value) : undefined,
    };
  },

  toJSON(message: OAuth2_EndpointParameter): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OAuth2_EndpointParameter>, I>>(base?: I): OAuth2_EndpointParameter {
    return OAuth2_EndpointParameter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OAuth2_EndpointParameter>, I>>(object: I): OAuth2_EndpointParameter {
    const message = createBaseOAuth2_EndpointParameter();
    message.name = object.name ?? undefined;
    message.value = object.value ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(OAuth2_EndpointParameter.$type, OAuth2_EndpointParameter);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
