// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/transport_sockets/tls/v3/tls.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../../../google/protobuf/duration";
import { BoolValue, UInt32Value } from "../../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../../typeRegistry";
import { CidrRange } from "../../../../config/core/v3/address";
import { TypedExtensionConfig } from "../../../../config/core/v3/extension";
import {
  CertificateProviderPluginInstance,
  CertificateValidationContext,
  TlsCertificate,
  TlsParameters,
  TlsSessionTicketKeys,
} from "./common";
import { SdsSecretConfig } from "./secret";

export const protobufPackage = "envoy.extensions.transport_sockets.tls.v3";

/** [#next-free-field: 8] */
export interface UpstreamTlsContext {
  $type: "envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext";
  /**
   * Common TLS context settings.
   *
   * .. attention::
   *
   *   Server certificate verification is not enabled by default. To enable verification, configure
   *   :ref:`trusted_ca<envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.trusted_ca>`.
   */
  common_tls_context?:
    | CommonTlsContext
    | undefined;
  /** SNI string to use when creating TLS backend connections. */
  sni?:
    | string
    | undefined;
  /**
   * If true, replaces the SNI for the connection with the hostname of the upstream host, if
   * the hostname is known due to either a DNS cluster type or the
   * :ref:`hostname <envoy_v3_api_field_config.endpoint.v3.Endpoint.hostname>` is set on
   * the host.
   *
   * See :ref:`SNI configuration <start_quick_start_securing_sni_client>` for details on how this
   * interacts with other validation options.
   */
  auto_host_sni?:
    | boolean
    | undefined;
  /**
   * If true, replaces any Subject Alternative Name (SAN) validations with a validation for a DNS SAN matching
   * the SNI value sent. The validation uses the actual requested SNI, regardless of how the SNI is configured.
   *
   * For common cases where an SNI value is present and the server certificate should include a corresponding SAN,
   * this option ensures the SAN is properly validated.
   *
   * See the :ref:`validation configuration <start_quick_start_securing_validation>` for how this interacts with
   * other validation options.
   */
  auto_sni_san_validation?:
    | boolean
    | undefined;
  /**
   * If true, server-initiated TLS renegotiation will be allowed.
   *
   * .. attention::
   *
   *   TLS renegotiation is considered insecure and shouldn't be used unless absolutely necessary.
   */
  allow_renegotiation?:
    | boolean
    | undefined;
  /**
   * Maximum number of session keys (Pre-Shared Keys for TLSv1.3+, Session IDs and Session Tickets
   * for TLSv1.2 and older) to be stored for session resumption.
   *
   * Defaults to 1, setting this to 0 disables session resumption.
   */
  max_session_keys?:
    | number
    | undefined;
  /**
   * Controls enforcement of the ``keyUsage`` extension in peer certificates. If set to ``true``, the handshake will fail if
   * the ``keyUsage`` is incompatible with TLS usage.
   *
   * .. note::
   *   The default value is ``false`` (i.e., enforcement off). It is expected to change to ``true`` in a future release.
   *
   * The ``ssl.was_key_usage_invalid`` in :ref:`listener metrics <config_listener_stats>` metric will be incremented
   * for configurations that would fail if this option were enabled.
   */
  enforce_rsa_key_usage?: boolean | undefined;
}

/** [#next-free-field: 12] */
export interface DownstreamTlsContext {
  $type: "envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext";
  /** Common TLS context settings. */
  common_tls_context?:
    | CommonTlsContext
    | undefined;
  /**
   * If specified, Envoy will reject connections without a valid client
   * certificate.
   */
  require_client_certificate?:
    | boolean
    | undefined;
  /**
   * If specified, Envoy will reject connections without a valid and matching SNI.
   * [#not-implemented-hide:]
   */
  require_sni?: boolean | undefined;
  session_ticket_keys_type?:
    | //
    /** TLS session ticket key settings. */
    { $case: "session_ticket_keys"; session_ticket_keys: TlsSessionTicketKeys }
    | //
    /** Config for fetching TLS session ticket keys via SDS API. */
    { $case: "session_ticket_keys_sds_secret_config"; session_ticket_keys_sds_secret_config: SdsSecretConfig }
    | //
    /**
     * Config for controlling stateless TLS session resumption: setting this to true will cause the TLS
     * server to not issue TLS session tickets for the purposes of stateless TLS session resumption.
     * If set to false, the TLS server will issue TLS session tickets and encrypt/decrypt them using
     * the keys specified through either :ref:`session_ticket_keys <envoy_v3_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.session_ticket_keys>`
     * or :ref:`session_ticket_keys_sds_secret_config <envoy_v3_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.session_ticket_keys_sds_secret_config>`.
     * If this config is set to false and no keys are explicitly configured, the TLS server will issue
     * TLS session tickets and encrypt/decrypt them using an internally-generated and managed key, with the
     * implication that sessions cannot be resumed across hot restarts or on different hosts.
     */
    { $case: "disable_stateless_session_resumption"; disable_stateless_session_resumption: boolean }
    | undefined;
  /**
   * If ``true``, the TLS server will not maintain a session cache of TLS sessions.
   *
   * .. note::
   *   This applies only to TLSv1.2 and earlier.
   */
  disable_stateful_session_resumption?:
    | boolean
    | undefined;
  /**
   * Maximum lifetime of TLS sessions. If specified, ``session_timeout`` will change the maximum lifetime
   * of the TLS session.
   *
   * This serves as a hint for the `TLS session ticket lifetime (for TLSv1.2) <https://tools.ietf.org/html/rfc5077#section-5.6>`_.
   * Only whole seconds are considered; fractional seconds are ignored.
   */
  session_timeout?:
    | Duration
    | undefined;
  /**
   * Configuration for handling certificates without an OCSP response or with expired responses.
   *
   * Defaults to ``LENIENT_STAPLING``
   */
  ocsp_staple_policy?:
    | DownstreamTlsContext_OcspStaplePolicy
    | undefined;
  /**
   * Multiple certificates are allowed in Downstream transport socket to serve different SNI.
   * This option controls the behavior when no matching certificate is found for the received SNI value,
   * or no SNI value was sent. If enabled, all certificates will be evaluated for a match for non-SNI criteria
   * such as key type and OCSP settings. If disabled, the first provided certificate will be used.
   * Defaults to ``false``. See more details in :ref:`Multiple TLS certificates <arch_overview_ssl_cert_select>`.
   */
  full_scan_certs_on_sni_mismatch?:
    | boolean
    | undefined;
  /**
   * If ``true``, the downstream client's preferred cipher is used during the handshake. If ``false``, Envoy
   * uses its preferred cipher.
   *
   * .. note::
   *   This has no effect when using TLSv1_3.
   */
  prefer_client_ciphers?: boolean | undefined;
}

export enum DownstreamTlsContext_OcspStaplePolicy {
  /** LENIENT_STAPLING - OCSP responses are optional. If absent or expired, the certificate is used without stapling. */
  LENIENT_STAPLING = "LENIENT_STAPLING",
  /**
   * STRICT_STAPLING - OCSP responses are optional. If absent, the certificate is used without stapling. If present but expired,
   * the certificate is not used for subsequent connections. Connections are rejected if no suitable certificate
   * is found.
   */
  STRICT_STAPLING = "STRICT_STAPLING",
  /**
   * MUST_STAPLE - OCSP responses are required. Connections fail if a certificate lacks a valid OCSP response. Expired responses
   * prevent certificate use in new connections, and connections are rejected if no suitable certificate is available.
   */
  MUST_STAPLE = "MUST_STAPLE",
}

export function downstreamTlsContext_OcspStaplePolicyFromJSON(object: any): DownstreamTlsContext_OcspStaplePolicy {
  switch (object) {
    case 0:
    case "LENIENT_STAPLING":
      return DownstreamTlsContext_OcspStaplePolicy.LENIENT_STAPLING;
    case 1:
    case "STRICT_STAPLING":
      return DownstreamTlsContext_OcspStaplePolicy.STRICT_STAPLING;
    case 2:
    case "MUST_STAPLE":
      return DownstreamTlsContext_OcspStaplePolicy.MUST_STAPLE;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum DownstreamTlsContext_OcspStaplePolicy",
      );
  }
}

export function downstreamTlsContext_OcspStaplePolicyToJSON(object: DownstreamTlsContext_OcspStaplePolicy): string {
  switch (object) {
    case DownstreamTlsContext_OcspStaplePolicy.LENIENT_STAPLING:
      return "LENIENT_STAPLING";
    case DownstreamTlsContext_OcspStaplePolicy.STRICT_STAPLING:
      return "STRICT_STAPLING";
    case DownstreamTlsContext_OcspStaplePolicy.MUST_STAPLE:
      return "MUST_STAPLE";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum DownstreamTlsContext_OcspStaplePolicy",
      );
  }
}

export function downstreamTlsContext_OcspStaplePolicyToNumber(object: DownstreamTlsContext_OcspStaplePolicy): number {
  switch (object) {
    case DownstreamTlsContext_OcspStaplePolicy.LENIENT_STAPLING:
      return 0;
    case DownstreamTlsContext_OcspStaplePolicy.STRICT_STAPLING:
      return 1;
    case DownstreamTlsContext_OcspStaplePolicy.MUST_STAPLE:
      return 2;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum DownstreamTlsContext_OcspStaplePolicy",
      );
  }
}

/**
 * TLS key log configuration.
 * The key log file format is "format used by NSS for its SSLKEYLOGFILE debugging output" (text taken from openssl man page)
 */
export interface TlsKeyLog {
  $type: "envoy.extensions.transport_sockets.tls.v3.TlsKeyLog";
  /** Path to save the TLS key log. */
  path?:
    | string
    | undefined;
  /** Local IP address ranges to filter connections for TLS key logging. If not set, matches any local IP address. */
  local_address_range?:
    | CidrRange[]
    | undefined;
  /** Remote IP address ranges to filter connections for TLS key logging. If not set, matches any remote IP address. */
  remote_address_range?: CidrRange[] | undefined;
}

/**
 * TLS context shared by both client and server TLS contexts.
 * [#next-free-field: 17]
 */
export interface CommonTlsContext {
  $type: "envoy.extensions.transport_sockets.tls.v3.CommonTlsContext";
  /** TLS protocol versions, cipher suites etc. */
  tls_params?:
    | TlsParameters
    | undefined;
  /**
   * Only a single TLS certificate is supported in client contexts. In server contexts,
   * :ref:`Multiple TLS certificates <arch_overview_ssl_cert_select>` can be associated with the
   * same context to allow both RSA and ECDSA certificates and support SNI-based selection.
   *
   * If ``tls_certificate_provider_instance`` is set, this field is ignored.
   * If this field is set, ``tls_certificate_sds_secret_configs`` is ignored.
   */
  tls_certificates?:
    | TlsCertificate[]
    | undefined;
  /**
   * Configs for fetching TLS certificates via SDS API. Note SDS API allows certificates to be
   * fetched/refreshed over the network asynchronously with respect to the TLS handshake.
   *
   * The same number and types of certificates as :ref:`tls_certificates <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CommonTlsContext.tls_certificates>`
   * are valid in the certificates fetched through this setting.
   *
   * If ``tls_certificates`` or ``tls_certificate_provider_instance`` are set, this field
   * is ignored.
   */
  tls_certificate_sds_secret_configs?:
    | SdsSecretConfig[]
    | undefined;
  /**
   * Certificate provider instance for fetching TLS certs.
   *
   * If this field is set, ``tls_certificates`` and ``tls_certificate_provider_instance``
   * are ignored.
   * [#not-implemented-hide:]
   */
  tls_certificate_provider_instance?:
    | CertificateProviderPluginInstance
    | undefined;
  /**
   * Custom TLS certificate selector.
   *
   * Select TLS certificate based on TLS client hello.
   * If empty, defaults to native TLS certificate selection behavior:
   * DNS SANs or Subject Common Name in TLS certificates is extracted as server name pattern to match SNI.
   * [#extension-category: envoy.tls.certificate_selectors]
   */
  custom_tls_certificate_selector?:
    | TypedExtensionConfig
    | undefined;
  /**
   * Certificate provider for fetching TLS certificates.
   * [#not-implemented-hide:]
   *
   * @deprecated
   */
  tls_certificate_certificate_provider?:
    | CommonTlsContext_CertificateProvider
    | undefined;
  /**
   * Certificate provider instance for fetching TLS certificates.
   * [#not-implemented-hide:]
   *
   * @deprecated
   */
  tls_certificate_certificate_provider_instance?: CommonTlsContext_CertificateProviderInstance | undefined;
  validation_context_type?:
    | //
    /** How to validate peer certificates. */
    { $case: "validation_context"; validation_context: CertificateValidationContext }
    | //
    /**
     * Config for fetching validation context via SDS API. Note SDS API allows certificates to be
     * fetched/refreshed over the network asynchronously with respect to the TLS handshake.
     */
    { $case: "validation_context_sds_secret_config"; validation_context_sds_secret_config: SdsSecretConfig }
    | //
    /**
     * Combines the default ``CertificateValidationContext`` with the SDS-provided dynamic context for certificate
     * validation.
     *
     * When the SDS server returns a dynamic ``CertificateValidationContext``, it is merged
     * with the default context using ``Message::MergeFrom()``. The merging rules are as follows:
     *
     * * **Singular Fields:** Dynamic fields override the default singular fields.
     * * **Repeated Fields:** Dynamic repeated fields are concatenated with the default repeated fields.
     * * **Boolean Fields:** Boolean fields are combined using a logical OR operation.
     *
     * The resulting ``CertificateValidationContext`` is used to perform certificate validation.
     */
    {
      $case: "combined_validation_context";
      combined_validation_context: CommonTlsContext_CombinedCertificateValidationContext;
    }
    | //
    /**
     * Certificate provider for fetching validation context.
     * [#not-implemented-hide:]
     */
    {
      $case: "validation_context_certificate_provider";
      validation_context_certificate_provider: CommonTlsContext_CertificateProvider;
    }
    | //
    /**
     * Certificate provider instance for fetching validation context.
     * [#not-implemented-hide:]
     */
    {
      $case: "validation_context_certificate_provider_instance";
      validation_context_certificate_provider_instance: CommonTlsContext_CertificateProviderInstance;
    }
    | undefined;
  /**
   * Supplies the list of ALPN protocols that the listener should expose. In
   * practice this is likely to be set to one of two values (see the
   * :ref:`codec_type
   * <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.codec_type>`
   * parameter in the HTTP connection manager for more information):
   *
   * * "h2,http/1.1" If the listener is going to support both HTTP/2 and HTTP/1.1.
   * * "http/1.1" If the listener is only going to support HTTP/1.1.
   *
   * There is no default for this parameter. If empty, Envoy will not expose ALPN.
   */
  alpn_protocols?:
    | string[]
    | undefined;
  /**
   * Custom TLS handshaker. If empty, defaults to native TLS handshaking
   * behavior.
   */
  custom_handshaker?:
    | TypedExtensionConfig
    | undefined;
  /** TLS key log configuration */
  key_log?: TlsKeyLog | undefined;
}

/**
 * Config for the Certificate Provider to fetch certificates. Certificates are fetched/refreshed asynchronously over
 * the network relative to the TLS handshake.
 *
 * DEPRECATED: This message is not currently used, but if we ever do need it, we will want to
 * move it out of CommonTlsContext and into common.proto, similar to the existing
 * CertificateProviderPluginInstance message.
 *
 * [#not-implemented-hide:]
 */
export interface CommonTlsContext_CertificateProvider {
  $type: "envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProvider";
  /**
   * opaque name used to specify certificate instances or types. For example, "ROOTCA" to specify
   * a root-certificate (validation context) or "TLS" to specify a new tls-certificate.
   */
  name?:
    | string
    | undefined;
  /**
   * Provider specific config.
   * Note: an implementation is expected to dedup multiple instances of the same config
   * to maintain a single certificate-provider instance. The sharing can happen, for
   * example, among multiple clusters or between the tls_certificate and validation_context
   * certificate providers of a cluster.
   * This config could be supplied inline or (in future) a named xDS resource.
   */
  config?:
    | //
    { $case: "typed_config"; typed_config: TypedExtensionConfig }
    | undefined;
}

/**
 * Similar to CertificateProvider above, but allows the provider instances to be configured on
 * the client side instead of being sent from the control plane.
 *
 * DEPRECATED: This message was moved outside of CommonTlsContext
 * and now lives in common.proto.
 *
 * [#not-implemented-hide:]
 */
export interface CommonTlsContext_CertificateProviderInstance {
  $type: "envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderInstance";
  /**
   * Provider instance name. This name must be defined in the client's configuration (e.g., a
   * bootstrap file) to correspond to a provider instance (i.e., the same data in the typed_config
   * field that would be sent in the CertificateProvider message if the config was sent by the
   * control plane). If not present, defaults to "default".
   *
   * Instance names should generally be defined not in terms of the underlying provider
   * implementation (e.g., "file_watcher") but rather in terms of the function of the
   * certificates (e.g., "foo_deployment_identity").
   */
  instance_name?:
    | string
    | undefined;
  /**
   * Opaque name used to specify certificate instances or types. For example, "ROOTCA" to specify
   * a root-certificate (validation context) or "example.com" to specify a certificate for a
   * particular domain. Not all provider instances will actually use this field, so the value
   * defaults to the empty string.
   */
  certificate_name?: string | undefined;
}

export interface CommonTlsContext_CombinedCertificateValidationContext {
  $type: "envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CombinedCertificateValidationContext";
  /** How to validate peer certificates. */
  default_validation_context?:
    | CertificateValidationContext
    | undefined;
  /**
   * Config for fetching validation context via SDS API. Note SDS API allows certificates to be
   * fetched/refreshed over the network asynchronously with respect to the TLS handshake.
   */
  validation_context_sds_secret_config?:
    | SdsSecretConfig
    | undefined;
  /**
   * Certificate provider for fetching CA certs. This will populate the
   * ``default_validation_context.trusted_ca`` field.
   * [#not-implemented-hide:]
   *
   * @deprecated
   */
  validation_context_certificate_provider?:
    | CommonTlsContext_CertificateProvider
    | undefined;
  /**
   * Certificate provider instance for fetching CA certs. This will populate the
   * ``default_validation_context.trusted_ca`` field.
   * [#not-implemented-hide:]
   *
   * @deprecated
   */
  validation_context_certificate_provider_instance?: CommonTlsContext_CertificateProviderInstance | undefined;
}

function createBaseUpstreamTlsContext(): UpstreamTlsContext {
  return { $type: "envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext" };
}

export const UpstreamTlsContext: MessageFns<
  UpstreamTlsContext,
  "envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext"
> = {
  $type: "envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext" as const,

  encode(message: UpstreamTlsContext, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common_tls_context !== undefined) {
      CommonTlsContext.encode(message.common_tls_context, writer.uint32(10).fork()).join();
    }
    if (message.sni !== undefined && message.sni !== "") {
      writer.uint32(18).string(message.sni);
    }
    if (message.auto_host_sni !== undefined && message.auto_host_sni !== false) {
      writer.uint32(48).bool(message.auto_host_sni);
    }
    if (message.auto_sni_san_validation !== undefined && message.auto_sni_san_validation !== false) {
      writer.uint32(56).bool(message.auto_sni_san_validation);
    }
    if (message.allow_renegotiation !== undefined && message.allow_renegotiation !== false) {
      writer.uint32(24).bool(message.allow_renegotiation);
    }
    if (message.max_session_keys !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.max_session_keys! },
        writer.uint32(34).fork(),
      ).join();
    }
    if (message.enforce_rsa_key_usage !== undefined) {
      BoolValue.encode(
        { $type: "google.protobuf.BoolValue", value: message.enforce_rsa_key_usage! },
        writer.uint32(42).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpstreamTlsContext {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpstreamTlsContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common_tls_context = CommonTlsContext.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sni = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.auto_host_sni = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.auto_sni_san_validation = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.allow_renegotiation = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.max_session_keys = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.enforce_rsa_key_usage = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpstreamTlsContext {
    return {
      $type: UpstreamTlsContext.$type,
      common_tls_context: isSet(object.common_tls_context)
        ? CommonTlsContext.fromJSON(object.common_tls_context)
        : undefined,
      sni: isSet(object.sni) ? globalThis.String(object.sni) : undefined,
      auto_host_sni: isSet(object.auto_host_sni) ? globalThis.Boolean(object.auto_host_sni) : undefined,
      auto_sni_san_validation: isSet(object.auto_sni_san_validation)
        ? globalThis.Boolean(object.auto_sni_san_validation)
        : undefined,
      allow_renegotiation: isSet(object.allow_renegotiation)
        ? globalThis.Boolean(object.allow_renegotiation)
        : undefined,
      max_session_keys: isSet(object.max_session_keys) ? Number(object.max_session_keys) : undefined,
      enforce_rsa_key_usage: isSet(object.enforce_rsa_key_usage) ? Boolean(object.enforce_rsa_key_usage) : undefined,
    };
  },

  toJSON(message: UpstreamTlsContext): unknown {
    const obj: any = {};
    if (message.common_tls_context !== undefined) {
      obj.common_tls_context = CommonTlsContext.toJSON(message.common_tls_context);
    }
    if (message.sni !== undefined) {
      obj.sni = message.sni;
    }
    if (message.auto_host_sni !== undefined) {
      obj.auto_host_sni = message.auto_host_sni;
    }
    if (message.auto_sni_san_validation !== undefined) {
      obj.auto_sni_san_validation = message.auto_sni_san_validation;
    }
    if (message.allow_renegotiation !== undefined) {
      obj.allow_renegotiation = message.allow_renegotiation;
    }
    if (message.max_session_keys !== undefined) {
      obj.max_session_keys = message.max_session_keys;
    }
    if (message.enforce_rsa_key_usage !== undefined) {
      obj.enforce_rsa_key_usage = message.enforce_rsa_key_usage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpstreamTlsContext>, I>>(base?: I): UpstreamTlsContext {
    return UpstreamTlsContext.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpstreamTlsContext>, I>>(object: I): UpstreamTlsContext {
    const message = createBaseUpstreamTlsContext();
    message.common_tls_context = (object.common_tls_context !== undefined && object.common_tls_context !== null)
      ? CommonTlsContext.fromPartial(object.common_tls_context)
      : undefined;
    message.sni = object.sni ?? undefined;
    message.auto_host_sni = object.auto_host_sni ?? undefined;
    message.auto_sni_san_validation = object.auto_sni_san_validation ?? undefined;
    message.allow_renegotiation = object.allow_renegotiation ?? undefined;
    message.max_session_keys = object.max_session_keys ?? undefined;
    message.enforce_rsa_key_usage = object.enforce_rsa_key_usage ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(UpstreamTlsContext.$type, UpstreamTlsContext);

function createBaseDownstreamTlsContext(): DownstreamTlsContext {
  return {
    $type: "envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext",
    session_ticket_keys_type: undefined,
  };
}

export const DownstreamTlsContext: MessageFns<
  DownstreamTlsContext,
  "envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext"
> = {
  $type: "envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext" as const,

  encode(message: DownstreamTlsContext, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common_tls_context !== undefined) {
      CommonTlsContext.encode(message.common_tls_context, writer.uint32(10).fork()).join();
    }
    if (message.require_client_certificate !== undefined) {
      BoolValue.encode(
        { $type: "google.protobuf.BoolValue", value: message.require_client_certificate! },
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.require_sni !== undefined) {
      BoolValue.encode({ $type: "google.protobuf.BoolValue", value: message.require_sni! }, writer.uint32(26).fork())
        .join();
    }
    switch (message.session_ticket_keys_type?.$case) {
      case "session_ticket_keys":
        TlsSessionTicketKeys.encode(message.session_ticket_keys_type.session_ticket_keys, writer.uint32(34).fork())
          .join();
        break;
      case "session_ticket_keys_sds_secret_config":
        SdsSecretConfig.encode(
          message.session_ticket_keys_type.session_ticket_keys_sds_secret_config,
          writer.uint32(42).fork(),
        ).join();
        break;
      case "disable_stateless_session_resumption":
        writer.uint32(56).bool(message.session_ticket_keys_type.disable_stateless_session_resumption);
        break;
    }
    if (
      message.disable_stateful_session_resumption !== undefined && message.disable_stateful_session_resumption !== false
    ) {
      writer.uint32(80).bool(message.disable_stateful_session_resumption);
    }
    if (message.session_timeout !== undefined) {
      Duration.encode(message.session_timeout, writer.uint32(50).fork()).join();
    }
    if (
      message.ocsp_staple_policy !== undefined &&
      message.ocsp_staple_policy !== DownstreamTlsContext_OcspStaplePolicy.LENIENT_STAPLING
    ) {
      writer.uint32(64).int32(downstreamTlsContext_OcspStaplePolicyToNumber(message.ocsp_staple_policy));
    }
    if (message.full_scan_certs_on_sni_mismatch !== undefined) {
      BoolValue.encode(
        { $type: "google.protobuf.BoolValue", value: message.full_scan_certs_on_sni_mismatch! },
        writer.uint32(74).fork(),
      ).join();
    }
    if (message.prefer_client_ciphers !== undefined && message.prefer_client_ciphers !== false) {
      writer.uint32(88).bool(message.prefer_client_ciphers);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DownstreamTlsContext {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDownstreamTlsContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common_tls_context = CommonTlsContext.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.require_client_certificate = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.require_sni = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.session_ticket_keys_type = {
            $case: "session_ticket_keys",
            session_ticket_keys: TlsSessionTicketKeys.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.session_ticket_keys_type = {
            $case: "session_ticket_keys_sds_secret_config",
            session_ticket_keys_sds_secret_config: SdsSecretConfig.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.session_ticket_keys_type = {
            $case: "disable_stateless_session_resumption",
            disable_stateless_session_resumption: reader.bool(),
          };
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.disable_stateful_session_resumption = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.session_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.ocsp_staple_policy = downstreamTlsContext_OcspStaplePolicyFromJSON(reader.int32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.full_scan_certs_on_sni_mismatch = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.prefer_client_ciphers = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DownstreamTlsContext {
    return {
      $type: DownstreamTlsContext.$type,
      common_tls_context: isSet(object.common_tls_context)
        ? CommonTlsContext.fromJSON(object.common_tls_context)
        : undefined,
      require_client_certificate: isSet(object.require_client_certificate)
        ? Boolean(object.require_client_certificate)
        : undefined,
      require_sni: isSet(object.require_sni) ? Boolean(object.require_sni) : undefined,
      session_ticket_keys_type: isSet(object.session_ticket_keys)
        ? {
          $case: "session_ticket_keys",
          session_ticket_keys: TlsSessionTicketKeys.fromJSON(object.session_ticket_keys),
        }
        : isSet(object.session_ticket_keys_sds_secret_config)
        ? {
          $case: "session_ticket_keys_sds_secret_config",
          session_ticket_keys_sds_secret_config: SdsSecretConfig.fromJSON(object.session_ticket_keys_sds_secret_config),
        }
        : isSet(object.disable_stateless_session_resumption)
        ? {
          $case: "disable_stateless_session_resumption",
          disable_stateless_session_resumption: globalThis.Boolean(object.disable_stateless_session_resumption),
        }
        : undefined,
      disable_stateful_session_resumption: isSet(object.disable_stateful_session_resumption)
        ? globalThis.Boolean(object.disable_stateful_session_resumption)
        : undefined,
      session_timeout: isSet(object.session_timeout) ? Duration.fromJSON(object.session_timeout) : undefined,
      ocsp_staple_policy: isSet(object.ocsp_staple_policy)
        ? downstreamTlsContext_OcspStaplePolicyFromJSON(object.ocsp_staple_policy)
        : undefined,
      full_scan_certs_on_sni_mismatch: isSet(object.full_scan_certs_on_sni_mismatch)
        ? Boolean(object.full_scan_certs_on_sni_mismatch)
        : undefined,
      prefer_client_ciphers: isSet(object.prefer_client_ciphers)
        ? globalThis.Boolean(object.prefer_client_ciphers)
        : undefined,
    };
  },

  toJSON(message: DownstreamTlsContext): unknown {
    const obj: any = {};
    if (message.common_tls_context !== undefined) {
      obj.common_tls_context = CommonTlsContext.toJSON(message.common_tls_context);
    }
    if (message.require_client_certificate !== undefined) {
      obj.require_client_certificate = message.require_client_certificate;
    }
    if (message.require_sni !== undefined) {
      obj.require_sni = message.require_sni;
    }
    if (message.session_ticket_keys_type?.$case === "session_ticket_keys") {
      obj.session_ticket_keys = TlsSessionTicketKeys.toJSON(message.session_ticket_keys_type.session_ticket_keys);
    }
    if (message.session_ticket_keys_type?.$case === "session_ticket_keys_sds_secret_config") {
      obj.session_ticket_keys_sds_secret_config = SdsSecretConfig.toJSON(
        message.session_ticket_keys_type.session_ticket_keys_sds_secret_config,
      );
    }
    if (message.session_ticket_keys_type?.$case === "disable_stateless_session_resumption") {
      obj.disable_stateless_session_resumption = message.session_ticket_keys_type.disable_stateless_session_resumption;
    }
    if (message.disable_stateful_session_resumption !== undefined) {
      obj.disable_stateful_session_resumption = message.disable_stateful_session_resumption;
    }
    if (message.session_timeout !== undefined) {
      obj.session_timeout = Duration.toJSON(message.session_timeout);
    }
    if (message.ocsp_staple_policy !== undefined) {
      obj.ocsp_staple_policy = downstreamTlsContext_OcspStaplePolicyToJSON(message.ocsp_staple_policy);
    }
    if (message.full_scan_certs_on_sni_mismatch !== undefined) {
      obj.full_scan_certs_on_sni_mismatch = message.full_scan_certs_on_sni_mismatch;
    }
    if (message.prefer_client_ciphers !== undefined) {
      obj.prefer_client_ciphers = message.prefer_client_ciphers;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DownstreamTlsContext>, I>>(base?: I): DownstreamTlsContext {
    return DownstreamTlsContext.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DownstreamTlsContext>, I>>(object: I): DownstreamTlsContext {
    const message = createBaseDownstreamTlsContext();
    message.common_tls_context = (object.common_tls_context !== undefined && object.common_tls_context !== null)
      ? CommonTlsContext.fromPartial(object.common_tls_context)
      : undefined;
    message.require_client_certificate = object.require_client_certificate ?? undefined;
    message.require_sni = object.require_sni ?? undefined;
    if (
      object.session_ticket_keys_type?.$case === "session_ticket_keys" &&
      object.session_ticket_keys_type?.session_ticket_keys !== undefined &&
      object.session_ticket_keys_type?.session_ticket_keys !== null
    ) {
      message.session_ticket_keys_type = {
        $case: "session_ticket_keys",
        session_ticket_keys: TlsSessionTicketKeys.fromPartial(object.session_ticket_keys_type.session_ticket_keys),
      };
    }
    if (
      object.session_ticket_keys_type?.$case === "session_ticket_keys_sds_secret_config" &&
      object.session_ticket_keys_type?.session_ticket_keys_sds_secret_config !== undefined &&
      object.session_ticket_keys_type?.session_ticket_keys_sds_secret_config !== null
    ) {
      message.session_ticket_keys_type = {
        $case: "session_ticket_keys_sds_secret_config",
        session_ticket_keys_sds_secret_config: SdsSecretConfig.fromPartial(
          object.session_ticket_keys_type.session_ticket_keys_sds_secret_config,
        ),
      };
    }
    if (
      object.session_ticket_keys_type?.$case === "disable_stateless_session_resumption" &&
      object.session_ticket_keys_type?.disable_stateless_session_resumption !== undefined &&
      object.session_ticket_keys_type?.disable_stateless_session_resumption !== null
    ) {
      message.session_ticket_keys_type = {
        $case: "disable_stateless_session_resumption",
        disable_stateless_session_resumption: object.session_ticket_keys_type.disable_stateless_session_resumption,
      };
    }
    message.disable_stateful_session_resumption = object.disable_stateful_session_resumption ?? undefined;
    message.session_timeout = (object.session_timeout !== undefined && object.session_timeout !== null)
      ? Duration.fromPartial(object.session_timeout)
      : undefined;
    message.ocsp_staple_policy = object.ocsp_staple_policy ?? undefined;
    message.full_scan_certs_on_sni_mismatch = object.full_scan_certs_on_sni_mismatch ?? undefined;
    message.prefer_client_ciphers = object.prefer_client_ciphers ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(DownstreamTlsContext.$type, DownstreamTlsContext);

function createBaseTlsKeyLog(): TlsKeyLog {
  return { $type: "envoy.extensions.transport_sockets.tls.v3.TlsKeyLog" };
}

export const TlsKeyLog: MessageFns<TlsKeyLog, "envoy.extensions.transport_sockets.tls.v3.TlsKeyLog"> = {
  $type: "envoy.extensions.transport_sockets.tls.v3.TlsKeyLog" as const,

  encode(message: TlsKeyLog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== undefined && message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.local_address_range !== undefined && message.local_address_range.length !== 0) {
      for (const v of message.local_address_range) {
        CidrRange.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.remote_address_range !== undefined && message.remote_address_range.length !== 0) {
      for (const v of message.remote_address_range) {
        CidrRange.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TlsKeyLog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTlsKeyLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.local_address_range === undefined) {
            message.local_address_range = [];
          }
          const el = CidrRange.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.local_address_range!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.remote_address_range === undefined) {
            message.remote_address_range = [];
          }
          const el = CidrRange.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.remote_address_range!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TlsKeyLog {
    return {
      $type: TlsKeyLog.$type,
      path: isSet(object.path) ? globalThis.String(object.path) : undefined,
      local_address_range: globalThis.Array.isArray(object?.local_address_range)
        ? object.local_address_range.map((e: any) => CidrRange.fromJSON(e))
        : undefined,
      remote_address_range: globalThis.Array.isArray(object?.remote_address_range)
        ? object.remote_address_range.map((e: any) => CidrRange.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: TlsKeyLog): unknown {
    const obj: any = {};
    if (message.path !== undefined) {
      obj.path = message.path;
    }
    if (message.local_address_range?.length) {
      obj.local_address_range = message.local_address_range.map((e) => CidrRange.toJSON(e));
    }
    if (message.remote_address_range?.length) {
      obj.remote_address_range = message.remote_address_range.map((e) => CidrRange.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TlsKeyLog>, I>>(base?: I): TlsKeyLog {
    return TlsKeyLog.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TlsKeyLog>, I>>(object: I): TlsKeyLog {
    const message = createBaseTlsKeyLog();
    message.path = object.path ?? undefined;
    message.local_address_range = object.local_address_range?.map((e) => CidrRange.fromPartial(e)) || undefined;
    message.remote_address_range = object.remote_address_range?.map((e) => CidrRange.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(TlsKeyLog.$type, TlsKeyLog);

function createBaseCommonTlsContext(): CommonTlsContext {
  return { $type: "envoy.extensions.transport_sockets.tls.v3.CommonTlsContext", validation_context_type: undefined };
}

export const CommonTlsContext: MessageFns<
  CommonTlsContext,
  "envoy.extensions.transport_sockets.tls.v3.CommonTlsContext"
> = {
  $type: "envoy.extensions.transport_sockets.tls.v3.CommonTlsContext" as const,

  encode(message: CommonTlsContext, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tls_params !== undefined) {
      TlsParameters.encode(message.tls_params, writer.uint32(10).fork()).join();
    }
    if (message.tls_certificates !== undefined && message.tls_certificates.length !== 0) {
      for (const v of message.tls_certificates) {
        TlsCertificate.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (
      message.tls_certificate_sds_secret_configs !== undefined &&
      message.tls_certificate_sds_secret_configs.length !== 0
    ) {
      for (const v of message.tls_certificate_sds_secret_configs) {
        SdsSecretConfig.encode(v!, writer.uint32(50).fork()).join();
      }
    }
    if (message.tls_certificate_provider_instance !== undefined) {
      CertificateProviderPluginInstance.encode(message.tls_certificate_provider_instance, writer.uint32(114).fork())
        .join();
    }
    if (message.custom_tls_certificate_selector !== undefined) {
      TypedExtensionConfig.encode(message.custom_tls_certificate_selector, writer.uint32(130).fork()).join();
    }
    if (message.tls_certificate_certificate_provider !== undefined) {
      CommonTlsContext_CertificateProvider.encode(
        message.tls_certificate_certificate_provider,
        writer.uint32(74).fork(),
      ).join();
    }
    if (message.tls_certificate_certificate_provider_instance !== undefined) {
      CommonTlsContext_CertificateProviderInstance.encode(
        message.tls_certificate_certificate_provider_instance,
        writer.uint32(90).fork(),
      ).join();
    }
    switch (message.validation_context_type?.$case) {
      case "validation_context":
        CertificateValidationContext.encode(
          message.validation_context_type.validation_context,
          writer.uint32(26).fork(),
        ).join();
        break;
      case "validation_context_sds_secret_config":
        SdsSecretConfig.encode(
          message.validation_context_type.validation_context_sds_secret_config,
          writer.uint32(58).fork(),
        ).join();
        break;
      case "combined_validation_context":
        CommonTlsContext_CombinedCertificateValidationContext.encode(
          message.validation_context_type.combined_validation_context,
          writer.uint32(66).fork(),
        ).join();
        break;
      case "validation_context_certificate_provider":
        CommonTlsContext_CertificateProvider.encode(
          message.validation_context_type.validation_context_certificate_provider,
          writer.uint32(82).fork(),
        ).join();
        break;
      case "validation_context_certificate_provider_instance":
        CommonTlsContext_CertificateProviderInstance.encode(
          message.validation_context_type.validation_context_certificate_provider_instance,
          writer.uint32(98).fork(),
        ).join();
        break;
    }
    if (message.alpn_protocols !== undefined && message.alpn_protocols.length !== 0) {
      for (const v of message.alpn_protocols) {
        writer.uint32(34).string(v!);
      }
    }
    if (message.custom_handshaker !== undefined) {
      TypedExtensionConfig.encode(message.custom_handshaker, writer.uint32(106).fork()).join();
    }
    if (message.key_log !== undefined) {
      TlsKeyLog.encode(message.key_log, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommonTlsContext {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommonTlsContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tls_params = TlsParameters.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.tls_certificates === undefined) {
            message.tls_certificates = [];
          }
          const el = TlsCertificate.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.tls_certificates!.push(el);
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          if (message.tls_certificate_sds_secret_configs === undefined) {
            message.tls_certificate_sds_secret_configs = [];
          }
          const el = SdsSecretConfig.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.tls_certificate_sds_secret_configs!.push(el);
          }
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.tls_certificate_provider_instance = CertificateProviderPluginInstance.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.custom_tls_certificate_selector = TypedExtensionConfig.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.tls_certificate_certificate_provider = CommonTlsContext_CertificateProvider.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.tls_certificate_certificate_provider_instance = CommonTlsContext_CertificateProviderInstance.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.validation_context_type = {
            $case: "validation_context",
            validation_context: CertificateValidationContext.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.validation_context_type = {
            $case: "validation_context_sds_secret_config",
            validation_context_sds_secret_config: SdsSecretConfig.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.validation_context_type = {
            $case: "combined_validation_context",
            combined_validation_context: CommonTlsContext_CombinedCertificateValidationContext.decode(
              reader,
              reader.uint32(),
            ),
          };
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.validation_context_type = {
            $case: "validation_context_certificate_provider",
            validation_context_certificate_provider: CommonTlsContext_CertificateProvider.decode(
              reader,
              reader.uint32(),
            ),
          };
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.validation_context_type = {
            $case: "validation_context_certificate_provider_instance",
            validation_context_certificate_provider_instance: CommonTlsContext_CertificateProviderInstance.decode(
              reader,
              reader.uint32(),
            ),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          if (message.alpn_protocols === undefined) {
            message.alpn_protocols = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.alpn_protocols!.push(el);
          }
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.custom_handshaker = TypedExtensionConfig.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.key_log = TlsKeyLog.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommonTlsContext {
    return {
      $type: CommonTlsContext.$type,
      tls_params: isSet(object.tls_params) ? TlsParameters.fromJSON(object.tls_params) : undefined,
      tls_certificates: globalThis.Array.isArray(object?.tls_certificates)
        ? object.tls_certificates.map((e: any) => TlsCertificate.fromJSON(e))
        : undefined,
      tls_certificate_sds_secret_configs: globalThis.Array.isArray(object?.tls_certificate_sds_secret_configs)
        ? object.tls_certificate_sds_secret_configs.map((e: any) => SdsSecretConfig.fromJSON(e))
        : undefined,
      tls_certificate_provider_instance: isSet(object.tls_certificate_provider_instance)
        ? CertificateProviderPluginInstance.fromJSON(object.tls_certificate_provider_instance)
        : undefined,
      custom_tls_certificate_selector: isSet(object.custom_tls_certificate_selector)
        ? TypedExtensionConfig.fromJSON(object.custom_tls_certificate_selector)
        : undefined,
      tls_certificate_certificate_provider: isSet(object.tls_certificate_certificate_provider)
        ? CommonTlsContext_CertificateProvider.fromJSON(object.tls_certificate_certificate_provider)
        : undefined,
      tls_certificate_certificate_provider_instance: isSet(object.tls_certificate_certificate_provider_instance)
        ? CommonTlsContext_CertificateProviderInstance.fromJSON(object.tls_certificate_certificate_provider_instance)
        : undefined,
      validation_context_type: isSet(object.validation_context)
        ? {
          $case: "validation_context",
          validation_context: CertificateValidationContext.fromJSON(object.validation_context),
        }
        : isSet(object.validation_context_sds_secret_config)
        ? {
          $case: "validation_context_sds_secret_config",
          validation_context_sds_secret_config: SdsSecretConfig.fromJSON(object.validation_context_sds_secret_config),
        }
        : isSet(object.combined_validation_context)
        ? {
          $case: "combined_validation_context",
          combined_validation_context: CommonTlsContext_CombinedCertificateValidationContext.fromJSON(
            object.combined_validation_context,
          ),
        }
        : isSet(object.validation_context_certificate_provider)
        ? {
          $case: "validation_context_certificate_provider",
          validation_context_certificate_provider: CommonTlsContext_CertificateProvider.fromJSON(
            object.validation_context_certificate_provider,
          ),
        }
        : isSet(object.validation_context_certificate_provider_instance)
        ? {
          $case: "validation_context_certificate_provider_instance",
          validation_context_certificate_provider_instance: CommonTlsContext_CertificateProviderInstance.fromJSON(
            object.validation_context_certificate_provider_instance,
          ),
        }
        : undefined,
      alpn_protocols: globalThis.Array.isArray(object?.alpn_protocols)
        ? object.alpn_protocols.map((e: any) => globalThis.String(e))
        : undefined,
      custom_handshaker: isSet(object.custom_handshaker)
        ? TypedExtensionConfig.fromJSON(object.custom_handshaker)
        : undefined,
      key_log: isSet(object.key_log) ? TlsKeyLog.fromJSON(object.key_log) : undefined,
    };
  },

  toJSON(message: CommonTlsContext): unknown {
    const obj: any = {};
    if (message.tls_params !== undefined) {
      obj.tls_params = TlsParameters.toJSON(message.tls_params);
    }
    if (message.tls_certificates?.length) {
      obj.tls_certificates = message.tls_certificates.map((e) => TlsCertificate.toJSON(e));
    }
    if (message.tls_certificate_sds_secret_configs?.length) {
      obj.tls_certificate_sds_secret_configs = message.tls_certificate_sds_secret_configs.map((e) =>
        SdsSecretConfig.toJSON(e)
      );
    }
    if (message.tls_certificate_provider_instance !== undefined) {
      obj.tls_certificate_provider_instance = CertificateProviderPluginInstance.toJSON(
        message.tls_certificate_provider_instance,
      );
    }
    if (message.custom_tls_certificate_selector !== undefined) {
      obj.custom_tls_certificate_selector = TypedExtensionConfig.toJSON(message.custom_tls_certificate_selector);
    }
    if (message.tls_certificate_certificate_provider !== undefined) {
      obj.tls_certificate_certificate_provider = CommonTlsContext_CertificateProvider.toJSON(
        message.tls_certificate_certificate_provider,
      );
    }
    if (message.tls_certificate_certificate_provider_instance !== undefined) {
      obj.tls_certificate_certificate_provider_instance = CommonTlsContext_CertificateProviderInstance.toJSON(
        message.tls_certificate_certificate_provider_instance,
      );
    }
    if (message.validation_context_type?.$case === "validation_context") {
      obj.validation_context = CertificateValidationContext.toJSON(message.validation_context_type.validation_context);
    }
    if (message.validation_context_type?.$case === "validation_context_sds_secret_config") {
      obj.validation_context_sds_secret_config = SdsSecretConfig.toJSON(
        message.validation_context_type.validation_context_sds_secret_config,
      );
    }
    if (message.validation_context_type?.$case === "combined_validation_context") {
      obj.combined_validation_context = CommonTlsContext_CombinedCertificateValidationContext.toJSON(
        message.validation_context_type.combined_validation_context,
      );
    }
    if (message.validation_context_type?.$case === "validation_context_certificate_provider") {
      obj.validation_context_certificate_provider = CommonTlsContext_CertificateProvider.toJSON(
        message.validation_context_type.validation_context_certificate_provider,
      );
    }
    if (message.validation_context_type?.$case === "validation_context_certificate_provider_instance") {
      obj.validation_context_certificate_provider_instance = CommonTlsContext_CertificateProviderInstance.toJSON(
        message.validation_context_type.validation_context_certificate_provider_instance,
      );
    }
    if (message.alpn_protocols?.length) {
      obj.alpn_protocols = message.alpn_protocols;
    }
    if (message.custom_handshaker !== undefined) {
      obj.custom_handshaker = TypedExtensionConfig.toJSON(message.custom_handshaker);
    }
    if (message.key_log !== undefined) {
      obj.key_log = TlsKeyLog.toJSON(message.key_log);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommonTlsContext>, I>>(base?: I): CommonTlsContext {
    return CommonTlsContext.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommonTlsContext>, I>>(object: I): CommonTlsContext {
    const message = createBaseCommonTlsContext();
    message.tls_params = (object.tls_params !== undefined && object.tls_params !== null)
      ? TlsParameters.fromPartial(object.tls_params)
      : undefined;
    message.tls_certificates = object.tls_certificates?.map((e) => TlsCertificate.fromPartial(e)) || undefined;
    message.tls_certificate_sds_secret_configs =
      object.tls_certificate_sds_secret_configs?.map((e) => SdsSecretConfig.fromPartial(e)) || undefined;
    message.tls_certificate_provider_instance =
      (object.tls_certificate_provider_instance !== undefined && object.tls_certificate_provider_instance !== null)
        ? CertificateProviderPluginInstance.fromPartial(object.tls_certificate_provider_instance)
        : undefined;
    message.custom_tls_certificate_selector =
      (object.custom_tls_certificate_selector !== undefined && object.custom_tls_certificate_selector !== null)
        ? TypedExtensionConfig.fromPartial(object.custom_tls_certificate_selector)
        : undefined;
    message.tls_certificate_certificate_provider =
      (object.tls_certificate_certificate_provider !== undefined &&
          object.tls_certificate_certificate_provider !== null)
        ? CommonTlsContext_CertificateProvider.fromPartial(object.tls_certificate_certificate_provider)
        : undefined;
    message.tls_certificate_certificate_provider_instance =
      (object.tls_certificate_certificate_provider_instance !== undefined &&
          object.tls_certificate_certificate_provider_instance !== null)
        ? CommonTlsContext_CertificateProviderInstance.fromPartial(object.tls_certificate_certificate_provider_instance)
        : undefined;
    if (
      object.validation_context_type?.$case === "validation_context" &&
      object.validation_context_type?.validation_context !== undefined &&
      object.validation_context_type?.validation_context !== null
    ) {
      message.validation_context_type = {
        $case: "validation_context",
        validation_context: CertificateValidationContext.fromPartial(object.validation_context_type.validation_context),
      };
    }
    if (
      object.validation_context_type?.$case === "validation_context_sds_secret_config" &&
      object.validation_context_type?.validation_context_sds_secret_config !== undefined &&
      object.validation_context_type?.validation_context_sds_secret_config !== null
    ) {
      message.validation_context_type = {
        $case: "validation_context_sds_secret_config",
        validation_context_sds_secret_config: SdsSecretConfig.fromPartial(
          object.validation_context_type.validation_context_sds_secret_config,
        ),
      };
    }
    if (
      object.validation_context_type?.$case === "combined_validation_context" &&
      object.validation_context_type?.combined_validation_context !== undefined &&
      object.validation_context_type?.combined_validation_context !== null
    ) {
      message.validation_context_type = {
        $case: "combined_validation_context",
        combined_validation_context: CommonTlsContext_CombinedCertificateValidationContext.fromPartial(
          object.validation_context_type.combined_validation_context,
        ),
      };
    }
    if (
      object.validation_context_type?.$case === "validation_context_certificate_provider" &&
      object.validation_context_type?.validation_context_certificate_provider !== undefined &&
      object.validation_context_type?.validation_context_certificate_provider !== null
    ) {
      message.validation_context_type = {
        $case: "validation_context_certificate_provider",
        validation_context_certificate_provider: CommonTlsContext_CertificateProvider.fromPartial(
          object.validation_context_type.validation_context_certificate_provider,
        ),
      };
    }
    if (
      object.validation_context_type?.$case === "validation_context_certificate_provider_instance" &&
      object.validation_context_type?.validation_context_certificate_provider_instance !== undefined &&
      object.validation_context_type?.validation_context_certificate_provider_instance !== null
    ) {
      message.validation_context_type = {
        $case: "validation_context_certificate_provider_instance",
        validation_context_certificate_provider_instance: CommonTlsContext_CertificateProviderInstance.fromPartial(
          object.validation_context_type.validation_context_certificate_provider_instance,
        ),
      };
    }
    message.alpn_protocols = object.alpn_protocols?.map((e) => e) || undefined;
    message.custom_handshaker = (object.custom_handshaker !== undefined && object.custom_handshaker !== null)
      ? TypedExtensionConfig.fromPartial(object.custom_handshaker)
      : undefined;
    message.key_log = (object.key_log !== undefined && object.key_log !== null)
      ? TlsKeyLog.fromPartial(object.key_log)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(CommonTlsContext.$type, CommonTlsContext);

function createBaseCommonTlsContext_CertificateProvider(): CommonTlsContext_CertificateProvider {
  return { $type: "envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProvider", config: undefined };
}

export const CommonTlsContext_CertificateProvider: MessageFns<
  CommonTlsContext_CertificateProvider,
  "envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProvider"
> = {
  $type: "envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProvider" as const,

  encode(message: CommonTlsContext_CertificateProvider, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    switch (message.config?.$case) {
      case "typed_config":
        TypedExtensionConfig.encode(message.config.typed_config, writer.uint32(18).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommonTlsContext_CertificateProvider {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommonTlsContext_CertificateProvider();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.config = {
            $case: "typed_config",
            typed_config: TypedExtensionConfig.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommonTlsContext_CertificateProvider {
    return {
      $type: CommonTlsContext_CertificateProvider.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      config: isSet(object.typed_config)
        ? { $case: "typed_config", typed_config: TypedExtensionConfig.fromJSON(object.typed_config) }
        : undefined,
    };
  },

  toJSON(message: CommonTlsContext_CertificateProvider): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.config?.$case === "typed_config") {
      obj.typed_config = TypedExtensionConfig.toJSON(message.config.typed_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommonTlsContext_CertificateProvider>, I>>(
    base?: I,
  ): CommonTlsContext_CertificateProvider {
    return CommonTlsContext_CertificateProvider.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommonTlsContext_CertificateProvider>, I>>(
    object: I,
  ): CommonTlsContext_CertificateProvider {
    const message = createBaseCommonTlsContext_CertificateProvider();
    message.name = object.name ?? undefined;
    if (
      object.config?.$case === "typed_config" &&
      object.config?.typed_config !== undefined &&
      object.config?.typed_config !== null
    ) {
      message.config = {
        $case: "typed_config",
        typed_config: TypedExtensionConfig.fromPartial(object.config.typed_config),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(CommonTlsContext_CertificateProvider.$type, CommonTlsContext_CertificateProvider);

function createBaseCommonTlsContext_CertificateProviderInstance(): CommonTlsContext_CertificateProviderInstance {
  return { $type: "envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderInstance" };
}

export const CommonTlsContext_CertificateProviderInstance: MessageFns<
  CommonTlsContext_CertificateProviderInstance,
  "envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderInstance"
> = {
  $type: "envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderInstance" as const,

  encode(
    message: CommonTlsContext_CertificateProviderInstance,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.instance_name !== undefined && message.instance_name !== "") {
      writer.uint32(10).string(message.instance_name);
    }
    if (message.certificate_name !== undefined && message.certificate_name !== "") {
      writer.uint32(18).string(message.certificate_name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommonTlsContext_CertificateProviderInstance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommonTlsContext_CertificateProviderInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.instance_name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.certificate_name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommonTlsContext_CertificateProviderInstance {
    return {
      $type: CommonTlsContext_CertificateProviderInstance.$type,
      instance_name: isSet(object.instance_name) ? globalThis.String(object.instance_name) : undefined,
      certificate_name: isSet(object.certificate_name) ? globalThis.String(object.certificate_name) : undefined,
    };
  },

  toJSON(message: CommonTlsContext_CertificateProviderInstance): unknown {
    const obj: any = {};
    if (message.instance_name !== undefined) {
      obj.instance_name = message.instance_name;
    }
    if (message.certificate_name !== undefined) {
      obj.certificate_name = message.certificate_name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommonTlsContext_CertificateProviderInstance>, I>>(
    base?: I,
  ): CommonTlsContext_CertificateProviderInstance {
    return CommonTlsContext_CertificateProviderInstance.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommonTlsContext_CertificateProviderInstance>, I>>(
    object: I,
  ): CommonTlsContext_CertificateProviderInstance {
    const message = createBaseCommonTlsContext_CertificateProviderInstance();
    message.instance_name = object.instance_name ?? undefined;
    message.certificate_name = object.certificate_name ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(
  CommonTlsContext_CertificateProviderInstance.$type,
  CommonTlsContext_CertificateProviderInstance,
);

function createBaseCommonTlsContext_CombinedCertificateValidationContext(): CommonTlsContext_CombinedCertificateValidationContext {
  return { $type: "envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CombinedCertificateValidationContext" };
}

export const CommonTlsContext_CombinedCertificateValidationContext: MessageFns<
  CommonTlsContext_CombinedCertificateValidationContext,
  "envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CombinedCertificateValidationContext"
> = {
  $type: "envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CombinedCertificateValidationContext" as const,

  encode(
    message: CommonTlsContext_CombinedCertificateValidationContext,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.default_validation_context !== undefined) {
      CertificateValidationContext.encode(message.default_validation_context, writer.uint32(10).fork()).join();
    }
    if (message.validation_context_sds_secret_config !== undefined) {
      SdsSecretConfig.encode(message.validation_context_sds_secret_config, writer.uint32(18).fork()).join();
    }
    if (message.validation_context_certificate_provider !== undefined) {
      CommonTlsContext_CertificateProvider.encode(
        message.validation_context_certificate_provider,
        writer.uint32(26).fork(),
      ).join();
    }
    if (message.validation_context_certificate_provider_instance !== undefined) {
      CommonTlsContext_CertificateProviderInstance.encode(
        message.validation_context_certificate_provider_instance,
        writer.uint32(34).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommonTlsContext_CombinedCertificateValidationContext {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommonTlsContext_CombinedCertificateValidationContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.default_validation_context = CertificateValidationContext.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.validation_context_sds_secret_config = SdsSecretConfig.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.validation_context_certificate_provider = CommonTlsContext_CertificateProvider.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.validation_context_certificate_provider_instance = CommonTlsContext_CertificateProviderInstance
            .decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommonTlsContext_CombinedCertificateValidationContext {
    return {
      $type: CommonTlsContext_CombinedCertificateValidationContext.$type,
      default_validation_context: isSet(object.default_validation_context)
        ? CertificateValidationContext.fromJSON(object.default_validation_context)
        : undefined,
      validation_context_sds_secret_config: isSet(object.validation_context_sds_secret_config)
        ? SdsSecretConfig.fromJSON(object.validation_context_sds_secret_config)
        : undefined,
      validation_context_certificate_provider: isSet(object.validation_context_certificate_provider)
        ? CommonTlsContext_CertificateProvider.fromJSON(object.validation_context_certificate_provider)
        : undefined,
      validation_context_certificate_provider_instance: isSet(object.validation_context_certificate_provider_instance)
        ? CommonTlsContext_CertificateProviderInstance.fromJSON(object.validation_context_certificate_provider_instance)
        : undefined,
    };
  },

  toJSON(message: CommonTlsContext_CombinedCertificateValidationContext): unknown {
    const obj: any = {};
    if (message.default_validation_context !== undefined) {
      obj.default_validation_context = CertificateValidationContext.toJSON(message.default_validation_context);
    }
    if (message.validation_context_sds_secret_config !== undefined) {
      obj.validation_context_sds_secret_config = SdsSecretConfig.toJSON(message.validation_context_sds_secret_config);
    }
    if (message.validation_context_certificate_provider !== undefined) {
      obj.validation_context_certificate_provider = CommonTlsContext_CertificateProvider.toJSON(
        message.validation_context_certificate_provider,
      );
    }
    if (message.validation_context_certificate_provider_instance !== undefined) {
      obj.validation_context_certificate_provider_instance = CommonTlsContext_CertificateProviderInstance.toJSON(
        message.validation_context_certificate_provider_instance,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommonTlsContext_CombinedCertificateValidationContext>, I>>(
    base?: I,
  ): CommonTlsContext_CombinedCertificateValidationContext {
    return CommonTlsContext_CombinedCertificateValidationContext.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommonTlsContext_CombinedCertificateValidationContext>, I>>(
    object: I,
  ): CommonTlsContext_CombinedCertificateValidationContext {
    const message = createBaseCommonTlsContext_CombinedCertificateValidationContext();
    message.default_validation_context =
      (object.default_validation_context !== undefined && object.default_validation_context !== null)
        ? CertificateValidationContext.fromPartial(object.default_validation_context)
        : undefined;
    message.validation_context_sds_secret_config =
      (object.validation_context_sds_secret_config !== undefined &&
          object.validation_context_sds_secret_config !== null)
        ? SdsSecretConfig.fromPartial(object.validation_context_sds_secret_config)
        : undefined;
    message.validation_context_certificate_provider =
      (object.validation_context_certificate_provider !== undefined &&
          object.validation_context_certificate_provider !== null)
        ? CommonTlsContext_CertificateProvider.fromPartial(object.validation_context_certificate_provider)
        : undefined;
    message.validation_context_certificate_provider_instance =
      (object.validation_context_certificate_provider_instance !== undefined &&
          object.validation_context_certificate_provider_instance !== null)
        ? CommonTlsContext_CertificateProviderInstance.fromPartial(
          object.validation_context_certificate_provider_instance,
        )
        : undefined;
    return message;
  },
};

messageTypeRegistry.set(
  CommonTlsContext_CombinedCertificateValidationContext.$type,
  CommonTlsContext_CombinedCertificateValidationContext,
);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
