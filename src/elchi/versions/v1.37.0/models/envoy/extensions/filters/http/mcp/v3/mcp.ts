// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/filters/http/mcp/v3/mcp.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { UInt32Value } from "../../../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../../../typeRegistry";

export const protobufPackage = "envoy.extensions.filters.http.mcp.v3";

/** This filter will inspect and get attributes from MCP traffic. */
export interface Mcp {
  $type: "envoy.extensions.filters.http.mcp.v3.Mcp";
  /** Configures how the filter handles non-MCP traffic. */
  traffic_mode?:
    | Mcp_TrafficMode
    | undefined;
  /**
   * When set to true, the filter will clear the route cache after setting dynamic metadata.
   * This allows the route to be re-selected based on the MCP metadata (e.g., method, params).
   * Defaults to false.
   */
  clear_route_cache?:
    | boolean
    | undefined;
  /**
   * Maximum size of the request body to buffer for JSON-RPC validation.
   * If the request body exceeds this size, the request is rejected with ``413 Payload Too Large``.
   * This limit applies to both ``REJECT_NO_MCP`` and ``PASS_THROUGH`` modes to prevent unbounded buffering.
   *
   * It defaults to 8KB (8192 bytes) and the maximum allowed value is 10MB (10485760 bytes).
   *
   * Setting it to 0 would disable the limit. It is not recommended to do so in production.
   */
  max_request_body_size?:
    | number
    | undefined;
  /** Parser configuration, this provide the attribute extraction override. */
  parser_config?: ParserConfig | undefined;
}

/** Traffic handling mode for non-MCP traffic. */
export enum Mcp_TrafficMode {
  /**
   * PASS_THROUGH - Proxies the HTTP request and response without MCP spec check.
   * This is the default mode.
   */
  PASS_THROUGH = "PASS_THROUGH",
  /**
   * REJECT_NO_MCP - Reject requests that are not following MCP spec.
   * Valid MCP requests are:
   * - POST requests with JSON-RPC 2.0 messages
   * - GET requests for SSE streams (with Accept: text/event-stream)
   */
  REJECT_NO_MCP = "REJECT_NO_MCP",
}

export function mcp_TrafficModeFromJSON(object: any): Mcp_TrafficMode {
  switch (object) {
    case 0:
    case "PASS_THROUGH":
      return Mcp_TrafficMode.PASS_THROUGH;
    case 1:
    case "REJECT_NO_MCP":
      return Mcp_TrafficMode.REJECT_NO_MCP;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Mcp_TrafficMode");
  }
}

export function mcp_TrafficModeToJSON(object: Mcp_TrafficMode): string {
  switch (object) {
    case Mcp_TrafficMode.PASS_THROUGH:
      return "PASS_THROUGH";
    case Mcp_TrafficMode.REJECT_NO_MCP:
      return "REJECT_NO_MCP";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Mcp_TrafficMode");
  }
}

export function mcp_TrafficModeToNumber(object: Mcp_TrafficMode): number {
  switch (object) {
    case Mcp_TrafficMode.PASS_THROUGH:
      return 0;
    case Mcp_TrafficMode.REJECT_NO_MCP:
      return 1;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Mcp_TrafficMode");
  }
}

/**
 * Parser configuration with method-specific rules.
 * This configuration allows overriding the default attribute extraction behavior for specific MCP methods.
 */
export interface ParserConfig {
  $type: "envoy.extensions.filters.http.mcp.v3.ParserConfig";
  /**
   * List of rules for classification and extraction.
   * Rules are evaluated in order; the first match wins.
   * If no rule matches, extraction defaults are used and group falls back to built-in classification.
   * Built-in groups: lifecycle, tool, resource, prompt, notification, logging, sampling, completion, unknown.
   */
  methods?:
    | ParserConfig_MethodConfig[]
    | undefined;
  /**
   * The dynamic metadata key where the group name will be stored.
   * If empty, group classification is disabled.
   */
  group_metadata_key?: string | undefined;
}

/** A single attribute extraction rule. */
export interface ParserConfig_AttributeExtractionRule {
  $type: "envoy.extensions.filters.http.mcp.v3.ParserConfig.AttributeExtractionRule";
  /**
   * JSON path to extract (e.g., "params.name", "params.uri").
   * The path is a dot-separated string representing the location of the field in the JSON payload.
   * For example, "params.name" extracts the "name" field from the "params" object.
   */
  path?: string | undefined;
}

/** Configuration for a specific MCP method. */
export interface ParserConfig_MethodConfig {
  $type: "envoy.extensions.filters.http.mcp.v3.ParserConfig.MethodConfig";
  /**
   * Method name (e.g., "tools/call", "resources/read", "initialize").
   * This matches the "method" field in the JSON-RPC request.
   */
  method?:
    | string
    | undefined;
  /**
   * The group/category name to assign to this method (e.g., "tool", "lifecycle").
   * This will be emitted to dynamic metadata under the key specified by group_metadata_key.
   * If empty, the built-in group classification is used.
   */
  group?:
    | string
    | undefined;
  /**
   * Attributes to extract for this method.
   * If empty, only default attributes (jsonrpc, method) are extracted.
   */
  extraction_rules?: ParserConfig_AttributeExtractionRule[] | undefined;
}

/** Per-route override configuration for MCP filter */
export interface McpOverride {
  $type: "envoy.extensions.filters.http.mcp.v3.McpOverride";
  /** Optional per-route traffic mode override */
  traffic_mode?:
    | Mcp_TrafficMode
    | undefined;
  /**
   * Optional per-route max request body size override.
   * When set, this overrides the global max_request_body_size for this route.
   * It defaults to 8KB (8192 bytes) and the maximum allowed value is 10MB (10485760 bytes).
   */
  max_request_body_size?: number | undefined;
}

function createBaseMcp(): Mcp {
  return { $type: "envoy.extensions.filters.http.mcp.v3.Mcp" };
}

export const Mcp: MessageFns<Mcp, "envoy.extensions.filters.http.mcp.v3.Mcp"> = {
  $type: "envoy.extensions.filters.http.mcp.v3.Mcp" as const,

  encode(message: Mcp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.traffic_mode !== undefined && message.traffic_mode !== Mcp_TrafficMode.PASS_THROUGH) {
      writer.uint32(8).int32(mcp_TrafficModeToNumber(message.traffic_mode));
    }
    if (message.clear_route_cache !== undefined && message.clear_route_cache !== false) {
      writer.uint32(16).bool(message.clear_route_cache);
    }
    if (message.max_request_body_size !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.max_request_body_size! },
        writer.uint32(26).fork(),
      ).join();
    }
    if (message.parser_config !== undefined) {
      ParserConfig.encode(message.parser_config, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Mcp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMcp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.traffic_mode = mcp_TrafficModeFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.clear_route_cache = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.max_request_body_size = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.parser_config = ParserConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Mcp {
    return {
      $type: Mcp.$type,
      traffic_mode: isSet(object.traffic_mode) ? mcp_TrafficModeFromJSON(object.traffic_mode) : undefined,
      clear_route_cache: isSet(object.clear_route_cache) ? globalThis.Boolean(object.clear_route_cache) : undefined,
      max_request_body_size: isSet(object.max_request_body_size) ? Number(object.max_request_body_size) : undefined,
      parser_config: isSet(object.parser_config) ? ParserConfig.fromJSON(object.parser_config) : undefined,
    };
  },

  toJSON(message: Mcp): unknown {
    const obj: any = {};
    if (message.traffic_mode !== undefined) {
      obj.traffic_mode = mcp_TrafficModeToJSON(message.traffic_mode);
    }
    if (message.clear_route_cache !== undefined) {
      obj.clear_route_cache = message.clear_route_cache;
    }
    if (message.max_request_body_size !== undefined) {
      obj.max_request_body_size = message.max_request_body_size;
    }
    if (message.parser_config !== undefined) {
      obj.parser_config = ParserConfig.toJSON(message.parser_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Mcp>, I>>(base?: I): Mcp {
    return Mcp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Mcp>, I>>(object: I): Mcp {
    const message = createBaseMcp();
    message.traffic_mode = object.traffic_mode ?? undefined;
    message.clear_route_cache = object.clear_route_cache ?? undefined;
    message.max_request_body_size = object.max_request_body_size ?? undefined;
    message.parser_config = (object.parser_config !== undefined && object.parser_config !== null)
      ? ParserConfig.fromPartial(object.parser_config)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Mcp.$type, Mcp);

function createBaseParserConfig(): ParserConfig {
  return { $type: "envoy.extensions.filters.http.mcp.v3.ParserConfig" };
}

export const ParserConfig: MessageFns<ParserConfig, "envoy.extensions.filters.http.mcp.v3.ParserConfig"> = {
  $type: "envoy.extensions.filters.http.mcp.v3.ParserConfig" as const,

  encode(message: ParserConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.methods !== undefined && message.methods.length !== 0) {
      for (const v of message.methods) {
        ParserConfig_MethodConfig.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    if (message.group_metadata_key !== undefined && message.group_metadata_key !== "") {
      writer.uint32(18).string(message.group_metadata_key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParserConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParserConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.methods === undefined) {
            message.methods = [];
          }
          const el = ParserConfig_MethodConfig.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.methods!.push(el);
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.group_metadata_key = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParserConfig {
    return {
      $type: ParserConfig.$type,
      methods: globalThis.Array.isArray(object?.methods)
        ? object.methods.map((e: any) => ParserConfig_MethodConfig.fromJSON(e))
        : undefined,
      group_metadata_key: isSet(object.group_metadata_key) ? globalThis.String(object.group_metadata_key) : undefined,
    };
  },

  toJSON(message: ParserConfig): unknown {
    const obj: any = {};
    if (message.methods?.length) {
      obj.methods = message.methods.map((e) => ParserConfig_MethodConfig.toJSON(e));
    }
    if (message.group_metadata_key !== undefined) {
      obj.group_metadata_key = message.group_metadata_key;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParserConfig>, I>>(base?: I): ParserConfig {
    return ParserConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParserConfig>, I>>(object: I): ParserConfig {
    const message = createBaseParserConfig();
    message.methods = object.methods?.map((e) => ParserConfig_MethodConfig.fromPartial(e)) || undefined;
    message.group_metadata_key = object.group_metadata_key ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ParserConfig.$type, ParserConfig);

function createBaseParserConfig_AttributeExtractionRule(): ParserConfig_AttributeExtractionRule {
  return { $type: "envoy.extensions.filters.http.mcp.v3.ParserConfig.AttributeExtractionRule" };
}

export const ParserConfig_AttributeExtractionRule: MessageFns<
  ParserConfig_AttributeExtractionRule,
  "envoy.extensions.filters.http.mcp.v3.ParserConfig.AttributeExtractionRule"
> = {
  $type: "envoy.extensions.filters.http.mcp.v3.ParserConfig.AttributeExtractionRule" as const,

  encode(message: ParserConfig_AttributeExtractionRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== undefined && message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParserConfig_AttributeExtractionRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParserConfig_AttributeExtractionRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParserConfig_AttributeExtractionRule {
    return {
      $type: ParserConfig_AttributeExtractionRule.$type,
      path: isSet(object.path) ? globalThis.String(object.path) : undefined,
    };
  },

  toJSON(message: ParserConfig_AttributeExtractionRule): unknown {
    const obj: any = {};
    if (message.path !== undefined) {
      obj.path = message.path;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParserConfig_AttributeExtractionRule>, I>>(
    base?: I,
  ): ParserConfig_AttributeExtractionRule {
    return ParserConfig_AttributeExtractionRule.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParserConfig_AttributeExtractionRule>, I>>(
    object: I,
  ): ParserConfig_AttributeExtractionRule {
    const message = createBaseParserConfig_AttributeExtractionRule();
    message.path = object.path ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ParserConfig_AttributeExtractionRule.$type, ParserConfig_AttributeExtractionRule);

function createBaseParserConfig_MethodConfig(): ParserConfig_MethodConfig {
  return { $type: "envoy.extensions.filters.http.mcp.v3.ParserConfig.MethodConfig" };
}

export const ParserConfig_MethodConfig: MessageFns<
  ParserConfig_MethodConfig,
  "envoy.extensions.filters.http.mcp.v3.ParserConfig.MethodConfig"
> = {
  $type: "envoy.extensions.filters.http.mcp.v3.ParserConfig.MethodConfig" as const,

  encode(message: ParserConfig_MethodConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.method !== undefined && message.method !== "") {
      writer.uint32(10).string(message.method);
    }
    if (message.group !== undefined && message.group !== "") {
      writer.uint32(18).string(message.group);
    }
    if (message.extraction_rules !== undefined && message.extraction_rules.length !== 0) {
      for (const v of message.extraction_rules) {
        ParserConfig_AttributeExtractionRule.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParserConfig_MethodConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParserConfig_MethodConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.method = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.group = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.extraction_rules === undefined) {
            message.extraction_rules = [];
          }
          const el = ParserConfig_AttributeExtractionRule.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.extraction_rules!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParserConfig_MethodConfig {
    return {
      $type: ParserConfig_MethodConfig.$type,
      method: isSet(object.method) ? globalThis.String(object.method) : undefined,
      group: isSet(object.group) ? globalThis.String(object.group) : undefined,
      extraction_rules: globalThis.Array.isArray(object?.extraction_rules)
        ? object.extraction_rules.map((e: any) => ParserConfig_AttributeExtractionRule.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: ParserConfig_MethodConfig): unknown {
    const obj: any = {};
    if (message.method !== undefined) {
      obj.method = message.method;
    }
    if (message.group !== undefined) {
      obj.group = message.group;
    }
    if (message.extraction_rules?.length) {
      obj.extraction_rules = message.extraction_rules.map((e) => ParserConfig_AttributeExtractionRule.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParserConfig_MethodConfig>, I>>(base?: I): ParserConfig_MethodConfig {
    return ParserConfig_MethodConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParserConfig_MethodConfig>, I>>(object: I): ParserConfig_MethodConfig {
    const message = createBaseParserConfig_MethodConfig();
    message.method = object.method ?? undefined;
    message.group = object.group ?? undefined;
    message.extraction_rules =
      object.extraction_rules?.map((e) => ParserConfig_AttributeExtractionRule.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(ParserConfig_MethodConfig.$type, ParserConfig_MethodConfig);

function createBaseMcpOverride(): McpOverride {
  return { $type: "envoy.extensions.filters.http.mcp.v3.McpOverride" };
}

export const McpOverride: MessageFns<McpOverride, "envoy.extensions.filters.http.mcp.v3.McpOverride"> = {
  $type: "envoy.extensions.filters.http.mcp.v3.McpOverride" as const,

  encode(message: McpOverride, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.traffic_mode !== undefined && message.traffic_mode !== Mcp_TrafficMode.PASS_THROUGH) {
      writer.uint32(8).int32(mcp_TrafficModeToNumber(message.traffic_mode));
    }
    if (message.max_request_body_size !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.max_request_body_size! },
        writer.uint32(18).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): McpOverride {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMcpOverride();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.traffic_mode = mcp_TrafficModeFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.max_request_body_size = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): McpOverride {
    return {
      $type: McpOverride.$type,
      traffic_mode: isSet(object.traffic_mode) ? mcp_TrafficModeFromJSON(object.traffic_mode) : undefined,
      max_request_body_size: isSet(object.max_request_body_size) ? Number(object.max_request_body_size) : undefined,
    };
  },

  toJSON(message: McpOverride): unknown {
    const obj: any = {};
    if (message.traffic_mode !== undefined) {
      obj.traffic_mode = mcp_TrafficModeToJSON(message.traffic_mode);
    }
    if (message.max_request_body_size !== undefined) {
      obj.max_request_body_size = message.max_request_body_size;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<McpOverride>, I>>(base?: I): McpOverride {
    return McpOverride.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<McpOverride>, I>>(object: I): McpOverride {
    const message = createBaseMcpOverride();
    message.traffic_mode = object.traffic_mode ?? undefined;
    message.max_request_body_size = object.max_request_body_size ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(McpOverride.$type, McpOverride);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
