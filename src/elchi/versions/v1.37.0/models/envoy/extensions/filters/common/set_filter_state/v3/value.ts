// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/filters/common/set_filter_state/v3/value.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { messageTypeRegistry } from "../../../../../../typeRegistry";
import { SubstitutionFormatString } from "../../../../../config/core/v3/substitution_format_string";

export const protobufPackage = "envoy.extensions.filters.common.set_filter_state.v3";

/**
 * A filter state key and value pair.
 * [#next-free-field: 7]
 */
export interface FilterStateValue {
  $type: "envoy.extensions.filters.common.set_filter_state.v3.FilterStateValue";
  key?:
    | //
    /**
     * The name under which the filter state object will be stored and can be retrieved.
     *
     * When using :ref:`well-known filter state keys <well_known_filter_state>` (e.g.,
     * ``envoy.network.upstream_server_name``, ``envoy.tcp_proxy.cluster``), the object key serves
     * dual purpose where it identifies both where the data is stored and which factory creates the
     * object. In this case, :ref:`factory_key
     * <envoy_v3_api_field_extensions.filters.common.set_filter_state.v3.FilterStateValue.factory_key>`
     * is not needed.
     *
     * When using a custom key name which is not from the well-known list, you must also specify
     * :ref:`factory_key
     * <envoy_v3_api_field_extensions.filters.common.set_filter_state.v3.FilterStateValue.factory_key>`
     * to indicate which factory should create the object from your value.
     *
     * Example using a well-known key where ``factory_key`` is not needed:
     *
     * .. code-block:: yaml
     *
     *    object_key: envoy.tcp_proxy.cluster
     *    format_string:
     *      text_format_source:
     *        inline_string: "my-cluster"
     *
     * Example using a custom key which requires a ``factory_key``:
     *
     * .. code-block:: yaml
     *
     *    object_key: my.custom.key
     *    factory_key: envoy.string
     *    format_string:
     *      text_format_source:
     *        inline_string: "my-value"
     */
    { $case: "object_key"; object_key: string }
    | undefined;
  /**
   * Specifies which registered factory should be used to create the filter state object from the
   * provided value. This field is required when :ref:`object_key
   * <envoy_v3_api_field_extensions.filters.common.set_filter_state.v3.FilterStateValue.object_key>`
   * is a custom name not found in the :ref:`well-known filter state keys <well_known_filter_state>`.
   *
   * Each well-known key has a factory registered with the same name (e.g., the key
   * ``envoy.tcp_proxy.cluster`` has a factory also named ``envoy.tcp_proxy.cluster``). For custom keys,
   * use one of the following generic factories:
   *
   * * ``envoy.string``: Creates a generic string object. Use this for arbitrary string values that
   *   will be accessed via ``StringAccessor``.
   *
   * If not specified, defaults to the value of ``object_key``.
   */
  factory_key?: string | undefined;
  value?:
    | //
    /**
     * Uses the :ref:`format string <config_access_log_format_strings>` to
     * instantiate the filter state object value.
     */
    { $case: "format_string"; format_string: SubstitutionFormatString }
    | undefined;
  /**
   * If marked as read-only, the filter state key value is locked, and cannot
   * be overridden by any filter, including this filter.
   */
  read_only?:
    | boolean
    | undefined;
  /**
   * Configures the object to be shared with the upstream internal connections. See :ref:`internal upstream
   * transport <config_internal_upstream_transport>` for more details on the filter state sharing with
   * the internal connections.
   */
  shared_with_upstream?:
    | FilterStateValue_SharedWithUpstream
    | undefined;
  /**
   * Skip the update if the value evaluates to an empty string.
   * This option can be used to supply multiple alternatives for the same filter state object key.
   */
  skip_if_empty?: boolean | undefined;
}

export enum FilterStateValue_SharedWithUpstream {
  /** NONE - Object is not shared with the upstream internal connections. */
  NONE = "NONE",
  /** ONCE - Object is shared with the upstream internal connection. */
  ONCE = "ONCE",
  /** TRANSITIVE - Object is shared with the upstream internal connection and any internal connection upstream from it. */
  TRANSITIVE = "TRANSITIVE",
}

export function filterStateValue_SharedWithUpstreamFromJSON(object: any): FilterStateValue_SharedWithUpstream {
  switch (object) {
    case 0:
    case "NONE":
      return FilterStateValue_SharedWithUpstream.NONE;
    case 1:
    case "ONCE":
      return FilterStateValue_SharedWithUpstream.ONCE;
    case 2:
    case "TRANSITIVE":
      return FilterStateValue_SharedWithUpstream.TRANSITIVE;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum FilterStateValue_SharedWithUpstream");
  }
}

export function filterStateValue_SharedWithUpstreamToJSON(object: FilterStateValue_SharedWithUpstream): string {
  switch (object) {
    case FilterStateValue_SharedWithUpstream.NONE:
      return "NONE";
    case FilterStateValue_SharedWithUpstream.ONCE:
      return "ONCE";
    case FilterStateValue_SharedWithUpstream.TRANSITIVE:
      return "TRANSITIVE";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum FilterStateValue_SharedWithUpstream");
  }
}

export function filterStateValue_SharedWithUpstreamToNumber(object: FilterStateValue_SharedWithUpstream): number {
  switch (object) {
    case FilterStateValue_SharedWithUpstream.NONE:
      return 0;
    case FilterStateValue_SharedWithUpstream.ONCE:
      return 1;
    case FilterStateValue_SharedWithUpstream.TRANSITIVE:
      return 2;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum FilterStateValue_SharedWithUpstream");
  }
}

function createBaseFilterStateValue(): FilterStateValue {
  return {
    $type: "envoy.extensions.filters.common.set_filter_state.v3.FilterStateValue",
    key: undefined,
    value: undefined,
  };
}

export const FilterStateValue: MessageFns<
  FilterStateValue,
  "envoy.extensions.filters.common.set_filter_state.v3.FilterStateValue"
> = {
  $type: "envoy.extensions.filters.common.set_filter_state.v3.FilterStateValue" as const,

  encode(message: FilterStateValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.key?.$case) {
      case "object_key":
        writer.uint32(10).string(message.key.object_key);
        break;
    }
    if (message.factory_key !== undefined && message.factory_key !== "") {
      writer.uint32(50).string(message.factory_key);
    }
    switch (message.value?.$case) {
      case "format_string":
        SubstitutionFormatString.encode(message.value.format_string, writer.uint32(18).fork()).join();
        break;
    }
    if (message.read_only !== undefined && message.read_only !== false) {
      writer.uint32(24).bool(message.read_only);
    }
    if (
      message.shared_with_upstream !== undefined &&
      message.shared_with_upstream !== FilterStateValue_SharedWithUpstream.NONE
    ) {
      writer.uint32(32).int32(filterStateValue_SharedWithUpstreamToNumber(message.shared_with_upstream));
    }
    if (message.skip_if_empty !== undefined && message.skip_if_empty !== false) {
      writer.uint32(40).bool(message.skip_if_empty);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FilterStateValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilterStateValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = { $case: "object_key", object_key: reader.string() };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.factory_key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = {
            $case: "format_string",
            format_string: SubstitutionFormatString.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.read_only = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.shared_with_upstream = filterStateValue_SharedWithUpstreamFromJSON(reader.int32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.skip_if_empty = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FilterStateValue {
    return {
      $type: FilterStateValue.$type,
      key: isSet(object.object_key)
        ? { $case: "object_key", object_key: globalThis.String(object.object_key) }
        : undefined,
      factory_key: isSet(object.factory_key) ? globalThis.String(object.factory_key) : undefined,
      value: isSet(object.format_string)
        ? { $case: "format_string", format_string: SubstitutionFormatString.fromJSON(object.format_string) }
        : undefined,
      read_only: isSet(object.read_only) ? globalThis.Boolean(object.read_only) : undefined,
      shared_with_upstream: isSet(object.shared_with_upstream)
        ? filterStateValue_SharedWithUpstreamFromJSON(object.shared_with_upstream)
        : undefined,
      skip_if_empty: isSet(object.skip_if_empty) ? globalThis.Boolean(object.skip_if_empty) : undefined,
    };
  },

  toJSON(message: FilterStateValue): unknown {
    const obj: any = {};
    if (message.key?.$case === "object_key") {
      obj.object_key = message.key.object_key;
    }
    if (message.factory_key !== undefined) {
      obj.factory_key = message.factory_key;
    }
    if (message.value?.$case === "format_string") {
      obj.format_string = SubstitutionFormatString.toJSON(message.value.format_string);
    }
    if (message.read_only !== undefined) {
      obj.read_only = message.read_only;
    }
    if (message.shared_with_upstream !== undefined) {
      obj.shared_with_upstream = filterStateValue_SharedWithUpstreamToJSON(message.shared_with_upstream);
    }
    if (message.skip_if_empty !== undefined) {
      obj.skip_if_empty = message.skip_if_empty;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FilterStateValue>, I>>(base?: I): FilterStateValue {
    return FilterStateValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FilterStateValue>, I>>(object: I): FilterStateValue {
    const message = createBaseFilterStateValue();
    if (object.key?.$case === "object_key" && object.key?.object_key !== undefined && object.key?.object_key !== null) {
      message.key = { $case: "object_key", object_key: object.key.object_key };
    }
    message.factory_key = object.factory_key ?? undefined;
    if (
      object.value?.$case === "format_string" &&
      object.value?.format_string !== undefined &&
      object.value?.format_string !== null
    ) {
      message.value = {
        $case: "format_string",
        format_string: SubstitutionFormatString.fromPartial(object.value.format_string),
      };
    }
    message.read_only = object.read_only ?? undefined;
    message.shared_with_upstream = object.shared_with_upstream ?? undefined;
    message.skip_if_empty = object.skip_if_empty ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(FilterStateValue.$type, FilterStateValue);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
