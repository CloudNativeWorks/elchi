// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/filters/listener/proxy_protocol/v3/proxy_protocol.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { messageTypeRegistry } from "../../../../../../typeRegistry";
import {
  ProxyProtocolConfig_Version,
  proxyProtocolConfig_VersionFromJSON,
  proxyProtocolConfig_VersionToJSON,
  proxyProtocolConfig_VersionToNumber,
  ProxyProtocolPassThroughTLVs,
} from "../../../../../config/core/v3/proxy_protocol";

export const protobufPackage = "envoy.extensions.filters.listener.proxy_protocol.v3";

/** [#next-free-field: 7] */
export interface ProxyProtocol {
  $type: "envoy.extensions.filters.listener.proxy_protocol.v3.ProxyProtocol";
  /** The list of rules to apply to requests. */
  rules?:
    | ProxyProtocol_Rule[]
    | undefined;
  /**
   * Allow requests through that don't use proxy protocol. Defaults to false.
   *
   * .. attention::
   *
   *   This breaks conformance with the specification.
   *   Only enable if ALL traffic to the listener comes from a trusted source.
   *   For more information on the security implications of this feature, see
   *   https://www.haproxy.org/download/2.1/doc/proxy-protocol.txt
   *
   * .. attention::
   *
   *   Requests of 12 or fewer bytes that match the proxy protocol v2 signature
   *   and requests of 6 or fewer bytes that match the proxy protocol v1
   *   signature will timeout (Envoy is unable to differentiate these requests
   *   from incomplete proxy protocol requests).
   */
  allow_requests_without_proxy_protocol?:
    | boolean
    | undefined;
  /**
   * This config controls which TLVs can be passed to filter state if it is Proxy Protocol
   * V2 header. If there is no setting for this field, no TLVs will be passed through.
   *
   * .. note::
   *
   *   If this is configured, you likely also want to set
   *   :ref:`core.v3.ProxyProtocolConfig.pass_through_tlvs <envoy_v3_api_field_config.core.v3.ProxyProtocolConfig.pass_through_tlvs>`,
   *   which controls pass-through for the upstream.
   */
  pass_through_tlvs?:
    | ProxyProtocolPassThroughTLVs
    | undefined;
  /**
   * The PROXY protocol versions that won't be matched. Useful to limit the scope and attack surface of the filter.
   *
   * When the filter receives PROXY protocol data that is disallowed, it will reject the connection.
   * By default, the filter will match all PROXY protocol versions.
   * See https://www.haproxy.org/download/2.1/doc/proxy-protocol.txt for details.
   *
   * .. attention::
   *
   *   When used in conjunction with the :ref:`allow_requests_without_proxy_protocol <envoy_v3_api_field_extensions.filters.listener.proxy_protocol.v3.ProxyProtocol.allow_requests_without_proxy_protocol>`,
   *   the filter will not attempt to match signatures for the disallowed versions.
   *   For example, when ``disallowed_versions=V2``, ``allow_requests_without_proxy_protocol=true``,
   *   and an incoming request matches the V2 signature, the filter will allow the request through without any modification.
   *   The filter treats this request as if it did not have any PROXY protocol information.
   */
  disallowed_versions?:
    | ProxyProtocolConfig_Version[]
    | undefined;
  /**
   * The human readable prefix to use when emitting statistics for the filter.
   * If not configured, statistics will be emitted without the prefix segment.
   * See the :ref:`filter's statistics documentation <config_listener_filters_proxy_protocol>` for
   * more information.
   */
  stat_prefix?:
    | string
    | undefined;
  /** Controls where TLV values are stored when rules match. Defaults to DYNAMIC_METADATA. */
  tlv_location?: ProxyProtocol_TlvLocation | undefined;
}

/** Controls where TLV values are stored when rules match. */
export enum ProxyProtocol_TlvLocation {
  /** DYNAMIC_METADATA - Store TLV values in dynamic metadata. */
  DYNAMIC_METADATA = "DYNAMIC_METADATA",
  /** FILTER_STATE - Store TLV values in filter state as a single map-like object. */
  FILTER_STATE = "FILTER_STATE",
}

export function proxyProtocol_TlvLocationFromJSON(object: any): ProxyProtocol_TlvLocation {
  switch (object) {
    case 0:
    case "DYNAMIC_METADATA":
      return ProxyProtocol_TlvLocation.DYNAMIC_METADATA;
    case 1:
    case "FILTER_STATE":
      return ProxyProtocol_TlvLocation.FILTER_STATE;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ProxyProtocol_TlvLocation");
  }
}

export function proxyProtocol_TlvLocationToJSON(object: ProxyProtocol_TlvLocation): string {
  switch (object) {
    case ProxyProtocol_TlvLocation.DYNAMIC_METADATA:
      return "DYNAMIC_METADATA";
    case ProxyProtocol_TlvLocation.FILTER_STATE:
      return "FILTER_STATE";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ProxyProtocol_TlvLocation");
  }
}

export function proxyProtocol_TlvLocationToNumber(object: ProxyProtocol_TlvLocation): number {
  switch (object) {
    case ProxyProtocol_TlvLocation.DYNAMIC_METADATA:
      return 0;
    case ProxyProtocol_TlvLocation.FILTER_STATE:
      return 1;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ProxyProtocol_TlvLocation");
  }
}

export interface ProxyProtocol_KeyValuePair {
  $type: "envoy.extensions.filters.listener.proxy_protocol.v3.ProxyProtocol.KeyValuePair";
  /** The namespace â€” if this is empty, the filter's namespace will be used. */
  metadata_namespace?:
    | string
    | undefined;
  /** The key to use within the namespace. */
  key?: string | undefined;
}

/** A Rule defines what metadata to apply when a header is present or missing. */
export interface ProxyProtocol_Rule {
  $type: "envoy.extensions.filters.listener.proxy_protocol.v3.ProxyProtocol.Rule";
  /**
   * The type that triggers the rule - required
   * TLV type is defined as uint8_t in proxy protocol. See `the spec
   * <https://www.haproxy.org/download/2.1/doc/proxy-protocol.txt>`_ for details.
   */
  tlv_type?:
    | number
    | undefined;
  /** If the TLV type is present, apply this metadata KeyValuePair. */
  on_tlv_present?: ProxyProtocol_KeyValuePair | undefined;
}

function createBaseProxyProtocol(): ProxyProtocol {
  return { $type: "envoy.extensions.filters.listener.proxy_protocol.v3.ProxyProtocol" };
}

export const ProxyProtocol: MessageFns<
  ProxyProtocol,
  "envoy.extensions.filters.listener.proxy_protocol.v3.ProxyProtocol"
> = {
  $type: "envoy.extensions.filters.listener.proxy_protocol.v3.ProxyProtocol" as const,

  encode(message: ProxyProtocol, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rules !== undefined && message.rules.length !== 0) {
      for (const v of message.rules) {
        ProxyProtocol_Rule.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    if (
      message.allow_requests_without_proxy_protocol !== undefined &&
      message.allow_requests_without_proxy_protocol !== false
    ) {
      writer.uint32(16).bool(message.allow_requests_without_proxy_protocol);
    }
    if (message.pass_through_tlvs !== undefined) {
      ProxyProtocolPassThroughTLVs.encode(message.pass_through_tlvs, writer.uint32(26).fork()).join();
    }
    if (message.disallowed_versions !== undefined && message.disallowed_versions.length !== 0) {
      writer.uint32(34).fork();
      for (const v of message.disallowed_versions) {
        writer.int32(proxyProtocolConfig_VersionToNumber(v));
      }
      writer.join();
    }
    if (message.stat_prefix !== undefined && message.stat_prefix !== "") {
      writer.uint32(42).string(message.stat_prefix);
    }
    if (message.tlv_location !== undefined && message.tlv_location !== ProxyProtocol_TlvLocation.DYNAMIC_METADATA) {
      writer.uint32(48).int32(proxyProtocol_TlvLocationToNumber(message.tlv_location));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProxyProtocol {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProxyProtocol();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.rules === undefined) {
            message.rules = [];
          }
          const el = ProxyProtocol_Rule.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.rules!.push(el);
          }
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.allow_requests_without_proxy_protocol = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pass_through_tlvs = ProxyProtocolPassThroughTLVs.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag === 32) {
            if (message.disallowed_versions === undefined) {
              message.disallowed_versions = [];
            }
            message.disallowed_versions!.push(proxyProtocolConfig_VersionFromJSON(reader.int32()));

            continue;
          }

          if (tag === 34) {
            if (message.disallowed_versions === undefined) {
              message.disallowed_versions = [];
            }
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.disallowed_versions!.push(proxyProtocolConfig_VersionFromJSON(reader.int32()));
            }

            continue;
          }

          break;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.stat_prefix = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.tlv_location = proxyProtocol_TlvLocationFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProxyProtocol {
    return {
      $type: ProxyProtocol.$type,
      rules: globalThis.Array.isArray(object?.rules)
        ? object.rules.map((e: any) => ProxyProtocol_Rule.fromJSON(e))
        : undefined,
      allow_requests_without_proxy_protocol: isSet(object.allow_requests_without_proxy_protocol)
        ? globalThis.Boolean(object.allow_requests_without_proxy_protocol)
        : undefined,
      pass_through_tlvs: isSet(object.pass_through_tlvs)
        ? ProxyProtocolPassThroughTLVs.fromJSON(object.pass_through_tlvs)
        : undefined,
      disallowed_versions: globalThis.Array.isArray(object?.disallowed_versions)
        ? object.disallowed_versions.map((e: any) => proxyProtocolConfig_VersionFromJSON(e))
        : undefined,
      stat_prefix: isSet(object.stat_prefix) ? globalThis.String(object.stat_prefix) : undefined,
      tlv_location: isSet(object.tlv_location) ? proxyProtocol_TlvLocationFromJSON(object.tlv_location) : undefined,
    };
  },

  toJSON(message: ProxyProtocol): unknown {
    const obj: any = {};
    if (message.rules?.length) {
      obj.rules = message.rules.map((e) => ProxyProtocol_Rule.toJSON(e));
    }
    if (message.allow_requests_without_proxy_protocol !== undefined) {
      obj.allow_requests_without_proxy_protocol = message.allow_requests_without_proxy_protocol;
    }
    if (message.pass_through_tlvs !== undefined) {
      obj.pass_through_tlvs = ProxyProtocolPassThroughTLVs.toJSON(message.pass_through_tlvs);
    }
    if (message.disallowed_versions?.length) {
      obj.disallowed_versions = message.disallowed_versions.map((e) => proxyProtocolConfig_VersionToJSON(e));
    }
    if (message.stat_prefix !== undefined) {
      obj.stat_prefix = message.stat_prefix;
    }
    if (message.tlv_location !== undefined) {
      obj.tlv_location = proxyProtocol_TlvLocationToJSON(message.tlv_location);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProxyProtocol>, I>>(base?: I): ProxyProtocol {
    return ProxyProtocol.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProxyProtocol>, I>>(object: I): ProxyProtocol {
    const message = createBaseProxyProtocol();
    message.rules = object.rules?.map((e) => ProxyProtocol_Rule.fromPartial(e)) || undefined;
    message.allow_requests_without_proxy_protocol = object.allow_requests_without_proxy_protocol ?? undefined;
    message.pass_through_tlvs = (object.pass_through_tlvs !== undefined && object.pass_through_tlvs !== null)
      ? ProxyProtocolPassThroughTLVs.fromPartial(object.pass_through_tlvs)
      : undefined;
    message.disallowed_versions = object.disallowed_versions?.map((e) => e) || undefined;
    message.stat_prefix = object.stat_prefix ?? undefined;
    message.tlv_location = object.tlv_location ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ProxyProtocol.$type, ProxyProtocol);

function createBaseProxyProtocol_KeyValuePair(): ProxyProtocol_KeyValuePair {
  return { $type: "envoy.extensions.filters.listener.proxy_protocol.v3.ProxyProtocol.KeyValuePair" };
}

export const ProxyProtocol_KeyValuePair: MessageFns<
  ProxyProtocol_KeyValuePair,
  "envoy.extensions.filters.listener.proxy_protocol.v3.ProxyProtocol.KeyValuePair"
> = {
  $type: "envoy.extensions.filters.listener.proxy_protocol.v3.ProxyProtocol.KeyValuePair" as const,

  encode(message: ProxyProtocol_KeyValuePair, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadata_namespace !== undefined && message.metadata_namespace !== "") {
      writer.uint32(10).string(message.metadata_namespace);
    }
    if (message.key !== undefined && message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProxyProtocol_KeyValuePair {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProxyProtocol_KeyValuePair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.metadata_namespace = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProxyProtocol_KeyValuePair {
    return {
      $type: ProxyProtocol_KeyValuePair.$type,
      metadata_namespace: isSet(object.metadata_namespace) ? globalThis.String(object.metadata_namespace) : undefined,
      key: isSet(object.key) ? globalThis.String(object.key) : undefined,
    };
  },

  toJSON(message: ProxyProtocol_KeyValuePair): unknown {
    const obj: any = {};
    if (message.metadata_namespace !== undefined) {
      obj.metadata_namespace = message.metadata_namespace;
    }
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProxyProtocol_KeyValuePair>, I>>(base?: I): ProxyProtocol_KeyValuePair {
    return ProxyProtocol_KeyValuePair.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProxyProtocol_KeyValuePair>, I>>(object: I): ProxyProtocol_KeyValuePair {
    const message = createBaseProxyProtocol_KeyValuePair();
    message.metadata_namespace = object.metadata_namespace ?? undefined;
    message.key = object.key ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ProxyProtocol_KeyValuePair.$type, ProxyProtocol_KeyValuePair);

function createBaseProxyProtocol_Rule(): ProxyProtocol_Rule {
  return { $type: "envoy.extensions.filters.listener.proxy_protocol.v3.ProxyProtocol.Rule" };
}

export const ProxyProtocol_Rule: MessageFns<
  ProxyProtocol_Rule,
  "envoy.extensions.filters.listener.proxy_protocol.v3.ProxyProtocol.Rule"
> = {
  $type: "envoy.extensions.filters.listener.proxy_protocol.v3.ProxyProtocol.Rule" as const,

  encode(message: ProxyProtocol_Rule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tlv_type !== undefined && message.tlv_type !== 0) {
      writer.uint32(8).uint32(message.tlv_type);
    }
    if (message.on_tlv_present !== undefined) {
      ProxyProtocol_KeyValuePair.encode(message.on_tlv_present, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProxyProtocol_Rule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProxyProtocol_Rule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.tlv_type = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.on_tlv_present = ProxyProtocol_KeyValuePair.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProxyProtocol_Rule {
    return {
      $type: ProxyProtocol_Rule.$type,
      tlv_type: isSet(object.tlv_type) ? globalThis.Number(object.tlv_type) : undefined,
      on_tlv_present: isSet(object.on_tlv_present)
        ? ProxyProtocol_KeyValuePair.fromJSON(object.on_tlv_present)
        : undefined,
    };
  },

  toJSON(message: ProxyProtocol_Rule): unknown {
    const obj: any = {};
    if (message.tlv_type !== undefined) {
      obj.tlv_type = Math.round(message.tlv_type);
    }
    if (message.on_tlv_present !== undefined) {
      obj.on_tlv_present = ProxyProtocol_KeyValuePair.toJSON(message.on_tlv_present);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProxyProtocol_Rule>, I>>(base?: I): ProxyProtocol_Rule {
    return ProxyProtocol_Rule.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProxyProtocol_Rule>, I>>(object: I): ProxyProtocol_Rule {
    const message = createBaseProxyProtocol_Rule();
    message.tlv_type = object.tlv_type ?? undefined;
    message.on_tlv_present = (object.on_tlv_present !== undefined && object.on_tlv_present !== null)
      ? ProxyProtocol_KeyValuePair.fromPartial(object.on_tlv_present)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(ProxyProtocol_Rule.$type, ProxyProtocol_Rule);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
