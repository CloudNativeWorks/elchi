// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/filters/http/mcp_router/v3/mcp_router.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../../../../google/protobuf/duration";
import { messageTypeRegistry } from "../../../../../../typeRegistry";
import { MetadataKey } from "../../../../../type/metadata/v3/metadata";

export const protobufPackage = "envoy.extensions.filters.http.mcp_router.v3";

/** Extract identity from a request header. */
export interface HeaderSource {
  $type: "envoy.extensions.filters.http.mcp_router.v3.HeaderSource";
  /** Header name to extract (e.g., "x-user-identity"). */
  name?: string | undefined;
}

/** Extract identity from dynamic metadata (e.g., populated by JWT or ext_authz filter). */
export interface DynamicMetadataSource {
  $type: "envoy.extensions.filters.http.mcp_router.v3.DynamicMetadataSource";
  /** The metadata key to retrieve the value from. */
  key?: MetadataKey | undefined;
}

/**
 * Defines how the identity (user/principal) is extracted from the request.
 * Exactly one of ``header`` or ``dynamic_metadata`` must be set.
 */
export interface IdentityExtractor {
  $type: "envoy.extensions.filters.http.mcp_router.v3.IdentityExtractor";
  /** Extract identity from a request header. */
  header?:
    | HeaderSource
    | undefined;
  /** Extract identity from dynamic metadata. */
  dynamic_metadata?: DynamicMetadataSource | undefined;
}

/** Specifies how to handle requests where the identity is missing or mismatched. */
export interface ValidationPolicy {
  $type: "envoy.extensions.filters.http.mcp_router.v3.ValidationPolicy";
  mode?: ValidationPolicy_Mode | undefined;
}

export enum ValidationPolicy_Mode {
  /** MODE_UNSPECIFIED - Not specified. Defaults to DISABLED behavior. */
  MODE_UNSPECIFIED = "MODE_UNSPECIFIED",
  /**
   * DISABLED - Bind identity on Initialize if present, but do not validate subsequent requests.
   * If extraction fails, the session proceeds anonymously.
   */
  DISABLED = "DISABLED",
  /**
   * ENFORCE - Reject the request (403) if the identity cannot be extracted
   * or if the session identity does not match the request identity.
   */
  ENFORCE = "ENFORCE",
}

export function validationPolicy_ModeFromJSON(object: any): ValidationPolicy_Mode {
  switch (object) {
    case 0:
    case "MODE_UNSPECIFIED":
      return ValidationPolicy_Mode.MODE_UNSPECIFIED;
    case 1:
    case "DISABLED":
      return ValidationPolicy_Mode.DISABLED;
    case 2:
    case "ENFORCE":
      return ValidationPolicy_Mode.ENFORCE;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ValidationPolicy_Mode");
  }
}

export function validationPolicy_ModeToJSON(object: ValidationPolicy_Mode): string {
  switch (object) {
    case ValidationPolicy_Mode.MODE_UNSPECIFIED:
      return "MODE_UNSPECIFIED";
    case ValidationPolicy_Mode.DISABLED:
      return "DISABLED";
    case ValidationPolicy_Mode.ENFORCE:
      return "ENFORCE";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ValidationPolicy_Mode");
  }
}

export function validationPolicy_ModeToNumber(object: ValidationPolicy_Mode): number {
  switch (object) {
    case ValidationPolicy_Mode.MODE_UNSPECIFIED:
      return 0;
    case ValidationPolicy_Mode.DISABLED:
      return 1;
    case ValidationPolicy_Mode.ENFORCE:
      return 2;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ValidationPolicy_Mode");
  }
}

/** Session identity configuration. */
export interface SessionIdentity {
  $type: "envoy.extensions.filters.http.mcp_router.v3.SessionIdentity";
  /** Defines how the identity (user/principal) is extracted from the request. */
  identity?:
    | IdentityExtractor
    | undefined;
  /**
   * Specifies how to handle requests where the subject is missing or invalid.
   * Defaults to DISABLED.
   */
  validation?: ValidationPolicy | undefined;
}

export interface McpRouter {
  $type: "envoy.extensions.filters.http.mcp_router.v3.McpRouter";
  /**
   * A list of remote MCP servers. MCP router aggregates capabilities, tools and resources from remote MCP servers
   * and presents itself as single MCP server to the client. All remote MCP servers are sent the same capabilities
   * that the client presented to Envoy.
   */
  servers?:
    | McpRouter_McpBackend[]
    | undefined;
  /**
   * If set, extracts a request "subject" and binds it into the MCP session.
   * If not set, sessions are created without identity binding.
   */
  session_identity?: SessionIdentity | undefined;
}

/** Specification of the MCP server. */
export interface McpRouter_McpBackend {
  $type: "envoy.extensions.filters.http.mcp_router.v3.McpRouter.McpBackend";
  /**
   * Unique name for this backend. Used for:
   * - Tool name prefixing (e.g., "time__get_current_time")
   * - Session ID composition
   * - Logging and error messages.
   * Default will be the cluster name if not specified.
   */
  name?:
    | string
    | undefined;
  /** Backend target specification. */
  mcp_cluster?: McpRouter_McpCluster | undefined;
}

/** Cluster-based backend configuration. */
export interface McpRouter_McpCluster {
  $type: "envoy.extensions.filters.http.mcp_router.v3.McpRouter.McpCluster";
  /** Cluster name to route requests to. */
  cluster?:
    | string
    | undefined;
  /** Path to use for MCP requests. Defaults to "/mcp". */
  path?:
    | string
    | undefined;
  /**
   * Request timeout.
   * If not set, uses cluster's timeout configuration.
   */
  timeout?:
    | Duration
    | undefined;
  /**
   * Indicates that during forwarding, the host header will be swapped with
   * this value.
   */
  host_rewrite_literal?: string | undefined;
}

function createBaseHeaderSource(): HeaderSource {
  return { $type: "envoy.extensions.filters.http.mcp_router.v3.HeaderSource" };
}

export const HeaderSource: MessageFns<HeaderSource, "envoy.extensions.filters.http.mcp_router.v3.HeaderSource"> = {
  $type: "envoy.extensions.filters.http.mcp_router.v3.HeaderSource" as const,

  encode(message: HeaderSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeaderSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeaderSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeaderSource {
    return { $type: HeaderSource.$type, name: isSet(object.name) ? globalThis.String(object.name) : undefined };
  },

  toJSON(message: HeaderSource): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HeaderSource>, I>>(base?: I): HeaderSource {
    return HeaderSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HeaderSource>, I>>(object: I): HeaderSource {
    const message = createBaseHeaderSource();
    message.name = object.name ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(HeaderSource.$type, HeaderSource);

function createBaseDynamicMetadataSource(): DynamicMetadataSource {
  return { $type: "envoy.extensions.filters.http.mcp_router.v3.DynamicMetadataSource" };
}

export const DynamicMetadataSource: MessageFns<
  DynamicMetadataSource,
  "envoy.extensions.filters.http.mcp_router.v3.DynamicMetadataSource"
> = {
  $type: "envoy.extensions.filters.http.mcp_router.v3.DynamicMetadataSource" as const,

  encode(message: DynamicMetadataSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined) {
      MetadataKey.encode(message.key, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DynamicMetadataSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDynamicMetadataSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = MetadataKey.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DynamicMetadataSource {
    return {
      $type: DynamicMetadataSource.$type,
      key: isSet(object.key) ? MetadataKey.fromJSON(object.key) : undefined,
    };
  },

  toJSON(message: DynamicMetadataSource): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = MetadataKey.toJSON(message.key);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DynamicMetadataSource>, I>>(base?: I): DynamicMetadataSource {
    return DynamicMetadataSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DynamicMetadataSource>, I>>(object: I): DynamicMetadataSource {
    const message = createBaseDynamicMetadataSource();
    message.key = (object.key !== undefined && object.key !== null) ? MetadataKey.fromPartial(object.key) : undefined;
    return message;
  },
};

messageTypeRegistry.set(DynamicMetadataSource.$type, DynamicMetadataSource);

function createBaseIdentityExtractor(): IdentityExtractor {
  return { $type: "envoy.extensions.filters.http.mcp_router.v3.IdentityExtractor" };
}

export const IdentityExtractor: MessageFns<
  IdentityExtractor,
  "envoy.extensions.filters.http.mcp_router.v3.IdentityExtractor"
> = {
  $type: "envoy.extensions.filters.http.mcp_router.v3.IdentityExtractor" as const,

  encode(message: IdentityExtractor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      HeaderSource.encode(message.header, writer.uint32(10).fork()).join();
    }
    if (message.dynamic_metadata !== undefined) {
      DynamicMetadataSource.encode(message.dynamic_metadata, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IdentityExtractor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIdentityExtractor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header = HeaderSource.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dynamic_metadata = DynamicMetadataSource.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IdentityExtractor {
    return {
      $type: IdentityExtractor.$type,
      header: isSet(object.header) ? HeaderSource.fromJSON(object.header) : undefined,
      dynamic_metadata: isSet(object.dynamic_metadata)
        ? DynamicMetadataSource.fromJSON(object.dynamic_metadata)
        : undefined,
    };
  },

  toJSON(message: IdentityExtractor): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = HeaderSource.toJSON(message.header);
    }
    if (message.dynamic_metadata !== undefined) {
      obj.dynamic_metadata = DynamicMetadataSource.toJSON(message.dynamic_metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IdentityExtractor>, I>>(base?: I): IdentityExtractor {
    return IdentityExtractor.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IdentityExtractor>, I>>(object: I): IdentityExtractor {
    const message = createBaseIdentityExtractor();
    message.header = (object.header !== undefined && object.header !== null)
      ? HeaderSource.fromPartial(object.header)
      : undefined;
    message.dynamic_metadata = (object.dynamic_metadata !== undefined && object.dynamic_metadata !== null)
      ? DynamicMetadataSource.fromPartial(object.dynamic_metadata)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(IdentityExtractor.$type, IdentityExtractor);

function createBaseValidationPolicy(): ValidationPolicy {
  return { $type: "envoy.extensions.filters.http.mcp_router.v3.ValidationPolicy" };
}

export const ValidationPolicy: MessageFns<
  ValidationPolicy,
  "envoy.extensions.filters.http.mcp_router.v3.ValidationPolicy"
> = {
  $type: "envoy.extensions.filters.http.mcp_router.v3.ValidationPolicy" as const,

  encode(message: ValidationPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mode !== undefined && message.mode !== ValidationPolicy_Mode.MODE_UNSPECIFIED) {
      writer.uint32(8).int32(validationPolicy_ModeToNumber(message.mode));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidationPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidationPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.mode = validationPolicy_ModeFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidationPolicy {
    return {
      $type: ValidationPolicy.$type,
      mode: isSet(object.mode) ? validationPolicy_ModeFromJSON(object.mode) : undefined,
    };
  },

  toJSON(message: ValidationPolicy): unknown {
    const obj: any = {};
    if (message.mode !== undefined) {
      obj.mode = validationPolicy_ModeToJSON(message.mode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidationPolicy>, I>>(base?: I): ValidationPolicy {
    return ValidationPolicy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidationPolicy>, I>>(object: I): ValidationPolicy {
    const message = createBaseValidationPolicy();
    message.mode = object.mode ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ValidationPolicy.$type, ValidationPolicy);

function createBaseSessionIdentity(): SessionIdentity {
  return { $type: "envoy.extensions.filters.http.mcp_router.v3.SessionIdentity" };
}

export const SessionIdentity: MessageFns<
  SessionIdentity,
  "envoy.extensions.filters.http.mcp_router.v3.SessionIdentity"
> = {
  $type: "envoy.extensions.filters.http.mcp_router.v3.SessionIdentity" as const,

  encode(message: SessionIdentity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.identity !== undefined) {
      IdentityExtractor.encode(message.identity, writer.uint32(10).fork()).join();
    }
    if (message.validation !== undefined) {
      ValidationPolicy.encode(message.validation, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionIdentity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionIdentity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.identity = IdentityExtractor.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.validation = ValidationPolicy.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionIdentity {
    return {
      $type: SessionIdentity.$type,
      identity: isSet(object.identity) ? IdentityExtractor.fromJSON(object.identity) : undefined,
      validation: isSet(object.validation) ? ValidationPolicy.fromJSON(object.validation) : undefined,
    };
  },

  toJSON(message: SessionIdentity): unknown {
    const obj: any = {};
    if (message.identity !== undefined) {
      obj.identity = IdentityExtractor.toJSON(message.identity);
    }
    if (message.validation !== undefined) {
      obj.validation = ValidationPolicy.toJSON(message.validation);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionIdentity>, I>>(base?: I): SessionIdentity {
    return SessionIdentity.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SessionIdentity>, I>>(object: I): SessionIdentity {
    const message = createBaseSessionIdentity();
    message.identity = (object.identity !== undefined && object.identity !== null)
      ? IdentityExtractor.fromPartial(object.identity)
      : undefined;
    message.validation = (object.validation !== undefined && object.validation !== null)
      ? ValidationPolicy.fromPartial(object.validation)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(SessionIdentity.$type, SessionIdentity);

function createBaseMcpRouter(): McpRouter {
  return { $type: "envoy.extensions.filters.http.mcp_router.v3.McpRouter" };
}

export const McpRouter: MessageFns<McpRouter, "envoy.extensions.filters.http.mcp_router.v3.McpRouter"> = {
  $type: "envoy.extensions.filters.http.mcp_router.v3.McpRouter" as const,

  encode(message: McpRouter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.servers !== undefined && message.servers.length !== 0) {
      for (const v of message.servers) {
        McpRouter_McpBackend.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    if (message.session_identity !== undefined) {
      SessionIdentity.encode(message.session_identity, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): McpRouter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMcpRouter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.servers === undefined) {
            message.servers = [];
          }
          const el = McpRouter_McpBackend.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.servers!.push(el);
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.session_identity = SessionIdentity.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): McpRouter {
    return {
      $type: McpRouter.$type,
      servers: globalThis.Array.isArray(object?.servers)
        ? object.servers.map((e: any) => McpRouter_McpBackend.fromJSON(e))
        : undefined,
      session_identity: isSet(object.session_identity) ? SessionIdentity.fromJSON(object.session_identity) : undefined,
    };
  },

  toJSON(message: McpRouter): unknown {
    const obj: any = {};
    if (message.servers?.length) {
      obj.servers = message.servers.map((e) => McpRouter_McpBackend.toJSON(e));
    }
    if (message.session_identity !== undefined) {
      obj.session_identity = SessionIdentity.toJSON(message.session_identity);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<McpRouter>, I>>(base?: I): McpRouter {
    return McpRouter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<McpRouter>, I>>(object: I): McpRouter {
    const message = createBaseMcpRouter();
    message.servers = object.servers?.map((e) => McpRouter_McpBackend.fromPartial(e)) || undefined;
    message.session_identity = (object.session_identity !== undefined && object.session_identity !== null)
      ? SessionIdentity.fromPartial(object.session_identity)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(McpRouter.$type, McpRouter);

function createBaseMcpRouter_McpBackend(): McpRouter_McpBackend {
  return { $type: "envoy.extensions.filters.http.mcp_router.v3.McpRouter.McpBackend" };
}

export const McpRouter_McpBackend: MessageFns<
  McpRouter_McpBackend,
  "envoy.extensions.filters.http.mcp_router.v3.McpRouter.McpBackend"
> = {
  $type: "envoy.extensions.filters.http.mcp_router.v3.McpRouter.McpBackend" as const,

  encode(message: McpRouter_McpBackend, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.mcp_cluster !== undefined) {
      McpRouter_McpCluster.encode(message.mcp_cluster, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): McpRouter_McpBackend {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMcpRouter_McpBackend();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mcp_cluster = McpRouter_McpCluster.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): McpRouter_McpBackend {
    return {
      $type: McpRouter_McpBackend.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      mcp_cluster: isSet(object.mcp_cluster) ? McpRouter_McpCluster.fromJSON(object.mcp_cluster) : undefined,
    };
  },

  toJSON(message: McpRouter_McpBackend): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.mcp_cluster !== undefined) {
      obj.mcp_cluster = McpRouter_McpCluster.toJSON(message.mcp_cluster);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<McpRouter_McpBackend>, I>>(base?: I): McpRouter_McpBackend {
    return McpRouter_McpBackend.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<McpRouter_McpBackend>, I>>(object: I): McpRouter_McpBackend {
    const message = createBaseMcpRouter_McpBackend();
    message.name = object.name ?? undefined;
    message.mcp_cluster = (object.mcp_cluster !== undefined && object.mcp_cluster !== null)
      ? McpRouter_McpCluster.fromPartial(object.mcp_cluster)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(McpRouter_McpBackend.$type, McpRouter_McpBackend);

function createBaseMcpRouter_McpCluster(): McpRouter_McpCluster {
  return { $type: "envoy.extensions.filters.http.mcp_router.v3.McpRouter.McpCluster" };
}

export const McpRouter_McpCluster: MessageFns<
  McpRouter_McpCluster,
  "envoy.extensions.filters.http.mcp_router.v3.McpRouter.McpCluster"
> = {
  $type: "envoy.extensions.filters.http.mcp_router.v3.McpRouter.McpCluster" as const,

  encode(message: McpRouter_McpCluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cluster !== undefined && message.cluster !== "") {
      writer.uint32(10).string(message.cluster);
    }
    if (message.path !== undefined && message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.timeout !== undefined) {
      Duration.encode(message.timeout, writer.uint32(26).fork()).join();
    }
    if (message.host_rewrite_literal !== undefined && message.host_rewrite_literal !== "") {
      writer.uint32(34).string(message.host_rewrite_literal);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): McpRouter_McpCluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMcpRouter_McpCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cluster = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.host_rewrite_literal = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): McpRouter_McpCluster {
    return {
      $type: McpRouter_McpCluster.$type,
      cluster: isSet(object.cluster) ? globalThis.String(object.cluster) : undefined,
      path: isSet(object.path) ? globalThis.String(object.path) : undefined,
      timeout: isSet(object.timeout) ? Duration.fromJSON(object.timeout) : undefined,
      host_rewrite_literal: isSet(object.host_rewrite_literal)
        ? globalThis.String(object.host_rewrite_literal)
        : undefined,
    };
  },

  toJSON(message: McpRouter_McpCluster): unknown {
    const obj: any = {};
    if (message.cluster !== undefined) {
      obj.cluster = message.cluster;
    }
    if (message.path !== undefined) {
      obj.path = message.path;
    }
    if (message.timeout !== undefined) {
      obj.timeout = Duration.toJSON(message.timeout);
    }
    if (message.host_rewrite_literal !== undefined) {
      obj.host_rewrite_literal = message.host_rewrite_literal;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<McpRouter_McpCluster>, I>>(base?: I): McpRouter_McpCluster {
    return McpRouter_McpCluster.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<McpRouter_McpCluster>, I>>(object: I): McpRouter_McpCluster {
    const message = createBaseMcpRouter_McpCluster();
    message.cluster = object.cluster ?? undefined;
    message.path = object.path ?? undefined;
    message.timeout = (object.timeout !== undefined && object.timeout !== null)
      ? Duration.fromPartial(object.timeout)
      : undefined;
    message.host_rewrite_literal = object.host_rewrite_literal ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(McpRouter_McpCluster.$type, McpRouter_McpCluster);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
