// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/filters/udp/dns_filter/v3/dns_filter.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../../../../google/protobuf/duration";
import { messageTypeRegistry } from "../../../../../../typeRegistry";
import { AccessLog } from "../../../../../config/accesslog/v3/accesslog";
import { Address } from "../../../../../config/core/v3/address";
import { DataSource } from "../../../../../config/core/v3/base";
import { TypedExtensionConfig } from "../../../../../config/core/v3/extension";
import { DnsResolutionConfig } from "../../../../../config/core/v3/resolver";
import { DnsTable } from "../../../../../data/dns/v3/dns_table";

export const protobufPackage = "envoy.extensions.filters.udp.dns_filter.v3";

/** Configuration for the DNS filter. */
export interface DnsFilterConfig {
  $type: "envoy.extensions.filters.udp.dns_filter.v3.DnsFilterConfig";
  /** The stat prefix used when emitting DNS filter statistics */
  stat_prefix?:
    | string
    | undefined;
  /**
   * Server context configuration contains the data that the filter uses to respond
   * to DNS requests.
   */
  server_config?:
    | DnsFilterConfig_ServerContextConfig
    | undefined;
  /**
   * Client context configuration controls Envoy's behavior when it must use external
   * resolvers to answer a query. This object is optional and if omitted instructs
   * the filter to resolve queries from the data in the server_config.
   * Also, if ``client_config`` is omitted, here is the Envoy's behavior to create DNS resolver:
   *
   * 1. If :ref:`typed_dns_resolver_config <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.typed_dns_resolver_config>`
   * is not empty, uses it.
   *
   * 2. Otherwise, uses the default c-ares DNS resolver.
   */
  client_config?:
    | DnsFilterConfig_ClientContextConfig
    | undefined;
  /**
   * Configuration for :ref:`access logs <arch_overview_access_logs>`
   * emitted by the DNS filter for each DNS query received.
   * Supports custom format commands for DNS-specific attributes:
   * - ``QUERY_NAME``: The DNS query name being resolved
   * - ``QUERY_TYPE``: The DNS query type (A, AAAA, SRV, etc.)
   * - ``QUERY_CLASS``: The DNS query class
   * - ``ANSWER_COUNT``: Number of answers in the response
   * - ``RESPONSE_CODE``: DNS response code
   * - ``PARSE_STATUS``: Whether the query was successfully parsed
   */
  access_log?: AccessLog[] | undefined;
}

/**
 * This message contains the configuration for the DNS Filter operating
 * in a server context. This message will contain the virtual hosts and
 * associated addresses with which Envoy will respond to queries
 */
export interface DnsFilterConfig_ServerContextConfig {
  $type: "envoy.extensions.filters.udp.dns_filter.v3.DnsFilterConfig.ServerContextConfig";
  config_source?:
    | //
    /** Load the configuration specified from the control plane */
    { $case: "inline_dns_table"; inline_dns_table: DnsTable }
    | //
    /**
     * Seed the filter configuration from an external path. This source
     * is a yaml formatted file that contains the DnsTable driving Envoy's
     * responses to DNS queries
     */
    { $case: "external_dns_table"; external_dns_table: DataSource }
    | undefined;
}

/**
 * This message contains the configuration for the DNS Filter operating
 * in a client context. This message will contain the timeouts, retry,
 * and forwarding configuration for Envoy to make DNS requests to other
 * resolvers
 *
 * [#next-free-field: 6]
 */
export interface DnsFilterConfig_ClientContextConfig {
  $type: "envoy.extensions.filters.udp.dns_filter.v3.DnsFilterConfig.ClientContextConfig";
  /**
   * Sets the maximum time we will wait for the upstream query to complete
   * We allow 5s for the upstream resolution to complete, so the minimum
   * value here is 1. Note that the total latency for a failed query is the
   * number of retries multiplied by the resolver_timeout.
   */
  resolver_timeout?:
    | Duration
    | undefined;
  /**
   * This field was used for `dns_resolution_config` in Envoy 1.19.0 and
   * 1.19.1.
   * Control planes that need to set this field for Envoy 1.19.0 and
   * 1.19.1 clients should fork the protobufs and change the field type
   * to `DnsResolutionConfig`.
   * Control planes that need to simultaneously support Envoy 1.18.x and
   * Envoy 1.19.x should avoid Envoy 1.19.0 and 1.19.1.
   *
   * [#not-implemented-hide:]
   *
   * @deprecated
   */
  upstream_resolvers?:
    | Address[]
    | undefined;
  /**
   * DNS resolution configuration which includes the underlying dns resolver addresses and options.
   * This field is deprecated in favor of
   * :ref:`typed_dns_resolver_config <envoy_v3_api_field_extensions.filters.udp.dns_filter.v3.DnsFilterConfig.ClientContextConfig.typed_dns_resolver_config>`.
   *
   * @deprecated
   */
  dns_resolution_config?:
    | DnsResolutionConfig
    | undefined;
  /**
   * DNS resolver type configuration extension. This extension can be used to configure c-ares, apple,
   * or any other DNS resolver types and the related parameters.
   * For example, an object of
   * :ref:`CaresDnsResolverConfig <envoy_v3_api_msg_extensions.network.dns_resolver.cares.v3.CaresDnsResolverConfig>`
   * can be packed into this ``typed_dns_resolver_config``. This configuration replaces the
   * :ref:`dns_resolution_config <envoy_v3_api_field_extensions.filters.udp.dns_filter.v3.DnsFilterConfig.ClientContextConfig.dns_resolution_config>`
   * configuration.
   * During the transition period when both ``dns_resolution_config`` and ``typed_dns_resolver_config`` exists,
   * when ``typed_dns_resolver_config`` is in place, Envoy will use it and ignore ``dns_resolution_config``.
   * When ``typed_dns_resolver_config`` is missing, the default behavior is in place.
   * [#extension-category: envoy.network.dns_resolver]
   */
  typed_dns_resolver_config?:
    | TypedExtensionConfig
    | undefined;
  /**
   * Controls how many outstanding external lookup contexts the filter tracks.
   * The context structure allows the filter to respond to every query even if the external
   * resolution times out or is otherwise unsuccessful
   */
  max_pending_lookups?: number | undefined;
}

function createBaseDnsFilterConfig(): DnsFilterConfig {
  return { $type: "envoy.extensions.filters.udp.dns_filter.v3.DnsFilterConfig" };
}

export const DnsFilterConfig: MessageFns<
  DnsFilterConfig,
  "envoy.extensions.filters.udp.dns_filter.v3.DnsFilterConfig"
> = {
  $type: "envoy.extensions.filters.udp.dns_filter.v3.DnsFilterConfig" as const,

  encode(message: DnsFilterConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stat_prefix !== undefined && message.stat_prefix !== "") {
      writer.uint32(10).string(message.stat_prefix);
    }
    if (message.server_config !== undefined) {
      DnsFilterConfig_ServerContextConfig.encode(message.server_config, writer.uint32(18).fork()).join();
    }
    if (message.client_config !== undefined) {
      DnsFilterConfig_ClientContextConfig.encode(message.client_config, writer.uint32(26).fork()).join();
    }
    if (message.access_log !== undefined && message.access_log.length !== 0) {
      for (const v of message.access_log) {
        AccessLog.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DnsFilterConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDnsFilterConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stat_prefix = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.server_config = DnsFilterConfig_ServerContextConfig.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.client_config = DnsFilterConfig_ClientContextConfig.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          if (message.access_log === undefined) {
            message.access_log = [];
          }
          const el = AccessLog.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.access_log!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DnsFilterConfig {
    return {
      $type: DnsFilterConfig.$type,
      stat_prefix: isSet(object.stat_prefix) ? globalThis.String(object.stat_prefix) : undefined,
      server_config: isSet(object.server_config)
        ? DnsFilterConfig_ServerContextConfig.fromJSON(object.server_config)
        : undefined,
      client_config: isSet(object.client_config)
        ? DnsFilterConfig_ClientContextConfig.fromJSON(object.client_config)
        : undefined,
      access_log: globalThis.Array.isArray(object?.access_log)
        ? object.access_log.map((e: any) => AccessLog.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: DnsFilterConfig): unknown {
    const obj: any = {};
    if (message.stat_prefix !== undefined) {
      obj.stat_prefix = message.stat_prefix;
    }
    if (message.server_config !== undefined) {
      obj.server_config = DnsFilterConfig_ServerContextConfig.toJSON(message.server_config);
    }
    if (message.client_config !== undefined) {
      obj.client_config = DnsFilterConfig_ClientContextConfig.toJSON(message.client_config);
    }
    if (message.access_log?.length) {
      obj.access_log = message.access_log.map((e) => AccessLog.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DnsFilterConfig>, I>>(base?: I): DnsFilterConfig {
    return DnsFilterConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DnsFilterConfig>, I>>(object: I): DnsFilterConfig {
    const message = createBaseDnsFilterConfig();
    message.stat_prefix = object.stat_prefix ?? undefined;
    message.server_config = (object.server_config !== undefined && object.server_config !== null)
      ? DnsFilterConfig_ServerContextConfig.fromPartial(object.server_config)
      : undefined;
    message.client_config = (object.client_config !== undefined && object.client_config !== null)
      ? DnsFilterConfig_ClientContextConfig.fromPartial(object.client_config)
      : undefined;
    message.access_log = object.access_log?.map((e) => AccessLog.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(DnsFilterConfig.$type, DnsFilterConfig);

function createBaseDnsFilterConfig_ServerContextConfig(): DnsFilterConfig_ServerContextConfig {
  return {
    $type: "envoy.extensions.filters.udp.dns_filter.v3.DnsFilterConfig.ServerContextConfig",
    config_source: undefined,
  };
}

export const DnsFilterConfig_ServerContextConfig: MessageFns<
  DnsFilterConfig_ServerContextConfig,
  "envoy.extensions.filters.udp.dns_filter.v3.DnsFilterConfig.ServerContextConfig"
> = {
  $type: "envoy.extensions.filters.udp.dns_filter.v3.DnsFilterConfig.ServerContextConfig" as const,

  encode(message: DnsFilterConfig_ServerContextConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.config_source?.$case) {
      case "inline_dns_table":
        DnsTable.encode(message.config_source.inline_dns_table, writer.uint32(10).fork()).join();
        break;
      case "external_dns_table":
        DataSource.encode(message.config_source.external_dns_table, writer.uint32(18).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DnsFilterConfig_ServerContextConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDnsFilterConfig_ServerContextConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.config_source = {
            $case: "inline_dns_table",
            inline_dns_table: DnsTable.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.config_source = {
            $case: "external_dns_table",
            external_dns_table: DataSource.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DnsFilterConfig_ServerContextConfig {
    return {
      $type: DnsFilterConfig_ServerContextConfig.$type,
      config_source: isSet(object.inline_dns_table)
        ? { $case: "inline_dns_table", inline_dns_table: DnsTable.fromJSON(object.inline_dns_table) }
        : isSet(object.external_dns_table)
        ? { $case: "external_dns_table", external_dns_table: DataSource.fromJSON(object.external_dns_table) }
        : undefined,
    };
  },

  toJSON(message: DnsFilterConfig_ServerContextConfig): unknown {
    const obj: any = {};
    if (message.config_source?.$case === "inline_dns_table") {
      obj.inline_dns_table = DnsTable.toJSON(message.config_source.inline_dns_table);
    }
    if (message.config_source?.$case === "external_dns_table") {
      obj.external_dns_table = DataSource.toJSON(message.config_source.external_dns_table);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DnsFilterConfig_ServerContextConfig>, I>>(
    base?: I,
  ): DnsFilterConfig_ServerContextConfig {
    return DnsFilterConfig_ServerContextConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DnsFilterConfig_ServerContextConfig>, I>>(
    object: I,
  ): DnsFilterConfig_ServerContextConfig {
    const message = createBaseDnsFilterConfig_ServerContextConfig();
    if (
      object.config_source?.$case === "inline_dns_table" &&
      object.config_source?.inline_dns_table !== undefined &&
      object.config_source?.inline_dns_table !== null
    ) {
      message.config_source = {
        $case: "inline_dns_table",
        inline_dns_table: DnsTable.fromPartial(object.config_source.inline_dns_table),
      };
    }
    if (
      object.config_source?.$case === "external_dns_table" &&
      object.config_source?.external_dns_table !== undefined &&
      object.config_source?.external_dns_table !== null
    ) {
      message.config_source = {
        $case: "external_dns_table",
        external_dns_table: DataSource.fromPartial(object.config_source.external_dns_table),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(DnsFilterConfig_ServerContextConfig.$type, DnsFilterConfig_ServerContextConfig);

function createBaseDnsFilterConfig_ClientContextConfig(): DnsFilterConfig_ClientContextConfig {
  return { $type: "envoy.extensions.filters.udp.dns_filter.v3.DnsFilterConfig.ClientContextConfig" };
}

export const DnsFilterConfig_ClientContextConfig: MessageFns<
  DnsFilterConfig_ClientContextConfig,
  "envoy.extensions.filters.udp.dns_filter.v3.DnsFilterConfig.ClientContextConfig"
> = {
  $type: "envoy.extensions.filters.udp.dns_filter.v3.DnsFilterConfig.ClientContextConfig" as const,

  encode(message: DnsFilterConfig_ClientContextConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resolver_timeout !== undefined) {
      Duration.encode(message.resolver_timeout, writer.uint32(10).fork()).join();
    }
    if (message.upstream_resolvers !== undefined && message.upstream_resolvers.length !== 0) {
      for (const v of message.upstream_resolvers) {
        Address.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.dns_resolution_config !== undefined) {
      DnsResolutionConfig.encode(message.dns_resolution_config, writer.uint32(42).fork()).join();
    }
    if (message.typed_dns_resolver_config !== undefined) {
      TypedExtensionConfig.encode(message.typed_dns_resolver_config, writer.uint32(34).fork()).join();
    }
    if (message.max_pending_lookups !== undefined && message.max_pending_lookups !== 0) {
      writer.uint32(24).uint64(message.max_pending_lookups);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DnsFilterConfig_ClientContextConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDnsFilterConfig_ClientContextConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.resolver_timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.upstream_resolvers === undefined) {
            message.upstream_resolvers = [];
          }
          const el = Address.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.upstream_resolvers!.push(el);
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.dns_resolution_config = DnsResolutionConfig.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.typed_dns_resolver_config = TypedExtensionConfig.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.max_pending_lookups = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DnsFilterConfig_ClientContextConfig {
    return {
      $type: DnsFilterConfig_ClientContextConfig.$type,
      resolver_timeout: isSet(object.resolver_timeout) ? Duration.fromJSON(object.resolver_timeout) : undefined,
      upstream_resolvers: globalThis.Array.isArray(object?.upstream_resolvers)
        ? object.upstream_resolvers.map((e: any) => Address.fromJSON(e))
        : undefined,
      dns_resolution_config: isSet(object.dns_resolution_config)
        ? DnsResolutionConfig.fromJSON(object.dns_resolution_config)
        : undefined,
      typed_dns_resolver_config: isSet(object.typed_dns_resolver_config)
        ? TypedExtensionConfig.fromJSON(object.typed_dns_resolver_config)
        : undefined,
      max_pending_lookups: isSet(object.max_pending_lookups)
        ? globalThis.Number(object.max_pending_lookups)
        : undefined,
    };
  },

  toJSON(message: DnsFilterConfig_ClientContextConfig): unknown {
    const obj: any = {};
    if (message.resolver_timeout !== undefined) {
      obj.resolver_timeout = Duration.toJSON(message.resolver_timeout);
    }
    if (message.upstream_resolvers?.length) {
      obj.upstream_resolvers = message.upstream_resolvers.map((e) => Address.toJSON(e));
    }
    if (message.dns_resolution_config !== undefined) {
      obj.dns_resolution_config = DnsResolutionConfig.toJSON(message.dns_resolution_config);
    }
    if (message.typed_dns_resolver_config !== undefined) {
      obj.typed_dns_resolver_config = TypedExtensionConfig.toJSON(message.typed_dns_resolver_config);
    }
    if (message.max_pending_lookups !== undefined) {
      obj.max_pending_lookups = Math.round(message.max_pending_lookups);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DnsFilterConfig_ClientContextConfig>, I>>(
    base?: I,
  ): DnsFilterConfig_ClientContextConfig {
    return DnsFilterConfig_ClientContextConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DnsFilterConfig_ClientContextConfig>, I>>(
    object: I,
  ): DnsFilterConfig_ClientContextConfig {
    const message = createBaseDnsFilterConfig_ClientContextConfig();
    message.resolver_timeout = (object.resolver_timeout !== undefined && object.resolver_timeout !== null)
      ? Duration.fromPartial(object.resolver_timeout)
      : undefined;
    message.upstream_resolvers = object.upstream_resolvers?.map((e) => Address.fromPartial(e)) || undefined;
    message.dns_resolution_config =
      (object.dns_resolution_config !== undefined && object.dns_resolution_config !== null)
        ? DnsResolutionConfig.fromPartial(object.dns_resolution_config)
        : undefined;
    message.typed_dns_resolver_config =
      (object.typed_dns_resolver_config !== undefined && object.typed_dns_resolver_config !== null)
        ? TypedExtensionConfig.fromPartial(object.typed_dns_resolver_config)
        : undefined;
    message.max_pending_lookups = object.max_pending_lookups ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(DnsFilterConfig_ClientContextConfig.$type, DnsFilterConfig_ClientContextConfig);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
