// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/extensions/access_loggers/stats/v3/stats.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { UInt64Value } from "../../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../../typeRegistry";

export const protobufPackage = "envoy.extensions.access_loggers.stats.v3";

export interface Config {
  $type: "envoy.extensions.access_loggers.stats.v3.Config";
  /** The stat prefix for the generated stats. */
  stat_prefix?:
    | string
    | undefined;
  /** The histograms this logger will emit. */
  histograms?:
    | Config_Histogram[]
    | undefined;
  /** The counters this logger will emit. */
  counters?: Config_Counter[] | undefined;
}

/** Defines a tag on a stat. */
export interface Config_Tag {
  $type: "envoy.extensions.access_loggers.stats.v3.Config.Tag";
  /** The name of the tag. */
  name?:
    | string
    | undefined;
  /** The value of the tag, using :ref:`command operators <config_access_log_command_operators>`. */
  value_format?: string | undefined;
}

/** Defines the name and tags of a stat. */
export interface Config_Stat {
  $type: "envoy.extensions.access_loggers.stats.v3.Config.Stat";
  /** The name of the stat. */
  name?:
    | string
    | undefined;
  /** The tags for the stat. */
  tags?: Config_Tag[] | undefined;
}

/** Configuration for a histogram stat. */
export interface Config_Histogram {
  $type: "envoy.extensions.access_loggers.stats.v3.Config.Histogram";
  /** The name and tags of this histogram. */
  stat?:
    | Config_Stat
    | undefined;
  /** The units for this histogram. */
  unit?:
    | Config_Histogram_Unit
    | undefined;
  /**
   * The format string for the value of this histogram, using :ref:`command operators <config_access_log_command_operators>`.
   * This must evaluate to a positive number.
   */
  value_format?: string | undefined;
}

/** The histogram units. The units are needed for some stat sinks. */
export enum Config_Histogram_Unit {
  Unspecified = "Unspecified",
  Bytes = "Bytes",
  Microseconds = "Microseconds",
  Milliseconds = "Milliseconds",
  /**
   * Percent - Values are scaled to range 0-1.0, indicating 0%-100%. Values can be outside this range,
   * but must be positive. Values extremely far out of this range may overflow.
   */
  Percent = "Percent",
}

export function config_Histogram_UnitFromJSON(object: any): Config_Histogram_Unit {
  switch (object) {
    case 0:
    case "Unspecified":
      return Config_Histogram_Unit.Unspecified;
    case 1:
    case "Bytes":
      return Config_Histogram_Unit.Bytes;
    case 2:
    case "Microseconds":
      return Config_Histogram_Unit.Microseconds;
    case 3:
    case "Milliseconds":
      return Config_Histogram_Unit.Milliseconds;
    case 4:
    case "Percent":
      return Config_Histogram_Unit.Percent;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Config_Histogram_Unit");
  }
}

export function config_Histogram_UnitToJSON(object: Config_Histogram_Unit): string {
  switch (object) {
    case Config_Histogram_Unit.Unspecified:
      return "Unspecified";
    case Config_Histogram_Unit.Bytes:
      return "Bytes";
    case Config_Histogram_Unit.Microseconds:
      return "Microseconds";
    case Config_Histogram_Unit.Milliseconds:
      return "Milliseconds";
    case Config_Histogram_Unit.Percent:
      return "Percent";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Config_Histogram_Unit");
  }
}

export function config_Histogram_UnitToNumber(object: Config_Histogram_Unit): number {
  switch (object) {
    case Config_Histogram_Unit.Unspecified:
      return 0;
    case Config_Histogram_Unit.Bytes:
      return 1;
    case Config_Histogram_Unit.Microseconds:
      return 2;
    case Config_Histogram_Unit.Milliseconds:
      return 3;
    case Config_Histogram_Unit.Percent:
      return 4;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Config_Histogram_Unit");
  }
}

/** Configuration for a counter stat. */
export interface Config_Counter {
  $type: "envoy.extensions.access_loggers.stats.v3.Config.Counter";
  /** The name and tags of this counter. */
  stat?:
    | Config_Stat
    | undefined;
  /**
   * The format string for the value to add to this counter, using :ref:`command operators <config_access_log_command_operators>`.
   * One of ``value_format`` or ``value_fixed`` must be configured.
   */
  value_format?:
    | string
    | undefined;
  /**
   * A fixed value to add to this counter.
   * One of ``value_format`` or ``value_fixed`` must be configured.
   */
  value_fixed?: number | undefined;
}

function createBaseConfig(): Config {
  return { $type: "envoy.extensions.access_loggers.stats.v3.Config" };
}

export const Config: MessageFns<Config, "envoy.extensions.access_loggers.stats.v3.Config"> = {
  $type: "envoy.extensions.access_loggers.stats.v3.Config" as const,

  encode(message: Config, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stat_prefix !== undefined && message.stat_prefix !== "") {
      writer.uint32(10).string(message.stat_prefix);
    }
    if (message.histograms !== undefined && message.histograms.length !== 0) {
      for (const v of message.histograms) {
        Config_Histogram.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    if (message.counters !== undefined && message.counters.length !== 0) {
      for (const v of message.counters) {
        Config_Counter.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Config {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stat_prefix = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.histograms === undefined) {
            message.histograms = [];
          }
          const el = Config_Histogram.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.histograms!.push(el);
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          if (message.counters === undefined) {
            message.counters = [];
          }
          const el = Config_Counter.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.counters!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Config {
    return {
      $type: Config.$type,
      stat_prefix: isSet(object.stat_prefix) ? globalThis.String(object.stat_prefix) : undefined,
      histograms: globalThis.Array.isArray(object?.histograms)
        ? object.histograms.map((e: any) => Config_Histogram.fromJSON(e))
        : undefined,
      counters: globalThis.Array.isArray(object?.counters)
        ? object.counters.map((e: any) => Config_Counter.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: Config): unknown {
    const obj: any = {};
    if (message.stat_prefix !== undefined) {
      obj.stat_prefix = message.stat_prefix;
    }
    if (message.histograms?.length) {
      obj.histograms = message.histograms.map((e) => Config_Histogram.toJSON(e));
    }
    if (message.counters?.length) {
      obj.counters = message.counters.map((e) => Config_Counter.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Config>, I>>(base?: I): Config {
    return Config.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Config>, I>>(object: I): Config {
    const message = createBaseConfig();
    message.stat_prefix = object.stat_prefix ?? undefined;
    message.histograms = object.histograms?.map((e) => Config_Histogram.fromPartial(e)) || undefined;
    message.counters = object.counters?.map((e) => Config_Counter.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(Config.$type, Config);

function createBaseConfig_Tag(): Config_Tag {
  return { $type: "envoy.extensions.access_loggers.stats.v3.Config.Tag" };
}

export const Config_Tag: MessageFns<Config_Tag, "envoy.extensions.access_loggers.stats.v3.Config.Tag"> = {
  $type: "envoy.extensions.access_loggers.stats.v3.Config.Tag" as const,

  encode(message: Config_Tag, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value_format !== undefined && message.value_format !== "") {
      writer.uint32(18).string(message.value_format);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Config_Tag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfig_Tag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value_format = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Config_Tag {
    return {
      $type: Config_Tag.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      value_format: isSet(object.value_format) ? globalThis.String(object.value_format) : undefined,
    };
  },

  toJSON(message: Config_Tag): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.value_format !== undefined) {
      obj.value_format = message.value_format;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Config_Tag>, I>>(base?: I): Config_Tag {
    return Config_Tag.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Config_Tag>, I>>(object: I): Config_Tag {
    const message = createBaseConfig_Tag();
    message.name = object.name ?? undefined;
    message.value_format = object.value_format ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Config_Tag.$type, Config_Tag);

function createBaseConfig_Stat(): Config_Stat {
  return { $type: "envoy.extensions.access_loggers.stats.v3.Config.Stat" };
}

export const Config_Stat: MessageFns<Config_Stat, "envoy.extensions.access_loggers.stats.v3.Config.Stat"> = {
  $type: "envoy.extensions.access_loggers.stats.v3.Config.Stat" as const,

  encode(message: Config_Stat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.tags !== undefined && message.tags.length !== 0) {
      for (const v of message.tags) {
        Config_Tag.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Config_Stat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfig_Stat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.tags === undefined) {
            message.tags = [];
          }
          const el = Config_Tag.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.tags!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Config_Stat {
    return {
      $type: Config_Stat.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => Config_Tag.fromJSON(e)) : undefined,
    };
  },

  toJSON(message: Config_Stat): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.tags?.length) {
      obj.tags = message.tags.map((e) => Config_Tag.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Config_Stat>, I>>(base?: I): Config_Stat {
    return Config_Stat.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Config_Stat>, I>>(object: I): Config_Stat {
    const message = createBaseConfig_Stat();
    message.name = object.name ?? undefined;
    message.tags = object.tags?.map((e) => Config_Tag.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(Config_Stat.$type, Config_Stat);

function createBaseConfig_Histogram(): Config_Histogram {
  return { $type: "envoy.extensions.access_loggers.stats.v3.Config.Histogram" };
}

export const Config_Histogram: MessageFns<
  Config_Histogram,
  "envoy.extensions.access_loggers.stats.v3.Config.Histogram"
> = {
  $type: "envoy.extensions.access_loggers.stats.v3.Config.Histogram" as const,

  encode(message: Config_Histogram, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stat !== undefined) {
      Config_Stat.encode(message.stat, writer.uint32(10).fork()).join();
    }
    if (message.unit !== undefined && message.unit !== Config_Histogram_Unit.Unspecified) {
      writer.uint32(16).int32(config_Histogram_UnitToNumber(message.unit));
    }
    if (message.value_format !== undefined && message.value_format !== "") {
      writer.uint32(26).string(message.value_format);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Config_Histogram {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfig_Histogram();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stat = Config_Stat.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.unit = config_Histogram_UnitFromJSON(reader.int32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.value_format = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Config_Histogram {
    return {
      $type: Config_Histogram.$type,
      stat: isSet(object.stat) ? Config_Stat.fromJSON(object.stat) : undefined,
      unit: isSet(object.unit) ? config_Histogram_UnitFromJSON(object.unit) : undefined,
      value_format: isSet(object.value_format) ? globalThis.String(object.value_format) : undefined,
    };
  },

  toJSON(message: Config_Histogram): unknown {
    const obj: any = {};
    if (message.stat !== undefined) {
      obj.stat = Config_Stat.toJSON(message.stat);
    }
    if (message.unit !== undefined) {
      obj.unit = config_Histogram_UnitToJSON(message.unit);
    }
    if (message.value_format !== undefined) {
      obj.value_format = message.value_format;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Config_Histogram>, I>>(base?: I): Config_Histogram {
    return Config_Histogram.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Config_Histogram>, I>>(object: I): Config_Histogram {
    const message = createBaseConfig_Histogram();
    message.stat = (object.stat !== undefined && object.stat !== null)
      ? Config_Stat.fromPartial(object.stat)
      : undefined;
    message.unit = object.unit ?? undefined;
    message.value_format = object.value_format ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Config_Histogram.$type, Config_Histogram);

function createBaseConfig_Counter(): Config_Counter {
  return { $type: "envoy.extensions.access_loggers.stats.v3.Config.Counter" };
}

export const Config_Counter: MessageFns<Config_Counter, "envoy.extensions.access_loggers.stats.v3.Config.Counter"> = {
  $type: "envoy.extensions.access_loggers.stats.v3.Config.Counter" as const,

  encode(message: Config_Counter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stat !== undefined) {
      Config_Stat.encode(message.stat, writer.uint32(10).fork()).join();
    }
    if (message.value_format !== undefined && message.value_format !== "") {
      writer.uint32(18).string(message.value_format);
    }
    if (message.value_fixed !== undefined) {
      UInt64Value.encode(
        { $type: "google.protobuf.UInt64Value", value: message.value_fixed! },
        writer.uint32(26).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Config_Counter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfig_Counter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stat = Config_Stat.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value_format = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.value_fixed = UInt64Value.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Config_Counter {
    return {
      $type: Config_Counter.$type,
      stat: isSet(object.stat) ? Config_Stat.fromJSON(object.stat) : undefined,
      value_format: isSet(object.value_format) ? globalThis.String(object.value_format) : undefined,
      value_fixed: isSet(object.value_fixed) ? Number(object.value_fixed) : undefined,
    };
  },

  toJSON(message: Config_Counter): unknown {
    const obj: any = {};
    if (message.stat !== undefined) {
      obj.stat = Config_Stat.toJSON(message.stat);
    }
    if (message.value_format !== undefined) {
      obj.value_format = message.value_format;
    }
    if (message.value_fixed !== undefined) {
      obj.value_fixed = message.value_fixed;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Config_Counter>, I>>(base?: I): Config_Counter {
    return Config_Counter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Config_Counter>, I>>(object: I): Config_Counter {
    const message = createBaseConfig_Counter();
    message.stat = (object.stat !== undefined && object.stat !== null)
      ? Config_Stat.fromPartial(object.stat)
      : undefined;
    message.value_format = object.value_format ?? undefined;
    message.value_fixed = object.value_fixed ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Config_Counter.$type, Config_Counter);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
