// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: envoy/config/accesslog/v3/accesslog.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Any } from "../../../../google/protobuf/any";
import { BoolValue } from "../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../typeRegistry";
import {
  AccessLogType,
  accessLogTypeFromJSON,
  accessLogTypeToJSON,
  accessLogTypeToNumber,
} from "../../../data/accesslog/v3/accesslog";
import { MetadataMatcher } from "../../../type/matcher/v3/metadata";
import { FractionalPercent } from "../../../type/v3/percent";
import { RuntimeUInt32 } from "../../core/v3/base";
import { HeaderMatcher } from "../../route/v3/route_components";

export const protobufPackage = "envoy.config.accesslog.v3";

export interface AccessLog {
  $type: "envoy.config.accesslog.v3.AccessLog";
  /** The name of the access log extension configuration. */
  name?:
    | string
    | undefined;
  /** Filter which is used to determine if the access log needs to be written. */
  filter?:
    | AccessLogFilter
    | undefined;
  /**
   * Custom configuration that must be set according to the access logger extension being instantiated.
   * [#extension-category: envoy.access_loggers]
   */
  config_type?:
    | //
    { $case: "typed_config"; typed_config: Any }
    | undefined;
}

/** [#next-free-field: 14] */
export interface AccessLogFilter {
  $type: "envoy.config.accesslog.v3.AccessLogFilter";
  filter_specifier?:
    | //
    /** Status code filter. */
    { $case: "status_code_filter"; status_code_filter: StatusCodeFilter }
    | //
    /** Duration filter. */
    { $case: "duration_filter"; duration_filter: DurationFilter }
    | //
    /** Not health check filter. */
    { $case: "not_health_check_filter"; not_health_check_filter: NotHealthCheckFilter }
    | //
    /** Traceable filter. */
    { $case: "traceable_filter"; traceable_filter: TraceableFilter }
    | //
    /** Runtime filter. */
    { $case: "runtime_filter"; runtime_filter: RuntimeFilter }
    | //
    /** And filter. */
    { $case: "and_filter"; and_filter: AndFilter }
    | //
    /** Or filter. */
    { $case: "or_filter"; or_filter: OrFilter }
    | //
    /** Header filter. */
    { $case: "header_filter"; header_filter: HeaderFilter }
    | //
    /** Response flag filter. */
    { $case: "response_flag_filter"; response_flag_filter: ResponseFlagFilter }
    | //
    /** gRPC status filter. */
    { $case: "grpc_status_filter"; grpc_status_filter: GrpcStatusFilter }
    | //
    /**
     * Extension filter.
     * [#extension-category: envoy.access_loggers.extension_filters]
     */
    { $case: "extension_filter"; extension_filter: ExtensionFilter }
    | //
    /** Metadata Filter */
    { $case: "metadata_filter"; metadata_filter: MetadataFilter }
    | //
    /** Log Type Filter */
    { $case: "log_type_filter"; log_type_filter: LogTypeFilter }
    | undefined;
}

/** Filter on an integer comparison. */
export interface ComparisonFilter {
  $type: "envoy.config.accesslog.v3.ComparisonFilter";
  /** Comparison operator. */
  op?:
    | ComparisonFilter_Op
    | undefined;
  /** Value to compare against. */
  value?: RuntimeUInt32 | undefined;
}

export enum ComparisonFilter_Op {
  /** EQ - = */
  EQ = "EQ",
  /** GE - >= */
  GE = "GE",
  /** LE - <= */
  LE = "LE",
  /** NE - != */
  NE = "NE",
}

export function comparisonFilter_OpFromJSON(object: any): ComparisonFilter_Op {
  switch (object) {
    case 0:
    case "EQ":
      return ComparisonFilter_Op.EQ;
    case 1:
    case "GE":
      return ComparisonFilter_Op.GE;
    case 2:
    case "LE":
      return ComparisonFilter_Op.LE;
    case 3:
    case "NE":
      return ComparisonFilter_Op.NE;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ComparisonFilter_Op");
  }
}

export function comparisonFilter_OpToJSON(object: ComparisonFilter_Op): string {
  switch (object) {
    case ComparisonFilter_Op.EQ:
      return "EQ";
    case ComparisonFilter_Op.GE:
      return "GE";
    case ComparisonFilter_Op.LE:
      return "LE";
    case ComparisonFilter_Op.NE:
      return "NE";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ComparisonFilter_Op");
  }
}

export function comparisonFilter_OpToNumber(object: ComparisonFilter_Op): number {
  switch (object) {
    case ComparisonFilter_Op.EQ:
      return 0;
    case ComparisonFilter_Op.GE:
      return 1;
    case ComparisonFilter_Op.LE:
      return 2;
    case ComparisonFilter_Op.NE:
      return 3;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ComparisonFilter_Op");
  }
}

/** Filters on HTTP response/status code. */
export interface StatusCodeFilter {
  $type: "envoy.config.accesslog.v3.StatusCodeFilter";
  /** Comparison. */
  comparison?: ComparisonFilter | undefined;
}

/**
 * Filters based on the duration of the request or stream, in milliseconds.
 * For end of stream access logs, the total duration of the stream will be used.
 * For :ref:`periodic access logs<arch_overview_access_log_periodic>`,
 * the duration of the stream at the time of log recording will be used.
 */
export interface DurationFilter {
  $type: "envoy.config.accesslog.v3.DurationFilter";
  /** Comparison. */
  comparison?: ComparisonFilter | undefined;
}

/**
 * Filters for requests that are not health check requests. A health check
 * request is marked by the health check filter.
 */
export interface NotHealthCheckFilter {
  $type: "envoy.config.accesslog.v3.NotHealthCheckFilter";
}

/**
 * Filters for requests that are traceable. See the tracing overview for more
 * information on how a request becomes traceable.
 */
export interface TraceableFilter {
  $type: "envoy.config.accesslog.v3.TraceableFilter";
}

/** Filters requests based on runtime-configurable sampling rates. */
export interface RuntimeFilter {
  $type: "envoy.config.accesslog.v3.RuntimeFilter";
  /**
   * Specifies a key used to look up a custom sampling rate from the runtime configuration. If a value is found for this
   * key, it will override the default sampling rate specified in ``percent_sampled``.
   */
  runtime_key?:
    | string
    | undefined;
  /**
   * Defines the default sampling percentage when no runtime override is present. If not specified, the default is
   * **0%** (with a denominator of 100).
   */
  percent_sampled?:
    | FractionalPercent
    | undefined;
  /**
   * Controls how sampling decisions are made.
   *
   * - Default behavior (``false``):
   *
   *   * Uses the :ref:`x-request-id<config_http_conn_man_headers_x-request-id>` as a consistent sampling pivot.
   *   * When :ref:`x-request-id<config_http_conn_man_headers_x-request-id>` is present, sampling will be consistent
   *     across multiple hosts based on both the ``runtime_key`` and
   *     :ref:`x-request-id<config_http_conn_man_headers_x-request-id>`.
   *   * Useful for tracking related requests across a distributed system.
   *
   * - When set to ``true`` or :ref:`x-request-id<config_http_conn_man_headers_x-request-id>` is missing:
   *
   *   * Sampling decisions are made randomly based only on the ``runtime_key``.
   *   * Useful in complex filter configurations (like nested
   *     :ref:`AndFilter<envoy_v3_api_msg_config.accesslog.v3.AndFilter>`/
   *     :ref:`OrFilter<envoy_v3_api_msg_config.accesslog.v3.OrFilter>` blocks) where independent probability
   *     calculations are desired.
   *   * Can be used to implement logging kill switches with predictable probability distributions.
   */
  use_independent_randomness?: boolean | undefined;
}

/**
 * Performs a logical “and” operation on the result of each filter in filters.
 * Filters are evaluated sequentially and if one of them returns false, the
 * filter returns false immediately.
 */
export interface AndFilter {
  $type: "envoy.config.accesslog.v3.AndFilter";
  filters?: AccessLogFilter[] | undefined;
}

/**
 * Performs a logical “or” operation on the result of each individual filter.
 * Filters are evaluated sequentially and if one of them returns true, the
 * filter returns true immediately.
 */
export interface OrFilter {
  $type: "envoy.config.accesslog.v3.OrFilter";
  filters?: AccessLogFilter[] | undefined;
}

/** Filters requests based on the presence or value of a request header. */
export interface HeaderFilter {
  $type: "envoy.config.accesslog.v3.HeaderFilter";
  /**
   * Only requests with a header which matches the specified HeaderMatcher will
   * pass the filter check.
   */
  header?: HeaderMatcher | undefined;
}

/**
 * Filters requests that received responses with an Envoy response flag set.
 * A list of the response flags can be found
 * in the access log formatter
 * :ref:`documentation<config_access_log_format_response_flags>`.
 */
export interface ResponseFlagFilter {
  $type: "envoy.config.accesslog.v3.ResponseFlagFilter";
  /**
   * Only responses with the any of the flags listed in this field will be
   * logged. This field is optional. If it is not specified, then any response
   * flag will pass the filter check.
   */
  flags?: string[] | undefined;
}

/**
 * Filters gRPC requests based on their response status. If a gRPC status is not
 * provided, the filter will infer the status from the HTTP status code.
 */
export interface GrpcStatusFilter {
  $type: "envoy.config.accesslog.v3.GrpcStatusFilter";
  /** Logs only responses that have any one of the gRPC statuses in this field. */
  statuses?:
    | GrpcStatusFilter_Status[]
    | undefined;
  /**
   * If included and set to true, the filter will instead block all responses
   * with a gRPC status or inferred gRPC status enumerated in statuses, and
   * allow all other responses.
   */
  exclude?: boolean | undefined;
}

export enum GrpcStatusFilter_Status {
  OK = "OK",
  CANCELED = "CANCELED",
  UNKNOWN = "UNKNOWN",
  INVALID_ARGUMENT = "INVALID_ARGUMENT",
  DEADLINE_EXCEEDED = "DEADLINE_EXCEEDED",
  NOT_FOUND = "NOT_FOUND",
  ALREADY_EXISTS = "ALREADY_EXISTS",
  PERMISSION_DENIED = "PERMISSION_DENIED",
  RESOURCE_EXHAUSTED = "RESOURCE_EXHAUSTED",
  FAILED_PRECONDITION = "FAILED_PRECONDITION",
  ABORTED = "ABORTED",
  OUT_OF_RANGE = "OUT_OF_RANGE",
  UNIMPLEMENTED = "UNIMPLEMENTED",
  INTERNAL = "INTERNAL",
  UNAVAILABLE = "UNAVAILABLE",
  DATA_LOSS = "DATA_LOSS",
  UNAUTHENTICATED = "UNAUTHENTICATED",
}

export function grpcStatusFilter_StatusFromJSON(object: any): GrpcStatusFilter_Status {
  switch (object) {
    case 0:
    case "OK":
      return GrpcStatusFilter_Status.OK;
    case 1:
    case "CANCELED":
      return GrpcStatusFilter_Status.CANCELED;
    case 2:
    case "UNKNOWN":
      return GrpcStatusFilter_Status.UNKNOWN;
    case 3:
    case "INVALID_ARGUMENT":
      return GrpcStatusFilter_Status.INVALID_ARGUMENT;
    case 4:
    case "DEADLINE_EXCEEDED":
      return GrpcStatusFilter_Status.DEADLINE_EXCEEDED;
    case 5:
    case "NOT_FOUND":
      return GrpcStatusFilter_Status.NOT_FOUND;
    case 6:
    case "ALREADY_EXISTS":
      return GrpcStatusFilter_Status.ALREADY_EXISTS;
    case 7:
    case "PERMISSION_DENIED":
      return GrpcStatusFilter_Status.PERMISSION_DENIED;
    case 8:
    case "RESOURCE_EXHAUSTED":
      return GrpcStatusFilter_Status.RESOURCE_EXHAUSTED;
    case 9:
    case "FAILED_PRECONDITION":
      return GrpcStatusFilter_Status.FAILED_PRECONDITION;
    case 10:
    case "ABORTED":
      return GrpcStatusFilter_Status.ABORTED;
    case 11:
    case "OUT_OF_RANGE":
      return GrpcStatusFilter_Status.OUT_OF_RANGE;
    case 12:
    case "UNIMPLEMENTED":
      return GrpcStatusFilter_Status.UNIMPLEMENTED;
    case 13:
    case "INTERNAL":
      return GrpcStatusFilter_Status.INTERNAL;
    case 14:
    case "UNAVAILABLE":
      return GrpcStatusFilter_Status.UNAVAILABLE;
    case 15:
    case "DATA_LOSS":
      return GrpcStatusFilter_Status.DATA_LOSS;
    case 16:
    case "UNAUTHENTICATED":
      return GrpcStatusFilter_Status.UNAUTHENTICATED;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum GrpcStatusFilter_Status");
  }
}

export function grpcStatusFilter_StatusToJSON(object: GrpcStatusFilter_Status): string {
  switch (object) {
    case GrpcStatusFilter_Status.OK:
      return "OK";
    case GrpcStatusFilter_Status.CANCELED:
      return "CANCELED";
    case GrpcStatusFilter_Status.UNKNOWN:
      return "UNKNOWN";
    case GrpcStatusFilter_Status.INVALID_ARGUMENT:
      return "INVALID_ARGUMENT";
    case GrpcStatusFilter_Status.DEADLINE_EXCEEDED:
      return "DEADLINE_EXCEEDED";
    case GrpcStatusFilter_Status.NOT_FOUND:
      return "NOT_FOUND";
    case GrpcStatusFilter_Status.ALREADY_EXISTS:
      return "ALREADY_EXISTS";
    case GrpcStatusFilter_Status.PERMISSION_DENIED:
      return "PERMISSION_DENIED";
    case GrpcStatusFilter_Status.RESOURCE_EXHAUSTED:
      return "RESOURCE_EXHAUSTED";
    case GrpcStatusFilter_Status.FAILED_PRECONDITION:
      return "FAILED_PRECONDITION";
    case GrpcStatusFilter_Status.ABORTED:
      return "ABORTED";
    case GrpcStatusFilter_Status.OUT_OF_RANGE:
      return "OUT_OF_RANGE";
    case GrpcStatusFilter_Status.UNIMPLEMENTED:
      return "UNIMPLEMENTED";
    case GrpcStatusFilter_Status.INTERNAL:
      return "INTERNAL";
    case GrpcStatusFilter_Status.UNAVAILABLE:
      return "UNAVAILABLE";
    case GrpcStatusFilter_Status.DATA_LOSS:
      return "DATA_LOSS";
    case GrpcStatusFilter_Status.UNAUTHENTICATED:
      return "UNAUTHENTICATED";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum GrpcStatusFilter_Status");
  }
}

export function grpcStatusFilter_StatusToNumber(object: GrpcStatusFilter_Status): number {
  switch (object) {
    case GrpcStatusFilter_Status.OK:
      return 0;
    case GrpcStatusFilter_Status.CANCELED:
      return 1;
    case GrpcStatusFilter_Status.UNKNOWN:
      return 2;
    case GrpcStatusFilter_Status.INVALID_ARGUMENT:
      return 3;
    case GrpcStatusFilter_Status.DEADLINE_EXCEEDED:
      return 4;
    case GrpcStatusFilter_Status.NOT_FOUND:
      return 5;
    case GrpcStatusFilter_Status.ALREADY_EXISTS:
      return 6;
    case GrpcStatusFilter_Status.PERMISSION_DENIED:
      return 7;
    case GrpcStatusFilter_Status.RESOURCE_EXHAUSTED:
      return 8;
    case GrpcStatusFilter_Status.FAILED_PRECONDITION:
      return 9;
    case GrpcStatusFilter_Status.ABORTED:
      return 10;
    case GrpcStatusFilter_Status.OUT_OF_RANGE:
      return 11;
    case GrpcStatusFilter_Status.UNIMPLEMENTED:
      return 12;
    case GrpcStatusFilter_Status.INTERNAL:
      return 13;
    case GrpcStatusFilter_Status.UNAVAILABLE:
      return 14;
    case GrpcStatusFilter_Status.DATA_LOSS:
      return 15;
    case GrpcStatusFilter_Status.UNAUTHENTICATED:
      return 16;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum GrpcStatusFilter_Status");
  }
}

/**
 * Filters based on matching dynamic metadata.
 * If the matcher path and key correspond to an existing key in dynamic
 * metadata, the request is logged only if the matcher value is equal to the
 * metadata value. If the matcher path and key *do not* correspond to an
 * existing key in dynamic metadata, the request is logged only if
 * match_if_key_not_found is "true" or unset.
 */
export interface MetadataFilter {
  $type: "envoy.config.accesslog.v3.MetadataFilter";
  /**
   * Matcher to check metadata for specified value. For example, to match on the
   * access_log_hint metadata, set the filter to "envoy.common" and the path to
   * "access_log_hint", and the value to "true".
   */
  matcher?:
    | MetadataMatcher
    | undefined;
  /**
   * Default result if the key does not exist in dynamic metadata: if unset or
   * true, then log; if false, then don't log.
   */
  match_if_key_not_found?: boolean | undefined;
}

/** Filters based on access log type. */
export interface LogTypeFilter {
  $type: "envoy.config.accesslog.v3.LogTypeFilter";
  /** Logs only records which their type is one of the types defined in this field. */
  types?:
    | AccessLogType[]
    | undefined;
  /**
   * If this field is set to true, the filter will instead block all records
   * with a access log type in types field, and allow all other records.
   */
  exclude?: boolean | undefined;
}

/** Extension filter is statically registered at runtime. */
export interface ExtensionFilter {
  $type: "envoy.config.accesslog.v3.ExtensionFilter";
  /**
   * The name of the filter implementation to instantiate. The name must
   * match a statically registered filter.
   */
  name?:
    | string
    | undefined;
  /** Custom configuration that depends on the filter being instantiated. */
  config_type?:
    | //
    { $case: "typed_config"; typed_config: Any }
    | undefined;
}

function createBaseAccessLog(): AccessLog {
  return { $type: "envoy.config.accesslog.v3.AccessLog", config_type: undefined };
}

export const AccessLog: MessageFns<AccessLog, "envoy.config.accesslog.v3.AccessLog"> = {
  $type: "envoy.config.accesslog.v3.AccessLog" as const,

  encode(message: AccessLog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.filter !== undefined) {
      AccessLogFilter.encode(message.filter, writer.uint32(18).fork()).join();
    }
    switch (message.config_type?.$case) {
      case "typed_config":
        Any.encode(message.config_type.typed_config, writer.uint32(34).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessLog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.filter = AccessLogFilter.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.config_type = { $case: "typed_config", typed_config: Any.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessLog {
    return {
      $type: AccessLog.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      filter: isSet(object.filter) ? AccessLogFilter.fromJSON(object.filter) : undefined,
      config_type: isSet(object.typed_config)
        ? { $case: "typed_config", typed_config: Any.fromJSON(object.typed_config) }
        : undefined,
    };
  },

  toJSON(message: AccessLog): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.filter !== undefined) {
      obj.filter = AccessLogFilter.toJSON(message.filter);
    }
    if (message.config_type?.$case === "typed_config") {
      obj.typed_config = Any.toJSON(message.config_type.typed_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccessLog>, I>>(base?: I): AccessLog {
    return AccessLog.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccessLog>, I>>(object: I): AccessLog {
    const message = createBaseAccessLog();
    message.name = object.name ?? undefined;
    message.filter = (object.filter !== undefined && object.filter !== null)
      ? AccessLogFilter.fromPartial(object.filter)
      : undefined;
    if (
      object.config_type?.$case === "typed_config" &&
      object.config_type?.typed_config !== undefined &&
      object.config_type?.typed_config !== null
    ) {
      message.config_type = { $case: "typed_config", typed_config: Any.fromPartial(object.config_type.typed_config) };
    }
    return message;
  },
};

messageTypeRegistry.set(AccessLog.$type, AccessLog);

function createBaseAccessLogFilter(): AccessLogFilter {
  return { $type: "envoy.config.accesslog.v3.AccessLogFilter", filter_specifier: undefined };
}

export const AccessLogFilter: MessageFns<AccessLogFilter, "envoy.config.accesslog.v3.AccessLogFilter"> = {
  $type: "envoy.config.accesslog.v3.AccessLogFilter" as const,

  encode(message: AccessLogFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.filter_specifier?.$case) {
      case "status_code_filter":
        StatusCodeFilter.encode(message.filter_specifier.status_code_filter, writer.uint32(10).fork()).join();
        break;
      case "duration_filter":
        DurationFilter.encode(message.filter_specifier.duration_filter, writer.uint32(18).fork()).join();
        break;
      case "not_health_check_filter":
        NotHealthCheckFilter.encode(message.filter_specifier.not_health_check_filter, writer.uint32(26).fork()).join();
        break;
      case "traceable_filter":
        TraceableFilter.encode(message.filter_specifier.traceable_filter, writer.uint32(34).fork()).join();
        break;
      case "runtime_filter":
        RuntimeFilter.encode(message.filter_specifier.runtime_filter, writer.uint32(42).fork()).join();
        break;
      case "and_filter":
        AndFilter.encode(message.filter_specifier.and_filter, writer.uint32(50).fork()).join();
        break;
      case "or_filter":
        OrFilter.encode(message.filter_specifier.or_filter, writer.uint32(58).fork()).join();
        break;
      case "header_filter":
        HeaderFilter.encode(message.filter_specifier.header_filter, writer.uint32(66).fork()).join();
        break;
      case "response_flag_filter":
        ResponseFlagFilter.encode(message.filter_specifier.response_flag_filter, writer.uint32(74).fork()).join();
        break;
      case "grpc_status_filter":
        GrpcStatusFilter.encode(message.filter_specifier.grpc_status_filter, writer.uint32(82).fork()).join();
        break;
      case "extension_filter":
        ExtensionFilter.encode(message.filter_specifier.extension_filter, writer.uint32(90).fork()).join();
        break;
      case "metadata_filter":
        MetadataFilter.encode(message.filter_specifier.metadata_filter, writer.uint32(98).fork()).join();
        break;
      case "log_type_filter":
        LogTypeFilter.encode(message.filter_specifier.log_type_filter, writer.uint32(106).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessLogFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessLogFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filter_specifier = {
            $case: "status_code_filter",
            status_code_filter: StatusCodeFilter.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.filter_specifier = {
            $case: "duration_filter",
            duration_filter: DurationFilter.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.filter_specifier = {
            $case: "not_health_check_filter",
            not_health_check_filter: NotHealthCheckFilter.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.filter_specifier = {
            $case: "traceable_filter",
            traceable_filter: TraceableFilter.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.filter_specifier = {
            $case: "runtime_filter",
            runtime_filter: RuntimeFilter.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.filter_specifier = { $case: "and_filter", and_filter: AndFilter.decode(reader, reader.uint32()) };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.filter_specifier = { $case: "or_filter", or_filter: OrFilter.decode(reader, reader.uint32()) };
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.filter_specifier = {
            $case: "header_filter",
            header_filter: HeaderFilter.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.filter_specifier = {
            $case: "response_flag_filter",
            response_flag_filter: ResponseFlagFilter.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.filter_specifier = {
            $case: "grpc_status_filter",
            grpc_status_filter: GrpcStatusFilter.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.filter_specifier = {
            $case: "extension_filter",
            extension_filter: ExtensionFilter.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.filter_specifier = {
            $case: "metadata_filter",
            metadata_filter: MetadataFilter.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.filter_specifier = {
            $case: "log_type_filter",
            log_type_filter: LogTypeFilter.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessLogFilter {
    return {
      $type: AccessLogFilter.$type,
      filter_specifier: isSet(object.status_code_filter)
        ? { $case: "status_code_filter", status_code_filter: StatusCodeFilter.fromJSON(object.status_code_filter) }
        : isSet(object.duration_filter)
        ? { $case: "duration_filter", duration_filter: DurationFilter.fromJSON(object.duration_filter) }
        : isSet(object.not_health_check_filter)
        ? {
          $case: "not_health_check_filter",
          not_health_check_filter: NotHealthCheckFilter.fromJSON(object.not_health_check_filter),
        }
        : isSet(object.traceable_filter)
        ? { $case: "traceable_filter", traceable_filter: TraceableFilter.fromJSON(object.traceable_filter) }
        : isSet(object.runtime_filter)
        ? { $case: "runtime_filter", runtime_filter: RuntimeFilter.fromJSON(object.runtime_filter) }
        : isSet(object.and_filter)
        ? { $case: "and_filter", and_filter: AndFilter.fromJSON(object.and_filter) }
        : isSet(object.or_filter)
        ? { $case: "or_filter", or_filter: OrFilter.fromJSON(object.or_filter) }
        : isSet(object.header_filter)
        ? { $case: "header_filter", header_filter: HeaderFilter.fromJSON(object.header_filter) }
        : isSet(object.response_flag_filter)
        ? {
          $case: "response_flag_filter",
          response_flag_filter: ResponseFlagFilter.fromJSON(object.response_flag_filter),
        }
        : isSet(object.grpc_status_filter)
        ? { $case: "grpc_status_filter", grpc_status_filter: GrpcStatusFilter.fromJSON(object.grpc_status_filter) }
        : isSet(object.extension_filter)
        ? { $case: "extension_filter", extension_filter: ExtensionFilter.fromJSON(object.extension_filter) }
        : isSet(object.metadata_filter)
        ? { $case: "metadata_filter", metadata_filter: MetadataFilter.fromJSON(object.metadata_filter) }
        : isSet(object.log_type_filter)
        ? { $case: "log_type_filter", log_type_filter: LogTypeFilter.fromJSON(object.log_type_filter) }
        : undefined,
    };
  },

  toJSON(message: AccessLogFilter): unknown {
    const obj: any = {};
    if (message.filter_specifier?.$case === "status_code_filter") {
      obj.status_code_filter = StatusCodeFilter.toJSON(message.filter_specifier.status_code_filter);
    }
    if (message.filter_specifier?.$case === "duration_filter") {
      obj.duration_filter = DurationFilter.toJSON(message.filter_specifier.duration_filter);
    }
    if (message.filter_specifier?.$case === "not_health_check_filter") {
      obj.not_health_check_filter = NotHealthCheckFilter.toJSON(message.filter_specifier.not_health_check_filter);
    }
    if (message.filter_specifier?.$case === "traceable_filter") {
      obj.traceable_filter = TraceableFilter.toJSON(message.filter_specifier.traceable_filter);
    }
    if (message.filter_specifier?.$case === "runtime_filter") {
      obj.runtime_filter = RuntimeFilter.toJSON(message.filter_specifier.runtime_filter);
    }
    if (message.filter_specifier?.$case === "and_filter") {
      obj.and_filter = AndFilter.toJSON(message.filter_specifier.and_filter);
    }
    if (message.filter_specifier?.$case === "or_filter") {
      obj.or_filter = OrFilter.toJSON(message.filter_specifier.or_filter);
    }
    if (message.filter_specifier?.$case === "header_filter") {
      obj.header_filter = HeaderFilter.toJSON(message.filter_specifier.header_filter);
    }
    if (message.filter_specifier?.$case === "response_flag_filter") {
      obj.response_flag_filter = ResponseFlagFilter.toJSON(message.filter_specifier.response_flag_filter);
    }
    if (message.filter_specifier?.$case === "grpc_status_filter") {
      obj.grpc_status_filter = GrpcStatusFilter.toJSON(message.filter_specifier.grpc_status_filter);
    }
    if (message.filter_specifier?.$case === "extension_filter") {
      obj.extension_filter = ExtensionFilter.toJSON(message.filter_specifier.extension_filter);
    }
    if (message.filter_specifier?.$case === "metadata_filter") {
      obj.metadata_filter = MetadataFilter.toJSON(message.filter_specifier.metadata_filter);
    }
    if (message.filter_specifier?.$case === "log_type_filter") {
      obj.log_type_filter = LogTypeFilter.toJSON(message.filter_specifier.log_type_filter);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccessLogFilter>, I>>(base?: I): AccessLogFilter {
    return AccessLogFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccessLogFilter>, I>>(object: I): AccessLogFilter {
    const message = createBaseAccessLogFilter();
    if (
      object.filter_specifier?.$case === "status_code_filter" &&
      object.filter_specifier?.status_code_filter !== undefined &&
      object.filter_specifier?.status_code_filter !== null
    ) {
      message.filter_specifier = {
        $case: "status_code_filter",
        status_code_filter: StatusCodeFilter.fromPartial(object.filter_specifier.status_code_filter),
      };
    }
    if (
      object.filter_specifier?.$case === "duration_filter" &&
      object.filter_specifier?.duration_filter !== undefined &&
      object.filter_specifier?.duration_filter !== null
    ) {
      message.filter_specifier = {
        $case: "duration_filter",
        duration_filter: DurationFilter.fromPartial(object.filter_specifier.duration_filter),
      };
    }
    if (
      object.filter_specifier?.$case === "not_health_check_filter" &&
      object.filter_specifier?.not_health_check_filter !== undefined &&
      object.filter_specifier?.not_health_check_filter !== null
    ) {
      message.filter_specifier = {
        $case: "not_health_check_filter",
        not_health_check_filter: NotHealthCheckFilter.fromPartial(object.filter_specifier.not_health_check_filter),
      };
    }
    if (
      object.filter_specifier?.$case === "traceable_filter" &&
      object.filter_specifier?.traceable_filter !== undefined &&
      object.filter_specifier?.traceable_filter !== null
    ) {
      message.filter_specifier = {
        $case: "traceable_filter",
        traceable_filter: TraceableFilter.fromPartial(object.filter_specifier.traceable_filter),
      };
    }
    if (
      object.filter_specifier?.$case === "runtime_filter" &&
      object.filter_specifier?.runtime_filter !== undefined &&
      object.filter_specifier?.runtime_filter !== null
    ) {
      message.filter_specifier = {
        $case: "runtime_filter",
        runtime_filter: RuntimeFilter.fromPartial(object.filter_specifier.runtime_filter),
      };
    }
    if (
      object.filter_specifier?.$case === "and_filter" &&
      object.filter_specifier?.and_filter !== undefined &&
      object.filter_specifier?.and_filter !== null
    ) {
      message.filter_specifier = {
        $case: "and_filter",
        and_filter: AndFilter.fromPartial(object.filter_specifier.and_filter),
      };
    }
    if (
      object.filter_specifier?.$case === "or_filter" &&
      object.filter_specifier?.or_filter !== undefined &&
      object.filter_specifier?.or_filter !== null
    ) {
      message.filter_specifier = {
        $case: "or_filter",
        or_filter: OrFilter.fromPartial(object.filter_specifier.or_filter),
      };
    }
    if (
      object.filter_specifier?.$case === "header_filter" &&
      object.filter_specifier?.header_filter !== undefined &&
      object.filter_specifier?.header_filter !== null
    ) {
      message.filter_specifier = {
        $case: "header_filter",
        header_filter: HeaderFilter.fromPartial(object.filter_specifier.header_filter),
      };
    }
    if (
      object.filter_specifier?.$case === "response_flag_filter" &&
      object.filter_specifier?.response_flag_filter !== undefined &&
      object.filter_specifier?.response_flag_filter !== null
    ) {
      message.filter_specifier = {
        $case: "response_flag_filter",
        response_flag_filter: ResponseFlagFilter.fromPartial(object.filter_specifier.response_flag_filter),
      };
    }
    if (
      object.filter_specifier?.$case === "grpc_status_filter" &&
      object.filter_specifier?.grpc_status_filter !== undefined &&
      object.filter_specifier?.grpc_status_filter !== null
    ) {
      message.filter_specifier = {
        $case: "grpc_status_filter",
        grpc_status_filter: GrpcStatusFilter.fromPartial(object.filter_specifier.grpc_status_filter),
      };
    }
    if (
      object.filter_specifier?.$case === "extension_filter" &&
      object.filter_specifier?.extension_filter !== undefined &&
      object.filter_specifier?.extension_filter !== null
    ) {
      message.filter_specifier = {
        $case: "extension_filter",
        extension_filter: ExtensionFilter.fromPartial(object.filter_specifier.extension_filter),
      };
    }
    if (
      object.filter_specifier?.$case === "metadata_filter" &&
      object.filter_specifier?.metadata_filter !== undefined &&
      object.filter_specifier?.metadata_filter !== null
    ) {
      message.filter_specifier = {
        $case: "metadata_filter",
        metadata_filter: MetadataFilter.fromPartial(object.filter_specifier.metadata_filter),
      };
    }
    if (
      object.filter_specifier?.$case === "log_type_filter" &&
      object.filter_specifier?.log_type_filter !== undefined &&
      object.filter_specifier?.log_type_filter !== null
    ) {
      message.filter_specifier = {
        $case: "log_type_filter",
        log_type_filter: LogTypeFilter.fromPartial(object.filter_specifier.log_type_filter),
      };
    }
    return message;
  },
};

messageTypeRegistry.set(AccessLogFilter.$type, AccessLogFilter);

function createBaseComparisonFilter(): ComparisonFilter {
  return { $type: "envoy.config.accesslog.v3.ComparisonFilter" };
}

export const ComparisonFilter: MessageFns<ComparisonFilter, "envoy.config.accesslog.v3.ComparisonFilter"> = {
  $type: "envoy.config.accesslog.v3.ComparisonFilter" as const,

  encode(message: ComparisonFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.op !== undefined && message.op !== ComparisonFilter_Op.EQ) {
      writer.uint32(8).int32(comparisonFilter_OpToNumber(message.op));
    }
    if (message.value !== undefined) {
      RuntimeUInt32.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComparisonFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComparisonFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.op = comparisonFilter_OpFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = RuntimeUInt32.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComparisonFilter {
    return {
      $type: ComparisonFilter.$type,
      op: isSet(object.op) ? comparisonFilter_OpFromJSON(object.op) : undefined,
      value: isSet(object.value) ? RuntimeUInt32.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ComparisonFilter): unknown {
    const obj: any = {};
    if (message.op !== undefined) {
      obj.op = comparisonFilter_OpToJSON(message.op);
    }
    if (message.value !== undefined) {
      obj.value = RuntimeUInt32.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ComparisonFilter>, I>>(base?: I): ComparisonFilter {
    return ComparisonFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ComparisonFilter>, I>>(object: I): ComparisonFilter {
    const message = createBaseComparisonFilter();
    message.op = object.op ?? undefined;
    message.value = (object.value !== undefined && object.value !== null)
      ? RuntimeUInt32.fromPartial(object.value)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(ComparisonFilter.$type, ComparisonFilter);

function createBaseStatusCodeFilter(): StatusCodeFilter {
  return { $type: "envoy.config.accesslog.v3.StatusCodeFilter" };
}

export const StatusCodeFilter: MessageFns<StatusCodeFilter, "envoy.config.accesslog.v3.StatusCodeFilter"> = {
  $type: "envoy.config.accesslog.v3.StatusCodeFilter" as const,

  encode(message: StatusCodeFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.comparison !== undefined) {
      ComparisonFilter.encode(message.comparison, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StatusCodeFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatusCodeFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.comparison = ComparisonFilter.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatusCodeFilter {
    return {
      $type: StatusCodeFilter.$type,
      comparison: isSet(object.comparison) ? ComparisonFilter.fromJSON(object.comparison) : undefined,
    };
  },

  toJSON(message: StatusCodeFilter): unknown {
    const obj: any = {};
    if (message.comparison !== undefined) {
      obj.comparison = ComparisonFilter.toJSON(message.comparison);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StatusCodeFilter>, I>>(base?: I): StatusCodeFilter {
    return StatusCodeFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StatusCodeFilter>, I>>(object: I): StatusCodeFilter {
    const message = createBaseStatusCodeFilter();
    message.comparison = (object.comparison !== undefined && object.comparison !== null)
      ? ComparisonFilter.fromPartial(object.comparison)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(StatusCodeFilter.$type, StatusCodeFilter);

function createBaseDurationFilter(): DurationFilter {
  return { $type: "envoy.config.accesslog.v3.DurationFilter" };
}

export const DurationFilter: MessageFns<DurationFilter, "envoy.config.accesslog.v3.DurationFilter"> = {
  $type: "envoy.config.accesslog.v3.DurationFilter" as const,

  encode(message: DurationFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.comparison !== undefined) {
      ComparisonFilter.encode(message.comparison, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DurationFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDurationFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.comparison = ComparisonFilter.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DurationFilter {
    return {
      $type: DurationFilter.$type,
      comparison: isSet(object.comparison) ? ComparisonFilter.fromJSON(object.comparison) : undefined,
    };
  },

  toJSON(message: DurationFilter): unknown {
    const obj: any = {};
    if (message.comparison !== undefined) {
      obj.comparison = ComparisonFilter.toJSON(message.comparison);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DurationFilter>, I>>(base?: I): DurationFilter {
    return DurationFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DurationFilter>, I>>(object: I): DurationFilter {
    const message = createBaseDurationFilter();
    message.comparison = (object.comparison !== undefined && object.comparison !== null)
      ? ComparisonFilter.fromPartial(object.comparison)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(DurationFilter.$type, DurationFilter);

function createBaseNotHealthCheckFilter(): NotHealthCheckFilter {
  return { $type: "envoy.config.accesslog.v3.NotHealthCheckFilter" };
}

export const NotHealthCheckFilter: MessageFns<NotHealthCheckFilter, "envoy.config.accesslog.v3.NotHealthCheckFilter"> =
  {
    $type: "envoy.config.accesslog.v3.NotHealthCheckFilter" as const,

    encode(_: NotHealthCheckFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): NotHealthCheckFilter {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseNotHealthCheckFilter();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(_: any): NotHealthCheckFilter {
      return { $type: NotHealthCheckFilter.$type };
    },

    toJSON(_: NotHealthCheckFilter): unknown {
      const obj: any = {};
      return obj;
    },

    create<I extends Exact<DeepPartial<NotHealthCheckFilter>, I>>(base?: I): NotHealthCheckFilter {
      return NotHealthCheckFilter.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<NotHealthCheckFilter>, I>>(_: I): NotHealthCheckFilter {
      const message = createBaseNotHealthCheckFilter();
      return message;
    },
  };

messageTypeRegistry.set(NotHealthCheckFilter.$type, NotHealthCheckFilter);

function createBaseTraceableFilter(): TraceableFilter {
  return { $type: "envoy.config.accesslog.v3.TraceableFilter" };
}

export const TraceableFilter: MessageFns<TraceableFilter, "envoy.config.accesslog.v3.TraceableFilter"> = {
  $type: "envoy.config.accesslog.v3.TraceableFilter" as const,

  encode(_: TraceableFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TraceableFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTraceableFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): TraceableFilter {
    return { $type: TraceableFilter.$type };
  },

  toJSON(_: TraceableFilter): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<TraceableFilter>, I>>(base?: I): TraceableFilter {
    return TraceableFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TraceableFilter>, I>>(_: I): TraceableFilter {
    const message = createBaseTraceableFilter();
    return message;
  },
};

messageTypeRegistry.set(TraceableFilter.$type, TraceableFilter);

function createBaseRuntimeFilter(): RuntimeFilter {
  return { $type: "envoy.config.accesslog.v3.RuntimeFilter" };
}

export const RuntimeFilter: MessageFns<RuntimeFilter, "envoy.config.accesslog.v3.RuntimeFilter"> = {
  $type: "envoy.config.accesslog.v3.RuntimeFilter" as const,

  encode(message: RuntimeFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.runtime_key !== undefined && message.runtime_key !== "") {
      writer.uint32(10).string(message.runtime_key);
    }
    if (message.percent_sampled !== undefined) {
      FractionalPercent.encode(message.percent_sampled, writer.uint32(18).fork()).join();
    }
    if (message.use_independent_randomness !== undefined && message.use_independent_randomness !== false) {
      writer.uint32(24).bool(message.use_independent_randomness);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuntimeFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuntimeFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.runtime_key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.percent_sampled = FractionalPercent.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.use_independent_randomness = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuntimeFilter {
    return {
      $type: RuntimeFilter.$type,
      runtime_key: isSet(object.runtime_key) ? globalThis.String(object.runtime_key) : undefined,
      percent_sampled: isSet(object.percent_sampled) ? FractionalPercent.fromJSON(object.percent_sampled) : undefined,
      use_independent_randomness: isSet(object.use_independent_randomness)
        ? globalThis.Boolean(object.use_independent_randomness)
        : undefined,
    };
  },

  toJSON(message: RuntimeFilter): unknown {
    const obj: any = {};
    if (message.runtime_key !== undefined) {
      obj.runtime_key = message.runtime_key;
    }
    if (message.percent_sampled !== undefined) {
      obj.percent_sampled = FractionalPercent.toJSON(message.percent_sampled);
    }
    if (message.use_independent_randomness !== undefined) {
      obj.use_independent_randomness = message.use_independent_randomness;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RuntimeFilter>, I>>(base?: I): RuntimeFilter {
    return RuntimeFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RuntimeFilter>, I>>(object: I): RuntimeFilter {
    const message = createBaseRuntimeFilter();
    message.runtime_key = object.runtime_key ?? undefined;
    message.percent_sampled = (object.percent_sampled !== undefined && object.percent_sampled !== null)
      ? FractionalPercent.fromPartial(object.percent_sampled)
      : undefined;
    message.use_independent_randomness = object.use_independent_randomness ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(RuntimeFilter.$type, RuntimeFilter);

function createBaseAndFilter(): AndFilter {
  return { $type: "envoy.config.accesslog.v3.AndFilter" };
}

export const AndFilter: MessageFns<AndFilter, "envoy.config.accesslog.v3.AndFilter"> = {
  $type: "envoy.config.accesslog.v3.AndFilter" as const,

  encode(message: AndFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filters !== undefined && message.filters.length !== 0) {
      for (const v of message.filters) {
        AccessLogFilter.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AndFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAndFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.filters === undefined) {
            message.filters = [];
          }
          const el = AccessLogFilter.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.filters!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AndFilter {
    return {
      $type: AndFilter.$type,
      filters: globalThis.Array.isArray(object?.filters)
        ? object.filters.map((e: any) => AccessLogFilter.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: AndFilter): unknown {
    const obj: any = {};
    if (message.filters?.length) {
      obj.filters = message.filters.map((e) => AccessLogFilter.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AndFilter>, I>>(base?: I): AndFilter {
    return AndFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AndFilter>, I>>(object: I): AndFilter {
    const message = createBaseAndFilter();
    message.filters = object.filters?.map((e) => AccessLogFilter.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(AndFilter.$type, AndFilter);

function createBaseOrFilter(): OrFilter {
  return { $type: "envoy.config.accesslog.v3.OrFilter" };
}

export const OrFilter: MessageFns<OrFilter, "envoy.config.accesslog.v3.OrFilter"> = {
  $type: "envoy.config.accesslog.v3.OrFilter" as const,

  encode(message: OrFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filters !== undefined && message.filters.length !== 0) {
      for (const v of message.filters) {
        AccessLogFilter.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          if (message.filters === undefined) {
            message.filters = [];
          }
          const el = AccessLogFilter.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.filters!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrFilter {
    return {
      $type: OrFilter.$type,
      filters: globalThis.Array.isArray(object?.filters)
        ? object.filters.map((e: any) => AccessLogFilter.fromJSON(e))
        : undefined,
    };
  },

  toJSON(message: OrFilter): unknown {
    const obj: any = {};
    if (message.filters?.length) {
      obj.filters = message.filters.map((e) => AccessLogFilter.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrFilter>, I>>(base?: I): OrFilter {
    return OrFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrFilter>, I>>(object: I): OrFilter {
    const message = createBaseOrFilter();
    message.filters = object.filters?.map((e) => AccessLogFilter.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(OrFilter.$type, OrFilter);

function createBaseHeaderFilter(): HeaderFilter {
  return { $type: "envoy.config.accesslog.v3.HeaderFilter" };
}

export const HeaderFilter: MessageFns<HeaderFilter, "envoy.config.accesslog.v3.HeaderFilter"> = {
  $type: "envoy.config.accesslog.v3.HeaderFilter" as const,

  encode(message: HeaderFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      HeaderMatcher.encode(message.header, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeaderFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeaderFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header = HeaderMatcher.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeaderFilter {
    return {
      $type: HeaderFilter.$type,
      header: isSet(object.header) ? HeaderMatcher.fromJSON(object.header) : undefined,
    };
  },

  toJSON(message: HeaderFilter): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = HeaderMatcher.toJSON(message.header);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HeaderFilter>, I>>(base?: I): HeaderFilter {
    return HeaderFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HeaderFilter>, I>>(object: I): HeaderFilter {
    const message = createBaseHeaderFilter();
    message.header = (object.header !== undefined && object.header !== null)
      ? HeaderMatcher.fromPartial(object.header)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(HeaderFilter.$type, HeaderFilter);

function createBaseResponseFlagFilter(): ResponseFlagFilter {
  return { $type: "envoy.config.accesslog.v3.ResponseFlagFilter" };
}

export const ResponseFlagFilter: MessageFns<ResponseFlagFilter, "envoy.config.accesslog.v3.ResponseFlagFilter"> = {
  $type: "envoy.config.accesslog.v3.ResponseFlagFilter" as const,

  encode(message: ResponseFlagFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.flags !== undefined && message.flags.length !== 0) {
      for (const v of message.flags) {
        writer.uint32(10).string(v!);
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResponseFlagFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseFlagFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.flags === undefined) {
            message.flags = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.flags!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResponseFlagFilter {
    return {
      $type: ResponseFlagFilter.$type,
      flags: globalThis.Array.isArray(object?.flags) ? object.flags.map((e: any) => globalThis.String(e)) : undefined,
    };
  },

  toJSON(message: ResponseFlagFilter): unknown {
    const obj: any = {};
    if (message.flags?.length) {
      obj.flags = message.flags;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResponseFlagFilter>, I>>(base?: I): ResponseFlagFilter {
    return ResponseFlagFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResponseFlagFilter>, I>>(object: I): ResponseFlagFilter {
    const message = createBaseResponseFlagFilter();
    message.flags = object.flags?.map((e) => e) || undefined;
    return message;
  },
};

messageTypeRegistry.set(ResponseFlagFilter.$type, ResponseFlagFilter);

function createBaseGrpcStatusFilter(): GrpcStatusFilter {
  return { $type: "envoy.config.accesslog.v3.GrpcStatusFilter" };
}

export const GrpcStatusFilter: MessageFns<GrpcStatusFilter, "envoy.config.accesslog.v3.GrpcStatusFilter"> = {
  $type: "envoy.config.accesslog.v3.GrpcStatusFilter" as const,

  encode(message: GrpcStatusFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.statuses !== undefined && message.statuses.length !== 0) {
      writer.uint32(10).fork();
      for (const v of message.statuses) {
        writer.int32(grpcStatusFilter_StatusToNumber(v));
      }
      writer.join();
    }
    if (message.exclude !== undefined && message.exclude !== false) {
      writer.uint32(16).bool(message.exclude);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrpcStatusFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrpcStatusFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            if (message.statuses === undefined) {
              message.statuses = [];
            }
            message.statuses!.push(grpcStatusFilter_StatusFromJSON(reader.int32()));

            continue;
          }

          if (tag === 10) {
            if (message.statuses === undefined) {
              message.statuses = [];
            }
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.statuses!.push(grpcStatusFilter_StatusFromJSON(reader.int32()));
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.exclude = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrpcStatusFilter {
    return {
      $type: GrpcStatusFilter.$type,
      statuses: globalThis.Array.isArray(object?.statuses)
        ? object.statuses.map((e: any) => grpcStatusFilter_StatusFromJSON(e))
        : undefined,
      exclude: isSet(object.exclude) ? globalThis.Boolean(object.exclude) : undefined,
    };
  },

  toJSON(message: GrpcStatusFilter): unknown {
    const obj: any = {};
    if (message.statuses?.length) {
      obj.statuses = message.statuses.map((e) => grpcStatusFilter_StatusToJSON(e));
    }
    if (message.exclude !== undefined) {
      obj.exclude = message.exclude;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GrpcStatusFilter>, I>>(base?: I): GrpcStatusFilter {
    return GrpcStatusFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GrpcStatusFilter>, I>>(object: I): GrpcStatusFilter {
    const message = createBaseGrpcStatusFilter();
    message.statuses = object.statuses?.map((e) => e) || undefined;
    message.exclude = object.exclude ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(GrpcStatusFilter.$type, GrpcStatusFilter);

function createBaseMetadataFilter(): MetadataFilter {
  return { $type: "envoy.config.accesslog.v3.MetadataFilter" };
}

export const MetadataFilter: MessageFns<MetadataFilter, "envoy.config.accesslog.v3.MetadataFilter"> = {
  $type: "envoy.config.accesslog.v3.MetadataFilter" as const,

  encode(message: MetadataFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.matcher !== undefined) {
      MetadataMatcher.encode(message.matcher, writer.uint32(10).fork()).join();
    }
    if (message.match_if_key_not_found !== undefined) {
      BoolValue.encode(
        { $type: "google.protobuf.BoolValue", value: message.match_if_key_not_found! },
        writer.uint32(18).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MetadataFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetadataFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.matcher = MetadataMatcher.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.match_if_key_not_found = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetadataFilter {
    return {
      $type: MetadataFilter.$type,
      matcher: isSet(object.matcher) ? MetadataMatcher.fromJSON(object.matcher) : undefined,
      match_if_key_not_found: isSet(object.match_if_key_not_found) ? Boolean(object.match_if_key_not_found) : undefined,
    };
  },

  toJSON(message: MetadataFilter): unknown {
    const obj: any = {};
    if (message.matcher !== undefined) {
      obj.matcher = MetadataMatcher.toJSON(message.matcher);
    }
    if (message.match_if_key_not_found !== undefined) {
      obj.match_if_key_not_found = message.match_if_key_not_found;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetadataFilter>, I>>(base?: I): MetadataFilter {
    return MetadataFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetadataFilter>, I>>(object: I): MetadataFilter {
    const message = createBaseMetadataFilter();
    message.matcher = (object.matcher !== undefined && object.matcher !== null)
      ? MetadataMatcher.fromPartial(object.matcher)
      : undefined;
    message.match_if_key_not_found = object.match_if_key_not_found ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(MetadataFilter.$type, MetadataFilter);

function createBaseLogTypeFilter(): LogTypeFilter {
  return { $type: "envoy.config.accesslog.v3.LogTypeFilter" };
}

export const LogTypeFilter: MessageFns<LogTypeFilter, "envoy.config.accesslog.v3.LogTypeFilter"> = {
  $type: "envoy.config.accesslog.v3.LogTypeFilter" as const,

  encode(message: LogTypeFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.types !== undefined && message.types.length !== 0) {
      writer.uint32(10).fork();
      for (const v of message.types) {
        writer.int32(accessLogTypeToNumber(v));
      }
      writer.join();
    }
    if (message.exclude !== undefined && message.exclude !== false) {
      writer.uint32(16).bool(message.exclude);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogTypeFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogTypeFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            if (message.types === undefined) {
              message.types = [];
            }
            message.types!.push(accessLogTypeFromJSON(reader.int32()));

            continue;
          }

          if (tag === 10) {
            if (message.types === undefined) {
              message.types = [];
            }
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.types!.push(accessLogTypeFromJSON(reader.int32()));
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.exclude = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogTypeFilter {
    return {
      $type: LogTypeFilter.$type,
      types: globalThis.Array.isArray(object?.types)
        ? object.types.map((e: any) => accessLogTypeFromJSON(e))
        : undefined,
      exclude: isSet(object.exclude) ? globalThis.Boolean(object.exclude) : undefined,
    };
  },

  toJSON(message: LogTypeFilter): unknown {
    const obj: any = {};
    if (message.types?.length) {
      obj.types = message.types.map((e) => accessLogTypeToJSON(e));
    }
    if (message.exclude !== undefined) {
      obj.exclude = message.exclude;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LogTypeFilter>, I>>(base?: I): LogTypeFilter {
    return LogTypeFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogTypeFilter>, I>>(object: I): LogTypeFilter {
    const message = createBaseLogTypeFilter();
    message.types = object.types?.map((e) => e) || undefined;
    message.exclude = object.exclude ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(LogTypeFilter.$type, LogTypeFilter);

function createBaseExtensionFilter(): ExtensionFilter {
  return { $type: "envoy.config.accesslog.v3.ExtensionFilter", config_type: undefined };
}

export const ExtensionFilter: MessageFns<ExtensionFilter, "envoy.config.accesslog.v3.ExtensionFilter"> = {
  $type: "envoy.config.accesslog.v3.ExtensionFilter" as const,

  encode(message: ExtensionFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    switch (message.config_type?.$case) {
      case "typed_config":
        Any.encode(message.config_type.typed_config, writer.uint32(26).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExtensionFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExtensionFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.config_type = { $case: "typed_config", typed_config: Any.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExtensionFilter {
    return {
      $type: ExtensionFilter.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      config_type: isSet(object.typed_config)
        ? { $case: "typed_config", typed_config: Any.fromJSON(object.typed_config) }
        : undefined,
    };
  },

  toJSON(message: ExtensionFilter): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.config_type?.$case === "typed_config") {
      obj.typed_config = Any.toJSON(message.config_type.typed_config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExtensionFilter>, I>>(base?: I): ExtensionFilter {
    return ExtensionFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExtensionFilter>, I>>(object: I): ExtensionFilter {
    const message = createBaseExtensionFilter();
    message.name = object.name ?? undefined;
    if (
      object.config_type?.$case === "typed_config" &&
      object.config_type?.typed_config !== undefined &&
      object.config_type?.typed_config !== null
    ) {
      message.config_type = { $case: "typed_config", typed_config: Any.fromPartial(object.config_type.typed_config) };
    }
    return message;
  },
};

messageTypeRegistry.set(ExtensionFilter.$type, ExtensionFilter);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
