// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: contrib/envoy/extensions/filters/http/istio_stats/v3/istio_stats.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../../../../../google/protobuf/duration";
import { messageTypeRegistry } from "../../../../../../../typeRegistry";

export const protobufPackage = "stats";

export enum MetricType {
  COUNTER = "COUNTER",
  GAUGE = "GAUGE",
  HISTOGRAM = "HISTOGRAM",
}

export function metricTypeFromJSON(object: any): MetricType {
  switch (object) {
    case 0:
    case "COUNTER":
      return MetricType.COUNTER;
    case 1:
    case "GAUGE":
      return MetricType.GAUGE;
    case 2:
    case "HISTOGRAM":
      return MetricType.HISTOGRAM;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum MetricType");
  }
}

export function metricTypeToJSON(object: MetricType): string {
  switch (object) {
    case MetricType.COUNTER:
      return "COUNTER";
    case MetricType.GAUGE:
      return "GAUGE";
    case MetricType.HISTOGRAM:
      return "HISTOGRAM";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum MetricType");
  }
}

export function metricTypeToNumber(object: MetricType): number {
  switch (object) {
    case MetricType.COUNTER:
      return 0;
    case MetricType.GAUGE:
      return 1;
    case MetricType.HISTOGRAM:
      return 2;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum MetricType");
  }
}

/** Specifies the proxy deployment type. */
export enum Reporter {
  /**
   * UNSPECIFIED - Default value is inferred from the listener direction, as either client or
   * server sidecar.
   */
  UNSPECIFIED = "UNSPECIFIED",
  /** SERVER_GATEWAY - Shared server gateway, e.g. "waypoint". */
  SERVER_GATEWAY = "SERVER_GATEWAY",
}

export function reporterFromJSON(object: any): Reporter {
  switch (object) {
    case 0:
    case "UNSPECIFIED":
      return Reporter.UNSPECIFIED;
    case 1:
    case "SERVER_GATEWAY":
      return Reporter.SERVER_GATEWAY;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Reporter");
  }
}

export function reporterToJSON(object: Reporter): string {
  switch (object) {
    case Reporter.UNSPECIFIED:
      return "UNSPECIFIED";
    case Reporter.SERVER_GATEWAY:
      return "SERVER_GATEWAY";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Reporter");
  }
}

export function reporterToNumber(object: Reporter): number {
  switch (object) {
    case Reporter.UNSPECIFIED:
      return 0;
    case Reporter.SERVER_GATEWAY:
      return 1;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Reporter");
  }
}

/**
 * Metric instance configuration overrides.
 * The metric value and the metric type are optional and permit changing the
 * reported value for an existing metric.
 * The standard metrics are optimized and reported through a "fast-path".
 * The customizations allow full configurability, at the cost of a "slower"
 * path.
 * [#next-free-field: 6]
 */
export interface MetricConfig {
  $type: "stats.MetricConfig";
  /**
   * (Optional) Collection of tag names and tag expressions to include in the
   * metric. Conflicts are resolved by the tag name by overriding previously
   * supplied values.
   */
  dimensions?:
    | Map<string, string>
    | undefined;
  /**
   * (Optional) Metric name to restrict the override to a metric. If not
   * specified, applies to all.
   */
  name?:
    | string
    | undefined;
  /** (Optional) A list of tags to remove. */
  tags_to_remove?:
    | string[]
    | undefined;
  /** NOT IMPLEMENTED. (Optional) Conditional enabling the override. */
  match?:
    | string
    | undefined;
  /**
   * (Optional) If this is set to true, the metric(s) selected by this
   * configuration will not be generated or reported.
   */
  drop?: boolean | undefined;
}

export interface MetricConfig_DimensionsEntry {
  $type: "stats.MetricConfig.DimensionsEntry";
  key: string;
  value: string;
}

export interface MetricDefinition {
  $type: "stats.MetricDefinition";
  /** Metric name. */
  name?:
    | string
    | undefined;
  /** Metric value expression. */
  value?:
    | string
    | undefined;
  /** Metric type. */
  type?: MetricType | undefined;
}

/** [#next-free-field: 13] */
export interface PluginConfig {
  $type: "stats.PluginConfig";
  /**
   * Optional: Disable using host header as a fallback if destination service is
   * not available from the control plane. Disable the fallback if the host
   * header originates outsides the mesh, like at ingress.
   */
  disable_host_header_fallback?:
    | boolean
    | undefined;
  /**
   * Optional. Allows configuration of the time between calls out to for TCP
   * metrics reporting. The default duration is ``5s``.
   */
  tcp_reporting_duration?:
    | Duration
    | undefined;
  /** Metric overrides. */
  metrics?:
    | MetricConfig[]
    | undefined;
  /** Metric definitions. */
  definitions?:
    | MetricDefinition[]
    | undefined;
  /** Proxy deployment type. */
  reporter?:
    | Reporter
    | undefined;
  /**
   * Metric scope rotation interval. Set to 0 to disable the metric scope rotation.
   * Defaults to 0.
   * DEPRECATED.
   */
  rotation_interval?:
    | Duration
    | undefined;
  /**
   * Metric expiry graceful deletion interval. No-op if the metric rotation is disabled.
   * Defaults to 5m. Must be >=1s.
   * DEPRECATED.
   */
  graceful_deletion_interval?: Duration | undefined;
}

function createBaseMetricConfig(): MetricConfig {
  return { $type: "stats.MetricConfig" };
}

export const MetricConfig: MessageFns<MetricConfig, "stats.MetricConfig"> = {
  $type: "stats.MetricConfig" as const,

  encode(message: MetricConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    (message.dimensions || new Map()).forEach((value, key) => {
      MetricConfig_DimensionsEntry.encode(
        { $type: "stats.MetricConfig.DimensionsEntry", key: key as any, value },
        writer.uint32(10).fork(),
      ).join();
    });
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.tags_to_remove !== undefined && message.tags_to_remove.length !== 0) {
      for (const v of message.tags_to_remove) {
        writer.uint32(26).string(v!);
      }
    }
    if (message.match !== undefined && message.match !== "") {
      writer.uint32(34).string(message.match);
    }
    if (message.drop !== undefined && message.drop !== false) {
      writer.uint32(40).bool(message.drop);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MetricConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = MetricConfig_DimensionsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            if (message.dimensions === undefined) {
              message.dimensions = new Map();
            }
            message.dimensions!.set(entry1.key, entry1.value);
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.tags_to_remove === undefined) {
            message.tags_to_remove = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.tags_to_remove!.push(el);
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.match = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.drop = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricConfig {
    return {
      $type: MetricConfig.$type,
      dimensions: isObject(object.dimensions)
        ? Object.entries(object.dimensions).reduce<Map<string, string>>((acc, [key, value]) => {
          acc.set(key, String(value));
          return acc;
        }, new Map())
        : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      tags_to_remove: globalThis.Array.isArray(object?.tags_to_remove)
        ? object.tags_to_remove.map((e: any) => globalThis.String(e))
        : undefined,
      match: isSet(object.match) ? globalThis.String(object.match) : undefined,
      drop: isSet(object.drop) ? globalThis.Boolean(object.drop) : undefined,
    };
  },

  toJSON(message: MetricConfig): unknown {
    const obj: any = {};
    if (message.dimensions?.size) {
      obj.dimensions = {};
      message.dimensions.forEach((v, k) => {
        obj.dimensions[k] = v;
      });
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.tags_to_remove?.length) {
      obj.tags_to_remove = message.tags_to_remove;
    }
    if (message.match !== undefined) {
      obj.match = message.match;
    }
    if (message.drop !== undefined) {
      obj.drop = message.drop;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetricConfig>, I>>(base?: I): MetricConfig {
    return MetricConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetricConfig>, I>>(object: I): MetricConfig {
    const message = createBaseMetricConfig();
    message.dimensions = (object.dimensions === undefined || object.dimensions === null) ? undefined : (() => {
      const m = new Map();
      (object.dimensions as Map<string, string> ?? new Map()).forEach((value, key) => {
        if (value !== undefined) {
          m.set(key, globalThis.String(value));
        }
      });
      return m;
    })();
    message.name = object.name ?? undefined;
    message.tags_to_remove = object.tags_to_remove?.map((e) => e) || undefined;
    message.match = object.match ?? undefined;
    message.drop = object.drop ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(MetricConfig.$type, MetricConfig);

function createBaseMetricConfig_DimensionsEntry(): MetricConfig_DimensionsEntry {
  return { $type: "stats.MetricConfig.DimensionsEntry", key: "", value: "" };
}

export const MetricConfig_DimensionsEntry: MessageFns<
  MetricConfig_DimensionsEntry,
  "stats.MetricConfig.DimensionsEntry"
> = {
  $type: "stats.MetricConfig.DimensionsEntry" as const,

  encode(message: MetricConfig_DimensionsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MetricConfig_DimensionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricConfig_DimensionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricConfig_DimensionsEntry {
    return {
      $type: MetricConfig_DimensionsEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: MetricConfig_DimensionsEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetricConfig_DimensionsEntry>, I>>(base?: I): MetricConfig_DimensionsEntry {
    return MetricConfig_DimensionsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetricConfig_DimensionsEntry>, I>>(object: I): MetricConfig_DimensionsEntry {
    const message = createBaseMetricConfig_DimensionsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

messageTypeRegistry.set(MetricConfig_DimensionsEntry.$type, MetricConfig_DimensionsEntry);

function createBaseMetricDefinition(): MetricDefinition {
  return { $type: "stats.MetricDefinition" };
}

export const MetricDefinition: MessageFns<MetricDefinition, "stats.MetricDefinition"> = {
  $type: "stats.MetricDefinition" as const,

  encode(message: MetricDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== undefined && message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    if (message.type !== undefined && message.type !== MetricType.COUNTER) {
      writer.uint32(24).int32(metricTypeToNumber(message.type));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MetricDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = metricTypeFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricDefinition {
    return {
      $type: MetricDefinition.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      value: isSet(object.value) ? globalThis.String(object.value) : undefined,
      type: isSet(object.type) ? metricTypeFromJSON(object.type) : undefined,
    };
  },

  toJSON(message: MetricDefinition): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    if (message.type !== undefined) {
      obj.type = metricTypeToJSON(message.type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetricDefinition>, I>>(base?: I): MetricDefinition {
    return MetricDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetricDefinition>, I>>(object: I): MetricDefinition {
    const message = createBaseMetricDefinition();
    message.name = object.name ?? undefined;
    message.value = object.value ?? undefined;
    message.type = object.type ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(MetricDefinition.$type, MetricDefinition);

function createBasePluginConfig(): PluginConfig {
  return { $type: "stats.PluginConfig" };
}

export const PluginConfig: MessageFns<PluginConfig, "stats.PluginConfig"> = {
  $type: "stats.PluginConfig" as const,

  encode(message: PluginConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.disable_host_header_fallback !== undefined && message.disable_host_header_fallback !== false) {
      writer.uint32(48).bool(message.disable_host_header_fallback);
    }
    if (message.tcp_reporting_duration !== undefined) {
      Duration.encode(message.tcp_reporting_duration, writer.uint32(58).fork()).join();
    }
    if (message.metrics !== undefined && message.metrics.length !== 0) {
      for (const v of message.metrics) {
        MetricConfig.encode(v!, writer.uint32(66).fork()).join();
      }
    }
    if (message.definitions !== undefined && message.definitions.length !== 0) {
      for (const v of message.definitions) {
        MetricDefinition.encode(v!, writer.uint32(74).fork()).join();
      }
    }
    if (message.reporter !== undefined && message.reporter !== Reporter.UNSPECIFIED) {
      writer.uint32(80).int32(reporterToNumber(message.reporter));
    }
    if (message.rotation_interval !== undefined) {
      Duration.encode(message.rotation_interval, writer.uint32(90).fork()).join();
    }
    if (message.graceful_deletion_interval !== undefined) {
      Duration.encode(message.graceful_deletion_interval, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PluginConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePluginConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.disable_host_header_fallback = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.tcp_reporting_duration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          if (message.metrics === undefined) {
            message.metrics = [];
          }
          const el = MetricConfig.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.metrics!.push(el);
          }
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          if (message.definitions === undefined) {
            message.definitions = [];
          }
          const el = MetricDefinition.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.definitions!.push(el);
          }
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.reporter = reporterFromJSON(reader.int32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.rotation_interval = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.graceful_deletion_interval = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PluginConfig {
    return {
      $type: PluginConfig.$type,
      disable_host_header_fallback: isSet(object.disable_host_header_fallback)
        ? globalThis.Boolean(object.disable_host_header_fallback)
        : undefined,
      tcp_reporting_duration: isSet(object.tcp_reporting_duration)
        ? Duration.fromJSON(object.tcp_reporting_duration)
        : undefined,
      metrics: globalThis.Array.isArray(object?.metrics)
        ? object.metrics.map((e: any) => MetricConfig.fromJSON(e))
        : undefined,
      definitions: globalThis.Array.isArray(object?.definitions)
        ? object.definitions.map((e: any) => MetricDefinition.fromJSON(e))
        : undefined,
      reporter: isSet(object.reporter) ? reporterFromJSON(object.reporter) : undefined,
      rotation_interval: isSet(object.rotation_interval) ? Duration.fromJSON(object.rotation_interval) : undefined,
      graceful_deletion_interval: isSet(object.graceful_deletion_interval)
        ? Duration.fromJSON(object.graceful_deletion_interval)
        : undefined,
    };
  },

  toJSON(message: PluginConfig): unknown {
    const obj: any = {};
    if (message.disable_host_header_fallback !== undefined) {
      obj.disable_host_header_fallback = message.disable_host_header_fallback;
    }
    if (message.tcp_reporting_duration !== undefined) {
      obj.tcp_reporting_duration = Duration.toJSON(message.tcp_reporting_duration);
    }
    if (message.metrics?.length) {
      obj.metrics = message.metrics.map((e) => MetricConfig.toJSON(e));
    }
    if (message.definitions?.length) {
      obj.definitions = message.definitions.map((e) => MetricDefinition.toJSON(e));
    }
    if (message.reporter !== undefined) {
      obj.reporter = reporterToJSON(message.reporter);
    }
    if (message.rotation_interval !== undefined) {
      obj.rotation_interval = Duration.toJSON(message.rotation_interval);
    }
    if (message.graceful_deletion_interval !== undefined) {
      obj.graceful_deletion_interval = Duration.toJSON(message.graceful_deletion_interval);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PluginConfig>, I>>(base?: I): PluginConfig {
    return PluginConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PluginConfig>, I>>(object: I): PluginConfig {
    const message = createBasePluginConfig();
    message.disable_host_header_fallback = object.disable_host_header_fallback ?? undefined;
    message.tcp_reporting_duration =
      (object.tcp_reporting_duration !== undefined && object.tcp_reporting_duration !== null)
        ? Duration.fromPartial(object.tcp_reporting_duration)
        : undefined;
    message.metrics = object.metrics?.map((e) => MetricConfig.fromPartial(e)) || undefined;
    message.definitions = object.definitions?.map((e) => MetricDefinition.fromPartial(e)) || undefined;
    message.reporter = object.reporter ?? undefined;
    message.rotation_interval = (object.rotation_interval !== undefined && object.rotation_interval !== null)
      ? Duration.fromPartial(object.rotation_interval)
      : undefined;
    message.graceful_deletion_interval =
      (object.graceful_deletion_interval !== undefined && object.graceful_deletion_interval !== null)
        ? Duration.fromPartial(object.graceful_deletion_interval)
        : undefined;
    return message;
  },
};

messageTypeRegistry.set(PluginConfig.$type, PluginConfig);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
