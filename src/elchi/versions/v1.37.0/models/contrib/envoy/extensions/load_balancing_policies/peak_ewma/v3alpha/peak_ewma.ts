// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: contrib/envoy/extensions/load_balancing_policies/peak_ewma/v3alpha/peak_ewma.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../../../../google/protobuf/duration";
import { DoubleValue, UInt32Value } from "../../../../../../google/protobuf/wrappers";
import { messageTypeRegistry } from "../../../../../../typeRegistry";

export const protobufPackage = "envoy.extensions.load_balancing_policies.peak_ewma.v3alpha";

/**
 * [#protodoc-title: Peak EWMA Load Balancer Configuration]
 * Configuration for the Peak EWMA (Exponentially Weighted Moving Average) load balancing policy.
 *
 * This policy implements a latency-aware variant of the Power of Two Choices (P2C) algorithm.
 * It selects the best host from two randomly chosen candidates based on a cost function:
 * `Cost = RTT_peak_ewma * (active_requests + 1)`.
 *
 * The Peak EWMA algorithm is designed to:
 * - Automatically route traffic away from slow or overloaded hosts
 * - Adapt to changing host performance without manual configuration
 * - Provide low-latency request routing with O(1) host selection complexity
 * - Work effectively in heterogeneous environments with varying host capabilities
 *
 * RTT measurements are automatically collected from HTTP request timing and used to update
 * the EWMA for each host. This provides real-time performance feedback for routing decisions.
 *
 * Important: This load balancer only considers latency and load when selecting hosts. It does
 * not handle host health or error responses - these should be managed by Envoy's health checking
 * and outlier detection systems. Peak EWMA operates on the pool of healthy hosts as determined
 * by these other systems.
 *
 * [#extension: envoy.load_balancing_policies.peak_ewma]
 * [#next-free-field: 6]
 */
export interface PeakEwma {
  $type: "envoy.extensions.load_balancing_policies.peak_ewma.v3alpha.PeakEwma";
  /**
   * The decay time for the RTT EWMA calculation. This specifies the time window over which
   * latency observations are considered relevant. After this duration, older measurements
   * have exponentially decayed to half their original weight.
   *
   * The Peak EWMA algorithm uses this to calculate the EWMA time constant (tau):
   * `tau = decay_time_nanos`, and the EWMA reaches its half-life after `tau * ln(2)`.
   *
   * This parameter is more intuitive than a raw smoothing factor as it directly relates
   * to the time duration over which you want to observe latency trends.
   *
   * If not specified, defaults to 10 seconds (following Finagle's default).
   */
  decay_time?:
    | Duration
    | undefined;
  /**
   * The interval at which EWMA data is aggregated from worker threads to the main thread.
   * This controls the frequency of cross-thread synchronization for the per-thread aggregation model.
   *
   * A shorter interval provides more up-to-date cross-worker information but increases
   * synchronization overhead. A longer interval reduces overhead but may cause workers
   * to operate with staler information about other workers' latency observations.
   *
   * If not specified, defaults to 100 milliseconds.
   */
  aggregation_interval?:
    | Duration
    | undefined;
  /**
   * Maximum RTT samples to buffer per host per worker thread before overwriting oldest samples.
   * This bounds memory usage while allowing burst traffic handling.
   *
   * Buffer capacity formula: max_samples_per_host / aggregation_interval = RPS capacity per host per worker
   * Memory formula: max_samples_per_host × num_hosts × num_workers × 16 bytes
   * Memory usage per worker = max_samples_per_host × num_hosts × 16 bytes
   *
   * If not specified, defaults to 1,000 samples per host per worker.
   */
  max_samples_per_host?:
    | number
    | undefined;
  /**
   * Default RTT value to use for hosts that don't have measured RTT yet.
   * This provides a baseline for cost calculations until actual measurements are available.
   *
   * This value is critical for initial load balancing decisions when hosts first join
   * the cluster or when RTT measurements are temporarily unavailable. It should reflect
   * the expected baseline latency for your environment:
   *
   * If not specified, defaults to 10 milliseconds.
   */
  default_rtt?:
    | Duration
    | undefined;
  /**
   * Penalty cost assigned to hosts that cannot provide valid cost calculations.
   * This is used when a host has no RTT measurements or is unhealthy, ensuring
   * the Power of Two Choices algorithm will prefer hosts with known performance.
   *
   * You probably should not change this value.
   *
   * The penalty should be significantly higher than any realistic RTT-based cost
   * to ensure hosts with unknown performance are strongly deprioritized while
   * still allowing them to receive traffic if no better alternatives exist.
   *
   * If not specified, defaults to 1,000,000.0 (1 million).
   */
  penalty_value?: number | undefined;
}

function createBasePeakEwma(): PeakEwma {
  return { $type: "envoy.extensions.load_balancing_policies.peak_ewma.v3alpha.PeakEwma" };
}

export const PeakEwma: MessageFns<PeakEwma, "envoy.extensions.load_balancing_policies.peak_ewma.v3alpha.PeakEwma"> = {
  $type: "envoy.extensions.load_balancing_policies.peak_ewma.v3alpha.PeakEwma" as const,

  encode(message: PeakEwma, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.decay_time !== undefined) {
      Duration.encode(message.decay_time, writer.uint32(10).fork()).join();
    }
    if (message.aggregation_interval !== undefined) {
      Duration.encode(message.aggregation_interval, writer.uint32(18).fork()).join();
    }
    if (message.max_samples_per_host !== undefined) {
      UInt32Value.encode(
        { $type: "google.protobuf.UInt32Value", value: message.max_samples_per_host! },
        writer.uint32(26).fork(),
      ).join();
    }
    if (message.default_rtt !== undefined) {
      Duration.encode(message.default_rtt, writer.uint32(34).fork()).join();
    }
    if (message.penalty_value !== undefined) {
      DoubleValue.encode(
        { $type: "google.protobuf.DoubleValue", value: message.penalty_value! },
        writer.uint32(42).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PeakEwma {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePeakEwma();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.decay_time = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.aggregation_interval = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.max_samples_per_host = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.default_rtt = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.penalty_value = DoubleValue.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PeakEwma {
    return {
      $type: PeakEwma.$type,
      decay_time: isSet(object.decay_time) ? Duration.fromJSON(object.decay_time) : undefined,
      aggregation_interval: isSet(object.aggregation_interval)
        ? Duration.fromJSON(object.aggregation_interval)
        : undefined,
      max_samples_per_host: isSet(object.max_samples_per_host) ? Number(object.max_samples_per_host) : undefined,
      default_rtt: isSet(object.default_rtt) ? Duration.fromJSON(object.default_rtt) : undefined,
      penalty_value: isSet(object.penalty_value) ? Number(object.penalty_value) : undefined,
    };
  },

  toJSON(message: PeakEwma): unknown {
    const obj: any = {};
    if (message.decay_time !== undefined) {
      obj.decay_time = Duration.toJSON(message.decay_time);
    }
    if (message.aggregation_interval !== undefined) {
      obj.aggregation_interval = Duration.toJSON(message.aggregation_interval);
    }
    if (message.max_samples_per_host !== undefined) {
      obj.max_samples_per_host = message.max_samples_per_host;
    }
    if (message.default_rtt !== undefined) {
      obj.default_rtt = Duration.toJSON(message.default_rtt);
    }
    if (message.penalty_value !== undefined) {
      obj.penalty_value = message.penalty_value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PeakEwma>, I>>(base?: I): PeakEwma {
    return PeakEwma.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PeakEwma>, I>>(object: I): PeakEwma {
    const message = createBasePeakEwma();
    message.decay_time = (object.decay_time !== undefined && object.decay_time !== null)
      ? Duration.fromPartial(object.decay_time)
      : undefined;
    message.aggregation_interval = (object.aggregation_interval !== undefined && object.aggregation_interval !== null)
      ? Duration.fromPartial(object.aggregation_interval)
      : undefined;
    message.max_samples_per_host = object.max_samples_per_host ?? undefined;
    message.default_rtt = (object.default_rtt !== undefined && object.default_rtt !== null)
      ? Duration.fromPartial(object.default_rtt)
      : undefined;
    message.penalty_value = object.penalty_value ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(PeakEwma.$type, PeakEwma);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
