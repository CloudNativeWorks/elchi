// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               unknown
// source: contrib/envoy/extensions/filters/common/workload_discovery/v3/discovery.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { messageTypeRegistry } from "../../../../../../../typeRegistry";

export const protobufPackage = "istio.workload";

/** NetworkMode indicates how the addresses of the workload should be treated. */
export enum NetworkMode {
  /** STANDARD - STANDARD means that the workload is uniquely identified by its address (within its network). */
  STANDARD = "STANDARD",
  /**
   * HOST_NETWORK - HOST_NETWORK means the workload has an IP address that is shared by many workloads. The data plane should avoid
   * attempting to lookup these workloads by IP address (which could return the wrong result).
   */
  HOST_NETWORK = "HOST_NETWORK",
}

export function networkModeFromJSON(object: any): NetworkMode {
  switch (object) {
    case 0:
    case "STANDARD":
      return NetworkMode.STANDARD;
    case 1:
    case "HOST_NETWORK":
      return NetworkMode.HOST_NETWORK;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum NetworkMode");
  }
}

export function networkModeToJSON(object: NetworkMode): string {
  switch (object) {
    case NetworkMode.STANDARD:
      return "STANDARD";
    case NetworkMode.HOST_NETWORK:
      return "HOST_NETWORK";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum NetworkMode");
  }
}

export function networkModeToNumber(object: NetworkMode): number {
  switch (object) {
    case NetworkMode.STANDARD:
      return 0;
    case NetworkMode.HOST_NETWORK:
      return 1;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum NetworkMode");
  }
}

export enum WorkloadStatus {
  /** HEALTHY - Workload is healthy and ready to serve traffic. */
  HEALTHY = "HEALTHY",
  /** UNHEALTHY - Workload is unhealthy and NOT ready to serve traffic. */
  UNHEALTHY = "UNHEALTHY",
}

export function workloadStatusFromJSON(object: any): WorkloadStatus {
  switch (object) {
    case 0:
    case "HEALTHY":
      return WorkloadStatus.HEALTHY;
    case 1:
    case "UNHEALTHY":
      return WorkloadStatus.UNHEALTHY;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum WorkloadStatus");
  }
}

export function workloadStatusToJSON(object: WorkloadStatus): string {
  switch (object) {
    case WorkloadStatus.HEALTHY:
      return "HEALTHY";
    case WorkloadStatus.UNHEALTHY:
      return "UNHEALTHY";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum WorkloadStatus");
  }
}

export function workloadStatusToNumber(object: WorkloadStatus): number {
  switch (object) {
    case WorkloadStatus.HEALTHY:
      return 0;
    case WorkloadStatus.UNHEALTHY:
      return 1;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum WorkloadStatus");
  }
}

export enum WorkloadType {
  DEPLOYMENT = "DEPLOYMENT",
  CRONJOB = "CRONJOB",
  POD = "POD",
  JOB = "JOB",
}

export function workloadTypeFromJSON(object: any): WorkloadType {
  switch (object) {
    case 0:
    case "DEPLOYMENT":
      return WorkloadType.DEPLOYMENT;
    case 1:
    case "CRONJOB":
      return WorkloadType.CRONJOB;
    case 2:
    case "POD":
      return WorkloadType.POD;
    case 3:
    case "JOB":
      return WorkloadType.JOB;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum WorkloadType");
  }
}

export function workloadTypeToJSON(object: WorkloadType): string {
  switch (object) {
    case WorkloadType.DEPLOYMENT:
      return "DEPLOYMENT";
    case WorkloadType.CRONJOB:
      return "CRONJOB";
    case WorkloadType.POD:
      return "POD";
    case WorkloadType.JOB:
      return "JOB";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum WorkloadType");
  }
}

export function workloadTypeToNumber(object: WorkloadType): number {
  switch (object) {
    case WorkloadType.DEPLOYMENT:
      return 0;
    case WorkloadType.CRONJOB:
      return 1;
    case WorkloadType.POD:
      return 2;
    case WorkloadType.JOB:
      return 3;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum WorkloadType");
  }
}

/** TunnelProtocol indicates the tunneling protocol for requests. */
export enum TunnelProtocol {
  /** NONE - NONE means requests should be forwarded as-is, without tunneling. */
  NONE = "NONE",
  /**
   * HBONE - HBONE means requests should be tunneled over HTTP.
   * This does not dictate HTTP/1.1 vs HTTP/2; ALPN should be used for that purpose.
   */
  HBONE = "HBONE",
}

export function tunnelProtocolFromJSON(object: any): TunnelProtocol {
  switch (object) {
    case 0:
    case "NONE":
      return TunnelProtocol.NONE;
    case 1:
    case "HBONE":
      return TunnelProtocol.HBONE;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum TunnelProtocol");
  }
}

export function tunnelProtocolToJSON(object: TunnelProtocol): string {
  switch (object) {
    case TunnelProtocol.NONE:
      return "NONE";
    case TunnelProtocol.HBONE:
      return "HBONE";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum TunnelProtocol");
  }
}

export function tunnelProtocolToNumber(object: TunnelProtocol): number {
  switch (object) {
    case TunnelProtocol.NONE:
      return 0;
    case TunnelProtocol.HBONE:
      return 1;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum TunnelProtocol");
  }
}

/**
 * Workload represents a workload - an endpoint (or collection behind a hostname).
 * The xds primary key is "uid" as defined on the workload below.
 * Secondary (alias) keys are the unique ``network/IP`` pairs that the workload can be reached at.
 * [#next-free-field: 26]
 */
export interface Workload {
  $type: "istio.workload.Workload";
  /**
   * UID represents a globally unique opaque identifier for this workload.
   * For k8s resources, it is recommended to use the more readable format:
   *
   * cluster/group/kind/namespace/name/section-name
   *
   * As an example, a ServiceEntry with two WorkloadEntries inlined could become
   * two Workloads with the following UIDs:
   * - cluster1/networking.istio.io/v1alpha3/ServiceEntry/default/external-svc/endpoint1
   * - cluster1/networking.istio.io/v1alpha3/ServiceEntry/default/external-svc/endpoint2
   *
   * For VMs and other workloads other formats are also supported; for example,
   * a single UID string: "0ae5c03d-5fb3-4eb9-9de8-2bd4b51606ba"
   */
  uid?:
    | string
    | undefined;
  /**
   * Name represents the name for the workload.
   * For Kubernetes, this is the pod name.
   * This is just for debugging and may be elided as an optimization.
   */
  name?:
    | string
    | undefined;
  /**
   * Namespace represents the namespace for the workload.
   * This is just for debugging and may be elided as an optimization.
   */
  namespace?:
    | string
    | undefined;
  /**
   * Address represents the IPv4/IPv6 address for the workload.
   * This should be globally unique.
   * This should not have a port number.
   * Each workload must have at least either an address or hostname; not both.
   */
  addresses?:
    | Uint8Array[]
    | undefined;
  /**
   * The hostname for the workload to be resolved by the ztunnel.
   * DNS queries are sent on-demand by default.
   * If the resolved DNS query has several endpoints, the request will be forwarded
   * to the first response.
   *
   * At a minimum, each workload must have either an address or hostname. For example,
   * a workload that backs a Kubernetes service will typically have only endpoints. A
   * workload that backs a headless Kubernetes service, however, will have both
   * addresses as well as a hostname used for direct access to the headless endpoint.
   */
  hostname?:
    | string
    | undefined;
  /**
   * Network represents the network this workload is on. This may be elided for the default network.
   * A (network,address) pair makeup a unique key for a workload *at a point in time*.
   */
  network?:
    | string
    | undefined;
  /** Protocol that should be used to connect to this workload. */
  tunnel_protocol?:
    | TunnelProtocol
    | undefined;
  /**
   * The SPIFFE identity of the workload. The identity is joined to form spiffe://<trust_domain>/ns/<namespace>/sa/<service_account>.
   * TrustDomain of the workload. May be elided if this is the mesh wide default (typically cluster.local)
   */
  trust_domain?:
    | string
    | undefined;
  /** ServiceAccount of the workload. May be elided if this is "default" */
  service_account?:
    | string
    | undefined;
  /**
   * If present, the waypoint proxy for this workload.
   * All incoming requests must go through the waypoint.
   */
  waypoint?:
    | GatewayAddress
    | undefined;
  /**
   * If present, East West network gateway this workload can be reached through.
   * Requests from remote networks should traverse this gateway.
   */
  network_gateway?:
    | GatewayAddress
    | undefined;
  /** Name of the node the workload runs on */
  node?:
    | string
    | undefined;
  /** CanonicalName for the workload. Used for telemetry. */
  canonical_name?:
    | string
    | undefined;
  /** CanonicalRevision for the workload. Used for telemetry. */
  canonical_revision?:
    | string
    | undefined;
  /** WorkloadType represents the type of the workload. Used for telemetry. */
  workload_type?:
    | WorkloadType
    | undefined;
  /** WorkloadName represents the name for the workload (of type WorkloadType). Used for telemetry. */
  workload_name?:
    | string
    | undefined;
  /**
   * If set, this indicates a workload expects to directly receive tunnel traffic.
   * In ztunnel, this means:
   * * Requests *from* this workload do not need to be tunneled if they already are tunneled by the tunnel_protocol.
   * * Requests *to* this workload, via the tunnel_protocol, do not need to be de-tunneled.
   */
  native_tunnel?:
    | boolean
    | undefined;
  /**
   * If an application, such as a sandwiched waypoint proxy, supports directly
   * receiving information from zTunnel they can set application_protocol.
   */
  application_tunnel?:
    | ApplicationTunnel
    | undefined;
  /**
   * The services for which this workload is an endpoint.
   * The key is the NamespacedHostname string of the format namespace/hostname.
   */
  services?:
    | Map<string, PortList>
    | undefined;
  /**
   * A list of authorization policies applicable to this workload.
   * NOTE: this *only* includes Selector based policies. Namespace and global polices
   * are returned out of band.
   * Authorization policies are only valid for workloads with ``addresses`` rather than ``hostname``.
   */
  authorization_policies?: string[] | undefined;
  status?:
    | WorkloadStatus
    | undefined;
  /** The cluster ID that the workload instance belongs to */
  cluster_id?:
    | string
    | undefined;
  /** The Locality defines information about where a workload is geographically deployed */
  locality?: Locality | undefined;
  network_mode?: NetworkMode | undefined;
}

export interface Workload_ServicesEntry {
  $type: "istio.workload.Workload.ServicesEntry";
  key: string;
  value?: PortList | undefined;
}

export interface Locality {
  $type: "istio.workload.Locality";
  region?: string | undefined;
  zone?: string | undefined;
  subzone?: string | undefined;
}

/** This represents the ports for a service */
export interface PortList {
  $type: "istio.workload.PortList";
  ports?: Port[] | undefined;
}

export interface Port {
  $type: "istio.workload.Port";
  /** Port the service is reached at (frontend). */
  service_port?:
    | number
    | undefined;
  /** Port the service forwards to (backend). */
  target_port?: number | undefined;
}

/**
 * ApplicationProtocol specifies a workload  (application or gateway) can
 * consume tunnel information.
 */
export interface ApplicationTunnel {
  $type: "istio.workload.ApplicationTunnel";
  /** A target natively handles this type of traffic. */
  protocol?:
    | ApplicationTunnel_Protocol
    | undefined;
  /** optional: if set, traffic should be sent to this port after the last zTunnel hop */
  port?: number | undefined;
}

export enum ApplicationTunnel_Protocol {
  /** NONE - Bytes are copied from the inner stream without modification. */
  NONE = "NONE",
  /**
   * PROXY - Prepend PROXY protocol headers before copying bytes
   * Standard PROXY source and destination information
   * is included, along with potential extra TLV headers:
   * 0xD0 - The SPIFFE identity of the source workload
   * 0xD1 - The FQDN or Hostname of the targeted Service
   */
  PROXY = "PROXY",
}

export function applicationTunnel_ProtocolFromJSON(object: any): ApplicationTunnel_Protocol {
  switch (object) {
    case 0:
    case "NONE":
      return ApplicationTunnel_Protocol.NONE;
    case 1:
    case "PROXY":
      return ApplicationTunnel_Protocol.PROXY;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ApplicationTunnel_Protocol");
  }
}

export function applicationTunnel_ProtocolToJSON(object: ApplicationTunnel_Protocol): string {
  switch (object) {
    case ApplicationTunnel_Protocol.NONE:
      return "NONE";
    case ApplicationTunnel_Protocol.PROXY:
      return "PROXY";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ApplicationTunnel_Protocol");
  }
}

export function applicationTunnel_ProtocolToNumber(object: ApplicationTunnel_Protocol): number {
  switch (object) {
    case ApplicationTunnel_Protocol.NONE:
      return 0;
    case ApplicationTunnel_Protocol.PROXY:
      return 1;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ApplicationTunnel_Protocol");
  }
}

/** GatewayAddress represents the address of a gateway */
export interface GatewayAddress {
  $type: "istio.workload.GatewayAddress";
  /** address can either be a hostname (ex: gateway.example.com) or an IP (ex: 1.2.3.4). */
  destination?:
    | //
    /** TODO: add support for hostname lookup */
    { $case: "hostname"; hostname: NamespacedHostname }
    | //
    { $case: "address"; address: NetworkAddress }
    | undefined;
  /** port to reach the gateway at for mTLS HBONE connections */
  hbone_mtls_port?: number | undefined;
}

/** NetworkAddress represents an address bound to a specific network. */
export interface NetworkAddress {
  $type: "istio.workload.NetworkAddress";
  /** Network represents the network this address is on. */
  network?:
    | string
    | undefined;
  /** Address presents the IP (v4 or v6). */
  address?: Uint8Array | undefined;
}

/** NamespacedHostname represents a service bound to a specific namespace. */
export interface NamespacedHostname {
  $type: "istio.workload.NamespacedHostname";
  /** The namespace the service is in. */
  namespace?:
    | string
    | undefined;
  /** hostname (ex: gateway.example.com) */
  hostname?: string | undefined;
}

function createBaseWorkload(): Workload {
  return { $type: "istio.workload.Workload" };
}

export const Workload: MessageFns<Workload, "istio.workload.Workload"> = {
  $type: "istio.workload.Workload" as const,

  encode(message: Workload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uid !== undefined && message.uid !== "") {
      writer.uint32(162).string(message.uid);
    }
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.namespace !== undefined && message.namespace !== "") {
      writer.uint32(18).string(message.namespace);
    }
    if (message.addresses !== undefined && message.addresses.length !== 0) {
      for (const v of message.addresses) {
        writer.uint32(26).bytes(v!);
      }
    }
    if (message.hostname !== undefined && message.hostname !== "") {
      writer.uint32(170).string(message.hostname);
    }
    if (message.network !== undefined && message.network !== "") {
      writer.uint32(34).string(message.network);
    }
    if (message.tunnel_protocol !== undefined && message.tunnel_protocol !== TunnelProtocol.NONE) {
      writer.uint32(40).int32(tunnelProtocolToNumber(message.tunnel_protocol));
    }
    if (message.trust_domain !== undefined && message.trust_domain !== "") {
      writer.uint32(50).string(message.trust_domain);
    }
    if (message.service_account !== undefined && message.service_account !== "") {
      writer.uint32(58).string(message.service_account);
    }
    if (message.waypoint !== undefined) {
      GatewayAddress.encode(message.waypoint, writer.uint32(66).fork()).join();
    }
    if (message.network_gateway !== undefined) {
      GatewayAddress.encode(message.network_gateway, writer.uint32(154).fork()).join();
    }
    if (message.node !== undefined && message.node !== "") {
      writer.uint32(74).string(message.node);
    }
    if (message.canonical_name !== undefined && message.canonical_name !== "") {
      writer.uint32(82).string(message.canonical_name);
    }
    if (message.canonical_revision !== undefined && message.canonical_revision !== "") {
      writer.uint32(90).string(message.canonical_revision);
    }
    if (message.workload_type !== undefined && message.workload_type !== WorkloadType.DEPLOYMENT) {
      writer.uint32(96).int32(workloadTypeToNumber(message.workload_type));
    }
    if (message.workload_name !== undefined && message.workload_name !== "") {
      writer.uint32(106).string(message.workload_name);
    }
    if (message.native_tunnel !== undefined && message.native_tunnel !== false) {
      writer.uint32(112).bool(message.native_tunnel);
    }
    if (message.application_tunnel !== undefined) {
      ApplicationTunnel.encode(message.application_tunnel, writer.uint32(186).fork()).join();
    }
    (message.services || new Map()).forEach((value, key) => {
      Workload_ServicesEntry.encode(
        { $type: "istio.workload.Workload.ServicesEntry", key: key as any, value },
        writer.uint32(178).fork(),
      ).join();
    });
    if (message.authorization_policies !== undefined && message.authorization_policies.length !== 0) {
      for (const v of message.authorization_policies) {
        writer.uint32(130).string(v!);
      }
    }
    if (message.status !== undefined && message.status !== WorkloadStatus.HEALTHY) {
      writer.uint32(136).int32(workloadStatusToNumber(message.status));
    }
    if (message.cluster_id !== undefined && message.cluster_id !== "") {
      writer.uint32(146).string(message.cluster_id);
    }
    if (message.locality !== undefined) {
      Locality.encode(message.locality, writer.uint32(194).fork()).join();
    }
    if (message.network_mode !== undefined && message.network_mode !== NetworkMode.STANDARD) {
      writer.uint32(200).int32(networkModeToNumber(message.network_mode));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Workload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.uid = reader.string();
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          if (message.addresses === undefined) {
            message.addresses = [];
          }
          const el = reader.bytes();
          if (el !== undefined) {
            message.addresses!.push(el);
          }
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.hostname = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.network = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.tunnel_protocol = tunnelProtocolFromJSON(reader.int32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.trust_domain = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.service_account = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.waypoint = GatewayAddress.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.network_gateway = GatewayAddress.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.node = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.canonical_name = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.canonical_revision = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.workload_type = workloadTypeFromJSON(reader.int32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.workload_name = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.native_tunnel = reader.bool();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.application_tunnel = ApplicationTunnel.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          const entry22 = Workload_ServicesEntry.decode(reader, reader.uint32());
          if (entry22.value !== undefined) {
            if (message.services === undefined) {
              message.services = new Map();
            }
            message.services!.set(entry22.key, entry22.value);
          }
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          if (message.authorization_policies === undefined) {
            message.authorization_policies = [];
          }
          const el = reader.string();
          if (el !== undefined) {
            message.authorization_policies!.push(el);
          }
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.status = workloadStatusFromJSON(reader.int32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.cluster_id = reader.string();
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.locality = Locality.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.network_mode = networkModeFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Workload {
    return {
      $type: Workload.$type,
      uid: isSet(object.uid) ? globalThis.String(object.uid) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : undefined,
      addresses: globalThis.Array.isArray(object?.addresses)
        ? object.addresses.map((e: any) => bytesFromBase64(e))
        : undefined,
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : undefined,
      network: isSet(object.network) ? globalThis.String(object.network) : undefined,
      tunnel_protocol: isSet(object.tunnel_protocol) ? tunnelProtocolFromJSON(object.tunnel_protocol) : undefined,
      trust_domain: isSet(object.trust_domain) ? globalThis.String(object.trust_domain) : undefined,
      service_account: isSet(object.service_account) ? globalThis.String(object.service_account) : undefined,
      waypoint: isSet(object.waypoint) ? GatewayAddress.fromJSON(object.waypoint) : undefined,
      network_gateway: isSet(object.network_gateway) ? GatewayAddress.fromJSON(object.network_gateway) : undefined,
      node: isSet(object.node) ? globalThis.String(object.node) : undefined,
      canonical_name: isSet(object.canonical_name) ? globalThis.String(object.canonical_name) : undefined,
      canonical_revision: isSet(object.canonical_revision) ? globalThis.String(object.canonical_revision) : undefined,
      workload_type: isSet(object.workload_type) ? workloadTypeFromJSON(object.workload_type) : undefined,
      workload_name: isSet(object.workload_name) ? globalThis.String(object.workload_name) : undefined,
      native_tunnel: isSet(object.native_tunnel) ? globalThis.Boolean(object.native_tunnel) : undefined,
      application_tunnel: isSet(object.application_tunnel)
        ? ApplicationTunnel.fromJSON(object.application_tunnel)
        : undefined,
      services: isObject(object.services)
        ? Object.entries(object.services).reduce<Map<string, PortList>>((acc, [key, value]) => {
          acc.set(key, PortList.fromJSON(value));
          return acc;
        }, new Map())
        : undefined,
      authorization_policies: globalThis.Array.isArray(object?.authorization_policies)
        ? object.authorization_policies.map((e: any) => globalThis.String(e))
        : undefined,
      status: isSet(object.status) ? workloadStatusFromJSON(object.status) : undefined,
      cluster_id: isSet(object.cluster_id) ? globalThis.String(object.cluster_id) : undefined,
      locality: isSet(object.locality) ? Locality.fromJSON(object.locality) : undefined,
      network_mode: isSet(object.network_mode) ? networkModeFromJSON(object.network_mode) : undefined,
    };
  },

  toJSON(message: Workload): unknown {
    const obj: any = {};
    if (message.uid !== undefined) {
      obj.uid = message.uid;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.namespace !== undefined) {
      obj.namespace = message.namespace;
    }
    if (message.addresses?.length) {
      obj.addresses = message.addresses.map((e) => base64FromBytes(e));
    }
    if (message.hostname !== undefined) {
      obj.hostname = message.hostname;
    }
    if (message.network !== undefined) {
      obj.network = message.network;
    }
    if (message.tunnel_protocol !== undefined) {
      obj.tunnel_protocol = tunnelProtocolToJSON(message.tunnel_protocol);
    }
    if (message.trust_domain !== undefined) {
      obj.trust_domain = message.trust_domain;
    }
    if (message.service_account !== undefined) {
      obj.service_account = message.service_account;
    }
    if (message.waypoint !== undefined) {
      obj.waypoint = GatewayAddress.toJSON(message.waypoint);
    }
    if (message.network_gateway !== undefined) {
      obj.network_gateway = GatewayAddress.toJSON(message.network_gateway);
    }
    if (message.node !== undefined) {
      obj.node = message.node;
    }
    if (message.canonical_name !== undefined) {
      obj.canonical_name = message.canonical_name;
    }
    if (message.canonical_revision !== undefined) {
      obj.canonical_revision = message.canonical_revision;
    }
    if (message.workload_type !== undefined) {
      obj.workload_type = workloadTypeToJSON(message.workload_type);
    }
    if (message.workload_name !== undefined) {
      obj.workload_name = message.workload_name;
    }
    if (message.native_tunnel !== undefined) {
      obj.native_tunnel = message.native_tunnel;
    }
    if (message.application_tunnel !== undefined) {
      obj.application_tunnel = ApplicationTunnel.toJSON(message.application_tunnel);
    }
    if (message.services?.size) {
      obj.services = {};
      message.services.forEach((v, k) => {
        obj.services[k] = PortList.toJSON(v);
      });
    }
    if (message.authorization_policies?.length) {
      obj.authorization_policies = message.authorization_policies;
    }
    if (message.status !== undefined) {
      obj.status = workloadStatusToJSON(message.status);
    }
    if (message.cluster_id !== undefined) {
      obj.cluster_id = message.cluster_id;
    }
    if (message.locality !== undefined) {
      obj.locality = Locality.toJSON(message.locality);
    }
    if (message.network_mode !== undefined) {
      obj.network_mode = networkModeToJSON(message.network_mode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Workload>, I>>(base?: I): Workload {
    return Workload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Workload>, I>>(object: I): Workload {
    const message = createBaseWorkload();
    message.uid = object.uid ?? undefined;
    message.name = object.name ?? undefined;
    message.namespace = object.namespace ?? undefined;
    message.addresses = object.addresses?.map((e) => e) || undefined;
    message.hostname = object.hostname ?? undefined;
    message.network = object.network ?? undefined;
    message.tunnel_protocol = object.tunnel_protocol ?? undefined;
    message.trust_domain = object.trust_domain ?? undefined;
    message.service_account = object.service_account ?? undefined;
    message.waypoint = (object.waypoint !== undefined && object.waypoint !== null)
      ? GatewayAddress.fromPartial(object.waypoint)
      : undefined;
    message.network_gateway = (object.network_gateway !== undefined && object.network_gateway !== null)
      ? GatewayAddress.fromPartial(object.network_gateway)
      : undefined;
    message.node = object.node ?? undefined;
    message.canonical_name = object.canonical_name ?? undefined;
    message.canonical_revision = object.canonical_revision ?? undefined;
    message.workload_type = object.workload_type ?? undefined;
    message.workload_name = object.workload_name ?? undefined;
    message.native_tunnel = object.native_tunnel ?? undefined;
    message.application_tunnel = (object.application_tunnel !== undefined && object.application_tunnel !== null)
      ? ApplicationTunnel.fromPartial(object.application_tunnel)
      : undefined;
    message.services = (object.services === undefined || object.services === null) ? undefined : (() => {
      const m = new Map();
      (object.services as Map<string, PortList> ?? new Map()).forEach((value, key) => {
        if (value !== undefined) {
          m.set(key, PortList.fromPartial(value));
        }
      });
      return m;
    })();
    message.authorization_policies = object.authorization_policies?.map((e) => e) || undefined;
    message.status = object.status ?? undefined;
    message.cluster_id = object.cluster_id ?? undefined;
    message.locality = (object.locality !== undefined && object.locality !== null)
      ? Locality.fromPartial(object.locality)
      : undefined;
    message.network_mode = object.network_mode ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Workload.$type, Workload);

function createBaseWorkload_ServicesEntry(): Workload_ServicesEntry {
  return { $type: "istio.workload.Workload.ServicesEntry", key: "" };
}

export const Workload_ServicesEntry: MessageFns<Workload_ServicesEntry, "istio.workload.Workload.ServicesEntry"> = {
  $type: "istio.workload.Workload.ServicesEntry" as const,

  encode(message: Workload_ServicesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      PortList.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Workload_ServicesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkload_ServicesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = PortList.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Workload_ServicesEntry {
    return {
      $type: Workload_ServicesEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? PortList.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Workload_ServicesEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = PortList.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Workload_ServicesEntry>, I>>(base?: I): Workload_ServicesEntry {
    return Workload_ServicesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Workload_ServicesEntry>, I>>(object: I): Workload_ServicesEntry {
    const message = createBaseWorkload_ServicesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? PortList.fromPartial(object.value)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Workload_ServicesEntry.$type, Workload_ServicesEntry);

function createBaseLocality(): Locality {
  return { $type: "istio.workload.Locality" };
}

export const Locality: MessageFns<Locality, "istio.workload.Locality"> = {
  $type: "istio.workload.Locality" as const,

  encode(message: Locality, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.region !== undefined && message.region !== "") {
      writer.uint32(10).string(message.region);
    }
    if (message.zone !== undefined && message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.subzone !== undefined && message.subzone !== "") {
      writer.uint32(26).string(message.subzone);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Locality {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocality();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.region = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.subzone = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Locality {
    return {
      $type: Locality.$type,
      region: isSet(object.region) ? globalThis.String(object.region) : undefined,
      zone: isSet(object.zone) ? globalThis.String(object.zone) : undefined,
      subzone: isSet(object.subzone) ? globalThis.String(object.subzone) : undefined,
    };
  },

  toJSON(message: Locality): unknown {
    const obj: any = {};
    if (message.region !== undefined) {
      obj.region = message.region;
    }
    if (message.zone !== undefined) {
      obj.zone = message.zone;
    }
    if (message.subzone !== undefined) {
      obj.subzone = message.subzone;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Locality>, I>>(base?: I): Locality {
    return Locality.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Locality>, I>>(object: I): Locality {
    const message = createBaseLocality();
    message.region = object.region ?? undefined;
    message.zone = object.zone ?? undefined;
    message.subzone = object.subzone ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Locality.$type, Locality);

function createBasePortList(): PortList {
  return { $type: "istio.workload.PortList" };
}

export const PortList: MessageFns<PortList, "istio.workload.PortList"> = {
  $type: "istio.workload.PortList" as const,

  encode(message: PortList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ports !== undefined && message.ports.length !== 0) {
      for (const v of message.ports) {
        Port.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PortList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePortList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          if (message.ports === undefined) {
            message.ports = [];
          }
          const el = Port.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.ports!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PortList {
    return {
      $type: PortList.$type,
      ports: globalThis.Array.isArray(object?.ports) ? object.ports.map((e: any) => Port.fromJSON(e)) : undefined,
    };
  },

  toJSON(message: PortList): unknown {
    const obj: any = {};
    if (message.ports?.length) {
      obj.ports = message.ports.map((e) => Port.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PortList>, I>>(base?: I): PortList {
    return PortList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PortList>, I>>(object: I): PortList {
    const message = createBasePortList();
    message.ports = object.ports?.map((e) => Port.fromPartial(e)) || undefined;
    return message;
  },
};

messageTypeRegistry.set(PortList.$type, PortList);

function createBasePort(): Port {
  return { $type: "istio.workload.Port" };
}

export const Port: MessageFns<Port, "istio.workload.Port"> = {
  $type: "istio.workload.Port" as const,

  encode(message: Port, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.service_port !== undefined && message.service_port !== 0) {
      writer.uint32(8).uint32(message.service_port);
    }
    if (message.target_port !== undefined && message.target_port !== 0) {
      writer.uint32(16).uint32(message.target_port);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Port {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePort();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.service_port = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.target_port = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Port {
    return {
      $type: Port.$type,
      service_port: isSet(object.service_port) ? globalThis.Number(object.service_port) : undefined,
      target_port: isSet(object.target_port) ? globalThis.Number(object.target_port) : undefined,
    };
  },

  toJSON(message: Port): unknown {
    const obj: any = {};
    if (message.service_port !== undefined) {
      obj.service_port = Math.round(message.service_port);
    }
    if (message.target_port !== undefined) {
      obj.target_port = Math.round(message.target_port);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Port>, I>>(base?: I): Port {
    return Port.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Port>, I>>(object: I): Port {
    const message = createBasePort();
    message.service_port = object.service_port ?? undefined;
    message.target_port = object.target_port ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Port.$type, Port);

function createBaseApplicationTunnel(): ApplicationTunnel {
  return { $type: "istio.workload.ApplicationTunnel" };
}

export const ApplicationTunnel: MessageFns<ApplicationTunnel, "istio.workload.ApplicationTunnel"> = {
  $type: "istio.workload.ApplicationTunnel" as const,

  encode(message: ApplicationTunnel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.protocol !== undefined && message.protocol !== ApplicationTunnel_Protocol.NONE) {
      writer.uint32(8).int32(applicationTunnel_ProtocolToNumber(message.protocol));
    }
    if (message.port !== undefined && message.port !== 0) {
      writer.uint32(16).uint32(message.port);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApplicationTunnel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplicationTunnel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.protocol = applicationTunnel_ProtocolFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.port = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApplicationTunnel {
    return {
      $type: ApplicationTunnel.$type,
      protocol: isSet(object.protocol) ? applicationTunnel_ProtocolFromJSON(object.protocol) : undefined,
      port: isSet(object.port) ? globalThis.Number(object.port) : undefined,
    };
  },

  toJSON(message: ApplicationTunnel): unknown {
    const obj: any = {};
    if (message.protocol !== undefined) {
      obj.protocol = applicationTunnel_ProtocolToJSON(message.protocol);
    }
    if (message.port !== undefined) {
      obj.port = Math.round(message.port);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApplicationTunnel>, I>>(base?: I): ApplicationTunnel {
    return ApplicationTunnel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApplicationTunnel>, I>>(object: I): ApplicationTunnel {
    const message = createBaseApplicationTunnel();
    message.protocol = object.protocol ?? undefined;
    message.port = object.port ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ApplicationTunnel.$type, ApplicationTunnel);

function createBaseGatewayAddress(): GatewayAddress {
  return { $type: "istio.workload.GatewayAddress", destination: undefined };
}

export const GatewayAddress: MessageFns<GatewayAddress, "istio.workload.GatewayAddress"> = {
  $type: "istio.workload.GatewayAddress" as const,

  encode(message: GatewayAddress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.destination?.$case) {
      case "hostname":
        NamespacedHostname.encode(message.destination.hostname, writer.uint32(10).fork()).join();
        break;
      case "address":
        NetworkAddress.encode(message.destination.address, writer.uint32(18).fork()).join();
        break;
    }
    if (message.hbone_mtls_port !== undefined && message.hbone_mtls_port !== 0) {
      writer.uint32(24).uint32(message.hbone_mtls_port);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GatewayAddress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGatewayAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.destination = { $case: "hostname", hostname: NamespacedHostname.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.destination = { $case: "address", address: NetworkAddress.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.hbone_mtls_port = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GatewayAddress {
    return {
      $type: GatewayAddress.$type,
      destination: isSet(object.hostname)
        ? { $case: "hostname", hostname: NamespacedHostname.fromJSON(object.hostname) }
        : isSet(object.address)
        ? { $case: "address", address: NetworkAddress.fromJSON(object.address) }
        : undefined,
      hbone_mtls_port: isSet(object.hbone_mtls_port) ? globalThis.Number(object.hbone_mtls_port) : undefined,
    };
  },

  toJSON(message: GatewayAddress): unknown {
    const obj: any = {};
    if (message.destination?.$case === "hostname") {
      obj.hostname = NamespacedHostname.toJSON(message.destination.hostname);
    }
    if (message.destination?.$case === "address") {
      obj.address = NetworkAddress.toJSON(message.destination.address);
    }
    if (message.hbone_mtls_port !== undefined) {
      obj.hbone_mtls_port = Math.round(message.hbone_mtls_port);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GatewayAddress>, I>>(base?: I): GatewayAddress {
    return GatewayAddress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GatewayAddress>, I>>(object: I): GatewayAddress {
    const message = createBaseGatewayAddress();
    if (
      object.destination?.$case === "hostname" &&
      object.destination?.hostname !== undefined &&
      object.destination?.hostname !== null
    ) {
      message.destination = {
        $case: "hostname",
        hostname: NamespacedHostname.fromPartial(object.destination.hostname),
      };
    }
    if (
      object.destination?.$case === "address" &&
      object.destination?.address !== undefined &&
      object.destination?.address !== null
    ) {
      message.destination = { $case: "address", address: NetworkAddress.fromPartial(object.destination.address) };
    }
    message.hbone_mtls_port = object.hbone_mtls_port ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(GatewayAddress.$type, GatewayAddress);

function createBaseNetworkAddress(): NetworkAddress {
  return { $type: "istio.workload.NetworkAddress" };
}

export const NetworkAddress: MessageFns<NetworkAddress, "istio.workload.NetworkAddress"> = {
  $type: "istio.workload.NetworkAddress" as const,

  encode(message: NetworkAddress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== undefined && message.network !== "") {
      writer.uint32(10).string(message.network);
    }
    if (message.address !== undefined && message.address.length !== 0) {
      writer.uint32(18).bytes(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkAddress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.network = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkAddress {
    return {
      $type: NetworkAddress.$type,
      network: isSet(object.network) ? globalThis.String(object.network) : undefined,
      address: isSet(object.address) ? bytesFromBase64(object.address) : undefined,
    };
  },

  toJSON(message: NetworkAddress): unknown {
    const obj: any = {};
    if (message.network !== undefined) {
      obj.network = message.network;
    }
    if (message.address !== undefined) {
      obj.address = base64FromBytes(message.address);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NetworkAddress>, I>>(base?: I): NetworkAddress {
    return NetworkAddress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NetworkAddress>, I>>(object: I): NetworkAddress {
    const message = createBaseNetworkAddress();
    message.network = object.network ?? undefined;
    message.address = object.address ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(NetworkAddress.$type, NetworkAddress);

function createBaseNamespacedHostname(): NamespacedHostname {
  return { $type: "istio.workload.NamespacedHostname" };
}

export const NamespacedHostname: MessageFns<NamespacedHostname, "istio.workload.NamespacedHostname"> = {
  $type: "istio.workload.NamespacedHostname" as const,

  encode(message: NamespacedHostname, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.namespace !== undefined && message.namespace !== "") {
      writer.uint32(10).string(message.namespace);
    }
    if (message.hostname !== undefined && message.hostname !== "") {
      writer.uint32(18).string(message.hostname);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NamespacedHostname {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNamespacedHostname();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.hostname = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NamespacedHostname {
    return {
      $type: NamespacedHostname.$type,
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : undefined,
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : undefined,
    };
  },

  toJSON(message: NamespacedHostname): unknown {
    const obj: any = {};
    if (message.namespace !== undefined) {
      obj.namespace = message.namespace;
    }
    if (message.hostname !== undefined) {
      obj.hostname = message.hostname;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NamespacedHostname>, I>>(base?: I): NamespacedHostname {
    return NamespacedHostname.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NamespacedHostname>, I>>(object: I): NamespacedHostname {
    const message = createBaseNamespacedHostname();
    message.namespace = object.namespace ?? undefined;
    message.hostname = object.hostname ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(NamespacedHostname.$type, NamespacedHostname);

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
